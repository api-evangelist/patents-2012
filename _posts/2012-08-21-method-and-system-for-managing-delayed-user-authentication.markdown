---

title: Method and system for managing delayed user authentication
abstract: A system and methods for coordinating the operation of a client security module and a host security module on a mobile electronic device. The modules communicate with each other through a platform abstraction layer using application programming interfaces to coordinate their activities. In particular, on start-up of the device, the host security module obtains user authorization input from a user and passes the input to a client operating system for validation. Once validated, the host security module unlocks the host-side of the device. At the same time, the client operating system sends a notice or request to the client-side virtual machine requesting that the client-side be unlocked. Once the virtual machine is initialized and available it launches the client security module and unlocks the client-side. During the delay while the virtual machine loads, the user is given access only to the host applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08489890&OS=08489890&RS=08489890
owner: Research In Motion Limited
number: 08489890
owner_city: Waterloo
owner_country: CA
publication_date: 20120821
---
The present application is a continuation of U.S. patent application Ser. No. 12 843 924 filed Jul. 27 2010 now U.S. Pat. No. 8 250 371 which is a continuation of U.S. patent application Ser. No. 11 302 154 filed Dec. 14 2005 now U.S. Pat. No. 7 784 088 which is a continuation in part of U.S. patent application Ser. No. 10 984 822 filed Nov. 10 2004 now U.S. Pat. No. 7 996 908 which claims priority to U.S. provisional patent application Ser. No. 60 592 141 filed Jul. 30 2004. The present application is also a continuation in part of U.S. patent application Ser. No. 13 175 925 filed Jul. 4 2011 which claims priority to U.S. provisional patent application Ser. No. 60 592 141 filed Jul. 30 2004 and is a continuation of U.S. patent application Ser. No. 10 984 822 filed Nov. 10 2004 now U.S. Pat. No. 7 996 908. The contents of all the foregoing applications are incorporated by reference in the detailed description hereof.

The present application relates to a client application operating upon a third party host device and in particular coordinating the operations of a client security module and a host security module.

Successful client applications providing a particular functionality are often desirable additions to third party devices directed to related but different functions. For example mobile telephones which typically provide voice call capability and text messaging functions may find it advantageous to incorporate a client application provided by another entity that enables the mobile phone to be used for wireless data communication. In one example the client application may enable e mail communications using the mobile phone.

Placing an existing client application on a mobile phone having its own architecture and operating platform may result in conflicts between specific modules within the client application and certain modules operating within the mobile phone host system. For example the client application may include a security module for implementing a set of client security policies. The mobile phone may feature its own host security module for implementing its security features. The security features implemented by the host security module for the mobile phone may differ or conflict with the security policies implemented by the client security module. Accordingly there is a need to ensure that the client security module and the host security module coordinate their security activities to maintain an adequate level of data security.

The present application describes a system and methods for coordinating the operation of a client security module and a host security module. The modules communicate with each other through a platform abstraction layer using application programming interfaces to coordinate their activities. In particular the client security module instructs the host security module when to unlock the device and the host security module alerts the client security module to attempts to lock or unlock the device.

In one aspect the present application provides a method for coordinating a client security module with a host security module wherein both modules are resident on a mobile electronic device. The method includes the steps of detecting a lock event implementing a first lock operation by one of the client security module and the host security module sending a lock command from the one of the client security module and the host security module to the other of the client security module and the host security module and initiating a lock operation at the other of the client security module and the host security module in response to the lock command.

In another aspect the present application provides a method for coordinating a client security module with a host security module wherein both modules are resident on a mobile electronic device. The method includes the steps of receiving a user security input validating the received user security input performing a first unlock operation by one of the client security module and the host security module sending an unlock command from the one of the client security module and the host security module to the other of the client security module and the host security module and initiating a second unlock operation at the other of the client security module and the host security module in response to the unlock command.

In yet another aspect the present application provides a mobile electronic device. The device includes a host operating system and a host security module wherein the host operating system and the host security module are resident on a host side of the device. The device also includes a client application the client application including a client security module wherein the client application is resident on a client side of the device. An abstraction interface layer is provided between the client side and the host side the abstraction layer including a plurality of application programming interfaces for exchanging communications between the client security module and the host security module.

In a further aspect the present application provides a method for unlocking a mobile electronic device. The device has a host operating system and a client operating system layer. The host operating system runs a host security module and the device includes a virtual machine running on the client operating system layer. The device includes memory storing protected client data. The host operating system supports at least one host application. The method is initiated on start up of the device which triggers the launch of the virtual machine. The method includes the steps of after the initiation of start up and before completion of the launch of the virtual machine the host security module receiving user authentication input and passing the user authentication input from the host security module to the client operating system layer with a validation request. The client operating system layer authenticates the user authentication input and notifies the host security module of a successful authentication. The host security module unlocks access to the at least one host application thereby enabling user access to the at least one host application and the client operating system layer sends a message to the virtual machine regarding the authenticated user input. On completion of the launch of the virtual machine the method includes the step of the virtual machine unlocking the protected client data in response to the message thereby enabling user access to the protected client data.

In yet a further aspect the present application provides a mobile electronic device. The device includes memory storing protected client data and a host operating system supporting at least one host application. It also includes a host security module wherein the host operating system and the host security module are resident on a host side of the device and wherein the host security module includes a component for receiving user authorization input from a user after initiation of start up of the device. The device includes a client entity including a client operating system layer and a virtual machine wherein the client entity is resident on a client side of the device and wherein the client operating system layer includes a password validator for authenticating the user authorization input and wherein the start up of the device triggers the launch of the virtual machine. The device also includes an abstraction interface layer between the client side and the host side. The abstraction layer includes a plurality of application programming interfaces APIs for exchanging communications between the client operating system layer and the host security module and the APIs include a validation request callable by the host security module for passing the user authentication input to the client operating system layer. The client operating system layer includes a component for notifying the host security module of a successful authentication. The host security module has a host unlocking component for unlocking access to the at least one host application prior to completion of the launch of the virtual machine in response to the notification of the successful authentication and the client operating system layer includes a request component for sending a message to the virtual machine regarding the successful authentication. The virtual machine includes a client unlocking component for unlocking the protected client data in response to the message after completion of the launch of the virtual machine thereby enabling user access to the protected client data.

In yet another aspect the present invention provides a computer program product comprising a computer readable medium storing computer executable instructions for unlocking a mobile electronic device. The device has a host operating system and a client operating system layer and the host operating system runs a host security module. The device includes a virtual machine running on the client operating system layer and it includes memory storing protected client data. The host operating system supports at least one host application. The computer executable instructions implement an unlocking process initiated on start up of the device which triggers the launch of the virtual machine. The computer executable instructions include computer executable instructions for execution after the initiation of start up and before completion of the launch of the virtual machine that include instructions for receiving user authentication input and passing the user authentication input from the host security module to the client operating system layer with a validation request instructions for authenticating the user authentication input at the client operating system layer and notifying the host security module of a successful authentication instructions for unlocking access to the at least one host application thereby enabling user access to the at least one host application and instructions for sending a message from the client operating system layer to the virtual machine regarding the authenticated user input. The computer executable instructions also include computer executable instructions for execution on completion of the launch of the virtual machine including instructions for unlocking the protected client data in response to the message thereby enabling user access to the protected client data.

Other aspects and features of the present application will be apparent to one of ordinary skill in the art in light of the following detailed description and drawings depicting one or more embodiments.

Referring first to there is a block diagram of a communication system and mobile electronic device to which example embodiments of the present application may be applied. The communication system includes mobile electronic devices only one of which is shown in a wireless network for communicating with the mobile electronic devices and a wireless network gateway for interfacing the wireless network with a Wide Area Network WAN .

In the embodiment of the mobile electronic device is a hand held two way mobile communication device having at least data and possibly also voice communication capabilities. In an example embodiment the device has the capability to communicate with other computer systems on the Internet. In various embodiments mobile electronic devices includes data communication devices multiple mode communication devices configured for both data and voice communication mobile telephones mobile communication devices PDAs enabled for wireless communications 1 way or 2 way pagers wireless modems operating in conjunction with computer systems and any type of mobile wireless communication devices. In the presently described embodiment each of the mobile electronic devices is configured to operate within the wireless network . It should be appreciated however that the present application is in no way limited to these example types of devices and may be implemented in other devices. Example embodiments may also be applied to non wireless enabled devices.

The device includes a communication subsystem including a receiver a transmitter and associated components such as one or more preferably embedded or internal antenna elements and a processing module such as a digital signal processor DSP . In some embodiments the communication subsystem includes local oscillator s LO . As will be apparent to those skilled in the field of communications the particular design of the communication subsystem will be dependent upon the communication network in which the device is intended to operate.

Signals received by the antenna through a wireless communication network are input to the receiver which may perform such common receiver functions as signal amplification frequency down conversion filtering channel selection and the like and in some embodiments analog to digital conversion. In a similar manner signals to be transmitted are processed including modulation and encoding for example by the DSP and input to the transmitter for digital to analog conversion frequency up conversion filtering amplification and transmission over the communications network via the antenna.

The device includes a microprocessor that controls the overall operation of the device. The microprocessor interacts with communications subsystem and also interacts with further device subsystems such as the display flash memory random access memory RAM auxiliary input output I O subsystems which may include a thumb wheel for example serial port keyboard or keypad speaker microphone a short range communications subsystem and any other device subsystems generally designated as .

Some of the subsystems shown in perform communication related functions whereas other subsystems may provide resident or on device functions. Notably some subsystems such as keyboard and display for example may be used for both communication related functions such as entering a text message for transmission over a communication network and device resident functions such as a calculator or task list.

Host operating system software and various host software applications used by the microprocessor are in one example embodiment stored in a persistent store such as flash memory or similar storage element. Host software applications may include a wide range of applications including a text messaging application a ring tone application a contacts application and or a game application. Those skilled in the art will appreciate that the host operating system specific host applications or parts thereof may be temporarily loaded into a volatile store such as RAM . It is contemplated that received communication signals may also be stored to RAM .

The microprocessor in addition to its operating system functions enables execution of host software applications on the device. A predetermined set of host applications which control basic device operations including at least voice communication applications for example will normally be installed on the device during manufacture. Further applications may also be loaded onto the device through the network an auxiliary I O subsystem serial port short range communications subsystem or any other suitable subsystem and installed by a user in the RAM or a non volatile store for execution by the microprocessor . Such flexibility in application installation increases the functionality of the device and may provide enhanced on device functions communication related functions or both.

In a communication mode a received signal such as a voice call a text message or web page download will be processed by the communication subsystem and input to the microprocessor which will preferably further process the received signal for output to the speaker or the display or alternatively to an auxiliary I O device . A user of device may also compose data items such as text messages for example using the keyboard in conjunction with the display and possibly an auxiliary I O device . Such composed items may then be transmitted over a communication network through the communication subsystem .

The serial port in would normally be implemented in a personal digital assistant PDA type communication device for which synchronization with a user s desktop computer not shown may be desirable but is an optional device component. Such a port would enable a user to set preferences through an external device or software application and would extend the capabilities of the device by providing for information or software downloads including user interface information to the device other than through a wireless communication network.

A short range communications subsystem is a further component which may provide for communication between the device and different systems or devices which need not necessarily be similar devices. For example the subsystem may include an infrared device and associated circuits and components or a Bluetooth communication module to provide for communication with similarly enabled systems and devices.

Wireless mobile network is in an example embodiment a wireless packet data network e.g. Mobitex or DataTAC which provides radio coverage to mobile electronic devices although it could be any other types of wireless networks. Wireless mobile network may also be a voice and data network such as GSM Global System for Mobile Communication and GPRS General Packet Radio System CDMA Code Division Multiple Access or various other third generation networks such as EDGE Enhanced Data rates for GSM Evolution or UMTS Universal Mobile Telecommunications Systems .

The device includes a host security module . The host security module may be one of the host software applications resident on the device . The host security module implements security measures in accordance with the security policies of the device . For example the host security module may monitor idle time of the device and display a security screen i.e. screen saver if an idle threshold time is exceeded. In some embodiments the host security module may permit a user to lock the keyboard or keypad . Those of ordinary skill in the art will appreciate that other security or locking features may be implemented by the host security module . It will be appreciated by those of ordinary skill in the art that the host security module while depicted as a distinct entity in may be spread across multiple entities. For example the host security module may comprise a module for monitoring idle time a module for displaying a security screen for blocking device access and a module for locking the keypad. In various embodiments these or other modules may be stand alone modules may be implemented within the host operating system or may implemented within one or more of the host software applications . It will be appreciated that references herein to the host security module are intended to encompass all of these variations and alternatives.

In addition to the host applications resident on the device a client entity is included with the device . The client entity may be for example a wireless data communication entity. The wireless data communication entity may for example enable the receipt and transmission of electronic messages. In one embodiment the wireless data communication entity may provide for electronic messaging i.e. E mail that is synchronised and co ordinated with a remote electronic messaging server wherein the remote electronic messaging server is coupled to the WAN at a remote location. Electronic messaging functions provided by the wireless data communication entity may include composing messages saving messages and displaying messages. Other functions or features may include a contacts list or directory a calendar application a task list application a web browser and other modules or applications. The client entity is a self contained stand alone entity that may have been designed to operate upon a specific native device as will be described in greater detail below.

The client entity is typically created and developed by a separate provider than the remainder of the mobile electronic device . The client entity is also typically associated with a native environment or device in association with which it was originally developed. Accordingly the client entity includes the functions and features associated with its operation on its native device but packaged as a stand alone software entity designed to run on top of a third party platform in a third party device. To enable the client entity to interact and exchange messages and events with the host operating system and or the host security module and other host applications the device may further include an abstraction layer . The abstraction layer contains or defines a set of application programming interfaces APIs that may be used by the client entity or by the host operating system and or host security module and or the host applications to exchange instructions messages or events between the host side of the device and the client entity .

Although the set of APIs is depicted in as being contained in the abstraction layer those of ordinary skill in the art will appreciate that the APIs that make up the abstraction layer need not be collected and contained within a single library or file. It will also be appreciated that the term application programming interface in this context is intended to encompass a wide range of inter process communications taking many forms. For example in one embodiment the APIs may comprise defined functions that are called by a process. In another embodiment the APIs may comprise the posting of messages from one process to another process. Those of ordinary skill in the art will appreciate the range of possible interfaces that may be employed for inter process communication. References herein to calling an API are not intended to limit the scope of the operation to calling a predefined function but instead are intended to encompass all possible forms of interfacing.

Reference is now made to which diagrammatically shows software architecture for a mobile electronic device such as the device shown in . As shown in the client entity the host security module and the host applications operate on top of the host operating system layer.

The client entity includes a client operating system layer . The client operating system layer may under some definitions not be considered an operating system per se but instead may be referred to as an I O management layer or a platform. The client operating system layer manages certain basic functions for the client entity including file structure and I O. The client operating system layer provides an independent platform upon which client specific applications can run.

On top of the client operating system layer the client entity may include a virtual machine within which various client applications operate. In one embodiment the virtual machine is a Java virtual machine. The client applications may include applications for facilitating wireless communication functions such as electronic messaging. In one embodiment one of the client applications includes an e mail application program that allows the user to receive read compose and send e mail messages. In some embodiments the client entity may operate the e mail application program as a part of a push service that relays e mail messages from an enterprise server at a remote location to the device so as to provide the user with real time e mail mobility. Other client applications may include instant messaging application programs contacts programs web based browser programs and others.

The virtual machine may also include a client security module for managing the security features of the client entity . For example the client security module may implement a password lock out function whereby the client entity and related data are inaccessible to a user without entering a valid password. In another embodiment the client security module may implement a keypad locking system requiring a certain keystroke sequence or key combination to unlock the keypad or keyboard. The client security module may include a user interface for receiving a user password i.e. in some situations the client security module may display popup dialogs accept password input and control when the dialog popup is removed from the display.

The system software architecture further includes the platform abstraction layer . The platform abstraction layer may be notionally divided into a host side platform abstraction layer and a client side platform abstraction layer . The platform abstraction layer enables the communication of messages and events back and forth between the client entity and the host operating system and or the host security module and or the host applications . The platform abstraction layer may be implemented through use of one or more APIs. The platform abstraction layer allows the client entity to operate on a platform independent basis from the host operating system the host applications and the host security module .

The client security module typically implements a set of security features to protect the user data and other data associated with the client entity shown in as client data . For example the client security module may encrypt or decrypt the client data when the device is locked or unlocked respectively. In its native environment the client security module may maintain a certain level of security with regard to the client entity that differs from the security normally associated with the device as provided by the host security module . The host security module may implement security features that are inadequate for the level of security wanted by the client entity . Because some client data associated with the client entity may be mirrored or copied to storage on the host side of the device some coordination between the security modules may be needed to ensure adequate security protection for the client data . In particular the client security module and the host security module coordinate their activities so as to lock and unlock the device in accordance with the same security policies.

It will be appreciated that certain functions of the device continue to operate in spite of the locks although the user cannot access the applications . For example where the client entity comprises a wireless data communication application the wireless data communication application may continue to communicate with a wireless network to receive and or exchange data.

Reference is now made to which shows in flowchart form a method of coordinating operation of separate security modules on a mobile device. The method is based upon a device having a client application with a client security module that implements a password protection feature. The device also has a host security module that implements a screen saver mode. It will be appreciated that the security modules may implement alternative or additional security features. For example the host security module may implement a keypad lock feature.

The method begins with the presumption that the device is in an unlocked state. At step the device determines if a client lock has been initiated by a user or a remote administrator. The client security module may allow a user to select a lock device operation for example from a menu. If the device or more particularly the client application receives a client instruction or a remote administrator instruction to perform a client lock then the method continues to step . If not then it continues at step wherein the device assesses whether it has received a host lock instruction.

The host operating system may recognize various events as constituting a host lock instruction. For example if the device is idle for a set period of time it may trigger a host lock. It will be understood by those of ordinary skill in the art that the idle timeout may need to be monitored by the host operating system rather than the client application since the client application may not always be in foreground on the device. Other applications may have control of the device processor. Accordingly the client application may not be able to monitor for idle timeout in all situations. Therefore an idle timeout may be determined by the host operating system. An idle timeout may be a host lock instruction event under step . There may be other events that are defined as host lock instructions. For example a particular user key combination may trigger a host lock. If no host lock instruction is detected in step then the method continues to await a client or host lock event.

If a host lock instruction is received in step then in step the occurrence of the lock event is communicated to the client application. In particular the host operating system communicates with the client application through the platform abstraction layer. In other words it calls an API designed to alert the client application to the receipt of a host lock event. Once this API is called then the method continues in step .

In step the client application starts the client security module. It recognizes the need to start the client security module from either the user selection of a client lock in step or the notification received as a result of the API called by the host operating system in step . Once the client security module is brought up then in step the client security module implements a client lock. At step the client security module then relays a message back down to the host operating system or the host security module to instruct them to perform their own lock operations. This step involves calling an API to trigger the host operating system to implement a host lock or to launch the host security module so as to implement a host lock. Accordingly having locked the client application in step control is now passed back to the host side of the device to perform a host lock. At step the host lock is implemented. In one embodiment the host lock comprises displaying a security screen i.e. a screen saver. In other embodiments it may include implementing a keyboard or keypad lockout as an alternative to or in addition to the security screen. Once the host security module implements the host lock the user is denied access to the host applications until the user performs a set of actions to unlock the device as described below . Typically the security screen remains in the foreground until the user performs certain actions to begin unlocking the device thereby preventing the user from accessing any host applications without satisfying the security requirements.

Following step the device is in a locked state. Having detected a lock event either on the client side or on the host side the device has been placed in a locked state by first implementing a client lock to prevent access to the client application and by then activating the host lock to prevent access to any of the host applications.

In some cases the client application may demand greater security than the host device. Accordingly it may have more robust security measures. However running the client application on top of the host operating system may expose certain areas of the client application such as for example client data stored in memory. Under some circumstances it may be possible to access information or operations despite the existence of client security measures. Accordingly the remaining steps of the method ensure that a user cannot disable the host lock without first satisfying the client unlocking procedure.

When in a locked state the device displays the security screen and the host operating system or the host security module awaits entry of a keystroke in step . In some embodiments the host security module implements a keypad or keyboard lock when the device is in a locked state. A particular key sequence such as pressing the hash key for a predetermined length of time or pressing a combination of keys may be required to unlock the keyboard. In an embodiment wherein the host security module implements a keypad lock then in step the host security system evaluates whether the received keystroke detected by the host operating system satisfies the keypad unlocking requirements. If the detected keystroke does not meet the requirements then it is ignored and the device continues to await a proper keystroke or key sequence. If the detected keystroke is the appropriate key sequence then the host security module unlocks the keypad and proceeds to step .

At step the host security module or in some embodiments the host operating system alerts the client application to the receipt of a keystroke. In particular the host security module calls an appropriate API to notify the client security module of the receipt of the keystroke. In one embodiment wherein the host security application does not implement a keypad lock the API passes the received keystroke to the client security module so that the client security module may use the received keystroke as the first character of a user entered password. Either the client security module or the API called by the host security module may evaluate whether or not the received keystroke makes sense as a password character. For example the entry of a directional key like a down arrow may be ignored by the client security module or it may cause a menu or options list to be displayed whereas the entry of a text character may be treated as the first character of a password. When the host security module or host operating system calls the API to alert the client security module to the receipt of the keystroke then control passes to the client security module.

The client security module brings a user password entry screen to the foreground on the display of the device and awaits entry of a user password. At step the client security module may in some embodiments determine if the user has elected to cancel the password entry operation i.e. has decided to leave the device locked. Some embodiments of the client security module may recognize a particular key combination or keystroke as a cancel command. The client security module may also timeout if a password is not entered after a predetermined duration. For example if no keystrokes are received by the client security module for two minutes then it may be deemed to have timed out. Upon cancellation or time out the client security module may restore control to the host security module in step whereupon the host security module re establishes its security features such as a keypad lock and display of a screen saver. The client security module may pass control to the host security module by calling the lock command API as was called in step . The device is thus returned to a locked state and waits in step for entry of a keystroke.

If the user does not indicate a cancellation or time out then the client security module evaluates the password entered by the user in step . If the password is invalid then the client security module applies its password retry policies in step to determine whether or not the user is entitled to retry the password entry. The policies may establish a maximum number of attempts. In some embodiments as shown by step after the maximum number of attempts is reached the device is disabled through a kill device operation in which the user data stored on the device is deleted. This may also involve calling a kill API to cause the host operating system or the host security module to delete or wipe particular user data from the system. Other actions may be taken in addition to or as an alternative to the kill operation in response to a maximum number of password attempts.

If the password is valid then the method continues as step wherein the client security module unlocks the client side of the device. This may include for example decrypting client data stored in memory on the device in an encrypted format. In step the client security module then passes control to the host security module with instructions to unlock the device. It may pass control by calling a host unlock API to alert the host security module to the successful entry of a password for unlocking the device. The client security module may also close after unlocking the client side of the device. In step the host security module performs operations necessary to unlock the host side of the device such as closing or minimizing a screen saver or other actions. The host security module may then be closed in step .

Following step the device is in an unlocked state and the method returns to step to await the initiation of further lock operations.

It will be appreciated by those of ordinary skill in the art that the method may include other steps or actions to accommodate devices or security module having different features. For example the security modules may permit the user to make E911 emergency calls while the device is locked. Accordingly at around step the client security module may detect a user selection of an E911 emergency call. This may be a selectable menu action item presented to the user on the client password entry interface screen. When the user selects an E911 emergency call the client security module may call an E911 API to instruct the host operating system or other host applications to place the emergency call despite the locked state of the device.

It will also be appreciated that the user or another entity such as a client administrator may elect to change the idle timeout value or other relevant configuration values or options. If the timeout value is changed for example by the user through a menu option presented by the client application then the client application calls an idle timeout change API to instruct the host operating system to update the idle timeout value since this value is monitored by the host operating system. The current idle timeout value may be communicated to the host operating system by the client application upon start up of the device through the call of the same or a similar API.

Other variations to the method will be understood by those of ordinary skill in the art in view of the foregoing description.

In one embodiment the unlocking operation on start up may differ from the unlocking operation described in the method shown in . When powering on a mobile device it may power up in a locked state. The start up or power on process may in some embodiments take an unacceptable length of time. In particular it may take an unacceptable length of time for the Java Virtual Machine to load and for the client security module to be started. Until the JVM and the client security module are started the user cannot enter a password to enable the device. The result is that the user is unable to use the mobile device even for host applications such as mobile telephony until the client applications are loaded and available.

The client security module typically performs password verification by calling a validation function. The password information is stored in persistent storage on the device and the validation function is designed to compare user input information with the stored password information. The validation function does not depend on initialization of the client security module to be accessible. Accordingly in one embodiment an API is provided in the platform abstraction layer to enable the host side to call the validation function.

To address the delay on start up in one embodiment the host includes a host start up module that essentially mirrors the dialog of the client security module in requesting an unlock password. Accordingly on start up the host start up module displays a user input dialog screen to prompt the user to enter a valid password. Once the user enters a password the host calls the client side validation function through the platform abstraction layer and passes it the entered password. The validation function determines whether or not the password is valid and returns an answer to the host start up module. If the password is valid then the host start up module notifies the host security module and the host side is unlocked. In some embodiments the client side is not locked on start up so the full range of device applications is available once the host side is unlocked. In another embodiment the client side is locked on start up so either the validation function or the host start up module notify the client security module that a valid password has been entered so that the client side is also unlocked once the client side applications have been initialized. It will be understood that the host start up module may comprise a part of the host security module. The client security module may be configured to suppress its password dialog screen on start up on the assumption that password input will be handled by the host side in this situation.

Reference is now made to which shows in flowchart form a method for unlocking a mobile device on start up. The method begins in step with the start up or powering on of the device. In the present embodiment the device powers on with a host lock in place meaning that the user cannot access the host or client applications.

On start up the host launches the host start up module which may comprise a portion of the host security module to display a password dialog to solicit user password input as shown in step . The device awaits user input in this state. In one embodiment the device may have a cancel option or may timeout while waiting for user input as shown in step . If so then the host security module may display a security screen in step and await a keystroke in step before re displaying the password dialog to solicit user password input.

If a password is received then in step the device evaluates whether it is a valid password. In particular the host start up module or host security module calls the validation function through an API provided via the platform abstraction layer and passes the received passwords. A result is returned indicating whether or not the entered password is valid. If it is not valid then in step the host start up module assesses whether the user should be permitted to retry. As outlined above there may be a predefined maximum number of attempts permitted. If the maximum number is exceeded then certain kill device operations may be implemented in step .

If the password is valid then in step the host side of the device is unlocked. As noted above in many embodiments the client side will not be locked on start up meaning that only the host side must be unlocked. If the client side is locked on start up then the method includes a further step not shown in which the host start up module or host security module calls a client unlock API to instruct the client security module to unlock the client side of the device.

Reference is again made to . The client operating system layer is shown to include a data encryption component and a password validator . As discussed above in connection with the password validator may validate or authenticate an input password by comparing the input password with stored password data. The password validator may return a success or failure indicator. As described above the host security module or host start up module may call the password validator through an API provided by the platform abstraction layer and may pass the password validator user authorization input received through a dialog box.

The data encryption component provides for the encryption and decryption of the client data . The data encryption component operates under the control of the client security module . When the client security module determines that the device should be unlocked then the client security module instructs the data encryption component to decrypt the client data . Similarly when the client security module determines that the device should be locked then it instructs the data encryption component to encrypt the client data .

In one embodiment the client data is encrypted and decrypted using the user password. The user password may be an encryption key or a seed value for obtaining an encryption key. The various types of possible encryption engines and techniques will be familiar to those ordinarily skilled in the art. In such an embodiment to perform decryption of client data the client security module invokes the data encryption component while passing it the validated user password that was input through a dialog box.

As noted above on start up of the device the virtual machine may take a significant period of time to become operational. In some embodiments the host side of the device may be available in a matter of seconds whereas the virtual machine may take a number of minutes to complete initialization and be available to respond to unlock requests. As a result a user may be required to wait for an unacceptably long delay before the device is available.

To address this concern in one embodiment the host side of the device provides the user with partial functionality i.e. only the host applications until the client side is operational at which point the full functionality of the device is made available to the user. Reference is now made to which shows a further embodiment of a method for unlocking a mobile device on start up.

The method begins in step with the powering on of the device. In step the host operating system has launched the host security module or host start up module and it provides the user with a dialog box for receiving user authentication input such as a password. Once the user inputs a password then in step the host security module or start up module passes the user input to the client operating system. In particular the host security module requests validation of the user input by calling a password validation function through a designated API. Through the API the host security module passes the user input to the client operating system where the password validator evaluates whether the user input corresponds to stored user authentication data. For example the password validator may compare the user input to a stored user password. The password validator indicates whether the password has been validated. A success or failure indicator may be returned to the host security module or start up module in response to the API call as shown in step . If the password is invalid then the method returns to step to allow the user to re attempt the password input through the displayed dialog box. If the password is validated then the method continues at step .

At step the host security module unlocks the host side of the device. In other words it provides the user with access to the host applications. This may include in one embodiment cellular telephone functions and related actions.

In step the client operating system may store the user authentication input that was sent by the host security module for validation. This may include writing the user input to a memory location or register or storing the information in an object or other data item. In some embodiments the validated user authentication input is already stored in a pre established memory location so no further act of storage is required at this step. In some embodiments the user authentication input is not required by the client security module to unlock the device so it may not be retained.

In step the client operating system may notify the virtual machine of the validated unlock request received from the host security module. The client operating system does not await a response to the notification or request sent by the client operating system to the virtual machine since the virtual machine is likely too busy to respond to the request. The notice or request may remain pending while the virtual machine completes its initialization. The notice or request may be sent by the password validator or may be triggered as a part of the API called by the host security module to verify the user input. In one embodiment the notice or request may be sent by the host security module once it receives confirmation that the password has been validated. In one embodiment the notice or request may include the user authentication input especially if it was not stored to memory in step .

While the virtual machine is busy the host applications on the host side of the device are available to the user. Accordingly any user requests to access functionality specific to the host side of the device are permitted. As shown in steps and any user requests to access data or applications on the client side of the device are denied. The client data remains encrypted at this stage and the client applications are not accessible to the user. In some embodiments the user interface provided upon the display of the device may be limited to host applications. In other words the icons menus or other mechanisms by which the user can select or trigger applications or operations may be limited to host side applications or operations. Client related icons or menu items may be made unavailable to the user at this stage.

Once the virtual machine is fully launched then in step it recognizes the notice or request to unlock the client side that was pending and the virtual machine launches the client security module. The launch of the client security module may be triggered by the pending request i.e. the request may be an unlock request that causes launch of the client security module. In step the client security module obtains the stored user authentication input if necessary . In some embodiments the client security module may clear the memory of the stored user authentication input at the same time so that it may not be read or used again without having the user re enter the authentication input.

In some embodiments it may not be necessary to obtain the stored authentication data because for example the user authentication input was contained in the notice or request that triggered launch of the client security module and is therefore already available or in another embodiment the client security module may not need the user authentication input to unlock the device.

In step the client security module unlocks the client side of the device by for example decrypting the client data. In one embodiment as described above the client data may be encrypted and decrypted using the user authentication input as part of the encoding scheme. In this embodiment the client security module may require the validated user authentication input to unlock the device.

In one embodiment the encryption or decryption functions are performed by an encryption decryption engine or component within the client operating system. To perform decryption of the client data the client security module may call or invoke this engine or component and pass it the user authentication input for user in decrypting the client data.

When the unlocking procedure is complete the client security module may notify the host security module as shown in step . The full functionality of the device is now available to the user including access to the client data and client applications. In one embodiment this may be manifested by the display of corresponding icons or menu items.

The above described embodiments of the present application are intended to be examples only. Alterations modifications and variations may be effected to the particular embodiments by those skilled in the art without departing from the scope of the application which is defined by the claims appended hereto.

