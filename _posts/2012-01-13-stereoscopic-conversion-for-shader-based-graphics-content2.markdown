---

title: Stereoscopic conversion for shader based graphics content
abstract: The example techniques of this disclosure are directed to generating a stereoscopic view from an application designed to generate a mono view. For example, the techniques may modify source code of a vertex shader to cause the modified vertex shader, when executed, to generate graphics content for the images of the stereoscopic view. As another example, the techniques may modify a command that defines a viewport for the mono view to commands that define the viewports for the images of the stereoscopic view.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09578299&OS=09578299&RS=09578299
owner: QUALCOMM Incorporated
number: 09578299
owner_city: San Diego
owner_country: US
publication_date: 20120113
---
This application claims the benefit of U.S. Provisional Application No. 61 452 289 filed Mar. 14 2011 and U.S. Provisional Application No. 61 474 638 filed Apr. 12 2011 the contents of each is hereby incorporated by reference in its respective entirety.

This disclosure relates to graphics data processing and more particularly to graphics data processing for stereoscopic view.

Stereoscopic view refers to a perceived image that appears to encompass a 3 dimensional 3D volume. To generate the stereoscopic view a device displays two images on a 2 dimensional 2D area of a display. These two images include substantially similar content but with slight displacement along the horizontal axis of one or more corresponding pixels in the two images. The simultaneous viewing of these two images on a 2D area causes a viewer to perceive an image that is popped out of or pushed into the 2D display that is displaying the two images. In this way although the two images are displayed on the 2D area of the display the viewer perceives an image that appears to encompass the 3D volume.

The two images of the stereoscopic view are referred to as a left eye image and a right eye image respectively. The left eye image is viewable by the left eye of the viewer and the right eye image is not viewable by the left eye of the viewer. Similarly the right eye image is viewable by the right eye of the viewer and the left eye image is not viewable by the right eye of the viewer. For example the viewer may wear specialized glasses where the left lens of the glasses blocks the right eye image and passes the left eye image and the right lens of the glasses blocks the left eye image and passes the right eye image.

Because the left eye and right eye images include substantially similar content with slight displacement along the horizontal axis but are not simultaneously viewable by both eyes of the viewer e.g. because of the specialized glasses the brain of the viewer resolves the slight displacement between corresponding pixels by commingles the two images. The commingling causes the viewer to perceive the two images as an image with 3D volume.

In general the techniques of this disclosure are directed to modifying instructions that generate a mono view to generate a stereoscopic view. For example a shader program of a graphics processing unit GPU may be designed to generate a mono view. The techniques described in this disclosure may modify the instructions of such a shader program. For instance the example techniques may add instructions that modify values generated by the shader programs. The techniques may also modify instructions issued by an application to cause a GPU to generate images for stereoscopic view instead of mono view. For example the techniques described in this disclosure may modify commands that define a viewport. A viewport may define the size and location of the image on the display. For example prior to modification a command may define a viewport for a mono view. The example techniques may modify the command that define a viewport for a mono view to define a viewport for each of the images of the stereoscopic view.

In one example this disclosure describes a method that includes receiving with a processor instructions for a vertex shader that is configured to generate an image of a mono view and that is to be executed on a shader processor of a graphics processing unit GPU . The method also includes modifying with the processor the instructions of the vertex shader to include one or more instructions that cause the vertex shader when executed on the shader processor of the GPU to generate graphics content for a first image of a stereoscopic view after a first execution of the vertex shader and graphics content for a second image of the stereoscopic view after a second execution of the vertex shader. The method further includes modifying with the processor a command that defines a viewport for the image of the mono view to a first command for a fixed function unit of the GPU that is different from the shader processor that defines a viewport for the first image and a second command for the fixed function unit of the GPU that defines a viewport for the second image.

In another example this disclosure describes an apparatus that includes a graphics processing unit GPU that includes a shader processor and a fixed function unit different from the shader processor of a fixed function pipeline and a processor. The processor is operable to receive instructions for a vertex shader that is configured to generate an image of a mono view and that is to be executed on the shader processor of GPU. The processor is also operable to modify the instructions of the vertex shader to include one or more instructions that cause the vertex shader when executed on the shader processor of the GPU to generate graphics content for a first image of a stereoscopic view after a first execution of the vertex shader and graphics content for a second image of the stereoscopic view after a second execution of the vertex shader. The processor is further operable to modify a command that defines a viewport for the image of the mono view to a first command for the fixed function unit of the GPU that is different from the shader processor that defines a viewport for the first image and a second command for the fixed function unit of the GPU that defines a viewport for the second image.

In another example this disclosure describes an apparatus that includes a graphics processing unit GPU that includes a shader processor and a fixed function unit different from the shader processor of a fixed function pipeline and a processor. The processor includes means for receiving instructions for a vertex shader that is configured to generate an image of a mono view and that is to be executed on the shader processor of the GPU. The processor also includes means for modifying the instructions of the vertex shader to include one or more instructions that cause the vertex shader when executed on the shader processor of the GPU to generate graphics content for a first image of a stereoscopic view after a first execution of the vertex shader and graphics content for a second image of the stereoscopic view after a second execution of the vertex shader. The processor further includes means for modifying a command that defines a viewport for the image of the mono view to a first command for a fixed function unit of the GPU that is different from the shader processor that defines a viewport for the first image and a second command for the fixed function unit of the GPU that defines a viewport for the second image.

In another example this disclosure describes a non transitory computer readable storage medium comprising instructions. The instructions when executed cause one or more processors to receive instructions for a vertex shader that is configured to generate an image of a mono view and that is to be executed on a shader processor of a graphics processing unit GPU . The instructions also cause the one or more processors to modify the instructions of the vertex shader to include one or more instructions that cause the vertex shader when executed on the shader processor of the GPU to generate graphics content for a first image of a stereoscopic view after a first execution of the vertex shader and graphics content for a second image of the stereoscopic view after a second execution of the vertex shader. The instructions also cause the one or more processors to modify a command that defines a viewport for the image of the mono view to a first command for a fixed function unit of the GPU that is different from the shader processor that defines a viewport for the first image and a second command for the fixed function unit of the GPU that defines a viewport for the second image.

The details of one or more aspects of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

The example techniques described in this disclosure are directed to rendering stereoscopic 3 dimensional S3D graphics during execution or run time. In conventional 3D graphics rendering a graphics processing unit GPU generates 3D graphics from a single point of view e.g. mono view . This single point of view may mean a single image that is viewable by both the right eye and left eye of a viewer.

S3D graphics differs from 3D graphics in that S3D graphics generate stereoscopic view. The term stereoscopic view refers to images that are generated from a binocular point of view. In a binocular point of view there may be two images where one image is viewable by one of the eyes and not the other and vice versa. For example when a viewer wears binoculars the light that enters through the left lens for the binoculars is viewable by the left eye and not the right eye and vice versa. The binocular point of view may be referred to as stereoscopic view.

For example in S3D graphics the GPU may generate an image for the left eye and another image for the right eye i.e. a stereoscopic view. The term stereoscopic view refers to two images e.g. left eye image and right eye image that are each displayed on the display whereas mono view refers to a single image that is displayed on the display. The combination of the left eye image and the right eye image may appear to a viewer as if the image is popping out of or pushing into the display that is displaying the images. This may result in a more realistic and richer viewing experience.

In this disclosure the concept of an S3D image e.g. stereoscopic view and a 3D image e.g. mono view should not be confused. A 3D image is an image that is constrained to a 2 dimensional 2D area of a display. For instance objects within a 3D image may appear further away or closer than other objects within the 3D image. However all of these objects are limited to the 2D area of the display. An S3D image is a perceived image resulting from a brain of a viewer combining the right eye and left eye images. The resulting image i.e. the S3D image appears to not be constrained to the 2D area of the display. Rather the S3D image appears to encompass a 3D volume where the image appears to pop out of or push into the display. For instance objects within the S3D image appear further away or closer than other objects within a 3D volume and not a 2D area as is the case with 3D images.

The right eye and left eye images that together form the S3D image may be 3D images. It is the brain of the viewer that causes the viewer to perceive the S3D image when the brain combines the 3D right eye image and the 3D left eye image. The content of the right eye image and left eye images may be substantially similar to the content of the single 3D image. The techniques described in this disclosure may modify instructions that cause the GPU to generate graphics content for a mono view to instructions that cause the GPU to generate graphics content for the stereoscopic view. In other words prior to modification the instructions may cause the GPU to generate a single 3D image. Subsequent to modification the instructions may cause the GPU to generate two 3D images e.g. the 3D left eye image and the 3D right eye image .

It should be noted that although the techniques described in this disclosure are generally disclosed for 3D images aspects of this disclosure are not so limited. The techniques of this disclosure may be extended to 2D graphics as well. For example the single image of the mono view may be a 2D image and the techniques of this disclosure may modify instructions to cause the GPU generate two 2D images for the stereoscopic view. In this case the viewer will perceive a single image that is popped out of or pushed into the display that is displaying the two images for the stereoscopic view. To avoid confusion the techniques described below refer to a single image for the mono view and left eye and right eye image for the stereoscopic view with the understanding that these images could be 3D images or 2D images.

The example techniques described in this disclosure may modify instructions issued by an application that are to be performed by the GPU and instructions of a vertex shader program that is to be executed by the GPU. For example an application processor may execute the application. The application may have been designed to generate a single image e.g. a mono view and may generate the graphics content of the single image as a plurality of primitives. In addition the application may determine pixel values such as color transparency and coordinate values for each vertex of the primitives

During execution of the application e.g. in run time the application issues a command to retrieve instructions of the vertex shader program. The output of the vertex shader program when executed may be clipping coordinates for the vertices of primitives generated by the application for the single image e.g. mono view . The example techniques may modify the instructions of the vertex shader program to generate clipping coordinates for the vertices of primitives for the left eye image and the right eye image e.g. stereoscopic view .

Also during execution of the application the application issues a draw instruction to the GPU to instruct the GPU to draw one or more of the primitives within the single image. For instance in the techniques of this disclosure the application executing on the application processor outputs instructions as if the GPU is going to generate graphics content for a single image. The techniques described herein modify one or more of the instructions issued by the application such as the draw instruction to generate graphics content for the left eye and right eye images. In this way there is no modification to the instructions from the perspective of the application.

For instance the techniques described in this disclosure monitor the instructions issued by the application. When the application issues a draw instruction the techniques capture such a draw instruction and issue two draw instructions where one instruction is to generate graphic content for the left eye image and one instruction is to generate graphics content for the right eye image.

In addition the techniques modify the viewport instruction issued by the application. For example the application issues a viewport instruction that defines the viewport of the single image. The viewport defines the size and location of the image on the display. For example the viewport may define the starting coordinates of the image and the width and length of the image. The width and length of the image may be values that indicate a horizontal distance and a vertical distance encompassed by the image. The width and length need not necessarily be coordinate values rather the width and length define a distance starting from the starting coordinates of the image. The application may provide the definition of the viewport for the single image to the GPU.

The techniques of this disclosure modify the viewport instruction to generate viewport instructions for the left eye image and the right eye image that define the size and the location of each of the left eye and right eye images on the display. In this way the modified viewport instruction may constrain the left eye image to one portion of the display and the right eye image to the other portion of the display. In some examples the modified viewport instruction may constrain the left eye image to the left half of the display and the right eye image to the right half of the display. However aspects of this disclosure are not so limited and the modified viewport instruction may constrain the left eye image to the top half of the display and the right eye image to the bottom half of the display as another non limiting example. In some instances the example techniques may further modify the viewports for the right eye image and the left eye image to potentially provide a better viewing experience. For example the techniques may shift or stretch the viewports for the right eye image and the left eye image.

The instructions that modify the viewport may not be part of the instructions that modify the shader program. For example the GPU may include a shader processor sometime referred to as a shader core and one or more fixed function units. The vertex shader program may execute on the shader processor and the application of the viewport to constrain the image to the defined viewport may be performed by at least one of the fixed function units e.g. a viewport transformation unit of the fixed function units . In the example techniques the shader processor may execute the modified shader program to generate graphics content for the stereoscopic view and the at least one fixed function unit may apply the defined viewport for each of the left eye and right eye images to constrain these images to respective halves of the display. In other words the viewport modification may occur external to the execution of the modified shader program.

Application processor may be the central processing unit CPU of device . GPU may be a processing unit operable to output graphics data for presentation on a display. Examples of application processor and GPU include but are not limited to a digital signal processor DSP a general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry.

System memory may be an example of a computer readable storage medium. For example system memory may store instructions that cause application processor and GPU to perform functions ascribed to each in this disclosure. In this way system memory may be considered as a computer readable storage medium comprising instructions that cause one or more processors e.g. application processor or GPU to perform various functions.

Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices flash memory or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer or a processor. System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable. As one example system memory may be removed from device and moved to another device. As another example a storage device substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

GPU may include shader processor and fixed function pipeline . Shader processor sometimes referred to as a shader core may be a core of GPU upon which shader programs such as vertex shaders and fragment shaders execute. Fixed function pipeline may include hardware units that perform fixed functions. In other words the shader programs such as vertex shaders and fragment shaders may be software units that execute on shader processor and allow for functional flexibility whereas fixed function pipeline include hardware units with fixed functions and minimal functional flexibility.

The example techniques described in this disclosure may modify shader programs that are designed to generate a single three dimensional 3D image e.g. for a mono view such that when the modified shader programs are executed on shader processor GPU generates graphics data for S3D images e.g. a stereoscopic view . Again as discussed above stereoscopic view includes a left eye image and a right eye image. The left eye image and the right eye image include substantially similar graphics content as the mono view image however one or more corresponding pixels of the left eye and right eye images may be displaced along the horizontal axis relative to one another. For example imagine that the right eye image is placed on top of the left eye image. In this case all of the content in the right eye image may not line up perfectly with the identical content in the left eye image. Rather one or more objects in the right eye may be to the left or to the right of the identical objects in the left eye image.

The left eye image is viewable by the left eye of the viewer and the right eye image is blocked from the left eye of the viewer. The right eye image is viewable by the right eye of the viewer and the left eye image is blocked from the right eye of the viewer. In some examples the viewer may wear specialized glasses that block the left eye image from being viewable by the right eye and the right eye image from being viewable by the left eye. However aspects of this disclosure do not necessarily require a viewer to wear specialized glasses. For example some displays do not require the viewer to wear specialized glasses to experience stereoscopic view. Techniques of this disclosure may be extended to such displays.

GPU may generate the graphics data for the left eye image and the right eye image such that when the viewer views both the left eye image and the right eye image at the same time the brain of the viewer causes the viewer to perceive an image that pops out of the display or pushes into the display displaying the two images e.g. appears to be ahead of or behind the display . This popping out or pushing in is due to the brain of the viewer resolving the horizontal discrepancies in the two images of the stereoscopic view with substantially similar content.

As an example application processor may execute one or more applications such as application stored in system memory . Examples of application include but are not limited to web browsers user interfaces e mail applications spreadsheet applications word processing applications graphics authoring applications video games or other applications that generate viewable objects for display. For instance application may be a video game that when executed outputs graphical content that is displayed on a display.

Application may be designed by a developer for mono view. For example application upon execution may generate 3D graphics content where the 3D graphics content is constrained to the 2D area of the display. Application upon execution on application processor may divide the generated 3D graphics content into primitives such as triangles rectangles or other types of polygons. Each of these primitives may include pixels that are to be displayed on the display. Application upon execution on application processor may also assign pixel values to each of the vertices of the primitives. For example the pixel values may include 3D coordinates of the vertices color values of the vertices and transparency values of the vertices. The pixel values need not include all of the above example components in every aspect of this disclosure.

Application processor may then forward the pixel values for the vertices to GPU for further processing. For example application processor may include graphics driver which may be software executing on application processor . Graphics driver may be designed to transmit commands to GPU and in response GPU may perform functions in accordance with the received commands. For example graphics driver functions as an interface between GPU and application processor . When application processor issues a command to GPU it is through graphics driver that GPU receives the command. For instance application executing on application processor may instruct GPU to perform a particular task. In this case graphics driver may receive the instruction from application for the particular task and may provide the instruction to GPU . In response GPU may perform the task.

In some examples graphics driver may be designed in accordance with a specific application programming interface API . For example graphics driver may be designed according to the OpenGL or OpenGL ES embedded system APIs which are APIs of the Khronos Group and their specifications are available publicly. However the techniques of this disclosure may be extendable to the Microsoft DirectX system such as DirectX 9 10 or 11 or any other shader based graphics system and APIs. For purposes of illustration the techniques of this disclosure are described in the context where the API is the OpenGL ES 2.0 API. However aspects of this disclosure are not so limited and can be extended to other APIs or shader based graphics systems.

To render the primitives received from application processor shader processor of GPU may execute one or more shader programs such as vertex shaders and fragment shaders to generate the pixel values for the pixels of a display. A developer may develop these vertex shaders and fragment shaders in accordance with an API such as the OpenGL ES 2.0 API used in this disclosure for illustration purposes. The source code for these vertex and fragment shaders may be stored in system memory .

For example application may utilize vertex shader which may be designed to generate a mono view. For instance the pixel values generated by application may need to be processed by shader processor using vertex shader . As one example vertex shader may be a vertex shader particularly called by application during the execution of application on application processor . Vertex shader may execute on shader processor of GPU and application may execute on application processor but vertex shader and application may be interrelated for the purposes of displaying the images generated by application .

The source code of vertex shader may be stored in system memory . Graphics driver may retrieve the source code of vertex shader and provide the source code for vertex shader to compiler . Compiler may compile the source code of vertex shader to generate object code of vertex shader and store the object code in system memory . Graphics driver may then instruct GPU to retrieve the object code of vertex shader from system memory and instruct GPU to execute the object code of vertex shader on shader processor . Shader processor may then execute the object code of vertex shader to process the pixel values for the vertices generated by the execution of application . GPU in conjunction with fixed function pipeline and shader processor may generate the graphics content for application for display.

Although system memory is shown to store source code for only one vertex shader aspects of this disclosure are not so limited. For example application may possibly utilize multiple different vertex shaders and the source code for each of these vertex shaders may be stored in system memory . Also application may require execution of multiple instantiations of vertex shader . For example shader processor may execute multiple instantiations of vertex shader at the same time e.g. in parallel where each instantiation of vertex shader performs substantially similar functions but on different pixel values. System memory may similarly store source code for fragment shaders. Graphics driver may retrieve the source code for the fragment shaders and compiler may compile the source code to generate object code for the fragment shaders in a manner similar to that described above for vertex shader .

As will be described in further detail one or more example techniques of this disclosure may modify the source code of vertex shader prior to the compilation. Compiler may compile the modified source code to generate object code of modified vertex shader . Shader processor may execute the object code of modified vertex shader which may cause GPU to generate stereoscopic 3D graphics content e.g. the graphics content for the left eye image and the right eye image of S3D . However prior to describing the modification to the source code of vertex shader the following describes example functionality of vertex shader which may assist in the understanding of the modification applied to the source code of vertex shader .

As described above application may generate coordinates for the vertices of the primitives. These coordinates may be referred to as world coordinates and may be specific to application . In other words the coordinates of the vertices as defined by application may not necessarily be coordinates of the display upon which the primitives are displayed and may also possibly be coordinates for vertices that are outside of a viewable area. Vertex shader may be designed to convert the world coordinates which may be in 3D into 2D coordinates of the display e.g. display coordinates . To perform this function vertex shader may transform the world coordinates into eye coordinates and then to clipping coordinates. For example the output of vertex shader when executed may be the clipping coordinates of the vertices. The final display coordinates e.g. the coordinates of the display may be determined subsequently as part of the fixed function pipeline .

The clipping coordinates may define a view frustum. The view frustum may define the viewable area of the 3D graphics content. GPU may utilize the view frustum to cull pixels which reside external to the view frustum. For example a fixed function unit of fixed function pipeline e.g. a frustum unit of fixed function pipeline may cull pixels which reside external to the view frustum as defined by the clipping coordinates generated by vertex shader .

The equation to calculate the clipping coordinates from the world coordinates may be Vclip PRJ Veye PRJ MVT Vworld equation 1 

where Vclip is the vertex clip coordinates Veye is the vertex eye coordinates Vworld is the vertex world coordinates provided by application PRJ is a projection matrix and MVT is a model view transformation matrix or world view transformation matrix . In some examples the PRJ and MVT matrices may be combined into a single matrix. However for ease of understanding these matrices are described separately.

The projection matrix PRJ and model view or world view transformation matrix MVT may be defined by the API. The terms model view and world view may be used interchangeably. Vclip Veye and Vworld may include four components e.g. x y z and w coordinates . For example Vclip Veye and Vworld may be represented as 

In some examples the clipping planes may be symmetrical. For example L may be equal to R and B may be equal to T. In these instances the PRJ matrix may simplify to 

All of the variables of the PRJ and MVT matrices may be defined by application executing on application processor and graphics driver may provide these variables to shader processor that is executing the object code of vertex shader . As can be seen from equations 1 4 and 5 with these variables vertex shader may determine the Vclip coordinates for each of the vertices. GPU may utilize the clip coordinates for the vertices and perform further functionality in conjunction with the functionality of fixed function pipeline and fragment shaders to render an image for display. In this way GPU may generate a mono view for the graphics content generated by application .

In accordance with techniques of this disclosure while vertex shader may utilize the variables for the MVT and PRJ matrices to determine the Vclip coordinates the MVT and PRJ matrices may not be needed to modify the source code of vertex shader to generate the stereoscopic view. Rather the techniques of this disclosure may include instructions in vertex shader that modify the clipping coordinates Vclip which are generated for a mono view to generate clipping coordinates for the stereoscopic view e.g. the left eye image and the right eye image .

The example above describes one way in which to determine the Vclip coordinates for the mono view. There may be many different techniques to calculate the clipping coordinates and in general it may be immaterial the particular technique utilized to calculate the clipping coordinates. However in any event for 3D graphics content clipping coordinates Vclip may need to be calculated regardless of the technique used to calculate the clipping coordinates. For example it may even be possible for application processor to determine the clipping coordinates and graphics driver may provide the clipping coordinates to shader processor that is executing the object code of vertex shader . In this example the PRJ and MVT matrices may be unity matrices. For example application processor may perform the matrix multiplication of equation 1 and provide the results to shader processor . In this example shader processor may multiply received values with a unity matrix to generate the Vclip coordinates for each of the vertices generated by application .

However in any case e.g. where vertex shader determines the clipping coordinates or where vertex shader receives the clipping coordinates vertex shader may utilize a specific variable to store the clipping coordinates. The specific variable may be particular to the API for which vertex shader is designed. For example if vertex shader is designed in accordance with the OpenGL OpenGL ES or OpenGL ES 2.0 APIs with programmable shaders vertex shader may store the clipping coordinates in the gl Position variable. There may be a similar variable in other graphics APIs. For instance if vertex shader is designed in accordance with the OpenGL OpenGL ES or OpenGL ES 2.0 APIs with programmable shaders vertex shader may include instructions such as gl Position.x x gl Position.y y gl Position.z z and gl Position.w w where as indicated above in equation 2 

In one or more example techniques described in this disclosure graphics driver wrapper which may be software executing on application processor may modify the instructions of vertex shader that define the clipping coordinates for the mono view to define clipping coordinates for the stereoscopic view e.g. clipping coordinates for the left eye image and clipping coordinates for the right eye image . Also graphics driver wrapper in addition to modifying instructions of vertex shader that define the clipping coordinates may modify instructions that define the viewport for the mono view to define viewports for the stereoscopic view.

The term viewport refers to the area an image encompasses on the display. For example application may define the size and location of the single image e.g. mono view on the display that displays the image. This definition of the size and location of the single image may be considered as the viewport for the single image. To define the viewport application may issue a glViewport command whose variables define the size and location of the mono view image on the display. Graphics driver wrapper may modify the command that defines the size and location of the single image e.g. the glViewport command issued by application to commands that define the size and location of the left eye image and the right eye image e.g. glViewport commands that define the viewport for the left eye image and the viewport for the right eye image . The glViewport command for the left eye image may constrain the left eye image to one portion of the display and the glViewport command for the right eye image may constrain the right eye image to another portion of the display.

In the examples of this disclosure graphics driver wrapper may modify the instructions that define the viewport external to the instructions that modify the instructions of vertex shader . In other words graphics driver wrapper may not need to modify the instructions of vertex shader to modify the viewport for the left eye image and the right eye image of the stereoscopic view. Rather graphics driver wrapper may modify the instruction that defines the viewport such that a fixed function unit e.g. a viewport transformation unit of fixed function pipeline applies the viewport for the left eye image that constrains the left eye image to one portion of the display and applies the viewport for the right eye image that constrains the right eye image to another portion of the display upon which the left eye and right eye images are displayed.

In some examples the viewport transformation unit of fixed function pipeline may constrain the left eye image to the left half of the display and the right eye image to the right half of the display however aspects of this disclosure are not so limited. The viewport transformation unit may constrain the left eye image and the right eye image to portions other than the left half and right half of the display. In general the viewport transformation unit may constrain the left eye image and the right eye image to portions of the display based on the modified viewport instruction that the viewport transformation unit receives as described in more detail.

As one example to cause GPU to render an image application may execute a glShaderSource command. The glShaderSource command instructs graphics driver to retrieve the source code of vertex shader from system memory . In examples of this disclosure in response to the glShaderSource command issued by application graphics driver wrapper may intercept the source code of vertex shader before it reaches graphics driver . Graphics driver wrapper may modify the source code of vertex shader to include instructions that cause modified vertex shader when executed to generate graphics content for stereoscopic view. For example graphics driver wrapper may cause the modified vertex shader to execute twice. In the first execution the modified vertex shader may generate graphics content for the left eye image and in the second execution the modified shader may generate graphics content for the right eye image or vice versa.

Graphics driver wrapper as executed by application processor may function as a source code editor. As one example graphics driver wrapper may monitor the instructions issued by application . When graphics driver wrapper recognizes that application issued the glShaderSource command graphics driver wrapper may capture and modify the instructions of vertex shader e.g. the source code of vertex shader . For example graphics driver wrapper may include instructions into the instructions of vertex shader that modify the value of the clipping coordinates generated for the single image e.g. mono view to generate the clipping coordinates for the left eye image and the right eye image e.g. stereoscopic view .

For example as indicated above vertex shader may include a gl Position.x command that stores the value for the xcoordinate. As discussed in greater detail below graphics driver wrapper may include an instruction into vertex shader that updates the value of gl Position.x e.g. the xcoordinate . To generate the left eye image the instruction added into vertex shader by graphics driver wrapper causes vertex shader to add a constant to the xvalue. To generate the right eye image the instruction added into vertex shader by graphics driver wrapper causes vertex shader to subtract a constant from the xvalue.

For example graphics driver wrapper may modify the source code of vertex shader to add an instruction that changes the value stored in the gl Position.x variable e.g. the xcoordinate to the current value of the gl Position.x variable plus z w R L 2 X where z R and L are all variables from the PRJ matrix equation 4 and wis a variable from the Vmatrix equation 2 e.g. the vertex coordinates as defined by application . The value of X may be D or D where D is an approximation of half the distance between the right eye and the left eye of the viewer and may be user definable or a preprogrammed value.

As one example graphics driver wrapper may add the following instruction to the set of instructions of vertex shader gl Position.x z w R L 2 X. This may be equivalent to gl Position.x gl Position.x z w R L 2 X. For example the gl Position.x commands adds the value defined by the gl Position.x instruction to the value stored by the gl Position command e.g. adds the value to x . In some situations the gl Position.x instruction may simplify to gl Position.x X. The reasons why the gl Position.x variable may equal z w R L 2 X or just X are described in further detail below.

In accordance with the techniques of this disclosure to generate the left eye image the graphics driver wrapper may define the value of the variable X to be D. When X equals D the gl Position.x command causes the addition of a constant e.g. z w R L 2 D or just D to the xcoordinate of each of the vertices generated by application which causes the vertices to move to the left by a value of D. To generate the right eye image the graphics driver wrapper may define the value of the variable X to be D. When X equals D the gl Position.x command causes the subtraction of a constant e.g. z w R L 2 D or just D from the xcoordinate of each of the vertices generated by application which causes the vertices to move to the right by a value of D.

After modifying the source code of vertex shader graphics driver wrapper may store the modified source code of vertex shader in system memory. In some examples graphics driver wrapper may store the modified source of vertex shader in the same location where the unmodified source code of vertex shader is stored in system memory . In alternate examples graphics driver wrapper may store the modified source of vertex shader in a location in system memory that is different from the location where the unmodified source code of vertex shader is stored.

Subsequent to issuing the glShaderSource command application issues a glCompileShader command. The glCompileShader command causes compiler executing on application processor to compile the modified source code of vertex shader . For example the glCompileShader command may cause compiler to retrieve the source code for the modified vertex shader from system memory and compile the modified vertex shader . After compiling compiler stores the resulting object code in system memory . For example as illustrated system memory includes modified vertex shader . Modified vertex shader is the object code resulting from compiler compiling the modified source code of vertex shader .

Moreover as described above graphics driver wrapper may include instructions in the source code of vertex shader that cause vertex shader to add a constant to the gl Position.x variable to generate the left eye image and subtract the constant from the gl Position.x variable to generate the right eye image. The object code of modified vertex shader includes instructions that cause modified vertex shader to add the constant to the gl Position.x variable to generate the left eye image and subtract the constant from the gl Position.x variable to generate the right eye image. As described in more detail modified vertex shader receives the value of the constant from graphics driver wrapper in response to a draw command.

Application upon execution by processor may also issue a command that defines the viewport of the single image e.g. a command that defines the size and location of the single image on the display . This command may be the glViewport command. The glViewport command defines the starting coordinates for the image e.g. x and y coordinates and the width and length of the image. The starting coordinates and the width and length values of the glViewport command define the size and location of the image.

In examples of this disclosure graphics driver wrapper may capture the glViewport command issued by application . In some examples graphics driver wrapper may block graphics driver from transmitting the glViewport command issued by application to GPU . Instead graphics driver wrapper may store the starting coordinates and the width and length values of the glViewport command as issued by application in system memory .

In an alternate example graphics driver wrapper may allow graphics driver to transmit the glViewport command issued by application to GPU . In this example similar to above graphics driver wrapper may store the starting coordinates and the width and length values of the glViewport command as issued by application . In this alternate example prior to GPU applying the glViewport command issued by application graphics driver wrapper may modify the glViewport command issued by application and transmit the modified glViewport command to GPU . In this manner although GPU received the glViewport command issued by application GPU may execute the modified glViewport command which is modified by graphics driver wrapper .

In either example graphics driver wrapper may then wait until application issues a command to GPU instructing GPU to draw one or more primitives. This draw command may be a glDraw command. There are various examples of glDraw commands such as glDrawArrays and glDrawElements. Each of these various examples of draw commands is commonly referred to as a glDraw command.

When application issues the glDraw command graphics driver wrapper captures the glDraw command and blocks graphics driver from transmitting the glDraw command to GPU . Graphics driver wrapper then generates instructions that cause GPU to generate the graphics content for the left eye image and the right eye image. As one example graphic driver wrapper generates instructions that cause GPU to execute the object code of modified vertex shader twice issues two glViewport commands to define the viewport for the left eye image and the right eye image and issues two glDraw commands.

As an overview of the techniques after graphics driver wrapper blocks graphics driver from the transmitting the glDraw command issued by application graphics driver wrapper issues a command to GPU that causes shader processor to make the modified vertex shader ready to generate clipping coordinates for a first image of the stereoscopic view e.g. the left eye image . Then graphics driver wrapper may issue a first glViewport command to a viewport transformation unit of the fixed function pipeline which defines the size and location of the first image on the display. Graphics driver wrapper may then issue a first glDraw command to GPU that causes GPU to render the first image constrained to a first portion of the display as defined by the first glViewport command.

Graphics driver wrapper then issues a command to GPU that causes shader processor to make the modified vertex shader ready to generate clipping coordinates for a second image of the stereoscopic view e.g. the right eye image . Then graphics driver wrapper may issue a second glViewport command to a viewport to the viewport transformation unit of the fixed function pipeline which defines the size and location of the second image on the display. Graphics driver wrapper may then issue a second glDraw command to GPU that causes GPU to render the second image constrained to a second portion of the display as defined by the second glViewport command.

The techniques of this disclosure described as an overview above are described in more detail in the following examples. For ease of understanding only in the following examples the techniques are described with GPU generating the graphics content for the left eye image first followed by the graphics content for the right eye image however the opposite is also possible. Also for ease of understanding only the techniques are described where the viewport for the left eye image is constrained to the left half of the display and the viewport for the right eye image is constrained to the right half of the display although this should not be considered as limiting.

For example after graphics driver wrapper intercepts the glViewport command and then blocks the glDraw command issued by application graphics driver wrapper generates an instruction that instructs GPU to generate clipping coordinates for the left eye image. Again it should be noted that in some examples graphics driver wrapper may block the transmission of the glViewport command issued by application to GPU . In other examples graphics driver wrapper may allow the glViewport command issued by application to be transmitted to GPU . However in either of the examples graphics driver wrapper may transmit modified glViewport commands to GPU . In this manner even if GPU received the glViewport command issued by application GPU may not execute the glViewport command issued by application and may instead execute the modified glViewport commands issued by graphics driver wrapper . In other words the modified glViewport commands modified by graphics driver wrapper reset the glViewport command issued by application .

As one example graphics driver wrapper generates an instruction that causes GPU to execute the object code of modified vertex shader . In response shader processor of GPU executes the object code of modified vertex shader . In addition graphics driver wrapper transmits the constant value that modified vertex shader is to add to the gl Position.x variable to generate the clipping coordinates for the left eye image. The output of shader processor due to the execution of the object code of modified vertex shader is the clipping coordinates for the vertices of the left eye image.

For instance as discussed above graphics driver wrapper may include the following instruction into the source code of vertex shader gl Position.x z w R L 2 X or just gl Position.x X for reasons that will be described. The z w R and L variables may possibly be known to shader processor as described above with respect to equations 2 and 4 . However aspects of this disclosure do not require shader processor to know the values of the z w R and L variables. For example the z world R and L variables may each be constants and therefore the result of z w R L 2 would be a constant value. In this case the value of z w R L 2 could be estimated or user provided and multiplied into the value of X. As described in more detail in some examples z w R L 2 may simplify to 1.

In some examples shader processor may not know the value of X. For the left eye image graphics driver wrapper may transmit the value of X to shader processor in addition to the instruction instructing shader processor to execute the object code of modified vertex shader . In some examples the value of X for the left eye image may be D where D equals approximately half the distance between the eyes of the viewer and may be user defined or preprogrammed. Because the value of variable X is D the gl Position.x command causes shader processor to add the value of D to the value stored in the gl Position.x variable e.g. add D to the value of x .

Graphics driver wrapper also defines the viewport for the left eye image. For example prior to when application issued the glDraw command application issued the glViewport command that graphics driver wrapper intercepted. Graphics driver wrapper also stored the starting coordinates and the width and length values in system memory . To define the viewport for the left eye image graphics driver wrapper may modify the intercepted glViewport command issued by application .

For example the glViewport command includes four variables where the first two variables define the starting coordinate for the image on the display and the last two variables define the width and length of the image. The width and length variables are not necessarily coordinate values. Rather the width and length variables define the amount by which the image extends from the starting coordinates. For instance application may issue a glViewport command that states glViewport 0 0 width length . In this example the 0 0 refer to the bottom left of the display. The variable width refers to the width of the display and the variable length refers to the length of the display. Accordingly in this example application defines the viewport of the image to encompass the entirety of the display which would be consistent with a mono view image. However application may assign different variables for the glViewport command other than those illustrated.

In accordance with this disclosure graphics driver wrapper may intercept the glViewport command e.g. glViewport 0 0 width length of the previous example and modify the variables for this viewport command. For example graphics driver wrapper may modify the variables of the glViewport command to constrain the left eye image to a desired portion of the display. For ease of description the techniques describe constraining the left eye image to the left half of the display and right eye image to the right half of the display however aspects are not so limited.

For the left eye image graphics driver wrapper may modify glViewport command issued by application to glViewport 0 0 width 2 length . In this example the width 2 would be half of the width of the display. For example the modified glViewport command indicates that the left eye image with start from the left end of the display e.g. starting from 0 point on the x axis and extend rightwards a distance of width 2 which would constrain the left eye image to the left half of the display. Also the modified glViewport command indicates that the left eye image will start from the bottom of the display e.g. starting from the 0 point on the y axis and extend upwards a distance of length which would constrain the image to the top and bottom of the display.

Graphics driver wrapper may then issue a first glDraw command to GPU . In response to the glDraw command GPU may process the clipping coordinates for the left eye image generated by the execution of the object code of the modified vertex shader through fixed function pipeline and fragment shaders. In this example the first glViewport command may constrain the left eye image to the left half of the display. The glDraw command may then cause GPU to render the left eye image to a frame buffer for temporary storage. For example the frame buffer may store the left eye image until the right eye image is generated. Then GPU may output the entirety of the frame buffer to a display processor not shown . The display processor may cause the display to display the left eye image and the right eye image to generate the stereoscopic view.

Graphics driver wrapper may repeat the same steps for generating the left eye image but for generating the right eye image. For example graphics driver wrapper issues another instruction to cause shader processor to execute the object code of modified vertex shader . In addition graphics driver wrapper transmits the constant value that modified vertex shader is to subtract from the gl Position.x variable to generate the clipping coordinates for the right eye image. The output of shader processor due to the execution of the object code of modified vertex shader is the clipping coordinates for the vertices of the right eye image.

As described above graphics driver wrapper may add the instruction gl Position.x z w R L 2 X or just gl Position.x X to the source code of vertex shader . For the left eye image the value of variable X may be D e.g. half the distance between the eyes of the viewer . In examples of this disclosure for the right eye image the value of variable X may be D. Because the value of variable X is D the gl Position.x command causes shader processor to subtract the value of D from the value stored in the gl Position.x variable e.g. subtract D from the value of x .

Graphics driver wrapper also defines the viewport for the right eye image. As discussed above for the left eye image graphics driver wrapper defines the viewport to be glViewport 0 0 width 2 length to constrain the left eye image to the left half of the display. For the right eye image graphics driver wrapper may define the viewport to be glViewport width 2 0 width 2 length . In this example the width 2 0 coordinate indicates that the right eye image will start from the middle of the display and extend rightwards. Also the width 2 length variables in the glViewport command indicate that the right eye image will extend half the width of the display and the full length of the display.

Therefore in this example the modified glViewport command e.g. glViewport width 2 0 width 2 length would constrain the right eye image to the right half of the display. For example the modified glViewport command indicates that the right eye image will start from the middle of the display e.g. starting from the width 2 point on the x axis and extend rightward a distance of width 2 which would constrain the right eye image to the right half of the display. Also the modified glViewport command indicates that the right eye image will start from the bottom of the display e.g. starting from the 0 point on the y axis and extend upward a distance of length which would constrain the image to the top and bottom of the display.

Graphics driver wrapper may then issue a second glDraw command to GPU . In response to the glDraw command GPU may process the clipping coordinates for the right eye image generated by the execution of the object code of the modified vertex shader through fixed function pipeline and fragment shaders. In this example the second glViewport command may constrain the right eye image to the right half of the display. The glDraw command may then cause GPU to render the right eye image to the frame buffer for temporary storage. In this case GPU may have already stored the left eye image to the frame buffer and GPU may instruct the display processor to retrieve and display the stored left eye image and right eye image from the frame buffer to generate the stereoscopic view.

As described above graphics driver wrapper may add the instruction gl Position.x command to the source code of vertex shader . It is the gl Position.x command that is added to the source code of vertex shader that causes the slight displacement between the left eye image and the right eye image to cause the popping out or pushing effect of the stereoscopic view. It is the modification of the instruction that defines the viewport for the mono view e.g. glViewport to instructions that define the viewport for the right eye and left eye images that constrain the left eye image and the right eye image to appropriate portions of the display e.g. the left half and right half of the display respectively .

To further assist with understanding assume that graphics driver wrapper did not modify the instructions of vertex shader to include the gl Position.x command but graphics driver wrapper modified the glViewport command and caused GPU to execute two glViewport commands and two glDraw commands. In this case GPU would render two images because of the two glDraw commands. However in this example to assist with understanding if these two images were placed on top of one another there would be no displacement and the content of the two images would line up perfectly. Because there is no displacement in the content of the two images there may not be any stereoscopic effect and the image would appear to the viewer as a single image constrained to the 2D area of the display. The inclusion of the gl Position.x command may cause the displacement in the content of the two images. Then when the viewer simultaneously views the left eye and right eye images where the left eye image is blocked from the right eye and the right eye image is blocked from the left eye the brain of the viewer resolves the displacement in the content of the two images to create the popping out or pushing in affect of the stereoscopic view.

Furthermore in some examples graphics driver wrapper may further modify the viewport in addition to the modification described above. For example as described above graphics driver wrapper may modify the glViewport instruction for the left eye image to glViewport 0 0 width 2 length and modify the glViewport instruction for the right eye image to glViewport width 2 0 width 2 length . When the viewer views these two images e.g. the stereoscopic view the viewer may perceive the stereoscopic image that encompasses a 3D volume on a zero disparity plane ZDP .

The ZDP may appear popped out of or pushed into the display e.g. appear ahead of or behind the display . However the location of the ZDP may not necessarily be at the desired location. For example the viewer may experience a richer and more realistic viewing experience if the ZDP were popped out further not popped out as much not pushed in as much or pushed in further.

To change the ZDP which may be referred to as viewport shift or shifting of the ZDP graphics wrapper driver may shift the left boundary for the left eye image and the right eye image. For example for the left eye image graphics wrapper may modify the glViewport command to 0 Vps 0 width 2 length and for the right eye image graphics wrapper may modify the glViewport command to width 2 Vps 0 width 2 length to change the amount by which the stereoscopic view is popped out of the display.

In these examples the Vps value refers to viewport shift and indicates the amount by which the viewport of the left eye image shifts and the amount by which the viewport of the right eye image shifts. The Vps value may be user selectable or preprogrammed. For example if the viewer desires to shift the ZDP from its current location e.g. prior the viewport shift the viewer may select the Vps value that achieves the desired location of the ZDP. Alternatively the Vps value may be preprogrammed based on tests that provide a measure of where viewers considered the ZDP to be optimally located. For instance if Vps is a positive value the amount by which the stereoscopic view is popped out may be reduced e.g. the ZDP plane is closer to the display . If Vps is a negative value the amount by which the stereoscopic view is popped out may be increased e.g. the ZDP plane is further from the display .

In some examples in addition to a viewport shift graphics driver wrapper may modify the glViewport commands for the left eye and right eye images for viewport stretch. Viewport stretch may be considered as stretching the size of viewport which may result in the stretching of the left eye image and the right eye image. In some instances the viewport shift and the viewport stretch may result in a better stereoscopic view. The viewport shift and the viewport stretch may be referred commonly as modifying the viewport. In other words graphics driver wrapper may modify the glViewport command issued by application to generate glViewport commands for the left eye image and the right eye image that define the viewports for the left eye image and the right eye image respectively. In this example graphics driver wrapper may further modify the viewports of the left eye image and the right eye image e.g. viewport shift or viewport shift and viewport stretch .

For stretching the viewport for the left eye image graphics driver wrapper may modify the glViewport command for the left eye image to be glViewport 0 Vps 0 width 2 Vps length . For stretching the viewport for the right eye image graphics driver wrapper may modify the glViewport command for the right eye image to be glViewport width 2 0 width 2 Vps length . In the example techniques the viewport shift and the viewport stretch may be not necessary in every instance. For instance in some examples graphics driver wrapper may modify the glViewport command issued by application to glViewport commands for the left eye image and the right eye image and may not perform any additional viewport shifting or stretching. In some alternate examples graphics driver wrapper may modify the glViewport command issued by application and further modify the viewports of the left eye image and right eye image e.g. viewport shift or viewport shift and viewport stretch .

In some examples the viewport shift and viewport stretch may be performed at the same time as the modification of the glViewport command. For example as described above graphics driver wrapper may modify the glViewport command for the left eye image to glViewport 0 0 width 2 length and for the right eye image to glViewport width 2 0 width 2 length . In some examples where the user desires to input the viewport shift value e.g. Vps graphics driver wrapper may shift or shift and stretch the viewport as described above. In alternate examples graphics driver wrapper may proactively add or subtract the Vps values when modifying the glViewport command in examples where the Vps value is preprogrammed.

As an example assume the size of the display is 10 10 pixels and the Vps value is selected or preprogrammed to be 2 to reduce the amount by which the stereoscopic view is popped out. In this example prior to the viewport shift the viewport for the left eye image may be 0 0 5 9 and the viewport for the right eye image may be 5 0 5 9 . Graphics driver wrapper may shift the viewport for the left eye image by subtracting 2 e.g. the value of Vps to shift the ZDP. In this example the viewport for the left eye image may become 2 0 5 9 . Graphics driver wrapper may shift the viewport for the right eye image by adding 2 e.g. the value of Vps to shift the ZDP. In this example the viewport for the right eye image may become 7 0 5 9 . Similar calculations may be performed to determine the viewport after viewport stretch.

For the viewport shifted left eye image GPU may crop some of the pixels of the left eye image. For example the coordinates of the display may be 0 0 9 9 in this example. However the coordinates for the viewport shifted left eye image may be 2 0 5 9 which means that the viewport shifted left eye image starts further left than the left edge of the display. Fixed function pipeline of GPU may crop the pixels whose coordinates are further left than the left edge of the display. Similarly for the viewport shifted right eye image GPU may crop some of the pixels of the right eye image. For example the coordinates for the viewport shifted right eye image may be 7 0 5 9 which means that the viewport shifted right eye image ends further right than the right edge of the display. Fixed function pipeline of GPU may crop the pixels whose coordinates are further right than the right edge of the display. Again similar calculations may be performed for viewport stretching.

The location of the viewport shifted or shifted and stretched ZDP e.g. the resulting ZDP from the viewport shifted or shifted and stretched left eye image and right eye image may be determined by the following equation ZDP ZDP ZDP Vps equation 6 where ZDP equals the location of the viewport shifted ZDP z is defined in the PRJ matrix equation 4 D is the half distance between the left eye and right eye of the viewer ZDP is the original location e.g. prior to viewport shifting and Vps is the amount by which the left boundary of the left eye image and right eye image are shifted.

In some instances the value of z ZDP D or Vps may not be available to the viewer. In these instances the viewer may still modify the Vps value e.g. increment the value or decrement the value until the viewer finds a desirable viewport shifted ZDP or shifted and stretched ZDP. The modification of the Vps value may not be necessary in every example and a preprogrammed Vps value may provide a suitably rich and realistic viewing experience for most viewers.

In some examples the techniques described in this disclosure may modify the instructions to generate an image for a mono view to generate images for stereoscopic view during execution or run time. For example a viewer may select application for execution which may require the execution of vertex shader for processing the graphics generated by the execution of application . While application is executing or running on device graphics driver graphics driver wrapper and compiler may perform their respective functions to modify the source code of vertex shader and generate the object code for modified vertex shader . For example graphics driver wrapper may intercept the glViewport command issued by application during run time and block the transmission of the glViewport command issued by application to GPU during run time in some examples or allow the transmission of the glViewport command issued by application to GPU in other examples. In either example graphics driver wrapper may modify the glViewport command issued by application so that the glViewport command executed by GPU is the modified glViewport command modified by graphics driver wrapper .

Moreover when application issues the draw command e.g. glDraw graphics driver wrapper may capture and block this glDraw from transmission to GPU . This glDraw command which application issued during run time may function as the trigger that causes graphics driver wrapper to include instructions that define the viewport for the left eye image and the right eye image in a manner described above and include two glDraw commands to cause GPU to generate graphics content for the left eye image and the right eye image.

Also although the above examples are described in the context where the graphics driver wrapper adds instructions to and modifies the instructions of vertex shader and modifies the instruction that defines the viewport aspects of this disclosure are not so limited. In alternate examples rather than graphics driver wrapper it may be possible for graphics driver or compiler to modify the instructions of vertex shader and the instruction that defines the viewport. However these examples may require modification to graphics driver or compiler .

Modification to graphics driver or compiler may be more difficult than developing graphics driver wrapper and having graphics driver wrapper perform the functions described in this disclosure so that GPU generates the left eye image and the right eye image for the stereoscopic view. For example device may have been loaded with preexisting graphics driver and compiler and it may be difficult to change graphics driver and compiler . By adding graphics driver wrapper that performs the modification to vertex shader the example techniques may not require modification to preexisting graphics driver and compiler .

Furthermore the techniques described above may allow GPU to generate images for the stereoscopic view without modification to application . For example some other techniques to generate stereoscopic view may require the developers of application to modify the source code of application to generate pixel values for the left eye and right eye images. These techniques required assistance from the developer of application to modify their applications for stereoscopic view which may be potentially cumbersome task for the developer of application . The example techniques described above may provide stereoscopic view for application developed for mono view without any assistance from the developer of application .

Also the techniques described above may not require multiple calls to system memory for generating the left eye and right eye images for stereoscopic view. For example in some other techniques to generate stereoscopic view a GPU would generate the left eye image. Upon completion of the generation of the left eye image the GPU would utilize depth information stored in system memory while generating the left eye image to generate the right eye image. However repeated calls to system memory to retrieve the depth information may be computationally expensive and may require excessive power consumption.

The example techniques described above may not require such multiple calls to system memory for the depth information for the left eye image to generate the right eye image. For example graphics driver wrapper may modify the source code of vertex shader and the instruction that defines the viewport to generate the left eye and right eye images independently from one another without necessarily needing the depth information of one image to generate the other image. For instance the instructions that are added into vertex shader and the modification of the glViewport commands and the issuances of two glDraw commands as described above may not require any depth information and in some examples generate the left eye image without requiring information about right eye image and vice versa. In this way the techniques described in this disclosure may reduce the number of access to system memory for generating the stereoscopic view as compared to other techniques.

Moreover as described above the glViewport command is utilized by a fixed function unit of fixed function pipeline e.g. the viewport transformation unit of fixed function pipeline and not by shader processor . In this way the source code for vertex shader may not need to be modified to force rendering of the left eye image to a first portion of the display e.g. the left half of the display and force rendering of the right eye image to the other portion of the display e.g. the right half of the display . Rather a fixed function unit of fixed function pipeline may apply the modified glViewport commands to constrain the left eye image to its portion of the display and the right eye image to its portion of the display. This may reduce and simplify the modifications to vertex shader which may increase the computational efficiency of shader processor .

For example in accordance with the techniques of the disclosure graphics driver wrapper may modify the source code of vertex shader to provide the displacement between the left eye image and the right eye image. For instance when generating the clipping vertex coordinates for the left eye image and the right eye image shader processor which is executing the object code of modified vertex shader may be oblivious to where the generated graphics data will be displayed. In other words shader processor may not be tasked with defining where the graphics data is to be presented for the left eye image and the right eye image. The viewport transformation unit of fixed function pipeline which is a unit external to shader processor may be tasked with constraining the left eye and right eye images to their respective portions of the display. In this way shader processor may not need to waste computational cycles in determining where the left eye and right eye images should be displayed. The hardwired functionality of the viewport transform unit of fixed function pipeline may be more suitable for constraining the left eye image the right eye image to their respective portions on the display as compared to shader processor .

For example if the source code for vertex shader were modified to determine where the left eye and right eye images should be displayed so as to control the zero disparity plane ZDP it may require shader processor to determine the coordinates for each vertex of each of the primitives in the left eye and right eye images. This may require shader processor to perform multiple computational cycles which may reduce the efficiency of shader processor . By performing the viewport transformation and also the viewport shift or shift and stretch e.g. further modifying the viewport based on the Vps value to adjust the ZDP in the viewport transformation unit of fixed function pipeline aspects of this disclosure may provide richer stereoscopic view without wasted computation cycles in the shader processor .

As described above graphics driver wrapper may include the gl Position.x z w R L 2 X or just gl Position.x X command into the source code of vertex shader that modifies the value of the gl Position.x variable. The following provides the reasons for such an inclusion of instructions into the source code of vertex shader .

As indicated above in equation 1 Vclip PRJ Veye PRJ MVT Vworld. The equation for Vclip may be modified to generate clipping coordinates for the left eye and the right eye. For example the clipping coordinates for the left eye and right eye may be Vclip left eye PRJ VTleft eye Veye PRJ VTleft eye MVT Vworld equation 7 and Vclip right eye PRJ VTright eye Veye PRJ VTright eye MVT Vworld equation 8 .

VTleft eye and VTright eye may be 4 4 matrices that are based on an assumed distance of the left eye and right eye away from the mono view. The coordinates of the mono view may be 0 0 0 and the left eye may be considered as being located at D 0 0 and the right eye may be considered as being located at D 0 0 . In other words the 0 0 0 location may be considered as being in the middle of the right eye and the left eye of the viewer. If the left eye is considered to be located D away from the middle of the right eye and the left eye and right eye is considered to be located D away from the middle of the right eye and the left eye then D indicates half of the distance between the right eye and left eye of the viewer.

VTleft eye and VTright eye may be rewritten as a sum of two matrices. For example VTleft eye may be rewritten as

By substituting the VTleft eye matrix into the equation for Vclip left eye equation 7 Vclip left eye equals 

By substituting the VTright eye matrix into the equation for Vclip right eye equation 8 Vclip right eye equals 

As described above in equation 1 PRJ MVT Vworld equals Vclip. Therefore the Vclip left eye and Vclip right eye equations e.g. equations 9 and 10 respectively can be rewritten as 

By substituting the matrices for the PRJ and MVT equations 4 and 5 respectively and performing the matrix multiplication of equation 11 the equation for Vclip left eye may simplify to 

In some examples it may be possible to further simplify the gl Position.x command to just gl Position.x X. For example it is common for the wvariable to be set to 1. Also OpenGL OpenGL ES and OpenGL ES 2.0 with programmable shaders define a frustum to be 

Accordingly equations 7 14 provide mathematical foundation that illustrates the reasons why adding the instruction gl Position.x z w R L 2 X or gl Position.x X to vertex shader may be sufficient to displace the mono view image to generate stereoscopic view when executed twice and where X equals D in the first execution and D in the second execution. In this way the techniques of this disclosure may provide for a minor modification to the source code of vertex shader which is designed for mono view such that when the modified source code is compiled and executed e.g. the execution of the object code of modified vertex shader the resulting images may provide the viewer with a stereoscopic view. The stereoscopic view may provide the viewer with a 3D experience which may be richer fuller experience as compared to viewing an image limited by the 2D area of the display.

In some examples graphics driver wrapper may include the command gl Position.x X even when z w R L 2 does not simplify to 1 e.g. where cot fov does not equal 1 because the viewing angle is not 45 degrees and or wdoes not equal 1 . For instance z w R L 2 may be constant because z w R and L are each constants. Since z w R L 2 is a constant the value of z w R L 2 X is a constant because X is a constant. In this case z w R L 2 X may be collapsed to represent a single constant which may simply be X. In this case the value of X may be user specified or preprogrammed. For instance in the above examples X equaled D for the left eye image and D for the right eye image. In this current example X may equal z w R L 2 D for the left eye image and z w R L 2 D for the right eye image where z w R L 2 and D may be user specified for preprogrammed values if the z w R and L values are not available to shader processor .

If the z w R and L values are available to the shader processor shader processor may determine the value of z w R L 2 and multiple that value with D or D based on whether GPU is generating graphics content for the left eye image or the right eye image. Also again if cot fov and wboth equal 1 then z w R L 2 may simplify to 1.

As one example as described above application processor executing application may instruct GPU to execute the object code of modified vertex shader . In this example command processor may receive the command from application processor and may instruct shader processor to execute the object code of modified vertex shader . As another example as described above graphics driver wrapper may modify the glViewport command issued by application and provide the modified glViewport commands to GPU . In this example command processor may receive the modified glViewport commands and determine that this command is for viewport transformation unit of fixed function pipeline . Command processor may forward the modified glViewport commands to viewport transformation unit for applying the viewports for the left eye image and right eye image.

For example as described above application may issue a glDraw command that graphics driver wrapper blocks from transmission to GPU . The glDraw command may trigger graphics driver wrapper into issuing a first instruction to shader processor to execute the object code of modified vertex shader . In turn shader processor executes the object code of modified vertex shader and stores the resulting clipping coordinates in its local memory or system memory . The glDraw command also causes graphics driver wrapper to issue a first modified glViewport instruction which is received by command processor . Then graphics driver wrapper issues the first glDraw command which is received by command processor . Command processor in response causes the fixed function units of fixed function pipeline and shader processor to perform their respective functions to generate the graphics content for a first image of the stereoscopic view e.g. the left eye image . For example as discussed in more detail in response to the first glDraw command viewport transformation unit constrains the first image to a first portion of the display and per fragment operation unit outputs the graphics content of the first image to frame buffer .

After the first image of the stereoscopic view is stored in frame buffer GPU repeats the steps to generate the graphics content for the second image of the stereoscopic view. For example graphics driver wrapper issues a second instruction to shader processor to execute the object code of modified vertex shader . In turn shader processor executes the object code of modified vertex shader and stores the resulting clipping coordinates in its local memory or system memory . Graphics driver wrapper also issues a second modified glViewport instruction which is received by command processor . Then graphics driver wrapper issues the second glDraw command which is received by command processor . Command processor in response causes the fixed function units of fixed function pipeline and shader processor to perform their respective functions to generate the graphics content for a second image of the stereoscopic view e.g. the right eye image . For example in response to the second glDraw command viewport transformation unit constrains the second image to a second portion of the display and per fragment operation unit outputs the graphics content of the second image to frame buffer . This functionality of GPU is described in more detail in the following examples.

As illustrated in dashed boxes in shader processor includes modified vertex shader and fragment shader . The dashed boxes are to indicate that shader processor may not actually include modified vertex shader and fragment shader . Rather shader processor may execute the object code of modified vertex shader and fragment shader . The object of modified vertex shader and fragment shader may be stored in system memory .

Fixed function pipeline may include one or more fixed function units such as primitive assembly unit frustum unit perspective divide unit viewport transformation unit rasterization unit and per fragment operation unit . Each of these fixed function units of fixed function pipeline may be hardware units that are hardwired to perform specific graphics related functions. Although these fixed function units of fixed function pipeline are illustrated as separate components aspects of this disclosure are not so limited. One or more of the fixed function units of fixed function pipeline may be combined together into a common fixed function unit. Also there may be more fixed function units of fixed function pipeline than those illustrated in . The one or more fixed function units of fixed function pipeline are illustrated separately to ease understanding.

Moreover the specific ordering of the fixed function units of fixed function pipeline is illustrated for example purposes and should not be considered limiting. For instance it may be possible to reorder the fixed function units of fixed function pipeline . As one example one of the functions of per fragment operation unit may be to cull pixels that are occluded by overlapping pixels. It may be possible for this function to be performed earlier in fixed function pipeline .

These fixed function units of fixed function pipeline may provide very limited functional flexibility as compared to shader processor . For example shader processor may be specifically designed to execute programmable shader programs such as modified vertex shader and fragment shader . These shader programs cause shader processor to function in the manner defined by the shader programs. In other words shader programs may define the functionality of shader processor whereas the functionality of the fixed function units of fixed function pipeline is set.

As described above graphics driver wrapper may instruct GPU to execute the object code of modified vertex shader twice where the first execution is for the generation of clipping coordinates for vertices of one of the images of stereoscopic view e.g. left eye image and the second execution is for the generation of clipping coordinates for vertices of the other image of stereoscopic view e.g. right eye image . In response to each of these instructions to execute the object code of modified vertex shader command processor may instruct shader processor to retrieve the object code of modified vertex shader and execute it. As described above compiler may compile the source code of the modified vertex shader and store the resulting object code as the object code of modified vertex shader . As illustrated in modified vertex shader may receive vertex array and textures as inputs. Vertex arrays may include information to generate the pixel values for the vertices generated by application e.g. the coordinates of the vertices color values of the vertices and transparency values of the vertices as described above. For example the coordinates of the vertices of vertex array may be the world coordinates as defined by application . Textures may be pixel values for textures that overlay over the generated graphics to provide a more realistic view of the graphics content.

Modified vertex shader executing on shader processor may generate the clipping coordinates for each of the vertices. For example modified vertex shader may convert the world coordinates of the vertices as defined by application and stored in vertex array into clipping coordinates for each of the vertices by performing the matrix multiplication of equation 1 as discussed above with respect to . Furthermore modified vertex shader executing on shader processor may update the gl Position.x variable for the clipping coordinates of each of the vertices to provide the displacement for the left eye image in the first execution of the object code of modified vertex shader and to provide the displacement for the right eye image in the second execution of the object code of modified vertex shader . Also modified vertex shader may perform additional conventional vertex shader tasks. For example modified vertex shader may perform lighting functions on the vertices.

After modified vertex shader performs the model view transformation e.g. conversion of the world view coordinates to clipping coordinates including the displacement with the gl Position.x command modified vertex shader provides the clipping coordinates for the vertices to primitive assembly unit of fixed function pipeline . Primitive assembly unit may utilize the clipping coordinates for the vertices to assemble the vertices into primitives. For example primitive assembly unit may assemble a plurality of triangles based on the clipping coordinates for the vertices where the vertices of each of the triangles correspond to vertices received from modified vertex shader . The plurality of triangles is one example of primitives. In general primitive assembly unit may assemble the received vertices into any polygon based on the clipping coordinates for the received vertices.

Primitive assembly unit may transmit the assembled primitives to frustum unit . Frustum unit may determine whether the assembled primitives are within a view volume. For example as described above OpenGL OpenGL ES and OpenGL ES 2.0 may define a particular view volume as fov . However the frustum may be user definable using for example the glFrustum function. Frustum unit may determine whether a primitive is fully within the view volume fully external to the view volume or partially within the view volume and partially external to the view volume. Frustum unit may cull from further processing primitives that are fully external to the view volume and portions of primitives are that external to the view volume. Frustum unit may keep for further processing primitives that are fully within the view volume and portions of primitives that are within the view volume.

Frustum unit may transmit the remaining primitives and portions of primitives to perspective divide unit . Perspective divide unit may expand or shrink primitives based on their depth. For example each of the primitives may be defined by x y and z coordinates. The z coordinate may indicate how close or away the primitive is. It should be noted that at this stage GPU is generating graphics content for one of the images for the stereoscopic view. Therefore the concept of proximity of a primitive is in the context of a mono view not a stereoscopic view.

For instance perspective divide unit may shrink some primitives and expand other primitives. This may create a perception that the shrunk primitives are further away compared to the expanded primitives in a mono view. As described above it is when these mono view images are displayed that the viewer perceives stereoscopic view. In other words perspective divide unit may cause the left eye image and the right eye image to be 3D images that are displayed in the 2D area of the display. When the viewer views these 3D images the displacement caused by the addition of the gl Position.x command in the left eye image and the right eye image causes the viewer to perceive the stereoscopic 3D S3D image that encompasses a 3D volume.

Perspective divide unit may transmit the primitives to viewport transformation unit . Viewport transformation unit modifies the size and location of the image to fit the defined viewport. For example prior to the viewport transformation unit modified vertex shader and the fixed function units of fixed function pipeline process graphics data as if the image is to be displayed on the entirety of the display. The function of viewport transformation unit may be to modify the size and location of the image so that the image is constrained to the defined viewport.

For instance as described above after the first execution of the object code of vertex shader which may generate graphics content for the left eye image e.g. clipping coordinates for vertices graphics driver wrapper may modify the viewport of the left eye image to constrain the left eye image to the left half of the display. For example after the first execution of the object code of vertex shader graphics driver wrapper may modify the glViewport 0 0 width length command which was previously issued by application and blocked from GPU to glViewport 0 0 width 2 length and provide this first modified glViewport command to GPU . Command processor may provide the first modified glViewport command to viewport transformation unit . Viewport transformation unit may then modify the sizes of the primitives received from perspective divide unit so that these primitives are constrained to the left half of the display in this example. For instance perspective divide unit may modify the sizes of the primitives relative to one another so that some primitives appear closer than other primitives. Viewport transformation unit may proportionally modify the size and location of the primitives such that the primitives are constrained to the left half of the display.

After the second execution of the object code of vertex shader viewport transformation unit may perform similar functions but for the right eye image. For example the second execution of the object code of vertex shader may be for the generation of graphics content for the right eye image e.g. clipping coordinates for vertices . After this second execution of the object code of vertex shader graphics driver wrapper may modify the glViewport 0 0 width length command which was previously issued by application and blocked from GPU to glViewport width 2 0 width 2 length and provide this second modified glViewport command to GPU . Command processor may forward the second modified glViewport command to viewport transformation unit . Viewport transformation unit may proportionally modify the size and location of the primitives such that the primitives are constrained to the right half of the display. In this way GPU may be operable to generate left eye and right eye images for the stereoscopic view from a mono view image generated by application during run time of application and without relying on depth information to generate the right eye image from the left eye image and vice versa.

Furthermore viewport transformation unit may perform the viewport shift or viewport shift and stretch as described above. For example as described above the viewer may provide a Vps value or the Vps value may be preprogrammed where the Vps value indicates the amount by which the viewport for the left eye image and the right eye image should shifted or shifted and stretched. In this example viewport transformation unit may be operable to perform the viewport shifting and stretching as well. The viewport shifting or shifting and stretching may cause the perceived stereoscopic view to pop out further from the display not pop out as much from the display not push into the display or push further into the display.

For viewport shifting or shifting and stretching command processor may retrieve the user provided or preprogrammed Vps value and provide the Vps value to viewport transformation unit . In this example viewport transformation unit may receive the modified glViewport command for the left eye image as glViewport 0 Vps 0 width 2 length or glViewport 0 Vps 0 width 2 Vps length and for the right eye image as glViewport width 2 Vps 0 width 2 length or glViewport width 2 0 width 2 Vps length . Viewport transformation unit may perform the viewport shifting of shifting and stretching for the left eye image and the right eye image and perform any culling if the viewport extends outside of the display area of the display. As described above the viewport shifting or shifting and stretching may provide the viewer with a richer stereoscopic view.

Viewport transformation unit may forward the primitives to rasterization unit after modifying the viewport after each of the first modified glViewport command and the second modified glViewport command. Rasterization unit may convert the primitives into pixels of the display. For example rasterization unit may determine which pixels of the display are encompassed by each of the primitives. Rasterization unit may also determine the location of each of these pixels on the displays.

Rasterization unit may output its graphics data to fragment shader . Fragment shader sometimes referred to as a pixel shader may be a shader program that executes on shader processor . For example the source code for fragment shader may be stored in system memory and compiler may compile the source code of fragment shader to generate the object code of fragment shader . Alternatively system memory may store the object code for fragment shader without it necessarily being generated by compiler .

Fragment shader may output the color values for each of the pixels on the display. For example fragment shader may define the color of each pixel based on a red green blue RGB component. Fragment shader may utilize 8 bits to define the red component 8 bits to define the green component and 8 bits to define the blue component as one illustrative example. Fragment shader may output the color values to per fragment operation unit .

Per fragment operation unit may cull pixels that are not viewable. For example a pixel of a further away object may be overlapped by a pixel of a closer object which per fragment operation unit may determine from a z buffer. The overlapping may cause the pixel of the further away object to be fully occluded. In this case per fragment operation unit may cull the overlapped pixel. Per fragment operation unit may also blend pixels together. For example an overlapping pixel may be translucent so that it does not fully occlude the overlapped pixel. In this case per fragment operation unit may blend the color of these pixels together.

The output of per fragment operation unit may be pixel values e.g. color for the pixels on the display. Per fragment operation unit may output the pixel values to frame buffer of system memory for temporary storage. Once frame buffer is full frame buffer may store the pixel values for each of the pixels on the display.

Frame buffer may be considered as a 2D array of storage locations. The number of storage locations with frame buffer may be at least equal to the number of pixels of a display. Also the storage locations within frame buffer may correspond to a location on the display. For example the top left storage location within frame buffer may correspond to the top left pixel of the display the storage location to the right of the top left storage location within frame buffer may correspond to the pixel to the right of the top left pixel of the display and so forth.

After the completion of the first glDraw command the storage locations located in the left half of frame buffer may store the pixel values for the left eye image because the left half of frame buffer may correspond to the left half of the display. Similarly after the completion of the second glDraw command the storage locations located in the right half of frame buffer may store the pixel values for the right eye image because the right half of frame buffer may correspond to the right half of the display. Therefore after completion of the first and second glDraw commands frame buffer may store the pixel values for the left eye image and the pixel values for the right eye image.

As illustrated in device may include application processor GPU system memory which includes frame buffer transceiver module user interface display and display processor . Application processor GPU and system memory may be substantially similar or identical to application processor GPU and system memory of . For purposes of brevity only the components that are shown in but not shown in are described in detail.

Device as illustrated in may include additional modules or units not shown in for purposes of clarity. For example device may include a speaker and a microphone neither of which are shown in to effectuate telephonic communications in examples where device is a mobile wireless telephone or a speaker where device is a media player. Furthermore the various modules and units shown in device may not be necessary in every example of device . For example user interface and display may be external to device in examples where device is a desktop computer or other device that is equipped to interface with an external user interface or display.

Examples of user interface include but are not limited to a trackball a mouse a keyboard and other types of input devices. User interface may also be a touch screen and may be incorporated as a part of display . Transceiver module may include circuitry to allow wireless or wired communication between device and another device or a network. Transceiver module may include one or more modulators demodulators amplifiers antennas and other such circuitry for wired or wireless communication. Display may comprise a liquid crystal display LCD an organic light emitting diode display OLED a cathode ray tube CRT display a plasma display a polarized display or another type of display device.

Display processor may be configured to cause display to display stereoscopic view. There may be various techniques that display processor may utilize to cause display to display stereoscopic view and aspects of this disclosure may utilize any of these techniques. For example display processor may retrieve the left eye image from the left half of frame buffer retrieve the right eye image from the right half of frame buffer and interleave the two images together to provide the stereoscopic view.

As another example display processor may control the refresh rate of display . In this example during each refresh cycle display processor may cycle between the left eye image and the right eye image. For instance display processor may retrieve the left eye image from the left half of frame buffer expand the left eye image to the entirety of display and display left eye image on display for one refresh cycle. Then for the next refresh cycle display processor may perform substantially similar functions but for the right eye image stored in the right half of frame buffer . In other words display may display the left eye image then the right eye image then the left eye image and so forth.

The viewer may be wearing specialized glasses that are synchronized with the refresh rate of display processor . For example while display is displaying the left eye image the specialized glasses may shutter close the right lens so that only the left eye of the viewer captures the left eye image. Then while display is displaying the right eye image the specialized glasses may shutter close the left lens so that only the right eye of the viewer captures the right eye image and so forth. If the refresh rate is fast enough the viewer perceives stereoscopic view where the image pops out of or pushes into display and encompasses a 3D volume.

In some examples some conventional display processors may not configured to cause display to display stereoscopic view. In these examples the viewer may couple device to a display that includes a display processor such as display processor which is configured to cause the display to present the stereoscopic view. For example the viewer may couple device to a stereoscopic view enabled television via transceiver module . For instance the viewer may couple transceiver module to the television via a high definition multimedia interface HDMI wire. In this example application processor or GPU may instruct transceiver module to transmit the pixel values stored in frame buffer to the display processor of the television. The display processor of this television may then cause the television to display the left eye and right eye images to form the stereoscopic view.

In these examples it may still be possible for the display of device to display the left eye and right eye images. However because display processor of device may not be able to cause display of device to present the stereoscopic view in this example display may display the left eye image and the right eye image side by side. For example the left half of display may display the left eye image and the right half of display may display the right eye image. This may be because of the viewport transformation described above. In this case even with specialized glasses the viewer may not experience the stereoscopic view simply by viewing display but would experience stereoscopic view by viewing the stereoscopic view enabled television.

A processor may receive instructions for a vertex shader that is designed to generate an image of a mono view and that is to be executed on a shader processor of a graphics processing unit GPU . For example application processor via the execution of graphics driver wrapper may receive instructions for vertex shader . As described above vertex shader may designed to generate graphics content for a mono view and may be designed to be executed on shader processor of GPU .

The processor may modify the instructions of the vertex shader to include one or more instruction that cause the vertex shader when executed on the shader processor of the GPU to generate graphics content for a first image of a stereoscopic view after a first execution of the vertex shader and graphics content for a second image of the stereoscopic view after a second execution of the vertex shader of a stereoscopic view . The first image may be the left eye image and the second image may be the right eye image.

For example graphics driver wrapper may receive the source code of vertex shader and may include the gl Position.x X command into the source code of vertex shader . Compiler may compile the modified source code of vertex shader to generate the object coded of modified vertex shader . Graphics driver wrapper may cause shader processor to execute the object code of modified vertex shader and may provide shader processor with the value of D for X. After graphics driver wrapper issues a first glDraw command graphics driver wrapper may cause shader processor to again execute the object code of modified vertex shader and may provide shader processor with the value of D for X.

A processor may modify a command that defines a viewport for the image of the mono view to a first command for a fixed function unit of the GPU that is different from the shader processor that defines a viewport for the first image and a second command for the fixed function unit of the GPU that defines a viewport for the second image . In this example the fixed function unit may be the viewport transformation unit of . As illustrated and described above viewport transformation unit is different from shader processor .

As one example graphics driver wrapper may modify the glViewport 0 0 width length command which was previously issued by application to glViewport 0 0 width 2 length command for rendering the left eye image and for rendering the right eye image graphics driver wrapper may modify the glViewport 0 0 width length command to glViewport width 2 0 width 2 length command. In some examples graphics driver wrapper may shift or shift and stretch the viewports for the first and second images as discussed above. In some examples graphics driver wrapper may shift or shift and stretch the viewport for the first and second images while modifying the instruction that defines the viewport for the mono view to define the viewports for the first and second images.

The following pseudo code provides an example of the functionality of graphics driver wrapper and application . This pseudo code is meant to assist with understanding and should not be considered limiting.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

