---

title: Join tuple assembly by partial specializations
abstract: Various embodiments of systems and methods for join tuple assembly by partial specializations are described herein. The join tuple assembly by partial specializations is a phase of the method for join query evaluation by semi-join reduction. By using partial specializations of the non-join part of the WHERE clause of a join query and matching sets, the join tuple assembly is organized in a manner that all computations are necessary, none are repeated, and failure to complete a partial join tuple to a full tuple is detected as early as possible. The method can be applied to inner and outer joins, and to arbitrary join graphs and non-join conditions in the WHERE clause. It can also be used outside the context of semi-join reductions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788482&OS=08788482&RS=08788482
owner: SAP AG
number: 08788482
owner_city: Walldorf
owner_country: DE
publication_date: 20120914
---
This application is a continuation application of U.S. patent application Ser. No. 12 781 855 filed May 18 2010 now U.S. Pat. No. 8 296 289 which is incorporated herein by reference.

Embodiments of the invention generally relate to the software arts and more specifically to methods and systems for join query evaluation by semi join reduction.

In the world of commercial computation a major part of all computation is devoted to join evaluation. The cost in evaluating joins is high as well with respect to memory consumption as to processing time. A common technique for reducing the amount of data is the use of semi joins. A join e.g. an SQL join combines two or more tables in a database producing a new one that can be saved as a table or used as an intermediate result of more complex computations. The join combines the fields from the two tables by using values that are common to each of them. A semi join is a binary operator on two relations. If these relations are R and S the result of the semi join of R with S is the set of all rows in R for which there is a row in S that is equal on their common attribute value. A relation is a data structure that consists of a heading an unordered set of attributes as columns in a table and a body an unordered set of rows that share the same type . In computer science a row represents an ordered list of attribute values. An n tuple is a sequence or an ordered list of n elements where n is a positive integer.

A semi join between two tables consists of rows from the first table where one or more matches are found in the second table. If there are two relations R and S the difference between the semi join of R with S and the join between R and S is the semi join is a subset of if alone whereas the join is a subset of the product R S. As a subset the semi join contains every row of R at most once. Even if S contains two matches for a row in R only one copy of the row in R is retained. Conceptually if J is the join between R and S the semi join is the projection of J to R.

A join query is typically processed in the following way first semi join reductions of the sizes of the joining relations are performed then the reduced relations are assembled to compute the join and finally from every tuple in the join the attributes referenced in the expressions in the SELECT clause are projected the expressions are evaluated and the results are returned to the user.

Various embodiments of systems and methods for join tuple assembly by partial specializations are described herein. In an embodiment the method includes receiving a join query a materialization graph representing a join part of the join query and a plurality of matching sets. The method further includes configuring a tuple construction counter which value indicates progression in an overall length of constructing a join tuple and an iterator that traverses through elements in a matching set from the plurality of matching sets. While the tuple construction counter value is a positive integer a partial specialization of an operator tree is computed wherein the operator tree represents a non join part of the join query. If the computed partial specialization satisfies the non join part of the join query and the tuple construction counter value is less than the overall length of the join tuple a subset of the plurality of matching sets are recomputed. Further if no empty matching set is encountered during recomputation the tuple construction counter value is increased.

In an embodiment the system includes a database storage unit for storing one or more of a plurality of matching sets derived from semi join reduction of a plurality of relations a join query and a materialization graph representing a join part of the join query. Further the system includes a processor in communication with the database storage unit that executes instructions including configuring a tuple construction counter which value indicates progression in an overall length of constructing a join tuple and an iterator that traverses through elements in a matching set from the plurality of matching sets. While the tuple construction counter value is a positive integer a partial specialization of an operator tree is computed wherein the operator tree represents a non join part of the join query. If the computed partial specialization satisfies the non join part of the join query and the tuple construction counter value is less than the overall length of the join tuple a subset of the plurality of matching sets are recomputed. Further if no empty matching set is encountered during recomputation the tuple construction counter value is increased.

These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for join tuple assembly by partial specializations are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

A method of query evaluation by semi join reduction is applied to the following query using the relations R R R R R R and R 

Table 1 shows an example of a join query based on the relations R R R R R R and R. The SELECT statement defines what data to be retrieved. In the example there is only one expression but this expression references attributes from all seven tables. For simplicity all these attributes are named as z . The FROM clause defines which relations are necessary to evaluate the join query . The WHERE clause includes one or more conditions that have to be fulfilled. Some of these conditions in the example all conditions except the last one are join conditions making the query a join query. Join query will join relations R R R R R R and R using the corresponding columns specified in the WHERE clause. For example the first condition of the WHERE clause is R a R a which means that columns with attribute a from relations R and R will be joined. This means that in every 7 tuple r r r r r r r R R R R R R Rsatisfying the complete WHERE clause the values in the a columns of Rand Rmust be equal. Analogously this is valid for the remaining join conditions of the WHERE clause.

All joins in join query are inner joins. An inner join is a common join operation used in applications and represents the default join type. The inner join creates a new result table by combining column values of two tables A and B based upon a join predicate. However the method can also be applied to left outer joins right outer joins and full outer joins. An outer join does not require each record in the two joined tables to have a matching record. The joined table retains each record even if no other matching record exists. The result of a left outer join or simply left join of table A with table B always contains all records of the left table A even if the join condition does not find any matching record in the right table B . A right outer join or right join closely resembles a left outer join except with the treatment of the tables reversed. A full outer join combines the results of both left and right outer joins.

The method of query evaluation by semi join reduction applied to the join query should result in a set of join tuples. Every join tuple is a 7 tuple r r r r r r r where ris a join tuple R rin R rin R rin R rin R rin R and rin R. Every such 7 tuple has to satisfy both the join conditions assembled in the join graph and the non join conditions assembled in the operator tree .

The second step of the method of query evaluation by semi join reduction is join tuple assembly. Its purpose is to construct all 7 tuples r r r r r r r R R R R R R Rsatisfying the complete WHERE clause of the SELECT statement or at least the needed number of 7 tuples if the query was a first k query. A first k query is a query where the size of the result is limited by the user for example the user may specify return only the first 20 rows of the result . For the join tuple assembly phase a materialization graph MG is constructed. The MG will be used to construct the join tuples satisfying the complete WHERE clause.

In general the choice of a good materialization sequence is an optimization issue. For simplicity reasons the natural order R R R R R R Ris used in the example. The sequence chosen is represented in the materialization graph by relabeling its vertices by their position in this sequence. For example Ris relabeled as 1 Rrelabeled as 2 and so on. If the materialization sequence was chosen to be R R R R R R R then the vertices would be relabeled in the following way Ras 5 Ras 2 Ras 7 and so on. Additionally the edges in MG are given a direction. The edges are made arrows pointing from lower numbered tail to higher numbered head. For example arrow a points from 1 to 2 where 1 is the tail of the arrow and 2 is the head of the arrow.

The query evaluation by semi join reduction is complete when all join tuples are assembled meaning that all 7 tuples r r r r r r r R R R R R R Rsatisfying the complete WHERE clause of the SELECT statement are known. For example the 7 tuple r 3 r 5 r 2 r 4 r 3 r 1 r 1 or just 3 5 2 4 3 1 1 satisfies the WHERE clause of join query . This can be verified in the following way first the join condition r a r a is checked for the rows r 3 and r 5. Looking into the reduced relations R and R since r 3 the row identifier for R is 3 which corresponds to the second row in table . Looking at the second row of table and at the a attribute it shows that r a 3. Again looking at the reduced relations R and R since r 5 the row identifier for R is 5 which corresponds to the second row in table . Looking at the second row of table and at the a attribute it shows that r a 3. Therefore r a 3 r a. The following list shows the verification of all join conditions of the WHERE clause on the 7 tuple given above.

When all join tuples are constructed their attributes referenced in the SELECT clause are fetched and the final answer is computed. For example corresponding to the 7 tuple 3 5 2 4 3 1 1 these are just the z values from which their sum is computed 10 0 12 12 4 20 14 72. 72 is therefore one element of the result returned by the query.

As mentioned above present an example of the method for query evaluation by semi join reduction. The query evaluation method includes several steps among which is the join tuple assembly. The standard techniques first construct all tuples satisfying the join part of the WHERE clause then select from these tuples those that additionally satisfy the non join conditions. This construction is expensive with respect to time and memory consumption. Depending on the data and the topology of the join graph e.g. cyclic joins certain obstacles can occur such as 1 perfect reduction of tables to the projections of the join by semi joins alone is challenged and 2 to flatten the join graph in the reduction phase into a tree by duplicating vertices leads to practical inefficiencies when afterwards in the assembly phase one has to secure the identity of the join tuple entries at the positions of the duplicated nodes. In these cases and also in the presence of non join conditions that can only be evaluated on the already evaluated join it is common in practice that the phase of join tuple assembly is the one consuming most of the computation time and or the phase with the highest memory consumption.

Embodiments of techniques for a join tuple assembly algorithm by partial specializations are described herein. For simplicity reasons the algorithm for a join tuple assembly is described using parts of the example introduced with . In an embodiment the algorithm is applied on a join query e.g. join query . The WHERE clause is divided into a join part and a non join part. The join part can be visualized as a join graph e.g. JG and the non join part can be visualized as an operator tree e.g. operator tree . The join tuples to be constructed should also satisfy the condition represented by the operator tree i.e. . In the operator tree the inner nodes are Boolean operators and the leaves are certain terms. Every term references some subset of the base relations R R . . . Rof the join.

A materialization graph G V A where V is a set of vertices and A is a set of arrows has been built that in general corresponds to a subgraph of the join graph. In the example MG corresponds to the full join graph. In general the materialization graph G is a directed graph on the vertex set V 1 2 3 . . . N where N N. In general every vertex n represents one base relation Rof the join graph e.g. JG . In the materialization graph G the relations are renamed as in MG . In the current example Ris 1 Ris 2 and so on. Here every arrow a A 

In an embodiment the underlying join graph part including a set of vertices V and a set of edges E where the set of edges E is obtained from a set of arrows A but without a direction may contain undirected cycles but not loops cycles of length 1 . Also every full subgraph G G 1 2 . . . n 1

In an embodiment an arrow has at most one predecessor. A predecessor of an arrow is another arrow that has the same head as the first arrow but the next lower tail. In the same example c has a predecessor namely b and b also has a predecessor namely a whereas a has no predecessor. a is not the predecessor of c since b is between them. This can be written as P c b P b a and P a .

In an embodiment matching sets from the reduction of the full relations R R R R R R and R are defined as part of the algorithm for join tuple assembly by partial specializations. For every vertex n V the matching set MRis the reduction result of the full table R. Additionally for every arrow a A 

In an embodiment the collection of all matching sets is defined as M. M contains exactly V sets of the form M exactly A sets of the form M and at most A sets of the form M. Further M contains at least one set of the form Mexactly when the materialization graph G contains unoriented cycles.

The definition of the matching sets also includes defining the head and tail functions on M as so far these are defined only for paths in G . In an embodiment M M is a matching set of the form M M or M. If M Mfor some vertex n V then h M n and t M 0. If M Mfor some path c a or c ab in G then h M h c and t M t c . These definitions lead to the following two consequences 1 for every matching set M there is MR where n h M and 2 for any n V there are matching sets M M with t M n exactly when n is not a sink a vertex of a directed graph with no outgoing arrows in G.

In an embodiment the above described head and tail functions on M are used to define an ordering on M. First the tail function is applied for all M M M t M 

In another embodiment the set M of all matching sets is subdivided using the head function for every vertex n V let M M M h M nM. Then M M M . . . M. This means that Mis a subset of matching sets from the collection M that have the same head and M is their disjoint union. Since M is already ordered every subset Mof M is also ordered. Thus it remains to make this ordering of Mexplicit for all M M M t M 

The ordering of Mis to be made explicit for matching sets of equal tails. This is done for all matching sets M Mhaving t M t where t is a fixed value with 1

The ordering in Mcan be written as M M M M . . . M r N where Mis placed before M which is placed before Mand so on till M. This expression provides the matching sets M which have the form M Mfor some path c a or c ab with an additional name M M where i 0 represents their position in the ordered collection M. These matching sets can be referred as higher matching sets . The first matching set M is the matching set already defined above as reduction result of relation R. Mis always placed first in M. The ordered collection Mhas some properties including 1 M Mfor all n V and 2 M 1 for all n 1.

In an embodiment the matching sets Mform a descending chain for any fixed n V of the type RMMM . . . M where r N. The descending order of this chain comes from the fact that their members satisfy successively more conditions that are necessary to qualify as the next element in a join tuple construction process. Elements for the construction process will only be taken from the last smallest set M but the intermediate chain members Malso represent valuable information. This information can be reused without being recomputed and accelerates the entire tuple construction process.

In an embodiment every matching set defined as part of the algorithm for join tuple assembly by partial specializations depends on some t tuple r r . . . r R R . . . R for 0

The matching sets are defined recursively in the order of M. The induction basis is formed by the reduction results M . . . M which are already defined and ordered first in M. In the ordering of M let M be the first matching set that is yet undefined. In an embodiment the first case is considered that M Mfor some arrow

In an embodiment is the operator tree e.g. operator tree representing those conditions of a join query that are not join conditions and cannot be evaluated before the join has been evaluated . For any N tuple r r . . . r R R . . . R a sequence of successive partial specializations of may be defined as follows let r r . . . r . In this case the full specialization of is either True or False at the latest. In an embodiment if some previous specialization has already been constant then all specializations that follow are identical to it and are constant.

The above definitions present matching sets of the form Monly in the case where there are two arrows a b A and the successor of arrow a is arrow b S a b. If arrow a has a tail m and a head n 

In an embodiment memory consumption can be greatly reduced by not explicitly storing all matching sets Mof the following descending chain RMMM . . . M where r N pertaining to some fixed vertex n V. It is enough to store Mand together with every element x x M an integer i 0

Additionally the computation of matching sets can be further decreased. Let M M be a matching set and t t M where M depends at most on r r . . . r. If M has been first computed for some t tuple r r . . . r and is later needed for a different t tuple r r . . . r then the attribute values of the rows of the relations that entered the computation from both t tuples are compared and it is checked if these attribute values are the same on r r . . . r as they were on r r . . . r . If they agree M does not need to be recomputed although r r . . . r changed. This leads to one more decrease in recomputation since repeated attribute values are quite common in practice.

At block a defined number of initializations are performed. In an embodiment the initializations include the following elements 1 a tuple construction counter t 2 an iterator it and 3 a trivial partial specialization of the operator tree . The tuple construction counter t indicates how far the algorithm has proceeded in building one more join tuple. For example if the relations are seven in number then 7 tuples r r . . . r are to be generated and the counter t indicates how far the construction of the current tuple has gone. For example if t 3 this means that a 2 tuple r r has been identified and constructed that can be completed to a 7 tuple r r . . . r and all conditions on rand rhave been checked and currently the algorithm will search for a suitable r. Initially t is 1 t 1 . The iterator is an object that allows the algorithm to traverse through all elements of a matching set such as iterator itand M. More iterators are used later in the algorithm such as ittraverses M ittraverses M ittraverses M ittraverses M ittraverses Mand ittraverses M. In general every iterator ittraverses the matching set ordered last in M.

At block the algorithm checks if the value of the counter t is a positive integer i.e. t 0. If the result from decision block is NO i.e. t 0 then the algorithm stops at block meaning that all tuples satisfying the complete WHERE clause of the join query have been identified as produced. If the result from decision block is YES then the algorithm continues at block . At block the iterator itis accessed. This iterator has been initialized either in block or in an earlier traversal of block . The row ris the row that itcurrently points to afterwards itis made to point to the next row in the matching set ittraverses if there is one r it it . When the value of the iterator increases the algorithm moves to the next row of the matching set. For example t 1 then itfirst points to 2 since here M 2 3. At block the partial specialization r is computed from . This means that the algorithm is at a specific row r of the table and there are some attribute values in this row which are taken to compute the partial specialization since attribute values the reduction results are given as input for the algorithm . The computation of r is performed by taking the attribute values from the specified row rand substituting these values into .

At decision block the algorithm checks if the computed partial specialization is False this is whether the operator tree has degenerated into the simple constant expression False. If the result from decision block is YES then the algorithm continues at block . At block while the counter t is a positive integer t 0 and the current iterator it points to the end of the matching set it traverses hence no row the value of the counter t is decreased by one or more count value. In an embodiment if for the original value of t itpoints to some row of its matching set then t remains unchanged. In another embodiment t can be decreased by more than 1. For example if t decreased from 5 to 3 this means that in the process of constructing the next join tuple there is a 4 tuple r r r r constructed which so far satisfies all necessary conditions and a suitable rhas to be found. However this may fail. Thus a better rhas to be found. But this may also fail so a better rwill be needed in that case. Therefore the algorithm resumes work on the current 2 tuple r r searching for a suitable ras part of a 3 tuple r r r that can be completed to a full N tuple r r r . . . r satisfying the WHERE clause. The algorithm is returned to decision block . If the result from decision block is NO then the algorithm continues at block . At decision block the algorithm checks whether the value of the tuple construction counter t is equal to N the needed length for a tuple to be completed which also equals the number of vertices in tire materialization graph. For example N 7 is the number of relations from which a row is materialized and thus the length of every valid tuple is 7.

If the result from decision block is YES then the algorithm continues at block . At block the tuple construction counter t is equal to the needed length t N i.e. another N tuple r r . . . r is obtained satisfying the complete WHERE clause. In an embodiment when a valid N tuple r r . . . r is found it can be used immediately during the algorithm. This could be the choice if for example the join result is used as input by another operation on a second computer. For example sending the join tuple to the second computer letting it begin its work immediately instead of waiting for the first computer to complete. In an alternative embodiment all found N tuples r r . . . r can be first collected and stored in a storage unit for later use.

If the result from decision block is NO then the algorithm continues at block . At this point the tuple constructed so far is shorter than a full TV tuple and the algorithm prepares for finding the rows that are still needed to complete the full tuple. At block all matching sets that depend on rare recomputed. These matching sets are identified by the condition that their tail equals t. At decision block the algorithm checks whether any one of the just recomputed matching sets turned empty. If the result from decision block is YES then the algorithm continues at block . This means that if there is an empty matching set then no full join tuple can be constructed from the current shorter tuple. At block while counter t is a positive integer t 0 and tire current iterator it points to the end of the matching set it traverses hence to no row the value of the tuple construction counter t is decreased. The algorithm returns to block and tries to find a new row rwith the decreased value of t.

If the result from decision block is NO then the algorithm continues at block . This means that there are no empty matching sets. At block the value of the counter t is increased by 1 as part of the loop indicating that the current tuple which is to be prolonged to a full N tuple has successfully been prolonged by 1. The algorithm is returned to block where the algorithm searches for a row r with the increased value of t. The algorithm terminates when t 0 indicating that all join tuples have been produced.

The algorithm accelerates the process of join tuple assembly in the method of semi join reduction such that the method itself becomes faster and when compared to other implementations also decreases memory consumption. The join tuple assembly process is accelerated by algorithm by using decision steps at several places e.g. blocks and checking as early as possible whether to stop the computation if it is clear that the current tuple cannot be completed. For example at decision block if the operator tree depending on r r . . . r is identical to False then there is no chance that the last operator tree could ever become True. Instead the algorithm is returned to block to find another rthat does not make the operator tree identical to False. Similarly at block if during recomputation of a subset of the matching sets an empty matching set is encountered then the algorithm is returned again to block because the algorithm is aware that at this place for some positions of the join tuple to be filled later there will be no eligible candidates. These are the earliest possible detections of future failures using only computations that may not be avoided hence causing no extra cost. In this way algorithm avoids redundant iterations in the loop and performing the same computation twice which reflects on the join tuple assembly acceleration.

Then the collection of all matching sets M is ordered using the computed head and tail functions at block . The ordering of the matching sets follows the definitions given above. First the matching sets that are not of the type Mare ordered these are the reduction results Mand the sets of type M. For these matching sets the order is first by ascending tail function and then for equal values of the tail function by ascending head function. These indications are sufficient since for these types of sets no two different sets have the same head and tail. Then every matching set Mis placed immediately after its corresponding set M. According to the example the resulting ordering is 

At block the collection of all matching sets M is divided into a number of sub collections containing matching sets with equal head function 

These sub collections can be renumbered to represent the order of a given matching set in a given sub collection. This is 

At block the matching sets Mwith i 0 are recursively defined using the reduction results Mas the induction basis. As set in the example of it is assumed that a 6 tuple r r r r r r R R R R R Ris given. The example of includes a 7 tuple r r r r r r r R R R R R r R but since the last vertex is a sink in the materialization graph reflecting a general property of all materialization graphs the last tuple i.e. r will never be used. The defined matching sets depend on appropriate parts of this 6 tuple. Simultaneously it is verified that the extent of dependency of the matching sets on the 6 tuple r r r r r r is correctly reproduced by the tail function as described above.

The definition of the higher matching sets begins by setting M M M a r . The predicate a is a x y x a y a for x R y R where the set a r depending on the first element rof the 6 tuple is a r x R x a r a so that matching set Mhas been defined M M x M s a r a. Hence M Mdepends on r but not on r r r r r. Since t M 1 this agrees with the following general observation if M M is a matching set with 0

The next matching set in the ordering of M is M M. The definition of Muses the previously defined M Mand M M M MM f M . The predicate fin f this example is f x y x f y f for x R y R. An explicit description of the set f M x R x f y f for some y M. Therefore the matching set Mcan be defined explicitly as M M x M x f y f for some y M. Since M Mand M Mboth depend on r but not on r r r r r the same is valid for M M in accordance with t M 1.

Analogously the following matching sets can be defined as all of them have a tail equal to 1 and depend on r but not on r r r r r.

Further in the ordering of M the matching sets with tail t M 2 are defined. These matching sets depend on r r but not on r r r r 

Further in the ordering of M the matching sets with tail t M 3 are defined. These matching sets depend on r r r but not on r r r 

Finally in the ordering of M the matching set with tail t M 4 is defined as in this example there is only one such matching set M M M l r . Similarly the matching set Mdepends on r r r r but not on r r. In this example of the method for join query evaluation there are no matching sets with tail t M 5 6 7 since these vertices are sinks in the materialization graph . That is why no matching set depends on ror r. However it should be noted that for other materialization graphs on 7 vertices matching sets with tail t M 5 6 may exist.

At block the join tuple assembly algorithm is initiated to construct all join tuples satisfying the complete WHERE clause each of them is a 7 tuple r r r r r r r R R R R R R R. At the outset their number is unknown both options are possible there might be no join tuples at all or there might be up to R R R R R R R join tuples. Their number also has to be determined by the algorithm.

At block the algorithm checks if the tuple construction counter is a positive integer. Since in the current example the tuple counter is a positive integer the loop of algorithm is entered. Executing r it it from block of algorithm leads to r 2 and itpointing to 3 M 2 3. At block the first partial specialization is computed. Using the attribute value r z 9 the partial specialization r of can be computed by substituting the attribute value into 9 

At block the tuple construction counter is checked if its value is equal to the needed length of any join tuple. Since currently t 1 and the needed length is 7 a full 7 tuple is not constructed and the method continues at block . Otherwise the method continues at block where the constructed full tuple is stored or used directly in some functionality. At block all matching sets with t M 1 are computed for the first time and recomputed on each next execution of the loop of algorithm this is those matching sets that depend on ronly. According to MG all arrows with tail 1 ordered by head ascending are 

Analogously the matching sets Mand Mare computed. Since M M x M x b r b and M M x M x c r c and r b 4 and r c 6 then M M x M x b 4 3 and M M x M x c 6 3.

Further the matching set M Mis computed. As defined above M M x M x f y f for some y M. Since M 3 in this case is a singleton a set with exactly one element the set y f y M 12 is also a singleton. Therefore M M x M x f 12 has to be evaluated. Since only row ID 4 in reduction table R satisfies this condition then M M 4.

Analogously the matching sets M M M and Mare computed M M x M x d r d x M x d 8 2 M M x M x g y g for some y M x M x g 9 4 M M x M x e r e x M x e 10 2 4 and M M x M x j y j for some y M. Although M 2 4 is a 2 element set these two rows happen to have identical j attributes and thus y j y M 12 and M M x M x j 12 3. The last computed matching set Mcan be interpreted as follows for r 2 only the subset 3 M MM 2 3 matches runder the join condition b MG since MM M and matches under join condition j MG some row in M which under join condition e MG matches r. Thus only the elements of M Msatisfy the stated necessary conditions for rto become completed to a full 7 tuple r r r r r r r R R R R R R Rsatisfying the complete WHERE clause.

At this point of the computation it is possible that the 1 tuple r 2 can be completed to a full 7 tuple r r r r r r r because 1 the first partial specialization is not False thus the complete specialization could become True and 2 all matching sets depending exactly on r these are M M M M M M M and M were computed and proven to be non empty sets thus rhas a consistent choice of join partners in all joins it participates in.

At block the tuple construction counter t is increased by 1 . This leads to t 2 which means that a 2 tuple r r is going to be constructed from the 1 tuple r 2 . Considering the following descending chain of matching sets RMMMM the iterator itpoints to row ID 4 M 4. Method is returned to block where algorithm is returned to the initial step of the loop as r 4 and itpoints to the end of M. Using the attribute value r z 5 the only attribute of Rreferenced in the next partial specialization r is computed as in block . Substituting the attribute value r z 5 into leads to 5 

As is not False all matching sets with tail t M 2 those matching sets that depend exactly on r are computed 

Similarly the 2 tuple r r could possibly be completed to a full 7 tuple r r r r r r r because of the same reasons 1 the second partial specialization is not False thus the complete specialization could become True and 2 all matching sets depending exactly on rwere computed and proven to be non empty sets. Therefore the tuple construction counter t is increased again to t 3 as in block . The method continues the loop considering the descending chain RMMMMMwith t 3 gets r 3 and itpointing to the end of M 3. Using the attribute value r x 14 the next partial specialization r is computed 14 

As is not False all matching sets with tail t M 5 those matching sets that depend exactly on r are computed 

Similarly the tuple construction counter is increased once more to t 4. Considering the descending chain RMMMMM on the next entry on the loop r 3 and itpointing to the end of M 3. Using the attribute value r z 10 the next partial specialization r is computed 10 1.5873 OR 10 0 This expression can be simplified to 

The second part of the expression becomes True since one sub part of it is True. Therefore R z R z R z 

Since is still not constant hence different from False all matching sets with tail t M 4 are computed those matching sets that depend exactly on r 2 r 4 r 3 r 3 . This is only one set 15 2

Further the tuple construction counter is increased to t 5. Considering the matching set chain RMMM and the iterator itpoints to the end of M 2. Using the attribute value r z 12 the next partial specialization r is computed 12 R z R z 

At this point of the example one of the partially specialized operator trees is False. The tuple construction counter remains unchanged at t 6 since at block itpoints to 4 M 2 4. Therefore the constructed tuple r 2 r 4 r 3 r 3 r 2 also remains unchanged and the computed matching sets with tail t M 

This means that the 6 tuple r 2 r 4 r 3 r 3 r 2 r 4 cannot be completed to any 7 tuple satisfying the complete WHERE clause. Additionally when r 2 r 4 r 3 r 3 r 2 are fixed there is no choice of a next r. Therefore even the 5 tuple r 2 r 4 r 3 r 3 r 2 cannot be completed to 7 tuple. Again when r 2 r 4 r 3 r 3 are fixed there is no choice of a next r. Therefore even the 4 tuple r 2 r 4 r 3 r 3 cannot be completed. This continues until it becomes evident that even the 1 tuple r 2 cannot be completed. Thus a new ris needed and since in the current scenario in contrast to the scenarios before a new rexists the algorithm decides to continue and not to stop as join tuples satisfying the WHERE clause could exist. Algorithm reflects this situation in step by decreasing the tuple construction counter from t 6 to t 1.

Method is then returned to block where tire loop is entered again. At this point r 3 and iterator itpointing to the end of Mare set. The last partial specialization used was . From this using the attribute value r z 10 the next partial specialization r is computed 10 

Since is not the constant expression False and t 1 did not yet reach the required level of N 7 the matching sets with tail t M 1 i.e. those matching sets that depend exactly on r 3 are recomputed. It should be noted that this cannot be avoided since rchanged and its attribute values also changed. At the same time all matching sets with tail less than t are not recomputed. In the specific examples where t scaled down from t 6 to t 1 this could be unnoticed since this leads to the event that only the reduction results Mare not recomputed having a tail of 0. If however t had only scaled down from t 6 to t 5 which indeed is the typical case all matching sets of tails 0 1 2 3 or 4 that is all matching sets would remain valid 

Following algorithm the tuple construction counter is increased to t 2 r 5 and the iterator itpoints to the end of M 5. Using the attribute value r z 0 the next partial specialization r is computed as in block . Substituting the attribute value r z 0 into leads to 0 1000 OR 0 z R0 As the second part of the Boolean expression is True the height of the operator tree decreases and becomes a one node tree 

Analogously the tuple construction counter is increased to t 3 r 2 and the iterator itpoints to the end of M 2. Using the attribute value r z 12 the next partial specialization r is computed as in block . Substituting the attribute value r z 12 into leads to 12 

Further the tuple construction counter is increased to t 4 r 4 and the iterator itpoints to the end of M 4. Using the attribute value r z 12 the next partial specialization r is computed as in block . Substituting the attribute value r z 12 into leads to 12 

Further the tuple construction counter is increased to t 5 r 3 and the iterator itpoints to row the end of M 3. Using the attribute value r z 4 the next partial specialization r is computed as in block . Substituting the attribute value r z 4 in leads to 4 

Since is not False and there are no matching sets to compute step of method is skipped and the algorithm proceeds with increasing the counter t as in step . Thus the tuple construction counter is increased to t 6 r 1 and the iterator itpoints to the end of M 1 5. Using the attribute value r z 20 the next partial specialization r is computed. Substituting the attribute value r z 20 into leads to 20 

Since is not False and there are no matching sets to compute step of method is skipped and the algorithm proceeds with increasing the counter t as in step . Thus the tuple construction counter is increased to t 7 r 1 and the iterator itpoints to tire end of M 1 Using the attribute value r z 14 the next partial specialization r is computed. Substituting the attribute value r z 14 into leads to 14

However there may be more than one full 7 tuple satisfying the complete WHERE clause of the join query. The algorithm continues to search for any other possible tuples. At block the tuple construction counter is decreased to t 6 so that all matching sets with tail t M 

Similarly the partial specialization is not False and since there are no matching sets to compute the algorithm proceeds with increasing the counter t as in step . Again the tuple construction counter is increased to t 7 and iterator itpoints to 1 M 1. It should be noted that the matching set Mis also reused without being recomputed since t M 4 the matching set Mdepends exactly on r 3 r 5 r 2 r 4 which did not change. The tuple construction counter is t 7 r 1 and the iterator itpoints to the end of M. Using the attribute value r z 14 the partial specialization r is computed. Substituting the attribute value r z 14 into leads to 14

It should be noted that in the example describing methods and in most cases the general relation MMwas satisfied by equality and that no matching set was ever encountered empty. This was due to the fact that the previous reduction of the full relations Rto the reduction results Mto was considered as perfect . This means that the reduction results Mto were as small as possible every Mequaled the projection of the solution of the join conditions alone to R. However a perfect reduction is not possible for all join graphs and all distributions of data. In the current example the failure of a partial tuple to complete to a full tuple was only caused by some partially specialized operator tree becoming False. However in other embodiments this could also be caused by some matching set becoming empty.

The algorithm for join tuple assembly by partial specializations handles the assembly phase of the method for join query evaluation by semijoin reduction. It improves it simultaneously with regard to time and space consumption. The algorithm is applicable to outer joins as well as to inner joins since the differences in the evaluation procedure derived from the join type occur only in the reduction phase which is before the join tuple assembly phase. Further the algorithm does not require flattening the join graph into a tree in the reduction phase by showing how to handle cycles in the assembly phase. In an embodiment the algorithm is suitable for first k queries and is applicable to pure join queries True . Moreover algorithm is not limited to the method of semi join reduction it can be used as a general method for evaluating any join query as previous reductions accelerate the method but are not a prerequisite the algorithm stays correct if in place of Many set S with M SRis taken. Finally algorithm is well suited to distributed computation. The row IDs in Mcan be distributed to distinct processors for possible completion to a join tuple if M is too small for this distribution the pairs of M Mcan be distributed and so on.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

