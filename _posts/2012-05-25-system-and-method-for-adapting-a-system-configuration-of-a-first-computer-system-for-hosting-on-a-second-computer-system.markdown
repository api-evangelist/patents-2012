---

title: System and method for adapting a system configuration of a first computer system for hosting on a second computer system
abstract: Some embodiments provide a method for a server hosting environment having several nodes. Each node is for using one or more hypervisors in order to host several configurations of several computer systems. The method receives a first configuration of a computer system. The first configuration includes an operating system that directly accesses hardware of the computer system. The method generates a second configuration that is based on the first configuration. The second configuration includes the first configuration modified to be operable on a particular hypervisor of a particular node in the several nodes. The method installs the second configuration on the particular node in order to allow the particular node to operate on the second configuration in conjunction with the particular hypervisor. The second configuration accesses a set of virtual hardware provided by the particular hypervisor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08533305&OS=08533305&RS=08533305
owner: Gogrid, LLC
number: 08533305
owner_city: San Francisco
owner_country: US
publication_date: 20120525
---
This patent application is a continuation application of U.S. patent application Ser. No. 12 421 611 filed Apr. 9 2009 now issued as U.S. Pat. No. 8 219 653. U.S. patent application Ser. No. 12 421 611 claims the benefit of the U.S. Provisional Patent Application 61 099 254 entitled System and Method for Automated Allocation and Configuration of Hosted Services filed Sep. 23 2008 the U.S. Provisional Patent Application 61 140 838 entitled System and Method for Automated Allocation and Configuration of Hosted Services filed Dec. 24 2008 the U.S. Provisional Patent Application 61 140 835 entitled Method and Apparatus for Adapting and Hosting a Configuration of a Computer System filed Dec. 24 2008 the U.S. Provisional Patent Application 61 145 962 entitled System and Method for Automated Allocation and Configuration of Hosted Services filed Jan. 20 2009 the U.S. Provisional Patent Application 61 145 965 entitled Method and Apparatus for Adapting and Hosting a Configuration of a Computer System filed Jan. 20 2009 the U.S. Provisional Patent Application 61 159 437 entitled System and Method for Automated Allocation and Configuration of Hosted Services filed Mar. 11 2009 and the U.S. Provisional Patent Application 61 159 438 entitled Method and Apparatus for Adapting and Hosting a Configuration of a Computer System filed Mar. 11 2009. All of the above enumerated Provisional Patent Applications and U.S. patent application Ser. No. 12 421 611 now issued as U.S. Pat. No. 8 219 653 are incorporated herein by reference.

The present invention relates to adapting a configuration that is operable on a first platform of a first computer system to be operable on a second platform of a second computer system.

Modern day computer systems have many levels of complexity over computer systems of the past. Traditionally a computer system included a hardware layer and a system configuration for interfacing with the hardware layer. A system configuration includes an operating system with a kernel layer on top of the hardware layer and interface application programs that facilitate operations of the operating system. Furthermore the system configuration defines individualized user settings that customize each of these software components per user specifications. For example the system configuration includes firewall settings for a firewall application of the operating system and display presentation settings for the graphical interface of the operating system.

However advancements in the field of virtualization have begun to blur the distinction between hardware and software. Through virtualization a virtualization engine also referred to as a hypervisor emulates the hardware layer as distributable sets of virtual hardware. The hypervisor can then allocate each set of virtual hardware to different system configurations thus allowing multiple distinct system configurations to reside on a single computer system.

As shown in virtualization allows a single computing device the ability to function as two or more different computing devices with each device having a distinct set of virtual hardware and a distinct system configuration. For instance system configuration may be allocated 40 of the memory and 80 of the processor cycles of the device and system configuration may be allocated the remaining 60 of the memory and 20 of the processor cycles of the device . Additionally the system configuration may operate using a first operating system with a first set of configuration parameters and the system configuration may operate using a second operating system with a second set of configuration parameters.

An added benefit of virtualization is that a failure in one set of virtual hardware or system configuration does not disrupt the operation of the other set of virtual hardware or system configurations even though the virtual hardware and the system configurations operate over physical resources of a single device. With reference to should any piece of the system configuration crash due to an improper setting the system configuration will continue operating unhindered as the resources used by each system configuration or system configuration operate independent of one another.

At the core of each virtualization solution is the hypervisor. The hypervisor manages a logical partitioning of a physical set of hardware resources of a physical device or platform between different virtualized guests e.g. configurations . Each virtualized guest implements one or more virtual machines over a logical partition. The hypervisor partitions underlying hardware resources such that each virtual machine is provided what logically appears as a distinct and unshared set of hardware resources. However the hypervisor maps the virtual machine hardware calls to a corresponding subset of physical hardware resources that are actually shared by all virtual machines operating on a particular hardware platform.

The hypervisor is thus responsible for mapping the hardware resources of a platform to a set of virtual resources that can then be distributed independently to one or more system configurations that together form the one or more virtual machines. In this manner each virtual machine effectively is provided its own resources e.g. a processor memory block device disk storage networking etc. and the operating system of each virtual machine operates with little to no change over the provided set of resources.

Different vendors implement hypervisors differently e.g. Xen Parallels VMware Kernel Virtual Machine KVM etc. . Specifically two prominent hypervisor types are defined as type 1 hypervisors and type 2 hypervisors which are further described with reference to .

The second exploded view illustrates a platform of a computer system in which a type 1 hypervisor is present. The type 1 hypervisor interfaces with the physical hardware of the computer and provides a set of virtual hardware to the system configuration . Thus the system configuration interfaces with the virtual hardware provided by the type 1 hypervisor which itself directly accesses the physical hardware of the computer system .

The third exploded view illustrates a platform of a computer system in which a type 2 hypervisor is present. The platform includes a host kernel layer on top of the physical hardware and a host operating system on top of the host kernel layer . This platform also includes an application layer not shown on top of the operating system layer. Additionally the platform includes a type 2 hypervisor which interfaces with the host operating system . This type 2 hypervisor may be one of the applications in the application layer not shown on top of the host operating system . The type 2 hypervisor is allocated a set of the physical resources by the host operating system . Accordingly the system configuration interfaces with virtual hardware provided by the type 2 hypervisor which itself receives a set of hardware resources from the host operating system .

The computer system shown in the exploded view may be considered a traditional computer system e.g. a traditional computer system as shown in the exploded view with the type 2 hypervisor as one of the applications in the application layer. In other words the computer system of this exploded view may be considered a traditional computer system with system configurations stacked on one another.

Hosting services allow users to implement their system configurations e.g. system configuration on remote computer systems without the pitfalls associated with owning and maintaining the hardware platforms on which the system configurations run. These pitfalls include overhead costs associated with purchasing upgrading and or maintaining equipment and software needed to implement the system configuration. Instead of a user burdening him or herself with these headaches a hosting service provider maintains and provisions a grid of hardware nodes that are shared amongst multiple users. More specifically resources of a single node can be partitioned and each of these partitions can be allocated to a virtual server configuration of a different user.

In order to host a system configuration some hosting systems allow a user to set up the system configuration from scratch. In other words the user selects one operating system from multiple different operating systems. The user can then custom configure the operating system by changing configuration parameters or by installing other interface applications to run in conjunction with the operating system. This methodology is problematic however when the user already has set up his or her system configuration on another computer e.g. his or her own home computer or another hosting service and wants to host it at the hosting system.

Therefore there is a need in the art for a method of adapting a system configuration of a computer system in order to host the system configuration in a server hosting environment. There is further a need to adapt a system configuration that is hosted in one server hosting environment in order to host the system configuration in a different server hosting environment.

Some embodiments provide an adaptation engine for adapting a system configuration that is operating as a virtual machine on a first computer system hosting one or more virtual machines to operate as a virtual machine on a second computer system hosting one or more virtual machines. The system configuration of some embodiments includes an operating system a kernel a set of drivers and user specified configuration settings for these software components of the system configuration. In some embodiments a virtualization engine e.g. a hypervisor interfaces with a set of physical hardware components e.g. memory processor hard drive network card etc. of a computer system and provides a set of virtual hardware that the system configuration interfaces with in order to implement the user virtual machine.

Some embodiments provide a method for adapting a system configuration that is operating directly on a first computer system to allow the system configuration to operate as a virtual machine on a second computer system hosting one or more virtual machines. In some such embodiments the system configuration directly accesses one or more physical hardware components of the first computer system. More specifically the system configuration includes an operating system and or kernel that directly accesses e.g. using a set of device drivers that correspond to the one or more hardware components the one or more physical hardware components of the first computer system. In other words the system configuration does not access the one or more physical hardware components of the first computer system as a set of virtualized hardware where the set of virtualized hardware is managed by a virtualization engine.

Some embodiments provide a method for adapting a system configuration operating in a first hosting environment to operate in a second hosting environment. The second hosting environment which hosts the adapted system configuration is separate from the first hosting environment e.g. operated by a different hosting system .

In order to adapt a system configuration operating on a first machine to be operable on a second machine some embodiments replace an original or source kernel of the system configuration with a new destination kernel. In some embodiments this replacement is performed automatically by the adaptation engine e.g. a software module running on the second machine without human intervention. Each of these kernels provides an interface between an operating system of the system configuration and a set of hardware components either virtual or physical of a machine on which the system configuration operates. In some embodiments the new kernel includes the same interface to the operating system of the system configuration as the original kernel but a different interface to hardware. In other words the new kernel includes an interface to a set of hardware components of the second machine while the original kernel includes an interface to a set of hardware components of the first machine.

In some embodiments replacing a kernel of a source kernel includes retrieving a destination kernel from a library that stores multiple kernels. Additionally in some embodiments replacing a source kernel includes modifying one or more components e.g. one or more core libraries such as a C library or a device manager of the source kernel.

In lieu of or in addition to replacing a kernel of a system configuration some embodiments import one or more device drivers into the system configuration. In some embodiments this importing of device drivers is performed automatically by the adaptation engine without human intervention. The imported device drivers each correspond to one or more hardware components either virtual or physical of the second machine.

In some embodiments one or more of the device drivers are previously generated e.g. by a manufacturer of the device to which the device driver corresponds . Some other embodiments automatically generate one or more of the device drivers through a development environment of an operating system and kernel of the system configuration. Still other embodiments generate the device driver s through a driver application programming interface API based on 1 an operating system of the system configuration and 2 the hardware components of the second machine. The generated device drivers replace corresponding drivers e.g. drivers of the same device type in the source system configuration.

Some embodiments provide a method for determining whether to replace a kernel or to import a set of device drivers as mentioned above in order to adapt a system configuration that is operable on a first machine to be operable on a second machine. The method analyzes a set of attributes of the system configuration e.g. operating system and or kernel of the system configuration in order to make the determination. Based on one or more of these attributes the method determines that the system configuration can be imported in order to adapt the system configuration to be operable on the second machine by 1 replacing the kernel of the system configuration and or 2 importing one or more device drivers into the system configuration.

Some embodiments provide an extraction engine that extracts attributes of a system configuration that operates on a first machine either on a virtual machine or directly on a computer system in order to allow the system configuration to be adapted to operate on a second machine. The extraction engine of some embodiments analyzes the system configuration in order to determine relevant attributes e.g. operating system kernel version device drivers number of hard drives number of processors IP address hostname etc. . Additionally the extraction engine of some embodiments provides these attributes to the adaptation engine which adapts the system configuration to be operable on the second machine. In some embodiments the extraction engine provides an entire file system of the system configuration e.g. some or all contents of storage devices used by the configuration to the adaptation engine.

In some embodiments the first machine locally runs an extraction engine that analyzes and extracts the system configuration of the first machine. In some other embodiments a remote extraction engine analyzes and extracts the system configuration of the first machine where the remote extraction engine is an engine that runs on a different machine that is separate from the first machine. The remote extraction engine remotely accesses the first machine through a network e.g. the Internet .

Some embodiments utilize a library that stores information as to customized settings of operating systems kernels drivers development environments and or kernel driver APIs in order to adapt a system configuration operating on a first machine either on a virtual machine or directly on a computer system to be operable on a second machine. In some embodiments the configuration information stored in the library is used by one or more of the processes described above e.g. replacing a kernel of the system configuration importing a set of device drivers into the system configuration etc. . The library of some embodiments is adaptive. In other words information that is generated when adapting a system configuration that is operable on a first machine to be operable on a second machine can be stored in the library. This stored information can then be retrieved and reused at a later time instead of necessitating that the same information be generated again if it is needed again.

In the following description numerous details are set forth for purpose of explanation. However one of ordinary skill in the art will realize that the invention may be practiced without the use of these specific details. For instance well known structures and devices are shown in block diagram form in order not to obscure the description of the invention with unnecessary detail.

Some embodiments provide a method for adapting a system configuration that is operable on a first platform also referred to as a source platform to operate on a second platform also referred to as a destination platform . The system configuration includes an operating system with a kernel device drivers and interface applications of the operating system that facilitate operations of the operating system. Additionally the system configuration includes user settings that customize the look behavior and operations of the operating system kernel device drivers or interface applications. Accordingly the adaptation performed by some embodiments occurs relative to a user s actual machine configuration. This is in contrast to adapting clean versions of an operating system kernel device drivers and interface applications whereby a user has to reapply all previously applied custom settings in order for the adapted destination system configuration to operate in the same manner as the user s source system configuration.

The process begins by extracting at the source system configuration from the source platform. As further described below with reference to in some embodiments the source platform locally runs an extraction engine that extracts the system configuration from the first platform while in other embodiments a remote extraction engine i.e. an engine that runs on a platform that is separate from the source platform extracts the system configuration from the source platform. The remote extraction engine of some embodiments accesses the source platform through a network e.g. the Internet . The remote extraction engine optionally performs an authentication procedure e.g. provides a log in name and or password that indicates to the source platform that the remote extraction engine is authorized to access the source platform. In some embodiments the extraction engine extracts an entire file system of the system configuration e.g. entire contents of a set of storage devices used by the system configuration to a data store for later analysis. In some other embodiments the extraction engine extracts only necessary elements for a system configuration.

The process analyzes at the extracted source system configuration. This analysis at determines whether any additional data is required from a library e.g. the library of which is further described below that stores information e.g. operating systems kernels drivers etc. used for adapting system configurations to be operable on the destination platform. In some embodiments this analysis at also determines what modifications if any are necessary to the source system configuration in order to adapt the source system configuration to be operable on the destination platform. For example adapting the source system configuration may require modifying the operating system layer the kernel layer or the device driver layer of the source system configuration. Upon determining at that required data is present in the library the process retrieves at the necessary data. The library of some embodiments and its contents are further described in more detail below.

The process then modifies at the source system configuration and or the data retrieved from the library. As noted above modifying the source system configuration and or data includes modifying a kernel and or operating system of the source system configuration. For example some embodiments replace an original kernel of the system configuration with a new kernel. The new kernel includes the same interface to the operating system of the system configuration as the original kernel but a different interface to hardware. In other words the new kernel includes an interface to a set of hardware components of the destination platform while the original kernel includes an interface to a set of hardware components of the source platform. In some embodiments the new kernel is a kernel that was modified at while in some embodiments the new kernel is a kernel that was retrieved at from the library.

Some embodiments modify the source system configuration by importing one or more device drivers into the system configuration. The imported device drivers each correspond to one or more hardware components either virtual or physical of the destination platform. In some embodiments one or more of the device drivers are previously generated e.g. by a manufacturer of the device to which the device driver corresponds . Such drivers may have been previously retrieved at from the library. Other embodiments generate one or more of the device drivers e.g. through a development environment of a kernel and operating system of the system configuration or through a driver application programming interface API both of which may be retrieved at from the library based on 1 an operating system of the system configuration and 2 the hardware components of the destination platform.

Some embodiments provide a method for determining whether to replace a kernel and or to import a set of device drivers as mentioned above in order to adapt the system configuration be operable on the destination platform. The method of some embodiments analyzes a set of attributes of the system configuration e.g. operating system and or kernel of the system configuration in order to make the determination. In some embodiments this set of attributes is provided by an extraction engine as discussed above. Based on one or more of these attributes the method of some embodiments determines that the system configuration can be imported in order to adapt the system configuration to be operable on the second platform by 1 replacing the kernel of the system configuration and or 2 importing one or more device drivers into the system configuration.

Using the modifications and or information from the library the process generates at a destination system configuration that is operable on the destination platform. In some embodiments the library from which data is retrieved at is an adaptive library. In some of these embodiments the process stores at any modifications that were made at into the adaptive library. This stored information can then be retrieved at a later time instead of necessitating that the same information be generated again if it is needed again. In this way the adaptive library is constantly growing as it learns new information about adaptation processes. Future adaptation processes thus occur more quickly as information that was generated through a previous adaptation process is retrieved from the adaptive library. The adaptive library of some embodiments is further described below in Section V.

The process then outputs at the destination system configuration to the destination platform for installation on the destination platform. Finally the process ends.

As discussed above with reference to a system configuration includes 1 an operating system 2 a kernel 3 a set of device drivers and or 4 a set of interface application programs that operate in conjunction with the operating system. In some embodiments a system configuration does not include one or more of these software elements. In some embodiments the system configuration includes other software elements not specifically enumerated above.

Also as discussed above with reference to a platform or a machine includes 1 physical hardware of a computer system and or 2 a virtualization engine that provides a set of virtual hardware components to the system configuration. A virtualization engine of some embodiments includes a type 1 hypervisor that accesses or resides on physical hardware of a computer system and or a type 2 hypervisor that resides on a host operating system and kernel of a computer system which itself accesses physical hardware of the computer system .

A system configuration that operates on physical hardware of a computer system directly accesses one or more hardware components e.g. memory central processing unit CPU hard drive etc. of the computer system. On the other hand a system configuration of some embodiments that operates on a hypervisor either type 1 or type 2 does not directly access one or more hardware components of the computer system. Rather the system configuration accesses a set of virtual hardware components that are managed by the hypervisor.

In some embodiments a platform e.g. the source platform and or the destination platform is a node in a grid of nodes e.g. a node in a server hosting environment . In other embodiments a platform is a single desktop computer system that is not a node in the grid of nodes.

Some embodiments adapt a source system configuration operable on any type of platform e.g. any of the three types of platforms described above with reference to such that it is made operable on any type of platform e.g. any of the three types of platforms mentioned above with reference to including the same type of platform. For example some embodiments adapt a system configuration that is operable on physical hardware of a source computer system to be operable on a type 1 hypervisor that operates on physical hardware of a destination computer system. Additionally some embodiments adapt a system configuration that is operable on a type 1 hypervisor that operates on physical hardware of a source computer system to be operable on a type 1 hypervisor that operates on physical hardware of a destination computer system. Moreover in addition to these two examples one of ordinary skill in the art would recognize that any other combination of types of source and destination platforms is possible.

Several more detailed embodiments of the invention are described in the sections below. Before describing these embodiments further an overview of a server hosting system architecture of some embodiments is provided in Section II below. This discussion is followed by Section III which discusses local and remote extraction of a source system configuration. Section IV then describes a process by which an adaptation engine adapts a system configuration that is operable on a source platform to be operable on a destination platform. Next Section V discusses an adaptive library of some embodiments. Then Section VI describes advantages of some embodiments of the invention. Lastly Section VII describes a computer system of some embodiments.

The service request server 1 receives communications i.e. service requests from external users through a network and 2 routes the communications to the front end provisioning manager . In some embodiments the service request server is a web server which communicates to a user through a network such as the Internet. Specifically in such embodiments a user accesses the hosting system through the user s web browser or through a downloadable client application which may reside on the user s computer. The user s computer of some embodiments is a particular machine such as a general purpose desktop computer portable notebook computer personal digital assistant PDA digital cellular telephone or other electronic device that is capable of communicating through the network .

In some embodiments the network is a local area network LAN an intranet and or a network of networks such as the Internet. The network of some embodiments also includes wireless data services e.g. general packet radio service GPRS or other variations of 2G or 3G packet data services or other electronic communication interfaces. In this manner users can access the hosting system while being located anywhere throughout the world.

The service request server routes user communications to the front end provisioning manager . On an initial communication the front end provisioning manager passes the user communication to a registration module not shown for user verification and authentication e.g. username and password verification . In some embodiments the registration module is a fully automated component of the hosting system that performs the verification and authentication operations without human intervention.

When the user cannot authenticate him or herself e.g is not an existing customer of the hosting system the registration module of some embodiments presents a graphical interface with editable fields through which the user enters additional identification information for creating a user account. The user specified information is then stored within data storage for subsequent authentication and authorization of the user. When the user can authenticate him or herself e.g. is an existing customer the user s prior system configuration s also referred to as virtual machine configurations and or usage information is are retrieved from the data storage i.e. database . The retrieved information is passed to the front end provisioning manager .

The front end provisioning manager is responsible for generating a graphical user interface GUI through which a user may specify graphical representations for various virtual machine configurations. In some embodiments the graphical representations contain sets of selected graphical items e.g. icons where each item represents a component of the system configuration. For instance a user desiring to create a system configuration having a load balancer multiple web servers and a database server simply selects the three graphical elements within the GUI that represent such components. In some embodiments such selection occurs when a user clicks e.g. left clicks right clicks double clicks etc. on items within the graphical display to add modify or delete the graphical representations for these items while some other embodiments allow users the ability to drag and drop the graphical representations for these items across the graphical display. In some embodiments each graphical representation includes one or more configurable parameters associated with configuring resources or characteristics of a physical device in the grid of nodes represented by the graphical representation.

In some embodiments the specified system configuration is scalable to increase or decrease allocated resources in response to demand through simple modification of the graphical representation. To facilitate the scaling of a system configuration the front end provisioning manager acts as a user interface manager that provides a tiered hierarchical representation of the system configuration.

Some embodiments of the front end manager further permit users the ability to specify custom settings for each component of the system configuration or for the system configuration as a whole. For instance the front end manager of some embodiments allows users the ability to specify a desired set of software e.g. operating systems anti virus protection anti spam protection applications etc. to operate in conjunction with the specified hardware configuration. In addition to specifying the operating system and applications to include within the user system configuration some embodiments permit users the ability to further specify settings within the selected operating system and applications. For instance a user can enter network addresses for load balancers and firewalls or specify hostnames.

After the graphical specification for the system configuration is complete some embodiments of the front end manager automatically provide the system configuration to the hosting system s back end logic which is formed by the resource management system module and the hypervisor management module .

In lieu of or in addition to selecting a system configuration and parameters using the front end manager a user uploads his or her own system configuration for hosting. The extraction engine of some embodiments allows users the ability to identify a system configuration of a user s platform in order to migrate the system configuration into the hosting system . In some embodiments identifying includes uploading a system configuration package that includes an image i.e. the entire file system and or attributes of the configuration s file system in some embodiments. Moreover the identifying of some embodiments includes identifying the user s platform e.g. an IP address of the platform and providing authentication credentials e.g. log in name and password in order to allow the platform to be accessed and the system configuration i.e. entire file system image and or relevant attributes of the system configuration to be extracted by the extraction engine .

The extraction engine supplies the extracted image and or attributes to the extracted configuration store and or image store database for later retrieval. The extraction engine also supplies the extracted image and or the attributes to the resource management system module which identifies resources required by the system configuration e.g. by determining attributes of the system configuration such as number of processors amount of storage space needed etc. .

The resource management system module of some embodiments of the back end logic receives the specified system configuration from the front end manager or the extraction engine . Alternatively the resource management system module of some embodiments receives the specified system configuration from the extracted image store . The resource management system module of some embodiments performs a logical assignment i.e. identifies a mapping of the components within the system configuration to the grid of hardware nodes . This logical assignment identifies a set of resources e.g. RAM hard drive space etc. required by the system configuration.

In some embodiments the logical assignment is stored within the data storage where it can be later accessed by other components of the hosting system . The data storage of some embodiments includes one or more databases that reside on one or more particular machines e.g. data storage devices of a computer system .

The hypervisor management module of some embodiments receives the logical assignment from the resource management system module or from the data storage after the resource management system module stores the logical assignment in the data storage .

As further described in the concurrently filed U.S. patent application Ser. No. 12 421 604 entitled Automated System and Method to Customize and Install Virtual Machine Configurations for Hosting in a Hosting Environment the hypervisor management module then automatically deploys the logical assignment across one or more of the physical hardware nodes . U.S. patent application Ser. No. 12 421 604 is hereby incorporated by reference.

In some embodiments the hypervisor management module acts as a virtualization manager to emulate a single virtual machine as if it existed on a single hardware node even though the hypervisor management module may physically leverage the resources of multiple nodes to host the single system configuration. Additionally a single functional component of the system configuration may be virtualized by distributing its functionality across multiple nodes . For instance when a database server of a system configuration requires a large allocation of disk space the hypervisor management module may deploy this database server over two nodes such that the disk space of any one node is not proportionally used by the database server.

The hypervisor management module automatically allocates the logical assignment across one or more of the physical hardware nodes by interfacing with a hypervisor operating on each node. The hypervisor manages the allocation of resources at the individual node level whereas the hypervisor management module of some embodiments manages the allocation of resources at the grid level for all nodes within the grid . Accordingly the hypervisor of each node allows for a non conflicting provisioning of a node s resources to two or more virtual machines and the hypervisor management module allows several such nodes with multiple virtual machines to operate seamlessly together.

Also operating on each node is a utility management module UVM of some embodiments. As described in further detail in the concurrently filed U.S. patent application Ser. No. 12 421 604 the UVM is a utility manager that customizes the resources allocated by the hypervisor management module . The UVM custom configures the resources based on a user virtual machine system configuration specified modified through the front end manager or received from the extraction engine . The UVM of some embodiments also includes an adaptation engine which receives extracted system configurations from the extracted configuration store and adapts them to be operable on the hypervisor of the node. In some embodiments the hypervisor management module instructs the UVM to retrieve the extracted system configurations from the extracted configuration store and or the image store database .

The UVM optimizes and customizes the system configurations by receiving adapted system configurations or retrieving system configuration images from an image store database and modifying the retrieved image according to user specifications. The UVM of some embodiments also performs other operations e.g. making an adapted system configuration bootable on the hypervisor . In this manner the UVM permits each virtual machine system configuration operating on a node of the grid to be unique based on 1 a user s extracted system configuration and or 2 user parameters specified through the graphical user interface of the front end logic.

In some embodiments the image store database is a database storing several operating system software images and or software images for applications to run in conjunction with the operating system of a virtual machine configuration. Additionally in some embodiments image store database physically represents a single database that stores single server appliances and multi server appliances.

A single server appliance is a stand alone image. Such a single server appliance includes a single operating system image or a single software application image. In other words a single server appliance represents a single element of a virtual machine.

A multi server appliance is an image composed of a combination of one or more operating system images and application program images. A multi server appliance represents all or some of the elements of a virtual machine deployed within the hosting system s grid of nodes. In some embodiments a multi server appliance specifies a tiered organization for the elements of a virtual machine. For example the multi server appliance may include two web servers at a first tier that interact with an application server at a second tier.

The images in the image store database are provided by the hosting system provider or by users of the hosting system. For instance some users specify virtual machine configurations that include an operating system and various commonly used applications that are configured to optimally operate with the operating system. Also as further discussed below the images in the image store database may be adapted system configurations supplied by an adaptation module of a node. By storing these system configurations within the image store database the system configurations and more specifically the optimizations made to the system configurations can be reused when instantiating virtual machines for other users.

Some embodiments provide means by which users may submit images to the image store database using a graphical interface of the front end logic of the hosting system. illustrates a graphical interface in accordance with some embodiments by which users of the hosting system submit images that may be used by other users of the hosting system. The front end logic of some embodiments described above generates the graphical interface . The interface includes an image selection tool and a set of tags .

The image selection tool selects the image that the user desires to submit to the image database of the hosting system provider. When selected the image selection tool opens a browser window from which the user navigates to select an image that can then be shared with other users of the hosting system. In some embodiments the image selection tool may be used to select a user s virtual machine that has already been adapted configured and deployed to a specific node within the grid of nodes of the hosting system. Once the virtual machine is selected the corresponding image for the virtual machine is stored within the image store database such that the image is directly accessible by other subsequent users that define virtual machine configurations through the front end logic of some embodiments.

In some embodiments the image selection tool is a drag and drop field within the graphical interface . To upload an image users drag an icon or other representation of a desired image and drop the representation within the area of the image selection tool .

Instead of submitting whole operating system images or software application images some embodiments allow users to submit parameters for modifying generic unmodified images of operating systems or application programs. Accordingly in some such embodiments the image store database stores unmodified images and sets of parameters or configuration files that are used to modify parameters of the unmodified images. Users submit the parameters or configuration files using an interface similar to interface of .

Some embodiments then allow subsequent users the ability to select between previously submitted images or previously submitted configuration files for unmodified images that are stored in the image store database . Specifically when a user specifies a virtual machine system configuration through the front end logic of the hosting system the user is presented a graphical interface from which to select between the various user submitted images or user submitted configuration files. The user then selects an image or configuration file that best suits the user s needs.

To assist a user in selecting an appropriate image some embodiments provide various performance metrics for each of the submitted images. In some embodiments other users who have integrated the various images or configuration files into their virtual machines and have monitored the performance and effectiveness of the images provide some of the performance metrics.

The performance metrics allow users to select between images that are known to be effective or that are known to provide a specified level of performance based on previous users experiences. It should be apparent to one of ordinary skill in the art that even though the interface of is described for selecting between images the same interface is adaptable for selecting between different configuration files for unmodified images that are stored within the image store database .

The extraction engine is communicatively coupled to one or more user computer systems e.g. physical computer systems or virtual machines . While a single extraction engine is shown in this figure some embodiments provide an extraction engine locally at one or more of the computer systems . The extraction engine interfaces with these computer systems in order to generate system configuration packages which include images of file systems of the system configurations and or attributes of the system configurations of the computer systems . The extraction engine provides these system configuration packages to the adaptation engines of nodes for which the system configuration packages are intended. As described above with reference to a hypervisor management module e.g. hypervisor management module of some embodiments makes this determination in conjunction with a resource management server e.g. resource management server .

A particular node includes a platform . The platform may be any type of platform e.g. one of the platforms enumerated in such as a virtualized platform which runs one or more system configurations on a hypervisor . The node runs several virtual machine system configurations . The node includes a UVM which includes an adaptation engine e.g. the adaptation engine of . As mentioned above the adaptation engine receives a system configuration package from an extraction engine and or an extracted image store and generates an adapted system configuration which is operable on the platform . This adapted system configuration is then run by the node as the virtual machine system configuration . In order to perform this adaptation the adaptation engine of some embodiments retrieves information from the library .

The library of some embodiments is made up of sub libraries. These sub libraries include 1 a library that stores multiple computer system core kernels also referred to as a core kernel library that stores kernels separately from third party drivers 2 a device driver library 3 an operating system library and or 4 a development environment library that stores development environments also known as clean versions of kernels and operating systems e.g. versions that are unchanged compared to versions released by vendors and or original developers of the operating systems and kernels . The adaptation engine of some embodiments uses information from some or all of these sub libraries when performing an adaptation of a source system configuration to be operable on a destination platform. In some embodiments the library is implemented as part of a file store array that is made up of many data storage devices e.g. hard drives used by a server hosting system.

In some embodiments the library is coupled to the workstation through which the library may be managed. Data e.g. kernels device drivers etc. may be manually added to or deleted from the library . Additionally the library of some embodiments is an adaptive library and data may be automatically added to the library. For examples when a device driver is updated by the manufacturer of the device the driver may be automatically downloaded from the device manufacturer s website and added to the driver library . Additionally the adaptive library of some embodiments receives new information to store from the adaptation engine when the adaptation engine generates new information.

While not explicitly shown in the figure one or more of the interfaces between the various components shown in is a network interface. In some embodiments the network interface is through a LAN a network of networks such as the Internet a wireless cellular telecommunication network such as GPRS or any other type of network. Moreover as mentioned above one or more of the components described above such as the extraction engine have a programmatic interface on a single computer system with each other in some embodiments.

It should be apparent to one of ordinary skill in the art that the grid of hardware nodes includes several distinct physical servers or clusters of servers located in a single server farm or distributed across multiple server farms in multiple disparate locations. Accordingly the grid of hardware nodes of some embodiments represents a cloud of computing resources shareable by multiple users. One of ordinary skill will appreciate that servers in other embodiments encompass any standalone computational element that can process requests it receives.

In some embodiments the grid of hardware nodes is uniformly used to implement all components of a system configuration. However some embodiments segregate various functionalities across groups of nodes. For instance in some embodiments a first grouping or cluster of nodes is used to implement the load balancing servers of a system configuration and a second grouping or cluster of nodes are used to implement other server components e.g. web servers database servers etc. of the system configuration. In some such embodiments the load balancing servers are dedicated F5 load balancing server appliances that can be configured to work in conjunction with the other nodes of the grid.

In some embodiments the grid of nodes contains an inter communication pathway by which each node shares data with other nodes of the array and the hypervisor management module. Through the inter communication pathway physically separated nodes together operate as a single functional unit.

Additionally as mentioned above the various physical resources of each node can be logically partitioned and allocated to one or more virtual machines. For instance each node in the grid of hardware nodes includes at least one processing unit where through the various partitioning allocation and deployment performed by the hypervisor management module hypervisor and or utility management module each physical processing unit conceptually operates as multiple separate processing units for two or more virtual machines of the node. Other resources of a node e.g. memory disk space network bandwidth etc. can also be logically split to be shared by multiple users.

The UVM operating system storage stores the operating system of the UVM including executable instructions that the UVM executes to carry out its various functions. In some embodiments the executable instructions that carry out the functions of the UVM or adaptation engine are defined by a set of scripts remotely stored in a file system of the hypervisor management module. The UVM mounts the file system in order to access the set of scripts. In some other embodiments the executable instructions that carry out the functions of the UVM or adaptation engine are stored as scripts in the UVM operating system store .

The configuration store stores an extracted system configuration configuration received from a configuration store or an extraction engine in some embodiments e.g. the extraction engine of . The adaptation engine accesses the configuration store in order to adapt the stored system configuration to be operable on the node .

The adapted configuration store stores a system configuration adapted by the adaptation engine adapted configuration once the adaptation engine has adapted an extracted system configuration. As shown by the figure this adapted system configuration will later be used by a virtual machine that runs on the node .

In some embodiments the UVM allocates the space required by the adapted system configuration e.g. mounts the drive in response to a message from a hypervisor management module of a server hosting system e.g. hypervisor management module of which indicates the resources required by the system configuration. The other storage stores other data stored on the node including virtual machine configurations not mentioned with reference to as well as unallocated space in some embodiments.

In some embodiments the configuration store and or the adapted configuration store are not erased. Instead these stores and continue to store their respective contents but are simply not accessed by the UVM .

After the system configuration is adapted the UVM of some embodiments notifies the hypervisor management module that the adapted system configuration has been installed on the node i.e. installed on the hypervisor of the node in some embodiments . In some embodiments the hypervisor management module informs a front end provisioning manager e.g. the front end provisioning manager of that the adapted system configuration has been installed on the node . The front end provisioning manager then presents a notification to a user. For example the front end provisioning manager presents the notification through a service request server such as the service request server of . In some embodiments this notification is a visual notification presented in a GUI.

Like illustrates the node after the adaptation engine has performed an adaptation. Also in the UVM has allocated space for the second virtual machine and copied the adapted system configuration into allocated space . As mentioned above the UVM of some embodiments erases the contents of one or both of the configuration store and the adapted configuration store .

It should be apparent to one of ordinary skill in the art that the architecture depicted in and A D do not encompass all embodiments of the invention. Some embodiments of the architecture may include other various functional components to work in conjunction with or instead of the enumerated components illustrated in and A D. While the above discussion was a description of a system architecture of some embodiments the following sections describe processes that may be performed by various components of the above described system.

Some embodiments provide a method for extracting a source system configuration that operates on a source platform in order to allow the system configuration to be adapted to be operable on a destination platform. In some embodiments extraction includes analyzing the source system configuration in order to determine attributes that are relevant to adapting the source system configuration to be operable on the destination platform. These attributes include operating system name kernel name kernel version and or other attributes. Sub section A below describes some embodiments that extract the system configuration locally at the source platform while sub section B below describes some other embodiments that remotely access the source platform in order to extract the system configuration.

The extraction engine of some embodiments analyzes the source system configuration in order to determine attributes that are relevant to adapting the source system configuration to be operable on a different platform. In some embodiments these attributes include operating system attributes e.g. operating system name operating system version etc. and or kernel attributes e.g. kernel name kernel version etc. . Determining these attributes includes identifying devices and or drivers of the system configuration in some embodiments. The extraction engine bundles some or all of the identified attributes and generates a system configuration package that stores the bundled attributes.

The source platform of some embodiments is communicatively coupled to an adaptation engine through a network e.g. a LAN the Internet or any other type of network . Through the network the source platform provides the system configuration package to the adaptation engine of some embodiments. As mentioned above the adaptation engine may be present on a separate physical device than the source platform . The adaptation engine uses the system configuration package in order to generate a destination system configuration package . The processes of some embodiments by which the adaptation engine generates the destination system configuration package are described below in Section IV. The destination system configuration package of some embodiments includes the source system configuration adapted to be operable on a destination platform.

The adaptation engine is communicatively coupled to a destination platform e.g. through a network such as a LAN or the Internet not shown . In some embodiments the destination platform is a node in a grid of nodes while in some embodiments the destination platform is a virtual machine on a node in the grid of nodes . The grid of nodes includes the node as well as one or more other nodes such as nodes and . Through its connection with the destination node the adaptation engine provides the destination configuration to the destination node in some embodiments so that the destination configuration can be installed on the destination node e.g. by a UVM of the destination node .

For instance when the operating system of the source system configuration is a Linux operating system the local extraction engine of some embodiments executes a uname a command that provides information about the kernel such as name version number. It should be apparent to one of ordinary skill in the art that the local extraction engine also performs other commands that provide other attributes of the system configuration. For example the local extraction engine issues commands to identify the kernel release date CPU type operating system name number of processors number of hard drives number of network devices etc. The local extraction engine of some embodiments also analyzes the source system configuration in order to determine a set of device drivers of the source system configuration. Moreover some embodiments programmatically check a device manager of an operating system of the source system configuration in order to determine device drivers of the source system configuration. In some embodiments these attributes are recorded and stored in a file or set of files e.g. text file s XML file s etc. .

After aggregating at the attributes of the local configuration the local extraction engine generates at a system configuration package e.g. the system configuration package of that includes some or all of the attributes that were previously aggregated at . In some embodiments this system configuration package is a single file. For example the system configuration package may include an image file such as an .iso file. Alternatively the system configuration package may be organized as multiple files.

In addition to including some or all of the attributes the system configuration package of some embodiments also includes a file system of the source system configuration i.e. some or all of the data stored on the source platform such as the operating system the kernel a set of device drivers and or a set of application programs . The attributes of the computer system may be listed in a separate file or set of files e.g. text file s XML file s etc. in the system configuration package. Thus the system configuration package includes 1 attributes of the system configuration 2 a file system of the system configuration or 3 both.

After preparing at the system configuration package the local extraction engine of some embodiments outputs at the system configuration package from the source platform. In some embodiments the system configuration package is received by an adaptation engine e.g. the adaptation engine of through a network e.g. the network of which is a LAN the Internet or any other network . As mentioned above the adaptation engine of some embodiments then uses this system configuration package in order to adapt the system configuration to be operable on a different platform.

While some embodiments perform extraction through a completely local process as described above some other embodiments perform extraction through a remote process. conceptually illustrates a system that performs remote extraction of a source system configuration. Like shows a source platform e.g. a single computer system a node in a grid of nodes etc. that includes a source system configuration . The source system configuration includes an operating system and a kernel . In some embodiments the source system configuration also includes other software modules such as application programs not shown .

The source platform is communicatively coupled through a network e.g. a LAN the Internet or any other network to a remote extraction engine . In some embodiments the remote extraction engine is present on a particular machine which is a different physical device e.g. a different computer system than the source platform . The device of the remote extraction engine may be part of the hosting system of some embodiments where the system configuration of the source platform is to be hosted.

Through the network the remote extraction engine requests attributes e.g. kernel name kernel version device drivers as discussed above of the source system configuration . These requests include a request for attributes of the operating system and or a request for attributes of the kernel . In response the source platform provides the requested attributes e.g. operating system attributes kernel attributes and device drivers not shown to the remote extraction engine . The remote extraction engine then generates a system configuration package that identifies some or all of the requested attributes.

The remote extraction engine is communicatively coupled to an adaptation engine . In some embodiments the remote extraction engine and the adaptation engine are present on the same device e.g. the same computer system and communicate through a programmatic software interface. In other embodiments the remote extraction engine and the adaptation engine are present on different physical devices e.g. different computer systems and communicate through a network interface e.g. through a LAN the Internet or any other network . The remote extraction engine provides the system configuration package to the adaptation engine which uses the system configuration package in order to generate a destination system configuration . The processes of some embodiments by which the adaptation engine generates the destination system configuration are described below in Section IV. The destination system configuration includes the source system configuration adapted to be operable on a destination platform.

In other embodiments the process accesses the source platform through a web application e.g. a Java applet running in a web browser on the source platform. The remote extraction engine of some of these embodiments runs an application server e.g. a Java servlet that performs some or all of the process . In yet other embodiments a user uploads an image of the system configuration to the remote extraction engine .

The process then requests at and receives a set of attributes of the system configuration of the source platform. As mentioned above these attributes includes operating system name operating system version kernel name kernel version and or any other attribute. These requests invoke commands that are executed at the source platform. For instance when the operating system of the source system configuration is a Linux operating system one of these commands is a uname a command that provides information about the kernel e.g. name version number as well as other attributes of the system configuration e.g. kernel release date machine hardware name CPU type operating system name etc. . The remote extraction engine of some embodiments also requests other attributes including a set of device drivers of the source system configuration. While some embodiments of the remote extraction engine cause the source machine to execute a uname command as mentioned above other embodiments utilize other well known methodologies for determining the attributes of the source system configuration in lieu of or in addition to executing a uname command e.g. checking a device manager of an operating system of the source system configuration as mentioned above .

The remote extraction engine of some embodiments issues a command that causes the source machine to record and store these attributes in a file or set of files e.g. text file s XML file s etc. . In some of these embodiments the remote extraction engine issues a command that causes the source machine to transmit the file or set of files to the remote extraction engine in addition to or in lieu of storing these attributes at the source machine. Additionally in some embodiments the remote extractor issues a command that causes the source machine to transmit some or all of the data contents e.g. operating system kernel drivers document files etc. of the source system configuration e.g. data stored on a hard drive of the source machine to the remote extraction engine. In other words the remote extraction engine of some embodiments creates a copy of the data contents of the hard drive s of the source system configuration and receives some or all of the data contents of the hard drive s .

After receiving at the attributes of the source system configuration the remote extraction engine generates at a system configuration package e.g. the system configuration package of that includes some or all of the attributes that were previously received at . In some embodiments this system configuration package is a single file. For example the system configuration package is an image file such as an .iso file. Alternatively the system configuration package may be organized as multiple files. In addition to including some or all of the attributes the system configuration package of some embodiments also includes some or all of the data stored by the source machine such as the operating system the kernel a set of device drivers and or a set of application programs. The attributes of the computer system may be listed in a separate file or set of files e.g. text file s XML file s etc. in the system configuration package.

After generating at the system configuration package the remote extraction engine of some embodiments transmits at the system configuration package. In some embodiments the system configuration package is received by an adaptation engine e.g. the adaptation engine of through a network e.g. a LAN the Internet or any other network . As mentioned above the adaptation engine of some embodiments then uses this system configuration package in order to adapt the system configuration to be operable on a different platform.

In some of the above described embodiments a system configuration package generated by an extraction engine includes attributes of the system configuration. However in some embodiments a system configuration package includes an image of the entire file system of the system configuration but does not include attributes of the system configuration. In other words the system configuration package includes all of the contents of some or all storage devices e.g. hard drive s of the source system configuration. In some of these embodiments the analysis operations described above are performed by an adaptation engine e.g. the adaptation engine of . Section IV below describes several exemplary methodologies of some embodiments that adapt a system configuration to be operable on a destination platform.

IV. Adaptation of a System Configuration Operable on a Source Platform to be Operable on Destination Platform

As mentioned above an adaptation engine of some embodiments e.g. the adaptation engine of adapts a system configuration that is operable on a source platform to be operable on a destination platform. The adaptation engine uses one or more processes to perform this adaptation. Examples of these processes which are further described below with reference to include importing a kernel into the system configuration porting device drivers into the system configuration and emulating hardware required by the system configuration.

Sub section A below describes a software module diagram for the adaptation engine of some embodiments. Sub section B describes a process that the adaptation engine uses in determining whether to import a kernel and or port a set of drivers. Next sub sections C and D describe exemplary methodologies that perform the abovementioned importing of a kernel and porting of a set of device drivers. Finally Sub section E describes a process that emulates a set of hardware requested by a source system configuration in order to adapt the system configuration to be operable on a destination node.

The adaptation engine of some embodiments includes a set of software modules that run on one or more particular machines e.g. computer systems used for adapting system configurations . These machines include each of the nodes of the hosting system described with reference to . Alternatively these machines include a machine at a central location within the hosting system such as the hypervisor management module of some embodiments. illustrates a software module block diagram of an adaptation engine of some embodiments that runs on a computer system in order to adapt a source system configuration of a source platform into a destination system configuration that runs on a destination platform.

The adaptation engine includes a kernel comparator retriever module a source operating system identifier retriever module a driver comparator retriever module an operating system modifier module a destination development environment module a driver API module and a destination system configuration aggregator module . The adaptation engine includes interfaces to several libraries including a kernel library an operating system library a driver library and a development environment library . In some embodiments one or more of these libraries correspond to the libraries illustrated in . The functionality of these various modules and libraries is further elaborated below in Sub sections B E. However the following is a brief discussion of the functionalities of these modules and libraries.

As mentioned above the adaptation engine receives a system configuration package e.g. a system configuration package that is provided by an extraction engine of a source system configuration. The system configuration package includes a source kernel a set of drivers and source operating system . The kernel comparator retriever module analyzes the source kernel and determines whether a compatible kernel is available in the kernel library . Upon determining that a compatible kernel is available the kernel comparator retriever module retrieves the compatible kernel from the kernel library . This determination is further described with reference to below.

The kernel is then passed to the destination system configuration aggregator module . The destination system configuration aggregator module aggregates data passed from the other modules of the adaptation module in order to output the destination system configuration which is a file or set of files in some embodiments.

The source operating system identifier retriever module analyzes the source operating system and determines whether a compatible operating system is available in the operating system library . Upon determining that a compatible operating system is available the operating system comparator retriever module retrieves the compatible operating system from the operating system library .

The operating system comparator retriever module also determines whether the operating system either the retrieved operating system or the original source operating system needs to be modified in the adaptation process. Upon determining that the operating system needs to be modified the operating system comparator retriever module provides the operating system either the retrieved operating system or the original source operating system to the operating system modifier module . In some embodiments the operating system comparator retriever module also passes a message to the operating system modifier module that indicates what changes need to be made. The operating system modifier module then performs the indicated one or more modifications to the operating system. Some embodiments of a process that modifies the operating system are further described below with reference to .

After making the modification the operating system modifier module of some embodiments provides the modified operating system back to the operating system library for retrieval in later adaptation processes thereby eliminating the need for modifying the operating system in the same way again. The retrieved modified and or original source operating system is then provided to the destination system configuration aggregator module .

The driver comparator retriever module determines whether one or more of the source drivers of the source platform need to be replaced by importing a set of device drivers into the source system configuration in order to generate the destination system configuration . The driver comparator retriever module also determines whether the drivers that need to be imported are available in the driver library . Upon determining that compatible device drivers are available the driver comparator retriever module retrieves the compatible drivers from the driver library .

Upon determining that the drivers are not available the driver comparator retriever module determines that these drivers need to be generated either automatically through a destination development environment building process or by using a device driver API of the source kernel and or operating system. The driver comparator retriever module supplies the source drivers to the driver API module or to the destination development environment module . These modules and generate the required drivers and supply them to the destination system configuration aggregator . In some embodiments these modules and also supply the generated drivers to the driver library for retrieval in later adaptation processes thereby eliminating the need for generating the same driver s again.

The destination development environment module retrieves a development environment of the kernel and operating system also known as clean versions of the kernel and operating system e.g. a version that is unchanged compared to a version released by a vendor or original developer of the operating system and kernel from the development environment library . The destination development environment module generates drivers using the retrieved development environment. The destination development environment module provides these generated drivers to the destination system configuration aggregator module . Some embodiments of processes that generate device drivers are described below with reference to .

One of ordinary skill in the art would recognize that the above described software module block diagram describes some embodiments of the invention but other embodiments are possible without departing from the scope of the invention. For instance some software modules could be combined into a single software module. On the other hand a software module that is represented as a single module in may actually be implemented as two or more software modules in some embodiments. Additionally it should be apparent to one of ordinary skill in the art that the software modules of the adaptation engine of some embodiments operate to perform a physical transformation of computer readable medium. For example the adaptation engine converts the source system configuration operable on a source platform to a destination system configuration operable on a destination platform. The following sub sections more specifically describe the functionality that is performed by the software modules of the adaptation engine .

Based on the identification information the process determines at whether the operating system is a proprietary operating system. A proprietary operating system is an operating system for which an associated kernel cannot be separately manipulated. In some embodiments a proprietary operating system is not an open source operating system. A proprietary operating system is an operating system for which a licensing fee must be paid in order to install and or use the operating system. Examples of such proprietary operating systems include Microsoft Windows XP and Sun Microsystems Solaris . To determine whether the operating system within the source system configuration is a proprietary operating system the process checks a database that lists proprietary operating systems. When the operating system is a proprietary operating system the process ports drivers at into the system configuration in order to adapt the system configuration to be operable on a destination platform. A process of some embodiments of porting drivers is described below with reference to .

A non proprietary operating system is an open source operating system. A non proprietary operating system is available under the GNU General Public License. Examples of non proprietary operating systems include some distributions of the Linux operating system such as Fedora Debian Ubuntu etc. Upon determining that the operating system is not a proprietary operating system the process performs at a further investigation to determine whether to import a kernel or to port drivers. This further investigation is described with reference to below which also describes a process of some embodiments for importing a kernel. After making the determination of whether to import a kernel or to port a set of device drivers the process ends.

The process begins by receiving at the operating system and kernel of the source system configuration. The process then determines at whether a compatible kernel is present in a library that stores multiple kernels. This determination is described below in further detail with reference to .

In some embodiments a compatible kernel includes the same interface to the same source operating system as the interface of the source kernel. However the compatible kernel includes a different hardware interface than the source kernel. In other words the source kernel includes a hardware interface that interfaces with hardware either physical hardware or virtual hardware of the source platform while the compatible kernel includes a hardware interface that interfaces with hardware either physical hardware or virtual hardware of the destination platform.

The process receives the compatible kernel and installs at the source operating system onto the received compatible kernel. In some embodiments installing at the source operating system onto the received compatible kernel entails storing the source operating system and the received compatible kernel in a single location e.g. a storage device of a computer system . In some embodiments installing at the source operating system entails overwriting one or more files of the source operating system. The source operating system and the received compatible kernel are referred to as the adapted source system configuration or the destination system configuration. After installing at the process ends.

When the process determines at that a compatible kernel is not present in the kernel library the process determines at whether a similar kernel is in the library. This may occur in the case where the source system configuration is modified and a compatible kernel with the same modification also referred to as an unsupported modification is not present in the kernel library. Such unsupported modifications include proprietary file systems e.g. file systems developed by a developer that does not release the source code proprietary networking protocols e.g. networking protocols used in the banking industry and or other modifications of which the nature cannot be determined. In contrast supported modifications i.e. modifications for which a compatible kernel is present in the library include an open source file system e.g. global file system GFS or internet small computer system interface iSCSI or other common modifications of which the nature can be determined. The discussion of below further elaborates on how this determination at is made.

Upon determining at that a similar kernel is present in the library the process receives a modified version of the source operating system and installs at the modified source operating system onto the similar kernel. The process then ends.

If however the process determines at that a similar kernel is not present in the kernel library the process ports at a set of device drivers into the source system configuration. As mentioned above this porting at of drivers is described below with reference to . The process then ends.

The process begins by receiving at the source operating system and kernel. The process determines at whether the source kernel is modified. In some embodiments a modified kernel is a kernel that includes modifications as compared to an unmodified also referred to as clean or standard version of the kernel that was distributed by an entity that originally created the kernel. These modifications include modifying a file system of the source kernel modifying a set of networking protocols and modifying one or more drivers as some examples. In some embodiments the process makes this determination by examining the version number of the source kernel and comparing this version number to a list of version numbers of unmodified kernels.

In addition to or in lieu of comparing version numbers some embodiments compare other parameters of the kernels in order to determine compatibility. In some embodiments these other parameters are attributes listed in a system configuration package generated by an extraction engine. Examples of other parameters include a number of processors number of network devices input device such as keyboard and or mouse drivers display drivers IP address hostname etc. When the process determines at that the source kernel is not modified then the process retrieves at a compatible unmodified kernel for the destination platform from the kernel library. The process then ends.

When the process determines at that the source kernel is a modified kernel then the process checks at the library for a kernel with the same modification or modifications as the source kernel. The process determines at whether a compatible kernel is present in the kernel library. The process of some embodiments makes this determination by identifying version numbers of the kernels stored in the library and comparing them to the version number of the source kernel. In some embodiments a matching version number indicates that a kernel in the kernel library includes the same modifications as the source kernel and is thus a compatible kernel. When kernels are placed in the library e.g. before the process unique identifiers may be appended to the version numbers in order to insure that a matching version number indicates an actual match.

When the process determines at that a kernel with the same modifications as the source kernel i.e. a compatible kernel is present in the kernel library then the process retrieves at the compatible kernel from the kernel library. However when the process determines at that a compatible kernel is not present in the kernel library then the process returns at no compatible kernel. The process then ends.

Each of these figures shows three different types of layers hardware layers kernel layers and operating system layers. Each hardware layer is illustrated with one or more conceptual notches and or pegs at the top of the layer to indicate that that the hardware layer interfaces with a kernel layer. Each kernel layer is illustrated with one or more conceptual notches and or pegs at both the bottom and the top of the layer to indicate that the kernel layer interfaces with both a hardware layer and an operating system layer respectively. Finally each operating system layer is illustrated with one or more conceptual notches and or pegs at the bottom of the layer to indicate that the operating system layer interfaces with a kernel layer. One of ordinary skill in the art would recognize that in some embodiments one or more of the layers shown in the figures is illustrated with one or more of its interfaces omitted. For instance a source operating system might include an interface to a set of application programs not shown .

This figure also illustrates a compatible kernel that has been retrieved from a kernel library. In some embodiments this compatible kernel is retrieved at operation of the process described above with reference to . As shown in this kernel is considered to be compatible with the source kernel because both kernels and have the same interface to the source operating system . This same interface is emphasized in the figure by a dotted double sided arrow labeled match. The compatible kernel includes a hardware interface that is different from the hardware interface of the source kernel . While the source kernel includes an interface to the source hardware layer the compatible kernel includes an interface to a hardware layer of a destination platform as indicated by the matching conceptual notches and pegs.

In some embodiments a computer readable medium e.g. a storage device such as a hard drive that does not store e.g. is not physically encoded with the adapted system configuration is transformed into a computer readable medium that stores e.g. is physically encoded with the adapted system configuration. Transforming a computer readable medium includes physically altering the computer readable medium e.g. physically encoding different data onto a platter of a hard drive . Some embodiments transform a computer system configuration which is stored on a computer readable medium into a different computer system configuration which is stored on the same computer readable medium.

As further described below in Section VII a system configuration of some embodiments is stored on a computer readable medium as a set of instructions that are executable by a processor of a computer system. Section VII below also provides a non exhaustive list of tangible articles which are considered as examples of computer readable media.

The process begins by receiving at an operating system. The process determines at whether a kernel that is compatible with the received operating system is in the library. In some embodiments this determination includes checking a database that maps operating systems to kernels in order to indicate which operating system is compatible with kernels stored in the library. The mapping in this database may be based on objective or subjective observations that were previously made about compatibility between various operating systems and kernels.

In some embodiments this database is the same as the database that stores the changes needed in order to make the source operating system compatible with the similar kernel. In some embodiments this database is physically stored within the library that stores kernels e.g. the core kernel library of .

When a similar kernel is not found in the library the process returns at no similar kernel and then ends. On the other hand when a similar kernel is found in the library the process retrieves at the similar kernel from the library. The process then modifies at the source operating system in order to make the source operating system compatible with the kernel from the library. As mentioned above examples of modifying the source operating system include modifying udev in a Linux operating system modifying a C library and modifying a RAM disk or initrd in a Linux operating system .

In lieu of or before modifying at the source operating system the process of some embodiments checks an operating system library e.g. operating system library of for a modified version of the source operating system. When the modified source operating system is already present then the process does not need to modify at the operating system again.

The process of some embodiments then supplies at the modified source operating system to the operating system library for storage and later retrieval. The process then ends.

This figure also illustrates a kernel that is similar to the source kernel . This similarity is illustrated by the conceptual notches on the tops of the kernels and which are similar but not the same. In some embodiments as mentioned above the similar kernel is retrieved from a core kernel library e.g. the core kernel library of . This figure further illustrates a destination platform . As indicated by the different conceptual notches the destination platform has a different hardware interface e.g. different physical or virtual hardware devices than the source platform .

In some embodiments a computer readable medium e.g. a storage device such as a hard drive that does not store e.g. is not physically encoded with the adapted system configuration is transformed into a computer readable medium that stores e.g. is physically encoded with the adapted system configuration. Transforming a computer readable medium includes physically altering the computer readable medium e.g. physically encoding different data onto a platter of a hard drive . Some embodiments transform a computer system configuration which is stored on a computer readable medium into a different computer system configuration which is stored on the same computer readable medium.

As further described below in Section VII a system configuration of some embodiments is stored on a computer readable medium as a set of instructions that are executable by a processor of a computer system. Section VII below also provides a non exhaustive list of tangible articles which are considered as examples of computer readable media.

The process begins by identifying at a hardware device either physical or virtual of the destination platform. The adaptation engine of some embodiments has access to a database that stores identifying information regarding the hardware devices of the destination platform. In some embodiments this identification is received by the adaptation engine from the destination platform e.g. from the UVM of a destination node . The identification indicates the name type e.g. a storage block device driver a network device driver a PCI device driver etc. manufacturer and or any other attribute of the device.

The process determines at whether a device driver that allows the identified device to communicate with the source system configuration is present in a library that stores multiple device drivers e.g. the driver library of . In some embodiments this determination at includes determining whether a driver in the library corresponds to 1 the same type of device and 2 an operating system and or kernel of the source system configuration. In some embodiments a corresponding device driver is similar but is not an exact match. For instance the corresponding device driver may be of the same type of device from a different manufacturer or may be a generic device driver. In some embodiments the process looks for such a similar device driver when an exact match is not found in the driver library.

In some of these embodiments the process examines a database that correlates devices to acceptable similar device drivers. This database is stored within the driver library in some embodiments. This database may be previously generated based on objective or subjective observations that were made about compatibility between various devices and device drivers e.g. during testing on the destination platform .

When a corresponding device driver is present in the library the process retrieves at the corresponding driver from the library. The process places at the retrieved driver into the source system configuration. In some embodiments placing the retrieved driver into the source system configuration includes copying a device driver file or set of device driver files of the retrieved driver into a storage e.g. a folder of a hard drive that also stores the source system configuration. In some embodiments the process deletes the source driver from the source system configuration while in other embodiments the process does not delete the source device driver from the source system configuration. In some of these embodiments the process renames the source device driver so that it can be easily located and reinstalled at a later time. The process then ends.

When the process determines at that a corresponding device driver is not located in the driver library the process determines at whether a development environment for the source operating system and kernel is available in a library that stores development environments e.g. the development environment library of . When the process determines at that a development environment is available in the development environment library the process of some embodiments retrieves the development environment from the library and installs at the development environment onto the destination platform in order to automatically generate the required device driver. This operation is further described below with reference to .

The process then receives at a device driver generated using the development environment. In some embodiments the process supplies at the generated driver to an adaptive library that stores drivers e.g. the driver library of in order to allow the generated driver to be retrieved later e.g. at a later iteration of the process specifically at determination operation in some embodiments . The adaptive driver library of some embodiments is further discussed below. The process of some other embodiments does not perform this supplying operation to a driver library and instead transitions directly to the next operation .

At operation the process replaces in the source system configuration a device driver of the device that was identified at with the generated driver. In other embodiments the process does not replace at this device driver with the generated driver. Rather the process simply inserts the generated driver into the source system configuration while not modifying the source device driver in any way. Alternatively the process of some embodiments inserts the generated driver into the source system configuration and alters the name and or location of the source device driver e.g. appends characters to the end of the name of the source device driver and or moves the source device driver to a different directory etc. . The process then ends.

When the process determines at that a development environment for the source operating system and kernel is not available in the development environment library then the process receives at a driver that is generated through an application programming interface or API of the kernel. The generating of this driver is further described below with reference to . After receiving at the driver generated through the API of the kernel the process of some embodiments transitions to operations and which are described above. Finally the process ends.

As mentioned above illustrates a process of some embodiments that automatically generates a driver using a development environment of a source operating system and kernel. In some embodiments the process occurs at operation of i.e. after the process determines that a required device driver is not in the driver library . The process is performed at a destination platform e.g. by a UVM of a destination node in some embodiments while the process is performed at an adaptation engine e.g. the adaptation engine of in some other embodiments.

The process of begins by retrieving at a development environment of a kernel and operating system from a development environment library e.g. the development environment library of . As mentioned above the development environment includes clean versions of the operating system and kernel e.g. unmodified as compared to the kernel and operating system as they are distributed by developers and or vendors of the kernel and operating system . The process installs at the retrieved development environment onto the destination platform.

In some other embodiments in lieu of installing at the kernel development environment onto the destination platform the process installs the development environment onto a platform that is identical to the destination platform. In cases where the destination platform is a physical hardware platform the process installs the development environment onto a platform that includes hardware that is identical to the destination platform. In cases where the destination platform is a virtual hardware platform e.g. the destination platform includes a virtualization engine on which the destination system configuration runs the process installs the development environment onto a platform that includes the same virtual hardware e.g. the same virtualization engine as the destination platform. In some of these embodiments this platform onto which the development environment is installed includes different physical hardware than the destination platform.

Once the development environment is installed onto the destination platform or an identical platform the process builds at the development environment on the platform on which the development environment is installed. Building at the development environment may be initiated automatically e.g. through a script and causes a set of device drivers to automatically be generated. These device drivers allow the source system configuration to interface with the hardware devices of the destination platform. The process then identifies at one or more of these drivers that are automatically generated. In some embodiments identifying at a driver includes comparing a device to which the source driver corresponds to a device to which a generated driver corresponds.

Next the process outputs at the identified driver. Finally the process ends. As mentioned above with reference to this identified driver may be used in generating a destination system configuration that is an adapted source system configuration.

The process of begins by retrieving at the API of the source kernel from a library that stores APIs of kernels e.g. the API library of . Next the process installs at the API onto a development platform e.g. the destination platform or a computer system that is neither the source platform nor the destination platform such as the workstation of . In some embodiments the API is already installed on the development platform. In some of these embodiments the process does not perform the retrieval at and installation at operations. The process merely performs a check on the development platform to determine that the API is already installed.

The process receives at device information at the development platform. In some embodiments this device information includes information relevant to developing a device driver that allows the source kernel to interface with the device e.g. system calls that the device makes and commands to which the device responds . The process also receives at a source device driver for which a matching driver is to be generated e.g. a matching device driver was not found in the driver library .

Next the process generates at a device driver that allows the device to communicate with the kernel by using the device information received at operation and the API installed at operation . In some embodiments this generating at includes manipulating computer code of the source device driver at the development platform. The process then ends once the device driver is generated.

In some embodiments a computer readable medium e.g. a storage device such as a hard drive that does not store e.g. is not physically encoded with the adapted system configuration is transformed into a computer readable medium that stores e.g. is physically encoded with the adapted system configuration. Transforming a computer readable medium includes physically altering the computer readable medium e.g. physically encoding different data onto a platter of a hard drive . Some embodiments transform a computer system configuration which is stored on a computer readable medium into a different computer system configuration which is stored on the same computer readable medium. The different computer system configuration is then executed by a processor of a computer system.

The process begins by receiving at the source system configuration. This receiving at may include receiving an operating system a kernel of the source system configuration and or associated attributes of the source system configuration. In some embodiments the process receives at the source system configuration at the adaptation engine as a system configuration package from an extraction engine e.g. the extraction engine of .

The process then identifies at a set of hardware devices that the source system configuration expects. Examples of these devices include one or more central processing units CPUs storage devices e.g. hard drives display devices e.g. graphics cards networking devices e.g. Ethernet cards and or any other type of hardware device. In some embodiments this identifying at includes identifying hardware devices for which the system configuration includes device drivers. This identifying at includes examining a set of device drivers of the system configuration in order to identify devices of the system configuration. While some embodiments of the process receive the operating system and or the kernel of the source system configuration some other embodiments of the process instead receive an identification e.g. a list of devices or device drivers in a system configuration package received from an extraction engine such as the extraction engine of .

Next the process configures at a virtualization engine e.g. a hypervisor of the destination platform to emulate the identified hardware required by the source system configuration. An example of a hypervisor that is able to emulate hardware is QEMU which is available on the Internet at http bellard.org qemu under the GNU General Public License. In some embodiments this system configuration at is performed through an API of the hypervisor by a software programmer who has knowledge of the identified hardware e.g. specific system calls that the identified hardware makes . Other embodiments search a library that stores hypervisor configurations not shown in order to determine whether the library already stores the desired hypervisor configuration. When the library does include the desired hypervisor configuration the process of these embodiments retrieves the hypervisor configuration.

In some embodiments configuring at the hypervisor to emulate the required hardware includes configuring a hypervisor of the destination platform. Once the hypervisor of the destination platform is configured to emulate the required hardware the original unmodified source system configuration is installed and subsequently operated on the destination platform. In some embodiments the emulated hardware correlates to hardware either physical or virtual of the destination platform. In other embodiments the emulated hardware is dummy hardware that does not correlate to hardware of the destination platform. In such a case the hardware is emulated in order to satisfy the source system configuration but performs no actual function.

Several of the processes of some embodiments described above make reference to one or more libraries e.g. core kernel library driver library operating system library development environment library and API library of from which information can be retrieved. This information can be used e.g. by an adaptation engine of in the adapting of a source system configuration that is operable on a source platform to be operable on a different destination platform. As further discussed below the source platform of some embodiments is a node in a grid of nodes of a server hosting system. Moreover the destination platform of some embodiments is a node in another grid of nodes in a different server hosting system. In some embodiments the two server hosting systems are operated by two different service providers.

In some embodiments any one or more of these libraries is an adaptive library. An adaptive library of some embodiments is a library which grows over time in terms of the information it stores. In other words an adaptive library learns information that is used when adapting a source system configuration to be operable on a destination platform.

When information is present in the adaptive library from which the information is requested the adaptive library is able to provide the requested information. However cases may arise where the requested information is not present in the adaptive library e.g. when the process of determines at that a requested driver is not in a driver library . As shown in other operations may need to be performed in order to generate the requested driver e.g. installing and building at a development environment . Performing these operations to generate the requested driver is generally not as efficient as simply retrieving the driver from a driver library.

Once an operation i.e. an operation besides retrieval such as installing and building a development environment is performed in order to generate new configuration information e.g. a driver the adaptive library of some embodiments stores the new configuration information for later retrieval. Thus if the information is ever requested again e.g. during adaptation of another source system configuration with the same or similar characteristics a subsequent check of the library will yield the requested information eliminating the need for performing an operation that generates the requested information. Accordingly the adaptive library allows the adaptation of source system configurations to be operable on destination platforms to be more efficient and less time consuming.

Additionally in some embodiments this adaptive library concept applies not only to aiding in the adapting of system configurations but also in allowing users to select system configurations that have already been adapted to run on the destination platform. In some of these embodiments the adaptation module supplies adapted system configurations to an image store database e.g. image store database of . These adapted system configurations may then be selected by a user for installation on a destination platform through a user interface e.g. the user interface described above with reference to .

The above described embodiments provide several advantages. For instance a system configuration e.g. a kernel an operating system and or a set of application programs that is operable on a source platform may be adapted to be operable on a different destination platform that bears no relation to the source platform. For instance illustrates that a system configuration that is hosted in a first hosting environment may be adapted to be operable by a second hosting environment in order to allow the system configuration to be hosted in the second hosting environment. In other words the first hosting environment includes the source platform and the second hosting environment includes the destination platform. In some embodiments the first and second hosting environments are operated by different unrelated service providers e.g. competing hosting service providers .

Specifically illustrates a first hosting system of some embodiments which is implemented as a grid of hardware nodes e.g. hardware nodes shown in exploded view each of which may run one or more system configurations. In this figure a source system configuration configuration a runs on a particular node of the grid of nodes. Additionally other system configurations including configuration b configuration n and any number of other nodes not shown run on one or more nodes of the grid of nodes.

In some embodiments the source system configuration runs directly on hardware of the source node. In other words the source system configuration has direct access to hardware of the source node. In other embodiments the source system configuration runs on a virtualization engine. In some of these embodiments the virtualization engine is a type 1 hypervisor that directly accesses the physical hardware of the source node and provides a set of virtual hardware to the source system configuration. The virtualization engine of some other embodiments is a type 2 hypervisor that 1 receives access to physical hardware of the source node through an operating system and kernel that have direct access to the physical hardware of the source node and 2 provides a set of virtual hardware to the source system configuration.

Attributes of the source system configuration i.e. configuration a in this example are provided to the extraction engine either remotely or locally in some embodiments as described above . Through the network the extraction engine of some embodiments provides a system configuration package with extracted attributes of the source system configuration to the adaptation engine which uses the system configuration package to adapt the source system configuration to be operable on a destination platform. In some embodiments the adaptation engine performs this adaptation in conjunction with a library that stores information such as operating systems kernels drivers etc.

In this figure the destination platform is located on a node of a second hosting system that is separate from the first hosting system. In some embodiments the second hosting system is a grid of nodes e.g. hardware nodes shown in exploded view .

While some embodiments adapt a system configuration that runs on a node of a first hosting system to allow the system configuration to be operable on a node of a second hosting system one skilled in the art would recognize that other embodiments of the invention provide other possibilities. For instance illustrates that a system configuration that is operable on a single computer system may be adapted to be operable on a node of a hosting system e.g. a grid of nodes . Additionally illustrates that a system configuration that is operable on a single computer system may be adapted to be operable on another single computer system. One of ordinary skill in the art would recognize that illustrate only some examples of possible types of hardware on which the source and destination system configurations could run and that other types of hardware not specifically enumerated could be used as well for the source and or destination platforms.

In some embodiments the adapted source system configuration also referred to as the destination configuration runs directly on hardware of the destination platform. In other words in some of these embodiments the destination system configuration has direct access to hardware of the destination platform. In other embodiments the destination system configuration runs on a virtualization engine. In some of these embodiments the virtualization engine is a type 1 hypervisor that directly accesses the physical hardware of the destination platform and provides a set of virtual hardware to the destination system configuration. The virtualization engine of yet other embodiments is a type 2 hypervisor that 1 receives access to physical hardware of the destination platform through an operating system and kernel that have direct access to the physical hardware of the destination platform and 2 provides a set of virtual hardware to the destination system configuration.

In some embodiments the source system configuration runs directly on physical hardware of the source platform and the destination system configuration runs on a virtualization engine e.g. a type 1 or type 2 hypervisor while in other embodiments the source system configuration runs on a virtualization engine and the destination system configuration runs on physical hardware of the destination platform. In some embodiments the source system configuration runs on a type 1 hypervisor and the destination system configuration runs on a different type 1 hypervisor while in other embodiments the destination system configuration runs on the same type 1 hypervisor as the source system configuration. In some embodiments the source system configuration runs on a type 2 hypervisor and the destination system configuration runs on a different type 2 hypervisor while in other embodiments the destination system configuration runs on the same type 2 hypervisor as the source system configuration.

As is made apparent from the discussion above some of the embodiments of the invention allow any system configuration that operates on any type of source platform to be adapted to be operable on any type of destination platform. Because of this capability a user is able to migrate his or her system configuration from his or her computer system onto a hosting system. Moreover a user may migrate his or her system configuration from one service provider s hosting system into a competing service provider s hosting system. In some embodiments this migration occurs automatically and without any human intervention once the migration is initiated. Thus the migration can occur within a short amount of time e.g. within five hours of initiation or less .

Some or all of the above described processes are machine implemented processes. The processes of some embodiments are tied to one or more particular machines. A particular machine of some embodiments includes a computer system as further described below. Some embodiments of the above described processes are implemented as software processes that transform data. Some of the transformed data includes representations of real world items e.g. a computer system configuration that includes photographs of real world objects recorded video footage recorded audio sounds etc. in some embodiments.

Software processes of some embodiments are specified as a set or sets of instructions recorded or encoded on a tangible computer readable storage medium also referred to as computer readable medium . The computer readable storage medium of some embodiments is a tangible physical article of manufacture. When the instructions recorded on the computer readable storage medium are executed by one or more computational element s e.g. processors or other computational elements including application specific integrated circuits ASICs and or field programmable gate arrays FPGAs the instructions cause the computational element s to perform the actions indicated by the instructions. In this specification the term computer is meant in its broadest sense and can include any electronic device with one or more processors. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc.

The term software as it used in this specification is also meant in its broadest sense. Software can include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the computer system . For instance the bus communicatively connects the processor with the read only memory the system memory and the permanent storage device . From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of the invention.

The read only memory ROM stores static data and instructions that are needed by the processor and other modules of the computer system. The permanent storage device of some embodiments on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive or ZIP disk and its corresponding disk drive as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike the permanent storage device the system memory of some embodiments is a volatile read and write memory such a random access memory RAM . The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory .

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards and or pointing devices also called cursor control devices . The input devices of some embodiments also include audio input devices e.g. microphones MIDI musical instruments etc. . The output devices display images generated by the computer system. For instance these output devices of some embodiments display a GUI. The output devices include printers and display devices such as cathode ray tubes CRTs or liquid crystal displays LCDs .

Finally as shown in the bus of some embodiments also couples computer to a network not shown through a network adapter . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN an intranet or a network of networks such as the Internet. For example the computer may be coupled to a web server through the network adapter so that a web browser executing on the computer can interact with the web server as a user interacts with a GUI that operates in the web browser. Any or all components of the computer system may be used in conjunction with the invention.

As mentioned above the computer system of some embodiments includes one or more of a variety of different computer readable media. Some examples of such computer readable media include but are not limited to tangible media such as RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives ZIP disks read only and recordable Blu ray discs floppy disks and any other optical or magnetic media. While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

