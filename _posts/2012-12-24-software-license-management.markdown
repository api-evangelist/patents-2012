---

title: Software license management
abstract: A method of managing a software license comprises loading a software program into volatile memory, obtaining authorization data, modifying a portion of the volatile memory relied upon by the program in accordance with the authorization data, executing the program, and causing the modifications to be deleted from the volatile memory. In some embodiments, selection criteria compared with the authorization data does not contain information corresponding to all of the content of the authorization data, thereby denying a software attacker the benefit of identifying and exploiting the selection criteria.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966646&OS=08966646&RS=08966646
owner: 
number: 08966646
owner_city: 
owner_country: 
publication_date: 20121224
---
This is a continuation of U.S. patent application Ser. No. 11 964 682 filed Dec. 26 2007 now U.S. Pat. No. 8 341 751 and claims priority thereto.

The invention relates generally to computer security and more particularly to software license management and anti piracy software protection.

Software license management systems typically obtain authorization data from a user who wishes to use the software for example by requesting a password searching for a dongle coupled to the computer or a specific media disk in a drive scanning a fingerprint or otherwise obtaining data from a security token. When the license management system then compares the authorization data or else the result of an algorithm operating on the authorization data for example a hash function with security criteria. If there is a match the license management system launches execution of the protected software. If there is no match the license management system is supposed to deny access to the protected software.

Unfortunately there is a common software cracking technique known as branch jamming in which the critical decision point often a conditional jump instruction in the security system is identified and changed. Possible changes include replacing the conditional jump with an unconditional jump or else a no operation NOP instruction. This change defeats the intentions of the software security programmer and permits access to the protected software without the proper authorization data. This type of software attack is often quite effective when the software license management system and the protected software both reside on a computer system under the control of the attacker.

U.S. Pat. No. 6 411 941 METHOD OF RESTRICTING SOFTWARE OPERATION WITHIN A LICENSE LIMITATION 941 patent discloses a prior art software license management system that operates similarly to method in . The 941 patent teaches that license decision data is obtained from the computer basic input output system BIOS and also from a remote license bureau 7. Independent of where the data is stored processed or how it is obtained the systems and methods taught in the 941 patent are vulnerable to branch jamming attacks similar to the one shown in . Specifically column 2 lines 19 20 and 56 59 describe the operation of a license verifier that searches for a match and then either launches the protected software or responds in another manner. The portions of the license verifier that determine the jump conditions or carry out the conditional jump may be altered to permit execution of the protected software even if no license data is stored in the BIOS and or the remote license bureau 7 has never been contacted to request any license data. In the teachings of the 941 patent the data stored in the BIOS may be considered either authorization data or test criteria since the methods taught indicate merely determining a match between the data in the BIOS and date obtained in another manner. In some systems the designation of authorization data versus test criteria may be arbitrary.

This vulnerability is at least partially addressed by U.S. patent application Ser. No. 10 300 905 METHOD OF SECURING SOFTWARE AGAINST REVERSE ENGINEERING 905 application . The 905 application teaches substituting central processing unit CPU instructions with tokens thereby placing the software into a state in which it will not function properly without compensating for the substitutions. Some of the methods taught include micropatching the CPU to respond to the token with some desired functionality and manipulating an execution pointer based on an external data structure in response to a token. Unfortunately the tokens may be easily identifiable using a string search of the executable program thereby flagging portions of the program that an attacker may need to modify for a branch jamming attack.

One scenario of attack is that an attacker obtains a single license for using a copy of the software and runs both a licensed version of the software and an unlicensed version of the software within stealthy debugging environments performing run traces. In a run trace executed instructions and certain memory changes are recorded. Hardware emulators and some software based virtualization systems provide stealthy debugging environments that may avoid detection by most debugging detection methods. The resulting run traces may then be compared side by side to enable determination the functionality replaced by the tokens. The functionality is likely to be fairly simple at least in the case for micropatching. An attacker can then create an equivalent of the functionality displaced by the tokens. Only the first token encountered needs to be reverse engineered. Subsequent identical tokens in the same software may be patched around using a relatively simple string search and replace with jumps to the attacker s equivalent routines. Further whenever other software is encountered that uses a similar token system either a different type of program or else a copy of the original program on a different computer the tokens may be replaced with jumps to the recreated functionality using a simple string search and replace. What an attacker learns by attacking one program protected by tokens facilitates attack against any other software using a similar token protection scheme.

Thus in some situations the tokens may actually facilitate reverse engineering and tampering by drawing an attacker s attention to very same critical decision making steps in the license management system that the software developer wanted to protect. To the extent necessary to understand the claims following the disclosures of both the 941 patent and the 905 application are incorporated by reference. However any statements regarding the effectiveness of the systems and methods disclosed in the 941 patent and the 905 application are specifically disagreed with. No software security system including the one presented herein is impervious to attack.

One solution to the vulnerabilities of the 941 patent and the 905 application is to replace the software instructions or data relied upon by the software with different values which are not identifiable as tokens. That is the changes are not changes to predetermined limited set of tokens that could be found by a search and replace or are otherwise identifiable by their value or content but rather use possibly random values or else different values that result in less capable software. For some types of changes an attempt to execute software with the changes in place will result in a computer crash but for other types of changes the software may operate properly to completion but with less precise data or reduced functionality. The repair of the software back to its more capable state can then be accomplished for example by a launcher identifying the bytes to be repaired using their locations. The information used in the repair may include the license management information whether locally stored such as in firmware obtained remotely such as from a license bureau typed in by a user or obtained from a storage device coupled to the computer. For example a security token such as a dongle may provide a license key parts of which identify the locations of bytes in files to be changed and parts of which identify the changes to make. In some situations the addresses and restoring data may not be readily apparent from the license information but rather may be produced by passing the license information through an algorithm.

By changing software instruction bytes or bytes of data relied upon by the software for proper execution a protected software program can be rendered less capable or even inoperable. By using a software license management system for example a launcher to modify repair the changed bytes with information derived from license data prior to launching the protected software a branch jamming attack will result in the launch and execution of damaged less capable software. The result may be reduced operability or even a crash of the computer process. The protected software possibly including a launcher is likely to be stored on a computer readable medium such as for example magnetic media optical media volatile memory and non volatile memory. The protected changed software may be stored in permanent or non volatile memory. However the modified repaired software and data which is the version to be executed should only be written to volatile memory and deleted from that memory as soon as practical after execution to minimize the chance of a memory grab by a software attacker.

One embodiment of an improvement to the systems and methods taught in the 941 patent and the 905 application includes modifying using information derivable from the license record portions of the selected program in volatile memory not identified by tokens and or data relied upon by the selected program executing the selected program and causing the selected program to be deleted from volatile memory. This requires the bytes to be modified to have previously been changed from one state to a state that reduces the capability of the software. The data relied upon by the selected program may be data constants jump addresses names of auxiliary files or dynamic link libraries DLLs case variables user interface commands and or other information used in program execution control. Another embodiment of an improvement to the systems and methods taught in the 941 patent and the 905 application includes modifying portions of the software at bytes not identified by tokens and causing the modified program to be deleted from volatile memory. The purpose of causing the modified program to be deleted from volatile memory is to minimize the chance of a memory grab by an attacker which could result in the modified program being stored in its more capable state and available for execution without the need for the repair procedure. Causing the modified program to be deleted from volatile memory may be as simple as closing the process so that the operating system OS can be expected to purge the volatile memory. However further actions may be taken such as deleting any copies of the modified program from swap space preventing the OS from writing copies of the modified software to virtual memory or overwriting any memory or storage space that had contained the modified program with other data.

This form of protection should be distinguished from encryption shells in which data or instructions are stored in an encrypted state and decrypted at some point prior to execution. For typical encryption shell protection the decryption process changes a predetermined set of bytes from an encrypted state which likely has no similarities to software instructions or usable data according to a predetermined algorithm based on a key entered by the user or accessible to a decrypting launcher. In some embodiments the modification in block includes replacement of bytes which is not decryption. In some embodiments the modification in block includes substitution of a set of data and instructions that would allow the program to operate although in a less capable state with a second set that allows the program to operate with more capability. For example the mantissa of a floating point value may be changed to reduce significant figures of a value used in a calculation. This is not feasible with most good encryption algorithms because the encrypted bytes would not likely comprise operable instructions and data. In some embodiments the modification information used in block includes an indication of the location of modifications to be made in volatile memory which is information not included in decryption keys and is not predetermined In some embodiments the modification information used in block includes an indication of the manner of making modifications whether simple replacement or a Boolean operation which is essentially a selection of an algorithm and is also not information which is included in decryption keys. However it should be understood that block may use decryption as part of the set of modifications. In block the software is executed using modified instructions and or data. In block the modifications are deleted from volatile memory along the program. This type of protection complicates matters for a software attacker and thus provides an additional level of protection over the prior art method shown in .

One potential attack is illustrated in . An attacker has attempted a branch jamming attack at both decision blocks and by introducing alternate paths and . Therefore the absence of authorization data or the entry of incorrect authorization data does not result in a fail state in block . However the attacker has learned that merely bypassing the authorization data verification resulted in the execution of software with flawed data and or instructions. That is the attacker has figured out that the software and or data files need to be modified in order to run the software with the desired capability. The attacker has also reverse engineered the license management system to identify not only where in the launcher the authorization data is compared with the authorization test criteria but also has identified the content of the test criteria.

For example if the authorization data comprises a password which is hashed prior to being tested for validity the authorization test criteria may be the hash result of the correct password. The authorization test for a match can then be a simple byte by byte comparison for equality between the test criteria and a hash of the password. Some poorly designed hash functions may be reversible meaning that the password can be calculated using the test criteria. However even for one way hash functions if the password is not very long a brute force attack which hashes candidate passwords and compares the results against the test criteria could allow identification of the password within a timeframe that is acceptable to the attacker. Alternatively if any license data is encrypted the attacker may be able to watch the encryption or decryption process in memory within a stealthy debugging environment obtain the key and then use the key to decrypt any information the attacker desires. The attacker can then watch the software modification process in a stealthy debugging environment learn what modifications are needed and create a routine to make the modifications independently of the need for entering the authorization data as indicated in block . This can attack can be accomplished without the attacker having access to the proper authorization data.

So unfortunately the license management system s access to the test criteria independent of the proper authorization data can be leveraged by an attacker to learn the content of the authorization data at least for systems operating in accordance with prior art method and the teachings of in the 941 patent and the 905 application. The attacker s version of the software may then be distributed with a modification or additional program that carries out the function of block which permits execution of the software with repaired instructions and or data in block even without access to the proper authorization data.

In method of an attacker can operate according to the following assumption whatever authorization data does not fail the authorization data verification process which includes blocks and must be the proper authorization data. If an attacker does not have the proper authorization data and is attempting to ascertain it by reverse engineering software that operates according to method two categories of information are initially hidden from the attacker 1 data that must be provided and 2 data that should not be provided. Method only leverages the first part of an attacker s uncertainty. Method leverages both.

The principle that enables operating according to method is that a user not only has control of what authorization data is provided to a software license management system but also has control of what data is not provided. A check for a match between authorization data and test criteria may then be replaced with selection from among potentially multiple authorization data candidates to determine the one closest to selection criteria or the prevailing selection criteria if multiple selection criteria data sets are used during the selection process. To launch the software with proper operation a user provides authorization data that is close enough but not too close to the selection criteria. This is because the authorization validation process may select incorrect authorization data that is closer to the selection criteria than is the proper authorization data. Distance may be measured in multiple ways including the number of bits or bytes that are similar arithmetic differences or other methods including weighted differences between portions of the data. Other selection criteria apart from distance may also be used.

By introducing the possibility that the selection process could result in the selection of incorrect authorization data instead of the proper authorization data a software attacker is denied the full benefits of reverse engineering the authorization data selection process to learn all the secrets of what the authorization data must be. Using protection in accordance with method even if an attacker learns all the secrets of selection criteria the attacker has learned something that is close to the required data but it is not the required data. In the framework of this paradigm any authorization validation process that operates in accordance with method by running protected software after a mere equality matching test between purported authorization data and test criteria which is available independently of the authorization data can be viewed as a facilitating gift to a software attacker.

In the illustrated embodiment of method a plurality of authorization data candidates are obtained in block . These authorization data candidates may be a plurality of data sets in firmware in a dongle on a media disk in a wireless device for example an inductively powered wireless device entered by a user data derived from biometric data or any other data from a security token or purported by a user to be authorization data. A launcher operating in accordance with an embodiment of method may obtain a data set from a particular location identified by the launcher while another launcher operating in accordance with another embodiment of method searches a user s computer and certain systems or media coupled to the user s computer for data sets having certain characteristics. In decision block method determines whether authorization data candidates matching the characteristics have been obtained. This determination may include a test of a partial match between a data candidate and a selection criteria data set. In block a plurality of selection criteria data sets is obtained which are used for selecting a candidate from the plurality in block . Block may occur prior in time to block . For example multiple authorization data sets and selection criteria data sets may be preloaded onto separate media for example a dongle may contain the candidates and a media disk may contain the selection criteria. Alternatively a single selection criteria may be obtainable from a remote license bureau or be contained within a launcher. The closest pairing between all possible combinations of criteria with a candidate may identify the selected candidate in block . For another example a set of selection criteria may be provided by a software developer for a multiple of software packages provided by that developer including packages that a particular user may not yet have purchased. Upon purchase of a license the developer then provides a set of multiple authorization codes on copy protected media such as a dongle which are pre screened for closer matches to ensure that a proper selection can be assured when the user attempts to operate the purchased software.

In block instructions and or data in volatile memory which are relied upon by the software are modified. The modifications may include any of those described for block for method of . The information used to determine the modifications comprises indications of the locations of the bytes to be modified indications of the manner of changing the bytes and or the specific bits used to change to the bytes. The manner of change may be a replacement or a Boolean operation such as an exclusive or XOR . For example the modification data may comprise information directing a launcher to 1 XOR the byte in volatile memory that corresponds to byte 1000 of the stored executable file with hex FA 2 replace the byte in volatile memory that corresponds to byte 1001 of auxiliary file LIB1.DLL with 90.

The information used in determining the modifications in block should include information that is available only by having access to the proper authorization data and not from having access only to selection criteria. In some embodiments data from selection criteria may be used in addition to what is determinable from the proper authorization data but will not be all of the modification information that is needed. For example in some embodiments the entire authorization data is processed in order to determine modification information in other embodiments only portions are used which include at least some portions of the authorization data that are different than the selection criteria. In some embodiments the portions of the authorization data that is different from the selection criteria may be processed to determine the needed modification information. In some embodiments the differences themselves between the selection criteria and the authorization data such as a Boolean operation on the portions of difference may be processed to determine the modification information. With this type of protection an attacker reverse engineering the selection criteria has no knowledge of the needed modifications similar to the way in which someone knowing the details of an encryption algorithm cannot decrypt data without the proper key. The differences then contain the secret data necessary to unlock the software functionality and thus perform a role similar to an encryption key for an openly published encryption algorithm.

Other variations are also possible for method . For example the need for selection criteria could even be eliminated entirely such that a launcher selects the first data provided as purported authorization data in block makes the modifications in accordance with the provided data and the protected program either operates correctly or else operates in whatever random manner is dictated by changes made according to the first data purported to be authorization data. In other embodiments after considering multiple data candidates and two or more may be selected and the differences between the selected ones may be used to determine the modifications. In this usage differences between the authorization information and the selection criteria includes means differences in the compared information which may not be the original data but instead may be processed data. For example if the authorization data is hashed prior to comparison with the selection criteria differences means differences between the hashed authorization data and the selection criteria. Thus due to the differences the selection criteria does not contain information corresponding to all of the content of the authorization data.

In block the software is executed and is followed by block upon completion of the execution of the software program. It should be understood that since method uses any purported authorization data set selected in block multiple data sets could repair the protected software to varying degrees. For example one authorization data set may contain information necessary to repair all changes whereas a second authorization data set may contain only enough information to repair some but not all changes and a third authorization data set may contain information for repairing different changes than does the second authorization data set. A software developer producing software that operates in accordance with method may for example produce multiple dongles that unlock differing sections of a particular software title. Since the portions unlocked are determinable by the selection of authorization data using selection criteria controlling either the selection criteria or authorization data available for use by an embodiment of method then enables control of the software capability.

As a comparison consider the use of public key cryptography. There is no central entity that controls the generation of public key pairs. Anyone running a key generation program could accidentally generate a key pair that is identical to that of another user. And yet public key cryptography is widely used even though this possibility exists. This is because the possibility of such an accident is so low that it has been accepted. The authorization data and selection criteria generation process can be tailored to make the data sets long enough and unique enough that another data set randomly available on a user s computer or on anything coupled to the user s computer is highly unlikely to be selected ahead of the proper authorization data. This can be accomplished simultaneously with retaining sufficient differences between the authorization data and the selection criteria to keep the modification data reasonably secret.

Generation of the data sets may be independent or one set may be generated from the other by introducing differences. For some embodiments when two data sets are generated either one may be used as authorization data or selection criteria. In some systems designation of authorization data versus selection criteria may be arbitrary. In some embodiments selection criteria may be generated by truncating authorization data. The authorization data and its corresponding selection criteria form an authorization pair which contains the information a launcher needs to restore functionality.

The software and or data relied upon by the software is changed in block such that corresponding modifications in block of method result in the functionality determined in block . In decision block method determines whether another combination of functionality authorization data and selection criteria is needed for a different distribution the software. If so method returns to block . The relevant license data packages are distributed in block .

In the illustrated embodiment a plurality of selection criteria data sets is shown already residing in volatile memory . For some embodiments of system the plurality may instead be a single data set. For some embodiments of system data sets may be contained within launcher whereas for other embodiments at least some of data sets may be imported into volatile memory from another source such as another computer system a media drive or non volatile memory coupled to CPU . Also in the illustrated embodiment a plurality of authorization data candidates is shown residing in storage . Storage comprises a computer readable medium such as a media disk magnetic or optical a dongle or other non volatile memory firmware BIOS or extensible firmware interface EFI . Some embodiments of system provide for one or more of authorization data candidates to be entered by a user for example by using a keyboard biometric reader scanner or other data input device.

As illustrated difference is the smallest so that an embodiment of method of is likely to select candidate in block if criteria data set was obtained in block . However if only criteria data set had been obtained in block then candidate would be selected. The possibility described earlier in which method could potentially select incorrect authorization data instead of proper authorization data would occur if candidate was actually the proper authorization data. In such a case difference rather than difference would furnish the best information for modifying protected software. If candidate provides problems for the user the software developer may furnish a diagnostic utility to the user that identifies license management conflicts and would therefore identify the reasons for non selection of candidate . The user could then decide between deleting whatever data produces candidate or else requesting a different criteria and candidate pair.

Candidate could represent random data on the user s computer or else a prior license. For example a user may have obtained a first license with an initial capability from the software developer but then upgraded to a second license. Candidate could then have been furnished by the developer in order to facilitate the first license and candidate would then have been furnished for the second license. In the illustrated representation since difference is smaller than difference the license upgrade is automatically granted by the candidate selection process although for some embodiments the user may be instructed to delete any copies of candidate to ensure that is the one selected. This form of license management is different than systems in which a software developer distributes a patch upon payment of a license fee to modify newly licensed software. Such license management systems typically modify a permanently stored copy of the software in a non volatile storage medium and thus only need to be accomplished once.

Although the present invention and its advantages have been described above it should be understood that various changes substitutions and alterations can be made herein without departing from the spirit and scope of the invention as defined by the appended claims. Moreover the scope of the present application is not intended to be limited to the particular embodiments described in the specification.

