---

title: Semantically enriched search of services
abstract: A computer-implemented method for performing a semantically enriched search of services includes: receiving a search string that a user inputs for searching services in a repository; generating queries from the search string; searching a multi-document index using the generated queries, the multi-document index including, for each of the services, an index entry comprising documents interlinked with each other, each of the documents reflecting at least one aspect regarding the service; and presenting an outcome of the search to the user in response to receiving the search string.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08886639&OS=08886639&RS=08886639
owner: SAP AG
number: 08886639
owner_city: Walldorf
owner_country: DE
publication_date: 20120419
---
Many of the applications and other software being developed nowadays rely on one or more services. Software processing is sometimes provided as web services that users can tap into using one or more programs. Various solutions involving cloud computer systems and or software as a service SaaS have been proposed for these purposes.

However the developer who wishes to employ services in an application is not always an expert in or sometimes not even familiar with the particular underlying technology that provides the service s . For example a developer may wish to create an application for a mobile device e.g. a so called app for a smartphone that exposes complex business data e.g. data managed by systems from SAP AG for easy consumption by a user. To access and fully benefit from such complex business data a number of the accompanying services e.g. SAP services must also be invoked in the mobile application. If this particular developer is not an expert in the underlying business system it can be challenging to ascertain what actions the available services provide and to select the relevant services for the developer s application.

In a first aspect a computer implemented method for performing a semantically enriched search of services includes receiving a search string that a user inputs for searching services in a repository generating queries from the search string searching a multi document index using the generated queries the multi document index including for each of the services an index entry comprising documents interlinked with each other each of the documents reflecting at least one aspect regarding the service and presenting an outcome of the search to the user in response to receiving the search string.

Implementations can include any or all of the following features. The multi document index has an index architecture comprising a service document that represents the service an entity set document that represents a data element of the service an entity type document that represents a data type of one or more entries being returned as a service response a complex type document that represents a data type of a non simple typed property a function document that represents at least one service operation of an entity set a navigation property document that represents at least one association from an entity type entity to one or more related entities of another entity type a property document that represents a field of a data type and a parameter document that represents a service operation parameter. The method further includes parsing the search string to generate one or more words for each index entry identified in the search aggregating information of related entities generating an array of results per each of the generated words scoring the array and flattening the array into a single result list. The method further includes generating one or more semantic forms of at least one of the words wherein the semantic forms are used in searching the multi document index. Generating the one or more semantic forms comprises identifying one or more synonyms abbreviations acronyms or naming conventions for at least one of the words generating for each of the words and the semantic forms a wildcard query that has a wildcard character before and after the word or the semantic form and searching the documents using the wildcard queries. The search provides multiple results and the method further includes scoring the multiple results wherein each result is given at least first and second scores for each result weighting the result using the at least first and second scores and ranking the results based on the weighting wherein the ranked results are included in the outcome of the search. The multi document index has hierarchy levels with components wherein the first score represents an average percentage of words from the search string that occur in each component of the hierarchy levels and the second score represents a percentage of the words from the search string that appear in any component of the hierarchy levels relating to the result.

A computer program product tangibly embodied in a computer readable storage medium and comprising instructions that when executed by a processor perform a method for performing a semantically enriched search of services. The method includes receiving a search string that a user inputs for searching services in a repository generating queries from the search string searching a multi document index using the generated queries the multi document index including for each of the services an index entry comprising documents interlinked with each other each of the documents reflecting at least one aspect regarding the service and presenting an outcome of the search to the user in response to receiving the search string.

A system comprising one or more processors and a computer program product tangibly embodied in a computer readable storage medium and comprising instructions that when executed by a processor perform a method for performing a semantically enriched search of services. The method includes receiving a search string that a user inputs for searching services in a repository generating queries from the search string searching a multi document index using the generated queries the multi document index including for each of the services an index entry comprising documents interlinked with each other each of the documents reflecting at least one aspect regarding the service and presenting an outcome of the search to the user in response to receiving the search string.

Implementations can provide any or all of the following advantages Allowing useable and intuitive searching of relevant services for the end user which searching can exploit an internal structure and semantics of the service repository and provide answers with low performance overhead. Indexing and scoring can be performed with a low performance footprint. A custom index architecture can accommodate rich metadata and different structures of service repositories such as by a complex structured index where various documents can be interlinked. Service discovery can employ a complex multi phase query process and aggregate the results. The service discovery can utilize both technical and business information for services and be usable by both business and technical users. A scoring function can be used in information retrieval to assign a score to each result for comparison. A custom scoring function can be used for scoring results where documents represent service artifacts and not English text. Heterogeneous vocabularies of end users can be addressed by a vocabulary such as in a custom query building process in order to map various user terminologies to the terminology used by the services. Terminology from naming conventions can be expanded into readable text before metadata is stored and indexed.

The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

This document describes examples of performing text based discovery of relevant services in one or more service repositories. Some implementations feature searching of both a textual description and a structured and interconnected meta model to find the relevant services. For example OData services can be discovered in this way such as those called OData for SAP Protocol services. Some implementations take into account that various end users may use different vocabularies to define the same thing. Before performing a search a system can normalize various vocabularies to one vocabulary that is supported by the service repository. Some implementations update the search result to account for changes in the service repository.

The service repository here includes one or more service collections having a service uniform resource locator URL and one or more service metadata documents . The service repository including the services information such as name description and URL and the service metadata documents called using these URLs is indexed as a preprocessing step. This generates the index in part or in its entirety.

When the user performs a search the index is used in order to find and display the relevant service artifacts as the search result. The synonym dictionary can also be used in this process to create the appropriate set of queries for searching the index. The synonym dictionary is created in advance and can be extended and refined using one or more processes. For example an offline learning process uses terms that appear in the service repository. As another example an online learning process uses the user search queries and selected results. The architecture can be used to perform a search over any hierarchical or object oriented model.

The following is an example of a scenario supported by the architecture . A user formulates a free text query and submits it to the system. For example the free text query may be customer cellular phone . In some implementations part or all of the architecture runs on the client side and the free text query is then submitted locally. The system analyzes the free text query and expands one or more naming conventions or heterogeneous vocabularies used by the user. This allows the system to produce a custom query that is normalized to the vocabulary of the service repository . The system then executes the custom query and produces a ranked list of one or more matching services along with the service components where the matches were found for each service in the list. For example this can highlight the search result matches.

The index here includes one or more service documents one or more entity set documents and one or more entity type documents . For example the documents and or can be created in a preprocessing indexing step. In some implementations the service repository includes one or more OData services.

The service repository can use one or more data models. In some implementations a OData data model optionally with one or more extensions such as an SAP specific extension is used. The OData model for example contains the following artifacts 

One or more indexes can then be built taking into account the structure of the services for example the hierarchical structure of the OData services. This can provide searching among all service components for each user search query while obtaining the benefits of having a single index.

In some implementations the index can be structured as follows. For each entity of the service data model an index document can be created that includes all the simple text properties of the entity as index document fields. Index document field names are unique for each type of entity in the model. Multiple types of index documents are created one per type of entity in the model each having a unique set of fields. An index document can have multiple fields of the same name with different values . For example a collection of simple text properties of an entity can easily be stored.

Also an ID field can be added for each entity with a value that is generated from the entity ID of the parent and the unique ID of the entity. For example the parent entity ID and the entity unique ID can be separated by a delimiter. When more than one parent can hold a particular entity the parent ID can be replaced by or enhanced with another ancestor ID such as the service. For example this can be the case with the relationship between Entity Set and Entity Type where more than one entity set can be of the same entity type.

Finally relations between entities are represented as a field in the index document of the entity. For example the relation can reference the related entity by holding a unique ID for the referenced entity. A reference can be from an entity to its parent entity such as from a Property to the Entity Type that contains it. Also a reference can be from an entity to its contained entity such as when an entity can be related to more than one parent entity for example as with Entity Set and Entity Type. Similarly to simple text properties a collection of references can be stored using multiple fields with the same name wherein the name represents the reference. Other index structures can be used.

The service document represents a service and contains one or more fields. The service document here includes an ID a service name a URL a description one or more entity set names one or more entity type names one or more complex type names and one or more function names. For example the ID can be based on the service name and the URL the entity set names can represent a collection of entity set entities the entity type names can represent a collection of entity type entities and or the function names can represent a collection of function entities.

The entity set document represents the data element of the service. The entity set document here includes an ID a name an entity type name and an entity type document ID. For example the ID can include a service document ID and or an entity set name. The entity type document ID can refer to the entity type document .

The entity type document represents a data type of one or more entries that can be returned as a service response such as to an entity set query. The entity type document here includes an ID and a name. For example the ID can include a service document ID and or an entity type name.

The complex type document represents a data type of a non simple typed property. The complex type document here includes an ID and a name. For example the ID can include a service document ID and or a complex type name.

The function document represents certain service operations of an entity set. In some implementations the function document represents service operations that are not Read Create Update or Delete operations. The function document here includes an ID a name a return type a documentation and a hypertext transfer protocol HTTP method. For example the ID can include a service document ID and or a function name. For example the return type can also or instead be a complex type and or an entity type name.

One or more navigation property documents can be included in the index structure . For example the navigation property documents represent associations from an entity type entity to one or more of its related entities of another entity type. The navigation property document here includes an ID a name a label a target entity type name and an origin entity type document ID. For example each of the target entity type name and the origin entity type document ID can refer to one of the entity type documents .

The index structure can include one or more property documents . For example the property document represents a field of a data type such as an entity type or a complex type. The property document here includes an ID a name a type a label semantics and an origin document ID. For example the ID can include an entity type ID or a complex type ID and or a property name. For example the type may also or instead be a complex type name. For example the origin document ID can refer to an entity type or a complex type. In some implementations the property document refers to one of the entity type document and the complex type document .

The index structure can include one or more parameter documents . For example the parameter document can represent a service operation parameter. The parameter document here includes an ID a name a type a documentation and an origin function document ID. For example the ID can include a function document ID and or a parameter name. For example the type can also or instead be a complex type or an entity type. In some implementations the parameter document refers to one or more of the function documents .

The user query e.g. the free text query in can be translated into a set of queries over the different document types of the index documents. Moreover the results can be aggregated according to relations between the entities. In each type of index document only the simple text property fields are searched for the query terms or for other semantic forms of the terms including but not limited to synonyms abbreviations acronyms and similar terms.

The semantic search component here includes a search sub component that performs a semantic search over a service index e.g. the index in .

The search component supplies a search application programming interface API such as for free text search and prefix auto completion to the design time tool .

The search component can perform searching using any suitable search platform which can provide basic search capabilities. In some implementations the open source search platform Lucene can be used. In some implementations the service index is accessed through an index management layer . Such semantic search can include logic regarding synonyms abbreviations and spellcheck over free text search. As another example logics of query prefix auto completion can be included.

The semantic search component here includes a data services indexer that divides parsed services documentation into index documents and fields. For example the services documentation can include but is not limited to metadata and useful repository information. The data services indexer can use basic indexing capabilities supplied by the search platform . The division can drive the selection or design of an index structure which in turn can impact search capabilities over the index such as which data can be retrieved. The data services indexer can supply a build index API to the design time tool .

The search platform includes service index storage and the index management layer . The index management layer creates and maintains the service index e.g. stored on a file system and enables basic search capabilities thereon e.g. without any semantic logic .

The semantic search component here includes a synonyms sub component that has a synonyms dictionary e.g. the synonym dictionary in such as a file and an abstract synonyms layer . The abstract synonyms layer creates the synonyms dictionary using any suitable technology. In some implementations the synonyms dictionary is created using WordNet. For example the synonyms dictionary can be stored on the file system and be delivered with the semantic search component . The abstract synonyms layer also allows the search sub component to find synonyms in the synonyms dictionary at runtime.

At the user clicks a search button. At the design time tool instructs the search sub component to search the free text query. At the search sub component instructs the synonyms sub component to find one or more synonyms. For example system specific terms e.g. SAP terms can be identified. At the synonyms sub component provides one or more synonyms.

At the search sub component provides the search query an all its synonymous terms to the index management layer . The index management layer provides results at .

At the search sub component provides aggregated and sorted results to the design time tool . At the design time tool presents the search results to the user .

In some implementations the user search query is translated into a set of queries over the different document types of the index documents and the results are aggregated according to the relations between the entities. In each type of index document only the simple text property fields will be searched for the query terms or for other semantic forms of these terms. For example ID and reference fields will not be searched for these terms or their semantic forms.

2. For each word a wildcard query can be performed in all the types of documents. For example a wildcard character before and after the word can be used.

3. The same process can be performed also for each known semantic form of the word. For example synonyms abbreviations acronyms etc. can be taken into account. In this case the search can be performed once with a wildcard query such as by using a wildcard character before and after the phrase and instead of spaces and once as a quoted query such as in the original form with quotation marks.

4. For each result of each type of document the information of the related entities can be aggregated. For example this can provide that each results contains the full information of its source and context such as the service it came from its related entity set s and entity type s etc.

5. For each word the search results that resulted from exactly the same index document i.e. representing the same entity instance can be aggregated and redundant results can be omitted. For example results from related entity type and entity set documents can be left out.

6. An array of results can then be created for each search query word. In some implementations the array is a 1 N vector of lists. In such a vector the ith cell of the vector can contain a list of results found while searching the ith query word. The ith query word may have been searched in its original form or in other semantic forms such as synonyms acronyms etc. For example for the query customer cellular phone the vector can contain three cells holding the search results relating to customer cellular and phone respectively. A search result that appears in more than one cell can be given a higher score.

8. After the search for each word separately an additional process of searching different forms of the whole search query string can be performed. For example this can involve synonyms acronyms etc. for the query as a whole. These other forms can be searched once as a wildcard query and once as a quoted query in analogy with the description above.

9. Duplications can be eliminated from the united result list and the list can be sorted by scoring the results such as from highest to lowest. Sometimes only part of the list is displayed to the user such as according to a threshold score. For example this can provide that not all or results are displayed to the user.

In some implementations the searching process can include a special treatment of search operators that the user may add to the search query such as and or not etc. By contrast wildcard characters may already be handled by the underlying indexing library.

In some implementations one can search for other semantic forms of the query words e.g. synonyms only if the results with the original query words are too few or have too low scores.

At the user types a search query prefix. For example the user may be interested in services relating to employees and therefore begins to type e m p . . . in a search field see e.g. the free text query in . At the design time tool instructs the search sub component to auto complete the query that has been received so far. This is an example of a simple completion done without sentence analysis. In this case the suggested completions can include the results of all index components relevant for the typed prefix. For example the step may be performed when a certain number of characters e.g. three have been typed.

The search sub component can perform one or more operations in response to the step . This is an example of a more complex auto completion based on sentence analysis. Some sentence analysis involves looking for one or more known patterns such as typing a verb that describes a possible service operation. In such situations the search can focus on a specific component of the service e.g. an entity set or property because the part of speech of the typed query sentence has been recognized. For example assume that a user wishes to search for find employees by followed by an arbitrary term. When the user begins typing the character sequence f i n d e m p the processing can be done as follows. The assumption is that after a verb here find should come an entity name e.g. an Entity Set or Entity Type of the data model . Then when the user continues typing b y as prefix of find employees by . . . the system understands that after the by should probably come a property name of the selected entity e.g. a Property or Navigation Property of the data model .

Thus in some implementations one or more of multiple alternative steps can be performed. For example a step A can be performed when completion of an entity set is required. In step A the search sub component can instruct the index management layer to search the index for one or more entity sets based on the prefix typed by the user. At A the index management layer can provide one or more entity set results in response.

As another example a step B can be performed when completion of a property is required. At B the search sub component can instruct the index management layer to search the index for one or more properties based on the prefix typed by the user. At B the index management layer can provide one or more property results in response.

In some implementations the auto completion can consider multiple variables. For example the query sentence structure the different service components and or the allowed operations on them as read create update delete filter etc. can be considered.

In some implementations all auto completed queries can be searched as a free text query to display the appropriate search results with more details. For example this can involve displaying the service context using highlighting etc.

At the search sub component provides one or more possible query completions to the design time tool . The design time tool presents the one or more possible completions to the user at . This can involve displaying one or more entity sets properties and or other components of the index architecture to the user. For example one or more services service descriptions or functions can be presented.

Search results are ranked. In some implementations search results that are sourced in hierarchical entities should consider the whole context in order to calculate the relevance of the result to the user. For example the term s position in the hierarchy and or the amount of components having the search can be taken into account.

In some implementations scoring can be performed as follows. Each result can be provided two or more scores. That is the result originates in a specific index document representing a specific component of the hierarchy which is part of an entity so the multiple scores can consider different aspects of the result context.

A component score can be used that represents the average percentage of query words that appear in each component of the hierarchy levels. Such a score can reflect the amount of levels in which each query word has a match. For example if the hierarchy includes Property Entity Set and Service levels then each result can be given three scores a property score for the percentage of query words that match the related property index document an entity set score for the percentage of query words that match the related entity set index document and a service score for the percentage of query words that match the related service index document. The component score can then be the average of the property entity set and service scores.

A cross component score can be used that represents the percentage of query words that appear in any component of the hierarchy levels that relate to this search result. For example if the hierarchy has Property Entity Set and Service levels then there is calculated for each result the percentage of query words that match any of the related index documents e.g. the property its entity set or its service .

Scores can be weighted. In some implementations a component score and a cross component score can be weighted. For example the component score can be multiplied by a factor 0.3 and the cross component score can be multiplied by a factor 0.6 and the multiplications can be added.

In some implementations the scores can be boosted according to different criteria for example since the first query word is usually more important than the others the results including the first word can be boosted. As another example results can be boosted where different query words appear on the same field of the same index document or boosting results origins in a specific index field which may be considered as more important or more reliable such as an entity label value which does not include technical names as the entity name field .

In some implementations results originating in longer words are boosted. For example there may be a higher possibility for relevancy and reliability of the result when a longer string is matched especially when the search considers substring of terms and not only exact terms.

At the design time tool provides an instruction to get all services to the service repository . At the service repository provides one or more services URLs and repository information in response.

One or more loops can be performed. For example a loop involving the design time tool and the service repository can be performed. At the design time tool provides an instruction to get service metadata to the service repository . At the service repository provides one or more portions of service metadata in response.

At the design time tool provides a build index instruction to the data services indexer . For example the instruction can be to build one or more indexes from the parsed metadata of all services and their repository information.

Next a loop of one or more operations can be performed. For example one or more index documents can be provided to the index management layer for being added to the index. At an index document with service details can be provided. At and respectively can be provided index documents with entity set details entity types details and properties details. Other index documents can be added in some implementations.

In some implementations a solution can be extended to perform service composition. For example the system can analyze the user query understand the desired operation the user would like to perform using the available services and suggest a sequence of service operations and or components to query that together will compose the desired operation.

For example this may be supported using a search of combination of services which may have some operations entry types or properties that can be related together among the services in order to perform the desired action. As another example this combination can be used to compose a new service that uses the other services to perform the desired operation or to suggest the sequence of operations by the different services in the combination that should be used to perform the desired operation.

In some implementations a solution can be extended to get more resources for understanding the semantic context of a search query and for getting other semantic forms for the query terms except for a pre defined dictionary .

In some implementations other possible extensions to the system in order to improve and refine the performed searches include 

Using the application context such as the types and variables names that are used as additional semantic information for performing the search and for displaying results that better match the developer needs of a service consumption. For example this can be done when the search is performed directly from the development environment where the application consuming the service is developed.

Learning from searches performed by different users as well as the result finally selected from the search result list in order to display more relevant results for similar future searches.

Allowing users to add their own terms and synonyms to the dictionary used by the system in order to improve future searches performed by the same and or other users .

The memory stores information within the system . In some implementations the memory is a computer readable medium. The memory is a volatile memory unit in some implementations and is a non volatile memory unit in other implementations.

The storage device is capable of providing mass storage for the system . In one implementation the storage device is a computer readable medium. In various different implementations the storage device may be a floppy disk device a hard disk device an optical disk device or a tape device.

The input output device provides input output operations for the system . In one implementation the input output device includes a keyboard and or pointing device. In another implementation the input output device includes a display unit for displaying graphical user interfaces.

The features described can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier e.g. in a machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. A computer program is a set of instructions that can be used directly or indirectly in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language including compiled or interpreted languages and it can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment.

Suitable processors for the execution of a program of instructions include by way of example both general and special purpose microprocessors and the sole processor or one of multiple processors of any kind of computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally a computer will also include or be operatively coupled to communicate with one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory can be supplemented by or incorporated in ASICs application specific integrated circuits .

To provide for interaction with a user the features can be implemented on a computer having a display device such as a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.

The features can be implemented in a computer system that includes a back end component such as a data server or that includes a middleware component such as an application server or an Internet server or that includes a front end component such as a client computer having a graphical user interface or an Internet browser or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include e.g. a LAN a WAN and the computers and networks forming the Internet.

The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

A number of implementations have been described. Nevertheless it will be understood that various modifications may be made without departing from the spirit and scope of this disclosure. Accordingly other implementations are within the scope of the following claims.

