---

title: Data pattern for storing information, including associated version and audit information for use in data management
abstract: Information is stored in a data pattern. The data pattern includes an identity table, a version table that includes at least one reference to the identity table, and an audit table that includes at least one reference to the version table. The identity table stores information identifying the information. The version table stores version information identifying one or more versions of the information identified in the identity table. The audit table stores audit information identifying when each of the one or more versions of the information was modified. The audit table may also store effectiveness information identifying when each of the one or more versions of the information is in effect.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08782070&OS=08782070&RS=08782070
owner: Oracle International Corporation
number: 08782070
owner_city: Redwood Shores
owner_country: US
publication_date: 20120813
---
This application is a continuation of U.S. patent application Ser. No. 12 139 327 entitled DATA PATTERN FOR STORING INFORMATION INCLUDING ASSOCIATED VERSION AND AUDIT INFORMATION FOR USE IN DATA MANAGEMENT filed Jun. 13 2008 and issuing on Aug. 14 2012 as U.S. Pat. No. 8 244 716 naming Laurence W. Becker Mark Kleidon and Brent Thomas Jenkins as inventors. This application is assigned to Oracle International Corporation the assignee of the present invention and is hereby incorporated by reference in its entirety and for all purposes.

This invention relates to data management and more particularly to a data pattern for managing information.

Various data processing systems such as customer relationship management systems use several types of information. Two such types of information are reference information and transactional information. Transactional information identifies a particular transaction e.g. such as an order placed by a customer . Transactional information contains references to reference information which identifies various entities e.g. such as products and customers that are affected by or involved in the transaction identified by the transactional information.

Reference information can be modified over time. For example a computer retailer may update the reference information describing a particular software product as new releases of that software become available. Similarly if a customer changes her name or contact information a retailer can update the reference information for that customer to identify the customer s new name and or contact information.

Reference information can also be designed to expire or otherwise become ineffective over time. For example a retailer may specify a seasonal sale price for a product where the seasonal sale price is only effective for a limited time. Similarly a contract employee may be employed for a limited time which can be reflected by the reference information for that employee specifying a particular effectiveness period bounded by the employee s beginning and ending dates of employment.

Because of the variable nature of reference information over time many data processing systems support functions to recreate the particular state of a particular entity described by the reference information at a specific point in time. For example some systems provide a function such as auditing which provides a user with information identifying how a particular entity described by reference information has been modified over time. Other functions can show the various time periods during which a particular entity described by the reference information was effective. Similar functions can be used to change reference information to a state that existed at another time e.g. such as an undo or redo function or a restore function .

Currently various data patterns are available to store information included within and or associated with reference information. Typically a different data pattern is used to store information for each specific function to be performed on the reference information. Thus the same reference information may be represented by many different data patterns each of which is only used to perform a single function. Unfortunately maintaining the same reference information in multiple data patterns leads to confusion inefficiency and or inconsistency. Accordingly new techniques for maintaining reference information are desirable. Such techniques are also desirable for maintaining transactional information.

Various systems and methods are disclosed for maintaining a data pattern for storing reference or transactional information including associated version and audit information. In one embodiment a method involves storing information in a data pattern and then accessing that information. The data pattern includes an identity table a version table that includes at least one reference to the identity table e.g. the version table can include multiple references back to the identity table and an audit table that includes at least one reference to the version table e.g. the audit table can include multiple references back to the version table . The identity table stores information identifying the information. The version table stores version information identifying one or more versions of the information identified in the identity table. The audit table stores information identifying when each of the one or more versions of the information was modified. The audit table can also store effectiveness information identifying when each of the one or more versions of the information is effective.

The foregoing is a summary and thus contains by necessity simplifications generalizations and omissions of detail consequently those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting. Other aspects inventive features and advantages of the present invention as defined solely by the claims will become apparent in the non limiting detailed description set forth below.

While the invention is susceptible to various modifications and alternative forms specific embodiments of the invention are provided as examples in the drawings and detailed description. It should be understood that the drawings and detailed description are not intended to limit the invention to the particular form disclosed. Instead the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

As shown in the data pattern for storing information includes a set of three tables such tables can also be referred to as databases an identity table a version table and an audit table . These tables can be implemented using database software e.g. a relational database management system such as Oracle Database provided by Oracle Corporation of Redwood Shores Calif. .

Identity table includes one or more rows such rows can also be referred to as records . In one embodiment a separate identity table is maintained for each type of entity for which information is maintained. Examples of types of entities that can be identified in an identity table include employees customers products territories territory nodes companies and the like. Each row in identity table represents an instance of the entity represented by the identity table. For example a row in an Employee identity table can identify a particular employee.

Identity row includes a primary key which uniquely identifies the particular instance associated with the row. Primary key is a one column identifier columns can also be referred to as fields that references a natural key or several such natural keys if available within the row. A one column primary key identifier is also referred to as a surrogate primary key.

In some alternative embodiments primary key is implicit instead of being an explicit column as shown in . For example primary key can be the absolute or relative position of identity row within identity table a sequence number or timestamp associated with identity row e.g. identifying the relative order or time at which identity row was added to identity table or other information unique to identity row but not necessarily included within identity row .

Identity row also includes a natural key . Natural key can include one or more columns within identity row that store user keys and or unique identifiers that define ownership of the particular instance described by identity row . In one embodiment primary key references the natural key .

Identity row can also include system attributes associated with the entity. For example one system attribute can indicate whether all or some of the information describing the instance has been archived. Similarly another system attribute can indicate whether all or some of the reference information is system information. Yet another system attribute can describe whether all or some of the information has been locked to prevent unauthorized modification. System attributes can also indicate whether the information is linked to other independent information or whether the information is federated information.

In this example none of the information contained in identity row is versioned information. In other words all of the information in identity row is information that is not versioned over time. Accordingly if the system attributes associated with identify row are modified these changes are not tracked nor are these changes auditable. Once created identity row will not be deleted even if the information e.g. stored in the version and audit tables described below associated with identity row is modified or even deleted .

Version table stores information representing one or more versions of an instance of an entity. Each version row within version table stores information representing one particular version of an instance of an entity.

As shown in version row includes a version identifier e.g. a single column primary key for version row which can also be referred to as a surrogate primary key for version row that uniquely identifies version row within version table . Version row also includes a foreign key that refers to the appropriate surrogate primary key in identity table . In this example foreign key of version row refers to primary key of identity row e.g. this can be effected by setting the value of foreign key to equal the value of primary key . This indicates that version row stores information describing a version of the instance of the entity identified by identity row .

Thus the foreign keys in version table allow each version row to be linked to a particular identity row. Similarly all of the rows of version table that are associated with the same instance of an entity can be identified by simply searching version table for all rows having foreign keys that identify the primary key of the identity row for that instance of the entity.

Each time an instance of an entity is modified a new version row is created in version table . Thus multiple version rows can be associated with the same instance of the entity such that multiple version rows have the same value of foreign key . Individual version rows can be distinguished by their respective version identifier .

Version row also stores one or more version attributes . Each version attribute can be stored in a separate column. Each version attribute is an item of information e.g. such as a name address description stock symbol and the like that can be versioned over time. For each version attribute version row can store an attribute name and an attribute value. It is noted that some version attributes can be references to other sets of information e.g. a version attribute of an employee record can reference a company record . Thus the value of some version attributes can be foreign keys that have values equal to the primary keys of identity rows of other records as shown in .

Similarly the employee s attributes can include foreign keys that refer to other entities. In this example the employee version table B includes an employee version row that includes foreign key B which references primary key B of the employee s identity row. The row in employee version table B also includes version attributes B which include foreign key B which references the primary key used to identify the organization s identity row in organization identity table A . Thus foreign key B indicates that the employee is an employee of the organization.

Returning to it is noted that version row does not include attributes that define audit times e.g. the time at which the version was created or effectivity periods e.g. times at which the version is no longer effective . Instead this information is maintained in audit table as described below.

While a version row does not store temporal attributes that define audit times and effectivity periods the version row can store temporal information. For example the version attributes can include attributes such as Date of Birth Date of Death Hiring Date and the like.

In at least some embodiments existing versions are not modified or permanently discarded even though those versions may currently be ineffective. In other words version rows are not deleted from version table over time however version rows can be archived as described in more detail below . Accordingly the data pattern can be described as non destructive since no information about preexisting versions is ever lost. The non destructive nature of the data pattern can be used to among other things provide a non destructive record of all versions of a particular instance of a particular entity that ever existed as well as to allow a user to roll back all changes that have ever been made to a particular item of information.

Audit table is a table that stores information referred to herein as effectiveness information representing when particular versions of an instance of an entity are effective as well as information referred to herein as audit information indicating when each version was modified. Modifications are identified as the creation i.e. activation of a new version and or the deletion i.e. deactivation of a prior version if any. For example if a user requests to modify a version attribute of an entity an existing version row storing the original value of the version attribute will be deactivated and a new version row storing the modified value of the version attribute will be activated. In general modifications can involve the creation of a new entity which involves activating a version row and or the modification of an existing entity which involves deactivating one or more version rows and activating one or more version rows.

Each row in audit table is associated with a row in version table . Accordingly each row in audit table identifies when a particular version is effective and was modified.

Each audit row includes an audit identifier which is a single column primary key also referred to herein as a surrogate primary key that uniquely identifies an audit row within audit table . Each audit row also includes a foreign key which references a version row in version table e.g. this reference can be effected by setting the value of foreign key to equal the value of primary key in the appropriate version row .

Audit row also includes columns for several effectiveness attributes including temporal attributes that identify the time period in which that associated version is effective. For example effectiveness attributes can include attributes that define a beginning effective date and an ending effective date.

Audit row also includes audit attributes which can include temporal attributes indicating when an associated version was created or modified. For example audit attributes can include an activation date e.g. representing when the associated version was created an activation user identifier e.g. identifying the user who created the associated version a deactivation date e.g. representing whether the information identified by the associated version was subsequently modified thus triggering creation of a new version and a deactivation user identifier e.g. identifying the user who triggered creation of a newer version .

Just as there can be multiple version rows associated with a single identity row there can also be multiple audit rows associated with a single version row. For example if a user changes the effectiveness period for the information without otherwise modifying any version attributes of the information stored in version table this change can be effected by simply adding one or more new rows to the audit table. In other words a given audit record describes a single usage of a version record in the two dimensional timespace of effectiveness time and audit time for a given identity record . A given version record may appear at multiple points in the timespace each of which is described by an audit record .

One type of information that can be stored in the data pattern of is profile information which can in turn be referenced by reference information. The profile information can store metadata for a particular type of reference entity which may be used to control creation of records storing reference information for that type of entity. The versioned attributes that can be included in the profile information can include information identifying attributes required to be included in a particular type of reference record information identifying attribute constraints information identifying a particular centralized calendar described below to be used with the reference record and the like.

Yet another type of information that can be stored in the data pattern of is type information. Type information can include versioned attributes that identify a profile record a conflict resolution strategy and the like that provides context for a particular type of reference entity.

Membership and or relationship information which can each define a many to many relationship can also be stored in the data pattern of . Membership information can be used to group records corresponding to individuals through references to each individual s record. Versioned attributes of membership information can include attributes such as rank.

There are many different techniques that can be implemented using the data pattern of . One to many relationships can be established by storing parent child relationship information in the data pattern of . In particular the identity row of a child record can include a foreign key reference to the identity record representing the parent entity.

In some embodiments extension records can be added to the data pattern of . In one situation extension records can be stored in an additional extension table whose rows can be referenced by columns within a version row of the record being extended. This additional table allows new version attributes to be added to the record without modifying the existing version table. The rows in the additional extension table can be described by the same audit information associated with the version row within the referencing record such that each of the referencing record s audit rows can reference both a version row and a row in the additional extension table.

In other situations it may be desirable to provide extension records that include some sort of context. For example it may be desirable to introduce a class of new attributes to an existing record. In this situation the new attributes can be stored in their own data pattern e.g. having identity version and audit tables and the new attributes themselves can be stored as columns in the extension record s version table. The identity table of the extension data pattern can include columns that identity the record as being an extension record i.e. to indicate that such a record is effectively part of the record that is being extended . The identity table of the extension data pattern also includes a foreign key that references the primary key of the record being extended.

Hierarchy information can also be stored in the data pattern of . Hierarchy information can include versioned attributes that identify the nodes in the hierarchy and the parent child relationships between those nodes. In one embodiment the version row of a hierarchy record can include columns for each level of the hierarchy and the values of those hierarchy level columns can reference independent hierarchy level records. The hierarchy level records can then include versioned attributes describing a respective level of the hierarchy. Similarly a hierarchy record or hierarchy level record can reference a hierarchy node record that stores versioned attributes describing a respective node within the hierarchy.

Like the data pattern of the data pattern of includes a set of three tables such tables can also be referred to as databases an identity table a version table and an audit table . Identity table and version table are very similar to the similarly numbered tables shown in . In contrast audit table of differs from audit table of in that audit table does not include any effectiveness attributes. Thus an audit row in audit table includes audit identifier which is a single column primary key also referred to herein as a surrogate primary key that uniquely identifies an audit row within audit table . Each audit row also includes a foreign key which references a version row in version table e.g. this reference can be effected by setting the value of foreign key to equal the value of primary key in the appropriate version row and audit attributes . Since the data pattern of does not include effectiveness attributes this data pattern is suited for storing information such as transactional information which does not have effective dates because the transactional information describes an event.

As an example of how reference information can be stored in the data pattern of consider a situation in which a user e.g. a program salesperson or human administrator creates a new customer record as used in this context a record includes a row in the identity table as well as one or more related rows in the version and audit tables for a customer named Mary Smith. Initially the user interacts with some sort of interface e.g. an application programming interface API command line interface CLI graphical user interface GUI or the like and provides input e.g. by entering text selecting an option with a mouse or other tool or the like indicating that the user would like to create a new customer record.

In some situations the user may also specify one or more attributes along with the request to create a new customer record in other situations some attributes may be specified at a later time e.g. if the customer is using a menu based or wizard system . In this example the user specified attributes include the customer s first and last name.

In response to the user s request to create a new customer record a data pattern module e.g. a software routine or process creates a new row in a customer identity table. A unique primary key ABC123 is associated with the new identity row for simplicity the only column shown in this identity row is the primary key column 

The data pattern module then creates a new row in the version table and causes the foreign key in this new version row to reference the newly created identity row. This new version row has an associated unique primary key 1 . The data pattern module also adds two version attributes first name and last name to the new version row and sets the values of these version attributes to Mary and Smith respectively. Accordingly the version table contains the following information for simplicity the only columns shown in this version row are the primary key foreign key and two version attribute columns 

The data pattern module then creates a new row in the audit table having a foreign key that references the newly created version row. This new audit row has a unique primary key A . The data pattern module also adds a beginning effectiveness date attribute an activation date attribute and an activation user attribute to the new audit row. The beginning effectiveness date attribute identifies the date when the new record becomes effective and the activation date attribute identifies the time at which the new record was created. In the illustrated embodiments both happen to be represented by the same timestamp however the activation date attribute has a higher resolution e.g. including a calendar date and time in minutes and seconds than the resolution e.g. including merely a calendar date of the beginning effectiveness date attribute. The activation user attribute not shown identifies the user that initiated the request. Accordingly the audit table contains the following information for simplicity the only columns shown in the audit row are the primary key foreign key two effectiveness attributes and two audit attributes 

The data pattern module can also set an ending effectiveness date attribute and a deactivation date attribute in the new audit row. Since the user did not specify this information and no such information can be inferred from the user s actions i.e. the user is not deactivating this version with the current request these attributes have a default value that indicates the end of time e.g. a special value such as null or predetermined date set far in the future such as 9 9 9999 .

At some time in the future Mary Smith plans to change her name e.g. in response to a change in marital status . This change is set to occur at the end of the present year but is identified several months earlier. In order to continue to be able to accurately identify the customer a user can send a request to update the customer s record to the data pattern module e.g. using one of the interfaces described above on or around the date that the upcoming change is identified. The request can include the primary key of the identity row associated with the customer. The request can also include the new last name Henrack for the customer as well as the date at which the name change will become effective alternatively this attribute information can be provided subsequent to the request .

In response to this request the data pattern module creates a second row in the version table. This second version row includes the same foreign key and first name attribute as the first version row but has a different primary key 2 and last name attribute Henrack instead of Smith .

The data pattern module also modifies the first audit row described above to include a deactivation date which is set equal to the date on which the user requested the name change. This renders the first audit row inactive. The data pattern module can also set the value of the deactivation user identifier in the first audit row not shown to identify the user that initiated this new request to change the customer s last name.

In order to provide a non destructive data pattern the data pattern module does not modify any of the effectiveness information in the first audit row. In order to indicate when the prior version in the first version row became ineffective the data pattern module also creates a second audit row which references the first version row i.e. the row that identifies the version of the customer named Mary Smith . This second audit row has an activation date equal to the date on which the user requested the change and an ending effectiveness date specifying the end of the current year i.e. the date on which the customer will stop being called Mary Smith . Other attributes in the second audit row such as the beginning effectiveness date can be the same as that in the first audit row.

The data pattern module additionally creates a third audit row which references the second version row i.e. the row that identifies the version of the customer named Mary Henrack . The beginning effectiveness date attribute of the third audit row identifies the beginning of the next year i.e. the date on which the customer will begin being called Mary Henrack . In contrast the activation date attribute of the third audit row has the same value as the activation date attribute of the second audit row which specifies the date on which both rows were created.

After these changes are implemented the audit table contains three rows corresponding to the customer 

It is noted that the data pattern module can update and create rows in any order. For example the data pattern module can create the second and third audit rows prior to modifying the first audit row such that the first audit row remains active until after the second and third audit rows have been created and populated with attribute information.

The day after the customer information is updated to reflect the upcoming name change the user discovers that the customer s new last name was misspelled and should actually be Henrick. To reflect this change the user requests another update of the customer s reference information.

In response to the user s request the data pattern module creates a third row in the version table. Like the first and second version rows the third version row references the primary key of the identity row associated with the customer. Furthermore this third version row also has the same first name attribute value Mary . The third version row has a different last name attribute value Henrick however.

The data pattern module also modifies the third audit row this is the audit row that indicated when the second version row became effective to include a deactivation date value equal to the date on which the user requested the correction. The data pattern module can also update a deactivation user attribute not shown to identify the user that requested the correction.

The data pattern module then creates a fourth audit row that references the newly created third version row i.e. the row identifying Mary Henrick . This fourth audit row has the same beginning effectiveness date as the third audit row and a default ending effectiveness date and deactivation date. Since this fourth audit row has the same effectiveness period as the third audit row an additional audit row is not needed i.e. only one audit row needs to be created to store this change while two audit rows were used for the name change above . The activation date of the fourth audit row is the date the user requested the correction.

In the above example user supplied reference information stored in the data pattern is never modified. Instead new rows are created to store new user supplied reference information. The only reference information that is modified is the deactivation date in the audit table. This reflects the non destructive nature of the data pattern which stores information clearly identifying all versions of the reference information that ever existed even if those versions never became effective as well as identifying each time that the reference information was modified and who initiated the modification.

As the above example shows in some embodiments the only information that is ever modified within the data pattern is the audit information such as the deactivation date and user initiating the deactivation. Thus all other information including effectiveness information is preserved from the time of its creation.

As noted above reference information like that describing the customer above is information that is referenced by transactional information describing a transaction. When Mary places an order transactional information describes the order and contains a reference e.g. the transactional information can include a customer column storing a foreign key that has a value equal to the primary key ABC123 for Mary s row in the data pattern s identity table to the identity information in the data pattern describing Mary. Because the transactional information references the identity table which is never purged the link from the transactional information to the reference information will never be destroyed even if Mary s reference information is later modified. Similarly by simply using references to the identity row associated with Mary each time Mary places an order the transactional information describing the order will always refer to the version of Mary s reference information that is active and effective at the time the order is placed.

Furthermore the effectiveness and audit information in Mary s reference information allow the transactional information to always obtain the correct version of the reference information. For example if information e.g. an invoice pertaining to an order needs to be recreated after the order was placed and a new version of the reference information is active when the information is being recreated the information in the version table can be used to obtain the appropriate version of the reference information that was in place at the time the order was placed. Specifically assume Mary placed an order on Oct 12 2008 and the invoice associated with that order needs to be recreated on Jan 7 2009. The transaction i.e. Mary s order is described by transactional information that has a transaction date identifying the date on which that transaction occurred Oct 12 2008 . The transactional information can also include audit information including a creation date which identifies when that transactional information was created and a last modified timestamp which identifies the most recent time at which the transactional information describing Mary s order was modified. Using the transaction date and the appropriate transactional audit information the audit table can be searched for the row e.g. Row B that identifies a version that was in effect on the transaction date Oct 12 2008 and that was active on the particular audit date e.g. as indicated by the creation date in the transactional information for which the information is desired. The information in the version row e.g. Row 1 identified by the identified audit row can then be used to recreate the invoice. Accordingly any preexisting version of reference information can be recreated based on an transaction date for the transaction which is used to query the effectiveness information in the audit table and an audit date for the transaction which is used to query the audit information in the audit table.

Note that in certain other situations it may be desirable to use the current date and or time as opposed to transaction specific information to query both the effectiveness and audit information of the data pattern. For example if it is desirable to use the current version of the reference information when generating information e.g. such as a product recall notice for a transaction the appropriate version can be found by simply using the current date to query the audit information and the effectiveness information. If it is desirable to send all customers who ordered a particular product a notice regarding that product s recall status on Feb. 2 2009 which is also the current date in this example and if Mary ordered that product in October of 2008 the Feb. 2 2009 date can be used to search for the audit row e.g. Row D associated with Mary that identifies a version that is both effective and active on Feb. 2 2009. The identified audit row can be used to identify the version row e.g. Row C that stores the version of Mary s reference information that is effective and active on Feb. 2 2008. This version of Mary s reference information can then be used to contact Mary regarding the recall.

A new row in the version table for that type of entity is also allocated as shown at . This new version row references the new identity row allocated at . If any versioned attributes describing the initial version of the new entity are received e.g. as part of the request or subsequent to the request the values of these versioned attributes can be stored in the new version row.

A new row is also allocated as shown at in the audit table for the type of entity being created. This new audit row references the new version row created at . Audit information identifying the time of the record s creation e.g. an activation date is stored in the new audit row as shown at . Other audit information such as the identity of the user that requested the creation of the new record at can also be stored in the new audit row. The audit information is not supplied by the user instead it is generated by the software allocating the new row e.g. dates can be obtained from a centralized clock or timer that generates timestamps .

Similarly in embodiments in which the data pattern stores effectiveness information effectiveness information e.g. an initial effectiveness date identifying the effectiveness of the associated version i.e. the version identified by the new version row referenced by the new audit row is also stored in the new audit row as shown at . This effectiveness information indicates the time period during which the associated version is effective. For example if the entity for which the record is being created is a product and the version of the entity identified in the new version row includes special sale pricing the effectiveness information can indicate the starting and ending date of the sale. Similarly if the entity is a contract employee the effectiveness information can indicate the beginning and ending dates of that employee s contract employment.

Some of the information in the new audit row may have a default value when the new audit row is allocated. For example the ending effectiveness date and the deactivation date for the record can each initially have a default value specifying the end of time. If user input specifying a value for one or both of these dates is received when the record is created however that information can be stored instead of the default information.

Furthermore in some embodiments a centralized calendar e.g. maintained as a set of rules or policies can be used to control the effectiveness information that is provided by the user. For example a company may use one or more centralized calendars to specify that new versions of certain types of reference information e.g. such as that describing new products can only become effective at certain times e.g. at the beginning of a new quarter . Different effectiveness constraints can be specified for different types of records e.g. some can be controlled by a payroll calendar while others are controlled by a fiscal calendar . Accordingly if a user inputs a beginning or ending effectiveness date that date can be verified against the calendar in order to determine whether the dates are allowable beginning and or ending effectiveness dates for the type of record being modified. If the user specified beginning or ending effectiveness date is not allowable the user can be prompted to enter a new date and optionally given information identifying allowable dates . Alternatively a default date e.g. the next allowable date can simply be substituted for the user specified date.

The method begins at when user input requesting to modify a record is received. The user input can include a command e.g. such as write delete or the like used to modify attributes within records as well as information e.g. the primary key associated with the record s identity row identifying the record. The user input can also include information e.g. column headers identifying the attribute s to be modified within the record e.g. ending employment date in the above example .

The user input can optionally include the effectiveness dates to be included in the effectiveness information associated with the new version of the record in embodiments that maintain such information . If no effectiveness dates are provided the user can be prompted to enter such dates or default value e.g. the current date for the beginning effectiveness date and the end of time for the ending effectiveness date can be used. As noted above such effectiveness dates can be verified against a centralized calendar.

In response to this user input a determination can be made as to whether the modification affects any system attributes of the reference record as shown at . If so the system attributes in the identity row allocated to the reference record can be modified as shown at . As noted above system attributes can be stored in the identity row of the reference record and thus modification of system attributes does not require the allocation of new version or audit rows.

If the modification instead or additionally affects attributes of the record other than system attributes as detected at a new row in the version table which references the identity row allocated to the record in the identity table is allocated for the record as shown at . This new row in the version table stores the current value of the versioned attributes of the record including those values that resulted from the modification requested at .

Additionally one or more new rows in the audit table are allocated. In particular if the modified version has the same effectiveness dates as the previous version a single new row is allocated in the version table as shown at and . This new audit row references the new row in the version table that was allocated at . The new audit row can include information identifying the effectivity of the version described by the values in the new version row as well as information identifying when the modification occurred e.g. as an activation date identifying the time at which the new version became active and or any other desired audit or effectivity information e.g. such as the identity of the user that requested the modification .

If instead the effectiveness dates of the new version stored in the version row allocated at differ from those of the prior version two new rows are allocated in the audit table as shown at and . The first new audit row references the prior version and the second new audit row references the new version row allocated at . The first audit row has the same beginning effective date as the audit row that references the prior version and an ending effective date equal to the beginning effective date of the new version. The second audit row has the beginning effective date specified for the new version. Thus the ending effective date of the first new audit row is the same as the beginning effective date of the second new audit row.

In addition to inserting one or more new audit rows a preexisting row of the audit table which references a preexisting prior to allocation of the new row at row of the version table is also modified as indicated at . The preexisting row of the audit table is the row that previously identified the current version prior to creation of a new version at . The preexisting row can be identified by searching the audit table for a row that identifies an active and effective version of the reference record prior to creation of the new version. This preexisting row can then be modified to indicate that the preexisting version is no longer active by modifying the deactivation date to specify the time at which the modification requested at occurred. This deactivation time can be the same as the activation time of the new audit row created at .

In some situations e.g. such as those that arise when a user makes a modification that is retroactive such that the beginning effective date of the modified version is earlier than the current date several preexisting rows may need to be modified as part of operation . Additionally more than two new audit rows may need to be inserted as part of operation in certain situations.

It is noted that no matter how many attributes are affected by the requested modification the number of I O operations needed to perform the requested modification will remain relatively stable. Thus if the request changes a large number of versioned attributes the request can be satisfied by simply changing all of the appropriate columns in the newly allocated version row. A few e.g. two or three audit rows contain the audit and effectiveness information for all of these changes and thus extra I O operations are not needed to capture audit and or effectiveness information for each individual change. In one embodiment the number of I O operations is constant. If the effectiveness information for the new version is the same as that for the prior version three rows are modified one is a new version row allocated to contain the updated version attributes another is a new audit row and the other is the preexisting audit row otherwise four rows are modified the three mentioned above plus a fourth new audit row .

The method begins at when user input requesting creation of an audit trail for a particular record is received. The user input can include for example a command associated with audit trail creation as well as information e.g. the primary key associated with the record s row in the identity table identifying the record.

In response to the request for an audit trail all of the version rows that are part of the record are identified as indicated at . Operation can be performed by searching the version table for all rows that reference the record s identity row i.e. all version rows having foreign keys that have the same value as the primary key of the record s identity row .

All of the audit rows referencing the identified at version rows can then be identified as shown at . Operation can be performed for example by searching for all audit rows having foreign keys that have the same value as one of the version identifiers used by the identified version rows.

At the audit information e.g. activation and or deactivation dates and or effectiveness information if any in the identified at audit rows is used to order the identified at version rows. For example the version rows can be ordered based upon the activation dates contained in their associated audit rows. Thus if a first version row was activated prior to a second version row as determined based upon the audit information in the audit rows associated with the first and second version rows the first version row can be ordered prior to the second version row.

In one embodiment ordering is performed in two phases. The first phase uses the beginning effectiveness date. For effectiveness records that have the same beginning effectiveness date only the first one based on activation date should be used in the comparison. Starting with the oldest beginning effectiveness date in the identified effectiveness records a comparison is made by querying the audit information for an activation date that is the same as the beginning effectiveness date. The beginning effectiveness date in the audit row identified in the comparison is then used to make the next comparison. In the second phase any ignored effectiveness records i.e. those having the same effectiveness date as another audit record and whose beginning effectiveness dates were not used in the comparison are used to build a branched comparison trail. This technique can be used to identify retroactive modifications or modifications made to an entity having pre existing future versions i.e. versions that are already stored in the version table but not yet effective as indicated by the effectiveness information associated with those versions .

The columns of the identified version rows can then be compared to determine what changes occurred between versions as indicated at . In other words for a given column that stores values of a particular version attribute e.g. such as a first or last name the value of that column in each of two rows can be compared to determine whether that particular version attribute changed between versions. In the above example describing the customer reference record for example changes to the customer s last name would be detected between versions e.g. the value of the column storing the last name attribute was changed from Smith to Henrack between versions 1 and 2 and then from Henrack to Henrick between versions 2 and 3 . If the value of a particular column differs between two consecutively ordered version rows a change is identified.

At information identifying the changes identified at as well as the order of those changes is returned to the user that requested the audit trail. The returned information can be returned by storing the returned information into an audit table which includes a row for each attribute that has been modified if an attribute has been modified multiple times a separate row is included for each modification . The returned information can also include other audit information as well as effectiveness information if any obtained from the identified audit rows. For example for each identified change the returned information can include information identifying the user that requested that change as well as the time at which that change occurred and or was requested. For the customer reference record example provided above the returned audit trail could include information indicating that the last name was changed from Smith to Henrack in response to a request received on Aug. 24 2008 and that the last name was changed from Henrack to Henrack in response to a request received on Aug. 25 2008. In one embodiment the audit information includes the following attributes all of which can be returned as part of an audit trail activation date activation user activation source activation method activation reason activation service run batch run job deactivation date deactivation user deactivation source deactivation method deactivation reason deactivation service run batch run job.

The method of is performed in response to a user request for an audit trail and uses audit information that was stored in the reference record prior to the receipt of the request for the audit trail. This method thus differs from many conventional systems which only begin recording audit information when an audit has been requested e.g. through activation of an audit trail function . In conventional systems audit tables are populated in real time such that performance of any modification to a record will involve updating the audit tables if the audit trail function has been activated. This can significantly impact performance since an additional row must be inserted into the audit table for each attribute being modified by a particular operation.

In contrast the use of the data pattern described herein allows audit information to be captured on the fly in a manner that only requires one to two new audit rows to be added in response to a particular operation regardless of the number of attributes being modified by that operation. This audit information in the data pattern can then be used to generate audit tables on demand using the method of . Additionally the data pattern described herein stores entire versions such that an appropriate record can be identified for any given audit date and effective date. In contrast conventional audit trail models require extensive computation to determine the exact state of an entity at a particular time. For example in conventional systems this computation is necessary to reconstruct a record by starting from a given version and then applying changes made from that point onwards.

Prior to performing the undo or redo operation certain conditions can be evaluated not shown to determine whether it is possible to undo or redo anything. For example if an undo operation is requested a determination can be made as to whether any modifications have been made to the specified record in the current session. If no modifications have been made information indicating that there is nothing to undo can be returned to the user. Similarly if no undo operations have been performed in the current session and the user requests a redo operation information indicating that there is nothing to redo can be returned to the user.

At the audit table is searched for an audit row or rows in the record that was most recently activated e.g. audit row s storing the most recent activation date . These audit row s identify the most recently activated version row s which are the version row s that store the version s that the user wants to remove via the undo or redo command. It is noted that multiple recently activated versions may exist each of which may have a different effectiveness period.

The audit table is also searched for the audit row s in the record that were most recently deactivated e.g. the audit row s storing the most recent deactivation date . These audit row s identify the most recently deactivated version row s which store the version that the user wants to reactivate via the undo or redo command.

At a new audit row s is are allocated. The new audit row s includes the same effectiveness information as the most recently deactivated audit row s . The deactivation date in the new audit row s is set to a value e.g. end of time that indicates that the associated version is active. This reactivates the most recently deactivated version row s thus undoing a previous command or redoing a previously undone command . The activation date of the new audit row s indicates the time at which the undo or redo operation was requested.

At the process is completed by modifying the most recently activated audit row s to indicate that the associated version row s have been deactivated e.g. by setting the deactivation date of the most recently activated audit row s to identify the time at which the undo or redo operation was requested .

It is noted that if multiple undo and or redo operations of the same type i.e. multiple undo operations or multiple redo operations are performed in succession with no intervening non undo and non redo user initiated modifications the number of and results of previous undo and or redo operations can be tracked in memory in order to support multiple levels of undo and redo. For example if a user requests two undo operations in succession the user presumably wants to undo two successive modifications not to undo the effects of the previously requested undo operation. Accordingly when the second undo operation is received the method of can be repeated except in operation instead of identifying the most recently deactivated audit row s the second most recently deactivated audit row s are identified. The second most recently deactivated audit row s are the most recently deactivated audit row s prior to the time at which the audit row s identified as most recently deactivated in the prior iteration of the method was deactivated.

Undo and redo operations can thus be performed by simply manipulating the audit table. No changes are made to the version table when performing these operations. The effect of the undo command is to activate an older version of the reference record and deactivate a newer version such that the older version becomes the current version and the newer version is no longer the current version. If a redo command is subsequently received the effect of the redo command is to activate the newer version again such that the newer version is again the current version and the older version is again deactivated.

The method begins at when user input requesting a soft delete is received. The user input can include information e.g. the primary key of the reference record s identity row identifying the reference record to be deleted and a delete command.

At all audit rows that are still in effect referred to as unexpired audit rows are identified. Identifying the unexpired audit rows can involve searching the audit table for audit rows in the reference record that have ending effectiveness date values that identify a future date. In some embodiments only audit rows that are both still in effect and currently active e.g. due to having deactivation dates in the future are identified.

In some embodiments additional checks may be made before proceeding. For example if the audit rows indicate that there is a future version e.g. because one or more versions have beginning effectiveness dates in the future or gap in time between current versions and future versions the user can be provided with a warning indicating that there are future versions that have not yet gone into effect that will be deleted. The user can be prompted to confirm or cancel the soft delete operation.

At each of the identified audit rows is modified to indicate that the row is now inactive e.g. by changing the deactivation date in each row to indicate the time at which the delete was requested . One or more new audit rows are also inserted e.g. as described above with respect to where the number of audit rows to insert depends upon when the new audit row will have the same beginning effective date as the modified audit row to indicate that the identified version row s are now ineffective as of the deletion date. This effectively renders all of the respective version rows for the record ineffective. As a result if a user tries to retrieve the current version of the record no current version will be found since no version is currently effective any more. At the same time because no version information is modified or deleted it is possible to recover the record if the user later decides to undelete the record.

In order to better facilitate undeletions a deleted records table can be maintained. This deleted records table can identify records for which soft delete operations have been performed. At a row in the deleted records table is allocated and information identifying the record for which the soft delete operations and were performed is stored in the newly allocated row. The information identifying the record can include the primary key of the record s row in the identity table and the activation date of the deletion. The deleted records table provides a list of soft deleted records allowing for example a recycle bin feature to be implemented. It is noted that operation is optional and may not be performed in embodiments that do not maintain a deleted records table.

At the audit table is searched for the audit row associated with the version to be recovered. For example if the user input specifies a prior time the audit table can be searched for an audit row that was both active and effective at that prior time. This audit row identifies the version row that stores the version to be recovered.

At a new audit row which references the version row identified by the audit row found at is allocated. The new audit row indicates that the version row identified by the audit row found at is active and effective. For example the new audit row can have a deactivation date and an ending effectiveness date equal to the end of time.

At the audit table is searched for all audit rows associated with subsequent versions relative to the version stored in the version row identified by the audit row found at of the reference record. For example if the user input specified a prior time the audit table can be searched for all audit rows that were activated subsequent to that prior time. In some embodiments only audit rows that are still active are identified. The current version can be included in the subsequent versions if the current version was activated subsequent to the version being recovered.

The audit row s identified at are then modified to indicate that their associated version row s are no longer active as indicated at . This operation can be performed by modifying the deactivation date for each of the audit row s identified at to indicate the time at which the data recovery was requested.

The data recovery technique illustrated in can be used to restore a version that was created in a session other than the current session. Thus the user input at can be received in the current user session and can specify a version that was created in a previous user session.

The data recovery method of can also be applied to multiple records at the same time. In such a situation instead of searching for only audit rows that correspond to a particular record all audit rows which can correspond to multiple different records are searched and audit rows for different records can be identified as candidates for recovery. Thus instead of specifying a particular record the user input at can specify other information e.g. such as a batch identifier which could be stored as audit information in all audit rows created in response to execution of the batch process identified by that batch identifier can be provided as part of the user input requesting the data recovery as well as a prior time to which the records should be recovered. This information can then be used to search for appropriate audit rows to reactivate and deactivate.

In some embodiments in which the user specifies the archival period the method can also involve verifying that the period is allowable for archive by comparing the period s beginning and or ending dates against a centralized calendar. For example the centralized calendar can specify allowable beginning and or ending dates as well as acceptable lengths of archival periods. If the period is not allowable for archive the user can be prompted to resubmit an acceptable archival period.

The database that implements the data pattern can be stored on what is referred to as working media. This working media is the storage media e.g. a disk array that is accessed each time a user requests to manipulate or otherwise access the information in the data pattern. In order to reduce the storage and or performance requirements of the working media as well as the performance requirements of the database itself portions of records can be archived. Archival involves copying data from the working media to an archival media e.g. a tape drive backup storage array or the like and then removing that data from the database and deleting all or some of the archived data from the working media.

In response to user input a substantial portion of one or more records is archived. In particular all of the record except for the record s identity row can be archived and if desired purged from the working copy of the database. By maintaining the identity rows any existing transactional data that references the record will still have a functional reference using the primary key associated with the appropriate identity row to the record. Based on this reference to the identity row the associated version and audit rows can be retrieved from the archive if needed.

In some embodiments all existing effectiveness and version rows are archived in response to receipt of user input requesting archival. In other embodiments only selected rows of the effectiveness and version tables are archived based upon the period specified in the user input. illustrates the latter embodiments. In the former embodiments all audit and version rows associated with the specified records regardless of period can be copied from the working media to the archival media.

At the audit rows associated with the period specified for archival are identified. In one embodiment this involves searching the audit table for audit rows having an ending effectiveness date that is prior to or the same as the period s end date. In another embodiment this involves searching the audit table for rows having a deactivation date that is prior to or the same as the period s close date eg. the physical timestamp that that the period was fiscally closed . In still other embodiments this operation involves identifying audit rows having either an ending effectiveness date that is prior to or the same as the period s end date and a deactivation date that is prior to or the same as the period s close date. Other search criteria can be used in other embodiments.

At the version rows associated with the identified audit rows are identified e.g. based upon the foreign keys included in the identified audit rows. Then at the identified audit and version rows are copied from the working media to the archival media. At the archived audit and version rows are purged by removing those rows from the working media.

Once portions of records have been archived a user can request to restore purged portions of records e.g. in order to create an audit trail for example . If user input requesting restoration of the purged rows is received as detected at the audit and version rows that were archived at are copied from the archival media to the working media and restored as part of the database as shown at .

In some embodiments a significant number of rows can be archived and or purged as part of a single archival operation. Similarly a large number of rows can be restored as part of a single restoration operation. Accordingly in some embodiments the archival purging and or restoration operations can be parallelized such that more than one row is being archived purged and or restored at the same time. For example if 40 000 rows are identified as candidates for archival e.g. at and different subsets of the identified rows can be assigned to parallel processes e.g. the first process can operate on the first 10 000 rows the next process can operate on the second 10 000 rows and so on .

In one embodiment multiple archive sets can be created over time. Each archive set is an archive of a particular set of records as created in response to one or more archive requests. Archive sets are identified according to the particular time at which those records were archived. When archive sets are used restoration is performed in the reverse order in which the archive sets were created. In other words a later created archive set must be restored prior to the restoration of an earlier created archive set. Thus if Archive Set A is created on May 6 2008 at 9 01 pm Archive Set B is created on May 6 2008 at 9 23 pm and Archive Set C is created on May 7 2008 at 10 01 pm then during restoration Archive Set C should be restored before Archive Set B can be restored. Similarly Archive Set B should be restored before Archive Set A can be restored. If archive sets are restored out of order there is a possibility that some audit and or effectiveness information e.g. used to generate an audit trail may be missing and that certain functions that depend on that information may not operate correctly.

In alternative embodiments instead of archiving records to archival media a similar process can be used to translate records to a star schema. Thus instead of writing information to archival media as shown at the information can be translated for storage in a star schema and then written to another media e.g. analytics media data mart media data warehouse media and the like . It is noted that in embodiments that are doing translations instead of archival operations and can be omitted in some situations operation may be performed after translation however many other situations will involve maintaining the existing information subsequent to translation .

A star schema includes central facts tables and ancillary dimension tables. The fact tables can store key information e.g. transactional information while the dimension tables store information related to that key information e.g. such as reference information . For example a fact table can store purchase orders while the dimension tables store information describing the entities specified in the purchase orders e.g. such as the product ordered the vendor the salesperson the purchaser and the like . A different dimension table can be defined for each type of entity specified in the purchase order.

The information in the three tables of the data pattern can be exported to a single star schema table by extracting relevant information from the data pattern transforming the extracted information and then loading the transformed information in the star schema table. The information to extract can be identified based upon audit and or effectiveness information e.g. a user can specify a period used to query the audit and or effectiveness information . The extracted information can include information identifying different versions of a particular column as well as when those versions were effective. The extracted information can also be enriched by including other information e.g. obtained from a centralized calendar associated with the record from which the information is being extracted.

Users may occasionally want to make local copies of records and then resynchronize those copies with the original copy of the record at a later point. For example a salesperson may want to create a local copy of a database on her laptop for use while traveling. Upon return the salesperson can resynchronize the local copy of the record with that stored in the database. Whenever a new copy of a record is created the OCA in the new copy has a value equal to the current at the time the copy is created value of the OCA in the original copy. Additionally this value is preserved in an additional attribute field within the copy. The additional attribute is referred to as a synchronization sync value. Accordingly while the OCA in the copy can be modified as the user performs various operations on the local copy the synchronization value will stay the same.

The method of begins at when user input requesting synchronization of a record with a copy of the record is received. The user input can include information identifying the record as well as information identifying the synchronization value contained in the copy of the record.

If the original record s OCA has the same value as the synchronization value contained in the copy of the record it indicates that the original copy of the record has not been modified since the copy was made. Accordingly there is no conflict between the two copies and any new information in the copy of the record can be copied to the original copy as indicated at and .

If instead the record s OCA has a different value than the synchronization value contained in the copy of the record it indicates that the original copy of the record has been modified since the copy was made. Accordingly there is a conflict between the two copies. To preserve the conflicting versions of the record a new record can be allocated in the same set of tables as the original copy. This new record has a new identity row and thus a new primary key and includes the audit and version rows in the copy that differ from the original copy of the reference record. In order to preserve any business rules defined by the original record s natural key e.g. natural key of the natural key in the new record may include an additional identifier e.g. the new identity row can include a standalone conflict identifier and or reference to the identity row of the original record to aid in conflict resolution.

In some embodiments various conflict resolution techniques can then be applied to the conflicting versions in order to select one version as a survivor and the other version as a deceased party. Either the copy now represented by the new record or the original copy can be selected as the survivor. In such situations a set of separate survivorship tables can be maintained in order to track the outcome of the conflict resolution and to be able to undo the effects of the conflict resolution and or create audit trails based upon information that existed prior to the conflict resolution. The survivorship tables can include a survivorship table which corresponds to an identity table but for survivorship records instead of normal records a survivorship version table that stores version information for each survivorship record and a survivorship audit table that stores effectiveness and audit information for each survivorship version row. Each survivorship record corresponds to the outcome of a conflict resolution involving a particular record.

Each row in the survivorship table can include a reference to the deceased party i.e. the reference can be a foreign key having a value equal to the primary key associated with the identity row for either the original copy or the copy depending upon which was selected as the deceased party during conflict resolution . Each row in the survivorship version table can include a similar reference to a surviving party and a corresponding row in the survivorship audit table can indicate the periods during which that version row is effective and active. Thus if a user attempts to access the deceased party e.g. because transactional data references that copy the survivorship tables can be used to find the current version of that party s information which is stored in a surviving party s reference record.

Many of the operations shown in can be performed in a different order than is illustrated e.g. operation of can be performed before operation of . Furthermore alternative embodiments can be implemented that include other operations instead of and or in addition to those illustrated in . Some alternative embodiments may also omit certain operations.

Computing device can be a personal computer network appliance server personal digital assistant mobile phone storage controller e.g. an array controller tape drive controller or hard drive controller laptop computer or the like. In general computing device is configured to execute software or otherwise provide appropriate functionality to act as a component of the data management system described herein.

As illustrated computing device includes one or more processors e.g. microprocessors Programmable Logic Devices PLDs or Application Specific Integrated Circuits ASICs configured to execute program instructions stored in memory . Memory can include various types of RAM Random Access Memory Read Only Memory ROM Flash memory Micro Electro Mechanical Systems MEMS memory magnetic core memory and the like. Memory can include both volatile and non volatile memory. Computing device also includes one or more interfaces . Processor interface and memory are coupled to send and receive data and control signals by a bus or other interconnect.

Interface can include a network interface to various networks and or interfaces to various peripheral buses. For example interface can include a network interface via which user input requesting various manipulations of information stored in a data pattern is received. Interface can also include an interface to one or more storage devices e.g. such as a storage device storing the identity table version table and audit table .

In this example program instructions and data executable to implement all or part of data pattern module are stored in memory . The program instructions and data implementing data pattern module can be stored on various computer readable storage media such as memory . In some embodiments such software is stored on a computer readable storage medium such as a Compact Disc CD Digital Versatile Disc DVD hard disk optical disk tape device floppy disk and the like . In order to be executed by processor the instructions and data can be loaded into memory from the other computer readable storage medium. The instructions and or data can also be transferred to computing device for storage in memory via a network such as the Internet or upon a carrier medium.

Although the present invention has been described in connection with several embodiments the invention is not intended to be limited to the specific forms set forth herein. On the contrary it is intended to cover such alternatives modifications and equivalents as can be reasonably included within the scope of the invention as defined by the appended claims.

