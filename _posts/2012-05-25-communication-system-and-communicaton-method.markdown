---

title: Communication system and communicaton method
abstract: A communication system includes a first interface module which can be coupled to a first logic unit and a second interface module which can be coupled to a second logic unit. The first and second interface modules are interconnected by a virtual channel over a routing network. The first interface module is configured to receive messages from the first interface module and to send the received messages over the virtual channel to the second interface module. The second interface module is configured to transmit the received messages to the second logic unit. The second interface module is further configured to receive a processing complete signal from the second logic unit when the received messages have been processed in the second logic unit and is further configured to send an acknowledgement signal to the first interface module after reception of the processing complete signal. Further a communication method is provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09081743&OS=09081743&RS=09081743
owner: PRO DESIGN Electronic GmbH
number: 09081743
owner_city: Bruckmuehl
owner_country: DE
publication_date: 20120525
---
The invention is in the field of communication. The invention is more particular in the field of communication between logic units and may be used in a test system for logic units.

In the context of the present invention a logic unit designates a digital functional block which may receive data and or send data. The data may include instructions. Logic units may be dedicated to a specific data processing operation or programmable to perform a class of data processing operations. Generally logic units are characterized to generate data only send to consume data only receive or to transform data send and receive . Examples for data processing operations are multimedia signal processing communication protocol processing and system maintenance and monitoring operations.

Logic units can be realized as software applications running on a computer. Logic units realized as software applications are described in a programming language for example in C or C . Logic units can also be realized inside a Field Programmable Gate Array FPGA . Logic units realized in an FPGA are described in a Hardware Description Language HDL for example in the languages VHDL or Verilog and will be called HDL design entities or HDL entities in the present specification. Logic units may also be realized in integrated circuits. Logic units realized or to be realized in integrated circuits may be simulated by logic units realized in an FPGA. An FPGA may comprise a plurality of logic units.

An FPGA system comprises multiple Field Programmable Gate Arrays and an infrastructure that allows users to utilize the FPGAs. In an FPGA system a logic unit may also be distributed on several FPGAs. The FPGAs are configured by transmitting the HDL description onto the FPGAs. The structure of the circuitry inside the FPGA is thus defined and a dedicated logic circuit comprising a logic unit or logic units is configured. An FPGA system may be used either as Rapid Prototyping Platform or as a so called supercomputer.

For Rapid Prototyping a digital system developer writes a HDL description of an intended digital processing system to be manufactured as an integrated circuit for example a Si chip Si silicon . An FPGA system may be used to map or emulate the behavior of the chip i.e. the HDL description is loaded onto the FPGA system. Additionally if the digital processing system contains programmable logic the FPGA system allows software engineers to start working before the actual chip is available. They may program on the FPGA system. This allows the digital system developer to debug the HDL using full size applications where all elements of the final Si chip and the required application software running on programmable data processing unit inside the Si chip are running.

The HDL design may be processed by Electronic Design Automation EDA tools. Although different EDA tools are needed to generate chip production files and FPGA configuration files the HDL description is the same except for some technology specific parts . Errors in the HDL description can therefore be already detected in the FPGA system i.e. prior to tape out of the silicon production files thus reducing both cost and development time.

For supercomputing the HDL description utilizes the highly parallel and regular nature of the FPGA architecture for the acceleration of equally parallel and regular computations.

One of the key features provided by any FPGA system s infrastructure is a communication access. Communication is required for example for transferring the FPGA configuration bit stream from a remote location for debugging the HDL design inside the FPGAs and for collaboration between software running on a remote machine and HDL designs running inside the FPGAs. Modern FPGA systems may be connected to a Host PC through a device access unit DAU .

Communication is further needed for data transfer between logic units. Difficulties for the communication may arise from the different kinds of logic units realized as software applications and or as HDL entities. Communication may further be hindered by different processing speed of different logic units and by a different size of data units required by different logic units.

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements.

In operation there may be a communication between different FPGAs and between computer and different FPGAs . More specifically there may be a communication between different logic units comprised in the computer and or in the FPGAs . The communication passes over the routing network . Each FPGA may comprise several logic units which are HDL design entities. Communication occurs between different logic units i.e. communication may also occur inside an FPGA. Computer may comprise software programs which comprise several logic units which are software applications i.e. communication may also occur inside the computer . There are communications between logic units of the same kind for example between HDL design entities or between software applications but also between logic units of different kind i.e. between a HDL design entity and a software application. Especially in a test environment the logic units which must communicate with each other may change.

In the embodiment shown the FPGAs comprise three HDL entities which are logic units in the understanding of the present application. It is to be understood that more or less HDL entities are possible. Limits of the HDL entities must not necessarily correspond to limits of FPGAs i.e. a HDL entity may extend over more than one FPGA or an FPGA may comprise several HDL entities. The FPGAs in box further comprise one or multiple HDL entities for service and configuration. A configuration operation loads a set of user designs embodied as configuration bit streams into the FPGAs of the FPGA system. Notice that the FPGA system may include a special preconfigured FPGA which is capable of configuring all remaining FPGAs. Examples for service operations are setup of clock frequencies or enable or disable reset signals.

Each logic unit including the root unit and service and configuration unit is provided with an interface module which is also called queue access control unit QAC i.e. an interface module is coupled to each logic unit. The interface modules provided for the software applications are realized as software modules. The interface modules provided for the HDL entities are realized as HDL entities. Every logic unit is connected to the network via an interface module . An interface module is configured to exchange data with another interface module via network as indicated by arrows . For the logic units connected to the software applications only one arrow is shown because the communication additionally passes by the digital access unit. An interface module is further configured to communicate with the logic unit or to which the interface module is coupled as indicated in by arrows .

Although shows one interface module for one logic unit and it is to be understood that more than one interface module may be coupled to each logic unit. As is explained below in more detail one interface module may communicate only with one other interface module at a time thus if the logic unit has to communicate with several other logic units more interface modules are coupled to the logic unit.

In the embodiment explained each interface module is provided with a memory and a counter. Each interface module is provided with an own fixed identification number. The identification number may be stored in the memory of the interface modules i. e. changeable or the own identification number may be programmed as a constant.

When running or using the FPGA system in a first phase FPGA configuration files are loaded into each of the FPGAs for programming the FPGAs. Furthermore resources of the FPGA system are configured including for example global clocking and resets. Once the FPGAs are programmed during the first phase a second phase may be started. The second phase is a so called system configuration phase. In the configuration phase virtual communication channels in the present specification also called virtual channels are established and logic units may be preloaded with data if necessary. Furthermore all network elements are configured and on the computer connections to external applications may be established. The configuration phase is controlled by the root unit based on the configuration file .

A virtual communication channel between a first and a second interface module is established by loading during the configuration phase into the first interface module in addition to its own identification number a second identification number which is the identification number of the second interface module. In the same way second interface module may receive during the configuration phase the identification number of the first interface module. An established virtual channel is fully duplex i.e. data transfer in both directions is possible. The first and second interface modules are interconnected by the virtual channel over the routing network .

An example of a virtual channel is shown in . A logic unit may be a message generating unit i.e. a logic unit which generates and sends messages. Logic unit is coupled to first interface module . Interface module comprises a memory and a counter . The first interface module is connected via the virtual channel established during the configuration phase over routing network to the second interface module . In other words during configuration phase the identification number of interface module was loaded into memory . The second interface module is coupled to a logic unit . Logic unit may be a message processing unit which receives messages and processes the received messages. During the configuration phase the root unit may also have sent to interface module information concerning a maximum size of a data unit accepted by logic unit . This information is also stored in memory . During the configuration phase the root unit may also have sent to interface module a maximum count of unacknowledged data units accepted by logic unit . The counter may be preloaded to the maximum count and count down with every data unit sent and count up with every data unit acknowledged. In another embodiment counter may count every sent data unit count down with every acknowledged data unit and compare the actual count to the maximum count. Counter acts as an evaluation unit evaluating how many unacknowledged data units have been sent. As already explained interface module may receive in the configuration phase the corresponding information for interface module and logic unit . Of course a virtual channel may also be established between two logic units i.e. to software applications or between two logic units i.e. two HDL entities. It is to be understood that for example interface module is aware of the capacities of logic unit after the configuration phase while logic unit is not.

In operation i.e. in a third phase which may also be called the execution phase message generating unit generates data which is to be transmitted to message receiving unit . The first interface module receives the data from the message generating unit and sends the data in form of messages via the established virtual channel to the second interface module . In other words the first interface module is configured to receive messages from the message generating unit and to send the received messages over the virtual channel to the second interface module with the help of a configuration message sent by a central configuration instance. A message comprises a header and a payload. The header comprises in the preferred embodiment 2 byte reserved for the identification number ID of the receiver i.e. of the second interface module and 2 byte reserved for the sender ID i. e. the ID of interface module . The header further comprises 2 byte reserved for a message type identification and 2 byte for indicating the payload size. Interface module sends the data from logic unit over the virtual channel to the second interface module

An example of the headers for a data transfer is given in . Interface module may have received information about a maximum size of a data unit of 3 MB for logic unit along with an information about the maximum number of allowable unacknowledged data units. The data unit generated by logic unit and to be sent by interface module may have a size of 2 MB. Interface module checks whether the size is within the limit received during the configuration phase. If the size is within the limit interface module may send the data in messages comprising for example a payload of 32 kB each. A header of the first message comprises a receiver ID of 802 designating interface module a sender ID of 407 designating interface module a payload size of 32 k and a message type ID 0. The message type ID 0 designates a sub message i.e. a part of a message. A header of a second message is identical as will be the header of following messages to . A header of a 64message has a message type ID of 74. As this is a non zero message type it indicates that this is the last sub message and the data unit is completed. Interface module may then set counter to 1 for one data unit sent or count down from the maximum count of unacknowledged data units stored in the configuration phase. Message type may stand for a certain message type it does not indicate end of message.

The first interface module may comprise a memory for storing an information about a maximum number of messages allowed to be send to the second interface module prior to receive an acknowledgement signal or acknowledgement message. In an embodiment the number of messages is calculated by the size of data units accepted by the receiving unit. The first interface module may comprise an evaluation unit for evaluating how many messages have been transmitted since the last acknowledgement signal. In an embodiment the number of data units may be evaluated instead. Furthermore the first interface module is configured to refuse data from the message generating unit when the maximum number has been reached.

Message type IDs may also trigger a change in the behavior of an interface module for example a change to a slave mode to receive messages from the root unit . Depending on the message type the connected software application or the HDL entity may be enabled to send or receive data. This allows interface modules where the HDL entity or software application is not aware if the interface module is involved in a regular peer communication or a master slave communication. The communication is decoupled from the logic units.

The second interface module is configured to receive the messages over the virtual channel and to transmit the received messages to the message processing unit . In other words the second interface module is configured to receive the messages over the virtual channel and to transmit the received messages to the message processing unit with the help of a configuration message sent by a central configuration instance. The message processing unit may assemble the incoming payload to a data unit before starting processing. Depending on the message processing unit unit may also start processing at once. Message processing unit generates a processing complete signal when the received data unit has been processed and transmits the processing complete signal to the second interface module . The second interface module then sends an acknowledgement message to the first interface module . A header for an acknowledgement message is shown in . The header of the acknowledgement signal comprises a receiver ID 407 which designates the interface module which has sent the data a sender ID of 802 designating interface module a payload size of 0 because the acknowledgement message does not contain any data and a message type ID 1 which indicates acknowledged . First interface module then counts down 1 or re augments the maximum count of unacknowledged data units if it was count down before.

In other words a queue access control is realized in which a so called two sided handshake method is established between two interface modules the sending interface module signaling with the message type ID when a whole data unit has been transferred and the receiving interface acknowledging only when the associated logic unit has signalized that the data unit has been processed. As the sending interface module is aware of the capacity of the logic unit to which the receiving interface module is coupled no data is sent when there is no receiving capacity. There is no need of any inquiry from the sending interface about the current capacity of the receiver. This would add latency to the communication path. The feature of acknowledging data only after processing saves the need of copying messages inside the memory or discarding incoming messages. No valuable memory area and memory bandwidth is wasted. No complex protocols are required and no communication bandwidth is wasted.

Furthermore the logic units and are not aware of the communication process and need not to be adapted to the respective communication partner. The whole communication is effectuated by the interface modules which are configurable during the configuration phase by the root unit .

Further to the above described configuration of interface modules as so called regular peers the inventive method also allows for configuration of so called slave peers. During the configuration phase the slave interface module does not receive an ID of an interface module to which a virtual channel is established. When receiving a message from another interface module the slave interface module will get the sender ID included in the header of the received message and store this ID as receiver ID. The slave interface module can now answer to the sender interface module. This kind of configuration is valid for a certain sequence of messages for example a query command message followed by a query reply. Slave peers are commonly used for remote configuration remote debugging and remote profiling. Again it is not necessary to fix the kind of peer in the logic unit. It is configurable in the interface module in every configuration phase. As it is possible to couple more than one interface module to a logic unit even both configurations are possible at the same time in different virtual channels.

In an embodiment it is also possible to change the virtual channel after a predefined number of messages or data units has been received or sent. Therefore the interface module comprises a counter and a further memory to store a predefined further ID for establishing a virtual channel.

A possible implementation of an interface module which may be coupled to a software application is a software API Application Programming Interface . The API provides the functions send . . . and recv . . . to the application. If the application requests a message operation that cannot be served for example because the send operation is blocked or nothing has been received yet the function automatically waits until the operation is possible. After the function returned the software application can be sure that the requested operation has been performed.

A possible implementation of an interface module which may be coupled to a HDL is a FIFO style module First In First Out which provides a two sided handshake for individual data words. Another possible implementation of an interface module which may be coupled to a HDL is a DMAC style HDL entity Direct Memory Access Controller which is further explained with reference to . An interface module is coupled via a DMA bus master and a register bus slave to an embedded system bus . A logic unit is also coupled to embedded system bus . The logic unit may be a message generating unit or a message processing unit. Both units are explained with reference to . A system memory is coupled to the embedded system bus . In other words interface module logic unit and system memory are interconnected by embedded system bus .

For sending a data unit using interface module the message generating unit generates data and writes it into a continuous address space inside the system memory . Then the unit checks whether the interface module is capable of sending a message by reading register slave . Through the register slave a system memory address size and message type ID are provided. The interface module then generates a direct memory access transfer for reading the message payload from system memory and sends it to the receiving peer.

For receiving a data unit when using the DMAC style interface module the logic unit which is now considered to be a receiving unit first checks whether the interface module has received another message by reading the register slave . The interface module generates direct memory access transfers to write a message payload to system memory . The receiving unit then retrieves system memory address size and message type ID through the register slave . The receiving unit processes the message payload from the system memory and indicates when the message has been processed also through the register slave . The interface module then generates an acknowledgement message to the sender.

In an embodiment the inventive communication method and system is used for rapid prototyping in an FPGA system. In another embodiment the inventive communication method and system is used for a supercomputer in an FPGA system. In both embodiments the FPGA system is configured for a single application and returns to idle mode after the application has finished. This results in a sequence of distinct system states.

The state of the system is controlled by the root unit which preferably runs on computer . Computer may be part of a system communication server. After being launched the Communication Server first establishes contact to the FPGA system through the device access unit through any appropriate medium.

As explained previously a system run starts with the FPGA programming phase in which the root unit transmits a sequence of messages containing the FPGA bit files. In the subsequent system configuration phase the root unit sets up a so called network topology by transmitting a sequence of messages resembling the routing information and peer connection information. In other words virtual channels are established. Furtheron connections to external applications are established.

During the following execution phase the root unit provides error handling and system monitoring. In this phase connections to external applications are active i.e. messages will be accepted from external applications and transmitted through the communication network . Any logic unit in the system may send a certain message type ID QUIT message to root unit . As soon as root unit receives the QUIT message the execution phase ends.

In the following evaluation phase root unit requests execution results from selected interface modules. After that root unit puts the FPGA system in a suspend mode.

In each system state root unit processes the corresponding section of the system configuration file . This makes the system configuration file a complete description of the system and the application running in it. Among others it contains the following descriptions 

Messages to initialize and read back the FPGA system states are a powerful tool in system debugging and profiling. For example consider a problem where the developed application tends to hang upon unknown conditions. A debug unit may be configured to detect a certain trigger event during the system configuration phase. During evaluation phase the debug unit is asked to return the number of occurrences of that event along with some recorded properties of the last occurrence to help pinning down the problem. The additional debug messages may simply be added to the respective sections of the system configuration file.

The debug approach becomes significantly more powerful when using multiple system configuration files . Consider an application where several data processing operations are connected to a data flow graph as represented in . Five logic units are realized as software applications and . They are interconnected by virtual communication channels and which are represented by arrows. The application may be a pure software reference implementation known to be functionally correct and running on computer .

To establish a communication system according to a first topology with a data flow as shown in software applications and are provided with two interface modules each whereas software application is provided with three interface modules and software application is provided with one interface module. The interface modules to are indicated in in the form of semicircles. They are placed at the junctions between software applications and and virtual channels and .

A first interface module coupled to software application may have the ID number and a second interface module coupled to the same software application may have the ID number . A third interface module which is coupled to software module may have the ID number and a fourth interface module coupled to software module may have the ID number . A fifth interface module coupled to software module may have the ID number and a sixth interface module coupled to software module may have the ID number . A seventh interface module coupled to software module may have the ID number and an eighth interface module coupled to the same software module may have the ID number . A ninth interface module coupled also to software module may have the ID number and a tenth interface module coupled to software module may have the ID number . As explained above interface modules to may be realized as a software API.

In the configuration phase controlled by a first configuration file the root unit sends configuration messages providing interface module with the ID number of interface module to establish virtual channel . Root unit further provides by configuration messages interface module with an information about the maximal size of a data unit accepted by software application and about the maximal count of unacknowledged data units for software application . In fact the latter is information about storage capacity of software application . Root unit may provide interface module with ID number of interface module if virtual channel is a bidirectional channel and interface modules and are regular peers.

In the configuration phase root unit further provides by configuration messages interface module with the ID number of interface module to establish virtual channel . Root unit provides in the same way interface module also with information about the maximal size of a data unit accepted by software application and about the maximal count of unacknowledged data units for software application . Root unit may provide interface module with ID number of interface module if virtual channel is a bidirectional channel and interface modules and are regular peers. It is to be understood that software applications and are unaware of the communication channels established. There is no need to change anything inside software applications and .

Still in the configuration phase root unit further provides interface module with the ID number of interface module to establish virtual channel . Root unit provides interface module also with information about the maximal size of a data unit accepted by software application and about the maximal count of unacknowledged data units for software application . Root unit may provide interface module with ID number of interface module if virtual channel is a bidirectional communication channel and interface modules and are regular peers. In the same way virtual channels and are established.

It follows the execution phase. Virtual channels to are used to transfer data between the logic units to . After the execution phase follows the evaluation phase and root unit requests execution results from selected interface modules. Then the FPGA system is in a suspend mode.

A second configuration file may now contain all information necessary to establish an application according to a second topography corresponding to a data flow graph as shown in . Software applications and running on computer remain unchanged with interface modules and coupled thereto. The second configuration file comprises the same information as the first configuration file to establish in the configuration phase virtual channels and .

However software application has been replaced by a HDL entity which is realized in one or more of the FPGAs comprised in the FPGA system . HDL entity is designed to have the same functionality as software application . HDL entity is provided with an interface module which may have the ID number an interface module which may have the ID number and an interface module which may have the ID number . As explained above interface modules and may be realized for example as FIFO style module or as DMAC style HDL entity.

In the configuration phase root unit provides interface module with the ID number of interface module to establish a virtual channel . Root unit provides interface module also with information about the maximal size of a data unit accepted by HDL entity and about the maximal count of unacknowledged data units allowable for HDL entity . Virtual channel in and virtual channel in are both marked with VC3 indicating that the same data communication will flow over these two virtual channels. Software application is unaware of the fact that software application has been exchanged against HDL entity .

Still in the configuration phase root unit provides interface module with the ID number of interface module to establish a virtual channel . Root unit provides interface module also with information about the maximal size of a data unit accepted by HDL entity and about the maximal count of unacknowledged data units allowable for HDL entity . Root unit further provides interface module with the ID number of interface module to establish a virtual channel to the interface module which is coupled to software application which remained unchanged. Root unit provides interface module also with information about the maximal size of a data unit accepted by software application and about the maximal count of unacknowledged data units allowable for software application . As mentioned before root unit may also provide for example interface module with the ID number of interface module and so on.

In the following execution phase virtual channels and are used to transfer data between the logic units and . After the execution phase follows another evaluation phase and root unit requests execution results from selected interface modules. The execution results from the first and the second execution phase can now be compared. Only part of the whole application i.e. software application was replaced. Any malfunction due to HDL implementation errors which occurred during the second execution phase can therefore be localized in HDL entity . Of course software application is still on computer but in the configuration phase no virtual channels were established to software application .

The approach of alternative system configuration files now allows a step by step approach of transforming a pure software implementation into a pure HDL design as intended for an ASIC silicon design. Each processing function is individually ported into a HDL design unit which is capable of processing the same input messages and producing the same output messages. Two system configuration files are used in two separate system runs one for the original virtual channel configurations one using the new HDL design unit. The users of the FPGA system now have a powerful method of isolating potential problems by exchanging parts of the HDL implementation with the original software implementation purely by using alternative system configuration files. Since the approach requires no re synthesis of the FPGA designs which typically take several hours it saves a large amount of time for error isolation. It should be understood that further system runs based on further configuration files with still other topologies comprising possibly further logic units may follow.

This message comparison is another powerful debug technology. As the message sequence into the reference implementation for example software is recorded and replayed into the unit under test for example FPGA the sequence of messages generated by the reference implementation and the unit under test can be compared. This allows exact isolation of the differences as well as simulation of isolated parts of the design in event based HDL simulators at acceptable speed.

Embodiments of the inventive communication methods are now summarized with reference to . In a step I in a virtual channel is established over a routing network between two interface modules wherein a first interface module is coupled to a message generating unit and a second interface module is coupled to a message processing unit. In a step II messages from the message generating unit are transmitted or handed over to the first interface module. Handed over and transmitted are used in the context of this specification for messages which are not sent over communication channels but rather transferred between an interface module and the unit it is coupled to. In a step III the messages which have been handed over are sent from the first interface module over the virtual channel to the second interface module. In a step IV the received messages are handed over from the second interface module to the message processing unit. In a step V at least part of the received messages are stored in the message processing unit. In a step VI the received messages are processed in the message processing unit. In a step VII a processing complete signal or processing terminated signal is transmitted from the message processing unit to the second interface module after the received messages have been processed. In a step VIII an acknowledgement signal is sent from the second interface module to the first interface module over the virtual channel after reception of the processing complete signal.

In an optional step XIV messages between the logic units are transmitted in a first execution phase over the virtual channels which have been established during the first configuration phase between their respective interface modules. In a further optional step XV messages from the logic units are transmitted in a first evaluation phase to the root unit. The messages comprise information about the first execution phase.

Although the communication system and the communication method have been described in detail through some exemplary embodiments these embodiments are not exhaustive various variations and modifications can be made therein by those skilled in the art without departing from the spirit and scope of the invention. Equivalents may be substituted for elements thereof and adaptations to a particular situation to the teachings of the invention can be done without departing from the essential scope thereof. Therefore the present invention is not limited to these embodiments the scope of which is only defined by the appended claims.

