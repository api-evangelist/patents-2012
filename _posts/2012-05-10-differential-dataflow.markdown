---

title: Differential dataflow
abstract: The techniques discussed herein efficiently perform data-parallel computations on collections of data by implementing a differential dataflow model that performs computations on differences in the collections of data. The techniques discussed herein describe defined operators for use in a data-parallel program that performs the computations on the determined differences between the collections of data by creating a lattice and indexing the differences in the collection of data according to the lattice.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09165035&OS=09165035&RS=09165035
owner: Microsoft Technology Licensing, LLC
number: 09165035
owner_city: Redmond
owner_country: US
publication_date: 20120510
---
Real world systems such as a social network system or a roadmap GPS system comprise collections of data. Dataflow graphs are used to model the processing being performed on the collections of data so that dataflow processing can be performed as the collections of data change over time. Declarative computer programming allows a computer programmer to define in a data parallel program a set of computations and input output dependencies between the computations. The set of computations and input output dependencies defined in a data parallel program are modeled by the dataflow graph. Accordingly a dataflow graph provides a representation of different functional paths that might be traversed through a data parallel program during execution such that collections of data pertaining to real world systems can be processed and updated as they change over time.

Conventionally the set of computations used in a data parallel program are batch oriented and loop free resulting in inefficient performance for data streaming and incremental computational updates to the collections of data for a particular model system e.g. a social network system or a roadmap GPS system . For instance batch processing retains no previous state of data and or computations and therefore batch oriented systems must reprocess entire collections of data even when the incremental changes that occur over time are minor or small. Meanwhile loop free data parallel programs cannot perform iterations e.g. loops or nested loops when processing an incremental update to a particular model system.

The techniques discussed herein efficiently perform data parallel computations on collections of data by implementing a differential dataflow model that performs computations on differences in the collections of data. The techniques discussed herein describe defined operators for use in a data parallel program that performs the computations on the determined differences in the collections of data by creating a lattice and indexing the differences in the collection of data according to the lattice.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The term techniques for instance may refer to system s method s computer readable instructions module s algorithms and or technique s as permitted by the context above and throughout the document.

The following description sets forth techniques for efficiently performing data parallel computations on collections of data by implementing a differential dataflow model that performs computations on differences between the collections of data instead of re performing the computations on the entire collections of data. The techniques discussed herein describe defined operators for use in a data parallel program that performs the computations on the determined differences between the collections of data by creating a lattice and indexing or arranging the determined differences according to the lattice.

Collections of data describe a totality of data pertaining to a real world system at a particular place in a data parallel program e.g. the state of the totality of data before or after one or more particular computations . In various embodiments collections of data pertaining to a real world system can be described as multiple independent sub collections of data. By focusing on differences between collections of data e.g. determining which ones of the independent sub collections of data that have changed the differential dataflow model can efficiently implement incremental updates nested fixed point iteration and prioritized execution of a dataflow graph by re using previous data and previous computations that remain a valid part of a maintained state for a model system rather than redundantly performing computations on the sub collections of data that have not changed from the previous maintained state. Accordingly when new data is added to a model system or data changes as a result of a computation in a data parallel program for example the amount of processing implemented by the differential dataflow model is proportional to a number of sub collections of data that represent the new data or the changed data from a previous computation.

The number of sub collections of data that represent the new data or the changed data is typically smaller than the total number of sub collections of data in the collections of data that comprise the totality of data in a real world system. Thus the differential dataflow model discussed herein avoids computational redundancy for data parallel programs and makes the data parallel programs more efficient.

While some conventional approaches to data parallel computations consider and process changes to data such changes occur in a one dimensional single order of time. Changes in a one dimensional single order of time are referred to as totally ordered changes based on a linear perception of time where a first change to a collection of data is known to definitely come before or after another change to the collection of data e.g. in a linear fashion . However conventional data parallel programs cannot efficiently and accurately perform data parallel computations on a partially ordered set of changes. In a partially ordered set of changes a first change to a sub collection of data may not be directly comparable to a second change to the sub collection of data e.g. in a time wise linear fashion . For instance a change to a sub collection of data may be in a second dimension independent of or in addition to an initial dimension of linear time. Thus conventional data parallel programs must impose a total order on the changes which loses useful information about the structure of the changes and restricts these programs to using a less efficient execution strategy.

The techniques described herein are implemented to consider and efficiently process a partially ordered set of changes where changes to data occur in multiple independent dimensions e.g. loop indices or input versions . Using the partially ordered set of changes different patterns and combinations of computations or sub computations in a dataflow graph can be accounted for and realized in accordance with partially ordered logical time. Accordingly the differential dataflow model creates as an input to one or more computations in a data parallel program a lattice varying collection where a set of differences to collections of data e.g. the sub collections that have changed are indexed and arranged according to a lattice type. The lattice varying collection comprises different lattice elements which are indexed and used to organize the set of differences to the collections of data. The differential dataflow model can then process the different lattice elements to perform nested fixed point iterations incremental updates and prioritized computations among other operations. Moreover the operators and dataflow graphs described herein are capable of responding to updates to the lattice varying collections so that further appropriate updates are realized and processed within the data parallel program until no further updates remain and the data parallel program and its computations quiesce.

Compared to conventional approaches the differential dataflow model discussed herein enables programmers to write a data parallel program with nested loops that respond quickly to incremental changes to the partially ordered set of changes arranged in the lattice varying collection.

As depicted in when processing the separate input records dX A B C D E F G and H corresponding to the respective differences to the sub collections of data in X the differential dataflow model creates a lattice varying collection and organizes or indexes the separate input records in the lattice varying collection where each input record is a lattice element. The term lattice represents an organizational pattern type by which a set of partially ordered differences are arranged so that they can be processed by one or more operators in different combinations and or orders. Thus for a particular set of input records dX the differential dataflow model creates a specific lattice varying collection that is the actual data indexed in accordance with the lattice type. For example in various embodiments the lattice type for is a two dimensional grid with 3 3 elements shown. Moreover the lattice elements may be indexed as tuples of integers as follows difference record A is indexed as lattice element 0 0 in the lattice varying collection difference record B is indexed as lattice element 0 1 in the lattice varying collection difference record C is indexed as lattice element 0 2 in the lattice varying collection difference record D is indexed as lattice element 1 in the lattice varying collection and so forth.

Because the separate input records in a lattice varying collection may be a partially ordered set of changes they may vary in multiple different dimensions that may not be directly comparable in linear time wise manner. For instance in various embodiment the lattice elements may be indexed according to tuples of integers in two dimensions three dimensions four dimensions and so forth. For example two different three dimensional lattice elements may be tuples of integers 1 5 3 and 2 1 9 . Here the individual corresponding coordinates of each tuple may be comparable e.g. 1 occurs before 2 5 occurs after 1 and 3 occurs before 9 . However when a data parallel program considers the entire lattice element for processing it is confused because some comparisons may indicate the element precedes another element in a time wise manner while other comparisons may indicate the element comes after the another element in a time wise manner as shown using the tuples 1 5 3 and 2 1 9 . Accordingly although individual coordinates between lattice elements may be comparable the entire lattice element may not be directly comparable for data parallel processing purposes.

As discussed above a two dimensional lattice type is depicted in . For example the elements in the top row of the lattice varying collection dX records A B and C may reflect separate iterations of a loop in a data parallel program and therefore may be comparable in a time wise manner where the first iteration e.g. the difference record represented by A is known to come before the second iteration e.g. the difference record represented by B which is known to come before the third iteration e.g. the difference record represented by C . However lattice element D may represent a change that modifies where the loop starts in the data parallel program thereby adding a second dimension to the lattice varying collection . Accordingly lattice element D may not be directly linearly time wise comparable to difference records A B and C in the top row of the input lattice and thus the differential dataflow model will have to process the three aforementioned iterations according to the modified loop starting point. For example such iterations with the modified loop starting point may be represented by the records D E and F in the second row of the input lattice.

One example way of denoting and indexing the lattice is to label the rows in the lattice as different versions e.g. 0 1 and 2 while the columns represent iterations e.g. 0 1 and 2 . Accordingly using the lattice varying collection the differential dataflow model can process a set of partially ordered changes so that the output dY appropriately reflects the different possible patterns and combinations of computations and or sub computations resulting from the input records dX.

While shows the input lattice with three rows and three columns in a two dimensional lattice type implementation it is understood in the context of this document that a lattice varying collection has no limit on the number of dimensions. Rather lattice varying collections are created and indexed to account for each possible difference to the collections of data so that the output is properly reflected. In various embodiments the input lattice may be referred to as a lattice version of time according to an unlimited number of dimensions time time time . . . .

Accordingly the differential dataflow model further discussed herein processes a partially ordered set of differences to collections of data that can vary in multiple different dimensions. This allows the differential dataflow model to efficiently stream data and improve the performance of iterative computations and prioritized computations when modeling real world systems and performing dataflow processing.

In various embodiments the architecture can be the World Wide Web including numerous PCs servers and other computing devices spread throughout the world. The computing devices . . . N and the one or more sources . . . N may be coupled to each other in various combinations through a wired and or wireless network including a LAN WAN or any other networking and or communication technology.

The computing devices . . . N comprise a memory and one or more processors . Furthermore in various embodiments the computing devices . . . N include the differential dataflow model which may include a collection input module a lattice indexing module a data parallel program with operators a dataflow graph and a collection output module . Furthermore the computing devices . . . N may include one or more network interface s and one or more compilers to compile the data parallel program .

The processor s may be a single processing unit or a number of units all of which could include multiple computing units. The processor s may be implemented as one or more microprocessors microcomputers microcontrollers digital signal processors central processing units state machines logic circuitries shared memory processors and or any devices that manipulate signals based on operational instructions. Among other capabilities the processor s may be configured to fetch and execute computer readable instructions stored in the memory .

The memory may comprise computer readable media including at least two types of computer readable media namely computer storage media and communications media.

Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store information for access by a computing or server device.

In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transmission mechanism. As defined herein computer storage media does not include communication media.

The network interface s enable network communication and may include one or more ports for connecting the respective computing device to the network . The network interface s can facilitate communications within a wide variety of networks and protocol types including wired networks e.g. LAN cable etc. and wireless networks e.g. WLAN cellular satellite etc. . For instance the network interface s may access over network s data stored at the one or more data sources . . . N . In various embodiments computing device s . . . N may have local access independent of a network connection to one or more data sources . . . N .

It is understood in the context of this document that the functionality performed by the differential dataflow model may be all inclusive on a single computing device or spread out amongst a plurality of computing device s . . . N connected to one another via network s . Moreover elements of the differential dataflow model may be located at one or more of the data sources . . . N .

In various embodiments the collection input module is configured to gather and or receive one or more collections of data that pertain to the real world system being modeled for dataflow processing. The collections of data gathered and received by the collection input module may pertain to the complete real world system or the collections of data may pertain to a subset of data of the complete real world system for which dataflow processing with respect to possible updates is to be performed. Examples of real world systems include but are not limited to social network systems GPS systems roadmap systems SPAM filter systems or any type of real world computing system where data is constantly updated added removed or modified and thus it would be beneficial to perform dataflow processing.

Once the one or more collections of data are received by the collection input module in various embodiments the differential dataflow model employs the lattice indexing module to determine and index the records of differences in the one or more collections of data according to a particular lattice type.

As previously discussed a declarative data parallel program defines computations over strongly typed collections of data. The one or more computations defined by a programmer in the declarative data parallel program may functionally map the differences in collections of data to integer counts. Accordingly the differential dataflow model can manipulate collections of data like functions e.g. collections of data may be added and subtracted e.g. according to their integer counts to determine differences in the collections of data thereby providing the difference records dX as discussed above with respect to .

A function that performs a computation on one or more input collections of data to output one or more new collections is performed by the defined operators . In various embodiments the operators express data parallelism through a key function K by which input records for a collection of data are grouped. For instance considering input collections of data A and B with records r let Aand Bbe respective restrictions on input records mapping to k under K as follows if 0 otherwise. Equ. 1 if 0 otherwise. Equ. 2 

The independence property in equation 3 allows the computations to be partitioned arbitrarily across threads processes and computers as long as elements mapping to the same key are grouped together. However some operations may be fully data parallel meaning that the operations on records are independent as follows 

Fully data parallel operations can be performed in situ and therefore fully data parallel operations do not require grouping or data exchange with other operations. Thus as previously discussed the conventional approaches to performing data parallel computations operate on collections of data and result in absolute values of the collections of data themselves which may then be used in further computation. However the computations in the conventional approaches are constrained to form a directed acyclic dataflow graph.

In contrast the differential dataflow model described herein uses the lattice indexing module to create the lattice varying collection indexing the difference records as elements in accordance with a lattice type from which the differential dataflow model can process a partially ordered set of changes to collections of data e.g. the sub collections of data that have changed that vary in multiple different dimensions.

In various embodiments the differential dataflow model processes the partially ordered set of changes using collection traces as functions from the lattice elements to collections of data. The functional dependence of operators between input and output collections extends to collection traces. For example for a defined operator the output collection trace must reflect at each t the operator applied to the input collections at t as follows . Equ. 5 

In various embodiments this relationship extends from operators to arbitrary sub computations and the dataflow graphs further discussed herein will satisfy this property.

With respect to differences between collections of data as discussed above with respect to the differential dataflow module implements an alternate representation for a collection trace called a difference trace which is a function from lattice elements to differences . A difference is a function from input records to integers where the value of the function on a record represents the necessary change to the frequency of the associated record. These integers may be negative indicating a decrement to the frequency of the record. Thus using differences the differential dataflow model defines a difference trace A from a collection trace A so that an output collection A t results from adding the differences A s for the lattice elements that satisfy s t where t is a given time up to which the difference records are accumulated as follows Equ. 6 

Each difference trace A induces a specific collection trace A but a difference trace A may also be defined coordinate wise from A and prior differences as follows 

Thus in various embodiments the lattice indexing module uses collection traces and or difference traces in accordance with equations 6 and 7 to determine what differences records dX to process as part of the lattice varying collection as depicted in . While a collection trace and its corresponding difference trace represent the same information mathematically the differential dataflow model uses the difference traces as further discussed herein to process changes to collections of data because the difference traces are more compact than collection traces and the difference traces explicitly indicate when and how a collection of data has changed. However in various embodiments the differential dataflow model may also use collection traces. Accordingly the differential dataflow model is able to restrict computations to data that has changed e.g. independent sub collections that have changed while not having to perform redundant computations on data associated with a previous maintained state that has not changed e.g. independent sub collections that have not changed .

Once the lattice indexing module determines the difference records dX that comprise the lattice varying collection the differential dataflow model compiles and executes the data parallel program defining the operators in accordance with an underlying dataflow graph e.g. a cyclic dataflow graph that propagates changes to the collections of data through vertices capable of determining output changes from input changes. Using the lattice varying collection the differential dataflow model does not require the dataflow graph to develop and or maintain explicit dependencies between input and output objects.

Generally the dataflow graph includes edges that correspond to difference traces and vertices that correspond to one of a source a sink or an operator that performs one or more computations or sub computations. A source has no incoming edges and a sink has no outgoing edges and thus they represent a computation s inputs and outputs respectively e.g. a computation performed by an operator .

The result of an operator s computation at a vertex is an assignment of differences traces to the edges so that for each operator vertex in the dataflow graph the difference trace on its output edge reflects the one or more operators applied to one or more difference traces on its input edges as shown in equation 5 .

In various embodiments the differential dataflow model executes the computations with respect to the dataflow graph based on an assignment of two difference traces to each edge. Initially all difference traces are empty. The first difference trace is processed by the recipient vertex and is reflected in the output from the computation at the recipient vertex. The second difference trace is unprocessed and calls for attention e.g. the computation will not be finished until the unprocessed difference trace has been emptied .

The differential dataflow model advances from one configuration to the next in the dataflow graph via one of two scenarios. In a first scenario a source adds a difference trace to an unprocessed trace on the source s output edge. In a second scenario an operator vertex subtracts a difference trace from its unprocessed region adds the difference trace to its processed region and then adds the difference trace to the unprocessed region of each output edge as appropriate to the logic of the operator. In each configuration the differential dataflow model requires that each output edge of an operator implementing a function has its two regions e.g. processed and unprocessed of an output trace sum to which is applied to the processed difference traces on the input edges. The computation quiesces when all unprocessed traces are empty and thus each operator s output difference traces are equal to the function applied to its input difference traces. Therefore the differential dataflow model does not need to perform more computation unless a source emits a new trace.

In various embodiments execution of the data parallel program according to the dataflow graph is atomic. In other embodiments execution may be in parallel as long as the resulting computation is indistinguishable from a legal serialized execution.

In various embodiments the differential dataflow model updates the difference traces as depicted in . depicts an exemplary operator that is part of the dataflow graph . For example with reference to the differential dataflow model may define A and B as processed input difference traces and Uand Uas unprocessed input differences traces while defining a and b as intended updates to the input difference traces such that the differential dataflow model outputs z such that . Equ. 8 

Following the data parallel definition of the differential dataflow model uses keys present in a or b as follows 

Thus the differential dataflow model sets zas the term corresponding to k in the sum and using the equivalence 

Accordingly zis a coordinate wise definition when implementing the differential dataflow model . For example if z t is non empty for few t then the differential dataflow only has to evaluate zat the lattice elements corresponding to t. Thus the differential dataflow may conservatively estimate non empty t from the least upper bounds of non empty t in A a B and b.

In various embodiments the differential dataflow model implements a library of declarative language operators which may be selectively used in the data parallel program s which are each configured for a particular system and or a particular dataflow task. However it is understood in the context of this document that the differential dataflow model and the data parallel program s may also define additional and other operators to perform computations on the input records dX depicted as the lattice elements in .

For example in at least one embodiment the operators are based on Language Integrated Query LINQ functionality in .NET languages. In LINQ collections of data for a system are represented by strongly typed collections of .NET objects and the example operators are functions transforming data input collections to data output collections. Accordingly while specific operators are further discussed herein it is understood in the context of this document that the LINQ functionality in .NET languages may also provide and or support additional operators to be used in conjunction with the techniques discussed herein.

The operators discussed herein are divided into four classes unary operators binary operators a fixed point operator and a prioritized operator.

The unary operators may include but are not limited to Select Where Groupby and Reducer . The Select operator produces an output collection that results from mapping a given function or computation across each element in an input collection as follows 

Here the type parameters S and T correspond to the record types in the input and the output respectively e.g. medical records strings integers web pages online presence status . For example S is a source data type and T is a target data type. The selector is a function from S to T e.g. an operator that changes the source data type records S to the target data type records T . The operator and the input collection and the output collection are also parameterized by L e.g. a placeholder for the lattice type. With respect to equations 6 and 7 L is the lattice type over which the variable t ranges. With respect to L would be the set of all pairs of tupled integers corresponding to the two dimensional arrangement depicted as previously discussed. In various embodiments the Select operator does not change the lattice elements associated with the input records dX so that the compiler can statically determine and report bugs arising from lattice misuse.

The Where operator produces an output collection containing records in the input collection satisfying a given predicate as follows 

Again the type parameter T corresponds to the target data types in the output collection and the Boolean value indicates whether the predicate is satisfied. The Where operator is also parameterized by the lattice type L as discussed above. In various embodiments the Where operator does not change the lattice elements associated with the input records dX.

The Groupby operator takes an input collection a key function and a reduction function from groups to output lists. The Groupby operator then collates the input by key applies the reduction function to each group and accumulates the result as follows 

The Groupby operator is also parameterized by the lattice type L as discussed above. In various embodiments the Groupby operator does not change the lattice elements associated with the input records dX.

In various embodiments the Reducer operator is a function from the key and a group of input records to an IEnumerable of output records and the Reducer operator is not parameterized by the lattice type L. Rather IEnumerable is a generic interface in .NET representing a collection of objects that can be enumerated by an iterator and IEnumerable allows a programmer the flexibility to express the reducer as a LINQ query.

In various embodiments the differential dataflow model uses a declarative language that defines data parallel versions of aggregation operators including a Count operator a Sum operator and a Min operator which are based on their LINQ counterparts with an additional key function.

The binary operators may include but are not limited to Join Concat Union Intersect and Except . For example the Join operator may be based on a relational equi join operator which logically computes a cartesian product of two input collections and outputs pairs of records which map to the same key as follows 

In various embodiments the differential dataflow model applies the Join operator to the function Selector to be used on each pair of records with matching keys. Both input collections have the same lattice type L ensuring that both collections vary with lattices for which the Join and Meet operators are well defined.

Moreover in various embodiments the differential dataflow model defines the Concat Union Intersect and Except operators as multi set operators that are functions of the frequency of each lattice element in either the input collections or the output collections. For example Concat produces an output collection where the frequencies of each lattice element in either the input collections or the output collections are added as follows 

Similarly the Union Intersect and Except binary operators have the same type and can be defined analogous to the Concat operator. Moreover similar to the unary operators the binary operators Join Concat Union Intersect and Except are also parameterized by the lattice type L as discussed above. In various embodiments these operators do not change the lattice elements associated with the input records dX so that the compiler can statically determine and report bugs arising from lattice misuse.

In various embodiments the Fixed Point operator is a declarative operator specifying a potentially unbounded iteration. Thus a programmer may define in a data parallel program an input collection and a function that will be repeatedly applied to the input collection until a fixed point is reached as follows 

In various embodiments the Fixed Point operator returns input . For example if the repeated application of to an input collection has a fixed point there will exist an iteration number n such that input input for all i n. If this does not hold true there may be no fixed point and the result of the Fixed Point operator may be undefined and the computation may diverge.

In various embodiments the Fixed point operator uses a lattice type M that is different than the original lattice type L. In various embodiments the lattice type M introduces a new integer to pair with an element from L where the new integer tracks the loop iterations. For example the differential dataflow model may infer the lattice type M via a C compiler and the lattice type M may be obtained by augmenting an element of the original lattice type L with an additional integer component that corresponds to the current iteration count. The differing lattice types have a consequence that if the body of Fixed Point operator refers to a Collection from an enclosing scope that lattice elements in that collection are extended to elements of M which the differential dataflow model can achieve using a unary Extend operator in LINQ. Accordingly the compiler can detect violations of this invariant with the use of strongly typed lattice elements.

In various embodiments the Prioritize operator uses a lattice based order e.g. priority queue to prioritize the lattice elements to be processed as follows 

Accordingly the Prioritize operator extends the lattice element associated with each record in the input and reverts to the original lattice in the output. In various embodiments the priority function defined by the Prioritize operator associates an integer with each input record dX and the Prioritize operator constructs a record in a new lattice varying collection P based on the integers. The effect of this prioritization is realized when an operator contains a Fixed Point operator . In this scenario the input records will be ordered first by priority and then injected into the body of the Fixed Point operator instead of their initially assigned time in the lattice L. When the differential dataflow model processes the high priority elements first there is less variation in the input collections and the difference traces will be more compact and require less computation.

As discussed above when executing a data parallel program the differential dataflow model transforms the operators defined in the data parallel program into a dataflow graph . In various embodiments the dataflow graph is a cyclic dataflow graph.

In various embodiments the unary operator dataflow graph receives a single input X performs one or more computations on X via one or more operators and outputs the results X . The binary operator dataflow graph receives two inputs X and Y performs one or more computations on X and Y via one or more operators g and outputs the results g X Y .

In various embodiments the Fixed Point operator may introduce a cycle that generates the Fixed Point dataflow graph . The Fixed Point dataflow graph contains an operator on the feedback path that advances the lattice element associated with each record so cyclic iterations can be performed. The differential dataflow model may ensure termination of a Fixed Loop dataflow graph by allowing vertices to delay their scheduling until all causally prior differences are retired and only process the causally least difference in their input. This ensures that any difference processed by the Fixed Point operator will not be cancelled at a future point unless a source introduces a new difference.

The Fixed Point dataflow graph shows that the Fixed Point operator is instantiated not by a single vertex but rather by a sub graph. For example the differential dataflow model uses an edge in the dataflow sub graph to connect the input with the output. In various embodiments the differential dataflow model introduces an ingress vertex in the Fixed Point dataflow graph that extends to the lattice elements associated with incoming records dX.

For instance for each record x t received as input to the Fixed Point operator dataflow graph the ingress vertex emits two outputs x t 1 and x t 2 which correspond respectively to a positive weighted version of x in a first iteration of the dataflow graph and a negative version of x in the second iteration of the dataflow graph . The Fixed Point dataflow graph may then be applied to the output of the ingress vertex. Since there are positive weighted and negative weighted copies of the input collections the result of the first iteration will contain f X at time t 1 and f X at time t 2 . In various embodiments the output of the Fixed Point dataflow graph is linked to an incrementer vertex that transforms a record x at time t i into x at t i 1 and feeds the result back into the Fixed Point dataflow graph . At the beginning of the second iteration for the Fixed Point dataflow graph the inputs tagged with t 2 include f X from the incrementer and X from the ingress vertex. The Fixed Point dataflow graph results tagged with t 2 are therefore X X which are incremented and returned as input. Generally the Fixed Point operator graph inputs tagged with t i are equal to X X . The incrementer vertex may delay scheduling or processing as long as possible and may increment the least index i in the input thereby ensuring that X X is iteratively propagated through the Fixed Point operator dataflow graph .

Accordingly the Fixed Point operator loop ceases to propagate updates once a fixed point has been achieved while only propagating necessary updates in the iterative process. Moreover the Fixed Point dataflow graph includes an output which exits the iterative loop index thereby turning the records x t i into x t . The accumulation of all output increments collapses at the final iteration and the fixed point is achieved.

In various embodiments the Prioritize operator generates the Prioritize operator graph . The Prioritize operator graph also has an ingress vertex which introduces a lattice element selected by the priority function followed by the p function followed by an output vertex that strips off the lattice element that was introduced in the ingress vertex. The ingress vertex optionally delays processing difference records dX in its input until all records with higher priority have been flushed through the p function and reached the egress.

In various embodiments the differential dataflow model executes the data parallel program and creates the dataflow graph by partitioning the state and computation of one or more data parallel operations across multiple different threads. This allows a scalable implementation that applies to data maintained at multiple different computers e.g. the different data sources in rather than a shared memory system. Thus in various embodiments the differential dataflow model partitions the state via worker threads that communicate messages to one another.

For example the differential dataflow model may extract data parallelism through application of equation 3 . The differential dataflow model may determine a degree of parallelism p replacing each vertex in the dataflow graph with p independent sub vertices each responsible for a 1 p fraction of keys k. Then the differential dataflow model may replace each directed edge by p p directed edges between source and destination sub vertices. The differences produced by source sub vertices may be partitioned by the destination key function and directed to appropriate destination sub vertices.

In various embodiments the differential dataflow model starts p worker threads each of which is assigned one of the sub vertices of each logical vertex in the dataflow graph . The sub vertices operate independently coordinated through messages communicated between the worker threads. The scheduling strategy for the sub vertices is to repeatedly activate their first sub vertex with unprocessed input differences and each of the sub vertices process all appropriate input differences according to respective delay policies thereby producing any necessary output differences.

To implement the data parallelism the differential dataflow model repeatedly presents each sub vertex with unprocessed input difference traces. Furthermore the differential dataflow model tasks each sub vertex with producing output difference traces. Accordingly the output 

For example an implementation could index A and B by key k such that random access to Aand Bresults. Thus the differential dataflow model can compute zusing the following pseudo code for sub vertex updates.

Reconstructing Aand afor each lattice element t is expensive and unnecessary. Thus in various embodiments the differential dataflow model optimizes equation 11 by determining z t at few lattice elements. For example the differential dataflow model may approximate a t for which z t is non zero from the non zero t in aand A. In particular an update can occur at a t that is the join of a set of times present in aor A at least one of which must be from a. A lattice element t that is not such a join is greater than some elements in the inputs but strictly greater than their join. Consequently the collection at t equals the collection at the join and there is no difference to report. If t is not greater than some update our definition of z t indicates it is empty.

In other embodiments rather than reconstructing A the differential dataflow model maintains A. For example when moving from A s to A t the differential dataflow model incorporates differences from . Equ. 13 

In various embodiments the differential dataflow model takes the meet of update lattice elements. For example as a computation proceeds and the differential dataflow model returns to a sub vertex the meets of lattice elements in aincreases tracking the current loop index. The differences Aoccurring before the meet are included in all t and therefore do not need to be revisited. The only differences of Aof interest are those at lattice elements at least the meet of lattice elements a.

Example operations are described herein with reference to and . The processes are illustrated as logical flow graphs which represent a sequence of operations that can be implemented in hardware software or a combination thereof. In the context of software the operations represent computer executable instructions that when executed by one or more processors perform the recited operations. Generally computer executable instructions include routines programs objects components data structures and the like that perform particular functions or implement particular abstract data types. The order in which the operations are described is not intended to be construed as a limitation and any number of the described operations can be combined in any order and or in parallel to implement the process.

At operation a programmer writes a data parallel program that defines a set of operators that perform computations for a dataflow processing task for a particular real world system to be modeled e.g. a social network system .

For example data parallel programs may define algorithms and or operators that process data according to a lattice type. In various embodiments a data parallel program computes a single source shortest paths algorithm in which each node in a model system repeatedly broadcasts its distance from the source to all of its neighbors and each node accumulates incoming messages and selects a minimum value. In other embodiments a data parallel program computes a connected components algorithm that converges when every node in a connected component holds the same label.

At operation the collection input module collects or identifies data pertaining to the real world system. At operation the differential dataflow model compiles and executes the data parallel program . At operation the collection output module outputs the new collections of data e.g. the results of the computations so that data processing can be performed.

Optionally at operations and may be repeatedly performed as the collections of data pertaining to the real world system change over time e.g. seconds minutes hours days months .

At operation the differential dataflow model uses the lattice indexing module to create a lattice representing changes to collections of data for a real world system.

At operation the differential dataflow model determines a partially ordered set of difference records as lattice elements for a given t and processes the difference traces using the dataflow graph.

At operation output corresponding to the different combinations and or patterns resulting from processing the difference traces.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or operations described above. Rather the specific features and operations described above are described as examples for implementing the claims.

