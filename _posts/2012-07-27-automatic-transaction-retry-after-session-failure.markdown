---

title: Automatic transaction retry after session failure
abstract: Techniques for recovering from session failures between clients and database servers are described herein. A session may be established between a client and a first database server, and a transaction may be opened to process a plurality of database commands. One or more commands associated with the transaction may be received from the client at the database server. Each received command has an associated command identifier. A transaction log stores the command identifier associated with each received command and indicates whether each received command has been successfully executed at the database server. After a session failure, the session is reestablished, and a command identifier for a further command is received from the client. If the command identifier associated with the further command is determined to have been stored in the transaction log, the command does not need to be executed, and the transaction may continue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898109&OS=08898109&RS=08898109
owner: Microsoft Corporation
number: 08898109
owner_city: Redmond
owner_country: US
publication_date: 20120727
---
A database server is a product that provides database services to computer applications in response to requests received therefrom. Such database services may include but are not limited to storing retrieving analyzing or manipulating database data. Depending upon the implementation the applications may be running on the same machine on which the database server is running or may be running on other machines that are connected to the machine on which the database server is running via one or more networks. To send requests to the database server an application connects to the database server and establishes therewith what is referred to as a session. A session represents an ongoing interactive information exchange between the application and the database server. A session is set up or established at a certain point in time and then torn down at a later point in time. An established session often involves the sending of more than one message from the application to the database server and from the database server to the application.

After an application has initiated a session with a database server a transaction may be opened between the application and server to perform a series of database operations. The transaction may be atomic such that all of the database operations occur or none of them occur. As such the application may send a command to the database server for execution within the context of a transaction. At some point in time the connection that was established between the application and the database server may fail. For example in a scenario in which the application and the database server are running on different machines the connection may fail if the machine on which the database server is running is shut down or crashes or if there is a problem with a network that connects the different machines. If the connection fails the session itself fails and the transaction currently being processed by the database server fails. Due to the transaction failing all of the operations of the transaction fail whether or not the database server has already started processing them. As a result the application has to implement retry logic to reattempt the entire transaction. However retry logic is complex to implement in an application. Furthermore when such an application is moved to a cloud environment there are more possibilities for session failures due to the nature of cloud services. As such the application may need to be modified to be better able to handle database access failures in the cloud.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

Methods and systems are provided for recovering from a session failure between a client and a database server and for enabling transactions that were in process during a session failure to be completed in an efficient manner. A transaction log is maintained at the database server to track the progress of executing commands inside of a transaction. If a session failure occurs between a client and a database server and is subsequently reestablished the transaction log may be referenced to enable the transaction to be continued from the point of failure without having to re start the transaction from the beginning and re execute the commands inside the transaction.

Computer program products containing computer readable storage media are also described herein that store computer code instructions for enabling recovery from session failures and enabling completion of transactions that were in process during a session failure as well as enabling additional embodiments described herein.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

The following detailed description refers to the accompanying drawings that illustrate exemplary embodiments of the present invention. However the scope of the present invention is not limited to these embodiments but is instead defined by the appended claims. Thus embodiments beyond those shown in the accompanying drawings such as modified versions of the illustrated embodiments may nevertheless be encompassed by the present invention.

References in the specification to one embodiment an embodiment an example embodiment or the like indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Furthermore when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of persons skilled in the relevant art s to implement such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

Embodiments described herein facilitate recovery from session failures between a client and a database server and enable the efficient completion of transactions that were in process during such failed sessions. A transaction may be initiated by a client to implement a plurality of database commands at a database server such as commands to store write data to retrieve read data and to update modify stored data of a database. In an embodiment a transaction may be an atomic transaction. According to an atomic transaction atomicity is guaranteed such that all database commands of the transaction are executed with respect to the database or none of the database commands of the transaction are executed. Such a guarantee of atomicity prevents updates to the database from occurring partially which can cause greater problems than rejecting the transaction in its entirety. Thus typically a connection failure during the processing of an atomic transaction causes the entire transaction to fail causing all commands of the transaction to be repeated. Embodiments enable transactions that suffer connection failures to be continued from the point of failure rather than having to be retried from the beginning.

Section II describes example embodiments for conducting database queries in a manner that enables recovery from session failures. Section III describes example embodiments in which a session failure between the first database server and the client is recovered between the client and a second database server. Section IV describes an example processor based computer system that may be used to implement various embodiments described herein. Finally Section V provides some concluding remarks.

Although the embodiments described herein are implemented in systems that include database servers persons skilled in the relevant art s will readily appreciate that the concepts described herein can easily be extended to any system in which sessions are established between a first entity to a second entity for execution of data requests and wherein recovery from session failures is desired. Such systems may include but are not limited to any of a wide variety of client server systems peer to peer systems or the like.

Numerous exemplary embodiments of the present invention are described as follows. It is noted that any section subsection headings provided herein are not intended to be limiting. Embodiments are described throughout this document and any type of embodiment may be included under any section subsection.

II. Example Embodiments for Conducting a Session between a Client and a Database Server in a Manner that Enables Recovery

As shown in system includes a client that is communicatively connected to a first database server via a communication channel and is communicatively connected to a second database server via a communication channel . Database servers and are intended to represent entities that perform operations with respect to data stored in one or more databases that are accessible thereto in response to receiving commands generated by clients such as client via communication channels and . The operations performed by each of database servers and may include for example storing retrieving analyzing and or manipulating database data. Database servers and may each be implemented as computer programs executing on a single machine or across multiple machines. As will be appreciated by persons skilled in the relevant art s such machines may comprise physical machines or virtual machines. In one embodiment database servers and may each be an instance of MICROSOFT SQL SERVER published by Microsoft Corporation of Redmond Wash. However this is an example only and is not intended to be limiting.

In one embodiment database servers and each comprise a standalone database server configured to execute commands received from one or more clients such as client . In an alternate embodiment database server and may be included in a plurality of database server instances running on a cluster of machines and employed to service requests from a plurality of clients such as client in a manner that allows for failover and high availability. In a further embodiment database servers and may each comprise one of a plurality of database server instances used to implement a cloud database service such as but not limited to MICROSOFT SQL AZURE offered by Microsoft Corporation of Redmond Wash. In embodiments any number of database servers similar to database servers and may be present including tens hundreds and even greater numbers of database servers.

Client is intended to represent an entity that generates and sends commands to database servers and for execution thereby. For example as shown in client includes a command generator . Command generator may is configured to generate an ID for each command with the transaction. Each time a command of a transaction is transmitted to a database server the command ID for that particular command within the transaction are transmitted to the database server. An identifier for the transaction itself may be generated to identify the transaction and may optionally be transmitted with each command ID. When a transaction is being conducted between client and a database server within the scope of a session e.g. a virtual session a session identifier may also be generated that identifies the session which may or may not also be transmitted with each command. Examples of commands that may be performed by a database server for a client include commands to store retrieve and or modify database data.

Client may be implemented as one or more computer programs executing on one or more machines. For instance client may be implemented in any type of stationary or mobile computing device including a desktop computer e.g. a personal computer etc. a mobile computer or computing device e.g. a Palm device a RIM Blackberry device a personal digital assistant PDA a laptop computer a notebook computer a tablet computer e.g. an Apple iPad a netbook etc. a mobile phone e.g. a cell phone a smart phone such as an Apple iPhone a Google Android phone a Microsoft Windows phone etc. or other type of stationary or mobile device

Client and database servers and may each be executed by different machines that are connected to each other via a particular communication infrastructure. In further accordance with such an implementation communication channels and may be established in a manner that corresponds to the particular communication infrastructure. For example in an embodiment in which the communication infrastructure comprises a network such as a local area network LAN a wide area network WAN or a combination of networks such as the Internet well known networking protocols may be used to establish communication channels and between the client and database servers and . As another example in an embodiment in which database servers and are included in a cloud database service communication channels and may be established via a gateway machine that acts as an intermediary between the machine on which client is running and the machines on which database servers and are running. Such gateway device when present may enable communications between client and one of database servers and at a particular time. Still other communication infrastructures and associated methods for establishing communication channels and are possible.

It is also possible that client and one or both of database servers and may be executing on the same machine. In accordance with such an implementation one or both of communication channels and may comprise a channel that is internal to the machine upon which both entities are executing.

Generally speaking communication channel and are used to transport commands generated by client to one or both of database servers and respectively so that database servers and or may execute such commands. Database servers and may also return requested data error messages or other information to client via communication channels and . In accordance with certain embodiments the manner in which information is exchanged between client and database servers and is governed by a standard application layer protocol that is supported by both entities. For example in a particular embodiment the application layer protocol comprises the Tabular Data Stream MS TDS protocol as defined in Version 20120328 of the Tabular Data Stream Protocol Specification published by Microsoft Corporation of Redmond Wash. However this is only an example and other protocols may be used.

In accordance with certain embodiments to interact with database servers and for the purpose of invoking the database services thereof client connects to one of database servers or and establishes therewith what is referred to herein as a session. For instance client may connect with database server to establish a session. The session represents an ongoing interactive information exchange between client and database server . A session may be set up or established at a certain point in time and then ended at a later point in time. During an established session client may conduct any number of transactions with database server and may send database server any number of commands within each transaction. Database server may return to client results error codes or other information in response to executing or attempting to execute such commands client may alternatively interact with database server in a similar manner when a session is established between them . For instance client may transmit an SQL structured query language command to database server such as a SELECT query or other command. A SELECT query may be used to retrieve data e.g. one or more rows and or columns from one or more database tables managed by a databases server. Client may transmit other types of commands including command to write data to a database e.g. to one or more rows and or columns of one or more tables to modify data of a database etc.

When database server receives write and or update commands from client within an atomic transaction database server may not perform the actual writes updates into the database until all commands of the transaction have been received. For instance database server may partially perform the commands by performing some database manipulation in temporary memory e.g. cache memory in preparation for making the writes updates in the actual database. Database server may also use locks e.g. locking database records to prevent others e.g. other clients from writing data into the portions of the database impacted by the commands depending on the isolation level required by the client. When all commands of a transaction have been transmitted by client to database server client may transmit a commit command to database server . The commit command instructs database server to fully execute all of the commands of the transaction which may cause database server to actually write to and or modify data in the database. After database server fully executes all of the commands of the transaction database server may transmit a commit complete response to client .

As shown in database server includes a transaction log manager and database server includes a transaction log manager . Transaction log managers and function similarly for their respective database servers. Furthermore additional database servers may be present that also include transaction log managers similar to transaction log managers and . For purposes of brevity session manager and transaction log manager are described as follows and this description is intended to be representative of the functionality of session manager and transaction log manager and of further transaction log managers that may be present in other database servers .

Session manager of first database server establishes a session with a client such as client to handle a database query for the client. For instance session manager may receive a session identifier from the client that is used to establish a session with the client and is used by session manager to identify communications associated with the established session. Alternatively session manager may be configured to generate the session identifier for a session and to transmit the session identifier to the client. Furthermore session manager enables a transaction to be opened with the client within the established session and receives commands from the client within the scope of the transaction. Session manager enables responses to the received commands to be transmitted to client as appropriate. Session manager functions for second database server in a similar manner as session manager functions for first database server

Transaction log manager is configured to generate a transaction log . Transaction log contains information representing a state of a transaction between database server and client at any particular time. As such transaction log may be used to recover a transaction in progress from a session failure between client and database server . Transaction log may include various types of transaction information. For instance transaction log manager may store the transaction identifier for a transaction that is open between client and database server in transaction log . Furthermore a command identifier associated with each transaction command generated by client and received by database server may be stored in transaction log by transaction log manager

Still further for each command of the transaction transaction log manager may store an indication in transaction log of whether the command has been successfully executed. This means that for a command transaction log manager may indicate in transaction log whether the command has been performed with respect to a database accessible by database server to the extent that the command may be performed prior to committing the transaction and whether a response e.g. data was returned. For instance for a read command transaction log manager may indicate whether the applicable data has been read from the database and stored in temporary storage e.g. cache memory etc. and or in transaction log itself for transmitting to client after receiving the commit instruction from client or whether the data has already been transmitted to the client. For a write command transaction log manager may indicate whether the data to be written to the database is ready to be written e.g. is stored in temporary storage after receiving the commit instruction from client or whether the data has already been written to the database. Similarly for a modify command transaction log manager may indicate whether the modify data is ready to be written to the database e.g. is stored in temporary storage after receiving the commit instruction from client or whether the modify data has already been written to the database.

The foregoing operations of transaction log manager enable session manager and transaction log manager to aid database server or other database server such as database server in recovering from a session failure between client and database . For instance if a session failure occurs between client and database server e.g. due to a connection failure a failure in database server etc. resulting in a command of a transaction that is being processed not being responded to client may retransmit the command with the command identifier and identifiers for the transaction and the failed session to database server . Database server may reestablish the failed session and may compare the received transaction and command identifiers with transaction log . If the transaction identifier for transaction log matches the received transaction identifier and the received command identifier matches a command indicated in transaction log the command has already been received by database server and the indication of whether the command has been successfully executed may be checked. If the command has not been successfully executed it may be executed at this time. If transaction log matches the received transaction identifier but the received command identifier does not match a command indicated in transaction log the command has not previously been received by database server and may therefore be treated as a new command of the transaction. The failed session may be reestablished in this manner and the transaction may be continued between client and database server from the point of the failure.

Alternatively as described herein another database server such as database server may be provided with a copy of transaction log by transaction log manager shown as replicated transaction log . If a session failure occurs between client and database server in the midst of an open transaction client may retransmit the command with the session transaction and command identifiers. The retransmitted command may be received by database server rather than database server . This may be because database server is not operating due to a system crash or other reason. Database server may compare the received command identifier and transaction identifier with those stored in replicated transaction log and if there is a match the command had already been received by database server and the indication of whether the command has been successfully executed may be checked in replicated transaction log . If the command is indicated as not successfully executed it may be executed at this time by second database server . If replicated transaction log includes a match for the received transaction identifier but the received command identifier does not match a command indicated in transaction log the command was not previously received by database server and may therefore be treated as a new command of the transaction by database server . The failed session may be reestablished between client and database server in this manner rather than database server and continued between client and database server from the point of the failure.

More information regarding the structure function and operation of the components of system in accordance with various implementations is described as follows in regard to .

In particular is a block diagram that illustrates various elements of a client in accordance with one example embodiment. Client is an example of client shown in . As shown in client comprises an application and a database driver . Application comprises a computer program that enables a user thereof to perform various functions at least some of which require database operations to be performed. In order to facilitate the performance of such database operations application is programmed to interact with database driver . In an embodiment application may be considered to be included in client as shown in or may be separate from client . For instance in one embodiment application and client may operate on a common computing device and application may access client to communicate with a database at a database server. Application may be any type of application that accesses data stored in a database e.g. using SQL queries or other types of database requests provided to database driver . Database driver operates to establish a connection between application or any of a variety of other applications and a database server and to utilize such connection for the purpose of obtaining services from the database server.

In one embodiment database driver provides an application programming interface API that can be used by any of a variety of applications to invoke the functionality thereof. As further shown in database driver also includes a command ID generator a parser and a protocol layer . Command ID generator forms an example of command generator of . The features of are described as follows.

Command ID generator is configured to generate an ID for each command that is generated by client for transmission to and execution by a database server within the scope of a transaction. In one embodiment command ID generator generates a unique ID for each command so generated. When client sends a command to a database server client also sends the command ID associated with that command to the database server and optionally includes the associated transaction identifier and session identifier . For example in one embodiment a command and its corresponding command ID are included within the same message that is transmitted from client to a database server.

Parser is configured to encode commands to be sent to a database server and to interpret information received therefrom in accordance with a particular application layer protocol such as but not limited to MS TDS. In one embodiment protocol layer is intended to represent one or more computer programs executing in hardware e.g. one or more processors utilized by database driver to carry encoded commands produced by parser to a database server and to receive encoded information therefrom.

In accordance with the embodiment shown in the functions performed by session ID generator and command ID generator are performed at the level of database driver rather than at the level of application . This is advantageous in that it can relieve programmers of applications that are designed to invoke database driver such as application from having to program features into their applications that are intended to recover from transaction and session failures. Additionally by incorporating such functionality at the database driver level rather than the application level embodiments described herein can advantageously reduce the complexity of such applications.

Session manager establishes a session with a client such as client of to handle a database query for the client. For instance session manager may generator or may receive a session identifier from the client that is used to establish a session with the client and is used by session manager to identify communications associated with the established session. For instance session ID generator of session manager is configured to generate an ID for each session that is established between client and a database server to fulfill a data request e.g. an SQL SELECT query etc. received from application . In one embodiment session ID generator generates a unique ID for each session. The session ID may be generated by session ID generator at database server as shown in or may alternatively be generated at the client and transmitted to the database server to establish the session and may optionally be included in subsequent communications to and from the database server that occur within the scope of the established session to identify those communications as being within the scope of the session .

Furthermore session manager may enable a transaction to be opened within the scope of an established session and may receive commands associated with the transaction from the client. For instance transaction ID generator of session manager is configured to generate an ID for each transaction that is opened by client with a database server within the scope of a session. In one embodiment transaction ID generator generates a unique ID for each different transaction. Database server may transmit the transaction ID to a client to open e.g. begin the transaction. Alternatively the client may generate the transaction ID for the opened transaction and may transmit the generated transaction ID to database server .

In the event of a session and transaction failure session manager may receive a session identifier from a client in a communication transmitted after the session failed and may enable the failed session to be reestablished if the session identifier received in the communication matches the session identifier stored in the session state for a session. Furthermore session manager may receive a transaction identifier from the client corresponding to the failed transaction and may enable the failed transaction to be continued if the transaction identifier received in the communication matches the transaction identifier stored in a transaction log for a session.

Engine is configured to interact with one or more databases such as a database associated with database server to perform various operations on data stored therein based on received commands where such operations include but are not limited to storing reading analyzing and or modifying database data.

Transaction log manager is intended to represent one implementation of transaction log managers and described above in reference to system of and thus performs the functions attributed to each of transaction log managers and . For instance transaction log manager may generate a transaction log that stores the transaction identifier for an opened transaction a command identifier associated with each received command of the transaction and an indication of whether each received command has been successfully executed either partially or fully . Transaction log is an example of transaction log described above. Transaction log may be included in a session state for the established session that is managed by session manager . For instance session manager may store the session identifier for the session in session state . Furthermore temporarily stored data associated with the session such as data retrieved by engine from database in response to one or more commands may be stored in session state e.g. prior to being transmitted to the client . As shown in session state may be stored in a state data repository . State data repository and any further state data repositories described elsewhere herein may include one or more of any type of storage mechanism including a magnetic disc e.g. a hard disk drive an optical disc e.g. an optical disk drive a memory device such as a RAM device e.g. a cache memory for temporary storage etc. and or any other suitable type of storage medium.

Still further after generating session state session manager may optionally replicate e.g. copy session state to at least one additional database server as indicated by the left directed arrow labeled in . The replicated session state enables the one or more additional database servers to reestablish a current session and continue any open transactions if the current session fails.

Remote replicated session state handler is optionally present. Remote replicated session state handler configured to receive replicated session states from other database servers. For instance as shown in remote replicated session state handler receives a replicated session state from a remote server not shown in and stores replicated session state in state data repository . Replicated session state enables database server to respond to reestablish a failed session and to continue an open transaction of the failed session for a session that failed at a different database server. As shown in replicated session state includes a replicated transaction log . Replicated transaction log is a copy of the transaction log from another database server and may be used to continue a transaction open at the other database server at database server .

Parser is configured to interpret client generated commands that are received by database server and to encode information to be sent to clients in accordance with a particular application layer protocol such as but not limited to MS TDS. In one embodiment protocol layer is intended to represent one or more computer programs executing in hardware e.g. one or more processors utilized by database server to carry encoded information produced by parser to the appropriate clients and to receive encoded commands therefrom.

As shown in the method of flowchart begins at step . In step a first session is established with a client to handle a database query for the client. For example as described above session ID generator of database server may generate a session identifier used to identify a particular session. In an embodiment session ID generator may perform a step of a flowchart shown in . In step a session identifier is generated for the first session. Session ID generator may generate the session identifier in any manner including incrementing the numerical value of a prior generated session identifier generating the session identifier in a random or pseudorandom manner or generating the session identifier in another manner.

Referring to database server may transmit the session identifier to a client to initiate a session with the database server. For instance database server may transmit the session identifier to client in a communication transmitted over communication channel may store the session identifier e.g. in session state and may establish a session with client . For instance referring to session manager may establish the session with the client and may receive an acknowledgment from the client. In establishing the session the client and database server may negotiate various parameters of the session including authentication and encryption techniques protocols etc. Operation proceeds from step to step .

Note that in an alternative embodiment client may generate the session identifier and may transmit the generated session identifier to database server to establish the session.

Referring back to in step a transaction of the first session is opened to execute a plurality of commands associated with the transaction for the client. For example as described above database server may open a transaction with client to perform a series of database commands. The transaction may be an atomic transaction such that all of the database commands of the transaction are performed or none of them are performed if there is a failure . Transaction ID generator of database server may generate the transaction identifier used to identify a particular transaction. For instance in an embodiment transaction ID generator may perform a step of a flowchart shown in . In step a transaction identifier is generated for the transaction. Transaction ID generator may generate the transaction identifier in any manner including incrementing the numerical value of a prior generated transaction identifier generating the transaction identifier in a random or pseudorandom manner or generating the transaction identifier in another manner.

Referring to database server may transmit the session identifier to a client to initiate a session with the client e.g. in response to a request received from the client . For instance database server may transmit the transaction identifier to a client to initiate or open a transaction with the database server. Client may receive the transaction identifier from database server in a communication transmitted over communication channel may store the received transaction identifier and may open the transaction with client . For instance referring to transaction log manager may store the transaction identifier in transaction log generated for the transaction. Client and or database server may transmit an acknowledgment that the transaction is open. Operation proceeds from step to step .

Referring back to in step at least one command associated with the transaction is received from the client each received command being received with an associated command identifier. In embodiments any number of commands may be transmitted from client to database server within the scope of the opened transaction including commands to read write or update database data. Database server may respond to each of the commands. Database server may receive a command ID associated with each of the one or more received commands. As discussed above such command IDs may be generated by command ID generator within client and transmitted to database server along with their associated commands. For instance in an embodiment command ID generator may perform a step of flowchart shown in for each command. In step a command identifier is generated for the command. Command ID generator may generate the command identifier in any manner including incrementing the numerical value of a prior generated command identifier e.g. generating command identifiers in sequence generating the command identifier in a random or pseudorandom manner or generating the command identifier in another manner.

With reference to the implementation of client shown in such commands may be encoded by parser and sent to database server via protocol layer . With reference to the implementation of database server shown in the encoded commands may be received via protocol layer and interpreted by parser . Operation proceeds from step to step .

Referring back to in step a transaction log is generated that stores the command identifier s and indicates whether each received command has been successfully executed. In embodiments database server attempts to execute each command received by database server in step . With reference to the implementation of database server shown in engine may execute the commands including retrieving requested data writing data and modifying data in database . Read data may optionally be stored in session state while waiting to be transmitted to client . In the case of an atomic transaction writing and modifying of data in database may not be fully executed until a commit instruction is received from client . Transaction log manager is configured to store the command identifier associated with each received command of the transaction in transaction log . Furthermore transaction log manager stores an indication of whether each received command has been successfully executed e.g. partially or fully in transaction log . Operation proceeds from step to step .

In step a request to reestablish the first session a further command associated with the transaction and a command identifier for the further command are received from the client after a failure in the first session. As described above a session between a client and a database server may undergo a session failure. The session failure may occur for a variety of reasons including a network failure between the client and database server or a failure in the database server e.g. a server crash etc. . Subsequent to such a failure in an embodiment the session between the client and the database server may be recovered and any transactions that were open at the time of the session failure may be continued in an efficient manner.

Referring to after the session failure client may attempt to re establish the failed session with database server . In such case client may re transmit the session identifier used for the failed session to database server in a request to re establish the session. Furthermore client may transmit a further command to database server with the command identifier for the further command. The request to reestablish the session and the retransmission of the command may be received by database server from client in a same communication or in separate communications. Operation proceeds from step to step .

Referring back to in step the first session is reestablished with the client. Database server may analyze the received request to re establish the session to determine whether to reestablish the session with client . For instance in an embodiment database server may perform a process shown in . depicts a flowchart of a process performed at a database server to identify a previously defined session according to an example embodiment.

As shown in flowchart begins with a step . In step the session identifier is received from the client in a communication transmitted to the database server to reestablish the session. As described above database server may receive the session identifier used for the failed session from client in a request to re establish the session.

In step it is determined that the session identifier received in the communication matches the session identifier stored in the session state. In an embodiment database server may compare the session identifier received in step to session identifiers stored in one or more session states to determine whether the received session identifier is for a pre existing session.

For instance in an embodiment session manager of may perform the comparison. is a block diagram of session manager of according to an example embodiment. As shown in session manager may include a session ID comparer a transaction ID comparer and a command ID comparer . Session ID comparer is configured to compare session identifiers received in communications from clients to session identifiers stored in session states. Session ID comparer may perform step by comparing the session identifier received in the request to reestablish the session to the session identifier in transaction log . If the session identifiers match session ID comparer indicates a match and session manager may enable the session to be reestablished. If the received session identifier does not match a session identifier in a stored session state session ID comparer indicates a match is not found. In such case session manager may not enable the session to be reestablished. Instead the session may potentially be reestablished with a different database server if a match occurs at that different database server . Operation proceeds from step in to step in .

Referring to in step whether a command identifier is already stored in the transaction log for the further command is determined. In an embodiment the further command received from client may be a re transmission of a previously transmitted command by client that may or may not have been received and or successfully executed by database server due to the session failure. For instance due to the session failure client may not have received an acknowledgement from database server regarding the command and thus may not even be aware of whether the command was received by database server

Database server may analyze the received retransmitted command to determine how to proceed. Database server may determine whether the command identifier for the received command is indicated in transaction log . For instance in an embodiment referring to transaction ID comparer of session manager may compare the transaction identifier for the received command to the transaction identifier stored in transaction log to determine whether command is part of the open transaction. If the transaction identifier is not stored in transaction log database server may treat the command as part of a different transaction. If the transaction identifier is stored in transaction log the further command is considered to be part of the open transaction. Command ID comparer of session manager may then compare the command identifier for the received further command to any command identifiers stored in transaction log . Operation proceeds to step if a match is found. If the received command identifier does not match any command identifier in transaction log operation proceeds to step .

In step whether the further command was executed successfully is determined. Because the command identifier for the further command is located in transaction log the command was previously received at database server from client . According to step session manager may access transaction log for an indication whether the further command was executed successfully. If the indication is that the further command was not executed successfully operation proceeds to step . If the indication is that the further command was executed successfully operation proceeds to step .

In step the further command is attempted to be executed. Because the further command was indicated as not executed successfully which may mean the further command was not executed at all the further command is attempted to be executed. For instance engine may execute the further command e.g. reading writing and or updating data . If the open transaction is an atomic transaction the further command may be partially executed as described above. Operation proceeds from step to step .

In step the transaction log is annotated with the command identifier and an indication of whether the further command has been successfully executed. In an embodiment after executing a command transaction log manager may annotate transaction log with the command identifier for the executed command if not already present in transaction log and may indicate in transaction log whether the command was successfully executed e.g. partially or fully . Operation proceeds from step to step .

In step the further command is avoided being re executed. Because the further command was indicated as executed successfully the further command does not need to be executed again. For instance the further command may have been previously executed when the further command was previously received by database server from client . Operation proceeds from step to step .

In step it is determined whether another command is received from the client. In embodiments the further command received in step may be the last command of the open transaction or additional commands may be received for the open transaction. If another command for the open transaction is received from client e.g. as indicated by the transaction identifier received with the command and or by the command being received while the transaction is still open etc. operation proceeds to step . If another command is not received operation proceeds to step .

In step the command is attempted to be executed. In a similar manner as in step engine may execute the command e.g. reading writing and or updating data . If the open transaction is an atomic transaction the command may be partially executed as described above. Operation proceeds from step to step .

In step the transaction log is annotated with the command identifier and an indication of whether the command has been successfully executed. Similarly to step after executing a command transaction log manager may annotate transaction log with the command identifier for the executed command if not already present in transaction log and may indicate in transaction log whether the command was successfully executed. Operation proceeds from step to step .

In step a commit instruction for the transaction is received from the client. After client has transmitted all commands of an open transaction to database server and has received corresponding acknowledgments client may transmit a commit instruction to database server to have the transaction committed. Operation proceeds from step to step .

In step the transaction is committed. Database server e.g. session manager causes all commands of the transaction to be fully executed e.g. writes and or updates are made to data in database etc. . Any data to be transmitted to client e.g. due to database reads etc. may be transmitted to client . A commit acknowledgment may be transmitted by database server to client . Furthermore transaction log manager may indicate the transaction as complete in transaction log or may delete transaction log . Operation of flowchart is complete.

Thus by generating and storing transaction log transaction log manager enables client and database server to recover and continue an open transaction from a session failure. After detecting the failure such as by receiving an indication of a connection or communication failure error client can retransmit the current command with command identifier the transaction identifier and the session identifier of the failed session. Database server may receive the command transaction identifier and session identifier and the session may be reestablished between client and database server . Furthermore the open transaction may be continued and the command may be executed if not previously executed.

As shown in the flow of information depicted by sequence diagram begins when client sends a request to database server to open a new connection. In response to receiving request database server sends a session established response to client which may include a session identifier for a new session to be established thereby establishing the requested connection.

Subsequent to the establishment of the connection client transmits a begin transaction request to open a transaction referred to as Transaction T to database server . Database server may transmit a response not shown in to client that includes a transaction identifier for the new transaction to be established thereby indicating that the transaction is open.

After client has opened the transaction with database server client generates a command referred to as Command for transmission to database server . Client then applies a method referred to as UniqueID to Command to obtain a unique ID associated therewith referred to as CmdID. This is shown as event in .

After client has obtained the unique identifier CmdID associated with Command client sends both Command and its associated unique ID CmdID to database server as part of a message . The session identifier and transaction identifier may optionally be sent with Command to identify Command as being within the scope of the established session and open transaction respectively.

Database server receives Command and may execute it at least partially as described above. Database server e.g. transaction log manager of may store the command identifier and an indication of whether the command was successfully executed in transaction log . Database server may transmit an acknowledgment not shown in to client indicating that Command was received.

Subsequent to transmitting Command client generates another command referred to as Command for transmission to database server . Client then applies the UniqueID method to Command to obtain a unique ID associated therewith referred to as CmdID. This is shown as event in .

After client has obtained the unique identifier CmdID associated with Command client sends both Command and its associated unique ID CmdID to database server as part of a message . The session identifier and transaction identifier may optionally be sent with Command to identify Command as being within the scope of the established session and open transaction respectively.

After message is sent client receives an indication that an error has occurred. Such error may result from some failure of communication between client and database server or from a breaking of the session that was established between client and database server

Because such error has occurred client cannot determine whether Command was received by database server e.g. because an acknowledgement was nor received and whether the transaction has failed. If the transaction fails and is an atomic transaction the transaction would have to be retried from its beginning.

Consequently client may re establish a new session with database server that is part of a same virtual session as the previously broken session. For instance client may re transmit the session identifier for the failed session to database server in a message to reestablish the session. Furthermore client re transmits Command along with its unique ID CmdID and the transaction identifier to database server as part of a message .

Note that if database server is functioning after the session failure and if a communication is not received from client requesting to reestablish the first session after a predetermined amount of time expires after the session failure database server may delete transaction log . For instance database server may assume that the transaction is not going to be continued and may delete transaction log to save storage e.g. cache memory space.

When database server receives Command its unique ID CmdID and the transaction identifier it checks to determine if CmdID has already been stored in transaction log associated with the transaction identifier . This may entail checking all command IDs associated with the transaction. If CmdID has already been stored in transaction log database server may send an acknowledgement not shown in to client indicating that Command was received. If CmdID was not found in transaction log database server may at least partially execute Command and may transmit the acknowledgement not shown in to client indicating that Command was received.

When all commands of the transaction have been transmitted from client to database server and acknowledged as received client transmits a commit instruction to cause the opened transaction Transaction T to be committed at database server . Commit instruction may include the transaction identifier to identify to database server the transaction to be committed. In response database server commits the transaction as described above. When complete database server may transmit a response not shown in to client indicating that the transaction is committed.

As shown by the foregoing system advantageously operates to ensure that database server can recover from a session failure and does not execute a command more than once even if client sends the same command multiple times. Such an ability to not perform a command more than once no matter how many times received is referred to as idempotent command execution. This enables handling of database commands at client at the database driver level thereby unburdening the application programmer from having to include retry features in the application and thus simplifying the application logic.

III. Example Embodiments for Recovery from Session Failures between a Client and a Database Server using a Different Database Server

As described above a database query session between a client and a database server may undergo a session failure e.g. before step of flowchart in . The session failure may occur for a variety of reasons including a network failure between the client and database server or a failure in the database server. Subsequent to such a failure in an embodiment rather than recovering the session and any open transactions between the client and the same database server the session and open transactions may be recovered with a different database server. For instance the original database server may not be available to participate in a new session may not be functioning properly etc. . As such a different database server may be used to recover the session and transactions with the client. Any transactions that were open at the time of the session failure may be continued by the different database server in an efficient manner.

For instance referring to transaction log may be replicated copied to another database server such as database server to enable recovery from a session failure that may occur between client and database server . As shown in transaction log may be replicated to database server as replicated transaction log . In an embodiment database server may perform a step shown in to replicate a transaction log. In step the session state is replicated to at least one additional database server . Referring to the example of session manager may transmit session state to one or more additional database servers that have access to database or a copy thereof . By replicating session state transaction log is also replicated to the additional database server s .

As such after detecting a failure such as by receiving an indication of a network connection or communication failure error client can retransmit the session identifier of the failed session. Database server may receive the session identifier such as through a network gateway device that routes communications to database server rather than database server e.g. because database server is not operating etc. . In another embodiment client may include a list of database servers and may try a different database server in the list when the session with a current database server fails e.g. after one or more retries etc. . Database server may establish a session with client based on the same session identifier. Subsequently commands of the transaction that are transmitted by client may be handled at database server with replicated transaction log being used to manage the transaction.

As shown in the method of flowchart begins at step . In step a replicated session state is received from a first database server at a second database server. For example as shown in remote replicated session state handler may receive replicated session state from a first database server. As shown in replicated session state includes a replicated transaction log . In the example of second database server may receive replicated transaction log in a replicated session state received from first database server . As described above replicated transaction log is a copy of transaction log which stores information regarding an open transaction between client and database server

In step a request is received at the second database server from a client to establish a session with the client. After detecting a failure in the session between client and database server client may attempt to reestablish the session by transmitting a request. Database server may receive the request from client indirectly such as through a network gateway device that selects active database servers to respond to database requests for a particular domain or cluster of servers. Alternatively database server may receive the request directly from client . For instance client may include a list of associated database servers e.g. that handle requests for one or more common databases with addresses for each of the database servers e.g. IP addresses etc. . Client may first attempt to reestablish the session with database server and if database server is non responsive may try to reestablish the session with a different database server in the list by communicating with that database server directly. In the current example the request to reestablish the session is received by database server as an alternative database server.

In step a session identifier included in the request is determined to match the session identifier included in the replicated session state. For instance as described above session ID comparer of session manager may compare the session identifier received in the request to the session identifier in the replicated session state.

In step a second session is established with the client at the second database server. If the session identifiers match in step session ID comparer indicates a match and session manager may enable the session to be reestablished and may store an indication as such. If the received session identifier does not match a session identifier in a stored session state session ID comparer indicates a match is not found. In such case session manager may not enable the session to be reestablished.

In step a further command associated with the second session is received from the client at the second database server. Client may transmit a command to database server that was previously transmitted to database server that may not have been received and or executed due to the session failure. The transmitted command e.g. command identifier and transaction identifier may be transmitted over communication channel and received by database server

At this point operation may proceed at second database server using replicated transaction log in a similar fashion as described above for first database server with respect to flowchart shown in proceeding from step of to step of to perform steps . In other words it may be determined whether the further command received in step has an identifier already stored in replicated transaction log step . If so whether the further command was executed may be determined step and may either be executed step and annotated to replicated transaction log step or may not be executed step . If the command identifier was not already stored in replicated transaction log the further command may be executed step and annotated to replicated transaction log step . Further commands received at second database server may be processed steps and the transaction may be committed at second database server steps . In this manner second database server continues and commits the transaction that was opened at database server without having to execute any commands multiple times.

In this manner replication of a transaction log is used to continue a transaction at a different database server than originally established the session with the client. In the embodiment of each database server may include a corresponding repository e.g. state data repository to store a copy of the session state either the original copy session state containing transaction log at the first database server e.g. database server of or replicated copies replicated session state containing replicated transaction log at the additional database servers e.g. database server of . It is noted other approaches may be used to achieve this goal.

For example is a block diagram of an example system that utilizes a shared memory approach to achieve the goal. System includes client first database server second database server first session manager second session manager first transaction log manager and second transaction log manager and operates in a substantially similar manner to system of . However in system rather than using replication to ensure that second transaction log manager has access to a separate copy of a transaction log generated by first transaction log manager a shared state data repository is used. In accordance with this approach first transaction log manager and second transaction log manager are both able to access the same transaction log stored in shared state data repository in a common session state used for the session. Consequently session state and transaction information stored in shared data repository by first database server will subsequently be accessible to second database server e.g. to recover and or continue a failed session between database server and client . Likewise session state and transaction information stored in shared data repository by second database server will subsequently be accessible to first database server

Client database server database server command generator session manager session manager transaction log manager transaction log manager client application database driver API session ID generator transaction ID generator command ID generator parser protocol layer database server session manager engine transaction log manager remote replicated session state handler parser protocol layer session ID comparer transaction ID comparer command ID comparer entity flowchart flowchart flowchart step and flowchart may be implemented in hardware or hardware and any combination of software and or firmware. For example client database server database server command generator session manager session manager transaction log manager transaction log manager client application database driver API session ID generator transaction ID generator command ID generator parser protocol layer database server session manager engine transaction log manager remote replicated session state handler parser protocol layer session ID comparer transaction ID comparer command ID comparer entity flowchart flowchart flowchart step and or flowchart may be implemented as computer program code configured to be executed in one or more processors and stored in a computer readable storage medium. Alternatively client database server database server command generator session manager session manager transaction log manager transaction log manager client application database driver API session ID generator transaction ID generator command ID generator parser protocol layer database server session manager engine transaction log manager remote replicated session state handler parser protocol layer session ID comparer transaction ID comparer command ID comparer entity flowchart flowchart flowchart step and or flowchart may be implemented as hardware logic electrical circuitry.

For instance in an embodiment one or more of client database server database server command generator session manager session manager transaction log manager transaction log manager client application database driver API session ID generator transaction ID generator command ID generator parser protocol layer database server session manager engine transaction log manager remote replicated session state handler parser protocol layer session ID comparer transaction ID comparer command ID comparer entity flowchart flowchart flowchart step and or flowchart may be implemented together in a system on chip SoC . The SoC may include an integrated circuit chip that includes one or more of a processor e.g. a microcontroller microprocessor digital signal processor DSP etc. memory one or more communication interfaces and or further circuits and or embedded firmware to perform its functions.

As shown in system includes a processing unit a system memory and a bus that couples various system components including system memory to processing unit . Processing unit may comprise one or more processors or processing cores. Bus represents one or more of any of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port and a processor or local bus using any of a variety of bus architectures. System memory includes read only memory ROM and random access memory RAM . A basic input output system BIOS is stored in ROM .

System also has one or more of the following drives a hard disk drive for reading from and writing to a hard disk a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD ROM BLU RAY disk or other optical media. Hard disk drive magnetic disk drive and optical disk drive are connected to bus by a hard disk drive interface a magnetic disk drive interface and an optical drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computer. Although a hard disk a removable magnetic disk and a removable optical disk are described other types of computer readable media can be used to store data such as flash memory cards digital video disks random access memories RAMs read only memories ROM and the like.

A number of program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM. These program modules include an operating system one or more application programs other program modules and program data . In accordance with various embodiments the program modules may include computer program logic e.g. computer code or instructions that is executable by processing unit to perform any or all of the functions and features of client database server database server command generator session manager session manager transaction log manager transaction log manager client application database driver API session ID generator transaction ID generator command ID generator parser protocol layer database server session manager engine transaction log manager remote replicated session state handler parser protocol layer session ID comparer transaction ID comparer command ID comparer entity flowchart flowchart flowchart step and or flowchart including any step of flowcharts and and or further embodiments described elsewhere herein.

A user may enter commands and information into system through input devices such as a keyboard and a pointing device . Other input devices not shown may include a microphone joystick game pad game controller scanner touch screen and or touch pad a voice recognition system to receive voice input a gesture recognition system to receive gesture input or the like. In one embodiment a touch screen is provided in conjunction with a display to allow a user to provide user input via the application of a touch as by a finger or stylus for example to one or more points on the touch screen. These and other input devices are often connected to processing unit through a serial port interface that is coupled to bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB .

A display is also connected to bus via an interface such as a video adapter . In addition to display system may include other peripheral output devices not shown such as speakers and printers.

System is connected to a network e.g. a local area network or wide area network such as the Internet through a network adaptor or interface a modem or other suitable means for establishing communications over the network. Modem which may be internal or external is connected to bus via serial port interface .

As used herein the terms computer program medium and computer readable medium are used to generally refer to physical media such as ROM and RAM used to implement system memory the hard disk associated with hard disk drive removable magnetic disk removable optical disk as well as other media such as flash memory cards digital video disks and the like.

As noted above computer programs and modules including application programs and other program modules may be stored on ROM RAM the hard disk associated with hard disk drive the removable magnetic disk or the removable optical disk . Such computer programs may also be received via network interface or serial port interface . Such computer programs when executed by processing unit enable system to implement features of embodiments discussed herein. Accordingly such computer programs represent controllers of system .

As used herein the terms computer program medium computer readable medium and computer readable storage medium are used to generally refer to media such as the hard disk associated with hard disk drive removable magnetic disk removable optical disk as well as other media such as flash memory cards digital video disks random access memories RAMs read only memories ROM and the like. Such computer readable storage media are distinguished from and non overlapping with communication media do not include communication media . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wireless media such as acoustic RF infrared and other wireless media. Embodiments are also directed to such communication media.

As noted above computer programs and modules including application programs and other program modules may be stored on the hard disk magnetic disk optical disk ROM or RAM. Such computer programs may also be received via network interface serial port interface or any other interface type. Such computer programs when executed or loaded by an application enable system to implement features of embodiments of the present invention discussed herein. Accordingly such computer programs represent controllers of the system .

Embodiments are also directed to computer program products comprising software stored on any computer useable medium. Such software when executed in one or more data processing devices causes a data processing device s to operate as described herein. Embodiments of the present invention employ any computer useable or computer readable medium known now or in the future. Examples of computer readable mediums include but are not limited to storage devices such as RAM hard drives floppy disks CD ROMs DVD ROMs zip disks tapes magnetic storage devices optical storage devices MEMs nanotechnology based storage devices and the like.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. It will be apparent to persons skilled in the relevant art s that various changes in form and details can be made therein without departing from the spirit and scope of the invention. Thus the breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

