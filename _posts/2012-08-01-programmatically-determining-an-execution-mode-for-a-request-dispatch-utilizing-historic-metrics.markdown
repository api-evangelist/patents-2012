---

title: Programmatically determining an execution mode for a request dispatch utilizing historic metrics
abstract: A request dispatcher can automatically switch between processing request dispatches in a synchronous mode and an asynchronous mode. Each dispatch can be associated with a unique identification value such as a process ID or Uniform Resource Identifier (URI), historic metrics, and a ruleset. With each execution of the request dispatch, historic metrics can be collected. Metrics can include, but is not limited to, execution duration and/or execution frequency, processor load, memory usage, network input/output, number of dependent dispatches, and the like. Utilizing historic metrics, rules can be constructed for determining which mode to execute the subsequent execution of the dispatch. As such, runtime optimization of Web applications can be further improved.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943196&OS=08943196&RS=08943196
owner: International Business Machines Corporation
number: 08943196
owner_city: Armonk
owner_country: US
publication_date: 20120801
---
This application is a continuation of U.S. patent application Ser. No. 12 715 139 filed Mar. 1 2010 pending which is incorporated herein in its entirety.

The disclosure relates to the field of middleware and more particularly to programmatically determining an execution mode for a request dispatch utilizing historic metrics.

When an application server processes executable code such as a Web application e.g. JAVA Servlet or a JAVA SERVER PAGE there can be one or more request dispatches present within the Web application. These request dispatches are typically denoted by an include function call specifying a resource to execute such as another servlet or JAVA SERVER PAGE JSP . The specified resource can be executed in one of two modes asynchronously or synchronously. Synchronous execution often results in the executable code blocking e.g. suspended until the specified resource execution is complete a situation which in many instances is unfavorable. Further the resource can include additional request dispatches which can execute other resources resulting in an execution chain that frequently introduces significant latency to the Web application. As such several disadvantages can arise as a result of this latency which can include unresponsive applications and or excessive server load.

One solution to overcome these disadvantages is utilizing an asynchronous execution mode for the specified resource. However asynchronous execution introduces overhead such as establishing a new thread placing markers in the output and replacing markers for server or client side aggregation. In many instances this overhead can compound latency which can significantly reduce performance gains offered by asynchronous execution. For instance synchronous execution of a resource can result in 10 ms latency where executing the same resource asynchronously can result in 20 ms latency due to the overhead introduced by the asynchronous execution e.g. thread setup costs .

Further in dynamic server environments synchronous and asynchronous resource execution can have varying results due to changes in resource availability. Since Web applications are commonly deployed in these environments the Web applications are subject to fluctuating performances. To address these problems Web developers often make educated guesses about which execution mode can yield the best performance results. Often times these guesses do not result in the most optimal application performance. As such many server environments executing Web applications can suffer from inefficient resource usage and reduced server capability which can unduly burden an information technology IT infrastructure.

One embodiment of the disclosure includes a method for dispatching a request. In the method a request dispatch to be executed within a first executable code during execution time can be identified. The request dispatch can be associated with a unique identification value. The unique identification value of the request dispatch can identify a second executable code to be executed. The first and second executable code can reside within a component of a Web container. The Web container can utilize any of a variety of technologies that permit the including of resources. For example the Web container can be associated with a runtime environment such as a J2EE runtime environment. Prior to execution of the second executable code an execution mode for the second executable code can be determined. This determination can involve evaluating at least one of a performance metric and a threshold value. The threshold value can be at least one of a user established value and a programmatically established value. The execution mode can be an asynchronous execution mode or a synchronous execution mode. Responsive to the determining of the execution mode the request dispatch can be executed based on using the determined execution mode. The synchronous execution mode can result in the first executable code executing and completing execution before execution of the second executable code begins. The asynchronous execution mode can result in the first and second executable code to be executed simultaneously.

Another embodiment of the disclosure can include a system for dispatching a request. The system can include a dispatch engine able to identify and execute a request dispatch associated with a first executable code. The dispatch engine can be a component of a transport channel chain within a runtime environment. The transport channel chain can be associated with a transport layer of an Open System Interconnect OSI layer model. The runtime environment can be any environment supporting an inclusion of resources. For example and in one embodiment the runtime environment can be a JAVA 2 ENTERPRISE EDITION J2EE runtime environment. The system can also include a request dispatch associated with the first executable code. The request dispatch can be associated with a unique identification value. The unique identification value can identify a unique resource to be executed. The request dispatch can trigger the execution of the unique resource. The unique resource can include a second executable code. The system can also include at least one performance metric that is associated with the request dispatch. The performance metric can be automatically collected during the request dispatch execution. The performance metric can be utilized to modify the execution behavior of the request dispatch. A ruleset can exist that is configured to establish at least one of a threshold value an execution mode and an event handler associated with the request dispatch. The threshold value can be a user established setting or an automatically determined value. The execution mode can be a synchronous execution mode or an asynchronous execution mode. The synchronous execution mode can result in the first executable code executing sequentially with the second executable code where the second executable code is not permitted to execute until the first executable code completes its execution. The asynchronous execution mode can result in the first and second executable code running simultaneously.

The disclosure provides a solution for programmatically determining a request dispatch execution mode during runtime utilizing historic metrics. That is a request dispatcher can automatically and intelligently switch between processing request dispatches e.g. include in a synchronous mode and an asynchronous mode. Each request dispatch can be associated with a unique identification value such as a process ID or Uniform Resource Identifier URI historic metrics and a ruleset. With each execution of the request dispatch historic metrics can be collected. Metrics can include but are not limited to execution duration and or execution frequency processor load memory usage network input output number of dependent request dispatches and the like. Utilizing historic metrics rules can be constructed for determining which mode to execute the subsequent execution of the request dispatch. For instance when the synchronous execution duration e.g. 100 ms of a request dispatch exceeds a user specified duration e.g. 50 ms the subsequent execution of the request dispatch can be executed in asynchronous mode. The rules associated with the request dispatch can be one or more arbitrarily complex rules for determining an appropriate execution mode. As such runtime optimization of Web applications can be further improved.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present invention may take the form of a computer program product embodied in one or more any tangible medium of expression having computer usable program code embodied in the medium.

Any combination of one or more computer usable or computer readable medium s may be utilized. The computer usable or computer readable medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device or a magnetic storage device.

The computer readable medium can be a non transitory storage medium in which data is retained in a digitally encoded form. The computer readable medium can be a physical tangible storage medium able to retain information which is extractable by computing equipment to obtain the data content that was stored upon the storage medium.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as JAVA Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Method can be performed within the context of any number of suitable systems such as system . Throughout the disclosure for clarity of expression and convenience JAVA based implementation examples have been provided. Scope of the disclosure is not limited in this regard and inventive arrangements detailed herein can be implemented using any of a variety of technologies including non JAVA ones so long as the implementation technologies support the inclusion of resources. For example in one embodiment .NET technologies can be utilized when determining an execution mode for a request dispatch using historic metrics as detailed herein.

As used herein request dispatch can include programmatic commands permitting the execution of a developer specified resource. In one embodiment e.g. a JAVA based one the request dispatch can be a JAVA Application Programming Interface API method such as include and forward . The request dispatch can be uniquely identified utilizing one or more identification mechanisms including but not limited to process ID automated manual code annotation tagging Uniform Resource Locator URL identification unique path identification unique query string and the like. Each request dispatch can be associated with one or more historic metrics and execution mode settings enabling optimized request dispatching based on application server performance.

In step an executable code within a Web container is initialized. The executable code can be a Web application executing within the Web container. The Web container can be one or more constructs executing within a JAVA 2 ENTERPRISE EDITION J2EE application server such as a JAVA VIRTUAL MACHINE JVM . Other servers such as a .NET server can be utilized instead of the J2EE application server depending on implementation choices and a target implementation environment in which method is performed. In step a request dispatch associated with the initialized executable code is identified. The identified dispatch can be associated with one or more resources to be executed. The resources can be one or more executable code objects such as servlets one or more JAVA SERVER PAGE JSP Web pages and the like. In step if metrics exist for the identified dispatch the method can continue to step else proceed to step . Metrics associated with the identified dispatch can be one or more historic metrics. Metrics can include but are not limited to execution duration and or execution frequency complexity processor load memory usage network input output number of dependent identified dispatches and the like. For instance metrics can include the average execution duration of the identified dispatch over a determined period of time. Further metrics for each execution mode of an identified dispatch can be tracked enabling optimum decision making functionality. That is an evaluation of metrics for an asynchronous execution mode and synchronous execution mode can be performed to establish default settings for a Web application.

In step if historic metrics for the identified dispatch exceeds a previously established threshold value the method can continue to step else proceed to step . For instance the threshold value can be a timing value such as an execution duration. In one embodiment historic execution time and threshold values can be numerically compared to determine which mode to execute the identified dispatch. In instances where a threshold value is absent the identified dispatch can be executed using a best guess approach. For example by analyzing similar dispatches a threshold value can be programmatically derived permitting intelligent execution of the identified dispatch. In step a dispatch event is registered with an event handler. In step the identified dispatch is executed in asynchronous mode which can include non blocking code execution. That is the Web application can continue to execute simultaneously with the identified dispatch. In step metrics for the identified dispatch can be collected. Metrics can be collected utilizing one or more metric collection components such as performance monitoring agents. Performance monitoring agents can include but are not limited to load monitors executable code optimization tools and the like.

In step the identified dispatch can be executed in synchronous mode. In step metrics can be collected for the identified dispatch. In step metric data can be collected for the identified dispatch. In one embodiment metric data can include the blocking duration of the identified dispatch. In step if the identified dispatch execution is completed the method can continue to step else the method can return to step .

In step identified dispatch is executed using default settings and metrics associated with the dispatch can be collected. In step the threshold value can be optionally modified based on historic metrics. For instance modification can include increasing decreasing threshold values over time. That is runtime performance can continually improve as historic metrics are collected. In step if more dispatches associated with the executable code are available for processing the method can return to step else continue to step . In step execution of executable code can be terminated.

It should be appreciated that the disclosed steps of method should not be construed to limit the invention in any regard. Method can be performed continuously and in real time permitting each executable code to be dynamically optimized as application server resource availability fluctuates. However to avoid over optimization of dispatches which can decrease performance each request can be optionally statically determined by the method . In one embodiment method can be performed at intervals allowing computing resources to be minimized.

Utilizing API an application developer can permit a request dispatch to be processed in an optimally execution mode at runtime based on available computing resources. In one embodiment API can be a component of an IBM WEBSPHERE Web container platform. For example an application developer can access request dispatch functionality through one or more import directives e.g. import com.ibm.Websphere.Webcontainer.RequestDispatch . Request dispatch can include one or more parameters to allow customization of execution. In one embodiment arguments e.g. auto 500 ms can permit an application developer to control a portion of the request dispatch behavior. Further API can permit functionality to natively manage and monitor request dispatches allowing developers to maintain control of the execution code and runtime environment.

In one embodiment a request dispatcher can reside within an Open System Interconnect model transport layer . The dispatcher can transparently receive and dispatch HTTP requests to appropriate Web containers . As such dispatcher can function independently from deployed applications and application limitations.

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. In one embodiment API can be transparent to the application developer such that request dispatch syntax can be identical to traditional syntax. Further the API can be a component of a base package which provides functionality automatically to a Web application. That is application developer need not be required to manually import the API functionality.

As used herein each servlet can be associated with one or more executable resources via a request dispatch . Servlet can execute within a Web container of a JAVA 2 ENTERPRISE EDITION J2EE application server or other type of server in other contemplated embodiments . Web container can be a dynamic runtime environment such as a JAVA VIRTUAL MACHINE runtime environment. For example servlet can be a Web application which can present Web based content e.g. Web pages to a requesting client within a browser interface . Each request dispatch can be associated with a unique identification value such as a process ID or a unique key and or a resource identifier e.g. Uniform Resource Locator . In one embodiment the unique key can be an automatically generated value e.g. by dispatch engine or a manually determined value. In one instance the unique identification value can be stored as an annotation or even a source code comment which can be extracted during compile time.

Servlet can receive a request which can trigger the execution of a request dispatch . When a request dispatch is encountered by runtime environment the dispatch can be analyzed to determine which resource to execute based on a user specified resource identifier. In one embodiment dispatcher can negotiate the execution of the specified resource with another runtime environment such as servlets executing in different Web containers.

Request dispatcher can uniquely identify and execute dispatch based on one or more rules and or settings. That is dispatcher can be configured to adapt to server resource availability e.g. server load . Request dispatcher can include dispatch engine metric engine performance monitor rules and interface . In one embodiment dispatcher can be a pluggable extension to Web container . Settings can be a user established setting or an automatically determined setting. For instance default timeout values for dispatches can be dynamically determined based on servlet performance.

Dispatch engine can process dispatch and programmatically determine a suitable execution mode using historic metrics . Engine can be responsible for identifying and or executing local and remote resources associated with dispatch . In instances where resource processing is performed remotely engine can forward the request to the remote processor where the processing can be performed. In instances where resource processing is performed locally engine can manage the request dispatch .

Metrics engine can collect historic metrics associated with servlet and or dispatch . For instance metrics can be collected at the servlet level permitting high level metrics to be obtained. In one instance metrics engine can collect metrics in real time or near real time. For example engine can be configured to track the last X number of dispatches over the last Y seconds where X and Y is user configurable. Further metrics engine can be used to monitor real time performance of Web container which can be presented via interface .

Historic metrics can include resource information such as latency execution mode and memory usage. Historic metrics can be associated with each dispatch execution. In one embodiment metrics for each mode e.g. asynchronous and synchronous can be computed enabling evaluation of an aggregate metric for each mode. In this manner engine can compute a suitable execution mode for the dispatch prior to execution. In another embodiment metrics associated with dispatch can be aggregated together and evaluated against a threshold value e.g. rule in ruleset . For instance the memory cost associated with an asynchronous execution can be compared to a memory quota value e.g. threshold value to determine if the overhead of an asynchronous execution is an optimal choice. In another instance the time overhead for setting up destroying an asynchronous context can be compared against a previously established threshold to determine which mode asynchronous or synchronous should be used.

Ruleset can comprise of one or more arbitrarily complex rules for determining the execution mode of a dispatch . Ruleset can be user established and or can be heuristically determined. In one embodiment multiple metrics can be evaluated together to determine an execution mode. Ruleset can include but is not limited to a threshold value an execution mode and an event handler associated with the request dispatch and the like. For instance the threshold value can be a user established setting or an automatically determined value. Ruleset can further specify the type of aggregation to be used e.g. server side vs. client side which can be used to prepare request . When dispatch execution is complete request can be generated and conveyed to client via network .

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. System can be one or more components of a distributed computing environment network computing environment Service Oriented Architecture SOA and the like. In one embodiment system can be one or more components of an IBM WEBSPHERE APPLICATION SERVER. In another embodiment system can include one or more components of a .NET framework or any other framework that permits resources to be included for purposes described herein .

In one embodiment presentation of request dispatches and metrics can occur in real time enabling execution snapshots to be obtained readily.

Interface can permit management of one or more executing request dispatches and dependent request dispatches. Interface can include sections and interactive interface elements . In interface information associated with a request dispatch can be presented within section . Request dispatch information can include but is not limited to process ID execution duration execution mode and the like. For instance section can present each request dispatch and dependent dispatch associated with a Servlet A. In one embodiment an administrator can selectively manage groups of request dispatches. Interface can present additional information such as active rules performance metrics and the like.

Information associated with a selected request dispatch can be presented in section . For instance interacting with interface element can present information associated with the dispatch request. In one instance section can permit modification of request dispatch values such as timeout values execution mode and the like. That is real time manual optimization of request dispatches can be achieved when automated optimization prove unsuccessful. In one embodiment interface can permit thread management capability. For instance interface element can allow a selected request dispatch to be terminated. Interaction with interface element can present inspection interface .

Interface can include section which can present metrics associated with a selected request dispatch . Section can include historic metrics such as processor usage execution duration and memory usage. For instance section can present the average resource load of a request dispatch using collected historic metrics. In one embodiment the historic metrics can be presented in multiple levels of granularity. For example historic metrics can be presented based on increments of day week month and the like.

Drawings presented herein are for illustrative purposes only and should not be construed to limit the invention in any regard. In one embodiment interfaces can be one or more screens of a JAVA 2 ENTERPRISE EDITION optimization tool. In another embodiment interfaces can be a component of an integrated development environment IDE . Interfaces can be a graphical user interface GUI a voice user interface VUI multi mode interface and the like. Interface elements associated with interfaces can include but is not limited to interactive buttons drop down menus radio selection elements and the like.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of all means or step plus function elements in the claims below are intended to include any structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present invention has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiment was chosen and described in order to best explain the principles of the invention and the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

The flowchart and block diagrams in the illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

