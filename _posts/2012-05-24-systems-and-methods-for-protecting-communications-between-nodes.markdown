---

title: Systems and methods for protecting communications between nodes
abstract: Systems and methods for protecting communications between at least two nodes protect the identity of a node requesting information, provide content of communications being sent and/or obscuring a type of communications being sent. Varying degrees of protection options including encryption, intermediate node termination and direct node communications are provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09325676&OS=09325676&RS=09325676
owner: IP Ghoster, Inc.
number: 09325676
owner_city: Westfield
owner_country: US
publication_date: 20120524
---
Example embodiments of the present invention relate to the use of various techniques to protect communications between nodes.

Conventional web tracking solutions are typically separated into solutions loaded in a customer s server for example packet sniffing and Internet Information Services IIS log file analysis software and solutions that attempt to track page level activity and which take the form of code inserted in a web page third party Web cookies or software applications.

Various countries corporations and Internet Service Providers block censor or filter communications transmitted between two or more nodes. These communications can occur via the Internet an Extranet an Intranet or any other communication path that allows two nodes to communicate with one another. The mode of communication between the nodes is independent of the communication path and includes for example client server peer to peer and mainframe communication architectures. All types of communications including for example wireless cellular wired optical and satellite communications may be subject to censorship. Moreover each of the various modes of communication including for example client server mainframe distributed and peer to peer are subject to censorship.

For example a user may subscribe to an Internet sports package to watch sporting events over a network. The user can request and watch so called out of market games but the games are often censored referred to as blacked out when a team is playing locally and the televised version of the game is available on local free or pay television channels. The distributor of the content identifies the source of the content request and denies the request if the source is within the blackout areas.

As another example a user living in Los Angeles Calif. representing a Requesting Node may normally be blocked from obtaining Target Content e.g. online TV from a particular website which represents a Responding Node because the website is configured to serve content only to users in the state of New York. Referring to the user at Requesting Node may find an Intermediate Node which requests the content from the Responding Node from within the state of New York. The user sends a request for the content on the target website to the Intermediate Node and the Intermediate Node obtains the content unrestricted in this example from the target website and returns the content to the user in Los Angeles.

An Intermediate Node may cache Target Content obtained from the Responding Node and still be considered an Intermediate Node as long as the Requesting Node is attempting to obtain the content data from the Responding Node . The data may be as simple as a low level communications request to check if a target server exists or the data may be as complex as is supported on the communication path used and by the type of communications selected.

Nodes are logical constructs that can be physically implemented as discrete nodes as part of other logical nodes or as a system. Requesting Nodes Intermediate Nodes and Responding Nodes may exist at the same physical location at completely disparate physical locations or at any combination thereof. Logical nodes may be comprised of different parts of a larger system be themselves independent systems or be combined together in any combination. For example a group of networked computers may each utilize a shared access point that is itself acting on behalf of a single logical node.

Many Intermediate Nodes do not provide visibility to their data retrieval activities and this lack of visibility causes difficulties with respect to the conventional use of Intermediate Nodes . Many Intermediate Nodes do not provide the services that they purport to offer and in fact many nefarious Intermediate Nodes cause more harm than any benefit they may provide. Harmful Intermediate Nodes may download malicious content onto a Requesting Node infiltrate the Requesting Node by utilizing an array of techniques or promote the location of the Requesting Node to dangerous third party groups. The Requesting Node has almost no inherent protection from harmful Intermediate Nodes .

Moreover using an Intermediate Node through any sort of manual effort can be both technically challenging and time consuming for a typical end user. Intermediate Node usage may require entries to be made in special sections of a Requesting Node s operating system file directory or some other configuration option either directly or indirectly and the only manner in which to determine if an Intermediate Node is a viable and functional option is typically to use the Intermediate Node and hope that nothing harmful occurs to the Requesting Node . Given the large number of Intermediate Nodes providing intermittent connectivity an end user may have to attempt to use hundreds or more of Intermediate Nodes prior to finding a somewhat viable option.

Compounding these problems with the conventional use of Intermediate Nodes is that an apparently functional Intermediate Node may hide additional data within the Target Content or perform actions beyond the scope of the Responding Node that directly or indirectly affect the Requesting Node . While an end user may find an apparently functional Intermediate Node through which requests for Target Content are fulfilled the end user may have no idea if the Intermediate Node is also downloading malicious content or performing other potentially harmful operations. Furthermore the end user has no way of knowing from which geographic region a given Intermediate Node is sending out Content Requests to the Responding Node . Overcoming censorship may rely on being perceived as requesting information from a distinct and safe geographic region but given the conventional options in the market choosing a specific location for an Intermediate Node is not possible.

It should be noted that an end user is not required. Automated machine to machine communications routing between systems networking devices and other communication related efforts may utilize an Intermediate Node in place of an end user. An end user can therefore be a human a computer a program or some portion of code that produces a Node Request . Node Requests may be generated directly or indirectly and with or without knowledge of the Intermediate Node . Content Requests need not be defined as distinct or separate from the Node Requests because the Content Request can be a routed Node Request or a context based new message.

Utilizing an Intermediate Node may aid in overcoming geography based restrictions and Intermediate Nodes may provide additional benefits including for example cookie blocking information compression and virus protection. However communications between two or more nodes can be infiltrated blocked transformed or altered through some unwanted action by various mechanisms.

One known issue with communications between two nodes is referred to as eavesdropping which includes any activity that somehow intercepts and reads processes stores or interacts with communication not intended for the node perpetuating the activity. A conventional solution to protect against eavesdropping is to utilize some form of encryption for example Virtual Private Networks VPN or Secure Socket Layer SSL . As programming capabilities increase in power these conventional technologies can be overcome and no longer provide the level of protection that they once offered. Furthermore VPN typically requires static specialized nodes referred to as VPN Servers and such a static approach may preclude dynamic communications by an increasingly mobile audience.

Another common communications issue is one of discovery which can lead to inadvertent loss of privacy. Even if a technology such as VPN is successful is protecting the data within a given communication potentially unwanted observers can still determine a significant amount of information about the given communication by examining the nodes involved in the communication. For example if a factious site is providing music downloads for a popular music group and a node obtains content from that site an observer could determine that the node likely downloaded music from the music group without ever needing to decrypt the protected data in the communication.

Furthermore a potentially unwanted observer may observe the communication protocol used for the communication to gain another level of insight into a communication between two nodes. In the previous example the potentially unwanted observer may determine for example that an FTP protocol was used between the known music site and the Requesting Node thereby providing more evidence to the observer that music was downloaded. There is no available option for protecting the Responding Node and the communication protocol from unwanted observation.

There is a range of conventional options for virtualizing application interfaces over a network. However one of the main issues with these conventional approaches is the use of specialized ports known protocols and the high bandwidth required to port across entire operating system environments. These types of communications are highly visible and are typically targeted for eavesdropping purposes.

It is an objective of example embodiments of the present invention to provide a more comprehensive suite of protective options for communications between two or more nodes.

Example embodiments provide a Packet Level Program that is configured to interact with communications down to the individual packet level or the lowest level of data supported by a given communication protocol if packets are not used by the protocol. The Packet Level Program may interact with higher levels of the communication protocol without limitation. The Packet Level Program may utilize Intermediate Nodes to obtain Target Content from Responding Nodes or the Packet Level Program may communicate directly with Packet Level Programs on other nodes in a unidirectional or a bidirectional manner. The Packet Level Program may communicate directly with nodes including Cryption Nodes.

The Packet Level Program may alter communication data including for example data compression encryption obfuscation or data splitting. Communication data is for example any text data binary data or some combination thereof that can travel over a communication protocol either between two nodes or within a logical node between two or more physical processes. A process is a specific object within a given node that obtains resources for some period of time including for example memory processor time or file system access. In an example embodiment a process may be a routine application script service computer server set of servers program code snippet or some other object that utilizes resources on a given node.

The Packet Level Program may wrap one communication protocol within another transform between communication protocols or map one or more communication protocols to one or more alternate protocols. The Packet Level Program may alter communications between two nodes in one communication direction only or in both communication directions. For example a Packet Level Program on a Requesting Node may embed a range of protocols into for example a standard web request. The standard web request may be sent directly or indirectly through an Intermediate Node to another Packet Level Program on a Responding Node. The Packet Level Program on the Responding Node may extract out the embedded protocol s prior to sending the communication to Computer Applications on the Responding Node.

Referring to a Packet Level Program according to an example embodiment is an independent process that intercepts packets of information as the packets enter and leave a given Requesting Node . If a given communications protocol does not use packets the packet Level Program interacts with the lowest level of available communication or formatted data for that protocol. For example a pulse switching protocol utilizes pulses of light to encode messages. The Packet Level Program interacts with the pulses of light if the Packet Level Program is applied to intercept information from communications using a pulse switching protocol. Each pulse sequence may be processed internally by the Packet Level Program to determine the encoded message the message is altered and a new set of light pulses are transmitted in turn. provides a schematic overview of a Packet Level Program that communicates through an Intermediate Node according to an example embodiment.

The Packet Level Program need only interact with a given packet prior to the packet being sent to a Network Interface Card from Computer Applications and the Packet Level Program may interact with packets received from the Network Interface Card in a given operating system before sending the packets to the Computer Applications . Other hardware for example memory hard drives and Network Interface Card specific drivers may also interact with the packets.

The Packet Level Program may be a single program a distributed system or some combination thereof. The packet Level Program may comprise a single driver on a given node or the Packet Level Program may comprise two or more drivers on a single node. Alternatively the Packet Level Program may comprise packet intake components on one node and packet processing on a different node. Another example embodiment of the Packet Level Program may comprise a component for sending packets on one node and a component for receiving packets on another node. Example embodiments of the Packet Level Program may comprise components in a User Mode and or a Kernel Mode .

The Packet Level Program may comprise a driver that is situated directly on top of the Network Interface Card as will be explained in more detail below. Computer Applications which are any routine application script service or program that sends packets out of a computer or receives packets from other nodes may send the communications without knowledge of the Packet Level Program . Computer Applications send standard Content Requests from a computer e.g. a Requesting Node and the Packet Level Program transforms the outgoing Content Requests into Node Requests . Similarly incoming Intermediate Node Responses to the Computer Applications are converted by the Packet Level Program into standard Content Responses prior to being sent to the Computer Applications . For example a Computer Application typically sends a Content Request directly to a Responding Node and the Computer Application typically receives a Content Response back from the Responding Node . However a Packet Level Program according to example embodiments may invisibly to the Computer Application inject a Node Request into the communication path of the Content Request and translate the resultant Intermediate Node Response without the Computer Application ever realizing any modification of the communication path occurred.

An example of the Protocol Driver Subsystem and the Filter Driver Subsystem in the form of NDIS is now provided for descriptive purposes however one skilled in the art will recognize that that the Protocol Driver Subsystem and the Filter Driver Subsystem are not limited to a NDIS application. The Network Driver Interface Specification NDIS is an application programming interface API for network interface cards NICs . NDIS was jointly developed by Microsoft Corporation and 3Com Corporation and is mainly used in Microsoft Windows. However the open source NDIS wrapper project allows many NDIS compliant NICs to be used with Linux FreeBSD and NetBSD. Moreover magnussoft ZETA a derivative of BeOS supports a number of NDIS drivers.

The NDIS is a Logical Link Control LLC that forms an upper sublayer of an Open Systems Interconnection OSI data link layer layer 2 of 7 and acts as an interface between layer 2 and layer 3 the Network Layer . The lower sublayer is the Media Access Control MAC device driver. The NDIS is a library of functions often referred to as a wrapper that hides the underlying complexity of the NIC hardware and serves as a standard interface for level 3 network protocol drivers and the hardware level MAC drivers. Another common LLC is the Open Data Link Interface ODI .

Using a NDIS system as an example TCP IP packets may enter the send packet handler of the NDIS filter driver from the upper level Protocol driver. The Protocol driver receives its TCP IP packets from user level applications for example web browsers and email clients. These packets leave the Protocol driver with amongst multiple other fields an identifying sequence number a destination IP address and a destination port number. Note that these fields are specific to this representative example and other example embodiments may have different and or additional fields. The NDIS driver redirects the packets to a proxy server by changing the fields and performing HTTP data reformatting including re computing cyclical redundancy checks CRC at all required layers. The field information is kept for the duration of a connection request.

TCP IP packets enter the receive packet handler from the lower level network interface card driver. The network interface card driver receives the packets from the wide area network e.g. the Internet . The packets have the same fields modified so that the upper level Protocol driver knows that the packets originated from its stack. The modified fields may include the original destination IP address the original destination port number and what would be the sequence number had this connection not been redirected.

After the requisite fields are modified and any optional CRC re computing completed the packets are forwarded to the original requesting Computer Application .

A system according to an example embodiment has an ability to handle communications between the Computer Applications and the Packet Level Program and communications between the Packet Level Program and other logical nodes. illustrates an example embodiment of a system including a Packet Level Program configured to interact with TCP packets. A Website Address and Port containing the Target Content in a Send Packet sent from the Computer Applications are moved to other TCP Header fields and the two fields originally containing the Website Address and Port are replaced with an Intermediate Node Address and Port by a Send Packet Modifying Handler in the Packet Level Program . The Packet Level Program thus transforms the Send Packet into a Modified Send Packet including a proxy server address a proxy server port and a proxy TCP sequence number of the Intermediate Node in place of the original Website Address the original Website Port and the original TCP sequence number for the Target Content . Each TCP communication requires a unique TCP Sequence Number to ensure packets are not missed. The Filter Driver Subsystem therefore first communicates with a target Intermediate Node to obtain a given Sequence Number which is subsequently used to transform the Content Request into a Node Request by the Packet Level Program i.e. to transform the Send Packets into the Modified Send Packets .

As shown in the above described process is reversed for TCP packets sent to the Computer Applications and a Node Response is transformed into a Content Response by the Packet Level Program . A Receive Packet Modifying Handler in the Packet Level Program transforms a Receive Packet which includes a proxy server address a proxy server port and a proxy TCP ACK number of an Intermediate Node into a Modified Receive Packet including the original Website Address original Website Port and the original TCP ACK number

The Protocol Driver Subsystem and the Filter Driver Subsystem may be required for the Packet Level Program for a particular operating system. However different operating systems and Requesting Nodes may have different requirements and the Packet Level Program need only be configured to modify all incoming and outgoing packets of information. That is the Packet Level Program need not include the Protocol Driver Subsystem and the Filter Driver Subsystem depending on the operating system and Requesting Node to which the Packet Level Program is applied. When using the term transfer control protocol TCP herein there are no restrictions in terms of IPv4 versus IPv6 nor are UDP and TCP the only types of packets that can be intercepted by a Packet Level Program according to example embodiments. Any packet of information that contains a discernible URI in a readable format is a candidate packet for the Packet Level Program .

The TCP Sequence numbers or the sequence numbers for whatever packet type is utilized for the communications to and from the Computer Applications are synchronized between the two disconnected sets of communications i.e. between the Send Packets and the Receive Packets . For example the TCP Sequence between a Computer Application and the Packet Level Program may start at 0 and the TCP Sequence between the Packet Level Program and a Responding Node may start at the number 500. Numbers are used for purely illustrative reasons and do not impart any of limitation on example embodiments as will be recognized by one of skill in the art. When the Computer Application sends a first TCP packet as part of a Content Request the Packet Level Program records the sequence number of the first TCP packet and sends out a Node Request with a starting TCP sequence number of 500. If for example the Content Request uses 50 packets the final sequence number is 50 for communications between the Computer Application and the Packet Level Program . On the Node Request side if for example 60 packets are used to send the Node Request the final TCP sequence number is 560 for communications between the Packet Level Program and the Responding Node . There is no restriction on sizes of the Content Request and the Node Request being the same size or different sizes. When a node response comes back to the Packet Level Program from the Responding Node in the present example the TCP Sequence Number of the first packet is 561. The Packet Level Program thus sends a Content Response to the Computer Application starting with a TCP sequence number of 51. Again the above example of TCP sequence number synchronization is intended to provide insight into a Communications Virtualization process according to an example embodiment and does not impart any restriction on how the synchronization or sequencing must occur for a given communication protocol.

By utilizing a packet level approach to handling Intermediate Node redirection an entire new architecture can be supported wherein upper level Computer Applications can operate without having any knowledge of the Intermediate Nodes . Conventional utilization of Intermediate Nodes required specific alteration configuration or modification of Computer Applications which was time consuming and often not possible. While alternative technologies such as Virtual Private Networks VPN do offer other non Intermediate Node options these conventional technologies come with their own limitations including high visibility and ease of blocking By invisibly redirecting standard requests through Intermediate Nodes anonymous traffic benefits can be obtained without these detractions.

A packet level approach to handling Intermediate Node redirection as will be shown in further detail below opens up the ability to provide additional layers of communication protection not possible with other approaches. For example multicast secured communications utilizing low level packet encryption may provide superior protection for communications without requiring expensive hardware systems such as VPN servers. Furthermore the ability to interact at such a lower level enables options including for example protocol masking and recipient obfuscation techniques described more fully in later sections which support additional security layers.

If the Packet Level Program is executed completely in the User Mode either the native Interface Card Layer provides an External Hook or the hook is manually created to insert packets of data into the outbound communications stream. The Packet Level Program may intercept all inbound and outbound packets of communication. According to optional rules the Packet level Program may send the intercepted packets directly to the Socket Interface Layer unmodified or processing the packets as described previously and use a Filter Interface to inject those modified packets through the External Hook into the outbound stream.

The Filter Interface and External Hook can be provided directly by the operating system built as part of the Packet Level Program or some combination thereof. The Filter Interface may be as robust as required and need only enable modified communications packets to be sent to the External Hook . The External Hook may encompass any additional levels of functionality desired and need only enable the injection of packets into the outbound communications stream immediately prior to the packets entering the Network Interface Card .

The inbound packets pass back up through the native layers without any interaction from the Packet Level Program until they enter the User Mode at which time each packet enters the Packet Level Program . As described previously the Packet Level Program may modify the packets prior to sending the packets stream to the upper level Computer Applications .

The Socket Interface may be implemented using technologies including for example Layered Service Provider LSP . LSP is a feature of the Microsoft Windows Winsock 2 Service Provider Interface SPI . A Layered Service Provider is a DLL that uses Winsock APIs to insert itself into the TCP IP protocol stack. Once in the stack a Layered Service Provider intercepts and modifies inbound and outbound Internet traffic and allows for processing of all the TCP IP traffic taking place between the Internet and the applications that are accessing the Internet e.g. a web browser the email client etc. .

The Windows Filtering Platform WFP may be utilized for the Unified Interface and the External Hooks and . Windows Filtering Platform WFP is a set of API and system services that provide a platform for creating network filtering applications. The WFP API allows developers to write code that interacts with the packet processing that takes place at several layers in the networking stack of the operating system. Network data may be filtered and modified before the network data reaches its destination. By providing a simpler development platform WFP is designed to replace previous packet filtering technologies such as Transport Driver Interface TDI filters Network Driver Interface Specification NDIS filters and Winsock Layered Service Providers LSP .

The Unified Interface may be implemented as a WFP Interface and may use callout drivers as its external hooks. A callout driver implements one or more callouts. Callouts extend the capabilities of the Windows Filtering Platform by processing TCP IP based network data in a manner that is beyond the scope of the simple filtering functionality. A callout can for example perform modification and reinjection of the network packet headers or data or both. A network address translation NAT product for example may modify the headers on IPv4 packets.

If WFP is not employed by an example embodiment the External Hook may be implemented as a Protocol WFP Callout Driver which enables the functionality of the Protocol Driver Subsystem in User Mode . The External Hook may be implemented as a WinSock WFP Callout Driver which enables the functionality of the Filter Driver Subsystem . These specific example are provided in order to clarify possible functional options and to demonstrate the flexibility and diversity of how the logical Packet Level Program may be implemented across User and Kernel Modes however one skilled in the art will readily recognize that example embodiments may be implemented in various other operating systems and devices and without other physical restrictions therein.

A Packet Level Program according to another example embodiment may reside as a physical manifestation for example as a chipset or embedded ROM on a router. Alternatively the Packet Level Program may exist or be executed in a particular region of an operating system for example in a Kernel Mode or a User Mode of the operating system. Furthermore as described below the Packet Level Program may exist across multiple operating system regions or the Packet Level Program may exist completely outside an operating system. Different operating systems have differing mechanisms for controlling access to resources and if the Packet Level Program exists at a particular level the Packet Level Program is configured to access required resources accordingly.

In one example of a division of resources the Packet Level Program may exist or be executed in a User Mode and a Kernel Mode of an operating system. The User Mode may be a region of the operating system where most Computer Applications are loaded and that provides relatively large amounts of memory disk space and other such resources. The Kernel Mode may be a region of the operating system that is significantly restricted on such resources as memory disk space etc. but runs much faster is more highly protected and includes low level programs e.g. drivers.

At least two reasons exits for presenting a Packet Level Program according to example embodiments across multiple operating system regions. First the Packet Level Program is a logical construct that may be physically comprised of numerous pieces of code applications drivers systems or other distributed or non distributed components are that required to support its main functionality. By presenting the Packet Level Program across the two regions a separation of possible physical implementations from the logical construct is highlighted. Second the Packet Level Program may require access to resources restricted to one region e.g. the Kernel Mode while requiring additional resources that are only available in another region e.g. the User Mode . For example in some operating systems the Kernel Mode provides direct access to communications directly prior to said communications leaving a given node and the Packet Level Program may be required to exist execute in the Kernel Mode in order to access the data at this point in the communication process.

The Kernel Mode however may place restrictions on an amount of maintainable memory and a level of access allowed from other regions e.g. the User Mode . If the Packet Level Program provides a communications virtualization capability as discussed above which may require more memory than is supported in the Kernel Mode a component of the Packet Level Program may be needed in the User Mode . Furthermore as discussed below additional applications may be layered on top of the Packet Level Program which may require more access to the Kernel Mode components of the Packet Level Program than is typically allowed. Accordingly a Packet Level Program according to example embodiments includes components in both the User Mode and the Kernel Mode of an operating system.

As shown in User Mode processes and Kernel Mode processes use a Shared Memory space to enable communications. The Shared Memory may comprise any resource that can be accessed by two discrete processes and includes for example Heap or Stack Memory I O or File Systems Binary or Text Service Calls shared data systems and managed memory access e.g. through a queue. Moreover the Shared Memory as a logical construct may exist or be instantiated within the same computer or the Shared Memory may be configured to enable communications across multiple computers. If the Shared Memory is configured to enable communications across multiple computers a User Mode process may be a logical construct wherein a range of nodes collectively provide additional resources and data to the Kernel Mode process.

As shown in a Memory Manager opens or accesses a specific address in Memory using a Pointer that is known to processes in both the Kernel Mode and the User Mode . In an example embodiment the Pointer is programmed directly into the Packet Level Program s processes. In alternative example embodiments external configuration files or communications from other nodes are utilized to synchronize the Pointer information between the Kernel Mode processes and the User Mode processes. Although shows the Kernel Mode process of the Project Level Program using the Pointer to first access the Shared Memory the Shared Memory may instead be first accessed by the User Mode process of the Project Level Program or exist or be executed independently of either mode and itself synchronize Pointers .

The Pointer may be a pointer in the well known classic sense i.e. a specialized operating system address of an object. Alternatively the Pointer may be a URI or the Pointer may contain complex information required for example to access a secured queue or web service. However Pointer need only provide sufficient information to locate a process e.g. the Shared Memory .

A Memory User may monitor the Memory using the Pointer . If the Pointer returns access to the Shared Memory the Memory User can maintain a connection to the Shared Memory . The Memory Manager may perform a similar monitoring process. This optional initialization and monitoring process as different types of shared communications may preclude this step is shown above the dotted line at the top of .

The section below the dotted line in shows how communications subsequent to any initialization occur between the Kernel Mode processes and the User Mode processes of the Packet Level Program . Data may be sent to and stored in the Shared Memory by one of the Kernel Mode processes and the User Mode processes and retrieved on the other end by the other of the Kernel Mode processes and the User Mode processes. The Data may be any resource that can be stored in memory and accessed by a process on the other end mode. The Data is not limited to text and or binary transmissions but may include for example instantiated objects as Pointers that can be sent to Shared Memory complex workflow instructions via shared data sets preconfigured instructions or some other trigger and communications meant for third parties.

For example in an example embodiment as shown in below a Daemon may use the Memory User to send Data that causes the Packet Level Program to verify connectivity to a target location e.g. a possible Intermediate Node . The Packet Level Program attempts to connect to the target location provided by the Daemon and sends back the results of the connection attempt to the Daemon . If the Daemon determines that the connectivity is insufficient according to an optional set of business rules or thresholds the Daemon sends the Data through the Memory User to the Memory Manager to cause the Packet Level Program to change its target Intermediate Node .

Example embodiments illustrated in do not require the use of an Intermediate Node . Furthermore the Packet Level Program is not restricted to sending Node Requests as communications may occur with a multitude of node options that include for example Cryption Nodes Partner Nodes and Packet Level Programs that exist on other logical nodes.

As shown in a Computer Application is used and or executed by an End User to request Node Data from the Central Nodes . It should be noted that the requested Node Data is not restricted to Node Data from the Central Nodes and can be requested from other nodes e.g. Cryption Nodes see or other instances of the Packet Level Program alternative example embodiments of which are described more fully in subsequent sections below.

The Computer Application enables the End User to select specific geographic locations e.g. at a country level a regional level and or a city level and obtain Node Data for nodes in the selected region. In response to the End User selection the Computer Application may send a request to the Central Nodes for Node Data for Intermediate Nodes specific to the region selected. It should be noted that the End User may choose to be within a specific region or the end user may choose to exclude a specific region and those selections in turn may be used to request the Node Information .

In further example embodiments additional information of Intermediate Nodes may be sent to the Central Nodes . For example an anonymity level provided by the Intermediate Node and the types modes and levels of communications supported by the Intermediate Node may be sent to the Central Nodes . Furthermore the criteria for selecting the Node Data may request only Intermediate Nodes that completely hide the Requesting Node s identifying information and that can support multimedia streaming and form submissions e.g. HTTP POST . A method for sending the criteria for selecting the Node Data and the actual criteria utilized may vary as will be recognized by one of skill in the art.

Other example embodiments may be configured to send the Node Data to the Computer Application independent of regional filters and the additional criteria may be used as upfront filters. The Computer Application may apply its own set of regional filters depending on End User selections.

Still other example embodiments may employ a combination of the above two approaches to enhance application responsiveness. For example an example embodiment may utilize additional filters and a country level filter to provide a large set of Node Data for an entire country to the Computer Application . In response to End user selections the Computer Application may additionally apply regional and or city level filters to the local set of Node Data . The Computer Application in any of these embodiments may utilize user friendly controls including for example dropdown lists to enable ease of geographic selection however example embodiments are not limited thereto. The Node Data is sent to the Packet Level Program via an optional Daemon .

The Daemon may represent a portion of the Packet Level Program that resides or is executed in the User Mode of the operating system employed by the End User . The Daemon which may be for example a service callable component e.g. a DLL or some other process may store all of the incoming Node Data in memory for faster access and monitor the traffic flowing through the Packet Level Program to monitor for Intermediate Node issues.

The Daemon may send its own independent requests through the Intermediate Node to verify connectivity. In other example embodiments the Daemon may monitor packets flowing through the Packet Level Program and based on optional sets of hard coded configurable and or dynamic business rules determine if a given Intermediate Node is not acting properly. For example the rules may be based around issues and thresholds set based thereon including for example total response time percent of packet loss cyclical request loops and other signs that communications through the Intermediate Node are not behaving as expected. Further example embodiments including the Daemon may monitor operating system events to trap for common communication issues. For example Internet Connectivity failures elicited by a web browser may by obtained by the Daemon and used to determine when to move to a new Intermediate Node for communications.

In an example embodiment the Daemon proactively causes the Packet Level Program to use different Intermediate Nodes for various types of communication and or changes the Intermediate Nodes to be used for communications by the Packet Level Program in response to connectivity issues or optional business rules and or thresholds. For example the Daemon may randomly change Nodes at periodic intervals to increase End User anonymity.

If a Daemon is not used or included the above described functionality associated with the Daemon may instead be included in the Packet Level Program or in the Computer Application . Such a simplified approach may be observed in stricter environments including for example mobile platforms wherein too many active parts can cause resource issues e.g. battery drain.

The Node Data transmitted from the Central Nodes to the Requesting Node may be encrypted so that the Node Data can be transmitted over standard transmission ports e.g. for HTTP this could be Port or without the Node Data being readable by an observer. To attempt to keep a user as anonymous as possible an example embodiment of the Packet Level Program may obtain secured transmission protection typically found in protocols including for example SSL by using a layered encryption approach as shown for example in . A layered encryption approach is based on the use of three types of encryption Shared Encryption User Encryption and Private Encryption .

The Shared Encryption process uses a Private Public key combination wherein the private key is shared between the Central Nodes and the Requesting Node . The same key combination is shared across all Nodes that interact with a particular Central Server . As a further option different Central Server components namely in distinct geographic regions use separate Shared Encryption keys for their sets of Requesting Nodes .

The User Level Encryption process creates a unique shared encryption key for each user. For example the unique shared encryption key is based on a combination of a given Requesting Node s Media Access Control MAC address and the date and time of the key s creation. The unique shared encryption key is shared between the Central Nodes and the Requesting Node .

The Private Encryption provides a private key that is not shared and is maintained only on the Central Nodes . The three encryption processes are randomly applied to various parts of messages flowing between the Central Nodes and the Requesting Nodes . To further obfuscate the use of such encryption the entire encrypted message may be Base 64 encoded to appear as plain text during transmission. The original message can be any combination of text and binary data and still work through this system.

Because the Packet Level Program may be hard wired onto a chipset or embedded in a ROM Read Only Memory the Node Data itself may be embedded within the packet Level Program and updated through more global options e.g. a ROM update or operating system patch.

A Packet Level Program according to example embodiments as described above with described respect to modifies packets to transform the packets in Content Request Messages and Node Response messages. In an example embodiment shown in additional features of a Packet Level Program according to example embodiments are illustrated in which the Packet Level Program may successfully modify any or all parts of transmission packages.

The actual data sent by a Node Request from the Packet Level Program through an Intermediate Node may still be intercepted and pieced together by certain monitoring agencies. Accordingly simply using an Intermediate Node may not be sufficient to provide complete protection online. There are optional technologies for example Virtual Private Tunnels that provide additional protection but the mere use of such technologies can draw unwanted attention to otherwise anonymous communications. A scrambling of messages therefore needs to look like normal traffic while providing the same higher level of security of technologies such as VPN.

As shown in a Plain View Encryption Process explained in more detail below may be used by the Packet Level Program at a Requesting Node to scramble an outbound Content Request . Within the scrambled message the original website URI and Port may be embedded in the outbound Content Request . The Content Request is transformed into a Node Request by the Packet Level Program however the URI for a given Cryption Node is used in place of the Target Content s website in the Node Request . The Node Request is sent through an Intermediate Node to the Cryption Node . The Cryption Node may be any Requesting Node set in any configuration including for example client server peer to peer and mainframe architectures. The Cryption Node may be a single process on a shared Node a single physical or virtual Node or a plurality combination thereof. The Cryption Node uses User Encryption Data to decrypt the contents of the Node Request . The Cryption Node may use the same Intermediate Node as was used to send the Node Request to the Cryption Node a new Intermediate Node or no Intermediate Node to obtain the Target Content from the intended destination by acting on behalf of a new Requesting Node or the original Requesting Node . For example online anonymity may be maximized if the Cryption Node acts as a new Requesting Node . On the other hand providing secured access to a corporate network as provided in other example embodiments may require the identifying information from the original Requesting Node .

If the Cryption Node acts on behalf of the Requesting Node the Cryption Node can utilize any or all parts of the incoming Node Request to generate its own Node Request or Content Request depending on the intended destination. The parts of the incoming Node Request utilized by the Cryption Node may include identifying information from the Requesting Node encrypted or decrypted pieces of data and or other aspects of the request sufficient for the intended recipient Node to be able to process the generated request.

The Cryption Node may also act as a Responding Node for the initial Intermediate Node . After the Cryption Node receives the Target Content the Cryption Node may use the User Encryption Data to scramble the data and the Cryption Node may send the Content Response back to the original Intermediate Node .

The original Intermediate Node in turn sends the Node Response back to the Packet Level Program at which the User Encryption Data is used to decrypt the Target Content . The Node Response may be transformed into a Content Response by the Packet Level Program prior to being sent to the Computer Application that initiated the request.

As shown in a Plain View Encryption Process according to example embodiments provides further details of scrambling techniques referred to in example embodiments described above with respect to . A premise of the Plain View Encryption Process is that each End User generates a unique User Encryption Data set that instructs the Packet Level Program and the Cryption Node on how to scramble and descramble inbound and outbound packages. It should be noted that the User Encryption Data is described with a simple text translation process for illustrative purposes only. In another example embodiment a combination of bit level transformations character replacement and binary image swapping techniques amongst other techniques may be utilized by the User Encryption Data .

The User Data Encryption set provides a target set of data characters in an example embodiment shown in along with the replacement values. In the scrambling process has been reduced to a target value such as http matched with a pipe separated replacement value such as CV . The various replacement options in this example are then joined together using tilde values however the one skilled in the art will recognize that replacement values are not limited thereto.

As can be seen in going down from Original Data through application of the User Encryption Data results in Modified Data . The Modified Data is meaningless but appears as normal traffic. Going up from the Modified Data through application of the User Encryption Data results in the Original Data .

The Encryption Driver may utilize an encryption algorithm that may be embedded directly into the driver obtained through an external process or through some combination thereof. For example the Encryption Driver may utilize a Public Private key encryption approach that is embedded directly in the driver. Key values of the encryption however may be configurable through a separate process for example a secured desktop application or a configuration file. The pluggable type of encryption may utilize Reflection or another similar discovery process to utilize independent processes including for example files services or calls to other such processes. For example the Encryption Driver may use Reflection to dynamically load a Dynamic Link Library DLL and utilize the methods found therein for encryption and or decryption processes.

In an example embodiment the Virtualization Driver receives Send Packets and sends the Send Packets to the Encryption Driver . The Encryption Driver encrypts the Send Packets and sends the encrypted packets back to the Virtualization Driver . The Virtualization Driver may reconfigure the encrypted Send Packets to utilize a specific Intermediate Node and send the packets to the Network Interface Card . In another example embodiment the Virtualization Driver may not modify the Send Packets but still perform the Communications Virtualization as described previously above.

In still another example embodiment the Virtualization Driver may not exist with the only driver in the Packet Level Program being the Encryption Driver . If the only driver is the Encryption Driver the Encryption Driver may only encrypt the main content of the individual packets while leaving the packet headers untouched or modified only as needed to support encryption size expansion. For example some encryption may increase the overall size and number of packets requiring additional packets to be created and inserted into the outgoing set of Send Packets .

In another example embodiment the Encryption Driver may receive the send packets before the Virtualization Driver and encrypt entire send packets without modification by the Virtualization Driver . In example embodiments in which the Encryption Driver encrypts the packets and the Virtualization Driver does not use an Intermediate Node regardless of where or how the Send Packets enter the Encryption Driver the Virtualization Driver may send packets to a preconfigured node for example another Packet Level Program or a Cryption Node . The preconfigured node may be defined statically result from an optional set of business rules or be based on communication path protocol or other dynamic measure.

An alternative example embodiment may utilize a verification process to enable a user to directly communicate with a Requesting Node on a Target Network . The verification process may be hardcoded into the End User s terminal or the verification process may be the result of an authentication and or authorization process for example a login process. If the Virtualized Applications exist on the End user s terminal the Virtualization Driver may send communications directly to the Requesting Node on the Target Network or send all communications through a Cryption Node . An alternative example embodiment may send a portion of the communications directly to the Requesting Node and others through the Cryption Node depending on various details including for example initialization monitoring and logging needs.

In other example embodiments in which an interface to a Requesting Node in a Target Network is provided to an End User the Virtualization Driver may not be present and the Encryption Driver may send the packets to their intended target. Alternatively the Virtualization Driver may not maintain virtualization data and only send packets to their intended destination.

Example embodiments may optimize communications by precluding encryption altogether or an example embodiment may use the Encryption Driver to compress outgoing content and or forgo encryption. Data compression may be defined as a variant of encryption and may include any process that alters any part or the total packet of communication. Accordingly an example embodiment may not utilize encryption but may instead compress communications to enhance speed. Other example embodiments may encrypt accordingly to rules that focus on the stage of communication e.g. initialization working or saving or the level of data being transmitted e.g. Public Secret or Top Secret .

Encryption by the Packet Level Program may occur in both communication directions occur in one communication direction or utilize a variable set of rules that are the same or different for each communication direction. In an example embodiment login credentials may be encrypted and sent out to a Cryption Node . The Cryption Node may decrypt the credentials because the Cryption Node resides within a Target Network . The Cryption Node may compress the resultant response and send the compressed response back to the End User but not encrypt the content of the compressed response.

In order to provide more secure communications various example embodiments may be combined together for example as illustrated in . is an overview of an encryption process combined with a Cryption Node to provide a range of secure communications according to an example embodiment. The dotted double headed arrows in represent a range of communications that may occur. An example embodiment may utilize the Encryption Driver to encrypt communications using one type of encryption in one communication direction and another type of encryption in another communication direction or the same type of encryption in both communication directions. Encryption may be varied by type of data Requesting Node Responding Node communication path protocol type and or direction or any combination thereof.

Protocol wrapping may be utilized and varied along the same lines. Accordingly the Packet Level Program may encrypt all communications and wrap all protocols to for example appear as normal HTTP traffic. An example embodiment may send the communications to a Cryption Node where the communications can be decrypted prior to being sent to a number of optional nodes. The communication may occur directly between Requesting Nodes and may or may not be decrypted on either end.

Communications going to a given node may be decrypted and or unwrapped. A Cryption Node for example may decrypt a given Node Request from a Requesting Node and act as a Requesting Node itself in obtaining Target Content . In an example embodiment the Cryption Node may encrypt any or all parts of the communication prior to sending the communication to another node. The encryption by the Cryption Node may occur on decrypted packets or on already encrypted packets thereby adding another layer of encryption.

Anonymity may thus be maintained by sending communications over a standard port and or by modifying packets of data in an unobtrusive manner. A further example embodiment may utilize a Cryption Node as an Intermediate Node to prevent unwanted observers from determining the intended target of a communication. For example the Requesting Node would be observed as communicating with the Cryption Node . Furthermore protocol wrapping may cause all communications to appear as simple web traffic. Various communications for example chatting and downloading thus appear as normal web traffic and optional encryption protects the communications even if an unwanted observer intercepts the traffic.

Each Secured Node may maintain a registry of URI values and Public Keys for other Secured Nodes in its network. Any Secured Nodes connected through End User actions may be added to the registry. Through the network of each Secured Node Secured Nodes securely manage synchronous keys.

A basic premise of a synchronous key architecture is that an Intermediate Node System for example as shown in may initiate at any time a Synchronous Key Update based on a triple encrypted key mechanism. The first layer of encryption may be a hardcoded asynchronous public key token that provides the new synchronous key as well as the old key value. The private key may be held only in Central Nodes and never be disseminated. Both old and new synchronous key values are needed in order to validate a key update. The next layer of encryption may encrypt the hardcoded key with the current synchronous key. The resultant value may be disseminated from a Central Node by encrypting the value with each local network registrant s public key. The updated key is sent to each Secured Node where the values are decrypted and used to update local key values. To aid in distribution lag times a 24 hour period of time may be maintained during which both synchronous keys are valid. Each Secured Node in turn may encrypt the original double encrypted value with each public key in its local network prior to sending the key on to other Secured Nodes . If a given update which contains the current old and new synchronous keys is received by a Secured Node the update may be ignored by the Secured Node and not further disseminated.

If a new Secured Node comes online the new Secured Node may use its Private Key to send out encrypted update requests to all Secured Nodes in its registry. If the system is new it may receive updated synchronous keys after it has registered its local network.

A Secured Node in one location may connect to a Secured Node in another location. For such a connection to occur the following steps may be followed 

When a Secured Node initializes the Secured Node may register with its local network. The registration process may include sending a query on a specific port that is being monitored by other Secured Nodes .

Once registered the End User may attempt to communicate with another End User by either entering a target IP address or a target username among other possible values.

Once the target Secured Node receives a request its End User is notified and can either accept or decline the connection request.

For an accept the target Secured Node may generate a synchronous Session Key which the target Secured Node combines with its URI and encrypts with its Private User Level Asynchronous Key and the target Secured Node encrypts its Public Key with the source system s Public Key and sends the encrypted URI and Public Key back.

Additional Secured Nodes can be added to the current session using the same process found in the response from the target Secured Node

Corporate connections involving Secured Nodes work as described in Example 1.1 in that dynamic discovery and registration may be used. Enterprises may want to control the Secured Nodes allowed to interact with a given Target Network . An enterprise may control the Secured Nodes by for example either controlling the encryption or by managing the data sources. In some example embodiments using encryption if the Packet Privacy System cannot decrypt incoming traffic the Packet Privacy System may ignore the encrypted traffic. Thus changing the encryption at the enterprise level may automatically create dynamic corporate nodes amongst specific Secured Nodes .

Another example embodiment may utilize a level of control involving disabling discovery and relying instead on centrally managed data sources. Using a mechanism similar to the Synchronous Key management approach Managed Networks may be disseminated from one location however the transmissions may not be sent out by the recipients. The same process may be used for the Synchronous Key updating in which transmissions from the central systems may not be retransmitted by the recipients.

This system however may go one step further in that the creation of installation packages in the Managed Networks environment may send out a Synchronous Key encrypted registration message only to the Central Nodes and Secured Node . Only that Secured Node will add the registration entries and it is up to that Secured Node to add the new system to its local data source. On the Central Nodes a desktop application may be provided that allows an authorized End User to send out Synchronous Key updates to different sets of Secured Nodes and to managed different levels of local data according to enterprise security demands.

Whenever a given local data store is updated the affected Secured Node may be sent an update via a queued response as described previously. However instead of neighbor querying update queries be sent only to the Central Nodes .

To enable these communications the Managed Networks system may provide a variable number of synchronous keys to enable multiple levels of communication. Thus an administrator may provide a general use synchronous key to all users a management level key for management and an executive key for only the top level systems thereby providing a secure mechanism wherein a given system can utilize varying levels of security based on an End User selection. Additional incoming requests can be identified by the synchronous key being utilized.

Examples 1.1 and 1.2 describe the utilization of point to point communication paths between Secured Nodes . The present example builds on top of those scenarios to provide a Cryption Node based portal into a given Target Network . Many VPN solutions in the current market offer to level of functionality in which a user accesses a dedicated server to gain network entry. In conventional options the VPN server maintains a virtual user instance and remotely sends local data back to the end user. These conventional options are very resource intensive and thus require significant hardware resources.

Example embodiments provide a superior option by redirecting remote queries through a secured interface between nodes i.e. a Cryption Node . To the enterprise network the communications appear local and to the End User s Applications the communications appear as if the Applications are residing within the target network. To enable these features the Packet Level Program may utilize a port forwarding parallel processing approach wherein each incoming user is offloaded to a lightweight protocol processing instance. Unlike the heavier VPN user instances these optional instances are merely encrypting and decrypting traffic to and from the network. Each instance handles the Communication Virtualization locally for the network just as the client system is handling the communications locally on the Secured Node . Transmissions between the two endpoints may be encrypted as previously described.

Example embodiments may unwind packets and for non HTTP traffic embed the packets into HTTP based TCP output. In this manner the fundamental packets of information can be deconstructed into a generic stream and re packaged into a new series of generic protocol packets such as TCP or UDP. Inserted into the front of the stream can be packets of data one possible example being a TCP header packet that provides details on the original communication protocol. Once the protocol layer has been created the upper level for example IP and HTTP layers can be constructed based on the new stream. Thus all information sent from the Packet Level Program appears as standard HTTP traffic. The traffic sent from the Packet Level Program may be passed through an Encryption Driver to enable the encryption protection. Processing of the traffic after encryption is described in the following examples below.

Communications from one Secured Node may be sent directly to another Secured Node in an example embodiment. The encrypted communications may be sent directly to the second Secured Node where a Packet level Program decrypts the traffic unwinds the wrapped protocol and restores the packets back to their original state. Other example embodiments may utilize Intermediate Nodes or Cryption Node configured to optionally decrypt change encryption or leave the communication unmodified. The communications are sent to the Computer Applications for processing. An example of this type of communication is torrent downloading or chat communications.

The first two sets of embodiments in this Examples section do not require Cryption Servers to work properly but they do require Secured Nodes on both ends of the communication path. Other example embodiments may utilize Cryption Servers or the same decrypting unwrapping processes as is found in previous examples described above.

An example embodiment using Cryption Servers may process all requests in a parallel manner. An example embodiment may utilize a User Mode application built to handle the parallel processing such that the underlying driver systems are run in a serial fashion. Thus the drivers handle capturing traffic and forwarding the traffic to a higher level application that unwinds the TCP decrypts the content and reverts the content back to its original format. The User Mode application handles in parallel submitting the content to its intended destination using the original protocol and handles receiving the results and packaging the results therein.

Thus while there have been shown and described and pointed out fundamental novel features of the present invention as applied to preferred embodiments and examples thereof it will be understood that various omissions and substitutions and changes in the form and details of the devices described and illustrated and in their operation and of the methods described may be made by those skilled in the art without departing from the spirit of the present invention. For example it is expressly intended that all combinations of those elements and or method steps which perform substantially the same function in substantially the same way to achieve the same results are within the scope of the invention. Substitutions of elements from one described embodiment or example to another are also fully intended and contemplated. It is the intention therefore to be limited only as indicated by the scope of the claims appended hereto.

