---

title: Computer code transformations to create synthetic global scopes
abstract: Methods and systems for processing computer code modules in order to avoid polluting the global namespace. According to one embodiment, the system or method comprises a server that receives a request for an additional computer code module to be added to the namespace. Prior to delivering the module, the server processes the module by identifying all references to global symbols that are not to be explicitly exported to a global scope and moving the identified symbols to a synthetic namespace prior. The server further wraps the processed module in a function that receives the synthetic global scope as a parameter, and delivers the wrapped module to the requesting namespace.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09015682&OS=09015682&RS=09015682
owner: Google Inc.
number: 09015682
owner_city: Mountain View
owner_country: US
publication_date: 20120328
---
The present specification relates generally to transforming computer code and more particularly to computer code transformations that facilitate incremental loading of modules from a module set without polluting the global namespace.

To assist in the efficient operation of a complex program a technique referred to as lazy loading is used. Lazy loading defers initialization of an object until the point at which it is needed. Another aspect of computer programming that requires consistency for the effective deployment of a program is that of a namespace. A namespace sometimes also called a name scope is an abstract container or environment created to hold a logical grouping of unique identifiers or symbols i.e. names . An identifier defined in a namespace is associated only with that namespace.

One aspect of lazy loading and minification is that all namespaced identifiers are flattened to reside in a single namespace. Therefore when using a lazy loading technique the namespace must be the global namespace in order to be accessible across individually loaded modules.

When code resides on many web pages on the Internet the risks of namespace collision is heightened. In addition as developers release future versions of a program that add one or more identifiers would potentially create other unexpected problems. Polluting the global namespace can further lead to hard to debug errors.

It is therefore a principal object and advantage of the present invention to provide a tool system and method that transforms code to permit lazy loading of modules with shared dependencies between them with consistent minification.

It is another object of the present invention to reduce global namespace pollution and prevent namespace collisions.

It is a further object and advantage of the present invention to provide a tool system and method that permits determination of the exact time when newly loaded code is evaluated thereby enabling parallel non redundant loading when users request multiple features in short order.

Other objects and advantages of the present invention will in part be obvious and in part appear hereinafter.

In accordance with the foregoing objects and advantages the present invention provides a system tool and method for transforming code such as JavaScript to facilitate incremental loading of modules from a module set without polluting the global namespace through the creation of synthetic global scopes. An embodiment of the present invention creates an automated transformation of JavaScript code that moves all global symbols that are not explicitly exported to a synthetic global scope. In so doing the embodiment of the present invention traverses an abstract syntax tree of a given JavaScript program and replaces every reference to a global symbol to be a property access of the name of the synthetic global scope object. An embodiment of the present invention identifies and distinguishes explicit references from implicit reference by traversing the abstract syntax tree and rewriting all references that are not default exports in the global object i.e. WINDOW in JavaScript to be property lookups on a synthetic scope object. The JavaScript payload is then wrapped in functions that receive the synthetic scope as a parameter argument and then passes that to a callback. Therefore all payloads will have access to the same synthetic scope and no symbols are involuntarily leaked into the global scope of a host page.

Embodiments of the present invention comprise systems and methods for processing a computer code payload. According to one embodiment a method comprises the steps of i receiving a request for a computer code payload ii obtaining the requested computer code payload which has a plurality of global symbols iii identifying which of the plurality of global symbols are not designated to be explicitly exported to a global scope iv moving all identified global symbols to a synthetic global scope v wrapping the processed computer code payload in a function that receives the synthetic global scope as a parameter and vi delivering the wrapped payload.

Yet another embodiment comprises a method for processing a JavaScript module at a module server comprising the steps of i receiving at a module server a request for a JavaScript module ii obtaining the requested JavaScript module at the module server where the JavaScript module has a plurality of global symbols iii identifying which of the plurality of global symbols are not designated to be explicitly exported to a global scope iv replacing each reference to an identified global symbol to be a property access of the synthetic global scope object v recompiling the JavaScript module vi wrapping the processed JavaScript module in a function that receives the synthetic global scope as a parameter and vii delivering the wrapped JavaScript module.

In another implementation a non transitory computer readable storage medium containing program code for receiving a request for a computer code payload program code for obtaining the requested computer code payload where the computer code payload has a plurality of global symbols program code for identifying which of the plurality of global symbols are not designated to be explicitly exported to a global scope program code for moving all identified global symbols to a synthetic global scope program code for wrapping the processed computer code payload in a function that receives the synthetic global scope as a parameter and program code for delivering the wrapped payload.

A further embodiment comprises a system for processing a computer code module by a computer processor the system comprising i a computer network ii a computerized device connected to the computer network and comprising a global namespace ii a computer processor connected to the computer network and the global namespace. The computer processor delivers to the global namespace a requested module which in turn comprises one or more global symbols. The computer processor processes the requested module prior to delivery to the global namespace by identifying which of the one or more global symbols are not designated to be explicitly exported moving each identified global symbol to a synthetic global scope and wrapping the modified module in a function that receives the synthetic global scope as a parameter.

Referring now to the drawings wherein like reference numerals refer to like parts throughout there is seen in configurations of loading incrementally and all at once code payloads according to various methods previously known in the art. In an application programming interface API is exported and delivers a payload that is contained within a private namespace. In this configuration all objects in the program payload will be initialized at one time when the API is exported but is done within a private network such that the payload will not become publically accessible.

In the configuration of two APIs are exported at different times such as when they are needed thereby delaying the initialization of the objects in the accompanying payloads that each reside in the global namespace. However in this configuration as compared to the one show in the payloads are publically accessible on the third party computers that have requested their delivery.

In the configuration of two APIs are first exported internally to a marshalling layer that is internal but still provides APIs that are accessible by third parties to deliver payloads but will remain private due to the use of a traditional linker program thereby minimizing some of the payload s footprint.

According to one embodiment a client device comprising a browser with a loaded web page running one or more JavaScript modules requests an additional JavaScript module from the module server that is in communication with the client device and browser via a network such as the Internet. A loaded and executing JavaScript module for example tells the module server that it needs the code for executing a specific action prompted by a user event.

At step a server side component such as a module server gathers the requested module the payload from memory receives it from another device or server or otherwise obtains the module from a source. Once the payload is obtained it can be processed at step of the method. At this step the payload is analyzed using any of a number of methods well known in the art to identify all the global symbols or variables present in the code. Global symbols can be any symbol or variable that is meant to exist outside the specific payload thus being accessible by other modules in the overall system. When a module such as a JavaScript module is loaded into a system such that it will or might interact with other modules in that system it can both export and import any variables that it designates and or variables that the other modules functions already extant in the system designate as being globally accessible. Since they are accessible by each module in the system these exported and imported variables are termed global symbols in comparison with local symbols which are only found and used inside a single module. Local variables live and die with the function in which they are incorporated. While global variables are not used excessively because they can cause conflicts between modules in a namespace for example module A exports global variable X to the global namespace and module B is then loaded into the same global namespace and exports a second global variable X thereby polluting the global namespace they can be an important aspect of a program. Indeed global variables are often created as a result of namespace flattening during minification which can turn all previously namespaced symbols into global symbols.

Once the possible global variables in the payload are identified they are categorized at step of the method into at least two different categories i global variables that are explicitly exported by the module and ii global variables that are not explicitly exported by the module. Note that this categorization may be an action such as creating two lists in memory rather than any physical segregation among many other methods of categorization.

The global variables that are explicitly exported by the module can be exported processed renamed or otherwise handled following any one of a number of known methods in the art. For example the explicitly exported global variables can simply be exported without any further processing which may significantly increase the possibility of namespace pollution . In another embodiment the explicitly exported global variables are all renamed to avoid conflicts between the global symbols and other code in first and third party sites. While this prevents many conflict scenarios the need to keep the prefix short to save bytes and reducing network transmission time opens up the change for future collisions.

At step of the method all global symbols that are not explicitly exported are moved to a synthetic global scope and at step the module is recompiled. To accomplish this step the system can for example traverse an abstract syntax tree AST of the program and replace every reference to a global symbol that is not to be explicitly exported to be a property access of the name of the synthetic global scope object although there are several other methods of replacing references known in the art. For example 

At step of the method the processed payload can be wrapped in a function that receives the synthetic scope as a parameter using any of a number of methods. As just one example code that originally reads as follows prior to being processed according to one embodiment of the present method 

All payloads in the system processed by the method described herein will therefore have access to the same synthetic scope and the symbols exported thereto and no symbols will be involuntarily leaked into the existing global scope of the system. In other words the scope object global1 in the above example will be shared between individually loaded modules thus providing the desired access to dependencies in previously loaded modules. Since the scope object is not referred to be name e.g. it only has to be lexically visible to the Xape loaded function as in the example above and thus does not leak into user space.

Finally at step of the method the processed payload is delivered to the requestor using any one of a number of known methods and systems in the art.

As an additional step in the process and using methods known in the art the transforming program or another program or module can also perform code minification. Often JavaScript minification with property collapsing tries to move all symbols into one scope level. In order for different payloads to access that scope level especially in the context of deferred loading the scope is by necessity the global scope which results in numerous symbols spilling into the global scope. This can create issues if multiple modules reside in the same namespace especially if the namespace is a web page containing any number of other modules from any number of third parties. Using the methods and systems of the present invention however code minification can be accomplished without moving all symbols into a single scope level and therefore without polluting the scope level. For example the global variable can be minified to only 1 byte thereby saving 1 byte per variable use against current methods which is using a prefix on every global identifier in order to prevent collisions and pollution of the namespace.

According to another embodiment of the method the module server can be extended to accept a callback parameter such as the following 

An additional option that could be incorporated into the transforming program is to call the callback with more parameters in order to support dual inclusion scenarios where different versions of the same module could reside together in a global namespace. For example 

In addition known global variables could also be passed to the code callback thereby enabling cross friendly frames sometimes called same origin frames reuse of the same JavaScript code For example 

Initially global namespace comprises the three modules and . An additional module is then requested by the system possibly in response to an automated feature or some user action. The system sends the request to a module server requesting the module and the module server performs one or more of the following steps of the method described herein to process the payload including but not limited to i gathering retrieving or receiving the requested payload at or by the module server ii processing the payload to identify all global symbols iii categorizing all the global symbols iv moving to a synthetic global scope all global symbols that are not explicitly exported and v wrapping the processed payload in a function that receives the synthetic scope as a parameter. The processed payload can then be delivered to the requesting system using any one of a number of known methods and systems in the art.

For example the system in has requested and received two additional modules Payload and Payload which exist inside the synthetic global namespace . Both Payload and Payload have access to the global variables defined inside synthetic global namespace as well as the global variables defined inside global namespace . An actual global namespace or synthetic global namespace can have more modules than are shown in and there can further be more synthetic global namespaces inside global namespace .

As shown in which uses one or more of the methods described or suggested herein the APIs can be exported incrementally and the payloads that are delivered upon request will be inside the synthetic scope instead of the global scope.

In a client side loader incrementally loads code payloads in a synthetic namespace using one or more of the methods suggested or described herein. The client side loader injects the same synthetic namespace into each module requested and incrementally loaded into the system.

By way of example user device can comprise a software or program component such as a web browser . Browser is designed to enable user to access retrieve and view resources and documents including resources and documents found on the Internet or an Intranet among other sources. For example the browser can be designed for viewing an Intranet within an organization or any other connection of local computers.

System may also comprise only user device and a software or program component. In this system the software or program component which is the web browser in the embodiment described above is designed for viewing locally stored files. In this embodiment system and the methods described herein are used to manage the local database without a network connection or without accessing an available network connection.

According to one embodiment of the invention the browser loads a web page or program via communication with server over network . In response to an action by user or an action or inquiry initiated by some other component of system the browser requests an additional module from module server via communication over network . Module server processes the requested module using any of the methods described or envisioned herein and sends it to user device and the browser via the network.

Although the present invention has been described in connection with a preferred embodiment it should be understood that modifications alterations and additions can be made to the invention without departing from the scope of the invention as defined by the claims.

