---

title: System and method for intelligently selecting a network interface
abstract: An method, apparatus and machine readable medium are described for intelligently selecting a network interface. An attempt may be made to connect over a first network interface having the highest priority (e.g., WiFi). At the same time, a fallback timer is started. If the attempt to connect over the first network interface does not succeed within a designated timer threshold, then a parallel attempt is made to connect over a second network interface having a lower priority (e.g., cellular). The first network interface over which a connection is successfully made is then used. These techniques may be employed on a per-connection basis. Thus, a first process may successfully connect over the first network interface while a second process may be unsuccessful over the first network interface but may fall back to the second network interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09439234&OS=09439234&RS=09439234
owner: Apple Inc.
number: 09439234
owner_city: Cupertino
owner_country: US
publication_date: 20121219
---
The subject matter described herein relates generally to the field of data processing systems. More particularly the subject matter described herein relates to the intelligent selection of network interfaces for communication.

Current wireless data processing devices are capable of connecting to network services through multiple different communication interfaces including Wifi interfaces e.g. 802.11 interfaces and cellular data interfaces e.g. GPRS G3 G4 interfaces . for example illustrates a wireless client with a Wifi interface for connecting to a network service over a Wifi network and a cellular interface for connecting to a push notification service over the cellular network .

Described below are apparatus methods and machine readable media for intelligently selecting a network interface. Throughout the description for the purposes of explanation numerous specific details are set forth. It will be apparent however to one skilled in the art that the subject matter described herein may be practiced without some of these specific details. In other instances well known structures and devices are not shown or are shown in a block diagram form to avoid obscuring the underlying principles of the described subject matter.

A mobile device is described below such as a tablet computing device e.g. an iPad a smartphone e.g. a iPhone or a mobile computer e.g. a MacBook Pro . It should be noted that the underlying techniques described herein may be implemented on any type of mobile computing device.

Using the techniques described herein a mobile device that is associated to a WiFi network and has access to a cellular data connection will attempt to fall back to the cellular data connection for any connection attempts that do not work over WiFi. For example WiFi networks typically utilize a firewall which may block access to certain services or applications executed on the mobile device. In other cases the WiFi network may not be attached to the Internet e.g. because the user s cable modem or DSL connection stopped working .

A wireless client may attempt a connection over a cellular network interface after waiting a reasonable amount of time for a connection over the WiFi network interface to succeed. As illustrated in a wireless client may include connection logic for implementing the techniques described herein to select between a Wifi interface and a cellular interface and establish a connection with a particular network service . As illustrated the WiFi interface may connect the wireless client over a Wifi network and the cellular interface may connect the wireless client over a cellular network . For cellular connections various technologies may be employed including but not limited to 3rd Generation Partnership Project technologies e.g. 3GPP2 code division multiple access technologies e.g. CDMA2000 technology using 1 RTT EVDO eHRPD Long Term Evolution LTE technology and or LTE Advanced LTE A technology and Universal Mobile Telecommunications System UMTS technology such as WCDMA TDSCDMA.

The connection logic includes connection prioritization logic for prioritizing the network interfaces and a fallback timer for timing connection attempts. In response to a network request by one of the processes the connection logic attempts to connect to the designated service or over the highest priority network interface which is available e.g. the WiFi interface . The fallback timer begins timing the connection attempt. If a connection is not successfully established via the highest priority network interface after a specified period of time e.g. 5 seconds then the connection logic initiates a parallel connection attempt over the next highest priority network interface e.g. the cellular interface . The connection logic may then use the first connection which is successfully established over one of the interfaces .

The techniques described herein may be implemented on a per connection basis. For example one process may successfully connect to a service over WiFi whereas another process may be unable to connect over WiFi but may successfully connect over cellular using the techniques described herein. The failure to connect over WiFi may be related to the manner in which the WiFi firewall is configured. For example the firewall may be configured to block certain types of traffic e.g. streaming video from certain network sources . The processes may be any form of executable program code capable of requesting and maintaining a network connection e.g. network processes within Apps Applications background tasks or other forms of program code .

The fallback timer may dynamically adjust the timer threshold for a second connection attempt based on current conditions. For example the fallback timer may initially set a slow timer value e.g. 5 seconds . If the connection over the highest priority network interface e.g. WiFi is unsuccessful and the connection logic is able to successfully fall back to the next highest priority network interface e.g. cellular then the fallback timer may adjust to a fast timer value to be used the next time a connection over the highest priority network interface is attempted. The same timer values may be established and used across processes services. The timer values may also be set on a per process interface or per service interface basis.

The connection logic may balance the need to try any method of establishing a connection against the power and money costs of using some or all network interfaces . Certain types of connections certain processes and or certain services may be designated as ineligible for fallback e.g. fallback from WiFi to cellular been disabled for these connections processes or services . A user may also be provided with the ability to configure the connection logic to prevent connections by certain processes services over certain network interfaces. For example the user may specify that any processes which perform media streaming are not to be used over the cellular interface e.g. to reduce cellular data costs and or reduce power . In addition certain processes may be pre configured to only utilize certain interfaces .

A given process may be eligible for fallback to cellular unless certain specified conditions are met for example 1 fallback has not been disabled 2 the connection would go out over WiFi 3 the connection won t be routed over a VPN 4 the client didn t opt out of fallback as with certain known processes such as mediaserverd 5 the client didn t bind to a specific interface 6 the client didn t specify a no cellular option and 7 cellular is available. If all of these conditions are met the fallback timer may be started at the same time the connection attempt is started over WiFi. If the connection attempt over WiFi does not succeed or fail within the designed timer period a parallel connection attempt is started over cellular. At that point whichever connection attempt completes first wins and the other attempt is cancelled.

The fast timer value may be tuned based on the measured Round Trip Time RTT over WiFi and the RTT over cellular. The goal is to make sure the RTT over WiFi is always some amount of time e.g. 50 milliseconds less than the RTT over cellular the fast fallback timer. Given the fact that cellular typically has a much longer round trip time the fast fallback timer may be 0 meaning that both WiFi and cellular will be attempted simultaneously with the fast timer value.

As mentioned if a fallback connection succeeds before the original attempt over WiFi a switch may be made to the fast timer if it wasn t already being used. If an original attempt over WiFi succeeds the connection logic may switch back to the slow timer value if it wasn t already being used. The fast slow timer state may be stored on a per process basis i.e. each process has either a fast or slow timer value associated therewith .

In some instances the above techniques may have the benefit of improving the user experience because if the WiFi network is not providing internet connectivity a process may experience an approximate 5 second delay for the first connection attempt using the slow timer but all subsequent connection attempts would be just about as fast as cellular using the fast timer . WiFi may always be given the first opportunity to connect assuming that a WiFi connection is feasible .

Once a transmission control protocol TCP connection is established it may in some instances not switch back to a different interface. One reason for this is that in many TCP implementations a TCP connection cannot migrate from one interface to another i.e. because TCP connections are bound by the source and destination IP addresses and ports . Subsequent connections may still fall back on a per connection basis. Thus anything that works over WiFi will tend to use WiFi and anything else will use cellular.

The cellular data connection may only be used when the device has access to cellular data. When in a roaming condition and or if the user has disabled cellular data roaming or when in AirPlane mode or if the user disabled cellular data cellular fallback will be disabled.

A method for falling back to a network interface is illustrated in . At an attempt is made to establish a network connection over a first network interface e.g. WiFi . As discussed above the network interfaces may be prioritized and the first network interface is the highest priority of the available network interfaces. The fallback timer is started at and at a determination is made as to whether a connection over the first network interface has been established within the designated fallback timer period. If so then at the connection is maintained over the first network interface and at the fallback timer is set or maintained at the slow timer value e.g. 5 seconds .

If a connection over the first network interface has not been established within the designated fallback timer period then at a parallel attempt is made to connect over the second network interface e.g. cellular . At a determination is made as to whether a connection has been successfully established over the first or second network interfaces. If the first then the connection is maintained over the first network interface at and at the fallback timer is set or maintained at the slow timer value. If however a connection is first established over the second network interface then at the connection over the second network interface is maintained and at the fallback timer is set or maintained at the fast timer value.

While not shown in the wireless client device may attempt to fall back to a third network interface if a connection over the first and second network interfaces is unsuccessful. For example if both the first and second interfaces fail to establish a connection after another specified timer value then a parallel attempt may be made over a third network interface. The number of connection attempts is limited only by the number of interfaces available on the wireless client device. Thus the connection logic may iterate through each network interface until a connection is successful.

The mobile device may determine whether it is connected to a host that simply redirects its connection attempt to a different location e.g. in the case of HTTP redirection . Some networks sometimes referred to as captive portals do not permit connections on the network until the user authenticates or accepts terms. These networks will intercept an HTTP connection attempt and redirect it to a special Web page containing the authentication portal or terms. The cellular fallback techniques described above may be used for cases where a connection attempt is redirected to a portal. For example upon detecting the redirection the mobile device will initiate a connection over the cellular interface. Said another way the definition of a successful connection is determined by the ability to access the desired resource not just establish a network connection.

While certain techniques are described above within the context of two specific communication channels Wifi and cellular the underlying principles are not limited to any particular type of communication channel. For example the techniques described herein may be employed on any client device with multiple communication interfaces capable of connecting over multiple different types of communication channels. For example these techniques may be implemented to connect over a first communication interface and then fall back to a second communication interface if the connection over the first interface is unsuccessful after a period of time.

Different application programming interfaces APIs may be implemented by a software component hereinafter API implementing software component that allows a different software component hereinafter API calling software component to access and use one or more functions methods procedures data structures and or other services provided by the API implementing software component. For example an API allows a developer of an API calling software component which may be a third party developer to leverage specified features provided by an API implementing software component. There may be one API calling software component or there may be more than one such software component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from a software application. An API can be specified in terms of a programming language that can be interpretative or compiled when an application is built rather than an explicit low level description of how data is laid out in memory.

The API defines the language and parameters that API calling software components use when accessing and using specified features of the API implementing software component. For example an API calling software component accesses the specified features of the API implementing software component through one or more API calls sometimes referred to as function or method calls exposed by the API. The API implementing software component may return a value through the API in response to an API call from an API calling software component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API typically does not reveal how the API call accomplishes the function specified by the API call. Various function calls or messages are transferred via the one or more application programming interfaces between the calling software API calling software component and an API implementing software component. Transferring the function calls or messages may include issuing initiating invoking calling receiving returning or responding to the function calls or messages. Hence an API calling software component can transfer a call and an API implementing software component can transfer a call.

By way of example the API implementing software component and the API calling software component may be an operating system a library a device driver an API an application program or other software module it should be understood that the API implementing software component and the API calling software component may be the same or different type of software module from each other . The API calling software component may be a local software component i.e. on the same data processing system as the API implementing software component or a remote software component i.e. on a different data processing system as the API implementing software component that communicates with the API implementing software component through the API over a network. It should be understood that an API implementing software component may also act as an API calling software component i.e. it may make API calls to an API exposed by a different API implementing software component and an API calling software component may also act as an API implementing software component by implementing an API that is exposed to a different API calling software component.

The API may allow multiple API calling software components written in different programming languages to communicate with the API implementing software component thus the API may include features for translating calls and returns between the API implementing software component and the API calling software component however the API may be implemented in terms of a specific programming language.

It will be appreciated that the API implementing software component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling software component . It should be understood that the API calling software component may be on the same system as the API implementing software component or may be located remotely and accesses the API implementing software component using the API over a network. While illustrates a single API calling software component interacting with the API it should be understood that other API calling software components which may be written in different languages or the same language than the API calling software component may use the API .

The API implementing software component the API and the API calling software component may be stored in a machine readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack applications can make calls to Services 1 or 2 using several Service APIs and to Operating System OS using several OS APIs. Services 1 and 2 can make calls to OS using several OS APIs.

Note that the Service 2 has two APIs one of which Service 2 API 1 receives calls from and returns values to Application 1 and the other Service 2 API 2 receives calls from and returns values to Application 2. Service 1 which can be for example a software library makes calls to and receives returned values from OS API 1 and Service 2 which can be for example a software library makes calls to and receives returned values from both OS API 1 and OS API 2. Application 2 makes calls to and receives returned values from OS API 2.

As illustrated in the computer system which is a form of a data processing system includes the bus es which is coupled with the processing system power supply memory and the nonvolatile memory e.g. a hard drive flash memory Phase Change Memory PCM etc. . The bus es may be connected to each other through various bridges controllers and or adapters as is well known in the art. The processing system may retrieve instruction s from the memory and or the nonvolatile memory and execute the instructions to perform operations as described above. The bus interconnects the above components together and also interconnects those components to the optional dock the display controller display device Input Output devices e.g. an Ethernet Network Interface a cursor control e.g. mouse touchscreen touchpad etc. a keyboard etc. and wireless interface s e.g. Bluetooth WiFi cellular infrared etc. .

The exemplary architecture of the data processing system may used for the mobile devices described above. The data processing system includes the processing system which may include one or more microprocessors and or a system on an integrated circuit. The processing system is coupled with a memory a power supply which includes one or more batteries an audio input output a display controller and display device optional input output input device s and wireless interface s e.g. such as the WiFi and cellular interfaces discussed above . It will be appreciated that additional components not shown in may also be a part of the data processing system and that fewer components than shown in may be used. In addition it will be appreciated that one or more buses not shown in may be used to interconnect the various components as is well known in the art.

The memory may store data and or programs for execution by the data processing system . The audio input output may include a microphone and or a speaker to for example play music and or provide telephony functionality through the speaker and microphone. The display controller and display device may include a graphical user interface GUI . The wireless e.g. RF interfaces which may include e.g. wireless transceivers and or baseband processing components for communicating data using WiFi technology infrared technology Bluetooth technology wireless cellular telephony technology and or other types of technology may be used to communicate with other data processing systems. The one or more input devices allow a user to provide input to the system. These input devices may be a keypad keyboard touch panel multi touch panel etc. The optional other input output may be a connector for a dock.

The features described herein may be implemented according to the various steps as set forth above. The steps may be embodied in machine executable instructions which cause a general purpose or special purpose processor to perform certain steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

The features described herein may also be implemented as a machine readable medium for storing the machine executable program code. The machine readable medium may include but is not limited to floppy diskettes optical disks CD ROMs and magneto optical disks ROMs RAMs EPROMs EEPROMs magnetic or optical cards or other type of media machine readable medium suitable for storing electronic program code.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example it will be readily apparent to those of skill in the art that the functional modules and methods described herein may be implemented as software hardware or any combination thereof. Moreover although some embodiments of the invention are described herein within the context of a mobile computing environment the underlying principles of the invention are not limited to a mobile computing implementation. Virtually any type of client or peer data processing devices may be used in some embodiments including for example desktop or workstation computers. Accordingly the scope and spirit of the invention should be judged in terms of the claims which follow.

