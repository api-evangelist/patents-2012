---

title: System and method for providing a dynamic invocation and service interface for use in a middleware or other environment
abstract: A system and method for providing a dynamic invocation and service interface for use in a middleware or other environment. At the service-side, messages can be inserted into an inbound processing chain. After service-side inbound processing, messages are given to the user via a provider request function. The user gives a response by using a provider response function that inserts messages into a service-side outbound processing chain. After service-side outbound processing, messages are given to the user's service response transport. On the client side, the user can insert messages into the outbound processing chain using a dispatcher request. After client-side outbound processing, messages are given to the user's client request transport. This decouples message processing from the transport and makes the message processing asynchronous in nature. When the response is received, a user uses a client response transport function to insert the response into the client-side inbound processing chain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09189304&OS=09189304&RS=09189304
owner: ORACLE INTERNATIONAL CORPORATION
number: 09189304
owner_city: Redwood Shores
owner_country: US
publication_date: 20120322
---
This application claims the benefit of priority to U.S. Provisional Patent Application No. 61 533 068 titled SYSTEM AND METHOD FOR PROVIDING A DYNAMIC INVOCATION AND SERVICE INTERFACE FOR USE IN A MIDDLEWARE OR OTHER ENVIRONMENT filed Sep. 9 2011 which application is herein incorporated by reference.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention is generally related to computer systems and software such as middleware and is particularly related to systems and methods for providing a dynamic invocation and service interface DISI for use in a middleware or other environment.

Generally a web service is a software system that supports machine to machine interaction over a network. A web service protocol stack is a stack of networking and other protocols that can be used to define locate implement and enable services to interact with one other. Examples of such protocols include the Simple Object Access Protocol SOAP which specifies the exchange of structured information for use with web services and which relies on Extensible Markup Language XML for a message format and on other protocols e.g. Hypertext Transfer Protocol HTTP or Simple Mail Transfer Protocol SMTP for message transmission. Commonly each web service has an interface described in a machine understandable format such as the Web Services Description Language WSDL . Other systems can use SOAP messages to interact with the web service interface in a manner prescribed by its description.

Other types of protocol stacks can similarly include some processing of message information wherein the messages are themselves encoded in some fashion e.g. the Common Object Request Broker Architecture CORBA stack.

In the context of message remoting stacks such as SOAP or CORBA stacks which allow computers to communicate at a relatively high level there are benefits in being able to treat messages as a unit i.e. taking a message and processing it including any necessary decoding and providing a result. The Java API for XML Web Services JAX WS specification which is provided as part of the Java EE platform for use in creating web services includes some aspects of client and service side dynamic message processing. However the JAX WS specification does not provide a means of allowing dynamic message processing at the transport level of the client and service sides nor of asynchronous handling of messages at the service side provider level. These are the general areas that embodiments of the invention are intended to address.

Disclosed herein is a system and method for providing a dynamic invocation and service interface DISI for use in a middleware or other environment. In accordance with an embodiment the system and or method operates both at the client side and at the service side. At the service side the user can insert messages into the inbound processing chain using a service request transport. After service side inbound processing messages are given to the user via a provider request function. The user gives a response by using a provider response function that inserts messages into the service side outbound processing chain. After service side outbound processing messages are given to the user s service response transport. The service request transport and service response transport decouples the messaging processing from the transport and makes the message processing asynchronous in nature. The provider request and provider response are also asynchronous in nature. On the client side the user can insert messages into the outbound processing chain using a dispatcher request. After client side outbound processing messages are given to the user s client request transport. This decouples message processing from the transport and makes the message processing asynchronous in nature. When the response is received a user uses a client response transport function to insert the response into the client side inbound processing chain. After client side inbound processing message are given to the user s dispatcher response function. The dispatcher request and dispatcher response are also asynchronous in nature. On both the client and service sides since DISI is asynchronous threads are not backed up i.e. a client can send a request and not have to wait for a response. The process also allows decoupling of e.g. SOAP processing from the message transport and makes it asynchronous in nature.

As described above a web service is a software system that supports machine to machine interaction over a network. A web service protocol stack is a stack of networking and other protocols that can be used to define locate implement and enable services to interact with one other. Examples of such protocols include the Simple Object Access Protocol SOAP which specifies the exchange of structured information for use with web services and which relies on Extensible Markup Language XML for a message format and on other protocols e.g. Hypertext Transfer Protocol HTTP or Simple Mail Transfer Protocol SMTP for message transmission. Commonly each web service has an interface described in a machine understandable format such as the Web Services Description Language WSDL . Other systems can use SOAP messages to interact with the web service interface in a manner prescribed by its description.

Other types of protocol stacks can similarly include some processing of message information wherein the messages are themselves encoded in some fashion e.g. the Common Object Request Broker Architecture CORBA stack.

In the context of message remoting stacks such as SOAP or CORBA stacks which allow computers to communicate at a relatively high level there are benefits in being able to treat messages as a unit i.e. taking a message and processing it including any necessary decoding and providing a result. The Java API for XML Web Services JAX WS specification which is provided as part of the Java EE platform for use in creating web services includes some aspects of client and service side dynamic message processing. However the JAX WS specification does not provide a means of allowing dynamic message processing at the transport level of the client and service sides nor of asynchronous handling of messages at the service side provider level.

In accordance with an embodiment disclosed herein is a system and method for providing a dynamic invocation and service interface DISI for use in a middleware or other environment. The system and or method operates both at the client side and at the service side.

At the service side messages can be inserted using a service request transport and a service response transport which decouples the messaging processing from the transport and makes the message processing asynchronous in nature. At the service side the user can insert messages into the inbound processing chain using a service request transport. After service side inbound processing messages are given to the user via a provider request function. The user gives a response by using a provider response function that inserts messages into the service side outbound processing chain. After service side outbound processing messages are given to the user s service response transport. The service request transport and service response transport decouples the messaging processing from the transport and makes the message processing asynchronous in nature. The provider request and provider response are also asynchronous in nature. JAX WS does have a provider but it is not asynchronous JAX WS does not have equivalents to service request transport and service response transport .

At the client side a dispatcher request function is provided which puts messages at the beginning of the outbound processing chain and a dispatcher response function is provided that receives messages at the end of the inbound processing chain. Since the process is asynchronous threads are not backed up i.e. a client can send a request and not have to wait for a response. The process also allows decoupling of e.g. SOAP processing from the message transport and makes it asynchronous in nature. At the client side a dispatcher request function inserts message into the client side outbound processing chain. On the client side the user can insert messages into the outbound processing chain using a dispatcher request. After client side outbound processing messages are given to the user s client request transport. This decouples message processing from the transport and makes the message processing asynchronous in nature. When the response is received a user uses a client response transport function to insert the response into the client side inbound processing chain. After client side inbound processing message are given to the user s dispatcher response function. The dispatcher request and dispatcher response are also asynchronous in nature. JAX WS does have a dispatch function that does have asynchronous capabilities JAX WS does not have equivalents to client request transport and client response transport . On both the client and service sides since DISI is asynchronous threads are not backed up i.e. a client can send a request and not have to wait for a response. The process also allows decoupling of e.g. SOAP processing from the message transport and makes it asynchronous in nature.

In accordance with an embodiment a DISI interface can be modeled after standard JAX WS client and service endpoint interfaces but can also include those differences necessary to satisfy the requirements of containing environments or products such as Oracle Service Bus OSB particularly in the areas of asynchrony and transport neutrality requirements. For example while JAX WS includes a client side asynchronous programming model there is no model for asynchronous services. Therefore in accordance with an embodiment DISI can define its own asynchronous client side programming model so that the client service endpoint and transport level interfaces are consistent.

In accordance with an embodiment the DISI interface can be used to formalize the contract between different environments or products such as Oracle WebLogic JRF Web Services and OSB in regard to e.g. how OSB should integrate web services including configuration manageability databinding and general runtime. Some benefits of the DISI interface include that it allows the dynamic and spontaneous initialization of a service endpoint without requiring an explicit JavaEE or JRF style deployment it allows the caller i.e. containing product to fully control inbound and outbound transports through hook points it allows the caller i.e. containing product to fully control service or client configuration through WebServiceFeature instances and to explicitly not require deployment descriptors and it can be fully asynchronous and allow request and response processing for any particular request to be executed by different threads.

As shown in a client side environment which includes a client computer a client container and a client application e.g. a web services client communicates via a transport with a service side environment which includes a service provider computer a service container e.g. a web services container and a service e.g. a web service .

At the client side the client application initiates an outbound call by invoking DispatcherRequest also giving a DispatcherResponse instance that will be invoked by the stack when if a response is returned . The runtime stack performs outbound SOAP processing e.g. WS Addressing MTOM character encoding WS ReliableMessaging WS Security etc. . When outbound SOAP processing is complete the runtime stack calls ClientRequestTransport with the message to be sent and a ClientResponseTransport instance to invoke when a response is returned . The client is then responsible for sending the message on a transport e.g. shared memory JMS FTP etc. . The client is also responsible to set up client response handling code that will receive responses e.g. JMS queue socket listener . When a response comes back on the transport the client code calls ClientResponseTransport with the message. The runtime stack performs inbound SOAP processing. When inbound SOAP processing is complete the runtime stack calls DispatcherResponse with the response which is then given to the client application.

The service side is similar to the client side. The service side is responsible to set up service request handling code that will receive requests from the transport . When a message arrives on the transport it is handled by the service request handling code that calls ServiceRequestTransport with the message also giving two ServiceResponseTransports instances that will be invoked when if a response is to be returned . The runtime stack performs inbound SOAP processing. When inbound SOAP processing is complete the runtime stack calls provider request with the message for the service and a provider response instance to invoke to return a response . The service communicates the response by invoking provider response with the message the message means both the data of the invocation and any metadata needed for processing e.g. mime type . The runtime stack performs outbound SOAP processing. When outbound SOAP processing is complete the runtime stack calls service response transport which is responsible for placing the response on the transport . Also as shown in when a box i.e. object is shown inside the client runtime or service containers this indicates that it is the responsibility of that container to create the object .

In the standard model which uses an outbound transport processor and inbound transport processor the transport handling code and physical transport are mostly opaque. In contrast in the DISI model the transport handling code and physical transport are available visible to the client. As shown in when a box i.e. object is shown inside a container this indicates that the object is visible to the container . As such while in the standard model only Dispatch and AsyncHandler are visible to the client container in the DISI model both the client request handling i.e. ClientRequest and ResponseTransport and the physical transport is visible available.

As shown in the standard client side invocation flow begins with a Dispatch instance carries through the web services runtime and terminates on a transport. Dispatch provides an easy to use asynchronous programming model. illustrates one variant of the model where the caller provides an AsyncHandler to receive the response 

In the above illustration Dispatch is called by the containing environment while AsyncHandler is implemented by the containing environment. With the above approach there is no standard way for an application to override or control the transport implementation other than using very low level socket or URL connection factory configurations. Dispatch provides no standard support for persistence or clustering and AsyncHandlers are not required to be serializable.

In accordance with an embodiment the DISI client side invocation flow defines DispatcherRequest and DispatcherResponse which take the place of Dispatch and AsyncHandler respectively and ClientRequestTransport and ClientResponseTransport which take the place of the outbound request and inbound response transport 

In the above illustration DispatcherRequest and ClientResponseTransport are called by the containing environment while DispatcherResponse and ClientRequestTransport are implemented by the containing environment.

In accordance with an embodiment the containing environment e.g. OSB can issue requests by invoking on an instance of DispatcherRequest. This request will terminate in a call to an instance of ClientRequestTransport. The ClientRequestTransport instance is responsible for interacting with the physical transport. When a response is received by the physical transport the containing environment will invoke response processing on an instance of ClientResponseTransport. The response processing will flow through the runtime stack and the response processing will terminate with a call to an instance of DispatcherResponse.

An example implementation that uses Oracle WebLogic Oracle Web Services and Oracle Service Bus may include the configuration shown below. Other environments and implementations which utilize different products may use different configurations 

In accordance with an embodiment clients may mix and match use of DispatcherRequest DispatcherResponse with use of ClientRequestTransport ClientResponseTransport and use of standard patterns. That is clients may use standard Dispatch synchronous polling AsyncHandler with ClientRequestTransport ClientResponseTransport. Clients may also use DispatcherRequest DispatcherResponse with the built in transports.

In accordance with an embodiment DISI provides a service class that acts as a factory for DispatcherRequest instances. The containing environment e.g. OSB passes their implementation of ClientRequestTransport using the feature ClientTransportFeature at either Service or Dispatch DispatcherRequest initialization.

Once the caller invokes DispatcherRequest.request . . . request processing commences and concludes with either an error or a call to the ClientRequestTransport. The ClientRequestTransport receives an instance of ClientResponseTransport to invoke on when the exchange is done. When the application code invokes the ClientResponseTransport instance then response processing has begun and this flow terminates in a call to the DispatcherResponse instance.

As shown in the standard service side invocation flow begins with the transport carries through the web services runtime via inbound transport processor and outbound transport processor and terminates on a Provider instance or SEI which then returns. There is no standard asynchronous service side programming model although the JAX WS Reference Implementation does provide an AsyncProvider 

In the above illustration Provider and Provider returns are implemented by the containing environment. As with the client side there is no standard way for an application to override or control the transport implementation other than using very low level or application server specific integrations. The Provider model provides no standard support for persistence or clustering and Providers are not required to be Serializable and the standard Provider model is not asynchronous.

In accordance with an embodiment the DISI service side invocation flow defines ServiceRequestTransport and ServiceResponseTransport which take the place of the inbound and response transport and ProviderRequest and ProviderResponse which take the place of the Provider.

In the above illustration ServiceRequestTransport and ProviderResponse are called by the containing environment and ServiceResponseTransport anon ServiceResponseTransport non anon and ProviderRequest are implemented by the containing environment.

In accordance with an embodiment the containing environment e.g. OSB can issue requests by invoking on an instance of ServiceRequestTransport. This request will terminate in a call to a Java Web Service JWS Provider instance or an instance of ProviderRequest depending on what the application initialized.

The caller of ServiceRequestTransport and the implementation of ServiceResponseTransport are responsible for interacting with the physical transport. For example the containing environment could receive requests in a servlet MDB or read them from a file and then pass them to the web services runtime through a ServiceRequestTransport.

The ProviderRequest implementation is responsible for executing the application request and this could include calling through to a client flow using DispatcherRequest acting as an intermediary as is the case for OSB .

When the application response is available the application is responsible for invoking the ProviderResponse which was passed to the application when the original request to the ProviderRequest was made.

The invocation of ProviderResponse passes through the web services runtime and terminates with a call to one of the ServiceResponseTransport instances. In accordance with an embodiment here the model is slightly different between client and service side. In order to support non anonymous addressing the web services runtime can invoke on two different ServiceResponseTransports shown here as and . The first of these transports represents the request transport s anonymous ServiceResponseTransport i.e. anon aka backchannel . In accordance with an embodiment if the request s ReplyTo or FaultTo headers are set to ANON then the anon ServiceResponseTransport is called after outbound service side SOAP processing. In this case the non anon ServiceResponseTransport is never called. If the request s ReplyTo or FaultTo headers are set to NON ANON then after outbound processing the anon ServiceResponseTransport is called first with metadata only i.e. no message . This gives the ability to close connections and send OK e.g. HTTP 202 messages to the sender. Then the non anon ServiceResponseTransport is called with the response message. Because the delivery address for the response message depends on the addressing headers a non anon message could be delivered on a different type of transport than the transport fronting the ServiceRequestTransport. For service containers that do need non anon responses the containing environment may pass null for the non anon ServiceResponseTransport.

An example implementation that uses Oracle WebLogic Oracle Web Services and Oracle Service Bus may include the configuration shown below. Other environments and implementations which utilize different products may use different configurations 

In accordance with an embodiment services may mix and match use of ServiceRequestTransport ServiceResponseTransport with the use of ProviderRequest ProviderResponse and the use of standard patterns. That is services may use standard Providers or SEI s with ServiceRequestTransport ServiceResponseTransport. Services may also use ProviderRequest ProviderResponse with the built in transports however this requires using pre existing deployment models.

In accordance with an embodiment DISI provides an Endpoint class that acts as a factory for ServiceRequestTransport instances. For example OSB can pass their implementation of ProviderRequest during Endpoint initialization.

As shown in at the client side at step the containing environment issues requests by invoking on an instance of DispatcherRequest. At step the runtime stack performs outbound SOAP processing. At step the request terminates in a call to an instance of ClientRequestTransport which is responsible for interacting with the physical transport. At step when a response is received by the physical transport the containing environment invokes response processing on an instance of ClientResponseTransport. At step the runtime stack performs inbound SOAP processing. At step the response processing flows through the runtime stack and terminates with a call to an instance of DispatcherResponse.

As shown in at the service side at step a request arrives on the transport. At step the containing environment issues requests by invoking on ServiceRequestTransport. At step the runtime performs service side inbound SOAP processing. At step the request terminates in a call to ProviderRequest. At step ProviderRequest starts execution of the application request. At step the application invokes ProviderResponse with the response. At step the runtime performs service side outbound SOAP processing. At step the request processing terminates in a call to ServiceResponseTransport. At step ServiceResponseTransport interacts with the physical transport.

In accordance with an embodiment when the use case does not involve buffering inside the SOAP runtime the following properties hold 

In accordance with an embodiment with buffering enabled request or response flows that must be buffered will terminate in the buffering sub system and then later a thread of the buffering sub system e.g. work manager for an MDB will complete the flow. In other words all of the rules above modified to add the buffering point continue to hold without any other additions.

In accordance with an embodiment endpoints can make their metadata i.e. both WSDL documents and XSD s available to callers by indicating a metadata request in per request metadata known as request context that is part of the message. The request context can have properties such as the following 

In accordance with an embodiment DISI persistence and clustering can be based on the serialization of request response context and ClientRequestTransport ClientResponseTransport DispatcherResponse ProviderRequest ProviderResponse and ServiceResponseTransport objects serialization of ClientRequestTransport and ProviderRequest is only required if buffering is configured to occur during SOAP processing .

In accordance with an embodiment the ProviderRequest implementation can serialize ProviderResponse object and any necessary arguments from the request. Later when another process such as a batch process has completed the ProviderResponse can be deserialized and invoked. The ProviderResponse may be deserialized and invoked from any machine in the same cluster as the machine where the original request occurred or after server restart.

In those implementations which use Web Services the Web Services runtime can serialize the non anonymous ServiceResponseTransport object so that it may later use this object to send non anonymous responses. This could happen because of a buffering point e.g. use of asynchronous Web Services Reliable Messaging WS RM or because the ProviderResponse object was serialized. It is not expected that the backchannel ServiceResponseTransport object will ever be serialized as transports that support a backchannel do not support persistence or clustering of the backchannel response.

In accordance with an embodiment the ClientRequestTransport implementation can serialize ClientResponseTransport object such that the ClientResponseTransport object could be invoked after server restart or on another machine in the cluster. This is one possible implementation of asynchronous response handling using non anonymous addressing.

In those implementations which use Web Services the Web Services runtime can serialize the DispatcherResponse object so that it may later invoke on this object to deliver the application response. This could happen because of a buffering point or because the ClientResponseTransport object was serialized. In accordance with an embodiment DISI does not define a model to manage the lifecycle of serialized callback objects. Web Services buffering implementations can provide these capabilities for objects they store e.g. WS RM can delete persisted data including serialized objects related to expired or terminated conversations .

In accordance with an embodiment all configuration of DISI service endpoints and clients can be programmatic using JAX WS standard APIs DISI APIs and DISI specific WebServiceFeature classes i.e. configuration beans . These APIs can include bean properties available on DISI s Service and Endpoint classes which derive from the standard Service and Endpoint classes respectively as well as standard WebServiceFeature classes such MTOMFeature and AddressingFeature. There are no standard WebServiceFeature classes for most WS features. Proprietary WebServiceFeature classes may be given to DISI if the underlying SOAP stack understands those classes. In accordance with an embodiment DISI has an Endpoint.update API that containing environments can use to dynamically reconfigure a DISI based endpoint i.e. service side . For example OSB might use OWSM to manage a web service. When a change notification comes from OWSM then Endpoint.update would be called with the new configuration.

In accordance with an embodiment context about DISI requests or responses data other than the message can be passed using instances of Map context objects. For ease of use DISI provides an adapter class to populate the request and response context from standard servlet request and response objects respectively ServletContextAdapter.

Table 1 describes request context key value pairs for ServiceRequestTransportrequest in accordance with an embodiment.

Table 2 describes response context key value pairs for ServiceResponseTransport.response and ServiceResponseTransport.fail in accordance with an embodiment.

Table 3 describes request context key value pairs for ProviderRequest.request in accordance with an embodiment.

Table 4 describes request context key value pairs for ProviderResponse.response in accordance with an embodiment.

Table 5 describes request context key value pairs for DispatcherRequest.request in accordance with an embodiment.

Table 6 describes request context key value pairs for DispatcherResponse.response in accordance with an embodiment.

Table 7 describes request context key value pairs for ClientRequestTransport.request in accordance with an embodiment.

Table 8 describes request context key value pairs for ClientResponseTransport.response in accordance with an embodiment.

The present invention may be conveniently implemented using one or more conventional general purpose or specialized digital computer computing device machine or microprocessor including one or more processors memory and or computer readable storage media programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure as will be apparent to those skilled in the software art.

In some embodiments the present invention includes a computer program product which is a non transitory storage medium or computer readable medium media having instructions stored thereon in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include but is not limited to any type of disk including floppy disks optical discs DVD CD ROMs microdrive and magneto optical disks ROMs RAMs EPROMs EEPROMs DRAMs VRAMs flash memory devices magnetic or optical cards nanosystems including molecular memory ICs or any type of media or device suitable for storing instructions and or data.

The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.

