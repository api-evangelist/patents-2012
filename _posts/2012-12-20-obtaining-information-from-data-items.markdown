---

title: Obtaining information from data items
abstract: Methods and apparatus are disclosed for obtaining information from one or more headers of a data item transmitted via a communication network, a predetermined portion of at least one header carrying a symbol or combination of symbols having a first pre-defined meaning according to a first pre-defined communication protocol. The method comprises inspecting at least one header of a received data item whereby to identify the symbol or combination of symbols carried by the predetermined portion thereof; identifying whether at least one other portion of a header of the data item is carrying the same symbol or combination of symbols; and in the event that it is identified that at least one other portion of a header of the data item is carrying the same symbol or combination of symbols, â€˜interpreting and/or processing at least one of the one or more headers according to a second pre-defined communication protocol, the second communication protocol differing from the first communication protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08964755&OS=08964755&RS=08964755
owner: BRITISH TELECOMMUNICATIONS public limited company
number: 08964755
owner_city: London
owner_country: GB
publication_date: 20121220
---
This application is the U.S. national phase of International Application No. PCT GB2012 000918 filed 20 Dec. 2012 which designated the U.S. and claims priority to EP Application No. 11250952.6 filed 30 Dec. 2011 the entire contents of each of which are hereby incorporated by reference.

The present invention relates to obtaining information from data items transmitted via a communication network. More specifically aspects of the present invention relate to methods and apparatus for obtaining information from one or more headers of a data item transmitted via a communication network.

We start by presenting some basic concepts to facilitate the understanding of the mechanisms that are presented further on.

A data sender usually splits data to be sent into small units known as packets. Each packet consists of a header and a payload carrying the data to be delivered. The header contains fields defined by the relevant communication protocol. Within the payload of a packet there will often be a further header itself encapsulating a further payload. For instance the great majority of packets carried by commercial networks nowadays are so called TCP IP packets where TCP is the Transmission Control Protocol and IP is the Internet Protocol. In these cases the network layer IP header encapsulates a transport layer payload that starts with a TCP header which in turn encapsulates its payload.

Similarly when a packet is transmitted over a communications link it will be encapsulated by a further header specific to the technology of the link in question. For instance when a packet traverses an Ethernet link an Ethernet header is added to encapsulate the IP packet which becomes the payload.

The general term for these split up units of data is a protocol data unit PDU . PDUs at different layers of encapsulation are typically given different names. At the link network and transport layers they are termed respectively frames packets and segments or datagrams .

As will later be understood embodiments of the present invention could be applied at any of these levels or possibly even at the application layer although it may be easier to extend a protocol without relying on embodiments of the present invention at the application layer .

From time to time a new requirement has to be met and can be achieved by updating part of a communications protocol rather than completely replacing it. Most protocols are defined so that some values of various fields are not used but are reserved for future use. The idea is that new features can be added by bringing values into use from these reserved ranges.

When reserved values are brought into use for a new variant of the protocol things generally do not go as planned. Existing equipment built before the protocol was updated is usually meant to take some default action if it encounters a packet carrying one of the reserved values. When a reserved value starts to be used however it is generally discovered that some legacy equipment does not take the specified default action possibly for one of the following three reasons 

Therefore the first adopters of a new protocol typically discover that arbitrary equipment seems to crash inexplicably or packets carrying new values never reach their destination because some item of equipment wrongly discards such packets termed being black holed .

The outcome is often that new features are not deployed because no company wants to bear the cost of all the support calls that will result when their perfectly implemented update is seen as the cause of numerous problems that it triggers problems that are actually due to all the other incorrectly implemented equipment that has already been deployed.

To improve network performance one current line of research is to send packets in chirps which are groups of several packets within which the gap between packets progressively reduces thus increasing the instantaneous bit rate per packet . This is discussed in a paper referred to below as Kuehlewind10 . The available bandwidth of a network path sets a lower limit on the gap between delivered packets so packets sent closer together will build up a queue which will then drain at the available bandwidth. Therefore by comparing the gaps between delivered packets with those between sent packets the end systems can identify the lower bound on the gap between packets and use this to estimate available bandwidth.

This promising technique can be used between two computers that have been modified to place the appropriate timestamps on packets and to echo the timestamps to the other end. However widespread deployment of such a change is hampered by numerous middleboxes between the end systems that disrupt any attempt to use a new protocol.

One idea would be to use the existing facility in TCP to timestamp packets see TCP.timestamp referred to below . The TCP timestamp is useful in this respect because it is specified in such a way that the receiver is meant to echo back to the sender whatever number the sender puts in the timestamp option field without regard to its meaning.

However the TCP timestamp option was designed to allow the sender to measure the two way delay over the path not the one way delay as required for chirping to work. Also a TCP receiver typically sends an acknowledgement every two packets and the timestamp facility was designed to measure the delay from when the first packet was sent to when the acknowledgement of the second packet is received. Therefore the TCP timestamp cannot be used for chirping without altering the semantics of the receiver as well as the sender.

It has recently been proposed to negotiate between the sender and receiver to alter the semantics of the TCP timestamp in order to repurpose it for chirping and other potential uses see TCP.ts.negotiate . However this negotiation results in an unusual initial packet which is likely to encounter problems with middleboxes not specifically written to expect it see TCP.security .

A technique proposed in an Internet Draft referred to below as Yourtchenko11 involves use of a pair of connection initialisation packets the first of which conforms to existing standards while the second uses an updated protocol in an extension to the header that would confuse a legacy receiver. This second initialisation packet also uses a different checksum algorithm so that a legacy receiver will consider it invalid and discard it. The legacy receiver then treats the first packet as the only initialisation packet. However an updated receiver will understand the new checksum algorithm and the new protocol so it will be able to process the second initialisation packet. It will also understand the first packet.

U.S. Pat. No. 7 342 892 relates to establishing whether repetition of a header field is an error or attack or whether the repetition is safe.

According to a first aspect of the present invention there is provided a method of obtaining information from one or more headers of a data item transmitted via a communication network a predetermined portion of at least one header carrying a symbol or combination of symbols having a first pre defined meaning according to a first pre defined communication protocol the method comprising 

Preferred embodiments relate to such a method being performed in respect of just one header of the data item in question in which case the method may be defined as follows 

It will be understood that processing a header according to a particular protocol may involve or may be regarded as involving interpreting the header according to the semantics of the protocol and processing the header accordingly in order to obtain information from it.

It will be understood that a symbol may be for example a digit a letter a non alphanumeric character or a combination of any of these. This may depend on the type of data item the type of header the applicable communication protocol and other factors for example. In many communication protocols the symbols are referred to as codepoints each of which may be a single or multi digit number in binary decimal hexadecimal or other such numbering system. Each codepoint or other such symbol may have a particular meaning according to a particular protocol. It is not necessary for each to have a different meaning in some protocols two or more symbols may be assigned the same meaning.

According to preferred embodiments the step of processing the at least one of the one or more headers according to a second pre defined communication protocol may comprise processing at least one of the identified instances of the symbol or combination of symbols itself according to the second pre defined communication protocol by interpreting it as having a second pre defined meaning the second meaning differing from the first meaning.

According to preferred embodiments the first pre defined meaning of the symbol or combination of symbols may be that data carried in one or more predetermined data fields in the at least one header should be processed according to the first pre defined communication protocol and the second pre defined meaning of the symbol or combination of symbols may be that data carried in the one or more predetermined data fields in the at least one header should be processed according to the second pre defined communication protocol.

According to preferred embodiments the communication network may be a digital network such as a packet network.

The predetermined portion of the at least one header may comprise one or more fields or parts of fields in a header of the data item. Alternatively the predetermined portion may comprise one or more sub headers or parts of sub headers in a header of the data item. In this regard it will be understood that sub headers may be what are termed option headers within certain contexts such as TCP time stamping for example. Alternatively the predetermined portion may comprise one or more Options fields in the data item. Other versions of the predetermined portion are possible.

According to preferred embodiments the data item in question may be comprise or be included in an Internet Protocol packet. Alternatively or additionally the data item in question may be comprise or be included in a Transmission Control Protocol segment.

According to preferred embodiments the first and or second pre defined communication protocols may relate to time stamping.

According to preferred embodiments the first pre defined meaning of the symbol or combination of symbols may be that data carried in the one or more predetermined data fields should be processed according to an existing communication protocol allowing determination of round trip time and or that the second pre defined meaning of the symbol or combination of symbols may be that data carried in the one or more predetermined data fields should be processed according to a second pre defined communication protocol allowing determination of one way trip time. It should be noted that one way trip time is also referred to as one way delay .

According to preferred embodiments the method may further comprise processing the at least one header according to the first pre defined communication protocol in the absence of an identification that another portion of a header of the data item is carrying the same symbol or combination of symbols.

According to a second aspect of the present invention there is provided apparatus for obtaining information from one or more headers of a data item transmitted via a communication network a predetermined portion of at least one header carrying a symbol or combination of symbols having a first pre defined meaning according to a first pre defined communication protocol the apparatus comprising 

The various options and preferred embodiments referred to above in relation to the first aspect are also applicable in relation to the second aspect.

According to preferred embodiments the idea is for a sender to repeat a widely accepted protocol option that would not previously have been expected to be repeated. Such repetition can therefore act as a covert signal indicating to the receiver that one or both of the repeated fields should be interpreted with new semantics. Note that only the type of the protocol option is repeated not necessarily all the parameters which may have different values.

A receiver that understands the new protocol will be arranged to detect the repetition and interpret the modified semantics of the repeated fields in the appropriate way.

A receiver that has not been updated to understand the new protocol will read the first occurrence act on it then read the second occurrence and act on it and so on most probably without noticing it has processed a similar option already. The phrase without noticing is used here in the sense that the behaviour of such a receiver is not affected by such repetition. 

The repeated fields can be arranged so that when processed by a receiver that has not been updated to understand the new protocol the last field processed will achieve a desirable and safe outcome even though the new protocol semantics have not been understood.

Note however there is a risk that variations in pre existing software will lead to unpredictable results. For instance 

An aim of preferred embodiments is to be able to circumvent problematic middleboxes that have been set up to work only with known protocols such that they will interfere with newly introduced protocol options. By merely repeating widely recognised protocol options such middleboxes will generally just work their way through the list of options and not notice that one option is repeated. To them a new protocol packet header will be indistinguishable from pre existing packet headers. It is therefore likely that such a method for introducing new protocol semantics will not hit problems with bugs and security checks on these problematic middleboxes.

It should be noted that Yourtchenko s idea discussed above does not use the existence of repetition itself as the signal that a second packet has new semantics. The second packet has a different format that an updated receiver can recognise even if the first packet is lost while a legacy receiver would consider it invalid. The first packet is merely sent as a fall back if the second packet is not understood. While Yourtchenko s idea uses a second packet which is generally related to the first embodiments of the present invention repeat a protocol field within a particular data unit i.e. a particular packet segment datagram etc. .

The disclosures thought by the inventors to be most closely related generally detect repetition of protocol fields as errors or attacks not as deliberate protocol extensions.

No other references to the use of duplicate or repeated protocol fields have been found for the purposes of protocol extension. The only references to header field duplication are concerned with establishing whether a repetition is an error or attack or whether the repetition is safe e.g. U.S. Pat. No. 7 342 892.

With reference to the accompanying figures a method according to a preferred embodiment will be described that may be used to facilitate incremental deployment of a new protocol without causing or increasing the likelihood of the types of problems such as those described above that often occur when a new protocol is deployed.

To show an example of how to implement the use of a second multiple TCP Timestamp Options TSopt we will first provide some background knowledge on TCP and the TSopt.

TCP provides reliable transport of data. That means whenever a packet gets lost on a link TCP ensures that the data will be retransmitted. To detect losses a TCP receiver sends acknowledgments for successfully received packets. Each packet carries a sequence number in the header to differentiate the data. Moreover the TCP header has an ACK flag to label an acknowledgment and an acknowledgment number field to indicate the next expected sequence number at the receiver side. To decrease network and computation load a TCP receiver will usually only send an acknowledgment for every second packet and thus acknowledge the data of both packets in one ACK packet. These are called delayed ACKs. 

TCP is a connection oriented protocol. Before any data can be sent both communication end points need to agree to set up a connection. For this purpose a TCP end point will send an initial TCP packet without any payload data only carrying a header that will indicate the start of a connection by setting the synchronise SYN flag. A TCP receiver that agrees to establish this connection will reply with another TCP packet without payload data. To acknowledge the reception of the SYN packet and indicate the start of a new connection the receiver will set the ACK flag and the SYN flag in the header of this packet. Before any data can be sent the initiator the sender of the initial SYN packet will need to send one more packet without payload data with the ACK flag set to complete this 3 way handshake.

Additional to a certain set of fixed fields and flags like SYN ACK or the sequence number field it is possible to assign optional fields to the TCP header. Each TCP option must have an Option Kind 1 byte field that indicates the type of option. All TCP options except types 0 and 1 must have an Option Length 1 byte field indicating the length of the option header including the type and length . The remaining bytes can be used for any option data to enable additional TCP functionality.

The TCP Timestamp Option is one specific TCP option with the type 8 and a length of 10 The TSopt holds two 4 byte fields called the TS Value TSval and TS Echo Reply TSecr field. The TSopt is intended to be used to estimate the Round Trip Time RTT of a connection. This is done the following way Host A will put a timestamp recording when it sent the segment in the TSval field and host B will copy this value or the earliest value of a non ack ed segment into the TSecr field of the next ACK packet it returns to host A. The timestamp option field is used by the two half connections in both directions A to B and B to A therefore host B puts a timestamp in the TSval field of the ACK to record the time it sent the ACK. When host A receives the ACK packet it can compare the echo of the timestamp it sent to the current time and thus estimate the RTT without holding any records of when it sent packets. For the initial SYN packet in TCP the TSecr field will be zero as no previous timestamp was received.

On the one hand if a TCP host wants to measure RTT it can use the regular TSopt. It will then add the original standard option header to the TCP header of every packet.

If on the other hand a TCP host needs to measure one way delay as well as RTT it can avoid problems with introducing a new protocol by reporting send timestamps in one TSopt header and reporting receive timestamps in an additional TSopt header. Host A will add another TSopt header but use the TSval and the TSecr field of one of them differently to how the TCP timestamp standard originally specified. That means host A will still set the Option Kind field to type 8 and the option will still have a length of 10 bytes but the TSecr field of the additional TSopt header will carry the additional receive timestamp. We will use the postfix r and s to distinguish the respective receive and send timestamps see . Therefore we will call the additional receive timestamp field TSecr r.

Thus the RTT calculation uses the send timestamps in the originally specified way whereas a host can use the receive timestamps to measure one way delay OWD of packets it sends. We now use the timestamps in the protocol time sequence diagram of to give examples of the relevant calculations.

When the SYN ACK arrives at host A at time t4 host A calculates 4 1 using the TSecr s value of t1 in the arriving packet. Host A can also calculate 2 1 using the TSecr r value of t2 in the arriving packet as well.

The additional TSopt header does not have to appear at any specific position before or after the original header but we recommend having the original TSopt as the latest position as it is most likely that a non updated host will echo this one.

An optimisation is sensible where the repetition must be immediate to be considered a signal that the first field has different semantics than if it occurred alone. Without this optimisation no field can be processed until every field has been read to check whether there are any repetitions. With this optimisation a field can be processed as soon as the type of the next field has been read.

Unlike the TSopt for send timestamps the receive timestamp TSopt does not strictly need space for two timestamps. However the TSopt for receive timestamps should mimic the length of the send timestamp field in order to reduce the chances of a middlebox rejecting it.

The apparently redundant TSval field in the additional TSopt header seems to be wasted. However it can be put to good use where specialised receive timestamping hardware is available in the network interface card NIC . This is illustrated in in which each packet is sent between the two transport endpoints Aand B but they are forwarded through respective network interface cards Aand B each of which provides a hardware timestamping facility.

As an example we will focus on the SYN ACK packet sent at time t5 in . This packet arrives at the network interface card NIC of host A at time t7 so the NIC stamps the receive timestamp value t7 into the TSval r field. When this packet arrives at host A s transport function A it reads the two TSecr values TSecr r t3 and TSecr s t1 and uses them in the calculations for RTT and OWD as already defined above. At time t9 when host A sends the ACK triggered by this packet it copies the two incoming values TSval r and TSval s into the two outgoing values TSecr r and TSecr s respectively and it stamps the send timestamp t9 onto TSval s. When this packet in turn arrives at the MC of host B it stamps the receive time t11 into the TSval r field and the process of reading and swapping timestamps repeats as before.

The NIC only timestamps incoming packets if the transport function instructs it to through a call to the appropriate application programming interface API . Then the transport function mechanically follows the same reading and swapping actions without having to read the system clock to timestamp when packets arrive. If the transport function does not instruct the NIC to add receive timestamps it ignores the incoming TSval r field and measures the time each packet is received by reading the system clock then writing this time into the TSecr r field of the following outgoing packet.

With the initial TCP SYN packet the TSecr of both timestamp options needs to be zero to not break the semantics. If the sender wants to guarantee that a correct RTT estimation at the beginning of a connection can be derived both occurrences of the TSval in the two option headers of the initial SYN should hold the same valid timestamp even though later in the session not all TSopt headers need to hold the same timestamp. This is because a sender will not typically know a priori if the respective receiver is updated to understand repeated headers.

If the sender sends an initial SYN packet with more than one TSopt and does not get an SYN ACK response the sender will retry after a certain time period. With the next SYN packet the sender should not use any repeated TSopt headers. If the sender has sent a SYN with multiple TSopt headers but the SYN ACK carries only one TSopt header the sender should not send additional TSopt header any more. Instead it should only send one header with the original semantics.

The embodiment described so far adds one additional timestamp option. If a different embodiment requires more than twice the space of the original TCP option header a header such as the TCP timestamp option that had traditionally been used only once may be repeated more than once each repetition potentially implying different semantics.

The flow diagrams in specify how a host reads the timestamp values TSval from repeated headers in an incoming packet into a memory array TS i see . Then when it sends the following outgoing packet as long as more values exist in this stored array it adds more timestamp option fields to the outgoing packet and writes the values from this array into their TSecr fields see . Finally in it writes the current time into the sending timestamp value TSval s of the last timestamp option.

A second embodiment will now be described. In the definition of version 6 of the Internet protocol IPv6 if the IPv6 packet is encapsulated tunnelled by another outer IPv6 header there is no facility to specify that a newly defined hop by hop option header should be copied to the outer header. The relevant IETF specification that defines how IPv6 hop by hop option headers are treated by tunnel endpoints RFC 2473 merely says that the decision as to whether to copy an IPv6 hop by hop option header to the outer header depends on the configuration of the tunnel endpoint. Therefore if an existing tunnel endpoint encounters a packet with a new option header that it doesn t recognise there is no mechanism to ask it to copy this newly defined header to the outer header. This second embodiment solves this problem by using the idea of header repetition to ensure that a newly defined IPv6 option header will be copied to the outer header of a tunnel.

The jumbogram IPv6 hop by hop option header has always been copied to the outer when it is encapsulated by an IPv6 tunnel endpoint. The jumbogram option header comprises a 1 byte option type of C2 hexadecimal a 1 byte option length field with value 4 meaning 4 bytes and a 4 byte field to specify the size of the jumbogram. We propose that if a new hop by hop option header is required to be copied to the outer on tunnelling rather than defining a new hop by hop option header a second header with option type C2 jumbogram can be added to the IPv6 packet. It is unlikely that any existing IPv6 router includes any check for repeated option types given there has been no need so far. Therefore repeating a jumbogram header should fool existing IPv6 tunnel endpoints into copying the repeated jumbogram header to the outer. The software for reading the value of the jumbogram field is highly likely to read the second jumbogram header without realising it has already read one and then use only the last value it reads as the size of the jumbogram.

If more than 4 bytes of option header is needed more headers with option type C2 can be added multiple times. All but the last duplicate jumbogram header can be given newly defined semantics nothing to do with jumbograms even though option type C2 was originally specified to have the semantics of a jumbogram header.

IPv6 routers that have been updated to understand these repeated jumbogram option headers will include code to count any hop by hop option headers starting with option type C2 and to act on each one in sequence with the appropriate semantics. For instance a new standard may specify that 

