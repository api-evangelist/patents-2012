---

title: Controlling depth and latency of exit of a virtual processor's idle state in a power management environment
abstract: A mechanism is provided in a logically partitioned data processing system for controlling depth and latency of exit of a virtual processor's idle state. A virtualization layer generates a cede latency setting information (CLSI) data. Responsive to booting a logical partition, the virtualization layer communicates the CLSI data to an operating system (OS) of the logical partition. The OS determines, based on the CLSI data, a particular idle state of a virtual processor under a control of the OS. Responsive to the OS calling the virtualization layer, the OS communicates the particular idle state of the virtual processor to the virtualization layer for assigning the particular idle state and wake-up characteristics to the virtual processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09027021&OS=09027021&RS=09027021
owner: International Business Machines Corporation
number: 09027021
owner_city: Armonk
owner_country: US
publication_date: 20120412
---
This application is a continuation of U.S. patent application Ser. No. 12 645 597 entitled CONTROLLING DEPTH AND LATENCY OF EXIT OF A VIRTUAL PROCESSOR S IDLE STATE IN A POWER MANAGEMENT ENVIRONMENT by Richard L. Arndt et al. filed Dec. 23 2009 the disclosure of which is hereby incorporated herein by reference in its entirety for all purposes.

The present application relates generally to an improved data processing apparatus and method and more specifically to mechanisms for controlling depth and latency of exit of a virtual processor s idle state in a power management environment.

There is an emerging customer requirement for better power and thermal management in server systems. Customers increasingly expect systems to behave in such a way as to be power efficient. Customers also want the ability to set policies that trade off power and performance in order to meet their particular objectives. For example customers want to be able to over provision their installations relative to the nominal maximum power and temperature values of the systems that they install but be able to take advantage of the variability in workloads and utilization to ensure that the systems operate correctly and within the limits of the available power and cooling.

IBM s EnergyScale system controls the power and temperature of running systems in a performance aware manner under the direction of a set of policies and objectives specified through EnergyScale system s user interfaces. To do so the EnergyScale system implements detailed periodic measurement of processor core power and temperature measurement of the power consumed by the entire system board as well as any plugged in processor cards and measurement of the memory power and temperature to the system. EnergyScale system uses the results of these measurements to adjust the system s operation and configuration to meet specified objectives for power temperature and performance by using closed loop feedback control operating in real time.

One of the tools used by the EnergyScale system to control power is to adjust the frequency and voltage of the processor chips and cores in the system to control the power dissipation as a function of the user specified energy scale policy. Early EnergyScale system designs required that the voltage and frequency of all central processing units CPUs in the system be maintained at the same value. As the EnergyScale system design and implementation becomes more sophisticated it becomes possible to have cores in a system running at different frequencies and voltages and allows the implementation of more sophisticated power savings algorithms. A side effect of the more sophisticated implementation is that energy savings opportunities increase with the increasing granularity of the EnergyScale system design.

One of the enhancements to the EnergyScale system design is the ability to set an idle state from among different possible idle states of a processor core. A processor core in an idle state saves power by not executing instructions. The amount of power saved depends on the amount of the processor s resources that can be disabled when entering the idle state. The greater the amount of the processor resource that is turned off the greater the power savings and correspondingly the greater the latency of exit when exiting the idle state and re enabling those processor resources that were previously disabled. The greater latency in exiting the idle state translates to greater processor resources that have to be enabled when exiting the idle stage.

On a logically partitioned system when an operating system OS determines that its thread in a dedicated processor partition is idle the OS calls a virtualization layer i.e. such as a hypervisor so that the virtualization layer can place the central processing unit CPU corresponding to the virtual processor in a low power idle state.

However when the OS calls the virtualization layer the OS has different expectations regarding the latency of exit from an idle state of the virtual processor. When referring to the phrase latency of exit from an idle state one is referring to the measure of how quickly the OS will regain control of its virtual processor after a qualifying event wakes up the virtual processor from its idle state. For example if the OS is folding its virtual processor the OS may not have an expectation that the virtual processor will respond to Input Output I O or timer interrupts. Moreover the OS expects to regain control of the virtual processor in at most for example one second after the virtual processor is awakened by the OS. In other cases for idle management the OS may tolerate a latency of only a few micro seconds when the virtual processor exits its idle state and the OS expects the same latency when the virtual processor is presented an I O or timer interrupt.

In one illustrative embodiment a method in a logically partitioned data processing system is provided for controlling the depth and latency of exit of a virtual processor s idle state. The illustrative embodiments generate a cede latency setting information CLSI data. The illustrative embodiments determine whether a logical partition has booted or has migrated. The illustrative embodiments communicate the CLSI data to an operating system OS of the logical partition. The illustrative embodiments determine a particular idle state of a virtual processor under a control of the OS. The particular idle state is determined based upon the CLSI data. The illustrative embodiments then communicate the particular idle state of the virtual processor to a virtualization layer in response to the OS calling the virtualization layer.

In other illustrative embodiments a computer program product comprising a computer useable or readable medium having a computer readable program is provided. The computer readable program when executed on a computing device causes the computing device to perform various ones and combinations of the operations outlined above with regard to the method illustrative embodiment.

In yet another illustrative embodiment a system apparatus is provided. The system apparatus may comprise one or more processors and a memory coupled to the one or more processors. The memory may comprise instructions which when executed by the one or more processors cause the one or more processors to perform various ones and combinations of the operations outlined above with regard to the method illustrative embodiment.

These and other features and advantages of the present invention will be described in or will become apparent to those of ordinary skill in the art in view of the following detailed description of the example embodiments of the present invention.

The illustrative embodiments provide a mechanism for controlling the depth and latency of exit of a CPU corresponding to a virtual processor s idle state. The mechanism allows the OS of a logical partition to make the correct decision with regard to the type of idle state that should be assigned to one or more of its virtual processors. This ensures that there are no unacceptable delays in the OS resuming control of the idle virtual processor when the OS requires the idle virtual processor s resources.

Thus the illustrative embodiments may be utilized in many different types of data processing environments including a distributed data processing environment a single data processing device or the like. In order to provide a context for the description of the specific elements and functionality of the illustrative embodiments are provided hereafter as example environments in which aspects of the illustrative embodiments may be implemented. While the description following will focus primarily on a single data processing device implementation of a mechanism that controls the latency of exit of a virtual processor this is only an example and is not intended to state or imply any limitation with regard to the features of the present invention. To the contrary the illustrative embodiments are intended to include distributed data processing environments as well.

With reference now to the figures and in particular with reference to example diagrams of data processing environments are provided in which illustrative embodiments of the present invention may be implemented. It should be appreciated that are only examples and are not intended to assert or imply any limitation with regard to the environments in which aspects or embodiments of the present invention may be implemented. Many modifications to the depicted environments may be made without departing from the spirit and scope of the present invention.

In the illustrative embodiments a computer architecture is implemented as a combination of hardware and software. The software part of the computer architecture may be referred to as microcode or millicode. The combination of hardware and software creates an instruction set and system architecture that the rest of the computer s software operates on such as Basic Input Output System BIOS Virtual Machine Monitors VMM Hypervisors applications etc. The computer architecture created by the initial combination is immutable to the computer software BIOS etc except through defined interfaces which may be few.

Referring now to the drawings and in particular to there is depicted a block diagram of a data processing system with which aspects of the illustrative embodiments may advantageously be utilized. As shown data processing system includes processor units . Each of processor units includes a processor and a cache memory. For example processor unit contains processor and cache memory and processor unit contains processor and cache memory

Processor units are connected to main bus . Main bus supports system planar that contains processor units and memory cards . System planar also contains data switch and memory controller cache . Memory controller cache supports memory cards that include local memory having multiple dual in line memory modules DIMMs .

Data switch connects to bus bridge and bus bridge located within native I O NIO planar . As shown bus bridge connects to peripheral components interconnect PCI bridges and via system bus . PCI bridge connects to a variety of I O devices via PCI bus . As shown hard disk may be connected to PCI bus via small computer system interface SCSI host adapter . Graphics adapter may be directly or indirectly connected to PCI bus . PCI bridge provides connections for external data streams through network adapter and adapter card slots via PCI bus .

Industry standard architecture ISA bus connects to PCI bus via ISA bridge . ISA bridge provides interconnection capabilities through NIO controller having serial connections Serial and Serial . A floppy drive connection keyboard connection and mouse connection are provided by NIO controller to allow data processing system to accept data input from a user via a corresponding input device. In addition non volatile RAM NVRAM connected to ISA bus provides a non volatile memory for preserving certain types of data from system disruptions or system failures such as power supply problems. System firmware is also connected to ISA bus for implementing the initial Basic Input Output System BIOS functions. Service processor connects to ISA bus to provide functionality for system diagnostics or system servicing.

The operating system OS is stored on hard disk which may also provide storage for additional application software for execution by a data processing system. NVRAM is used to store system variables and error information for field replaceable unit FRU isolation. During system startup the bootstrap program loads the operating system and initiates execution of the operating system. To load the operating system the bootstrap program first locates an operating system kernel image on hard disk loads the OS kernel image into memory and jumps to an initial address provided by the operating system kernel. Typically the operating system is loaded into random access memory RAM within the data processing system. Once loaded and initialized the operating system controls the execution of programs and may provide services such as resource allocation scheduling input output control and data management.

The illustrative embodiment may be embodied in a variety of data processing systems utilizing a number of different hardware configurations and software such as bootstrap programs and operating systems. The data processing system may be for example a stand alone system or part of a network such as a local area network LAN or a wide area network WAN . As stated above is intended as an example not as an architectural limitation for different embodiments of the present invention and therefore the particular elements shown in should not be considered limiting with regard to the environments in which the illustrative embodiments of the present invention may be implemented.

With reference now to a block diagram of an exemplary logically partitioned platform is depicted in which the illustrative embodiments may be implemented. The hardware in logically partitioned platform may be implemented for example using the hardware of data processing system in .

Logically partitioned platform includes partitioned hardware operating systems and virtual machine monitor . Operating systems and may be multiple copies of a single operating system or multiple heterogeneous operating systems simultaneously run on logically partitioned platform . These operating systems may be implemented for example using IBM i which is designed to interface with a virtualization layer such as partition management firmware e.g. a hypervisor. IBM i is used only as an example in these illustrative embodiments. Of course other types of operating systems such as AIX and Linux may be used depending on the particular implementation. Operating systems and are located in logical partitions and respectively.

Hypervisor software is an example of software that may be used to implement platform in this example virtual machine monitor and is available from International Business Machines Corporation. Firmware is software stored in a memory chip that holds its content without electrical power such as for example a read only memory ROM a programmable ROM PROM an erasable programmable ROM EPROM and an electrically erasable programmable ROM EEPROM .

Logical partitions and also include partition firmware loader and . Partition firmware loader and may be implemented using IPL or initial boot strap code IEEE 1275 Standard Open Firmware and runtime abstraction software RTAS which is available from International Business Machines Corporation.

When logical partitions and are instantiated a copy of the boot strap code is loaded into logical partitions and by virtual machine monitor . Thereafter control is transferred to the boot strap code with the boot strap code then loading the open firmware and RTAS. The processors associated or assigned to logical partitions and are then dispatched to the logical partition s memory to execute the logical partition firmware.

Partitioned hardware includes a plurality of processors a plurality of system memory units a plurality of input output I O adapters and storage unit . Each of the processors memory units NVRAM storage and I O adapters may be assigned to one of multiple logical partitions and within logically partitioned platform each of which corresponds to one of operating systems and .

Virtual machine monitor performs a number of functions and services for logical partitions and to generate and enforce the partitioning of logical partitioned platform . Virtual machine monitor is a firmware implemented virtual machine identical to the underlying hardware. Thus virtual machine monitor allows the simultaneous execution of independent OS images and by virtualizing all the hardware resources of logical partitioned platform .

Service processor may be used to provide various services such as processing of platform errors in logical partitions and . Service processor may also act as a service agent to report errors back to a vendor such as International Business Machines Corporation. Operations of the different logical partitions may be controlled through a hardware system console . Hardware system console is a separate data processing system from which a system administrator may perform various functions including reallocation of resources to different logical partitions.

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the illustrative embodiments may be applied to a multiprocessor data processing system other than the symmetric multiprocessing SMP system mentioned previously without departing from the spirit and scope of the present invention.

LPARs and may communicate with one another through virtualization layer . Virtualization layer may be software that performs communications and resource management to allow multiple instances of OSs and to run on logically partitioned data processing system at the same time. Virtualization layer performs tasks such as processor time slice sharing memory allocation or the like. Virtualization layer may be for example a hypervisor or a virtual machine monitor such as virtual machine monitor of .

Each OS and registers with virtualization layer a virtual processor area VPA for each of the particular OS s assigned virtual processors and or . VPA is a per virtual processor two way communication area between the particular OS and and the virtualization layer . VPA includes several fields of information pertaining to its corresponding virtual processor or . One of the fields included in VPA is an idle flag. Typically when OS or enters its idle process the particular idle OS sets the VPA idle flag. When work becomes again available for the corresponding virtual processor or or when an interrupt is received on the corresponding virtual processor or the OS or corresponding to the interrupted virtual processor clears the VPA idle flag.

In this example logically partitioned platform may comprise dedicated LPARs and shared LPARs and and virtual processors and within partitioned hardware under control of virtualization layer . Virtual processors and may be dedicated resources and may be assigned to dedicated LPAR as whole units by virtualization layer . Virtual processors and may also be dedicated resources and may be assigned to dedicated LPAR as whole units by virtualization layer . However virtual processor and may be part of shared processor pool and may be configured by virtualization layer based on the requirements of shared LPARs and . That is virtualization layer may allocate one or more of virtual processors and from shared processor pool to shared LPARs and .

As an example of the decisions made by an operating system within logically partitioned platform an operating system such as OS determines whether the workload for virtual processors and is below a certain threshold i.e. when a executing thread in a dedicated LPAR of OS is idle . If OS determines that the workload for virtual processors and of dedicated LPAR is below the predetermined threshold OS calls virtualization layer in order for virtualization layer to place the CPU corresponding to virtual processor or in a deeper low power idle state. On IBM POWER Architecture Platform Reference PAPR platforms this call to virtualization layer is named h cede since OS is ceding control of its virtual processor or .

When OS calls virtualization layer to place an idle virtual processor or in an idle state OS has a particular expectation regarding the virtual processor s latency of exit from its idle state. According to one example OS chooses either virtual processor or for this example virtual processor for folding. Processor folding is a technique used by an OS to steer work away from one or more of its virtual processors. As the CPU utilization of a logical partition decreases below a threshold the OS will fold a virtual processor. In this regard OS prevents any further workload to be queued up for chosen virtual processor disables interrupts to processor . Alternatively if OS determines that processor is folded and the workload for processor is above a certain threshold then OS chooses virtual processor for unfolding and enables interrupts to virtual processor which allows work to be queued for virtual processor or the like.

Folding unfolding decisions are evaluated by the OS on a time scale of seconds. Processor folding in micro partitions helps with the performance of the shared processor pool by reducing dispatching. Processor folding in dedicated processor partitions helps with a power savings and or b improved donation to a shared processor pool.

According to the example above if OS folds its virtual processor OS generally has no expectation that virtual processor will respond to Input Output I O or timer interrupts. Moreover OS expects to regain control of virtual processor in at most for example one second after virtual processor is awakened by OS . However in other exemplary idle management scenarios the OS may tolerate a latency of only a few micro seconds when the virtual processor exits its idle state and the OS expects the same latency when the virtual processor is presented an I O or timer interrupt.

To ensure that OS determines the correct idle state that is to be assigned by virtualization layer to an idling virtual processor a Cede Latency Settings Information CLSI system is generated by virtualization layer and communicated to OS . The CLSI system parameters data inform OS of the maximum latency to wake up from the various platform supported processor sleep states that OS might employ for its virtual processors and . Referring now to an exemplary record of a CLSI table is shown according to one embodiment of the invention. In practice CLSI table includes a plurality of records each record corresponding to a particular platform supported idle state. However for purposes of simplicity a single record of the CLSI table is shown. Record corresponds to a generic idle state. In general the number of idle states and the latency of exit out of the idle state will vary with processor implementation and therefore from platform to platform.

According to one implementation the idle states are known as Doze which is the shallowest idle state Nap which is the idle state of intermediate depth and Sleep which is the deepest idle state. The Doze idle state loses the least amount of processor resources has the lowest latency of exit and saves the least amount of power. At the other end of the spectrum of idle states the Sleep state loses the most processor resources has the highest latency of exit and saves the most amount of power.

The record in a generic CLSI table includes various fields that are ordered in a NULL terminated parameter string. The first field titled Cede Latency Specifier Value identifies the particular idle state that is described e.g. Doze Nap Sleep etc. . The second field titled Maximum Wakeup Latency in Time Base Ticks identifies the maximum amount of time that it takes for a virtual processor to exit its idle state. The third field titled Virtual Processor Responsive to . . . identifies a particular event such as an external interrupt which may or may not reactivate the idle virtual processor. Reactivation depends upon the particular idle state that is assigned to the virtual processor which takes into account the policies and workloads that are present. This ensures that gratuitous wakeups of the idle virtual processor are avoided. Each of fields is associated with a field length reflected in column and a particular value reflected in column .

The CLSI system is independent of the number of idle states implemented by a processor implementation and the physical characteristics of the idle state e.g. exit latency of the virtual processor . Furthermore the CLSI system can accommodate partition migration across computer systems having different processor implementations.

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in any one or more computer readable medium s having computer usable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CDROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in a baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Computer code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable radio frequency RF etc. or any suitable combination thereof

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java language Smalltalk language C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to the illustrative embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions that implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring now to these figures provide flowcharts outlining example operations of controlling the depth and latency of exit of a virtual processor s idle state in accordance with an illustrative embodiment. While are described in relation to only one OS assigning an idle state to a single virtual processor one of ordinary skill in the art would realize that the operation may be performed with any number of operating systems which can assign via e.g. a hypervisor a particular idle state to any number of virtual processors for any number of partitions without departing from the spirit and scope of the invention.

The flowcharts or block diagrams in illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to one embodiment of the present invention. In this regard each block in the flowcharts or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in . For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

As noted above it should be appreciated that the illustrative embodiments may take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In one example embodiment the mechanisms of the illustrative embodiments are implemented in software or program code which includes but is not limited to firmware resident software microcode etc.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

