---

title: Compliance rules analytics engine
abstract: The present invention relates to compliance rules analytics systems and methods for facilitating compliance, such as the compliance of an investment portfolio or a set of investment portfolios, with a rule or a set of rules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08631033&OS=08631033&RS=08631033
owner: Taiwan Semiconductor Manufacturing Company, Ltd.
number: 08631033
owner_city: Hsin-Chu
owner_country: TW
publication_date: 20120130
---
This application is a continuation of U.S. patent application Ser. No. 12 576 785 filed on Oct. 9 2009 entitled Compliance Rules Analytics Engine which is a continuation of U.S. patent application Ser. No. 11 253 273 filed on Oct. 18 2005 entitled Compliance Rules Analytics Engine now U.S. Pat. No. 7 603 358 which claims priority to U.S. Provisional Application Ser. No. 60 654 667 filed on Feb. 18 2005 entitled Compliance Systems and Methods which applications are hereby incorporated herein by reference in their entireties.

Applicants hereby submit computer program listings on a compact disc 2 copies Copy 1 and Copy 2 of which are submitted herewith. Each copy of the CD contains a master folder entitled Macgregor Tabet CD Contents having a size of 33 MB and having been created on Oct. 10 2005. The master folder contains a folder entitled XIPWS having a size of 33 MB and having been created on Oct. 10 2005. The XIPWS folder contains the following folders a 3party folder having a size of 1.33 KB an App folder having a size of 403 KB and a Common folder having a size of 32.6 MB each of the folders having been created on Oct. 10 2005 and each of the folders and all of the files contained in those folders and on the CD being incorporated herein by reference in their entirety. A complete listing of all files contained on each copy of the CD their date of creation and the size of each of those files is attached as Appendix I.

The present invention relates to rule based systems e.g. portfolio compliance rule based systems. Portfolio compliance is a unique challenge because it requires maintenance of potentially millions of aggregations with fast impact analysis of any proposed transaction set. An aggregation is a combination of positions e.g. positions owned or controlled by a single trader or group of traders that one can use to ensure compliance with rules such as regulations. A position is the amount of a security either owned which constitutes a long position or borrowed which constitutes a short position .

Because the mapping between proposed transaction sets and a set of affected aggregations is not explicit a compliance architecture must support an efficient matching calculation and identification of affected aggregations to provide fast impact analysis and explicit reporting. The mapping is not explicit because the aggregations and the proposed transaction sets are both dynamic e.g. changing over time. Many of these aggregations are comprised of hundreds or thousands of data values across a variety of data structures and sources.

Investment activity in large firms involves tens of thousands of daily transactions affecting a variety of aggregations. The requirement for effective pre trade compliance is to quickly identify the impact of each set of transactions without adding delays to the investment process.

Conventional systems have not achieved comprehensive real time scalable portfolio compliance. Only a small percentage of the portfolio compliance rules typically less than about 10 are evaluated in real time. The large majority of compliance rules are checked only in a post trade post mortem basis. Such post mortem checking means that violations are only detected after the fact and millions of dollars are put at risk or wasted in preventable errors. The primary impediment to implementing preventive measures is that current solutions do not provide the performance level and scalability needed to evaluate the status of portfolio compliance as part of real time investment processes. Moreover the business challenge is getting worse since most organizations have to deal with increasing volumes. Industry trends towards separately managed accounts and increased market regulation will continue to raise the performance thresholds that compliance solutions need to clear before they can be practically integrated into real time investment processes.

From a technology perspective existing devices are based on non scalable and mostly stateful designs. In addition prior methods typically restrict their choice of technologies to a small set of programming models. Typically portfolio compliance systems are built on procedural language frameworks like C combined with relational database management systems. These systems do not achieve and thus a need remains for practical real time scalable portfolio compliance.

The present invention relates to rule based systems and methods e.g. rule based systems and methods for achieving portfolio compliance. One embodiment of the invention provides a compliance rules analytics system including a rule editor operative to receive rule related data and to convert the rule related data into intermediate format data a rule translator in communication with the rule editor and operative to receive the intermediate format data and operative to translate the intermediate format data into executable format data and a compliance analytics engine CAE in communication with the rule translator and operative to receive the executable format data and to perform a compliance evaluation based at least in part on the executable format data the evaluation being performed using at least in part a RETE based process.

In one embodiment the CAE includes compliance services operative to receive a check compliance message from a request queue a rules engine in communication with the compliance services and operative to receive a do inference message from the compliance services and to execute executable format rule related data and business objects in communication with the rules engine. The business objects include a data sensor in communication with the rules engine and operative to receive a get static data request from the rules engine and to return static data to the rules.net engine and an aggregate sensor in communication with the rules engine and operative to receive a get aggregation data request from the rules engine and to return aggregation data to the rules engine.

Another embodiment of the invention provides a method for performing a compliance evaluation. The method includes receiving rule related data for portfolio compliance rules obtaining aggregation data from an online analytic processing component and performing a portfolio compliance evaluation based at least in part on the rule related data and the aggregation data the evaluation being performed using at least in part a RETE based process.

Yet another embodiment of the invention provides a compliance rules analytics system including rule editor means for receiving rule related data and converting the rule related data into intermediate format data rule translator RT means in communication with the rule editor means the RT means for receiving the intermediate format data and for translating the intermediate format data into executable format data and compliance analytics engine CAE means in communication with the RT means the CAE means for receiving the executable format data and for performing a compliance evaluation based at least in part on the executable format data the evaluation being performed using at least in part a RETE based process.

The present invention relates to rule based systems e.g. such as rule based systems for ensuring portfolio compliance. is a deployment diagram for one embodiment of a system according to the invention. With reference to the illustrated embodiment includes a web server application server coupled to a database server having data sources . The application server has a business logic layer that includes business services components and business package components . The business services components include rules management services compliance services rules engine services application service and exception management services . Similarly the business package components include a rules management package a compliance package a rules engine package an application package and an exception management package .

The application server also has data access components including business objects BO data access interface and data access components DAC . The Data Access Components DAC are a set of components implementing data access functions in a data access layer DAL . The DAL exposes the data stored in databases to the business logic layer shown as element in . The Business Objects abstract domain objects domain data from specific database technologies platforms . In addition the application server has a session management component a repository component and a messaging services component .

The application server also has presentation layer server side components including a Push to Browser PTB server and a page manager . The application server interfaces with a client PC . The client PC has presentation layer client side components including view components controller components and a fa ade . The fa ade interfaces with the business logic layer and the controller components interface with the presentation layer server side components .

In other words with reference to The Web Application Server interacts with the database server and its data sources . It also communicates with the client and presentation layer components . The Web Application Server components include session management a repository messaging services the presentation layer server side components the business logic layer and finally the data access components . The business logic layer has two sets of components Business Services Components and Business Package Components . The Business Logic Layer communicates directly with the client layer and interfaces with the Data Access Components. While the Business Services Components provide a web services interface to the business logic Business Package components are the components that implement the actual business logic. The Business Package components have a one to one relationship to the business services provided by the system. Each package may access functionality implemented in other packages and reuse those implementations.

In operation the presentation layer client side components implement the user interface functionality such as viewing account data rules and compliance results. These components interface with presentation layer server side and allow the PTB Server to push data from the server to the web client page and allow the page manager to manage of page layouts. Session Management and Messaging Services are conventional application server infrastructure components. The Business logic layer interfaces with the client side presentation layer. Its main function is to provide components implementing the application business logic. In one embodiment the system aggregates Business Services and Business Packages in order to provide business logic for portfolio compliance clients. A business service is a standard web service and is coupled to a single business package. A business package implements specific functionality application business logic such as check compliance generate reports and persist exception violations . In one embodiment a business package is based on conventional .NET enterprise service technology available from Microsoft Corporation of Redmond Wash. Business logic layer interfaces with data access components which encapsulate all data access logic. The Data Server component is a conventional database server MS SQL Server for example 

With reference to one embodiment of the component structure for the system of includes business logic BL compliance components in communication with data access components also shown in . The data access components are in turn in communication with data server also shown in . The BL compliance components include compliance services in communication with compliance rule engine services which are in communication with business objects . The component Data Access provides an interface for accessing data storage and retrieving data to the compliance components via BO data access interface .

The compliance services include validation services rules and transactions and check compliance services . Validation services checks a rule to confirm that the rule conforms to a particular grammar and check compliance services confirms that a proposed trade or set of trades complies with a rule or set of rules. The compliance check generates a pass fail status where fail means that a rule is violated. Whether the compliance check generates a pass or a fail status the system returns calculated values if any to show how proposed transaction violates a rule. In one embodiment the compliance rule engine services include a rules.net engine and a rules.net application programming interface API . .NET is a Microsoft operating system platform that incorporates applications.

The business objects include aggregate objects aggregate sensor domain objects and a data sensor . Compliance services are in communication with the data sensor . The two components communicate internally using an interface API and exchange data from the domain model e.g. securities positions account information represented as C objects.

The BL compliance components further include rule repository services . The repository services include deployment services and a repository service application programming interface API .

In one embodiment the data access components include an online analytical processing OLAP .service.net service primarily responsible for OLAP refresh and one implementation of OLAP.service.net is based on the Microsoft Decision Support Object DSO package. OLAP is computer processing that enables a user to easily and selectively extract and view data from different points of view. For example a user can request that data be analyzed to display a spreadsheet showing all of a company s suntan lotion products sold in Massachusetts in the month of August compare revenue figures with those for the same products in October and then see a comparison of other product sales in Massachusetts in the same time period. To facilitate this kind of analysis OLAP data is stored in a multidimensional database.

MOLAP multidimensional online analytical processing is OLAP that indexes directly into a multidimensional database. In general as noted above an OLAP application treats data multidimensionally the user is able to view different aspects or facets of data aggregates such as sales by time geography and product model. If the data is stored in a relational database it can be viewed multidimensionally but typically only by successively accessing and processing a table for each dimension or aspect of a data aggregate. MOLAP processes data that is already stored in a multidimensional array in which all possible combinations of data are reflected each in a cell that can be accessed directly. For this reason MOLAP is for most uses faster and more user responsive than relational online analytical processing ROLAP the main alternative to MOLAP.

The data access components further include an OLAP.client.net service . This service accesses aggregate data from within the left hand side LHS of a rule i.e. the condition part of a rule . In other words this service accesses data based on the expression contained in the LHS side of a rule. The following is an example of a rule using 2 aggregates in its LHS. This rule implements a money Markey fund compliance rule 

In addition the data access components include a DB.client.net service . This component is a database client and provides data source connectivity and access.

The data server includes a MOLAP ROLAP component and a database that includes an application database and rule repository .

The OLAP.client.net service generates objects that the system matches against specified properties for the left hand side of a rule. One example of an aggregate object includes the following information measure holds the value of the aggregate as returned by OLAP key represents the kinds of aggregate value here 10.3.0 means account total market value and slicevalue here the system sliced the data based on the account ID this is just an input to OLAP . The OBJECT variable holds a pointer to the aggregate so the system can use it in the rule where it is declared 

The Business Objects layer deals with aggregate objects and with domain objects. A domain object is an object containing data of interest to the system a domain object is an object from a domain model. A conventional domain object encapsulates business rules and logic. A Domain Model creates a web of interconnected objects where each object represents some individual entity the individual entity having meaning to the system. The individual entity can be as large as a corporation or as small as a single line on an order form. In the present invention the rules are separate from the domain objects.

Using service rules the Compliance Engine generates aggregate objects dynamically based on the rules needs. The conditions of each rule match on specific objects. Furthermore one who creates a rule can assign compliance rules to specific accounts. The combination of this information allows a compliance engine according to the invention to create instantiations of aggregate objects at runtime as the rules fire for a given account or accounts Similarly the system creates domain objects using the data sensor layer. Domain objects are created similarly to aggregate objects based on rules conditions referring to specific classes of data for given accounts . The engine uses the data sensor to issue a conventional query to the database and fetch that data. The object instances are then created from the returned data. This is not a standard command in C Jess C is a programming language and Jess is a general purpose rule engine . The aggregate object and domain object messages contain object instance data values according to the attributes of those objects and their types. Examples of such domain objects include securities position data and account details. An asset object has attributes such as an asset ID a short name an asset type code an issuer ID a primary exchange code price currency code and votes per share. At runtime given one or more accounts and their specific properties or constraints for example a money market account we only create object instances related to such a context. This allows the system to load only necessary data objects and optimize memory usage. One could imagine generating SQL code to query the data sources before running rules but such an approach is not efficient.

The Rules.NET library is an API allowing various levels of access to the Rules.NET engine execution environment and object model. The library a DLL allows a Rules.NET user to observe manipulate the operation of the rules engine. As an example a user can see the rules being selected for execution new facts that have been created data that has been updated and the number of rules that have been fired. The Library a dynamic link library or DLL can be used by various components to build services. A dynamic link library is a library which is linked to application programs when they are loaded or run rather than as the final phase of compilation. The Compliance Engine Gateway Compliance Services interface is a bridge allowing the integration and interaction between the compliance engine component can be referred to as a compliance engine or as compliance rules engine services one uses the term services in the context of APIs and interfaces and one uses the term engine in the context of components and external components and services such as an order management system OMS . It is the entry point for compliance checking on a proposed set of orders or a list of transactions. The gateway provides low level validation such as data type checking integrity check and other validation tests such as checking if the input transaction set exists already. The gateway is also used to retrieve the results from the underlying engine and stores them in the database using the data access layer interface. DB.CLIENT.NET is an API used for data access by components of the system. The engine s data sensor uses this interface to retrieve security data for example and other domain model objects as needed. OLAP.CLIENT.NET defines the interface to access aggregate data in the OLAP server using the engine s aggregate factory. The retrieved aggregate data is also transformed into objects using this interface and asserted as facts into the engine s working memory. OLAP.SERVICE.NET is primarily responsible for OLAP refresh. This component defines an API facilitating its configuration and the management of multiple OLAP cubes installations. It also provides a method to set a refresh interval as a default or per declared cube. A cube update service can be turned off for example in the case of overnight cycles. The overnight cycle is a process that takes place at a scheduled time after the end of day after the market closes . It includes any processing on carry over orders changes to data generation of reports on all activity that happened that day and in some cases tests all rules against the data and generates reports on compliance checks at that point as well. Rules.NET Engine Rules NET is a J port of the Java based Jess rule engine. J is a Microsoft supported language for .NET. J is Microsoft s implementation of the Java programming language. As noted above .NET is a Microsoft operating system platform that incorporates applications. Rules.NET adds an extended API to allow for an easy integration with the platform. one can practice this invention using any Production Rules Engine that supports .NET platform or Java platform. The following table describes the component information 

With reference to The OLAP client sends multi dimensional expression queries to OLAP cubes and receives datasets in response. Similarly data sensor performs read write operations on the database .

With reference to major software components of one embodiment of a system according to the invention include a business rules definition component e.g. a natural language grammar and a Rule Editor . In operation organizations can define complex business rules using application specific languages and tools e.g. a natural language compliance grammar and a Rule Editor best suited to the task. Appendix II provides one embodiment of a rule grammar specification for a structured standard grammar language close to Backus Naur form BNF standard syntax. Using this specification a person of ordinary skill in the art can create a rule editor and a natural language grammar that support the rule expressions provided in the compliance engine of the present invention.

Returning to the rule editor converts the business rules into a machine readable application and technology independent format e.g. Rule Object Model format . The intermediate representation format allows other applications to share and reuse a defined business rule and for system developers to deploy the rules on alternative execution environments. A Rule Translator RT receives the intermediate representation format of the business rules and translates the business rules from the application and technology neutral format into an equivalent format suitable for high performance execution in a specific runtime environment i.e. in the Compliance Analytics Engine proper . In other words one of the RT s outputs is an equivalent format e.g. a C Language Integrated Production System or CLIPS rules format of the compliance rules. The Compliance Analytics Engine CA engine receives the CLIPS Rules as an input. CLIPS is a language for developing expert systems with support for forward chaining rule based object oriented and procedural programming.

In addition in the illustrated embodiment the RT extracts and persists the Rule Attributes properties of the rule so that the rest of the system can directly access that information. In other words the RT outputs Rule Attributes RA . The RA interface exposes a set of static basic properties of each rule that user interface UI applications require for display purposes. These properties can include a complete list of domain attributes referenced by the rule in question and information on how to navigate the attributes. The Security Asset Code from the security business object or the safe harbor date on the Account business object represent two examples of domain attributes referenced in regulatory rules U.S. regulations as an example . There are other attributes regarding account properties e.g. taxable or not taxable and national or state .

The RT also generates a Relevance Filter RF function for each translated rule. The RF is an executable function unique for each rule. In one embodiment in the portfolio compliance context the RF receives as input a set of identifiers for securities and determines which of the securities if any contribute to the possible failure of that rule. A relevance filter is a function tightly coupled to the rule and in one embodiment is written as C standard query language SQL code. One adds these filters to support post compliance functionality. Here is an example of such code 

Once the CA engine receives the CLIPS rules the CA engine evaluates and records the status of portfolio compliance with respect to the assigned rules in near real time. In other words an output of the CA engine is compliance status . A compliance workstation accesses the rule attributes and the compliance status information to perform in depth analysis and reporting.

With reference to a high level diagram of one embodiment of the compliance analytics engine execution runtime environment shows a client posting a request to a request queue . A listener component picks up the next request in the queue. The specific request is associated with a compliance analytics engine thread . A thread includes placeholder information associated with a single use of a program that can handle multiple concurrent users. From a program interface perspective a thread is the information needed to serve one individual user or a particular service request. If multiple users are using the program or concurrent requests from other programs occur a thread is created and maintained for each of them e.g. a plurality of threads are created.

With reference to A and A one embodiment of a compliance service receives e.g. from an inventory management service IMS via the request queue and listener a check compliance request associated with thread . The compliance service passes a do inference request to a rules.net component . The rules.net component sends a get static data request to the data sensor . In response the data sensor returns static data to the rules.net component . The rules.net component also sends a get aggregation data request to the aggregate sensor . In response the aggregate sensor returns aggregation data to the rules.net component .

The DoInference call in is a call for the engine to fire rules. The rules.net component creates exception data e.g. data regarding aspects of a portfolio and or a set of trades that do not comply with deployed rules. The rules.net component passes the exception data back to the compliance service which in turn passes a persist evaluation data request to a post compliance component . The post compliance component passes an update compliance state request to the data sensor and the compliance service passes a post result request to the response queue .

With reference to another embodiment of the operation of the system of includes the compliance services receiving a transaction set from an order management system OMS . The compliance services perform a check transaction list function and a validate transaction list function. The compliance services then send a load Business Objects request to the compliance engine CE e.g. the rules.net engine. The CE performs an assert facts function sends a get security data request to the data sensor and a get aggregates request to the aggregate sensor . In response the aggregate sensor passes a get OLAP data request to the OLAP client which sends a return OLAP data message in response. The aggregate sensor in turn sends a return aggregates message to the CE .

When the CE receives a do inference request from the compliance services the CE executes a fire function and returns results to the compliance services . The compliance services send a save results request to the data sensor and send a return results message to the OMS

With reference to one embodiment of a system according to the invention includes Service Rules and a Knowledge Management Framework. The Rule Translator element of generates the Service Rules. Service Rules provide a fast and flexible mechanism for accessing data elements needed for rule evaluation. The Knowledge Maintenance Framework KMF combines traditional object oriented and relational programming models with declarative rules and online analytical processing OLAP programming models into a common development platform.

A rule is a kind of instruction or command that applies in certain situations. For the purposes of this document one embodiment of a rule has a left hand side LHS i.e. a predicate or premise and a right hand side RHS i.e. an action or conclusion. One can imagine a rule without a LHS no conditions which one could interpret to be a fact or without a RHS no action which one could interpret to be a query. The Service Rules provide a meta evaluation level to efficiently optimize the calls to OLAP from the left hand side condition part of each compliance rule that is a candidate to be evaluated. In conventional OLAP usage a procedural integration component would be built and used to access data in OLAP. Such an approach would require many calls and overhead. According to one embodiment of the invention a user of the system can declare that a rule needs certain types of aggregates. When the rule matches on specific account information for a given rule it will then generate an instance of the aggregate object and use the parameters of the instantiation to call OLAP. OLAP will then return the results for example a measure of the total market value for a given account. The system reuses such result in compliance rules to then check compliance status for example a rule checking that a mutual fund market value for a given industry must be under 5 of the total of the account . The use of service rules evaluated first before the compliance rules filters unneeded data and information.

Metadata objects are objects used to define other objects. By creating metadata objects to represent aggregate instances and using them declaratively from within the left hand side of the rules Service Rules provide a bridge between the analytics system e.g. an OLAP system and the rules inferencing mechanism. An aggregate object which is a metadata object is used in the condition LHS part of a rule. The statement is declarative and not procedural where one would have to call a routine to communicate with OLAP.

One embodiment of the Service Rules bridge integrates the results of the analytics OLAP processing directly into the inferencing mechanism i.e. the Rules Engine in . The engine not only processes domain data but it also matches on the declaratively defined aggregations specified in services rules not executed in procedural methods . This matching allows for a seamless integration of OLAP and the inference engine. Typical methods would only focus on procedural execution sequential execution of OLAP queries and then follow that procedural execution with rule engine processing.

Aggregations are declaratively defined since they are described as conditional patterns in service rules in one embodiment service rules are the rules the system fires before the compliance rules . Consider the following compliance business rule A money market account cannot own more than 5 of its total market value in technology. The aggregate objects two in this case return the total market value for the account and the total for the account for tech assets only. This information is then used by the compliance rules to check the 5 condition. The matching of patterns against available data is part of the engine s function and the architecture of one embodiment of the present invention makes sure the system matches first on service rules and then compliance rules which means in this cases aggregates are created first and populated with the results from OLAP and then compliance rules are tested .

Another aspect of the invention is the fact that the rules are operating independently from the OLAP implementation. Declarative programs such as certain rule based programs describe what the computer should do but omit much of the instructions on how to do it leaving the runtime system to fill in the blanks.

Service rules reuse the same RETE based forward chaining rule execution mechanism as the business rules. The Rete algorithm is an efficient pattern matching algorithm for implementing rule based expert systems . In other words a RETE based forward chaining rule execution mechanism is used to determine whether to execute a particular business rule for a given set of facts. Service rules use the same RETE based forward chaining rule execution mechanism to determine an efficient way to access the data that is to be tested to determine if a particular business rule should be executed. The RETE algorithm provides a two phase optimization of its network. The Rete algorithm is described in a paper by Charles Forgy entitled Rete A Fast Algorithm for the Many Pattern Many Object Pattern Match Problem published in Artificial Intelligence 19 pp 17 37 1982 and incorporated herein by reference in its entirety. Service rules contain conditions that are satisfied at runtime allowing the selection of which data to load and filtering any unneeded data and objects.

The architecture appears as if there was a rule engine inside the rule engine. The present invention allows the engine running compliance rules to be driven by the inference process applied to metadata on accounts portfolios securities and other business objects When such meta rules fire one can refer to these meta rules as service rules they generate data objects in an efficient way only the data needed is generated allowing the compliance rules to be fired and the compliance check to be executed. As noted above is a high level diagram of the compliance analytics engine execution runtime environment. The path from Services Rules to the OLAP calculation implementation is supported by the Aggregate Sensor shown as element in . The Aggregate Sensor acts as an object factory used to create aggregate objects integrated to the compliance domain object model.

Each aggregate class is generated using an OLAP multi dimensional expression MDX query markup. MDX was created to query OLAP databases and has become widely adopted within the realm of analytical applications. MDX is a standard for issuing queries to and exchanging data with multidimensional data sources. At runtime the instantiation of each instance in the engine is what enables the implementation of the bridging between the rules and the OLAP queries empowered by the choreography of Service Rules. In other words once a rule is evaluated against the facts at a particular point in time the service rules can efficiently access the necessary data based on the present state of the rule and the present state of the data by using the Rete algorithm. The instantiation and the evaluation of the rules enable the system to focus on specific OLAP cells at any point in time an OLAP cell represents a single aggregate value in any dimension . The Service rules are efficient because they use the Rete algorithm to take advantage of the context data.

The Rete algorithm is a network linking all the conditions of the rules that are deployed in the compliance engine. Rete is a fundamental algorithm for production rule systems. The way Rete is structured it remembers the instantiation of the conditions using the current facts and therefore can decide which rules are ready or are close to being ready to fire. As an example consider a rule that needs to check compliance for an account against a rule restricting trading in technology in certain countries. These conditions are used in service rules to only load specific data from the database for this account. Compliance rules are then applied only against the returned data as opposed to loading all the data related to that account as is done by many other systems.

Service Rules help to satisfy the demanding performance and scalability requirements of portfolio compliance. Most data intensive applications make extensive use of data caching schemes in order to satisfy performance requirements. However the open ended nature of user defined business rules combined with real time changes to portfolio information and the need for scalability renders conventional data schemes inefficient and even counterproductive.

To amplify on this last point user defined business rules can apply to arbitrary data sets and aggregations and therefore data access patterns are typically unknown at design time e.g. one organization may want to limit client portfolio investment in any security with more than 10 sales exposure in any one country except for those countries with GDP growth greater than 3 . In one embodiment the compliance rules analytics engine design begins to get around the classic performance limitations of ad hoc data analysis by leveraging the power of commercial OLAP engine technology to enable fast on the fly generation of arbitrary aggregations. An aggregation in the OLAP context is a composition technique for building a new object from one or more existing objects that support some or all of the new object s required interfaces.

One embodiment of the invention uses a Microsoft Analytic Services engine e.g. one could purchase a Microsoft SQL Server 2000 Analysis Services platform from Microsoft Corporation of Redmond Wash. and load it onto a server as part of performing the methods of the present invention. Alternatively other OLAP engines could be used to practice the present invention.

In addition for every business rule defined the rule translator module generates a set of service rules that define the data access rules associated with executing that business rule. The RT generates both service and business rules starting from the natural language. For each template rule mapped to the natural language expression there is a corresponding service rule defining the data objects needed for such a template. The instantiation of the templates to real rules happens at translation time and the instantiation and creation of data access objects happens at runtime as a result of the engine executing the service rules. In essence the compliance engine caches the data access strategy. Moreover because the rules engine is RETE based it naturally optimizes the data access strategy defined declarative in the service rules. A data access strategy in this context refers to the algorithm useD to query and retrieve specific data from the database at a given point in time during the compliance check process. As an example assume the system is checking compliance for a money market account. Since one embodiment of the system uses service rules therefore declaratively stating the conditions for data access the system can target specific data to load for this account only and not others. Further this embodiment of the system will only load the data needed by the rules used by this account.

The RETE algorithm does not distinguish between business logic rules and data access logic rules and it optimizes them just the same. The optimization is a property of the algorithm itself. As noted above the Rete algorithm is described in a paper by Charles Forgy entitled Rete A Fast Algorithm for the Many Pattern Many Object Pattern Match Problem published in Artificial Intelligence 19 pp 17 37 1982 and incorporated herein by reference in its entirety. The algorithm builds a network of nodes where each node represents the patterns or the conditions of each rule this is the case for both the service rules and the compliance business rules of the present invention .

As noted above the arbitrary nature of user defined business rules would make it difficult if not a practical impossibility to generate optimal data access schemes at design time.

The RT translates service rules into CLIPS rules shown in . More precisely in one embodiment the RT ultimately translates or compiles all rules as CLIPS rules. Thus the RT translates service rules to CLIPS format before the Rules.NET Engine executes the rules.

The following paragraphs describe the process of translating a rule from a UI RuleGist format to executable rules. One part of translation involves resolving the intent of a rule against the rule created by the editor.

Because of the natural language presentation of a rule rules are open to interpretation from simple rules with several conditions to complex rules with parenthetical.

The following steps explain in detail the process for creating rules using the UI RuleGist. In some cases we refer to the implemented application classes. Details on each one of the classes are given in the next section. Some of these steps can be viewed as a recommendation on best practices 

With reference to a Knowledge Maintenance Framework KMF integrates the OLAP cube models MDX queries Service Rules Business Rules the Object Oriented domain representation and the Relational Domain Model into a common semantic platform. represent one embodiment of a design of the system s knowledge structure. This design defines the data store of elements of the KMF as well as the operation of the system. In connecting A and B to the knowledge structure relates to the data access server and BL components and to the editor . illustrates one embodiment of a compliance check process including the editing starting with the user entering rules using the editor to the translation to the internal representation of rules to the runtime where a compliance status is generated. The overall structure of the system is shown in .

With the KMF the present invention provides a semantic integration of all the elements in use. The present invention does not have separate concepts used in completely different ways and concepts meaning different things in each model. To clarify one embodiment of the system uses a single XML schema tree structure to include all the elements making the knowledge base of the present compliance system. For example one embodiment of the KMF includes rules sql queries OLAP MDX queries all in the same uniform representation.

In one embodiment the Rules Analytics Engine integrates a variety of best of breed information processing technologies e.g. MDX queries OLAP and Rules.Net the .Net implementation of Jess In addition to those technologies already mentioned above one can obtain SQL Server .Net development tools and C programming language from Microsoft Corporation of Redmond Wash. . Each of the information processing technologies performs a certain kind of function and each supports a different model of operation with proprietary semantics. Many of these technologies have not been adopted widely enough to be subject to robust industry standardization. The semantic integration challenge implied by the combination of these technologies is likely a major reason why other organizations have not successfully pursued the approach implemented by the present invention. Integration is always a difficult task requiring advanced technology. In this invention multidimensional data and multiple sources add to the challenge. Semantic integration challenges include the translation of meaning from one model to another for example the queries described in OLAP the way the system uses the queries in rules and how the user understands the queries . Another example of a semantic challenge in compliance systems is translating from one data source s interpretation to another. The integration of the meaning from one source to another is a challenge. Declarative systems as supported in this invention help alleviate such issues because logical expressions conditions and other types of information are described declaratively and not encoded in procedures.

The framework of includes an MDX markup language capable of supporting a platform programming language and platform neutral OLAP statements. Platform in this context means software platform software environment. One example of a platform for use with the invention is Microsoft SQL Server 2000 Analysis Services. The expressiveness of the rule language is empowered by an extension to MDX query support the extension is achieved using an extensible markup language XML schema The XML schema can be used to write extended MDX queries. An MDX knowledge base defines and implements a set of generic templates used to generate OLAP queries in a platform independent manner. The queries can be represented in an OLAP language and in the C programming language. An MDX utility facilitates not only the editing and navigation of queries but also the testing and tuning of the performance of each query template. The MDX utility is a conventional application written in C . It allows the testing of MDX queries using conventional calls to OLAP systems. One can take the same MDX queries and run them directly in the OLAP system of their choice. illustrate the structure of the Knowledge Management Framework and the schema used to support OLAP integration.

One embodiment of the invention provides a flexible mechanism allowing the definition representation and deployment of MDX statements as part of the MLC knowledge base which includes business rules for compliance and domain data and metadata.

One embodiment of the invention provides an XML markup for MDX queries with an object centered approach. An XML document according to the invention integrates MDX statements Rules and other SQL statements together in the same environment An MLC XML document contains rules metadata mdx and sql 

An XSL transformer implements the translation layer from XML to MDX statements for execution. The MDX template navigator used to view and edit the list of available templates and their contents is similar to the explorer interface in windows. In one embodiment a feature is added to test and monitor the performance of each query and compare any changes that have been made and their performance with the previous version. The XSL transformer is written in standard XSL. Given the MDX XML schema one can write an XSL translator. The template navigator is a conventional C application.

The MDX markup language is a subset of the overall knowledge base markup shown in . MlcKnowledgeStore is one embodiment of a root element of an information set according to the invention the information set including data metadata queries and rules. More specifically MlcKnowldgeStore is a sequence of rulebase elements olapquerybase elements sqlquerybase elements domaindata elements and domainmetadata elements which is in turn a sequence of metadata elements .

The MDX subset starts with as its main root element. It is a sequence possibly empty of mdxquery elements. Each element represents a single mdx statement. With reference to element is a made of a header a body and a list of query parameters . Optionally it may also include a query test element used for testing purposes.

The element is the root element. It is a container for the sequence of MDX queries. It can also be empty since MLC knowledge bases may have no defined OLAP queries initially.

The element is defined as an optional and unbounded sequence of mdx queries. Each element is itself a sequence of three elements and . An optional fourth element is available for testing purposes. The header element represents the header information for a given mdx query. It is used for C code generation. Each header includes a parameter optional a description header summary and return values element . The element is an optional element describing declared header parameters. This element has two attributes name and type. The name is used for the parameter name and the type is used for the corresponding data type. In the following example one declares the parameter MeasureID of type Integer The element contains the description and comment for the defined query as shown in this example Select a measure by crossjoin of members The element contains a sequence of elements where each one of them represents a value returned by the execution of the mdx query. Here is an example with two columns Members and MeasureID 

With reference to a user can enter a rule via a Rule Editor User Interface UI . In the illustrated example the user has specified via a set of inputs e.g. drop down menus and input fields the following rule The weight based on Net Assets of investments where SecurityAssetCode is equal to CS must be less than 70 . 

One of the available representations for each rule is its text representation accessible from the Rule Editor. This is intended to be as close to the natural language expression of that rule as possible. Once the above rule is entered its text representation is 

 The weight based on Net Assets of investments where SecurityAssetCode is equal to CS must be less than 70 

The Rule Gist is the internal extensible markup language XML representation that the Editor and the Translator use to communicate with each other. As noted above Appendix II provides one embodiment of a rule grammar specification for a structured standard grammar language close to Backus Naur form BNF standard syntax. Using this specification a person of ordinary skill in the art can create a rule editor and a natural language grammar that support the rule expressions provided in the compliance engine of the present invention.

The Rule Gist XML representation is a hierarchical form that captures the structure of the rule along with all referenced values used by the editor. In our example the generated Rule Gist file is 

As noted above one of the Rule Translator s outputs is a set of CLIPS rules representing the translated Compliance Rule. The generated set in our example is attached here 

Simple Service rule that creates an internal list of all the referenced Security Asset Codes in this case it s just the one element list CS additional AND OR clauses in the original rule would cause this list to grow

From a technology perspective the present invention overcomes current problems associated with developing real time flexible and scalable portfolio compliance systems. The invention overcomes these problems through the successful integration of declarative rules and OLAP technologies. Service Rules and the Knowledge Maintenance Framework facilitate this success. The present invention integrates OLAP and Rules technologies to achieve scalable real time execution performance while maintaining a semantic range that is flexible enough to support user defined business rules. In other words one embodiment of the present invention integrates RETE base rules systems OLAP systems RDBMS systems Web Services Object Oriented Systems and procedural 3GLs e.g. C .

Having thus described at least one illustrative embodiment of the invention various alterations modifications and improvements are contemplated by the invention. Such alterations modifications and improvements are intended to be within the scope and spirit of the invention. Accordingly the foregoing description is by way of example only and is not intended as limiting. The invention s limit is defined only in the following claims and the equivalents thereto.

