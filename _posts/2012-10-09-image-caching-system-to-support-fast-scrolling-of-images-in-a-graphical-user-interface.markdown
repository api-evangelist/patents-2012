---

title: Image caching system to support fast scrolling of images in a graphical user interface
abstract: A system for image caching is described. The system may include a non-volatile memory to store encoded images, a volatile memory including an image cache, and a processing device to retrieve one or more of the encoded images from the non-volatile memory using a fetching thread, distribute the retrieved images to multiple decoding threads to decode the retrieved images, and store the decoded images in the image cache for use by a rendering application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501415&OS=09501415&RS=09501415
owner: Amazon Technologies, Inc.
number: 09501415
owner_city: Reno
owner_country: US
publication_date: 20121009
---
A large and growing population of users employs various mobile devices to view information about various products available on the Internet such as books movies electronics furniture toys clothing accessories and the like. Among these mobile devices are e book readers also known as e readers cellular telephones personal digital assistants PDAs portable media players tablet computers netbooks and the like.

Many online retailers present information about various products in the form of images e.g. images of book covers images of toys etc. . A user can view images of available or recommended products on a screen of a mobile device scroll through these images and then select a specific image to see more details about a respective product. As the quantity of products available on the Internet continues to grow finding inexpensive and effective ways to allow fast scrolling through a large number of product images on mobile devices continues to be a priority.

Described herein are methods and systems for caching images to support efficient image scrolling in a graphical user interface GUI presented on a screen of a mobile device. Images may graphically illustrate products provided or recommended by online retailers or other entities e.g. individuals other organizations etc. and may include for example images of book covers images of movie covers images of portable electronic devices images of furniture items images of toys and the like. Alternatively images may pertain to photographs collected or maintained by a user of the mobile device or other users. The mobile device may be an e book reader a cellular telephone a personal digital assistant PDA a portable media player a tablet computer a netbook etc.

A rendering application can allow users to scroll through images displayed on the screen of a mobile device. As a user scrolls through the displayed images additional images are getting prepared for presentation. Currently the preparation phase involves several time consuming operations. For example for rendering applications executed by the Java Virtual Machine JVM the preparation phase typically involves loading encoded images into a JVM heap memory decoding the loaded images and converting the decoded images into image bitmaps. These operations often result in a significant delay in the display of images. In another example for rendering applications utilizing OpenGL Open Graphics Library or other interfaces to interact with video hardware e.g. a graphics chip or a video card the preparation phase typically involves loading encoded images into a video dedicated memory memory dedicated to a graphics chip or a video card decoding the loaded images and converting the decoded images into image textures.

Embodiments of the present disclosure overcome the above deficiency by providing an optimized pipeline for decoding outside of the JVM heap memory or the video dedicated memory and by enabling caching of decoded images in the operating system memory and the JVM heap or video dedicated memory. Some embodiments of the present disclosure facilitate the reuse of bitmap objects or texture objects thus reducing time required for the conversion of decoded images into image bitmaps or image textures. In addition some embodiments of the present disclosure provide a memory mapped file MMF cache to persistently store decoded images which reduces the time for displaying an initial set of images when a rendering application is re started.

The mobile device includes a disk that stores encoded images e.g. Joint Photographic Experts Group JPEG image files Portable Network Graphics PNG image files etc. . The disk may be a non volatile storage device such as a hard disk a memory card a flash card or the like. The encoded images may be downloaded to the disk via a network e.g. from an online retailer or a content provider from local memory or from a removable storage device e.g. a USB flash drive . The encoded images may be stored in a cache e.g. L3 cache not shown in residing in non volatile memory of the mobile device.

The rendering application may send a request to load one or more images to the L2 cache . The rendering application may send such a request upon invocation or when it detects a user s scrolling command e.g. a user s gesture to scroll to the right or to the left on a touch screen or a user activation of a scrolling GUI control via a mouse or a similar cursor control device . The rendering application may identify specific images to be loaded e.g. by their file names . Alternatively the disk may store the images in a queue in a specific order and the rendering application may specify the number of images to be loaded and or their position in the queue e.g. first 5 images in the queue images 10 through 20 in the queue etc. . Yet alternatively the request to load one or more images to the L2 cache may be generated automatically in response to the removal of decoded images from the L2 cache . For example each time a decoded image is removed from the L2 cache a request to load a new image to the L2 cache is generated. In addition or yet alternatively when the image caching system detects that the execution of the rendering application is starting e.g. based on a signal received from the rendering application the image caching system may automatically request a predefined number of images to be loaded to the L2 cache .

Upon receiving the load request a fetching thread e.g. a process or a portion of a process executed by the CPU of the mobile device may be invoked to start retrieving fetching encoded images from the disk . Images are fetched sequentially one after another and then each fetched image is decoded using a decoding thread . Because fetching takes significantly less time than decoding e.g. fetching may take 2 to 5 milliseconds while decoding may take 60 to 70 milliseconds the image caching system uses several decoding threads to perform decoding of multiple images in parallel. Each processor or processor core of the mobile device may execute one or more decoding threads . The use of multiple decoding threads significantly reduces the time needed to prepare images for presentation by the rendering application .

The decoded images are then added to the L2 cache . In one embodiment as decoded images are getting added to the L2 cache the existing images are being removed evicted from the L2 cache . Alternatively the existing images are not removed from the L2 cache unless specifically requested by the rendering application . For example the application may send an eviction request and identify decoded images that should be removed from the L2 cache .

The L2 cache may include images to be displayed in the user view initially as well as images that are expected to be displayed in the user view subsequently in response to the user s scrolling operation. For example the L2 cache may include 8 images that will be displayed in the user view initially additional 5 images that are expected to be displayed in the user view subsequently if the user scrolls to the right and 5 other images that are expected to be displayed in the user view if the user scrolls to the left. The L2 cache may include a set of buffers that store the decoded images. As new images are added to the L2 cache the contents of the buffers are replaced with the new images data. In one embodiment when the rendering application sends a request to add an image to the L2 cache the rendering application specifies in the request an existing image that should be replaced with the new image. Alternatively the images are replaced based on the order in which they were added to the L2 cache or based on some other parameter s .

When the user performs a scrolling operation the rendering application sends a request to load decoded images to the L1 cache . The request may identify specific images to be loaded from the L2 cache or the L2 cache may store decoded images in a specific order and the rendering application may specify the number of images to be loaded and or the position of images in the L2 cache .

In response to the request to load images to the L1 cache the image caching system finds a bitmap object that matches the size of a requested image and uses the found bitmap object to create an image bitmap for the requested image. A bitmap object may be a Java object representing a buffer for storing image data in a format understandable by the rendering application . An image bitmap refers to the buffer filled with the image data. The image bitmap inherits parameters of the bitmap object including for example the size height and width the number of pixels in a row the number of rows etc. The image caching system maintains a pool of bitmap objects for creating image bitmaps for decoded images stored in the L1 cache .

In one embodiment if the image caching system does not find a bitmap object of the matching size in the bitmap object pool the image caching system creates a new bitmap object. In another embodiment the image caching system uses an existing bitmap object even if its size does not match the size of the requested object. In particular the image caching system uses a bitmap object of a larger size than the requested image to create an image bitmap for the requested image. The image caching system then fakes the size of the image bitmap e.g. by changing it to match the size of the image in order to force the rendering application to only display the portion of the bitmap that has image data in it e.g. to avoid a black boarder to appear around the image when the image is displayed in the GUI . For example if the image is 800 800 pixels and the bitmap object is 1000 1000 pixels the bitmap object will still be used for this image but the size of the image bitmap will artificially by clipping the edges be changed to 800 800 pixels thus reusing an existing bitmap object as opposed to spending time and resources on creating a new bitmap object.

The resulting image bitmaps are then added to the L1 cache . In one embodiment as decoded images are getting added to the L1 cache the existing images are being removed evicted from the L1 cache . Alternatively the existing images are not removed from the L1 cache unless specifically requested by the rendering application . For example the application may send an eviction request and identify decoded images that should be removed from the L1 cache .

In one embodiment the image caching system generates a notification each time an image is added to or removed from the L2 cache or L1 cache . This notification may be generated for the rendering application or any other program or component. In addition the image caching system may provide a list of images currently stored in the L2 cache and or a list of image bitmaps stored in the L1 cache . These lists can be provided automatically at certain times or in response to a request of the rendering application .

In an alternative embodiment not shown a rendering application is not a JVM based application but rather an OpenGL based application that uses OpenGL to interact with video hardware e.g. a graphics chip or a video card . An OpenGL based application operates by retrieving images to be displayed in the GUI from a video dedicated memory memory dedicated to a graphics chip or a video card . Hence in an OpenGL based image caching system an L1 cache resides in the video dedicated memory. Similarly to a JVM based rendering application an OpenGL based application can send a request to load decoded images to the L1 cache from the L2 cache. The L1 cache may use a pool of texture objects similarly to the bitmap pool . A texture object may be an OpenGL object in the form of a buffer for storing image data in a format understandable by the rendering application. An image texture refers to the buffer filled with the image data. The image texture inherits parameters of the texture object including for example the size height and width the number of pixels in a row the number of rows etc. The image caching system may create a new texture object for an image if the pool does not include a texture object matching the size of the image. Alternatively the image caching system may use a texture object of a larger size than the image to create an image texture for the image and fake the size of the image bitmap in order to force the rendering application to only display the portion of the texture that has image data in it.

Similarly to the image cache system the image cache system includes a disk that stores encoded images e.g. JPEG image files PNG image files etc. . The rendering application may send a request to load one or more images to the L2 cache or the request to load one or more images to the L2 cache may be generated automatically in response to the removal of decoded images from the L2 cache .

Upon receiving the load request encoded images may be fetched from the disk . Fetched images may then be decoded using multiple threads as discussed above. Alternatively fetched images may be decoded sequentially one after another e.g. if the mobile device includes one single core processor and or the mobile device does not have sufficient resources for parallel decoding .

The decoded images are then added to the L2 cache . In addition one or more memory mapped files MMFs may be created for the decoded images and added to the L2 Prime cache . A MMF is a segment of virtual memory which has been assigned a direct correlation with a file like resource present on disk. In one embodiment an MMF is created for a single decoded image. Alternatively an MMF is created for multiple decoded images. An MMF may be created for decoded images that are displayed by the rendering application upon launch. For example the L2 Prime cache may include the MMF with the first 10 images that will be displayed by the rendering application initially and the L2 cache may include the next 15 images that may be displayed by the rendering application when the user scrolls to the left or to the right.

An existing MMF may be removed from the L2 Prime cache when specifically requested by the rendering application . For example the application may send an eviction request and identify an MMF that should be removed from the L2 Prime cache . Alternatively a MMF may be removed from the L2 Prime cache automatically e.g. after a predefined time interval or in response to a predefined event . In one embodiment the image caching system generates a notification each time an MMF is added to or removed from the L2 Prime cache . This notification may be generated for the rendering application or any other program or component. In addition the image caching system may provide a list of MMFs currently stored in the L2 Prime cache . The list can be provided automatically at certain times or in response to a request of the rendering application .

When the user performs a scrolling operation the rendering application sends a request to load images to the L1 cache . The request may identify specific images to be loaded from the L2 cache and or the L2 Prime cache or the L2 cache and or the L2 Prime cache may store decoded images in a specific order and the rendering application may specify the number of images to be loaded and or the position of images in the L2 cache and or the L2 Prime cache .

In response to the request to load images to the L1 cache the image caching system may create an image bitmap for each requested image and add the image bitmap to the L1 cache . The rendering application may then display these image bitmaps in the user view.

The rendering application may be terminated and then restarted. For example if the rendering application is no longer running in the foreground e.g. due to the user launching another application the rendering application is terminated to free up memory and other computing resources and the contents of the L1 and L2 caches stored in volatile memory are destroyed. When the user wishes to return to the rendering application the rendering application is restarted. To avoid a time consuming decoding process for an initial set of images to be displayed upon the application restart the caching system maintains the L2 Prime cache in the non volatile memory of the mobile device. As discussed above the L2 Prime cache stores one or more MMFs files for decoded images. When the rendering application is restarted it does not need to wait for the fetching and decoding of the initial set of images. Rather the decoded images can be read from the MMF file s stored in the L2 Prime cache and then converted into image bitmaps and added to the L1 cache for use by the rendering application . As a result the time for displaying the initial set of images by the rendering application is significantly reduced.

As discussed above the L2 Prime cache can include one or more MMFs for a predefined set of decoded images to be displayed initially when the rendering application is launched. Alternatively the rendering application may instruct the image caching system to create one or more MMFs for a set of images displayed to a user at a certain point of time. For example when the rendering application is transitioned from an active state to an inactive state e.g. when a user activates a different application the rendering application may request the image caching system to add the most recently displayed images to one or more MMFs in the L2 Prime cache thus allowing a user to see the images that had been presented in the user view right before the execution of the rendering application was terminated. The images may be copied to the MMF from the L1 cache or the L2 cache . In one embodiment the request of the rendering application identifies the images to be added to one or more MMFs and specified where these images should be obtained copied from e.g. the L2 cache or the L1 cache .

As discussed above the image caching system or uses L2 native memory cache and L1 cache. Referring to the L1 cache stores images that are being displayed in the user view of the GUI. The L2 cache stores images to be displayed in the user view as well as images that are expected to be displayed in the user view if the user scrolls to the left and images that are expected to be displayed in the user view if the user scrolls to the right. Alternatively the L2 Prime cache stores images that are initially displayed in the user view and the L2 cache stores images that are expected to be displayed in the user view if the user scrolls to the left and images that are expected to be displayed in the user view if the user scrolls to the right. The images that will be subsequently displayed in the user view if the user continues to scroll to the left as shown by arrow or to the right as shown by arrow are stored on the disk e.g. in L3 cache .

The mobile devices are variously configured with different functionality to enable consumption of digital content such as electronic documents e.g. e books newspaper articles etc. videos e.g. movies images e.g. images of products recommended by online retailers and the like. The mobile devices may include any type of content rendering devices such as electronic book readers portable digital assistants mobile phones laptop computers portable media players tablet computers cameras video cameras netbooks notebooks desktop computers gaming consoles DVD players media centers and the like.

The content providing system provides digital content upgrades and or other information to the mobile devices registered with the content providing system via the network . The content providing system also receives various requests instructions and other data from the mobile devices via the network . The content providing system may include one or more machines e.g. one or more server computer systems routers gateways that have processing and storage capabilities to provide the above functionality.

Communication between the content providing system and a mobile device may be enabled via any communication infrastructure. One example of such an infrastructure includes a combination of a wide area network WAN or a VPN and wireless infrastructure which allows a user to use the mobile device to purchase items and consume items without being tethered to the content providing system via hardwired links. The wireless infrastructure may be provided by a wireless carrier system that can be implemented using various data processing equipment communication towers etc. Alternatively or in addition the wireless carrier system may rely on satellite technology to exchange information with the mobile device . Yet alternatively or in combination the wireless infrastructure may be provided by an access point e.g. WiFi access point provider system.

In one embodiment the content providing system periodically sends to the mobile devices images of products provided or recommended by the content providing system or by other entities e.g. individuals other organizations etc. and may include for example images of book covers images of movie covers images of portable electronic devices images of furniture items images of toys and the like. Each mobile device may include a rendering application that displays these images to the user and allows the user to scroll through the images. In one embodiment the rendering application is executed by the JVM running on the operating system of the mobile device .

In addition each mobile device may host an image caching subsystem that facilitates fast scrolling through images displayed on the screen of the mobile device by the rendering application. In particular the image caching subsystem provides an optimized pipeline for decoding images outside of the JVM heap memory and enables caching of decoded images in the operating system memory and the JVM heap memory. In some embodiments the image caching subsystem facilitates the reuse of bitmap objects thus reducing time required for the conversion of decoded images into image bitmaps. In yet some other embodiment the image caching subsystem provides a memory mapped file MMF cache to store decoded images which reduces the time for displaying an initial set of images when the rendering application is re started.

The L3 cache may reside in non volatile memory e.g. a hard disk a memory card a flash card of the user device. The image downloading manager may download encoded images to the mobile device via a network e.g. from a content providing system or other systems and cache them in the L3 cache or it may copy encoded images from local memory or from a removable storage device e.g. a USB flash drive of the mobile device to the L3 cache .

The image fetching manager may fetch encoded images from the L3 cache using a fetching thread. The image decoding manager may decode the fetched images and add the decoded images to the L2 image cache . In one embodiment the image decoding manager uses multiple decoding threads e.g. one thread per a processor core of the mobile device to decode fetched images in parallel. Alternatively the image decoding manager uses a single decoding thread to decode fetched images sequentially. The image decoding manager may decode the encoded images into the RGBA red green blue alpha format or the ARGB alpha green blue format that defines color components of each pixel e.g. 32 bits per pixel . Alternatively the image decoding manager may decode the encoded images into the YUV format that allows reduced bandwidth for chrominance components of a pixel e.g. 16 bits per pixel where Y refers to a luminance component of a pixel and UV refer to chrominance components of a pixel. The image decoding manager can also create metadata for each decoded image that may include for example the image file name the size of the image the number of row in the image the number of pixels per row etc.

The L2 cache may reside in the native memory of the operating system of the mobile device and may include images to be displayed by a rendering application in the user view initially as well as images that are expected to be displayed in the user view subsequently in response to the user s scrolling operation.

When the user performs a scrolling operation the rendering application may send a request to the image bitmap manager to load decoded images to the L1 cache . The request may identify specific images to be loaded from the L2 cache . In response to the request to load images to the L1 cache the image bitmap manager may search a pool of existing bitmap objects for a bitmap object that matches the size of a requested image. If the image bitmap manager finds such a bitmap object it uses the found bitmap object to create an image bitmap for the requested image. If the image bitmap manager does not find a bitmap object of the matching size in the bitmap object pool the image bitmap manager may create a new bitmap object. In another embodiment the image bitmap manager uses an existing bitmap object even if its size does not match the size of the requested object. In particular the image bitmap manager uses a bitmap object of a larger size than the requested image to create an image bitmap for the requested image. The image bitmap manager fakes the size of the image bitmap e.g. by changing it to match the size of the image in order to force the rendering application to only display the portion of the bitmap that has image data in it e.g. to avoid a black boarder to appear around the image when the image is displayed in the GUI . The image bitmap manager adds the resulting image bitmaps to the L1 cache for display by the rendering application.

The MMF manager is responsible for providing an initial set of images when the rendering application is launched or restarted e.g. after a termination due to inactivity . In particular when the image decoding manager decodes the images fetched from the L3 image cache it invokes the MMF manager which creates one or more memory mapped files MMFs for the decoded images and adds them to the L2 Prime cache that resides in non volatile memory of the mobile device. In one embodiment the MMF manager creates an MMF for a single decoded image. Alternatively the MMF manager creates an MMF for multiple decoded images e.g. for an initial set of decoded images to be presented by the rendering application . Subsequently if the rendering application is terminated and then restarted the MMF manager may read the decoded images from the MMF file s stored in the L2 Prime cache and provide them to the image bitmap manager for conversion into image bitmaps. The resulting image bitmaps are then added to the L1 cache for use by the rendering application . As a result the initial set of images does need to go through the decoding process thus reducing the time needed to display the initial set of images by the rendering application.

In one embodiment an image processed by the image caching subsystem can be defined as a state machine that transitions from one state to another. For example the image may initially be in NotLoaded state. Once the image is processed by the image downloading manager the image transitions into L3 state and then after being processed by the image fetching manager the image transitions into Fetched state. Next the image is processed by the image decoding manager causing the image to transition into Decoded state and then to L2 state. If the image is processed by the MMF manager the image transitions into L2 Prime state. Finally after being processed by the image bitmap manager the image transitions into L1 state where it is ready for display in the GUI by the rendering application.

The mobile device includes one or more processing units such as one or more CPUs or processor cores. The mobile device also includes system memory which may correspond to any combination of volatile and or non volatile storage mechanisms. The system memory may store information which provides an operating system component various program modules including image caching subsystem program data and or other components. The mobile device performs functions by using the processing unit s to execute the image caching subsystem and other instructions provided by the system memory . The system memory may also store information that provide a JVM component and a rendering application executed by the JVM where the rendering application interacts with the image caching subsystem during execution.

The mobile device may also include a data storage device that may consist of one or more types of removable storage and or one or more types of non removal storage. The data storage device may include a computer readable medium on which is stored one or more sets of instructions such as instructions of the image caching subsystem embodying any one or more of the methodologies or functions described herein. As shown instructions of the image caching subsystem may also reside completely or at least partially within the system memory and or within the processing unit s during execution thereof by the user device the system memory and the processing unit s also constituting computer readable media. The instructions of the image caching subsystem may further be transmitted or received over a network. In one embodiment the L3 cache and the L2 Prime cache of the image caching subsystem reside on the data storage .

The mobile device may also include one or more input devices keyboard mouse device specialized selection keys etc. and one or more output devices displays printers audio output mechanisms etc. . The mobile device may further include one or more communication interface mechanisms . These communication interface mechanisms allow the user device to interact with other processing devices such as remote computers the content providing system and so forth.

The above enumerated list of modules is representative and is not exhaustive of the types of functions performed by the mobile device . As indicated by the label Other Device Functionality the mobile device may include additional functions.

At block the image caching subsystem retrieves the requested images from the disk of the mobile device using a fetching thread. The images may be stored on the disk in an encoded file format such as JPEG PNG etc. At block the image caching subsystem decodes the retrieved images using multiple decoding threads operating in parallel. Each decoding thread can be executed by a distinct processor core of the mobile device. At block the image caching subsystem stores the decoded images in a first image cache in native memory of the operating system of the mobile device. In one embodiment the image caching subsystem generates a notification when a decoded image is added to or removed from the first image cache. A decoded image may be removed from the first image cache upon a request from the rendering application or when a new decoded image is added to the first image cache. In one embodiment the image caching subsystem provides a list of decoded images currently stored in the first image cache. The list may be provided periodically or in response to a request from the rendering application.

The rendering application may further request that at least some of the decoded images in the first image cache be loaded to a second image cache accessible by the rendering application. The second image cache resides in an application memory that is accessible by the application during execution. Depending on the type of the rendering application the application memory can be a JVM heap memory a video dedicated memory etc.

In response the image caching subsystem adds the requested images to the second image cache e.g. as image bitmaps or image textures where they are used by the rendering application for presentation as scrollable images on the screen of the mobile device.

At block the image caching subsystem receives a request of the rendering application for a decoded image stored in a first image cache e.g. L2 cache in native memory . In one embodiment the request identifies the decoded image using an identifier or file name.

At block the image caching subsystem determines whether the image pool includes a bitmap object with the size matching the size of the requested image. If so the image caching subsystem adds an image bitmap to a second cache e.g. L1 cache in the JVM heap memory using the bitmap object block .

If the bitmap object pool does not include a bitmap object with the matching size the image caching subsystem selects from the bitmap object pool a bitmap object with a larger size than the size of the requested image block . In one embodiment the image caching subsystem looks for the bitmap object that has the closest size to the size of the requested object. In an alternative embodiment in which all bitmap objects are of the same size the image caching subsystem selects any bitmap object from the pool e.g. any bitmap object that does not include image data or a bitmap object that has had current image data longer than other bitmap objects .

At block the image caching subsystem adds an image bitmap for the requested image to the second cache using the selected bitmap object. At block the image caching subsystem artificially changes the size parameter of the created image bitmap to match the size of the image e.g. by clipping the edges of the image bitmap . The rendering application then accesses the image bitmap and displays it as a scrollable image in the GUI. By faking the size of the image bitmap only the portion of the image bitmap that has image data is displayed without any black border appearing around the image. As a result many bitmap objects can be reused without having to create new bitmap objects thus reducing the time required to convert a decoded image into an image bitmap.

The above mechanism is discussed in the context of a JVM based image caching subsystem. A similar mechanism can be used for a OpenGL subsystem that uses texture objects and image textures instead of bitmap objects and image bitmaps as discussed above.

In some embodiments subsequently the image caching subsystem may receive a request from the rendering application to cache images from the native memory cache or the application memory e.g. JVM heap memory or video dedicated memory . The image caching subsystem may issue such a request upon the rendering application transitioning into an inactive status e.g. when moved from foreground to background in response to the launch of another application and may identify images currently displayed in the user view to allow the user to see the images that the user had most recently seen in the user view right before the execution of the rendering application was terminated. is a flow diagram of one embodiment of a method for utilizing memory mapped files MMFs to reduce a start time of a rendering application providing image scrolling. Method starts when the rendering application begins executing e.g. when it is restarted after previous termination and is attempting to display an initial set of scrollable images. At block the image caching subsystem receives a request for images the initial set of images from the rendering application. At block the image caching subsystem determines whether an MMF includes any MMFs of previously decoded images. If so the image caching subsystem fetches corresponding decoded images using the MMFs adds the decoded images to the native memory cache block and proceeds to block . If not the image caching subsystem fetches encoded images from the disk block decodes the fetched images block adds the decoded images to the native memory cache and proceeds to block .

At block the image caching subsystem adds the decoded images to a JVM heap cache using bitmap objects. The added images can then be used by the rendering application.

In the above description numerous details are set forth. It will be apparent however to one of ordinary skill in the art having the benefit of this disclosure that embodiments of the invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the description.

Some portions of the detailed description are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as identifying creating notifying allowing or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

