---

title: Distributed testing within a serial testing infrastructure
abstract: A serial testing infrastructure includes the capability to execute a distributed test on multiple virtual processors. A test executable may be stored in a library and the test description, including the name of the test, the test library, and other test characteristics, may be stored in a separate test data file. The serial testing infrastructure initiates multiple distributed test executors that each launch an instance of the distributed test as a process that runs concurrently with other instances of the distributed test. Each distributed test executor monitors execution of it corresponding process until completion or timeout.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914673&OS=08914673&RS=08914673
owner: Microsoft Corporation
number: 08914673
owner_city: Redmond
owner_country: US
publication_date: 20120220
---
Large scale software applications require continual testing to ensure that the applications generate consistent results. Functional testing is typically used during development to test functions methods features and or the complete application with various inputs. Regression testing is typically used after development of the application to test correctness of the application and the quality of the output. A large number of tests may be used to test a large scale software application. Each test may include various runtime options numerous settings and a large volume of testing data that increases the complexity and dimension of the testing process.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A serial testing infrastructure used to automate testing of software applications includes the capability to launch a distributed test into multiple processes that execute concurrently using a message passing model of communication. The serial testing infrastructure may utilize several instances or processes of a distributed test executor where each instance of a distributed test executor launches an instance or process of the distributed test. Each instance of a distributed test executor monitors an instance of the distributed test until completion or timeout. The distributed test executors may be initiated through an invocation of a message passing executable that also sets up a message passing environment for each of the distributed test processes to communicate. The format to invoke the message passing executable may be prepared by a serial to distributed test adapter from a description of a particular test run.

A test data file may be used to describe each test that is executed by the serial testing infrastructure. The test executable may be stored in a testing library that is distinct from the test data file. A serial test executor reads the test data file to obtain the information describing a test run which is then passed to a serial to distributed test adapter. The serial to distributed test adapter formats an invocation to a message passing executable to initiate execution of the multiple distributed test executors. Each distributed test executor in turn launches an instance of the distributed test i.e. process which is executed concurrently with the other instances of the distributed test. Upon completion of each process the corresponding distributed test executor returns test results pertaining to the outcome of the distributed test run to the serial to distributed test adapter. The serial to distributed test adapter prepares the test results for the serial test executor which provides them to the intended user.

These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of aspects as claimed.

Various embodiments pertain to a technology facilitating the execution of a distributed test within a serial testing infrastructure. A serial testing infrastructure is a testing environment that only has the capability of executing tests serially that is where only one process is executed at a time. A distributed test is an executable program that can be distributed into several processes that execute concurrently. Each process has its own local memory and communicates with other processes through message passing. The embodiments provide a serial testing infrastructure with the capability to execute a distributed test in addition to serially executed tests thereby providing a more robust testing environment.

In one or more embodiments the distributed test may be implemented as an executable function that is contained in a specific entry point or location in a library. A test data file may be used to specify a particular test run in the form of test characteristics that describe the requirements to execute a test. The test characteristics may include without limitation input data parameter settings number of processes and other information regarding the desired runtime environment for the test run e.g. configuration of the hardware resources used to run the test . The test data file may also specify the particular executable function or test to execute the location of the library where the executable function is located and a distributed test executor that generates the distributed runtime. The placement of the testing information in the test data file and the distributed test in a separate library enables a user to more easily run the same test in a variety of configurations.

Each instance of the distributed test may be implemented as a process that shares data and communicates with other processes through a message passing model of communication. In one or more embodiments the message passing interface MPI may be used to set up a message passing execution environment for a test run. MPI is a standard developed by the MPI Forum that specifies a message passing model of communication between multiple processes. Some implementations of the MPI standard are tailored for a particular parallel machine platform e.g. IBM Linux based cluster Cray Sun and SGI architectures while others are platform independent e.g. Microsoft MPI etc. . A MPI implementation may be composed of a set of library routines e.g. application programming interfaces APIs classes methods etc. that implement the features of the MPI specification. The APIs may be stored in a library that may be called from an external application such as a distributed test. However the MPI library routines adhere to a specific format which may not be executable within the serial testing infrastructure.

The serial testing infrastructure may utilize a serial to distributed test adapter to generate multiple distributed test executors that recognize the MPI requirements for a test run monitor the execution of each instance of a distributed test and report back the outcome of the distributed test.

Attention now turns to a more detailed description of an exemplary system for executing distributed tests within a serial testing infrastructure. illustrates a block diagram of an exemplary system that includes a serial testing infrastructure that may be composed of a test data file a serial test executor a serial to distributed test adapter multiple distributed test executors A N and one or more processes . Although the system as shown in has a limited number of elements in a certain topology it may be appreciated that the system may include more or less elements in alternate topologies as desired for a given implementation.

The serial testing infrastructure may be embodied within a computing device. The computing device may be any type of electronic device capable of executing programmable instructions such as without limitation a mobile device a personal digital assistant a mobile computing device a smart phone a cellular telephone a handheld computer a server a server array or server farm a web server a blade server a network server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof.

The serial testing infrastructure may be configured to execute serial and parallel tests. The serial testing infrastructure may be implemented as part of an integrated development environment a stand alone application as part of an operating system and so forth. The embodiments are not limited in this manner.

A test data file may be used to describe a test that is to be performed along with the testing environment input data settings parameters and so forth i.e. test characteristics . The test data file may contain data that describes one or more tests. In addition the test data file may include information about the expected outputs of a test. For example the test data file may describe a negative test case where a specific error is to occur during test execution. The tests may be distributed tests i.e. concurrent or parallel program and or a serially executed test.

Table 1 below illustrates an exemplary test data file . In this example the data for a distributed test is stored in tabular form in an Extensible Markup Language XML file. However it should be understood that the embodiments are not limited to an XML file and that the test data file may be embodied in other forms such as without limitation a Java Script Object Notation JSON file an Asynchronous Java Script and XML AJAX file Extensible Application Markup Language XAML file database table excel spreadsheet comma separated values and the like. Furthermore the data describing a distributed test is not limited to a file structure and may be described graphically.

The test data file shown in Table 1 above declares several parameters in lines 3 8. In particular line 4 declares the string DLLName as a parameter. It is used to indicate the test library where the test executable resides. In line 5 the string FunctionName is declared as a parameter and it is used to identify the function within the library that is the test executable. Similarly in line 6 the string MPIData is declared as a parameter and it is used to identify the parameter settings for the MPI environment.

In this example each test is described in a row of the table named DistributedRuntimeBasic identified in line 8. The test is described in lines 9 12. Line 10 indicates that the test is found in the library named TEST. Line 11 indicates that the test is the function TEST which is within the library TEST.DLL. Line 12 sets the parameter MPIData to the string n 4 which is used to indicate that four processes are to be used in this test run.

As shown in Table 1 the test data file allows a user to construct each test in a variety of configurations. The configurations are easily programmable by specifying different parameters settings options and input data in the table. The use of a separate file distinct from the distributed test executable provides more flexibility in the configuration of the test runs.

The serial test executor reads each row of the test data file and transmits the information stored in each row to the serial to distributed adapter . In one or more embodiments the serial test executor may be part of an existing testing framework that does not have the capability to execute a distributed test. In this case the serial to distributed test adapter initiates execution of multiple distributed test executors A N collectively . The number of distributed test executors may be a setting specified in the test data file . Each distributed test executor launches an instance of the distributed test as a process and monitors execution of the process until completion.

Each process A N collectively may execute on a dedicated virtual processor A N collectively . A virtual processor is a representation of a processing unit to an operating system. A processing unit may be implemented as a core within a multi core processor a single processor a processing element within a multiprocessor environment and so forth. A physical processor on a single integrated circuit IC may be composed of one or more cores. A core is an independent processing unit capable of executing programmable instructions. For example a dual core processor has two cores in a single IC and a quad core processor has four cores in a single IC. Furthermore a collection of cores may be logically grouped into a node where the cores in a node share a single address space. The cores may physically reside in one or more computing devices. At runtime the operating system maps a virtual processor to a physical processing unit.

In various embodiments the system described herein may comprise a computer implemented system having multiple elements programs procedures modules. As used herein these terms are intended to refer to a computer related entity comprising either hardware a combination of hardware and software or software. For example an element may be implemented as a process running on a processor a hard disk drive multiple storage drives of optical and or magnetic storage medium an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server may be an element. One or more elements may reside within a process and or thread of execution and an element may be localized on one computer and or distributed between two or more computers as desired for a given implementation. The embodiments are not limited in this manner.

The various elements of system may be communicatively coupled via various types of communications medium as indicated by various lines or arrows. The elements may coordinate operations between each other. The coordination may involve the uni directional or bi directional exchange of information. For instance the elements may communicate information in the form of signals communicated over the communications medium. The information may be implemented as signals allocated to various signal lines. In such allocations each message is a signal. Further embodiments however may alternatively employ data messages. Such data messages may be sent via various connections. Exemplary connections include parallel interfaces serial interfaces and bus interfaces.

Referring to a user e.g. developer tester programmer etc. may utilize a serial testing infrastructure to submit a test execution request . A test data file may include multiple tests TEST A through TEST K K where data pertaining to each test may be stored in a row in the test data file . The serial test executor reads each row in the test data file and submits the test data contained in the row TEST I to the serial to distributed test adapter . The serial test executor may then wait for the completion of the test before submitting the next test to the serial to distributed test adapter . Alternatively the serial test executor may read the next row in the test data file and submit the test data to the serial to distributed test adapter before the previous test is completed.

The serial to distributed test adapter reads the test data and converts it into a format used to call or invoke a MPI executable. The MPI executable may be invoked using the MPIEXEC.EXE with the parameters needed to make the invocation. For example the function call MPIEXEC.EXE DISTRIBUTED TEST EXECUTOR TEST.DLL TESTNAME NPROCS may be used to invoke the MPI executable to invoke multiple distributed test executors to execute the distributed test Test Name found in the library Test.DLL with the number of processes identified in the parameter NPROCS.

The MPIEXEC.EXE call may be submitted to a high performance computing HPC scheduler that obtains the hardware resources needed to execute the distributed test block . A HPC scheduler may be used in a HPC environment e.g. cluster to obtain the resources such physical cores memory I O etc. for a test run prior to execution of the test run. A HPC cluster is a configuration of computing devices that share resources in which each computing device may be referred to as a node. The HPC scheduler may be a dedicated node in a cluster that has the task of assigning resources for each job e.g. test run process that executes in the cluster. Examples of commonly used HPC schedulers are the Microsoft HPC Scheduler the Sun Grid Engine the Load Sharing Framework LSF the Portable Batch System PBS Torque and so forth.

Once the HPC scheduler obtains the resources the HPC scheduler initiates execution of the MPIEXEC.EXE call which in turn generates multiple instances or processes i.e. NPROCS of the distributed test executor A N collectively . Each distributed test executor initializes a MPI environment by specifying the type of message passing the test run requires such as synchronous send blocking send blocking receive non blocking send receive buffered send combined send receive and read send. Each distributed test executor monitors execution of a corresponding distributed test process until the distributed test process finishes processing or times out. In some situations the distributed test executor or the serial to distributed test adapter may initiate a stall mechanism that will terminate a distributed test process if any one of the distributed test processes executes for an exceeding long time.

Each distributed test executor and the distributed test processes process to process N A N utilize the MPI library to access MPI implemented executables e.g. classes methods functions subroutines etc. . Each distributed test executor accesses the library TEST.DLL where the distributed test resides to launch an instance of the distributed test.

The distributed test is used to test functions under test . The functions under test may be implemented as program code programs procedures module code segments program stacks middleware firmware methods routines and so on. The executable computer program instructions may be implemented according to a predefined computer language manner or syntax for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high level low level object oriented visual compiled and or interpreted programming language.

Each process process to process N A N executes on a dedicated virtual processor virtual processor virtual processor N A N. An operating system may map each virtual processor A N to a physical processing unit e.g. processor core etc. .

Each distributed test executor monitors the execution of its corresponding process until completion or timeout. An instance of a distributed test may execute successfully or fail. A test status may be returned from the MPIEXEC.EXE call that indicates the result of the test run such as failure or successful completion. Additional information from the test run may also be returned from the MPIEXEC.EXE call. One or more of the distributed test processes may have failed and additional information regarding the failure may be provided back to the user. The test status and additional information referred to as test results A N collectively may be passed from each distributed test executor to the serial to distributed test adapter which converts the information into a format recognizable by the serial test executor . The serial test executor provides the test results to the user.

The various elements of system may be communicatively coupled via various types of communications medium as indicated by various lines or arrows. The elements may coordinate operations between each other. The coordination may involve the uni directional or bi directional exchange of information. For instance the elements may communicate information in the form of signals communicated over the communications medium. The information may be implemented as signals allocated to various signal lines. In such allocations each message is a signal. Further embodiments however may alternatively employ data messages. Such data messages may be sent various connections. Exemplary connections include parallel interfaces serial interfaces and bus interfaces.

In various embodiments the system described herein may comprise a computer implemented system having multiple elements programs procedures modules. As used herein these terms are intended to refer to a computer related entity comprising either hardware a combination of hardware and software or software. For example an element may be implemented as a process running on a processor a hard disk drive multiple storage drives of optical and or magnetic storage medium an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a server and the server may be an element. One or more elements may reside within a process and or thread of execution and an element may be localized on one computer and or distributed between two or more computers as desired for a given implementation. The embodiments are not limited in this manner.

Operations for the embodiments may be further described with reference to various exemplary methods. It may be appreciated that the representative methods do not necessarily have to be executed in the order presented or in any particular order unless otherwise indicated. Moreover various activities described with respect to the methods can be executed in serial or parallel fashion or any combination of serial and parallel operations. The methods can be implemented using one or more hardware elements and or software elements of the described embodiments or alternative embodiments as desired for a given set of design and performance constraints. For example the methods may be implemented as logic e.g. computer program instructions for execution by a logic device e.g. a general purpose or specific purpose computer .

Referring to a serial test executor reads each test from the test data file and passes each test s information or test characteristics one at a time to the serial to distributed test adapter block . The serial to distributed adapter may initiate multiple distributed test executors to facilitate execution of the distributed test block . The serial to distributed adapter may interact with a HPC scheduler to obtain the needed hardware resources before the distributed test executors execute block . Each distributed test executor initiates an instance of the distributed test as a process and monitors execution of the process until completion or timeout block . Each distributed test executor returns an outcome of the distributed test such as a test status and or related test information as test results which are passed back to the serial to distributed adapter block . The serial to distributed adapter converts the test results from each distributed test executor into a format recognizable by the serial test executor block . The serial test executor upon receipt of the test results provides the information to the user block .

Attention now turns to a discussion of an exemplary operating environment. illustrates a first operating environment . It should be noted that the operating environment is exemplary and not intended to suggest any limitation as to the functionality of the embodiments. The embodiments may be applied to an operating environment having one or more client s in communication through a communications framework with one or more server s . The operating environment may be configured in a network environment a distributed environment a multiprocessor environment or a stand alone computing device having access to remote or local storage devices.

A client may be embodied as a hardware device a software module or a combination thereof. The client may be any type of electronic device such as without limitation a mobile device a personal digital assistant a mobile computing device a smart phone a cellular telephone a handheld computer a server a server array or server farm a web server a network server a blade server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof. The client may also be embodied as a software module having instructions that execute in a single execution path multiple concurrent execution paths e.g. thread process etc. or in any other manner.

A server may be embodied as a hardware device a software module or as a combination thereof. The server may be any type of electronic device capable of executing programmable instructions such as without limitation a mobile device a personal digital assistant a mobile computing device a smart phone a cellular telephone a handheld computer a server a server array or server farm a blade server a web server a network server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof. The server may also be embodied as a software module having instructions that execute in a single execution path multiple concurrent execution paths e.g. thread process etc. or in any other manner.

The communications framework facilitates communications between the clients and the servers . The communications framework may embody any well known communication techniques such as techniques suitable for use with packet switched networks e.g. public networks such as the Internet private networks such as enterprise intranet and so forth circuit switched networks e.g. the public switched telephone network or a combination of packet switched networks and circuit switched networks with suitable gateways and translators . A client and a server may include various types of standard communication elements designed to be interoperable with the communications framework such as one or more communications interfaces network interfaces network interface cards radios wireless transmitters receivers wired and or wireless communication media physical connectors and so forth. Examples of wired communications media may include a wire cable metal leads printed circuit boards backplanes switch fabrics semiconductor material twisted pair wire coaxial cable fiber optics a propagated signal and so forth. Examples of wireless communications media may include acoustic radio frequency spectrum infrared and other wireless media.

Each client s may be coupled to one or more client data store s that store information local to the client . Each server s may be coupled to one or more server data store s that store information local to the server .

A cluster may contain one or more nodes A K collectively and one or more network data storage devices communicatively coupled to a cluster interconnect . Each node may contain one or more cores . A core is an independent processing unit that has the capability to execute programmable instructions. Multiple cores may reside on one or more integrated circuits that are within a node e.g. multicore processors multiprocessors etc. A node may be implemented as a computing device.

In one or more embodiments the serial testing infrastructure may be configured to execute within one cluster and utilize virtual processors that are from within the same cluster as the serial testing infrastructure and or outside of the cluster. The embodiments are not limited to any particular configuration of a cluster.

The cluster interconnect and the inter cluster interconnect may embody any well known communication techniques such as techniques suitable for use with packet switched networks and circuit switched networks or a combination of packet switched networks and circuit switched networks with suitable gateways and translators. A node may include various types of standard communication elements designed to be interoperable with a cluster interconnect or inter cluster interconnect such as one or more communications interfaces network interfaces network interface cards radios wireless transmitters receivers wired and or wireless communication media physical connectors and so forth. Examples of wired communications media may include a wire cable metal leads printed circuit boards backplanes switch fabrics semiconductor material twisted pair wire coaxial cable fiber optics a propagated signal and so forth. Examples of wireless communications media may include acoustic radio frequency spectrum infrared and other wireless media.

The memory may be any computer readable storage media that may store executable procedures applications and data. The computer readable storage media does not pertain to propagated signals such as modulated data signals transmitted through a carrier wave. It may be any type of memory device e.g. random access memory read only memory etc. magnetic storage volatile storage non volatile storage optical storage DVD CD floppy disk drive and the like. The memory may also include one or more external storage devices or remotely located storage devices. The memory may contain instructions and data as follows 

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

Various embodiments may be implemented using hardware elements software elements or a combination of both. Examples of hardware elements may include devices components processors microprocessors circuits circuit elements integrated circuits application specific integrated circuits programmable logic devices digital signal processors field programmable gate arrays memory units logic gates and so forth. Examples of software elements may include software components programs applications computer programs application programs system programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application program interfaces instruction sets computing code code segments and any combination thereof. Determining whether an embodiment is implemented using hardware elements and or software elements may vary in accordance with any number of factors such as desired computational rate power levels bandwidth computing time load balance memory resources data bus speeds and other design or performance constraints as desired for a given implementation.

Some embodiments may comprise a storage medium to store instructions or logic. Examples of a storage medium may include one or more types of computer readable storage media capable of storing electronic data including volatile memory or non volatile memory removable or non removable memory erasable or non erasable memory writeable or re writeable memory and so forth. Examples of the logic may include various software elements such as programs procedures module applications code segments program stacks middleware firmware methods routines and so on. In an embodiment for example a computer readable storage medium may store executable computer program instructions that when executed by a processor cause the processor to perform methods and or operations in accordance with the described embodiments. The executable computer program instructions may be implemented according to a predefined computer language manner or syntax for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high level low level object oriented visual compiled and or interpreted programming language.

