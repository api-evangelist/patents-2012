---

title: Distributed mobile enterprise application platform
abstract: Various embodiments of systems and methods for distributed mobile enterprise application platform (MEAP) are described herein. In one aspect, the method includes receiving a request to be executed from a mobile device. Based upon the request, one or more middleware components capable of executing the request are determined from one or more remotely located servers. A middleware component from the one or more middleware components is selected for executing the request. The request is sent to the selected middleware component for execution. Based upon the execution, an output is received from the selected middleware component. In one embodiment, the output is stored in a backend system or sent to a portable device from which the request is received. In another embodiment, the output is sent to another middleware component for further execution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09059992&OS=09059992&RS=09059992
owner: SAP SE
number: 09059992
owner_city: Walldorf
owner_country: DE
publication_date: 20121217
---
A mobile enterprise application platform MEAP provides a middleware for linking enterprise applications or databases to mobile applications. A MEAP supports a limited number of mobile devices without degrading performance. For supporting more mobile devices new MEAPs are required to be installed. Installing a new MEAP requires effort and time because components of existing MEAP are required to be copied to the new MEAP. Additionally if the performance of the MEAP degrades the MEAP needs to be scaled up e.g. by adding or upgrading physical resources such as a memory CPU etc. However the addition or up gradation of physical resources requires shut down of the MEAP. Therefore there is potential loss of operational or productive time. Further the MEAP may also need to be shut down for software upgrades which again leads to potential loss of operational or productive time.

Embodiments of techniques for distributed mobile enterprise application platform MEAP are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Distributed mobile enterprise application platform MEAP is a middleware which links enterprise applications or databases to mobile applications. Components of the distributed MEAP middleware are used for executing requests from various mobile devices. A middleware component may be a software application capable of performing a task including at least one of processing data storing data forwarding data assigning data and sending confirmation. In one embodiment a middleware component can be a sender which sends data or a message to other component. In one embodiment the middleware component can be a target which receives data or messages. In one instance the middleware component can act like the sender and at other instance the same middleware component can act like the target. In one embodiment the middleware component may be a state machine component. In the below description the middleware component may be simply referred as a component.

Target is the middleware component which processes or executes data passed to it. In one embodiment executing data implies transforming data. In another embodiment executing data implies forwarding data to some other middleware component. In one embodiment the target can be a software application or an enterprise system.

Sender is the middleware component which sends data to be executed by some other middleware component. The sender delegates or assigns data to some other middleware components. For example a load balancer or a process delegator may be the sender which sends data to the target for executing.

The portable device can be any mobile computing device such as a smart phone. The portable device is registered with the distributed MEAP . Using the portable device a user can send the request to be executed by the distributed MEAP . The request may be for transforming data storing data filtering data forwarding data etc. In one embodiment the request may comprise a sequence of tasks tasks queue to be executed in order. For example the request may comprise tasks namely staging validation and distribution which is to be executed in sequence. The staging transforms data and produces clean correct and useful data. The validation ensures that a program operates on the clean correct and useful data and the distribution is meant for distributing or loading the validated data into data warehouses data marts or any data stores.

Referring to the request is received by the distributed MEAP . In one embodiment the request is received by a process delegator included within the distributed MEAP . In one embodiment the process delegator may be external to the distributed MEAP . Once the request is received by the process delegator the process delegator determines or selects the component to execute the request. In one embodiment the process delegator is a state machine component which selects the component to execute the request. In one embodiment the process delegator selects the component based upon the request or context of the request. In one embodiment the context implies various fields within the request format. In one embodiment the context implies a type of the task the request performs. For example if the request is for filtering data then the process delegator selects a filtering component. 

The process delegator selects the component from various available components capable of executing the request. The components may be available within the distributed MEAP or on the cloud . For example one or more filtering components may be available within the distributed MEAP or on the cloud . illustrates various servers e.g. server 1 server 3 on the cloud which are registered with the distributed MEAP . The servers e.g. server 1 server 3 are remotely located servers. The process delegator looks for the available components e.g. various filtering component C within the distributed MEAP and on the servers 1 3. As shown the filtering component C is available within distributed MEAP and on the server 1 and server 3. Therefore the process delegator selects one of the filtering component C from various filtering components C available on the distributed MEAP server 1 and server 3.

In one embodiment the process delegator selects the component C based upon the availability or workload of the component C. In one embodiment the component having the least or the lowest workload is selected. For example if the workload of the component C of server 3 is less than the workload of the component C of server 1 and the workload of the component C of distributed MEAP then the component C of the server 3 is selected. In one embodiment the component having less than a threshold or a predefined workload is selected. In one embodiment if a plurality of components C has the lowest workload then one of the plurality of components is selected randomly to execute the request in one embodiment if all the available components C are over loaded and not available then the distributed MEAP can create the component C on any of the registered servers. In one embodiment the distributed MEAP selects the server which is least busy and then creates the component C on that server. In one embodiment the component C is created by executing a predefined code of the component C on the selected server. Typically an instance of the component C is created on the selected server.

In one embodiment the request is executed on one or more specific servers. The process delegator determines a client sending the request. Once the client is determined the process delegator sends the request to the component existing on the server registered for the client. For example if the client has registered server 1 and server 2 then the requests from the client would be executed by the components on the distributed MEAP server 1 and server 2. In one embodiment executing requests on specific servers ensure security or confidentiality of data. In one embodiment the distributed MEAP creates the component C on the server registered by the client for executing request from that client.

The created or the selected component C executes the request. In one embodiment executing the request implies transforming data to generate the output. In another embodiment executing the request implies forwarding the request to some other component. In one embodiment the component C sends the output or confirmation to the distributed MEAP . In one embodiment the component C is termed target as it processes e.g. filters data passed to it. The generated output e.g. filtered data is returned to the distributed MEAP . The distributed MEAP stores the output in the data store such as the backend system . The backend system may be any enterprise system e.g. an enterprise resource planning ERP a customer relationship management CRM a human capital management HCM etc.

In one embodiment the component C sends a confirmation message that the request is executed to the process delegator . In one embodiment the component C sends the output filtered data to other component for execution. At the instance of sending the output the component C may be termed as sender because it sends data to be executed by other component.

To execute the task T from the device D the process delegator determines the least busy component C available on cloud and the distributed MEAP . As shown the component C of server 3 is least busy only one task T is running on it from device D therefore the process delegator sends DT to the component C of server 3. In one embodiment more than one component C might be running on server 3. The DT is executed on the component C of server 3 to generate the output O.

In one embodiment while DT is being executed on server 3 the process delegator receives the request from the device D to execute tasks T T in order. At that time suppose the component C of server 1 becomes free and completes executing previous two tasks T from the devices D and D. The process delegator selects the component C of server 1 to execute DT. Therefore the process delegator selects the best possible option to efficiently execute the task or request at any given time.

Referring to the output O generated by the component C of server 3 is sent to the process delegator . In one embodiment the component C directly sends the output O to the component C for executing the next task i.e. DT. In one embodiment the process delegator selects the component C having least workload e.g. component C on server 2 has no workload for executing the task DT. The task DT is executed by the component C of server 2 to generate the output O. The component C sends the output O to the process delegator or directly to the component C for executing DT last task . In one embodiment the process delegator selects the component C having least workload e.g. C of server 3 for executing the task DT to generate a final output O. The final output O is received by the process delegator . The process delegator either stores the output O within the backend system or sends the output O to the portable device .

In one embodiment the request comprises a mode field which indicates whether the request is to be processed in an online mode as an online request or in an offline mode as an offline request. The distributed MEAP accordingly processes the request. The online request is the request which is processed when the portable device is connected to the distributed MEAP whereas the offline request is the request which may be stored and processed even if the portable device is not being connected to the distributed MEAP . Typically the process delegator identifies the context of the request e.g. the mode field and then calls the target synchronously or asynchronously to execute the request. If the request is online request the process delegator calls the target synchronously to execute the request. In case of the offline request the process delegator calls the target asynchronously to execute the request. In asynchronous call the target immediately returns the output to the process delegator after executing the task.

In one embodiment the distributed MEAP pushes data or information into the portable device without receiving request from the portable device . Typically the distributed MEAP applies push mechanism to automatically update data or software of the portable device .

In one embodiment the components e.g. C C and the process delegator are written in a dynamic language such as Erlang . Using a dynamic language a latest version of code or updated component can be loaded while running an old version. Therefore software up gradation can be easily performed while running an old version and without shutting down the operation. Once the software or the components are updated from next execution cycle the new or the latest version of code or updated component is used for execution.

Embodiments described above provide a distributed MEAP. The distributed MEAP selects any available components from remotely located servers apart from its own components for executing the requests. The component is selected based upon a workload or availability of the component. Therefore the requests can be executed very efficiently and in less time. Also the distributed MEAP can easily scale out by registering new servers for executing requests. Further new components can be easily created on the new servers on demand and when required by the distributed MEAP. The process of replicating or creating components on various servers helps the distributed MEAP to scale out and efficiently execute the request. The distributed MEAP enables execution of several requests in parallel on various servers. The distributed MEAP can also easily scale up by using computing resources e.g. hardware resources from remotely located servers.

Moreover a developer can configure whether the request is to be executed in an online mode or an offline mode as per requirement. In one embodiment an end user can specify the mode of executing the request as per their choice. Therefore the distributed MEAP supports both the online and the offline mode of executing the request. Further the distributed MEAP allows upgrading software and hardware without shutting down the operation. The code for the components including the process delegator is written in dynamic language such as Erlang . Therefore a latest version of code can be easily loaded while running an old version and without shutting down the operation. Once the code is updated from next execution the new or the latest version of code is used for execution. Therefore there is no wastage of operational or productive time.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components may be implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of a non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic indicator devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open Database Connectivity ODBC produced by an underlying software system e.g. an ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the one or more embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the embodiments to the precise forms disclosed. While specific embodiments of and examples for the embodiment are described herein for illustrative purposes various equivalent modifications are possible within the scope of the embodiments as those skilled in the relevant art will recognize. These modifications can be made to the embodiments in light of the above detailed description. Rather the scope of the one or more embodiments is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

