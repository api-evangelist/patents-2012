---

title: Method and system for information retrieval in response to a query
abstract: A machine-implemented system and method of information retrieval, comprising: receiving queries including an ordered set of clause definitions, each clause definition including a clause pipeline, wherein a clause pipeline includes an ordered set of clause specifications that comprises an expansion operation and/or a filter operation, where the queries are received from a calling application; parsing the queries into a collection of expression pools; processing data by the expression pools in the collection to generate a current object set; and returning the current object set to the calling application in response to the queries.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09081873&OS=09081873&RS=09081873
owner: STRATACLOUD, INC.
number: 09081873
owner_city: Atlanta
owner_country: US
publication_date: 20120928
---
This application claims the benefit of U.S. Provisional Application No. 61 540 657 filed Sep. 29 2011 and is a Continuation in Part of U.S. patent application Ser. No. 12 573 587 filed Oct. 5 2009. All of the forgoing applications are incorporated by reference in their entireties for all purposes.

A model builder is a software component that conforms to a defined interface to the query processor for the purpose of providing data from a specific type of data source 

An input pool may be a pool of processes that receive data from a message bus perform initial classification of data and based on the classification send data to the initial query pool.

An initial expression pool may be a pool of processes representing the first expression of a query dedicated to processing data sent to that query. IF the processes in the initial expression pool classify certain types of data to be forwarded through the pipeline then that data may be sent to the next pool of processes in the pipeline.

An expression pool may be a pool of processes that process data received from either a previous expression pool in the processing pipeline or from the input pool. When an expression pool starts and stops it dynamically subscribes and unsubscribe from a previous expression pool.

 Expression output may be a pool of processes that receive data from a previous expression pool or the input pool and publish that data to a message bus and or one or more initial expression pools for other queries.

A lifecycle may be a pool of processes that manage the lifecycle of queries. The lifecycle component may translate a textual representation of a query into individual expressions and may then create the expression pools of processes for each expression in the query.

A query may be a pipeline of expression pools starting with the initial expression pool and ending with the expression output.

Complex Event Processing CEP systems use a language similar to SQL to perform pattern matching on data using criteria at soft real time speeds. Data streams events in those data streams fields within those events and temporal specification in the language are utilized. A CEP system based on a virtual graph based key value query language is discussed below. This language may offer the ability to express a pipeline of processing steps for data flowing through a query.

In some embodiments the techniques described herein may task the limitations of a single computational server s resources and thus it is contemplated that one or more process steps or functions may be distributed onto a set or hierarchy of multiple computational servers. Of course any other hardware software systems devices and the like may be used. More generally the subject matter described herein may be implemented with any collection of one or more autonomous computers together with their associated software systems protocols and techniques linked by a network or networks.

A representative information retrieval system in which the disclosed subject matter may be implemented comprises a set of computer resources typically software processes programs utilities and associated interfaces data and protocols to provide a monitoring and reporting tool for IT system administrators and that includes a search capability. Preferably the tool has the capability of consolidating logs metrics and other data from various applications servers and network devices into a searchable repository and can be used to generate graphs reports and alerts and to take other actions. The information retrieval system helps administrators to identify anomalies and to diagnosis problems in the infrastructure. The tool may have the ability to correlate log files across systems and software components and such data can help users determine root causes when problems arise within the infrastructure. The described subject matter may be implemented within the information retrieval system or as an adjunct to that system. In one particular implementation the IT infrastructure is a virtualized infrastructure such as the VIRTUALIZATION MANAGEMENT CENTER VMC solution available from Reflex Systems LLC of Atlanta Ga. VMC enables next generation data centers to enforce IT policies ensure compliance with government mandates and protect virtual servers desktops and networks across multiple platforms. In particular VMC provides a single authoritative visual interface central management and security for heterogeneous virtual environments. By combining a centralized event database virtual infrastructure integration and analysis engines with a robust visual interface VMC enables the user to administer audit secure and monitor complex dynamic virtual infrastructures. This results in better network and event visibility for a faster and more efficient management and security response.

A lifecycle may be a pool of processes that manage the lifecycle of queries. The lifecycle component may translate a textual representation of a query into individual expressions and may then create the expression pools of processes for each expression in the query.

In one embodiment multiple queries may be parsed into a collection of expression pools. Then data may be processed on an iterative basis by the expression pools in the collection to generate a current object set. Referring to a message bus may receive data from input sources . The message bus may receive data from data publishers and send data to data publishers. The message bus may also send data to an input pool . The input pool may be a pool of processes that receive data from the message bus perform initial classification of data and based on that classification send certain data to the initial expression pool . Thus the input pool may receive criteria for different queries. For example the input pool may receive information that when objects with certain properties are received by the input pool those objects should be sent to certain queries e.g. queries 1 9 and 45 . Once the input pool sends data to the queries e.g 1 2 and 3 in the data is received by a query s initial expression pool . The initial expression pool may be a pool of processes representing the first expression of a query dedicated to processing data sent to that query. If the processes in the initial expression pool classify certain types of data to be forwarded through the pipeline then that data may be sent to the next pool of processes in the pipeline. Thus the initial expression pool may process the data and then send the data to the query s additional expression pools until the processed data reaches the query s output expression pool . The additional expression pools may be a pool or processes the process data received from either a previous expression pool in the processing pipeline or form the initial expression pool . When an expression pool starts and stops it may dynamically subscribe and unsubscribe from a previous expression pool. The expression output pool may be a pool of processes that receive data from a previous expression pool or the initial expression pool and publish that data to the message bus and or an initial expression pool for other queries in the same node and or in another node. The initial expression pools and the expression pools may process the data in for example but not limited to the following ways filtering non filtering expanding traversing relationships to other objects or manufacturing new objects or any combination thereof.

As described above once the data is processed by the expression pools the data may be sent from the query s output expression pool to the message bus and then to an output destination .

Using the methodology described in multiple queries e.g. hundreds of thousands millions may be processed at the same node. In addition multiple queries may be processed at the same time across multiple nodes. The nodes may be interconnected nodes that may process the output of other nodes. In this way the data may be processed very quickly.

Referring now to a model builder object is characterized by one or more of the following an object schema a set expansion and a set reduction . The properties of an object are provided by the object schema and a representative schema is illustrated using a UML based model. A set expansion produces a set of new objects based off of a source object. A set reduction filters a superset of objects down to a smaller set based off of given filter criteria. The objects in an object set pipeline are provided by an underlying system of model builders. Thus a given model builder provides the query processor with an object schema object set expansions and object set reductions. The expansion specifications are defined in more detail below in the Parse Constructs section.

The model builders provide this data to the search language constructs in a single unified data model. In an IT infrastructure environment the object types constitute generalized IT objects. Examples of object types include but are not limited to virtual machines physical hosts groups of systems clusters network interfaces switches software processes protocols memory CPUs system events storage files and networks. Of course these examples are merely illustrative and the object type of course will vary depending on the implementation environment.

A model builder thus provides primitive data objects to the query processor. A model builder obtains data from a data source and generates a data model. As noted a data source may be one of a historical database an on demand data source accessed via an API a streaming data source or the like. The models are used during the processing by the query processor of the abstract syntax tree which is generated as an output from the compiler which receives as input tokens produced from lexical analysis of the query string .

The boundary between the query processor and a model builder conforms to a well defined interface. As noted above this interface ensures that a model builder provides the query processor with a heterogeneous object schema object set expansions based on expansion specifications and object set reductions based off of filters. As noted above an object set expansion produces a set of new objects based off a source object. For example the query vm.name foo project vnic may expand a set of one vm object to a set of more than one vnic objects. In this case the query processor calls on the model builder provided object set explanation function and preferably passes in an instance of a vm object the model builder expands that object to a set of vnic objects which set is then returned to the query processor. In contrast an example object set reduction simply filters a superset of objects down to a smaller set based on a given filter criteria. Continuing with this example if the current object set comprises of vm objects and each has a mem memory property a clause specification of vm.mem 2048 would filter out any vm objects whose mem properties were less than or equal to 2048 thus an object set reduction would produce a reduced set of objects from the original set. In this case the query processor preferably passes in the filter vm.mem

As these examples illustrate the query processor maps the different heterogeneous object schemas together from multiple model builders to provide a single unified query interface even from potentially heterogeneous data storage systems.

As another concrete example consider the query vm.name foo project cpu perf at 1 week ago. This query uses two different model builders. The first model builder uses a historical SQL based database system and the second model builder uses a SOAP based API. Using the techniques described herein the query processor has integrated the two different heterogeneous object types into a single unified object model. In particular the query processor deduces that the vm object type is provided by the historical database system and delegates the filtering of the vm object named foo to it. The query processor then deduces that the cpu perf object type is provided by the second model builder. Once the vm object is returned by the first model builder it is then passed in conjunction with a time specification as filter parameters to the second model builder thereby producing a resulting cpu perf object.

When queries are executed the resulting object set may be returned to the message bus as illustrated in . Several different types of object interchange formats can be used to return the resulting data objects including without limitation JSON YAML XML .Net Java or Google Protocol Buffers. The output of the query can be used by any existing procedural language to conduct any further operations on the data such as auto response capabilities. is an example of an HTTP based query entity making a request and the results returned from that request.

The various components e.g. compiler query processor model builder typically are implemented as one or more computer programs where a computer program is a set of computer program instructions stored in a computer memory or data store and adapted to be executed by one or more processors to perform a process or method having a set of functions or operation steps. As noted above a model builder extracts data from any type of data source such as a relational database system RDBMS or an application programming interface API . By providing the model builder abstraction layer the language itself can query data in several different heterogeneous data storage systems and it can then provide any type of dictionary of objects and properties. Using this abstraction the model builder can introduce new objects relationships and properties without modifying the language structure itself. In addition the model builder can query a single relational database system and the contents of that database can include data from multiple heterogeneous systems.

Model builders can provide data from any data source. Preferably querying a model builder not only queries factual data but can also query correlated information as well as logically derived information at the time of query execution from a data source. For example a model builder can store the fact that virtual network interface A is on VLAN 12 and virtual network interface B is on VLAN 12. A model builder can correlate those two facts into a new primitive property that has a relationship with both virtual machines. The model builder can present this new property to the language without requiring a change to the language.

Moreover because model builders can derive new properties and objects based on factual data model builders themselves can create new language properties and objects based on persisted state within a source data structure. For example a model builder can provide a named property on a virtual machine object if there is data within the source data store that provides evidence that the virtual machine was connected to an insecure network in the past.

As noted above object relationships either can be encoded as facts in the underlying model or they can be derived from facts within the model builder itself. Expansion operations in the query remove the complexity of object navigation by using the object schema provided by model builders to traverse an abstract syntax tree for desired objects. Filtering operations in the query use standard grouping Boolean logic for object property comparisons. Preferably the language need include any type information for objects but instead provides operators that the model builders map to native object type operations to produce results.

When a user issues an on demand query to the query system the model builders preferably distribute the processing of the query across multiple data processing engines for the purpose of data correlation and improving query performance. Moreover because model builders can provide data from any data source the system can also provide query specifications to a model builder that processes streaming data as opposed to mere static data or data that is retrieved on demand . Thus the language can specify a single query across multiple model builders to simultaneously provide query results from a static model builder a dynamic model builder and a streaming model builder. In this way and as has been described the system correlates data from multiple data sources.

Because model builders provide most of the breadth of the language the set of tokens that constitute the language itself is fairly small. To provide natural language query simplicity the language considers unrecognized tokens as string query specifications for the string versions of all object properties within the universe of the current clause specification the token was found in.

A query processor that implements the language comprises a parser a lexical analyzer an abstract syntax tree and one or more model builders as well as model builders to different types of data storage systems providing high performance pipeline selection logic of disparate objects and properties.

As illustrated in the execution of the query processor may or may not occur within the process space of a model builder. In appropriate circumstances it may be desirable to implement remote execution of the query processor to improve query performance over local process execution. In addition the language formatting is not line terminated and preferably uses keywords spacing and identifiers suitable for UTF 8 encoding in URLs.

A context free grammar for the language is described below. As noted above the compiler performs lexical analysis of a query string based off a set of lexical constructs. This lexical analysis produces a set of tokens that are then parsed to produce the abstract syntax tree. These constructs are set forth in .

The following is a set of parsing constructs described according to BNF an industry standard grammar that are implemented by the parser. Preferably a search query is composed of an ordered set of clause definitions and each clause can have set membership operations applied to it. Each clause includes a clause pipeline and a time constraint. A clause pipeline includes an ordered set of clause specifications separated by a pipeline operator. A clause specification can be either an expansion operation or a filtering operation. Preferably a first clause specification in a pipeline operates on an initial universe of all objects and each subsequent clause specification operates on a set of objects produced from the previous clause specification.

An expansion specification uses the object schema provided by the model builder to navigate to specific information the user desires without requiring the user to understand the relationships between all object relationships. As noted above this technique minimizes query specification size and reduces complexity. There are two types of expansion mechanisms defined project and expand. Clause specifications are pipelined together meaning that the objects from a previous clause specification are used as input to a subsequent clause specification. If the previous objects are used to produce the subsequent set but are not included the keyword project is used. If the user wishes to include the previous objects into the new set of objects then the user specifies the expand keyword.

A capability of the language is the inclusion of temporal specification within clause definitions. There are two primary methods for time specification. The first uses the keyword at and the second uses the keywords between and thru. Certain types of data can exist across a span of time. An example of this type of data is the running state of a virtual machine e.g. the virtual machine ran from time A to time B. In these instances the keyword at is used to denote a specific place within that span of time. Other types of data exist only at a particular instance of time as opposed to a time span. An example of that type of data is a particular event such as an alarm which occurred at an exact time. Thus a time span is used to include that type of data using the keywords between and thru.

In one embodiment the disclosed language differs from prior art techniques and existing languages by simultaneously allowing both natural language search and a relationship driven structured search to be used within a single query specification on a unified data model. In addition the language also adds two other major differences from existing languages. The language provides for the codification of time in query terms thereby allowing users to limit query results based off of object property relationships for example using instances or ranges of time. The described subject matter also can take advantage of set membership capabilities including query result unions intersections and subtractions. Note that illustrates the rules and principles that govern the structure of a query according to an embodiment.

In one embodiment the present invention provides for a data retrieval system from dissimilar computer software environments to a storage system of computer data. In order to interface the environments a domain specific language is provided to map abstract data structures in different specific data types of varying composition into a format that is known and can be utilized by an application program. The language provides natural language expressions and default contextual type conversions to handle a full range of user based queries for IT infrastructure. The query system is composed of a compiler as well as model builders to different types of data storage systems providing high performance pipeline selection logic of disparate objects and properties.

The disclosed techniques provide the ability to produce query results based on the codification of IT infrastructure with complex relationships requiring minimal knowledge of the environment. As described in one embodiment the invention combines both approaches of free form search as well as structured search using a query based language grammar that executes at real time speeds. In one embodiment the invention provides the ability to simplify query creation by providing natural language search capabilities where simple strings of characters can be used without specifying object relationships or special character delimiters or tokens. The language is able to use object relationships to produce more accurate query results whose results can be relied upon even by unattended software automation. More generally the techniques described herein provide for a single unified language construct that simplifies query processing.

The functionality described above may be implemented as a standalone approach e.g. a software based function executed by a processor or it may be available as a managed service including as a web service via a SOAP XML interface . The particular hardware and software implementation details described herein are merely for illustrative purposes are not meant to limit the scope of the described subject matter.

More generally computing devices within the context of the disclosed invention are each a data processing system such as shown in comprising hardware and software and these entities communicate with one another over a network such as the Internet an intranet an extranet a private network or any other communications medium or link. The applications on the data processing system provide native support for Web and other known services and protocols including without limitation support for HTTP FTP SMTP SOAP XML WSDL UDDI and WSFL among others. Information regarding SOAP WSDL UDDI and WSFL is available from the World Wide Web Consortium W3C which is responsible for developing and maintaining these standards further information regarding HTTP FTP SMTP and XML is available from Internet Engineering Task Force IETF . Familiarity with these known standards and protocols is presumed.

The scheme described herein may be implemented in or in conjunction with various server side architectures including simple n tier architectures web portals federated systems and the like.

Still more generally the subject matter described herein can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the function is implemented in software which includes but is not limited to firmware resident software microcode and the like. Furthermore as noted above the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain or store the program for use by or in connection with the instruction execution system apparatus or device. The medium can be an electronic magnetic optical electromagnetic infrared or a semiconductor system or apparatus or device . Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and DVD. The computer readable medium is a tangible item.

The computer program product may be a product having program instructions or program code to implement one or more of the described functions. Those instructions or code may be stored in a computer readable storage medium in a data processing system after being downloaded over a network from a remote data processing system. Alternatively those instructions or code may be stored in a computer readable storage medium in a server data processing system and adapted to be downloaded over a network to a remote data processing system for use in a computer readable storage medium within the remote system.

In a representative embodiment the parser lexical analyzer and model builder components are implemented in a special purpose computer preferably in software executed by one or more processors. The software is maintained in one or more data stores or memories associated with the one or more processors and the software may be implemented as one or more computer programs. Collectively this special purpose hardware and software comprises a language processor that provides the described functionality.

While the above describes a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary as alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations or the like. References in the specification to a given embodiment indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic.

Finally while given components of the system have been described separately one of ordinary skill will appreciate that some of the functions may be combined or shared in given instructions program sequences code portions and the like.

The query mechanism may be any convenient client side application such as a web browser a command line interface CLI a programmatic interface or the like. As used herein the client side application should be broadly construed to refer to an application a page associated with that application or some other resource or function invoked by a client side request to the application. A browser as used herein is not intended to refer to any specific browser e.g. Internet Explorer Safari FireFox or the like but should be broadly construed to refer to any client side rendering engine that can access and display Internet accessible resources. Further while typically the client server interactions occur using HTTP this is not a limitation either. Any client server interaction may be formatted to conform to the Simple Object Access Protocol SOAP and travel over HTTP over the public Internet FTP or any other reliable transport mechanism may be used. Also the term web site or service provider should be broadly construed to cover a web site a set of linked web pages a domain at a given web site or server a trust domain associated with a server or set of servers or the like. A service provider domain may include a web site or a portion of a web site. Any application or functionality described herein may be implemented as native code by providing hooks into another application by facilitating use of the mechanism as a plug in by linking to the mechanism and the like.

While various embodiments have been described above it should be understood that they have been presented by way of example and not limitation. It will be apparent to persons skilled in the relevant art s that various changes in form and detail may be made therein without departing from the spirit and scope. In fact after reading the above description it will be apparent to one skilled in the relevant art s how to implement alternative embodiments. Thus the present embodiments should not be limited by any of the above described embodiments.

In addition it should be understood that any figures which highlight the functionality and advantages are presented for example purposes only. The disclosed methodology and system are each sufficiently flexible and configurable such that they may be utilized in ways other than that shown.

Further the purpose of any Abstract of the Disclosure is to enable the U.S. Patent and Trademark Office and the public generally and especially the scientists engineers and practitioners in the art who are not familiar with patent or legal terms or phraseology to determine quickly from a cursory inspection the nature and essence of the technical disclosure of the application. An Abstract of the Disclosure is not intended to be limiting as to the scope of the present invention in any way.

Although the term at least one may often be used in the specification claims and drawings the terms a an the said etc. also signify at least one or the at least one in the specification claims and drawings.

Additionally the term comprising or similar terms in the specification claims and drawings should be interpreted as meaning including but not limited to. 

Finally it is the applicant s intent that only claims that include the express language means for or step for be interpreted under 35 U.S.C. 212 paragraph 6. Claims that do not expressly include the phrase means for or step for are not to be interpreted under 35 U.S.C. 212 paragraph 6.

