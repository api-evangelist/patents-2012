---

title: Scalable fine-grained multi-service authorization
abstract: A scalable cross-protocol mechanism is provided for describing, transmitting and checking large lists of authorizations for operations on network resources. At an authorization server, data is stored that represents operations that can be performed on a plurality of resources of a service provider at the request of one or more users. A set of {resource,operations} tuples is generated, wherein a resource describes an endpoint for a network service and operations is a list of operations that are authorized on an endpoint. The set of {resource,operations} tuples is partitioned into one or more subsets. A subset of the set of {resource,operations} tuples is combined into a string according to a predetermined rule. A hash is then computed, according to a hash function, to generate hash results. Hashes are passed instead of the lists themselves to minimize data transfer and latency.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08925043&OS=08925043&RS=08925043
owner: Cisco Technology, Inc.
number: 08925043
owner_city: San Jose
owner_country: US
publication_date: 20120710
---
When running a large Software as a Service SaaS provider there are often many services created by disparate teams running over different network protocols that need to appear as a coherent set of products services to customers partners and the larger developer community that will use that set of subservices as a platform. A primary challenge for some SaaS providers is obtaining a centralized identity service so that there is one user name and authentication mechanism e.g. password that works across all of the subservices. Once a user is identified the next hurdle is to determine which if any services the user is authorized to access.

Several authorization systems that have been built in the past assume that if a user can access the service there are a very fixed set of static permissions for which pieces of the service the user is entitled to use. This approach does not always work well particularly for enterprises which prefer very fine grained control over which users can use each feature of a service. Often these enterprises like to use groups or roles to assign similar permissions to sets of users.

For security reasons authorization decisions are performed server side since client applications are under control of untrusted parties perhaps having been written entirely by untrusted parties in a fully realized developer community scenario. However clients often want to know what operations they are allowed to perform so that they can disable or remove the portions of the user experience that the user is not allowed to access rather than waiting for the user to try something that is going to fail.

In many enterprises there are hundreds of millions of users and thousands of servers. With aggressive virtualization services may be distributed across hundreds of thousands of servers. Therefore complex tightly coupled or centralized processing is best kept to a minimum. In particular on the server side the latency requirement dictates that processing can be simplified and calls to other internal services can be kept to a minimum.

A scalable cross protocol mechanism is provided for describing transmitting and checking large lists of authorizations for operations on network resources. At an authorization server data is stored that represents operations that can be performed on a plurality of resources of a service provider at the request of one or more users. A set of resource operations tuples is generated wherein a resource describes an endpoint for a network service and operations is a list of operations that are authorized on an endpoint. The set of resource operations tuples is partitioned into one or more subsets. A subset of the set of resource operations tuples is combined into a string according to a predetermined rule. A hash is then computed according to a hash function to generate hash results.

Referring first to a block diagram is shown of a system in which a service provider communicates with one or more clients L by way of a network to provide software services to one or more of the clients L . The service provider has or has access to a plurality of servers K physical and or virtual that can provide software services to the clients L . The servers K need not be co located and need not be completely under control of the service provider. The network may consist of one or more local area networks wired and wireless and one or more wide area networks wired and wireless .

The clients L are software applications that are running on a device such as a desktop computer laptop computer tablet computer server computer smartphone or any other apparatus on which an application called a client application herein is running that at some point in time involves a user accessing a service provided by the service provider . A user may be a person or another computing apparatus.

A resource is a concrete self contained piece of functionality that is the smallest unit of authorization. A resource describes an endpoint for a network service.

An operation is a separate action that is authorized to be performed on a resource endpoint . For example in Hypertext Transport Protocol HTTP based systems this might correspond to the HTTP method used for the request.

A resource operations tuple thus defines an endpoint for a network service and a collection of operations authorized on the endpoint. A resource operations tuple is also referred to herein as a ResOp .

A service provider offers services that consist of one or more operations on each of one or more resources.

A token service or authorization service is an entity trusted by the service provider to ensure that authentication has succeeded. The authorization service generates and signs tokens. The authorization service is provided supported by an authorization server shown in .

An identity provider is a system entity that authenticates users and maps them to identities that can be processed by the authorization service. The identity provider IdP is shown at reference numeral in .

A client is as explained above software application or process that uses the services provided by the service provider after having communicated with the identity provider and authorization service.

An authorization token or token is a time limited list of permissions that entitles the bearer to access a long list of discreet services.

When a user is provisioned to have access to a set of services provided by one or more service providers a token service or authorization service e.g. the authorization server is given a list of protocols host names resources and operations on those resources that are involved in that user having access. The authorization service does not need to know what semantic is associated with these ResOps. The service provider may also inject extension data which will be available to the service provider later in the process.

The ResOps lists described above can be very long in a real world complex system to the point where the length of the list would make the system impractical. However the number of combinations of resources and operations used in practice are usually quite limited. Instead of passing around long lists a pointer to the list is distributed as needed. One such pointer to the list can be constructed by ordering the list canonically according to a predetermined rule converting it to a canonical bytestream e.g. using a JavaScript Object Notation JSON as set forth in RFC 4627 and performing a cryptographically strong hash over the bytestream. These hashes can then be exchanged instead of the lists. Using the hash as a verification mechanism any actor in the system that knows the original data that corresponded to the hash can then act as a trusted source of that information leading to highly optimized transport of that data. For example if an entity refers to a given hash in its capabilities description that entity can be assumed to know the set of resource operations tuples described by the hash. The service provider stores a cache of hashes shown at reference numeral in for facilitating the distribution of authorization information to clients as described in further detail hereinafter.

When the client accesses an authorization service AuthZ provided by the authorization server for the first time normal single service authentication authorization is performed e.g. OAuth perhaps involving the separate IdP .

Reference is made to . shows a flow chart for operations performed at the authorization server for example. provides a pictorial representation of these operations. At data is stored that represents operations that can be performed on a plurality of resources of a service provider at the request of one or more users. At a set of resource operations tuples is generated that are authorized on a resource endpoint where again a resource defines an endpoint for a network service and operations is a collection of operations that are authorized on the endpoint. shows a set of resource operations tuples comprising resource Res and operation Op operation k Op that are authorized on Res and Op Opthat are authorized on Res . . . and Op Opthat are authorized on Res.

For HTTP the resource may be specified by a Universal Resource Locator URL and the operation may be a request method e.g. GET POST etc. Other protocols may specify their own operations e.g. publish subscribe etc. The authorization server treats resource and operations as opaque.

In this example one resource hierarchy is auth and the operations on this resource are GET and POST. Another deeper resource hierarchy is meetings and the operations on this resource are DELETE GET and POST. An explicit resource is print that has operations DELETE and POST.

At the set of resource operations tuples are de duplicated and then partitioned into one or more subsets shown at in . The partitioning operation may be performed so as to minimize the number of subsets needed to describe authorizations across a user population. For example the set of resource operations tuples is separated into one or more subsets so as to minimize the number of subsets and maximize the number of hash collisions so that the hash results cache optimally as described further hereinafter. In so doing there will be as few hashes alive or active in the system at any one time so that they cache more optimally.

The authorization server may compute an optimal set of ResOps subsets by looking for common patterns. Imagine a spectrum of subset sizes from one where each user would need thousands of subsets to the number of users where each user would get a different subset and no caching can occur . The optimal number of subsets will minimize the token size and maximize the number of cache hits using feedback from the number of times a subset is requested the number of times that subset is given out and cross organizational scans for the most common subsets used.

At at least one subset of resource operations tuples is combined into a string according to a predetermined rule e.g. alphabetical sorting followed by JSON serialization. The string is shown at reference numeral in . An example of a string for the example resource operations tuple given above is note no newlines are intended in the below example 

At a hash of the string is computed using a hash function to generate hash results. For example the hash function may be a Secure Hash Algorithm 1 SHA1 hash an MD5 function etc. The hash results are generically shown at reference numeral in . The hash results may converted to a string of characters. For the example string referred to above the string of characters for the hash results derived from a SHA1 hash is 

There are several possibilities options for use of the hash results. First at the subset of resource operations tuples may be stored in a distributed hash table based on the hash results. A distributed hash table DHT provides a lookup service that stores key value pairs and any participating device entity can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the entities in such a way that a change in the set of participants causes a minimal amount of disruption. Thus a DHT can scale to large numbers of entities. The DHT may be maintained by memory in the authorization server or service provider or some other entity device in the system.

Another possibility is as shown at to generate a cacheable Universal Resource Identifier URI that points to the subset of resource operations tuples and is described by the hash results for the string for storage and use by the service provider and clients. An example of a cacheable URI for the hash results example provided above is https authz d669e4c30a1b9d360f86786ee448cd71bcf9dd6c. The cacheable URI may be cacheable via a network protocol.

Still another possibility is at to generate a token in response to a request based on a user identity associated with a client. The token includes one or more hash results. At the token is sent to the client with a signature generated from the contents of the token .

Yet another possibility as shown at is to retrieve the subset of resource operations tuples using the hash results from any entity that is known to have the subset of resource operations tuples. In other words a client can request any entity to provide the subset using the hash results if the client has some knowledge that that entity should have the subset.

Reference is now made to for a description of a token. A token shown generally at reference numeral includes data indicating time validity specifying the time period during which the token is valid in the form of a start time field and an end time field . There is an identity field that identifies the user for which the token is intended. After the identity field there are one or more sets of ResOps fields each set comprising a prefix field a rule field and a hash results field e.g. prefix rule and hash results prefix rule and hash results . . . prefix rule and hash results . The prefix field specifies the initial portion of the resource and is to be combined with the resource suffixes in the ResOp set by simple concatenation. Moreover the token is usable on by a plurality of service providers. The prefix fields indicate on which one or more service providers the token may be used. In the example token given below the prefix http cisco.webex.com refers to one service provider while the prefix http go.webex.com refers to another service provider. The rule field specifies a rule associated with the resource such as allow deny or other rules such as delegate. The hash results field contains the hash results for a subset of resource operations tuples. Thus there is a list of hash results each having an associated prefix and rules for the operations indicated in the hash results. There is also an extension field after the ResOps fields. The extension field contains additional data provided by a service provider upon provisioning such as inputs to other more complicated authorization schemes. The signature field contains a cryptographic signature computed across all of the other fields shown in and may be optional in some applications.

Turning now to a flow chart is described for techniques to minimize redundancy of data in the token by selecting a subset of resource operations tuples that minimizes redundancy. At in generating the token the lists of hash results may be separated such that the resource with the same prefix goes into the same list. At the minimal number of lists is output for inclusion in the token.

Multiple users will have the same set of authorizations. If the system maximizes the number of times that the same ResOp set occurs more efficient caching can be performed on the hash of that set. There are several mechanisms which can increase the number of collisions.

First the ResOp set is shared between users of the system. Second the Universal Resource Locator URL prefix e.g. scheme hostname port can be removed from the hash thereby reusing the hash across machines. Third new lists with different prefixes can be added rather than creating a new longer list. Fourth allowing resources to apply hierarchically with match up to the next special character like and match all resources that start with this resource . In addition excess ResOps whose resource and operation match can be removed. Further still ResOps that are more restrictive than a higher level authorization which grants access to that same feature can be removed. For example top GET PUT contains top next GET so the latter is redundant and may be removed.

Reference is now made to which illustrates an overall flow diagram for the operations performed by a client the service provider and authorization server . At the client sends a request GetToken to obtain a token from the authorization server . At the authorization server sends the token optionally signed to the client .

The client provides the token every time it performs an operation on a resource of a service provider. Thus a the client sends the token with a request to perform an operation on a resource to the service provider . At the service provider checks the signature of the token and its validity time to determine that the signature is valid and that it is not expired. If the signature and or validity time is not valid then the process stops and an appropriate message is sent to the client notifying the client of the token validity failure. If the signature and time validity check passes then at the service provider can grant access to one or more resources and operations on the service provider and the service provider checks its ResOp cache to see if the operation requested is in its ResOp cache. If it is in the ResOp cache then the processing continues at . If it is not in the ResOp cache then at the service provider sends a request to get the ResOp Get ResOp to the authorization server . At the authorization server responds by sending the entire set of resource operations tuples as described above in connection with for the service provider and the associated hash results computed by the authorization server.

At the service provider checks the hash results sent by the authorization server and if the hash results are consistent with the set of resource operations tuples contained in the response sent at then the service provider can store them in its ResOp cache.

At the service provider checks to ensure that the ResOp desired is allowed in the token and otherwise satisfies any rules in the token. If the ResOp is not allowed or does not otherwise satisfy specified rules in the token an error message is returned to the client. At the service provider performs the requested service operation and sends the results to the client if the service operation worked as desired.

Once all of the ResOp lists pointed to in the token are cached and pre processed the checks at and can be performed quite rapidly without accessing a service running on a separate machine. When cache hits are common the system can perform well at scale allowing bounds on memory usage by any given process by aging the least recently used ResOp lists out of the cache.

The Application Programming Interface API framework to support the operations depicted in include APIs to check token validity de reference ResOp URI check hash results as well as matching a host source to an operation via an URI .

Clients need to be able to determine what actions the current user is authorized to perform in order to optimize the user experience. The mechanism specified above for the service provider is simple enough such that clients may have their own implementations. Removing the need for the client to constantly inquire if a feature is authorized substantially reduces server traffic.

Clients will also examine the contents of the token to retrieve the expiry times indicated by the start and stop time fields so that they can generate a new token before the old one expires. A further refinement will allow notification via a publish subscribe mechanism when the authorization server detects that an existing token is no longer valid.

None of the operations described herein require the authorization server to understand anything about HTTP e.g. the valid operations or HTTP URLs. Non HTTP service providers can create string representations of their resources and operations in a consistent fashion often using an available URI scheme as the encoding process.

Reference is now to for an example of how a client may use a received token. At the client parses a token received from the authorization server and retrieves the list of subsets from the token. At the client retrieves for each hash results in the list in the token the corresponding ResOp subset. At the client searches for a resource and an operation that are associated with a user interface element. For example as shown in the resource and operation that the client can perform is a print resource e.g. the aforementioned explicit resource print that has operations DELETE and POST for which a print icon is displayed. The client searches for that resource and operation in each of the ResOps subsets retrieved in . If that resource and operation is found the client is authorized for the print resource. Otherwise the print icon is grayed out or opaque as shown in .

Thus show that a client gets refreshes tokens from the authorization server and maps ResOps to user interface elements such that unauthorized resources may be indicated as a removed or gray out user interface element.

Turning now to a diagram is shown that depicts how ResOps are loaded into the authorization server . ResOps may be injected into the authorization server from a variety of resources including entitlement billing administration and other entities such as security etc. The entitlement server will load user entitlements the billing server will load billing entitlements and the administration server will load custom organizational policies. The authorization server will then build the set of resource operations tuples and can use this information to generate and sign tokens at the request of clients.

The memories and shown in may comprise read only memory ROM random access memory RAM magnetic disk storage media devices optical storage media devices flash memory devices electrical optical or other physical tangible e.g. non transitory memory storage devices. The processors shown in are for example a microprocessor or microcontroller that executes instructions in their associated memory. Thus in general the memories and may comprise one or more tangible non transitory computer readable storage media e.g. a memory device encoded with software comprising computer executable instructions and when the software is executed by a processor it is operable to perform the operations described herein.

In summary disclosed herein is a scalable performant cross protocol mechanism for describing transmitting and checking large lists of authorizations for operations on network resources. This mechanism drastically reduces the size of tokens that would otherwise contain exhaustive lists of all of the authorizations required to access a service. This allows the mechanism to be used for much finer grained authorizations without sacrificing latency of processing.

