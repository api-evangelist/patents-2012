---

title: System and method for automatically generating coverage constructs and constraint solver distributions
abstract: The present disclosure relates to a computer-implemented method for electronic design simulation. The method may include providing, using at least one computing device, an electronic design and associating, using the at least one computing device, one or more identifiers with each constraint solver call utilized in a simulation of the electronic design. The method may further include automatically generating, using the at least one computing device, a coverage model for one of more constraints associated with the electronic design, the coverage model being based upon, at least in part, the one or more identifiers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904321&OS=08904321&RS=08904321
owner: Cadence Design Systems, Inc.
number: 08904321
owner_city: San Jose
owner_country: US
publication_date: 20121106
---
The present disclosure relates to electronic design automation and more specifically to a method for automatically generating coverage constructs and constraint solver distributions associated with an electronic design simulation.

Electronic design automation EDA utilizes software tools that may be used in the design and analysis of numerous electronic systems such as printed circuit boards PCBs and integrated circuits ICs . Verification environments include constraints that describe the relationship between the variables that control the simulation and sometimes the data that is used as well . Coverage models in the verification environment capture which parts of the solution space have been covered by the stimulus created with the constraints constraint solver. These coverage models allow the results from many simulations to be merged showing which random variables were chosen. These coverage models are currently created manually a tedious complex and error prone task.

In one or more embodiments of the present disclosure a computer implemented method for electronic design simulation. The method may include providing using at least one computing device an electronic design and associating using the at least one computing device one or more identifiers with each constraint solver call utilized in a simulation of the electronic design. The method may further include automatically generating using the at least one computing device a coverage model for one of more constraints associated with the electronic design the coverage model being based upon at least in part the one or more identifiers.

One or more of the following features may be included. In some embodiments the method may include analyzing the coverage model using a constraint solver. The method may further include identifying a number of variables associated with each constraint solver call. The method may also include identifying a type of variable associated with each constraint solver call. The method may additionally include generating a simulation report including simulation results associated with the coverage model. The method may further include identifying a failed subset of the electronic design based upon at least in part the simulation report. The method may also include identifying a value of a variable associated with each constraint solver call.

In some embodiments a computer readable storage medium for electronic design simulation is provided. The computer readable storage medium may have stored thereon instructions that when executed by a machine result in one or more operations. Operations may include providing using at least one computing device an electronic design and associating using the at least one computing device one or more identifiers with each constraint solver call utilized in a simulation of the electronic design. Operations may further include automatically generating using the at least one computing device a coverage model for one of more constraints associated with the electronic design the coverage model being based upon at least in part the one or more identifiers.

One or more of the following features may be included. In some embodiments operations may include analyzing the coverage model using a constraint solver. Operations may further include identifying a number of variables associated with each constraint solver call. Operations may also include identifying a type of variable associated with each constraint solver call. Operations may additionally include generating a simulation report including simulation results associated with the coverage model. Operations may further include identifying a failed subset of the electronic design based upon at least in part the simulation report. Operations may also include identifying a value of a variable associated with each constraint solver call.

In one or more embodiments of the present disclosure a system may include a computing device having at least one processor configured to simulate an electronic design and provide an electronic design and associate one or more identifiers with each constraint solver call utilized in a simulation of the electronic design. The at least one processor may be further configured to automatically generate a coverage model for one of more constraints associated with the electronic design the coverage model being based upon at least in part the one or more identifiers.

One or more of the following features may be included. In some embodiments the at least one processor may be further configured to analyze the coverage model using a constraint solver. The at least one processor may be further configured to identify a number of variables associated with each constraint solver call. The at least one processor may be further configured to identify a type of variable associated with each constraint solver call. The at least one processor may be further configured to generate a simulation report including simulation results associated with the coverage model. The at least one processor may be further configured to identify a failed subset of the electronic design based upon at least in part the simulation report. The at least one processor may be further configured to identify a value of a variable associated with each constraint solver call.

Additional features and advantages of embodiments of the present disclosure will be set forth in the description which follows and in part will be apparent from the description or may be learned by practice of embodiments of the present disclosure. The objectives and other advantages of the embodiments of the present disclosure may be realized and attained by the structure particularly pointed out in the written description and claims hereof as well as the appended drawings.

It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory and are intended to provide further explanation of embodiments of the invention as claimed.

Constrained random verification environments may exhibit a number of problems. Some of these may include but are not limited to expected values are not reached the values are chosen less frequently or more frequently than expected the constraint solver calls take too long to finish the solver is unable to find a solution for a given constraint set the solver is unable to find a solution with certain starting conditions including variables that are not random or handles and arrays that are not initialized the solver runs out of memory etc. Typical constrained random verification environments use many randomized constraint solver calls to determine the configuration of the design being verified and the data used to verify the chosen configuration.

Additionally time based breakpoint or single stepping techniques for resolving coding mistakes may not work well for solving constraint issues. Many constraint solver calls happen in the same simulator time step. They may also occur before any simulation time has been consumed. The same randomized call may also be called thousands of times in the same simulation each time with a different seed or different state variables.

Some constraints e.g. SystemVerilog may be expressed in a declarative not procedural way. Variables related to each other by constraint operators must be solved so that a uniform distribution in the solution space is provided. This usually means that the related variables known as a variable partition are solved concurrently. Resolving constraint solver issues presents a unique challenge because of this concurrent processing. A single randomized call may also be broken down by the constraint solver engine into many layers for a variety of reasons including but not limited to the partitioning of variables solve before constraints function calls in the constraints etc. The manner in which the solving process is broken into steps is often not obvious further complicating the analysis process.

Reference will now be made in detail to the embodiments of the present disclosure examples of which are illustrated in the accompanying drawings. The present disclosure may however be embodied in many different forms and should not be construed as being limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the concept of the disclosure to those skilled in the art.

As will be appreciated by one skilled in the art the present disclosure may be embodied as a method system or computer program product. Accordingly the present disclosure may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore the present disclosure may take the form of a computer program product on a computer usable storage medium having computer usable program code embodied in the medium.

Any suitable computer usable or computer readable medium may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer usable or computer readable storage medium including a storage device associated with a computing device or client electronic device may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device. In the context of this document a computer usable or computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with the instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program coded embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations of the present disclosure may be written in an object oriented programming language such as Java Smalltalk C or the like. However the computer program code for carrying out operations of the present disclosure may also be written in conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present disclosure is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable memory that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable memory produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide steps for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Referring to there is shown identifying process and coverage generation process that may reside on and may be executed by server computer which may be connected to network e.g. the Internet or a local area network . Examples of server computer may include but are not limited to a personal computer a server computer a series of server computers a mini computer and a mainframe computer. Server computer may be a web server or a series of servers running a network operating system examples of which may include but are not limited to Microsoft Windows Server Novell NetWare or Red Hat Linux for example. Microsoft and Windows are registered trademarks of Microsoft Corporation in the United States other countries or both Novell and NetWare are registered trademarks of Novell Corporation in the United States other countries or both Red Hat is a registered trademark of Red Hat Corporation in the United States other countries or both and Linux is a registered trademark of Linus Torvalds in the United States other countries or both. Additionally alternatively the report generation process may reside on and be executed in whole or in part by a client electronic device such as a personal computer notebook computer personal digital assistant or the like.

The instruction sets and subroutines of identifying process and coverage generation process which may include one or more software modules and which may be stored on storage device coupled to server computer may be executed by one or more processors not shown and one or more memory modules not shown incorporated into server computer . Storage device may include but is not limited to a hard disk drive a solid state drive a tape drive an optical drive a RAID array a random access memory RAM and a read only memory ROM . Storage device may include various types of files and file types including but not limited to hardware description language HDL files which may contain the port type descriptions and executable specifications of hardware blocks.

Server computer may execute a web server application examples of which may include but are not limited to Microsoft IIS Novell Webserver or Apache Webserver that allows for HTTP i.e. HyperText Transfer Protocol access to server computer via network Webserver is a trademark of Novell Corporation in the United States other countries or both and Apache is a registered trademark of Apache Software Foundation in the United States other countries or both . Network may be connected to one or more secondary networks e.g. network examples of which may include but are not limited to a local area network a wide area network or an intranet for example.

Server computer may execute an electronic design automation EDA application e.g. EDA application examples of which may include but are not limited to those available from the assignee of the present application. EDA application may interact with one or more EDA client applications e.g. EDA client applications for report generation. EDA application may be referred to herein as a design tool.

Identifying process and coverage generation process may each be a stand alone application or may be an applet application script that may interact with and or be executed within EDA application . In addition as an alternative to being a server side process the browsing process may be a client side process not shown that may reside on a client electronic device described below and may interact with an EDA client application e.g. one or more of EDA client applications . Further the browsing process may be a hybrid server side client side process that may interact with EDA application and an EDA client application e.g. one or more of client applications . As such the browsing process may reside in whole or in part on server computer and or one or more client electronic devices.

The instruction sets and subroutines of EDA application which may be stored on storage device coupled to server computer may be executed by one or more processors not shown and one or more memory modules not shown incorporated into server computer .

The instruction sets and subroutines of EDA client applications which may be stored on storage devices respectively coupled to client electronic devices respectively may be executed by one or more processors not shown and one or more memory modules not shown incorporated into client electronic devices respectively . Storage devices may include but are not limited to hard disk drives solid state drives tape drives optical drives RAID arrays random access memories RAM read only memories ROM compact flash CF storage devices secure digital SD storage devices and a memory stick storage devices. Examples of client electronic devices may include but are not limited to personal computer laptop computer mobile computing device such as a smart phone netbook or the like notebook computer for example. Using client applications users may access EDA application and may allow users to e.g. utilize identifying process and coverage generation process .

Users may access EDA application directly through the device on which the client application e.g. client applications is executed namely client electronic devices for example. Users may access EDA application directly through network or through secondary network . Further server computer i.e. the computer that executes EDA application may be connected to network through secondary network as illustrated with phantom link line .

The various client electronic devices may be directly or indirectly coupled to network or network . For example personal computer is shown directly coupled to network via a hardwired network connection. Further notebook computer is shown directly coupled to network via a hardwired network connection. Laptop computer is shown wirelessly coupled to network via wireless communication channel established between laptop computer and wireless access point i.e. WAP which is shown directly coupled to network . WAP may be for example an IEEE 802.11a 802.11b 802.11g Wi Fi and or Bluetooth device that is capable of establishing wireless communication channel between laptop computer and WAP . Mobile computing device is shown wirelessly coupled to network via wireless communication channel established between mobile computing device and cellular network bridge which is shown directly coupled to network .

As is known in the art all of the IEEE 802.11x specifications may use Ethernet protocol and carrier sense multiple access with collision avoidance i.e. CSMA CA for path sharing. The various 802.11x specifications may use phase shift keying i.e. PSK modulation or complementary code keying i.e. CCK modulation for example. As is known in the art Bluetooth is a telecommunications industry specification that allows e.g. mobile phones computers and personal digital assistants to be interconnected using a short range wireless connection.

Client electronic devices may each execute an operating system examples of which may include but are not limited to Microsoft Windows Microsoft Windows CE Red Hat Linux or other suitable operating system. Windows CE is a registered trademark of Microsoft Corporation in the United States other countries or both. .

As shown in and as will be discussed in further detail below identifying process may include providing an electronic design. Identifying process may further include associating an identifier with each constraint solver call utilized in a simulation of the electronic design. Identifying process may also include generating an application programming interface configured to allow a user to navigate through electronic design simulation results based upon at least in part the identifier associated with each constraint solver call.

In some embodiments during the simulation of an electronic design the verification environment may ask the constraint solver to return one or more sets of values that meet the specified constraints. For example if a video core is being tested the first choice may be which codec to use from a list e.g. MP4 H.264 WMV AVI etc. . The next choice may be which screen resolution to use e.g. 1024 768 1600 1024 1900 1200 etc. . Each of these choices could be made with a separate constrained call to the constraint solver. In a real verification environment there may be thousands of calls. If there is an issue with the call to the constraint solver then it can be difficult to identify the constraint solver call in a way that both the engineer and simulator can understand. It is also important to be able to return to exactly the same constraint solver call after an issue in the constraints has been fixed to validate the fix. Each individual constraint solver can be further sub divided into solve before layers. This can happen manually using solve before statements and can happen automatically if there is a construct in the constraints like a function call that is not transparent to the constraint solver. Again it is vital for resolving issues improving performance and reducing memory consumption that the engineer can return to a specific solve before layer in a specific constraint solver call quickly. The results from the constraint solver call often drive decision points in the simulation branches where the simulation branches to cover a certain area of the design solution space. Knowing the constraint solver output and the memory and performance profile of the simulator can help isolate and resolve simulation and verification environment issues. Traditional profiling solutions are time based. As many constraint solver calls can happen on the same time step there are many issues that are hard to resolve using time based methods.

Accordingly identifying process described herein may enable a unique numbering system for each constraint solver call. Additionally and or alternatively identifying process may be configured to uniquely number each layer of the constraint solving process. Identifying process may be configured to allow for the generation of an application programming interface API based on these unique numbers that may provide the user with various controls. Some of these controls may include but are not limited to starting stopping and or pausing the simulation the enabling and or disabling of the printing of debugging information the enabling and or disabling of testcase generation for the constraint solver the enabling and or disabling of performance and memory consumption information. Identifying process may also be configured to allow the user to run a user defined script when the constraint solver runs.

In this way identifying process by uniquely numbering each constraint solver call and uniquely numbering each layer may allow the engineer controlling the simulation to return to a specific constraint solver call. Additionally and or alternatively from this point in the simulation identifying process may enable or disable additional debug information and may generate memory and performance profile data from the simulator at specific points in the simulation. Identifying process may also be configured to automatically generate test case and debug information at a specific constraint solver call. Identifying process may also be configured to automatically generate performance and memory consumption information about the verification environment when the constraint solver runs and or at interesting branch points in the simulation. Identifying process may also be configured to generate performance and memory consumption data about specific constraint solver calls.

Accordingly identifying process may be configured to allow users to visualize the impact of their constraints and to quickly return to the point in a simulation where the constraint solver gave undesirable results caused simulation memory to grow and or took an extended period of time to solve. Identifying process may be configured to allow users to assess the impact of changes that were made in the verification environment.

Referring now to an embodiment depicting an example verification environment that may be used to verify a video core is provided. In this constrained random environment a randomize call may be used to determine the configuration of the device under test DUT . There are many constraint solver calls but the highlighted call calculates the configuration of the design. This may be applicable for other constraint calls but in this case configuration has been chosen. In the individual test described in 2 frames a H264 decoder and a screen resolution of 1024 768 have been selected as indicated by the shaded sections shown in . As discussed herein identifying process may be configured to allow a constraint call to be identified. Accordingly the simulation may be automatically stopped when it reaches the constraint call and many iterations run on the same call with different seeds. A verification environment may include thousands of similar calls each call determining the configuration or data for a certain part of the environment. The values chosen by the early constraint solver calls may exclude other constraint solver calls from being executed. The first step in resolving the issues described above is to label the constraint solver calls. Embodiments included here may be configured to perform this automatically.

Embodiments described herein may provide various types of feedback to the user. For example in some embodiments the source file and line number where the randomize call is located may be shown first then the text of that randomize call may be shown. This may be followed by the type of the object being randomized then the seed used for that particular randomize call. When the randomize call ends that may be noted in the debug output which may include the memory and CPU time used for this call and the cumulative values for memory and CPU time. These values may be specified for various components of randomization. For example in SystemVerilog SVRNC is the language processing layer and RNC which is the constraint solver. Additionally and or alternatively a randomized call where the solver uses an excessive amount of time or memory to solve the constraints may be readily indicated by showing the start and end points of the randomization call and the memory and CPU time consumed. If the user is debugging a randomized problem deep into the simulation and wants to avoid filling up their log files with this type of output they can delay its initiation using an environment variable.

Referring now to and as will be discussed in further detail below coverage generation process may include providing using at least one computing device an electronic design. Coverage generation process may further include associating using the at least one computing device one or more identifiers with each constraint solver call utilized in a simulation of the electronic design. Coverage generation process may further include automatically generating using the at least one computing device a coverage model for one of more constraints associated with the electronic design the coverage model being based upon at least in part the one or more identifiers.

As discussed above verification environments may include constraints to describe the relationship between the variables that control the simulation and sometimes the data that is used as well . Coverage models in the verification environment may be used to capture those parts of the solution space that have been covered by the stimulus created with the constraints constraint solver. These coverage models may allow the results from many simulations to be merged showing which random variables were chosen. In existing solutions the coverage models are currently created manually a tedious complex and error prone task.

Accordingly the coverage generation process described herein may be configured to generate the coverage models automatically from the constraints that already exist in the environment. In this way coverage generation process may be configured to iterate the constraint solver on a specific constraint rather than running it once to allow the distribution of results to be collected.

In this way coverage generation process may eliminate the requirement of the verification engineer having to write complex cover groups manually. Coverage generation process may be configured to generate the cover groups e.g. SystemVerilog automatically saving considerable time and mistakes. As a result the user e.g. verification engineer need not run thousands of simulations taking significant time coverage generation process may iterate on a specific constraint a user selectable number of times to generate the range of likely values. This is in contrast to existing solutions that require manual generation of cover groups.

In some embodiments coverage generation process may utilize a unique numbering scheme for constraint solver calls as discussed above. In this way the user can specify a specific constraint solver call to analyze and may analyze the coverage model using a constraint solver. Accordingly when the simulation reaches this point coverage generation process may identify the number and type of random variables associated with each constraint solver call. Coverage generation process may also know the type and value state e.g. fixed not random variables. The values of the state variables may be dependent on earlier constraint solutions which is why it is important that the specific constraint solver call can be identified. The random state and class structure for the solve may be written out making an environment that only expresses this one constraint problem. This may pull all of the constraints that could be widely separated in the original environment into this smaller example which is likely much smaller than the original environment. The constraint solver may then iterate on the constraint problem writing out the results. This may give an indication of the possible solutions and the distribution of those solutions.

Using the coverage generation process described herein changes in constraints may be quickly implemented and tested using the small environment. If the user believes that the constraint solver is choosing incorrect values or not finding values that are legal this may allow them to share a small automatically generated test case without having to expose the intellectual property in their main environment. This small test case may be ideal for the regression environment ensuring that the issue will be trapped should it reoccur. It will also minimize the time spent by field personnel as they will not have to work on the test case just implementing the fix. It may take many hours of simulation to reach this constraint solving problem in the main environment. Writing out a small test case allows the user to quickly test solutions.

In some embodiments additional information about the internal operations of a randomize call can be enabled using an environment variable. The additional information displayed as a result of setting this environment variable may include but is not limited to the partitions of variables that are related by constraint operators the order in which variable partitions are solved the order in which variables within a partition are solved the properties of variables during the solving of a partition e.g. random state variable i.e. not random and previously solved etc.

Referring now to embodiments depicting simulation reports generated in accordance with coverage generation process are provided. Each simulation report may include simulation results associated with the coverage model. Coverage generation process may also be configured to identify a failed subset of the electronic design based upon the simulation report.

In some embodiments as the regression runs coverage generation process may then indicate the coverage of the configuration that has been reached. This can be seen in . depicts the results after 50 simulations depicts the results after 150 and depicts the results after 300. Existing solutions require that the code to generate this coverage information be generated manually. Automating this process via coverage generation process minimizes time eliminates some errors and allows the coverage information to be quickly updated as the constraints change. This information may be further processed to calculate the advantage of running further simulations.

In existing solutions the information shown in Table 1 may be gathered by running thousands of simulations and then merging the data in groups to see the impact of adding more simulations. This process needs to be repeated when the stimulus constraints change. Many project teams decide to run more tests in some cases thousands to ensure they are reaching all of the coverage that they can based on the constraints they have with little or no information on the impact of these tests. In contrast coverage generation process allows this information to be gathered quickly from one simulation run and processed automatically and quickly saving many hours of manual work and computer time. It should be noted that this particular example does not demonstrate that the configurations can be filtered into a list only containing unique legal configurations. Each simulation on the simulation grid can then use a line from the file to ensure it is running a unique configuration. This eliminates the replication that occurs when many simulations randomly select the same configuration which may allow coverage closure to be reached much faster.

In some embodiments EDA application may be configured to perform testbench automation reuse and analysis to verify designs from the system level through RTL to the gate level. EDA application may support a metric driven approach and may utilize a native compiled architecture in order to speed the simultaneous simulation of transaction level behavioral low power RTL and gate level models.

In some embodiments EDA application may support a variety of languages and or standards. Some of these may include but are not limited to IEEE standard languages the Open Verification Methodology OVM the emerging Accellera Universal Verification Methodology UVM and the e Reuse Methodology eRM . EDA application may support one or more software extensions which may provide a high throughput channel between the testbench and the device under test DUT and enable automated metric driven verification of embedded software exactly as if it were another part of the DUT.

Accordingly EDA application may be configured to fuel testbench automation analysis and reuse for increased productivity. EDA application may be configured to ensures verification quality by tracking industry standard coverage metrics including functional transactional low power and HDL code plus automatic data and assertion checking EDA application may be configured to drive and or guide verification with an automatically backannotated and executable verification plan. EDA application may be configured to create reusable sequences and multi channel virtual sequences on top of a multi language verification environment and to configure existing Universal Verification Components UVCs or quickly constructs all new UVCs. EDA application may be configured to enable advanced debug for transaction level models SystemVerilog e class libraries transient mixed signal low power and traditional waveform analysis.

In some embodiments EDA application may supports e Open Verification Library OVL OVM class library emerging UVM class library SystemC SystemC Verification Library SystemVerilog Verilog VHDL PSL SVA CPF as well as numerous other languages. EDA application may be used in accordance with mixed language mixed signal and low power designs across multiple levels of abstraction and may include the ability to hot swap the RTL simulation in out of numerous accelerators emulators.

As used in any embodiment described herein the terms circuit and circuitry may include for example singly or in any combination hardwired circuitry programmable circuitry state machine circuitry and or firmware that stores instructions executed by programmable circuitry. It should be understood at the outset that any of the operations and or operative components described in any embodiment herein may be implemented in software firmware hardwired circuitry and or any combination thereof. Embodiments of the present disclosure may be incorporated in whole or in part into any design tools.

It will be apparent to those skilled in the art that various modifications and variations can be made in the embodiments of the present disclosure without departing from the spirit or scope of the present disclosure. Thus it is intended that embodiments of the present disclosure cover the modifications and variations provided they come within the scope of the appended claims and their equivalents.

