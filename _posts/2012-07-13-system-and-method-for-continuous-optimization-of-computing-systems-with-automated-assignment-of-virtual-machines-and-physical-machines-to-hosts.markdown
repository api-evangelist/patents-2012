---

title: System and method for continuous optimization of computing systems with automated assignment of virtual machines and physical machines to hosts
abstract: A system and method for automatically reconfiguring a computing environment comprises a consumption analysis server, a placement server, a deployment server in communication with a set of virtual machine monitors and a data warehouse in communication with a set of data collection agents, and a database. The consumption analysis server operates on measured resource utilization data in the data warehouse to yield a set of resource consumptions, available capacities and host and virtual machine configurations from the computing environment. The deployment server continuously monitors an event triggering condition and when the triggering condition is met, the placement server assigns a set of target virtual machines to a target set of hosts in a new placement and the deployment server implements the new placement through communication with the set of virtual machine monitors. The placement server right-sizes the virtual machines and the target set of hosts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396008&OS=09396008&RS=09396008
owner: CA, Inc.
number: 09396008
owner_city: New York
owner_country: US
publication_date: 20120713
---
The present disclosure relates to performance of computing systems and more specifically to a system and method for the placement and management of actual and virtual machines in modern computing environments containing virtualization hosts including cloud computing environments. The term cloud computing environment is used to represent all computing environments.

A cloud computing environment provides a set of services through use of one or more data centers accessible by a set of clients usually via a network such as the Internet. A data center includes a collection of computer clusters storage subsystems and other components connected by a computer network. In a virtualization environment each host in a computer cluster provides a set of physical resources such as CPUs memory disks and network interface cards NICS and runs a virtual machine monitor VMM that emulates a set of virtual machines. Each virtual machine is configured with a set of virtual resources such as virtual CPUs VCPUs and memory.

In a cloud computing environment appropriate assignment of virtual machines to hosts and configuration of virtual machines hosts resource pools and computer clusters affects performance service agreements and resource availability. Assignment of virtual machines to differing hosts is often required to provide optimum load balancing and manage infrastructure costs. The size complexity and rate of change of resource consumption makes assignment of virtual machines to hosts difficult and time consuming. So an automated process for optimizing assignment is required.

Appropriate placement of virtual machines is related to a classical bin packing problem in that resources consumed by each virtual machine must be packed into the corresponding resource bin on a host. Each virtual machine when deployed on a host consumes a portion of the host s resource capacity as a function of its configuration and workload. Thus in the virtual machine placement problem 1 each virtual machine presents a different size resource consumption over time 2 the host resource bin sizes resource capacities vary from placement to placement and 3 the set of resource consumptions by each virtual machine may be assigned to only one host.

An infrastructure management system and method is disclosed for reconfiguration of a source computing system into a destination computing system with a new placement of a target set of virtual machines on a target set of hosts. According to one aspect of the present disclosure the infrastructure management system comprises a server having a processor a memory and a set of program instructions stored in the first memory. The processor executes the set of program instructions and determines a new placement of the target set of virtual machines on the target set of hosts wherein the new placement comprises a set of virtual machine host pairs from the target set of hosts and the target set of virtual machines. The infrastructure management system automatically reconfigures a source computing system into a destination computing system according to the new placement.

In another aspect of the present disclosure the infrastructure management system removes a set of movable virtual machines from the source computing system installs the set of movable virtual machines in the destination computing system according to the new placement and installs a set of new virtual machines in the destination computing system according to the new placement.

In another aspect wherein the target set of virtual machines comprises a set of new virtual machines a set of existing unmovable virtual machines and a set of existing movable virtual machines the infrastructure management system determines a source configuration from a source set of physical machine configurations a source set of host configurations the set of existing unmovable virtual machines and the set of existing movable virtual machines. The infrastructure management system further determines an initial placement from the set of unmovable virtual machines and the set of movable virtual machines and the source configuration and converts the initial placement into the new placement using a set of placement modifications. The infrastructure management system determines an additional host requirement based on the target set of virtual machines. In a further aspect the new placement is right sized.

A method for reconfiguring the source computing system to the destination computing system is disclosed. According to a first aspect of the present disclosure the reconfiguration method determines a new placement of the target set of virtual machines on the target set of hosts the set of host resource capacities and the set of virtual machine resource consumptions. The new placement comprises a set of virtual machine host pairs derived from the target set of hosts and the target set of virtual machines. The method automatically reconfigures the source computing system into the destination computing system with the new placement.

In another aspect the method determines a source configuration for the source computing system determines the new placement based on the workload forecast and the source configuration and determines an additional host requirement based on the target set of virtual machines.

In an aspect of a placement process of the present disclosure the method determines the new placement and a new placement score based on an event condition and compares the new placement score to a threshold requirement. If the threshold requirement is met then the method implements the target set of virtual machines on the target set of hosts using a set of virtual machine monitors.

In an aspect of determining the threshold requirement a total available capacity for the target set of hosts is determined a total resource consumption for the target set of virtual machines is determined and a normalized difference between the total available capacity and the total resource consumption is determined. In a further aspect the threshold requirement is derived by multiplying the normalized difference by a scoring factor. In a first right sizing aspect a number of hosts to add to the target set of hosts is determined based on the normalized difference. In a second right sizing aspect a number of hosts to remove from the target set of hosts is determined based on the normalized difference.

In a further aspect of the method a workload forecast for a proactivity time is determined. The source computing system is monitored until a stop condition occurs. The method evaluates a placement triggering condition and based on the placement triggering condition the new placement is determined for the workload forecast. The target set of virtual machines are reassigned according to the new placement. In another aspect the method further removes a set of movable virtual machines from the source computing system installs the set of movable virtual machines and the set of new virtual machines in the destination computing system according to the new placement.

In another aspect the method comprises determining a source configuration for the source computing system and determining the new placement based on a workload forecast and the source configuration. The method further comprises determining if an additional set of hosts are required to accommodate the target set of virtual machines and a number of hosts to add. The method implements the new placement in the destination computing system.

As will be appreciated by one skilled in the art aspects of the present disclosure may be illustrated and described herein in any of a number of patentable classes or context including any new and useful process machine manufacture or composition of matter or any new and useful improvement thereof. Accordingly aspects of the present disclosure may be implemented entirely in hardware entirely in software including firmware resident software micro code etc. or combining software and hardware implementation that may all generally be referred to herein as a circuit module component or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. The computer readable media may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an appropriate optical fiber with a repeater a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java Scala Smalltalk Eiffel JADE Emerald C C VB.NET Python or the like conventional procedural programming languages such as the C programming language Visual Basic Fortran 2003 Perl COBOL 2002 PHP ABAP dynamic programming languages such as Python Ruby and Groovy or other programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider or in a cloud computing environment or offered as a service such as a Software as a Service SaaS .

Aspects of the present disclosure are described herein with reference to flowchart illustrations and or block diagrams of methods apparatuses systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable instruction execution apparatus create a mechanism for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that when executed can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions when stored in the computer readable medium produce an article of manufacture including instructions which when executed cause a computer to implement the function act specified in the flowchart and or block diagram block or blocks. The computer program instructions may also be loaded onto a computer other programmable instruction execution apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatuses or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The systems and methods of the present disclosure are applicable to any modern computing environment containing virtualization hosts including a cloud computing environment. For the purposes of the present disclosure a cloud computing environment physically comprises a set of host servers interconnected by a network which can be organized in any of a number of ways including but not limited to the examples that follow here and in the descriptions of the drawings. For example the set of host servers can be organized by application function such as web servers database servers and specific application servers of multiple applications. The set of host servers can be organized by physical location for example a first subset of host servers operating in a first data center a second subset of host servers operating in a second data center on a first network a third set subset of host servers operating in the second data center on a second network and so forth. The set of host servers can be organized into a set of host clusters wherein each host cluster comprises a subset of host servers and functions to manage a set of shared resources in a set of resource pools for the subset of host servers. Multiple sets of host clusters within a cloud computing environment can be further organized into logical groups of clusters referred to as superclusters.

A dominant attribute of a cloud computing environment is that applications and resources of the associated computing cloud are available as a set of services to client systems over the network which is usually a wide area network such as the Internet but also encompasses a corporate intranet where the applications and resources are physically diversified.

Another important attribute of a cloud computing environment utilized in this present disclosure is that cloud based applications and resources are usually operated and managed by a set of virtual machines deployed across the set of host servers wherein each host server can host multiple virtual machines VMs and includes a virtual machine monitor VMM that manages the local resources of the host server and installs new machines. A virtual machine can be moved from one host server to another host server as a complete computing unit having a guest operating system and a specified set of resource requirements managed by the VMM such as processor consumption requirements measured in virtual processing units known as VCPUs memory consumption requirements network bandwidth requirements and so forth. In many virtualization environments the VMM is referred to as a hypervisor.

Virtualization tools for creating and managing virtual machines for most computer and server hardware platforms are provided by a number of vendors including for example VMware Inc. of Palo Alto Calif. VMware IBM of AIX zNM Hewlett Packard of HP UX and various open source virtualization tools for Linux e.g. XEN OpenVZ Vserver KVM . The embodiments of the present disclosure are not limited by any specific virtualization tool but rather intended to interwork with all existing and future virtualization tools.

Optimization in the context of the present disclosure generally means risk minimization. Reconfiguration according to the present disclosure is done by performing a process of placing a set of VMs on a set of hosts resulting in multiple placements. An objective function is described for scoring placements and selecting placements that minimize risk that any resource on any host becomes over consumed. The reconfiguration process has an additional benefit of balancing resource consumption across the set of hosts thereby reducing response times.

Referring to a system for reconfiguration and optimization of a cloud computing environment is shown. Cloud computing environment comprises a group of data centers including data center connected to a network . Data center is a representative data center in the group of data centers. A set of clients also connected to network are connected to cloud computing environment and produce a workload for computing operations in the cloud computing environment. Data center comprises a network a set of physical servers and cluster of host servers. A physical server in the set of physical servers comprises a set of resources including but not limited to CPU memory network interface and operating system resources. Set of physical servers is instrumented with set of data collection agents that monitor the real time resource consumption of the set of resources . Host is a representative host server in cluster of host servers. Host comprises a set of host resources including but not limited to CPU memory network interface and operating system resources. Host further comprises a set of virtual machines of which each virtual machine consumes a portion of the set of host resources . Host further comprises a virtual machine monitor VMM that negotiates and manages the resources for set of virtual machines and performs other general overhead functions. VMM is one member of a set of virtual machine monitors wherein each virtual machine monitor is included with each host in cluster .

Cluster includes a set of data collection agents that monitor the real time resource consumption of the set of resources and monitors resources for all other hosts in the cluster. Network also includes a set of network data collection agents that monitor the real time consumption of network resources for example router and interconnection usage and workload arrival rates. Networks and are typically Ethernet based networks. Networks and can be a local area network wide area network public network or private network as required by applications served by the cloud computing environment.

The group of data centers are monitored and managed by a novel infrastructure management system communicating with an infrastructure management client . The infrastructure management system comprises a data warehouse with database a consumption analysis server connected to data warehouse and database a placement server connected to consumption analysis server and database and a web server connected to infrastructure manager client database and placement server . Infrastructure management system further comprises a deployment server in communications with the set of virtual machine monitors including VMM . The deployment server is also connected to database web server infrastructure manager client and placement server .

In an embodiment the consumption analysis server the placement server and the deployment server operate on different physical machines. In an alternate embodiment two or more of the group consisting of the database data warehouse consumption analysis server deployment server and the placement server reside on single physical machine. In another alternate embodiment there is no web server and the infrastructure management client communicates directly to the database the consumption analysis server the placement server.

More detail of the apparatus involved in an infrastructure reconfiguration process is shown in the block diagram of . In a source cloud configuration characterized by a set of source parameters a base set of workloads are serviced by a collection of source applications executing as programmed instructions on a source set of virtual machines and a source set of physical servers . The source set of virtual machines are deployed amongst a set of S source hosts source host to source host S. The set of S source hosts draw on their internal resources but can also draw from a source resource pool as required by the set of source applications. Each source virtual machine includes a guest operating system guest OS .

The source cloud configuration is typically an existing cloud configuration for a cloud computing environment which is reconfigured and implemented as the destination cloud configuration . The destination cloud configuration is provided by the novel infrastructure management system of the present disclosure according to a set of placement constraints a set of right sizing constraints and according to differences between base set of workloads and final set of workloads . In many applications of the infrastructure management system the final set of workloads is the same as the base set of workloads. In a scenario analysis involving workload forecasting the base and final sets of workloads will be different.

Destination cloud configuration is characterized by a set of destination parameters . Final set of workloads are serviced by a collection of destination applications executing as programmed instructions on a destination set of virtual machines and a destination set of physical servers . The destination set of virtual machines are deployed amongst a set of D destination hosts destination host to destination host D. The set of D destination hosts draw on their internal resources but can also draw from a destination resource pool as required by the set of destination applications.

The set of placement constraints include constraints such as a threshold requirement for reconfiguration the threshold requirement being specified against a metric calculated for the destination cloud configuration. The preferred metric relating to an objective function of resource capacity consumption headroom and a preferred method of computing the threshold requirement against the preferred metric will be described in more detail below. Other placement constraints include but are not limited to a number of iterations performed in a method a list of unmovable VMs constraints on computation of guest OS overhead for VMs and constraints on VMM overhead for host servers.

The set of right sizing constraints relate to matching the set of D destination hosts to a set of host server templates approved by the governing IT organization or consistent with industry standards. The host server templates provide hardware configurations that further constrain the resources available to the set of D destination hosts. Other right sizing constraints include but are not limited to a list of VMs that cannot be right sized how often the candidate placements are right sized while iterating through a placement process the addition or removal of host servers the size of clusters a cluster positioning within a data center which could affect network resources and the size of the destination resource pool.

Referring to in use data warehouse interacts with sets of data collection agents and to receive timestamp categorize and store the sets of resource measurements into database . Consumption analysis server includes a first set of programmed instructions that further operates on the sets of resource measurements in database as will be described in more detail below.

Placement server receives a set of constraints including an implementation threshold and reconfiguration threshold from deployment server . The placement server receives the existing placement as a target placement presented to placement server for optimization wherein the target placement is converted by the placement server to a new placement with existing VMs moved from one host server to another host server and new VMs placed in the new placement. The placement server also receives other changes to the cloud computing environment such as changes to the workload and the addition or removal of a host server cluster or data center from the cloud computing environment. In another embodiment the set of constraints are received into the deployment server from any of the group consisting of infrastructure management client web server an application programming interface API and a combination thereof.

A placement is defined as a set of virtual machine and host pair assignments V H . For example a placement is described by a set of pairings v1 h0 v2 h0 . . . vN h0 s1 h0 between each virtual machine in the set of virtual machines v1 v2 . . . vN and physical server s1 on the single host h0 . However a placement more generally comprises all virtual machines existing and newly configured within host cluster and within all host clusters in the group of data centers.

Placement server interacts with consumption analysis server and database to provide a new placement for cloud computing environment . In an embodiment deployment server requests a new placement from placement server including the placement of any new virtual machines and hosts. In response placement server sends the new placement and a new placement score to deployment server . Deployment server compares the new placement score to a reconfiguration threshold condition. If the reconfiguration threshold condition is met deployment server automatically moves VMs from one host server to another in each cluster in each database to convert a source configuration to a destination configuration of the cloud computing environment.

Referring to an example of an existing cluster of hosts in a source configuration is shown. Cluster of hosts includes host a host b and host c having available capacities and respectively as represented by the total area of the host s corresponding block. Host a host b and host c have resource consumptions and respectively attributed to a set of existing unmovable VMs and resource consumptions and attributed to a set of movable VMs. Host a host b and host c have capacity headroom and respectively which is the unused capacity when subtracting the total resource consumption from the available capacity.

In a preferred mode of operation the infrastructure management system performs a continuous optimization of the computing environment. Referring to a continuous optimization method is described. At step a proactivity time is defined representing a predicted amount of time to elapse before the computing environment is expected to reach a pre determined state including a workload. In an embodiment the proactivity time is greater than the predicted amount of time to elapse. Also at step a stop condition is defined for terminating the continuous optimization method. At step a set of placement triggering conditions are defined in which a placement triggering condition is an event related to a state of the computing environment. An exemplary triggering condition is an event where the minimum capacity headroom of a particular resource capacity across all host servers in the computing environment becomes less than a pre defined capacity headroom. Another exemplary triggering condition is an event defined by a response time for a given application becoming greater than a threshold response time. A manual triggering event is also possible for example receiving a communication requiring a new set of virtual machines for an application.

Another example of a triggering condition is when a workload forecast predicts a required upgrade. At step a process that periodically determines a future workload forecast is started where the future workload forecast is computed in accordance with the proactivity time using predictive analysis.

At step a data collection process begins to periodically collect performance measurements from the set of data collection agents in the computing environment. Step generally occurs prior to all other steps in continuous optimization method and initiates an ongoing process. At step a monitoring process begins where a set of triggering events are generated and received. In an embodiment the deployment server acts as a controller in the monitoring process receiving triggering events from the data warehouse consumption analysis server placement server web server and infrastructure management client. A more detailed explanation of step is found in the description of below.

At step the set of triggering events are repeatedly evaluated and compared to the set of placement triggering conditions. If at step the placement triggering condition is met steps and are performed. At step a reconfiguration and placement analysis is performed resulting in a new placement for a target set of VMs including an existing set of VMs and a new set of VMs on a target set of hosts. At step the target set of VMs are physically and logically reassigned within the target set of hosts according to the new placement. The monitoring process continues at step until the stop condition occurs. When the stop condition occurs continuous optimization method ends at step .

A suitable reconfiguration and placement analysis for step is provided in where an embodiment of a reconfiguration and placement process is shown. At step the source configuration is determined for an existing set of hosts. At step the destination configuration for a target set of hosts and the set of new VMs is provided. Initially in step the target set of hosts is the existing set of hosts.

At step a placement process is performed which in an embodiment includes the threshold scoring method a placement process a final right sizing process and an intermediate right sizing process. In step the infrastructure manager will not attempt to move unmovable VMs from their existing hosts however the infrastructure manager will relocate the existing VMs and add the new VMs so as to maximize the minimum headroom over the target set of hosts across all resources. Also at step the threshold scoring method will check to determine if more hosts need to be added to the existing set of hosts. If more host need to be added then the method reports a number of hosts to add. The output of step is new placement including the set of new VMs. A suitable method for step is described below in relation to .

At step if more hosts are needed to accommodate the set of new VMs then the method moves to step . At step a request is communicated to the deployment server to add hosts to the existing set of hosts according to the reported number of hosts to add. In an embodiment the request is communicated to the infrastructure management client. In an alternate embodiment a predetermined number of host servers can be kept offline and managed by the deployment server.

At step the reported number of hosts is physically added to the existing set of hosts to arrive at a new target set of hosts. Control is then returned to step . Step is repeated for the new target set of hosts.

In another embodiment step also checks if hosts need to be removed from the existing set of hosts. If hosts need to be removed then a number of hosts to remove is computed as in the description of and reported to the deployment server and infrastructure management client.

At step if more hosts are not needed to accommodate the set of new VMs then step is performed. In this case there is sufficient host capacity and a sufficient target set of hosts. At step new placement is returned for implementation.

Referring to a capacity consumption model for a CPU resource on a host is shown. Other types of resources e.g. memory network interface will have similar capacity consumption models. The host is assumed to operate a set of VMs and include a VMM for that purpose. The CPU resource has a raw capacity of C RAW. The raw capacity is computed in a set of portable units TPP for processing resources for the host as a physical server with an ideal operating system and ideal processor. Practically the processor efficiency is less than 100 and raw capacity is reduced by a processor efficiency characterized by a percentage Peff. Processor inefficiency occurs due to native operating system overhead and due to additional non ideal scaling of processor efficiency as a function of processor load due to chip core and thread contention for shared resources. The VMM also consumes processor threads as a function of the number of VMs and virtual CPUs VCPUs configured and further reduces the overall CPU capacity by a percentage VMMeff to an ideal capacity of CV. Host effective capacity is the product of the host raw capacity the processor efficiency and the VMM efficiency CH C RAW Peff VMMeff. However it is also common to reduce the host effective capacity by a capacity reserve CR which represents for example a potential capacity reduction set aside to accommodate system hardware failures software failures and unexpected fluctuations in demand. Capacity reserve can vary from resource to resource and from host to host and is user specified by risk level. The available capacity CA is the host effective capacity reduced by the capacity reserve CA CH 1 CR . The available capacity in is the total processor capacity available to meet the processing needs of the set of VMs deployed on the host.

 Portable units are defined as the speed independent service demand per unit time in U.S. Pat. No. 7 769 843 843 the disclosure of which is incorporated by reference. The portable unit for CPU resources is referred to herein as total processing power TPP which is a generalization of the SPECint rate benchmark.

As for processor efficiency and VMM efficiency a suitable OS chip core thread scalability algorithm for computing processor efficiency is the algorithm disclosed in U.S. Pat. No. 7 957 948 948 which is also hereby incorporated by reference.

As for the VMs deployed on the host each VM raw consumption is the raw consumption of CPU resources by a VM excluding guest OS overhead and represented in portable units. The VM raw consumption is the resource consumption that is moved to or from a host during a placement process. VMM efficiency is inherent to the host and is recomputed during placement moves. VM guest OS overhead is unique to each VM and represents the effect of Guest OS scalability on a VM. In practice it is estimated as a function of the virtual processor states for the VM and empirical scalability characteristics of the VM Guest OS. The raw VM consumptions are compensated for VM Guest OS to determine a total CM consumption where the raw VM consumptions for a set of VMs VM through VM deployed on the host and their estimated Guest OS overhead consumptions are all summed together as a total VM consumption QVM of the available capacity on the host. CPU capacity headroom is total VM consumption subtracted from available capacity . For the objective function CPU capacity headroom is normalized by available resource capacity to a scale of 0 zero to 1 one CA QVM CA is a metric for establishing a placement score.

Referring to an embodiment of a continuous analysis method is described. Continuous analysis method operates on a source set of physical servers and a source set of VMs associated with a source set of hosts to reconfigure the placement of the VMs on the hosts. Each source host and each source VM has a set of resources associated to it.

At step measurements from the data collection agents are recorded in raw units and stored. The measurements include ordinary utilization of raw physical resources e.g. CPU memory disk network by each source physical and virtual machine for a single machine virtualization host or cluster or a plurality of machines virtualization hosts or clusters organized in small time periods for the long term past.

At step the method extracts transforms and stores physical machine configurations e.g. vendor machine type and model number processor type and speed and physical resource configuration e.g. number of processor cores memory storage and network IO capacities for each source and existing target physical machine individual or virtualization host for each day of the long term past. A physical machine configuration is stored with a date time stamp only when the physical machine s configuration changes.

At step the method extracts transforms and stores virtual machine configurations e.g. number of virtual CPUs and memory configured for each source virtual machine for each day of the long term past. A virtual machine configuration is stored with a date time stamp only when the virtual machine s configuration changes.

At step a component scalability model library is constructed for a set of physical machine configurations and virtual machine configurations. A mapping is determined for each physical and virtual machine configuration in the source and destination cloud configurations to the corresponding pre computed entry in a component scalability model library which is used to determine how the physical machine s capacity scales with configuration and load. For example the component scalability model library is used to determine host effective capacity and available capacity as host effective capacity reduced by a desired capacity reserve. Desired capacity reserve values are provided by the user as an input.

The component scalability model library provides a pre computed host capacity lookup table that maps a given physical machine configuration and an ordinary utilization directly to a pre calculated resource capacity consumption in portable units. The total VM consumption is used in a VMM scalability model to compute VMM efficiency. If total VM consumption is unknown for a host then average VM populations per host are computed as a starting point to estimate VMM efficiency. For resource consumption the component scalability model library provides a pre computed resource consumption lookup table that maps a given physical machine configuration and a measured resource utilization directly to a pre calculated resource consumption in portable units.

In an alternate embodiment the component scalability model library maps a set of scalability parameters to each machine configuration. In use a scalability function is called that computes effective capacity based on the machine configuration and the prescribed resource utilization by looking up the set of scalability parameters for the machine configuration and applying the scalability parameters in the computation.

A set of host templates suitable for creating target machine configurations is linked to the component scalability model library and specifies details such as the number of processor chips number of cores and number of threads the amount of cache memory per core the amount of onboard RAM the amount of onboard disk storage and so forth.

At step referred to as capacity analysis the method determines in portable units the resource capacity of each source physical machine and source host and the resource consumptions of each VM in the source configuration and the destination configuration in a set of regularized time blocks based on the measured utilizations and on the component scalability library of step . Step also provides a set of planning percentile resource consumptions Q V R for all the VMs V and resources R along with a set of available capacities C H R for all the host servers. Step will be described below in greater detail in reference to .

Steps and are performed on a periodic basis. For example in step the determination of resource consumptions in portable units in a set of regularized time blocks and the determination of planning percentiles. The determination of available capacities and guest OS overhead are preferably done only in response to step but in some embodiments are also done on a periodic basis. Step is done prior to any of the other steps but can also be performed as an update at any time. Steps and the following steps are triggered by event that starts a reconfiguration.

Steps and are performed primarily by a set of programmed instructions executed by the consumption analysis server and step and step are performed primarily by a second set of programmed instructions executing on the web server in conjunction with the data warehouse and in communication with the database. Steps and are performed primarily by a third set of programmed instructions executed by the placement server where the results are presented through the web server. Step generally requires direct interaction between the infrastructure management client and the VMMs on the host servers to remove a subset of virtual machines from a first subset of host servers and install the subset of virtual machines on a second subset of host servers. Furthermore step will install a set of new virtual machines on the host servers.

In an alternate embodiment the first second and third sets of programmed instructions operate on a single specified physical server. In another alternate embodiment the first second and third sets of programmed instructions operate on any one of the consumption analysis server web server and placement server as needed by the computing environment being managed.

Referring to a set of ordinary utilization measurements are collected as in step by data warehouse into database as a set of raw resource data tables VM1 R1 VM2 R1 . . . VMn R1 . . . VM1 Rm VM2 Rm . . . VMn Rm . Where Rm refers to the mth resource and VM n refers to the nth virtual machine so that the raw resource data table VMn Rm includes ordinary resource utilization measurements for the mth resource consumed by the nth virtual machine. Each set of ordinary utilization measurements are collected at set of short sample times e.g. accumulating every 5 or every 15 minutes during each day for a history of days e.g. 90 days .

Generally the data collection agents are not synchronized nor are the sample time intervals for measurements consistent. The ordinary utilization measurements cell values can be an average over the sample time interval a peak over the sample time interval a sum over the sample time interval or any other meaningful measurement provided the meaning of each measurement is also collected by the data warehouse and stored with the set of utilization measurements. An example of an ordinary utilization measurement is an average of 50 for a CPU configuration between 10 00 and 10 15 hours where if the CPU configuration has 32 processors 50 or 16 of the processors were busy between 10 00 and 10 15 hours.

Returning to a target configuration is confirmed at step and any threshold constraints placement constraints VM right sizing host right sizing and cluster sizing constraints are recorded for use during the remainder of method . The target configuration can be accepted as the existing configuration. Otherwise additional hosts and VMs can be added or deleted. If additional hosts and VMs are added then a scalability model is identified for the additional hosts and VMs using the set of host templates and a set of VM templates from the component scalability library. The initial host capacities and VM resource consumptions of the additional hosts and additional target VMs are determined as in step . Cluster sizing constraints can be checked at this step or preferably at step to determine if host s need to be deleted and their existing VMs orphaned for placement onto other hosts.

In an alternate embodiment step is extended to include a scenario analysis where a target configuration is hypothetical. Examples of possible scenario analyses include workload forecasting new cloud based application deployments removing or adding a data center in a data center consolidation analysis and general user specified hyptothetical scenarios that alter an existing cloud configuration. A further example of a user specified hypothetical scenario is to increase the VM resource consumptions over the existing VM resource consumptions by a scaling factor representing for example the change in consumption resulting from installation of a new version of application software. The scaling factor is applied to the existing VM resource consumptions to arrive at set of scaled VM resource consumptions and propose a target placement to accommodate the set of scaled VM resource consumptions.

Examples of threshold constraints are 1 an adjustable risk parameter that sets the planning percentile level and 2 a fractional parameter that determines what fraction of an ideal score to set the threshold.

At step a threshold score is determined. From a placement score is related to a difference headroom between capacity and consumption. The input to step is the target configuration including a target set of hosts with associated host capacities and a target set of VMs with associated VM resource consumptions. The placement score is generally and preferably computed as the minimum normalized headroom in a cloud computing environment across all resources all time intervals all hosts and all clusters. If the optimal placement and an achievable score were known then the threshold score could be computed from the achievable score. However it is not practical to find the optimal placement. Instead an ideal score is calculated from an aggregate headroom as MIN 1 Qtot Ctot where Ctot is the total available capacity of the target set of hosts and Qtot is the total VM resource consumption over the target set of virtual machines for each resource in a set of resources The aggregate value 1 Qtot Ctot is the normalized difference between Ctot and Qtot normalized by dividing the difference between the total available capacity and the total VM resource consumption by the total available capacity. The minimum is taken over the set of hosts and the set of resources and the defined set of time intervals. The threshold score is taken as a pre configured fraction of the ideal score.

The ideal score represents the smooth spreading of all resource consumptions by all VMs across all hosts proportional to the available capacities of those hosts. However when a set of VMs are placed on a set of hosts even when placed as uniformly as possibly a variation naturally results in the headroom of each host due to the chunky nature of the VM sizes and host capacities that is their different consumption requirements on different resources in different capacity environments and the requirement to place all the resource consumptions by a particular VM on the same host. So the ideal placement is typically unachievable but the ideal score is a useful upper bound for computing the threshold score. The threshold scoring method of step is described in more detail below in relation to . There is also a pseudocode listing for an alternate embodiment of threshold scoring step in pseudocode listing of .

At step the placement process is executed to determine a new placement. In an embodiment of the present disclosure the mode of operation of placement process is user selectable by the web server. The input to the placement process is the target configuration including a target set of hosts with associated host capacities and a target set of VMs with associated VM resource consumptions along with any constraints from step the threshold score from step . Step finds a placement that is good enough to meet the threshold score and reports the good enough placement. During the placement process only candidate placements that satisfy all placement constraints are considered. The placement process of step is described in more detail below in relation to and pseudocode listings A B and .

At step a final right sizing process is executed. The good enough placement from step is converted to a right sized placement that matches all data center VMM and industry standard policies VM constraints and host constraints. All clusters hosts VMs and resources are considered in step . For example the good enough placement may have resulted in a VM that is configured with insufficient virtual resources to meet its consumption. In this case the VM is right sized with adequate virtual resources. The right sizing process of step is described in more detail below in relation to .

At step a score is determined for the right sized configuration. If the score is less than the threshold score then step is repeated to find another placement based on the right size configuration. Step adjusts the right sized placement and re scores it to find a better placement. If the score is greater than the threshold score then step is performed to implement the right sized placement in the cloud configuration by reconfiguring the associated hosts clusters and data centers to match the right sized placement.

At step the resource consumption in portable units of a given resource is determined for a given machine configuration V virtual or physical server during a set of sample time intervals. A highly efficient embodiment of step is accomplished by mapping a measured ordinary utilization and the given machine configuration into resource consumption for the given resource by looking up the given machine configuration and the measured ordinary utilization in the pre computed resource consumption lookup table from step . A highly precise embodiment of step is accomplished by performing a functional mapping as described in reference to step .

Since the data collection agents are not synchronized nor are the sample time intervals for ordinary utilization measurements consistent the resource consumptions from step are also not synchronized and are associated with irregular sample times. The resource consumptions are then regularized into a set of regularized time blocks where a regularized time block is prescribed for all resources virtual machines and physical machines synchronized to a single clock and characterized by a pre defined period of time. At step the resource consumptions are first broken up regularized and stored into the database as a set of interval data records.

The interval data records are formed one of several possible methods. In a first when a subset of utilization data values is reported in a set of sample times within one regularized time block the subset of utilization data values is aggregated for example by averaging the subset of utilization data values. In a second method if two or more utilization data values reported at two or more sample times overlap with a single regularized time block then a weighted averaging of the utilization data values is performed. In a third method if there are multiple regularized time blocks for one utilization data value reported in one sample time then the utilization data value is divided amongst the multiple regularized time blocks.

In an embodiment of step the set of interval data records for a long time past time period each resource R and each VM or physical server V are analyzed as a group. For example all regularized time blocks are grouped in each day for the last 30 days. Then a planning percentile of VM resource consumption is computed for the group e.g. 95th percentile and stored as an aggregate resource consumption Q V R .

At step a guest OS overhead consumption GuestOS V R is estimated for each resource R on each virtual machine V. A simplifying assumption is made in that the guest OS overhead is constant across the set of VMs regardless of host placement. In an alternate embodiment the guest OS is computed for each VM in the set of VMs according to host placement.

At step the method determines the resource capacities comprising raw capacity ideal capacity host effective capacity and available capacity in portable units for a resource R and host H. Step is accomplished by mapping the total VM consumption for host H and the given machine configuration into a resource capacity C H R for the given resource by looking up the given machine configuration and the total VM consumption in the pre computed host capacity lookup table from step . In other embodiments a functional mapping is performed as described in step . The determination of resource capacity is done only for source virtual and physical machines whose configurations have changed during the long term past.

At step the resource consumption in portable units of a given resource is determined for a given machine configuration V virtual or physical server during a set of sample time intervals. A highly efficient embodiment of step is accomplished by mapping a measured ordinary utilization and the given machine configuration into resource consumption for the given resource by looking up the given machine configuration and the measured ordinary utilization in the pre computed resource consumption lookup table from step . A highly precise embodiment of step is accomplished by performing a functional mapping as described in reference to step .

Since the data collection agents are not synchronized nor are the sample time intervals for ordinary utilization measurements consistent the resource consumptions from step are also not synchronized and are associated with irregular sample times. The resource consumptions are then regularized into a set of regularized time blocks where a regularized time block is prescribed for all resources virtual machines and physical machines synchronized to a single clock and characterized by a pre defined period of time. At step the resource consumptions are first broken up regularized and stored into the database as a set of interval data records. At step the resource consumptions are first broken up regularized and stored into the database as a set of interval data records.

In an embodiment the interval data records are formed by one of several possible methods. In a first method when a subset of utilization data values is reported in a set of sample times within one regularized time block the subset of utilization data values is aggregated for example by averaging the subset of utilization data values. In a second method if two or more utilization data values reported at two or more sample times overlap with a single regularized time block then a weighted averaging of the utilization data values is performed. In a third method if there are multiple regularized time blocks for one utilization data value reported in one sample time then the utilization data value is divided amongst the multiple regularized time blocks.

In an embodiment at step the set of interval data records are also grouped tagged and stored in the database as a set of interval groups with a set of group identifiers I. For example all thirteen of Friday 5 00 pm 6 00 pm regularized time blocks from every week over the last 90 days are grouped together into an interval group and each of the corresponding interval data records are tagged with a group identifier I. In another example all thirty of 9 00 am 10 00 am regularized time blocks and all thirty of the 10 00 am 11 00 am regularized time blocks over the last 30 days are grouped together into an interval group and each of the corresponding interval data records are tagged with a group identifier.

Step begins a loop which iterates step for each interval group. At step a planning percentile of VM resource consumption for each interval group is computed e.g. 75th percentile and stored as the aggregate group resource consumption Q V R I associated with the group identifier I.

At step a guest OS overhead consumption GuestOS V R I is estimated for each resource R on each virtual machine V in each interval group I. In an embodiment a simplifying assumption is made in that the guest OS overhead remains constant across the set of VMs regardless of host placement GuestOS V R I GuestOS R .

At step the method determines the resource capacities comprising raw capacity ideal capacity host effective capacity and available capacity in portable units for a resource R and host H in an interval group I. Step is accomplished by mapping the total VM consumption for host H and the given machine configuration into a resource capacity C H R I for the given resource and interval group by looking up the given machine configuration and the total VM consumption in the pre computed host capacity lookup table from step . In other embodiments a functional mapping is performed as described in step . In an embodiment the determination of resource capacity is done only for source virtual and physical machines whose configurations have changed during the long term past.

Referring back to the set of ordinary utilization measurements from are converted to set of resource consumptions in portable units as in steps and . The set of resource consumptions are for a virtual machine labeled VM 2 having a configuration identifier 859 and are presented in portable units of TPP total processing power . The configuration identifier 859 matches a configuration identifier for a VM configuration in the component scalability library. Set of resource consumptions have been converted as in step to a set of regularized time blocks which are presented as a set of interval data records in rows . Set of resource consumptions are further organized into sample periods which are presented as columns . A sample period can be ascribed to a variety of time periods. For example sample period could be a day a week a month 6 hour periods historical periods such as every Monday in the last three months and so forth.

Referring to a set of percentiles is shown as computed as in step . For example a cell of column shows a calculated 65th percentile calculated across the sample periods of columns for a regularized time block in a row. Similarly column is a set of calculated 75th percentiles column is a set of calculated 85th percentiles and column is a set of calculated 95th percentiles.

When regularized time blocks are grouped by tagging into a set of interval groups a cell in column is a calculated 65th percentile calculated across tagged cells of columns for the regularized time blocks in the corresponding row. The cells of columns and represent an Nth percentile calculated on an interval group. As an example a first interval group could be defined for regularized interval 2 including sample periods 1 8 15 and 21. As a further example a second interval group could be defined for regularized interval 2 including sample periods 2 3 9 10 16 17 and 22 23 and the percentiles computed and stored in another set of columns which are not shown in .

Referring to table is shown. A set of percentiles for N virtual machines is shown in columns and for the set of virtual machines VM 1 VM 2 . . . VM N wherein the columns contain percentile values for individual virtual machines in set of rows where each row in set of rows represents an interval group.

Referring to an embodiment of the threshold scoring method of step is provided. At step a target configuration is provided defining a target set of hosts and a target set of VMs to be placed on the target set of hosts. At step steps and are iterated over all resources.

At step the sum of available capacities for the resource R for all of the target set of hosts is computed as 

At step the sum of the Nth percentile resource consumptions for the resource R for all of the target set of VMs is computed as 

At step the ideal score for the target configuration is computed as the minimum score in the set of ideal resource scores S MIN S . At step a condition for adding or removing hosts is checked. If in step the ideal score is within a pre defined range S S then a threshold score is computed at step by multiplying the ideal score by a scoring factor SF as S S SF.

If the ideal score Sis less than S then step is performed and one or more host servers are added to the target set of hosts. In an embodiment S 0 zero . At step the number of additional hosts having a host resource capacity of C R is computed according to the formula 

In an embodiment for handling excess capacity a user specifies a minimum capacity Mto be available as spare host capacity and a threshold host capacity to remove Min units of host capacity C R . A number of hosts to remove NHostsRemove is computed at step and compared to M. If NhostsRemove is greater than M then step is performed and NhostRemove host servers are removed from the target set of hosts. The number of hosts to be removed is computed according to the formula 

Referring to an embodiment of the threshold scoring method of step is provided. At step a target configuration is provided defining a target set of hosts and a target set of VMs to be placed on the target set of hosts. At step steps and are iterated over all resources. At step steps and are iterated over all intervals.

At step the sum of available capacities for the resource R in the interval I for all of the target set of hosts is computed as 

At step the sum of the Nth percentile resource consumptions for the resource R in the interval I for all of the target set of VMs is computed as 

At step the ideal resource score for the target configuration is computed as the minimum score in the set of ideal interval scores S MIN S . The threshold scoring method then repeats at step until all ideal resource scores are computed and stored.

At step the overall ideal score for the target configuration is computed as the minimum score in the set of ideal resource scores S MIN S . At step a condition for adding or removing hosts is checked. If at step the ideal score is within a pre defined range S S then a threshold score is computed at step by multiplying the ideal score by a scoring factor SF as S S SF.

If the ideal score Sis less than S then step is performed and one or more host servers are added to the target set of hosts. In an embodiment S 0 zero . At step the number of additional hosts having a host resource capacity of C R is computed according to the formula 

In an embodiment for handling excess capacity a user specifies a minimum capacity Mto be available as spare host capacity and a threshold host capacity to remove Min units of host capacity C R . A number of hosts to remove NHostsRemove is computed at step and compared to M. If NhostsRemove is greater than M then step is performed and NhostRemove host servers are removed from the target set of hosts. The number of hosts to be removed is computed according to the formula 

In an alternate embodiment If NHostsRemove is greater than or equal to M then step is preformed. If a set of hosts need to be removed a dialogue is presented by the web server indicating that a host server needs to be removed the dialogue further providing a tool to select a host server to remove from the target set of hosts.

Referring to an embodiment of the final right sizing process in step is shown. At step a set of right sizing policies are received. The set of right sizing policies preferably include an allowed set of host configurations and allowed set of VM configurations and are specified in the set of host templates and the set of VM templates in the component scalability library. Each virtual machine VM has a resource configuration describing the required VCPUs virtual RAM and so forth. Virtual machine monitors and virtual machine tools from various vendors as well as industry standards dictate a defined set of resource configurations.

At step the step is repeated for all eligible virtual machines where eligible is a user selectable parameter in an embodiment. The eligible parameter is specified by the user and can include several potential conditions. In a first case the parameter is set to none. In this case right sizing is never performed. In a second case the parameter is set so that only VMs that were moved during the placement process are eligible for right sizing. In a third case all VMs are eligible for right sizing.

At step a VM configuration returned from the placement process is reconfigured with a nearest allowable VM configuration that is also a right sized VM configuration. The nearest allowable VM configuration can be selected by selecting from a fixed set of VM size constraints by applying a set of VM sizing rules to the existing VM configuration or by a combination of selecting from the fixed set of VM size constraints and applying the set of VM sizing rules.

In a first example of determining nearest allowable VM configuration a size constraint is applied to a first VM where the size constraint is selected from the fixed set of VM size constraints based on the VM size needed for the regularized time block of the first VM s greatest consumption.

In a second example of determining nearest allowable VM configuration a size constraint is applied to a second VM where the size constraint is selected from the fixed set of VM size constraints based on the second VM s Nth percentile VM resource consumption. In the second example the second Nth percentile VM resource consumption used for right sizing can be the same or different than the Nth percentile VM resource consumption used in the scoring process where N ranges from 50 to 100.

In an embodiment of step the second example is implemented where the Nth percentile VM resource consumption used for right sizing is larger than the Nth percentile VM resource consumption used in scoring e.g. scoring uses 75percentiles right sizing uses 85percentiles and the second Nth percentile VM resource consumption is computed across all regularized time blocks over a long time period.

In a third example of determining nearest allowable VM configuration a size constraint is applied to a third VM where the size constraint is calculated by multiplying the third VM existing resource consumption by a pre defined inflation factor to arrive at a computed VM resource consumption and then taking the mathematical ceiling of the computed VM resource consumption to specify a minimum resource consumption for the third VM. For example given an existing VM consumption of processing power is 2.9 VCPU and the pre defined inflation factor is selected as 1.25 the processing power is multiplied by a pre defined inflation factor and taking the ceiling results in a specification of 4.0 VCPU for a nearest allowable VM configuration.

In a fourth example of determining nearest allowable VM configuration a size constraint is applied to a fourth VM where the size constraint is calculated by multiplying a fixed VM constraint from the fixed set of VM constraints by a pre defined inflation factor to arrive at a computed VM resource consumption and then taking the mathematical ceiling value of the computed VM resource consumption to specify the resource configuration. In a more detailed example of the third example suppose an existing VM consumption of processing power is 2.9 VCPU and the pre defined inflation factor is selected as 1.25. Multiplying the processing power by the pre defined inflation factor and taking the ceiling results in a specification of 4.0 VCPU for a nearest allowable VM configuration.

After all eligible VMs have been replaced the reconfigured placement may not be right sized at the host level. At step the hosts are checked in the reconfigured placement against right sizing constraints such as the allowed set of host configurations. For example a host level right sizing constraint is the number of VCPUs allowed in a host configuration. If after step the number of VCPUs exceeds the host level right sizing constraint then at least one VM should be moved.

At step any necessary adjustments are made to the host configurations including VM placement. Steps and are then repeated for a pre determined number of iterations in order to avoid excessive looping. In an embodiment steps and are performed only once.

The result of steps and is a right sized placement. At step a placement score Sis computed for the right sized placement according to the scoring process of . At step a check is performed to add or remove hosts from the target configuration as shown in .

Referring to at step a condition for adding or removing hosts is checked. If the ideal score is within the pre defined range S S then the process moves to step . At step no changes are made to the target set of hosts. If the placement score Sis less than S then step is performed. At step one or more host servers are added to the target set of hosts. In an embodiment S 0 zero . At step the number of additional hosts having a host resource capacity of C R is computed according to the formula 

In an embodiment for handling excess capacity a user specifies a minimum capacity Mto t be available as spare host capacity and a threshold host capacity to remove Min units of host capacity C R . A number of hosts to remove NHostsRemove is computed at step and compared to M. If NhostsRemove is greater than M then step is performed and NhostRemove host servers are removed from the target set of hosts. The number of hosts to be removed is computed according to the formula 

Referring to the first mode of operation of placement process is described. The refinement method works to find an overall best placement within a pre defined number of refinement iterations stop limit . An iteration count is incremented whenever step is performed.

Beginning at step an initial placement V H is determined based on an input target configuration. The resulting initial placement is stored as the best placement .

There are generally five classes of virtual machines which are dealt with during placement new VMs that were not part of the source configuration which can be moved from host to host during placement movable new VMs generated from physical servers which are movable existing movable VMs existing soft VMs which are preferably not movable and existing hard VMs which unmovable and fixed to their source host by constraint. All five classes of VMs are placed at initial placement.

At step an initial score is determined for the initial placement and stored as the best score . The iteration count is also set to zero in step . All other steps of placement process describe the refinement method of the placement process which takes the initial placement and modifies it one iteration at a time. The refinement method of the placement process implements a steepest descent method which is a well behaved method for finding the minimum of a function. The function in the placement process is the objective function implemented by a scoring process.

In alternate embodiments other methods can be implemented to find the minimum of the objective function for example a stochastic search method implements a random placement of target VMs onto target hosts to search for a lowest placement score.

The refinement method begins at step where the best placement is modified to arrive at a candidate placement after which the iteration count is incremented. The preferred modification in step is a single VM move from the worst host to the best host where the worst host has the lowest score and the best host has the highest score in the set of hosts and where the moves are performed in order of new existing movable and soft VMs as required to improve the score. Other embodiments of step are possible. For example the single VM move could be chosen at random from the set of hosts. In another example the VMs can be sorted by resource consumption on a particular resource into a sorted list and selected from the sorted list in order. In another embodiment multiple VM moves are allowed.

Multiple VM moves can be desirable in some cases. In a first case a pair of VMs are known to be complementary that is one of the VM has a low score during the time intervals where the other VM has a high score. The two VMs may be paired and placed on a host together in a single refinement step. In a second case where a pair of VMs is known to be competitive that is both VMs have a high score or both VMs have a low score and exist on the same host the two VMs may be paired and placed on different hosts in a single refinement step. In a third case complementary and competitive VM sets are examined in the modification in step while placing VMs. In a fourth case analysis of complementary or competitive VMs is performed periodically by the consumption analysis server as a part of the capacity analysis. In many other cases two or more VMs with no correlative relationship simply fit better in different locations due to sizing and other constraints.

At step the candidate placement is scored according to an objective function and the new score is stored. A preferred method of scoring for both of steps and are presented in more detail below in .

At step the refinement method compares the new score to the best score . If the new score is greater than the best score the refinement method continues at step

If the new score is less than or equal to the best score step is performed to check if the number of refinement iterations has reached the stop limit. When the stop limit has been reached the placement process ends at step where the best placement found is returned by the placement process which becomes the new placement even if the best placement is the initial placement.

If the stop limit has not been reached at step then the placement process continues at step by modifying the current best placement .

At step when the new score is greater than the best score the candidate placement is stored as the best placement and the new score is stored as the best score for subsequent iterations of the refinement method.

At step a comparison is made between the number of refinement iterations and the stop limit. If the stop limit has been reached then step is performed wherein the best placement found is returned by the placement process. If not the method returns to step

Steps and step can be implemented using a different mechanism to stop the iterations of step . In an alternate embodiment a number of iterations performed without improvement in the best score is compared to a stop limit. In another alternate embodiment an elapsed execution time is compared to a maximum execution time.

Referring to second mode of operation of placement process is described. In the second mode of operation the refinement method works to find an overall best placement that is right sized within the pre defined number of refinement iterations stop limit .

Beginning at step an initial placement V H is determined based on an input target configuration. The resulting initial placement is stored as the best placement . At step an initial score is determined for the initial placement and stored as the best score . The iteration count is also set to zero in step . All other steps of placement process describe the refinement method of the placement process which takes the initial placement and modifies it one iteration at a time. The refinement method of the placement process implements a steepest descent method which is a well behaved method for finding the minimum of a function. The function in the placement process is the objective function implemented by a scoring process.

The refinement method begins at step where the best placement is modified to arrive at a candidate placement after which the iteration count is incremented. The preferred modification in step is a single VM move from the worst host to the best host where the worst host has the lowest score and the best host has the highest score in the set of hosts where the worst host has the lowest score and the best host has the highest score in the set of hosts and where the moves are performed in order of new existing movable and soft VMs as required to improve the score. Other embodiments of step are possible. For example the single VM move could be chosen at random from the set of hosts. In another example the VMs can be sorted by resource consumption on a particular resource into a sorted list and selected from the sorted list in order. In another embodiment multiple VM moves are allowed.

At step the candidate placement is scored according to an objective function and the new score is stored. A preferred method of scoring for both of steps and are presented in more detail below in .

At step the refinement method compares the new score to the best score . If the new score is greater than the best score the refinement method continues at step

If at step the new score is not greater than the best score then step is performed to check if the number of refinement iterations has reached the stop limit. When the stop limit has been reached the placement process ends at step . Step where the best placement found is returned by the placement process even if the best placement is the initial placement. The best placement becomes the new placement.

If the stop limit has not been reached at step then the placement process continues at step by further modifying the current best placement .

Continuing with step when the new score is greater than the best score the candidate placement is stored as the best placement and the new score is stored as the best score for subsequent iterations of the refinement method. Then a right sizing condition is checked at step . If at step the right sizing condition is met then a right sizing process is performed at steps and otherwise step is performed to check the number of iterations against the stop limit.

At step a right sizing process is performed on the best placement for the set of VMs moved in step during the last iteration. The result of step is a right sized placement according to a right sizing condition. The right sizing condition includes a set of conditions that determine if a VM is allowed to be right sized. In another embodiment all source physical servers which are converted to a VM are right sized. In yet another embodiment a user specified right sizing condition is selectable by a user. In another embodiment of a right sizing condition a number of iterations of the refinement method to skip before performing step is prescribed. In still another embodiment the right sizing condition is met when the number of iterations has reached the stop limit. In another embodiment the resource consumption of a VM as it is placed determines if a right sizing condition is met.

At step the right sized placement is scored yielding a right sized score. An embodiment of an intermediate right sizing process for step is described in more detail below in relation to . An embodiment of a scoring process for step utilizes the same algorithm as in steps and

After step the stop limit is checked at step and the refinement method continues or stops based on the outcome of step and the status of the refinement method.

Step can be implemented using a different mechanism to stop the iterations of step . In an alternate embodiment a number of iterations performed without improvement in the best score is compared to a stop limit. In another alternate embodiment an elapsed execution time is compared to a maximum execution time.

Referring to a third mode of operation for the placement process is described where the refinement method works to find the first placement that when right sized is good enough to surpass a threshold score. Beginning at step an initial placement V H is determined based on an input target configuration. The resulting initial placement is stored as the best placement . At step an initial score is determined for the initial placement and stored as the best score . The iteration count is also set to zero in step . All other steps of placement process describe the refinement method of the placement process which takes the initial placement and modifies it one iteration at a time. The refinement method of the placement process implements a steepest descent method which is a well behaved method for finding the minimum of a function. The function in the placement process is the objective function implemented by a scoring process.

The refinement method begins at step where the best placement is modified to arrive at a candidate placement after which the iteration count is incremented. The preferred modification in step is a single VM move from the worst host to the best host where the worst host has the lowest score and the best host has the highest score in the set of hosts and where the moves are performed in order of new existing movable and soft VMs as required to find a score that is good enough to meet the threshold. Other embodiments of step are possible. For example the single VM move could be chosen at random from the set of hosts. In another example the VMs can be sorted by resource consumption on a particular resource into a sorted list and selected from the sorted list in order. In another embodiment multiple VM moves are allowed.

At step the candidate placement is scored according to an objective function and the new score is stored. A preferred method of scoring for both of steps and are presented in more detail below in .

At step the refinement method compares the new score to the best score . If the new score is greater than the best score the refinement method continues at step

If at step the new score is not greater than the best score then step is performed to check if the number of refinement iterations has reached the stop limit. When the stop limit has been reached the placement process ends at step . If the stop limit has not been reached at step then the placement process continues at step by further modifying the best placement .

If at step the new score is greater than the best score then at step the candidate placement is stored as the best placement and the new score is stored as the best score . The right sizing condition is checked at step . If at step the right sizing condition is met then a right sizing process is performed at steps and otherwise step is performed to check the number of iterations against the stop limit.

At step a right sizing process is performed on the best placement for the set of VMs moved in step during the last iteration. The result of step is a right sized placement according to a right sizing condition. The right sized placement is then stored as the best placement . The right sizing condition includes a set of conditions that determine if a VM is allowed to be right sized. In another embodiment all source physical servers which are converted to a VM are right sized. In yet another embodiment a user specified right sizing condition is selectable by a user. In another embodiment of a right sizing condition a number of iterations of the refinement method to skip before performing step is prescribed. In still another embodiment the right sizing condition is met when the number of iterations has reached the stop limit. In another embodiment the resource consumption of a VM as it is placed determines if a right sizing condition is met.

At step a score is determined for the right sized placement and stored as the best score . At step the best score is compared to the threshold score. If the best score is greater than or equal to the threshold score the best placement is considered to be a good enough placement suitable for implementation. In this case the placement process ends at step by returning the best placement which becomes the new placement.

At step if the right sized score is less than the threshold score then the stop limit on refinement iterations is checked at step and the refinement method continues or stops based on the outcome of step and the status of the refinement method. Step can be implemented using a different mechanism to stop the iterations of step . In an alternate embodiment a number of iterations performed without improvement in the best score is compared to a stop limit. In another alternate embodiment an elapsed execution time is compared to a maximum execution time.

An embodiment of placement process implements a fourth mode of operation as described in . In the fourth mode of operation the refinement method works to find the first placement that when right sized is good enough to surpass a threshold score. Beginning at step an initial placement V H is determined based on an input target configuration. The resulting initial placement is stored as the best placement . At step an initial score is determined for the initial placement and stored as the best score . The iteration count is also set to zero in step . All other steps of placement process describe the refinement method of the placement process which takes the initial placement and modifies it one iteration at a time.

The refinement method begins at step where the best placement is modified to arrive at a candidate placement after which the iteration count is incremented. At step a single VM is moved from the worst host to another host. In an embodiment the single VM is moved from the worst host to the best host where the worst host has the lowest score and the best host has the highest score in the set of hosts and where the moves are performed in order of new existing movable and soft VMs as required to find a score that is good enough to meet the threshold.

At step the candidate placement is scored according to an objective function and the new score is stored. A preferred method of scoring for both of steps and are presented in more detail below in .

At step the refinement method compares the new score to the best score . If the new score is greater than the best score the refinement method continues at step

If at step the new score is not greater than the best score then step is performed. At step if all of the movable VMs assigned to worst host have been moved without yielding a placement score better then the best score then the worst host and the unmovable subset of VMs still assigned to the worst host are removed from further consideration in the method and stored in a set of removed VM host pairs. The worst host is not scored and no VMs in the unmovable subset of VMs are moved thereafter.

The method then continues at step where the number of refinement iterations is compared to the stop limit. When the stop limit has been reached the placement process ends at step . If the stop limit has not been reached at step then the placement process continues at step by further modifying the best placement .

If at step the new score is greater than the best score then at step the candidate placement is stored as the best placement and the new score is stored as the best score . The right sizing condition is checked at step . If at step the right sizing condition is met then a right sizing process is performed at steps and otherwise step is performed to check the number of iterations against the stop limit.

At step a right sizing process is performed on the best placement for the set of VMs moved in step during the last iteration. The result of step is a right sized placement according to a right sizing condition. The right sizing condition includes a set of conditions that determine if a VM is allowed to be right sized. In another embodiment all source physical servers which are converted to a VM are right sized. In yet another embodiment a user specified right sizing condition is selectable by a user. In still another embodiment of a right sizing condition a number of iterations of the refinement method to skip before performing step is prescribed. In another embodiment the right sizing condition is met when the number of iterations has reached the stop limit. In another embodiment the resource consumption of a VM as it is placed determines if a right sizing condition is met.

At step a score is determined for the right sized placement and stored as the best score . At step the best score is compared to the threshold score. If the best score is greater than or equal to the threshold score the best placement is considered to be a good enough placement suitable for implementation. At step the set of removed VM host pairs is appended to the best placement to arrive at the new placement and if the set of removed VM host pairs is not empty that is if any VM host pairs were removed in step then score the placement as the score of the first host removed in the process. The placement process ends at step by returning new placement.

At step if the right sized score is less than the threshold score then the stop limit on refinement iterations is checked at step and the refinement method continues or stops based on the outcome of step and the status of the refinement method.

Step can be implemented using a different mechanism to stop the iterations of step . In an alternate embodiment a number of iterations performed without improvement in the best score is compared to a stop limit. In another alternate embodiment an elapsed execution time is compared to a maximum execution time.

Another alternative embodiment of the refinement method uses a different method for generating candidate placements during refinement at steps and . A critical resource is defined as the resource having the greatest ratio of total VM resource consumption summed over all VMs to total available capacity summed over all hosts. For the modification step a move is attempted with a VM having the least consumption of the critical resource on the worst host moving the VM from the worst host to the host with the greatest available capacity of the critical resource. Additionally in the fourth mode of operation at step if the critical resource has failed to improve the score the worst host can be discarded without trying to move all of the other VMs on the worst host.

Referring to an embodiment of the scoring process used during placement and during right sizing is described.

Referring to the scoring process requires as input a target placement V H . Steps and specify that the following steps are repeated for each host H and each resource R in each host H respectively. At step the total VM resource consumption is computed for resource R on host H based on Nth percentile VM resource consumptions.

Referring to step is described. At step step is performed for each virtual machine and physical server V assigned to host H and for resource R assigned to V. Step computes the planning percentile consumption according to 

Returning to at step the method adjusts the available capacity C H R for resource Ron host H by recomputing the processor efficiency through a processor scalability analysis and recomputing the VMM efficiency through a VMM scalability analysis on the VMs placed on host H. It is assumed that the processor efficiency and the VMM efficiency are constant and no adjustment is performed unless the placement process is being run for a final right sized placement.

At step the headroom for resource R on host H is computed as the difference between the available capacity on the host and the total VM consumption normalized and stored as a resource score in a set of resource scores. The resource score is computed as Score 

At step the host score for host H is determined as the minimum score in the set of resource scores Score H MIN Score H R . The host score is stored in a set of host scores. At step the scoring process repeats for all other hosts in the target placement.

At step the aggregate score is determined as the minimum score in the set of host scores. If there are multiple clusters then the aggregate score represents a cluster score in a set of cluster scores and an overall score is determined as the minimum score in the set of cluster scores.

At step the placement score Score V H is set equal to the aggregate score if the target configuration has a single cluster or single set of hosts. Score V H is equal to the overall score if the target configuration has multiple clusters.

The result of steps and is a right sized placement. At step a placement score is computed for the right sized placement according to the scoring process of .

Referring to the scoring process requires as input a target placement V H . Steps and specify that the following steps are repeated for each host H each resource R in each host H and for each interval I in a block of intervals respectively where the block of intervals comprise a set of regularized time blocks or grouped intervals. At step the total VM resource consumption is computed for resource R on host H during interval I. In an embodiment interval I represents an interval group comprising a set of interval data collected from a tagged group of sample periods during a regularized time block.

An Nth percentile VM resource consumption for a given regularized time block is the Nth percentile computed from VM resource consumption reported for all sample periods available for the resource during the given regularized time block. An Nth percentile VM resource consumption for a given interval group is the Nth percentile computed from VM resource consumption reported for the tagged group of sample periods associated to the given interval group.

Referring to step is described. At step step is performed for each virtual machine and physical server V assigned to host H and for resource R assigned to V in interval I. Step computes the total VM resource consumption as a sum of VM planning percentile consumptions according to 

Returning to at step the method adjusts the available capacity C H R I for resource R on host H by recomputing the processor efficiency through a processor scalability analysis and recomputing the VMM efficiency through a VMM scalability analysis on the VMs placed on host H. It is assumed that the processor efficiency and the VMM efficiency are constant across intervals and no interval level adjustment is performed unless the placement process is being run for a final right sized placement.

At step the headroom for resource R on host H is computed as the difference between the available capacity on the host and the total VM consumption normalized and stored as an interval score in a set of interval scores. The interval score is computed as Score 

At step the resource score for resource R in host H is determined as the minimum score in the set of interval scores Score H R MIN Score H R I . The resource score is stored in a set of resource scores. The method repeats after step at step for all other resources in host H. The resource score is stored in a set of resource scores.

At step the host score for host H is determined as the minimum score in the set of resource scores Score H MIN Score H R . The host score is stored in a set of host scores. At step the scoring process repeats for all other hosts in the target placement.

At step the aggregate score is determined as the minimum score in the set of host scores. If there are multiple clusters then the aggregate score represents a cluster score in a set of cluster scores and an overall score is determined as the minimum score in the set of cluster scores.

At step the placement score Score V H is set equal to the aggregrate score if the target configuration has a single cluster or single set of hosts. Score V H is equal to the overall score if the target configuration has multiple clusters.

Other embodiments of the scoring process are possible. For example in alternate embodiment of the scoring process an alternative placement score is computed for a resource by calculating the joint probability that the resource s consumptions for all VMs placed on a host will obtain a threshold score. The alternative placement score can computed in a first alternate embodiment on a set of regularized time blocks or in a second alternate embodiment a single regularized time block across a group of sample periods.

In set of alternate embodiments other metrics are used to define an objective function for the scoring process. All of the various host level resources CPU memory network interfaces disk storage are available as metrics for which the capacity headroom metric and threshold score have been described. In a first alternate embodiment of the scoring process scoring is restricted to the metric computed for host level resources to only those VMs that are movable. In a second alternate embodiment for the scoring process the fraction of existing VMs moved is used as a metric with a threshold score at or near 1.0. In a third alternate embodiment of the scoring process the number of VMs per host is a metric and the threshold score is a function of the host class specifications associated to the host. In a fourth alternate embodiment of the scoring process the number of VCPUs per host is a metric and the threshold score is a function of VMM capacity and host class specifications. In a fifth alternate embodiment of the scoring process infrastructure cost is a metric with a pre determined fractional improvement as the threshold. In a sixth alternate embodiment of the scoring process placements are scored across multiple widely varying metrics by defining an appropriate normalization for each metric value scoring across all metric values to find a set of resulting placement scores and using the resulting placement scores to find the placement with the maximum of a minimum headroom value across all the metrics.

Referring to an embodiment of an intermediate right sizing process suitable for steps and is shown. At step a set of right sizing policies are received. The set of right sizing policies preferably include an allowed set of host configurations and allowed set of VM configurations and are specified in a set of host templates and a set of VM templates. Each virtual machine VM has a resource configuration describing the required VCPUs virtual RAM and so forth. Virtual machine monitors and virtual machine tools from various vendors as well as industry standards dictate a defined set of resource configurations.

At step the step is repeated for all eligible virtual machines where eligible is a user selectable parameter in the embodiment. The eligible parameter is specified by the user and can include several potential conditions. In a first case the parameter is set to none. In this case right sizing is never performed. In a second case the parameter is set so that only VMs that were moved during the placement process are eligible for right sizing. In a third case all VMs are eligible for right sizing.

At step a VM configuration returned from the placement process is reconfigured with a nearest allowable VM configuration that is also a right sized VM configuration. The nearest allowable VM configuration can be selected from a fixed set of VM size constraints by applying a set of VM sizing rules to the existing VM configuration or by a combination of selecting from the fixed set of VM size constraints and applying the set of VM sizing rules.

In a first example of determining nearest allowable VM configuration a size constraint is applied to a first VM where the size constraint is selected from the fixed set of VM size constraints based on the VM size needed for the interval group of the first VM s greatest consumption in the interval analysis.

In a second example of determining next largest allowable VM configuration a size constraint is applied to a second VM where the size constraint is selected from the fixed set of VM size constraints based on the second VM s Nth percentile VM resource consumption. In the second example the second Nth percentile VM resource consumption used for right sizing can be the same or different than the Nth percentile VM resource consumption used in the scoring process where N ranges from 50 to 100.

In an embodiment of step the second example is implemented where the Nth percentile VM resource consumption used for right sizing is larger than the Nth percentile VM resource consumption used in scoring e.g. scoring uses 75percentiles right sizing uses 85percentiles and the second Nth percentile VM resource consumption is computed across all regularized time blocks over a long time period.

In a third example a size constraint is applied to a third VM where the size constraint is calculated by multiplying the third VM existing resource consumption by a pre defined inflation factor to arrive at a computed VM resource consumption and then taking the mathematical ceiling of the computed VM resource consumption to specify a minimum resource consumption for the third VM. In a more detailed example of the third example suppose an existing VM consumption of processing power is 2.9 VCPU and the pre defined inflation factor is selected as 1.25. Multiplying the processing power by the pre defined inflation factor and taking the ceiling results in a specification of 4.0 VCPU for a nearest allowable VM configuration.

In a fourth example a size constraint is applied to a fourth VM where the size constraint is calculated by multiplying a fixed VM constraint from the fixed set of VM constraints by a pre defined inflation factor to arrive at a computed VM resource consumption and then taking the mathematical ceiling value of the computed VM resource consumption to specify the resource configuration.

The pre processing method placement process and scoring process are amenable to parallel processing. For example in an alternate embodiment of the pre processing method each loop of step and step of can be performed in parallel by a set of processors. In another alternate embodiment of the scoring process each loop of step and step of can be performed in parallel by a set of processors during placement.

In another example of parallel processing applied to the placement process the refinement method in the placement process can be split into multiple refinements executing on parallel processors where each refinement modifies the best placement by randomly selecting a VM for relocation and where the random selection is seeded differently for each refinement. Once all of the refinements terminate the resulting best placements can be compared and the near optimal best placement selected. In this example the steps described for the first mode of operation are operated in parallel with the addition of a final comparison step to select the near optimal best placement .

Referring to a pseudocode listing is provided for an example embodiment of a general placement method . At line a threshold placement score is determined. At line an initial placement is constructed from a set of user specified source machines onto a user specified set of target hosts and the current placement is set equal to the initial placement. At line a current placement score is determined for the current placement. Lines form a loop and at line a while condition is checked. At line if the current placement score is greater than the threshold placement score then the while condition is met. If the number of candidate placements considered in the loop is not larger than a pre defined placement count then the while condition is met. If the execution time of the loop is not larger than a pre defined execution time then the while condition is met. At line a candidate placement is generated and scored with a placement score. At line if the candidate placement is better than the current score then at line the candidate placement is accepted as the current placement with current score equal to the placement score.

Referring to a pseudocode listing is provided for an example embodiment of an initial placement method which is used in line of general placement method . Lines form a while loop. At line an initial placement is started with a set of unmovable virtual machine host pairs. In an alternate embodiment the initial placement is started with no virtual machine host pairs. At line the while loop continues if not all virtual machines in the target set of virtual machines have been placed into the initial placement where the target set of virtual machines includes new VMs new VMs from the source set of physical servers existing movable VMs soft VMs movable but preferably stationary and hard VMs unmovable . At line a virtual machine V is selected for placement by random selection from the subset of target virtual machines that have not yet been placed. Lines form a begin end loop. At line a target host H is selected at random from the set of target hosts and a set of scores is emptied. At line virtual machine V is assigned to target host H and appended to the initial placement to form a resulting placement for which a resulting placement score is determined and stored in the set of scores. At line if the resulting placement score is greater than the threshold score then at line resulting placement is accepted as the initial placement and the loop continues at line . At line if the resulting placement score is not greater than the threshold score and if a pre defined number of loops have executed for the begin end loop then at line the resulting placement corresponding to the best score in the set of scores is accepted as the initial placement and the loop continues at line . At line the begin end loop is repeated for all hosts in the target set of hosts. At line the while loop is repeated. At line the result of the initial placement method is an initial placement of all VMs from the target set of virtual machines onto the target set of hosts including any unmovable VMs.

Referring to a pseudocode listing is provided for an example embodiment of an alternate initial placement method which is used in line of general placement method . At line an initial placement is started with no virtual machine host pairs. At line the set of target virtual machines are sorted on the most critical resource into a VLIST from the largest resource consumer to the smallest resource consumer. At line the target set of hosts are sorted into an HLIST on the most critical resource from largest headroom to smallest headroom. The VLIST includes all of the new VMs new VMs from the source set of physical servers existing movable VMs soft VMs movable but preferably stationary and hard VMs unmovable .

Lines form a while loop. At step the while loop continues if not all virtual machines in the target set of virtual machines have been placed into the initial placement. At line the next virtual machine V is selected from the VLIST beginning with the largest resource consumer. Lines form a begin end loop. At line the next target host H is selected from the HLIST beginning with the target host having the largest headroom and a set of scores is emptied. At line the next virtual machine V is assigned to the next target host H and appended to the initial placement to form a resulting placement for which a resulting placement score is determined and stored in the set of scores. At line if the resulting placement score is greater than the threshold score then at line the resulting placement is accepted as the initial placement and the loop continues at line . At line if the resulting placement score is not greater than the threshold score and if a pre defined number of loops have executed for the begin end loop then at line the resulting placement corresponding to the best score in the set of scores is accepted as the initial placement and the loop continues at line . At line line is repeated for all hosts in the target set of hosts. At line the available capacity of the next target host H is reduced by the VM resource consumption of the next virtual machine V and the set of target hosts are re sorted as in line . At line the while loop is repeated at line . At line the while loop is terminated. The result of the initial placement method is an initial placement of all VMs from the target set of virtual machines onto the target set of hosts including any unmovable VMs.

Referring to a pseudocode listing is provided for an example embodiment of a threshold scoring method . Threshold scoring method is used in line of general placement method and includes lines . At line a set of target hosts and a set of target VMs are provided. Lines are executed for each resource r in a set of host resources. At line the total resource consumption of all VM in the set of target VMs Qtot r is computed as a sum over all VMS of the Nth percentile consumptions of resource r by each VM plus an estimated GuestOS overhead for each VM on resource r.

At line if the resource r is CPU then estimate the average number of virtual CPUs and the average number of processor threads consumed per host. At line the available capacity is computed for all hosts in the set of target hosts.

Lines are executed for each host h in the target set of hosts and lines are executed for each resource r in the set of host resources. At line the raw capacity is computed for resource r on host h. At line if the resource r is CPU then execute lines . At line the processor efficiency is computed for host h using a scalability model for host h. At line a VMM efficiency is computed for host h using a VMM scalability analysis and the average number of virtual CPUs per host. At line a CPU effective capacity for host h CH r CPU is computed by multiplying the raw capacity by the processor efficiency and the VMM efficiency.

Lines are executed if the resource r is not CPU. At line a host effective capacity CH r for resource r is set equal to the raw capacity for resource r.

At line the host available capacity is computed as CA h r CH r 1 CR r where CR is a pre determined capacity reserve for the resource r.

Referring to Lines compute the ideal resource scores. Lines are repeated for each resource r in the set of host resources. At line the total available capacity Ctot r of the set of target hosts is calculated as the sum of CA h r over all hosts h. At line the ideal resource score for resource r is computed as S r 1 Qtot r Ctot r . At line the overall ideal score is computed as the minimum of all ideal resource scores for the set of host resources. At line the threshold score is determined as a pre defined fraction F of the overall ideal score.

Referring to a pseudocode listing is provided for an example embodiment of refinement method suitable for use in the placement process. According to line refinement method is substituted for lines in general placement method . Refinement method includes lines and features a repetition of a single move refinement at lines . Refinement method has an initial placement as input which becomes a refined placement as the refinement method proceeds a set of target hosts and a set of target VMs placed according to the initial placement on the set of target hosts. According to line the set of target hosts are sorted by increasing score order into a list HLIST. The single move refinement starts at line with a single VM selected from the worst host host with the lowest score in HLIST. A single move refinement begins at line and ends at line wherein the single VM is reassigned to a different host in HLIST in an attempt to improve an overall score for the refined placement.

At line a tentative assignment of the single VM is made to the best host host with the highest score the overall score for the tentative reassignment computed the worst and best target hosts are scored again and an overall score is recomputed. At line if the tentative reassignment improves the overall score line is executed where the tentative reassignment is accepted as the refined placement the set of target hosts are resorted into HLIST again and the refinement method starts again at line .

At step if reassignment of a virtual machine V to the best host in HIST does not improve the overall score then lines are executed. At line virtual machine V is tentatively assigned to the remaining hosts in HLISTS in increasing score order and scored until an improvement in the overall score occurs or all candidate hosts have been considered. At line if no reassignment of V to any host in HLIST improves the overall score then step is repeated for different VM and the refinement method starts again with the refined placement as generated so far by the refinement method. At line if reassignment of all movable VMs on the worst hosts have been attempted without an improvement in the overall score the worst host is removed from HLIST and the refinement method repeats at line . According to line the refinement method is repeated at line until the overall score is greater than threshold good enough or the number of refinement iterations is too large. The set of target hosts can describe a small set of hosts a cluster or a set of clusters as existing in an existing cloud configuration or in a hypothetical cloud configuration.

Referring to a pseudocode listing is provided for an example embodiment of a VM scalability method for CPU resources . At line a mapping table is pre computed containing records with a configuration descriptor for a virtual machine configuration a CPU measurement and measurement type and a TPP value total processing power in portable units calculated from the component scalability model for the hardware configuration and empirical data. At line the mapping table is stored in the database. At line a query is performed on the database with a server and VM configuration and a CPU measurement value and type. At line the query returns the closest matching record from the mapping table.

Referring to a pseudocode listing is provided for an example method to convert ordinary CPU utilization measurements to CPU capacity consumption in portable units. At line ordinary CPU utilization is measured as the number of active threads divided by the maximum number of active threads possible for the CPU. Method is primarily used to determine processor efficiency and available capacity for a host configuration under a virtual machine load. A suitable portable unit for CPU capacity consumption is CPU secs per unit of real time CPU secs sec .

Lines describe a calculation for capacity utilization as a total delivered work for a CPU divided by a CPU capacity. Lines and describe the CPU capacity as the delivered work for N Threads where N threads is the maximum number of threads supported by the CPU.

Lines describe a calculation for the delivered work for a CPU as a weighted sum of delivered work over each processor state from 1 to N Threads active where the weights are determined from the processor state probability. Lines describe the calculation of the state probability based on a binomial distribution of processor state probabilities.

Referring to lines describe the pseudocode for computing delivered work for a CPU when N threads are active from a total delivered capacity on NCHIPS processor chips with NCORES cores. Lines describes the calculation of total delivered capacity which is calculated as a total efficiency multiplied by a number of contending threads. Lines describe the calculation of the number of contending threads executing on a particular core a particular chip and with a number of tasks given. Lines describe a calculation for the total efficiency for a particular core of a particular chip with a number of tasks given. The total efficiency is calculated by calling the Object Efficiency routine. A suitable example of the Object Efficiency routine is disclosed in the 948 reference.

Referring to lines describe the pseudocode for an exemplary VMM scalability method for computing VMM efficiency. In exemplary method virtual machine monitor VMM CPU overhead is modeled as a function of the number of tasks executing on the host and the number of virtual CPUs configured on all the VMs on the host. At line VMM Thread Overhead is computed for a VMM on a host based on multiplying a MaxOverhead value for the VMM an adjustable parameter A and N Threads Executing and dividing by Total N Processor Threads for the host. Adjustable parameter A is in the range 0.0 1.0 . In the example embodiment the adjustable parameter is .

At line VMM CPU Overhead for a VMM on a host is computed based on the MaxOverhead value for the VMM the ones complement of adjustable parameter A and a minimum of 1 and ratio of Total Configured VCPUs for the host to ReferenceNVCPUs for the VMM.

In lines MaxOverhead value for a VMM is defined as the maximum CPU overhead imposed by the VMM on the host N Threads Executing is the number of processor threads currently executing a task Total N Processor Threads is the total number of processor threads configured on the host Total Configured VCPUs for a host is the total number of virtual CPUS configured on all VMS assigned to the host and ReferenceNVCPUs for a VMM is the number of virtual CPUs at which VMM VCPU Overhead for the VMM reaches its maximum. MaxOverhead VMM function and Reference NVCPUs VMM are model parameters derived empirically.

In an embodiment given a particular placement N Threads Executing on a host is computed as shown in lines where N Threads Executing is a ratio of the total consumption of VMs on the host to the total capacity permitted consumption of each physical processor thread on the host.

In an alternate embodiment for efficiency of the placement process an estimation is made and substituted for lines that the number of threads executing N Threads Executing is the maximum Total N Processor Threads so that N Threads Executing is not recomputed for each candidate placement. This estimation is also made if the number of threads executing is unknown.

Also when Total Configured VCPUs is unknown the maximum value of ReferenceNVCPUs is used for Total Configured VCPUs.

For VMM memory overhead on a host the memory available to VMs is reduced on that host and can be estimated as a simple function of memory consumption by the VMs on the host the number of VCPUs configured on the VMs on the host and the VMM type. The simple function is determined empirically.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various aspects of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The terminology used herein is for the purpose of describing particular aspects only and is not intended to be limiting of the disclosure. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises and or comprising when used in this specification specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

The corresponding structures materials acts and equivalents of any means or step plus function elements in the claims below are intended to include any disclosed structure material or act for performing the function in combination with other claimed elements as specifically claimed. The description of the present disclosure has been presented for purposes of illustration and description but is not intended to be exhaustive or limited to the disclosure in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the disclosure. The aspects of the disclosure herein were chosen and described in order to best explain the principles of the disclosure and the practical application and to enable others of ordinary skill in the art to understand the disclosure with various modifications as are suited to the particular use contemplated.

