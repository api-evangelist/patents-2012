---

title: Method and apparatus for carrier controlled dynamic rate adaptation and client playout rate reduction
abstract: A method and system is provided for controlling bandwidth rate limiting and client rendering rate limiting in a video delivery network. The method provides network service providers with a means for overriding video delivery data rates selected through dynamic client bitrate adaptation, as well as video data rendering rates of the clients, to limit the impact of network congestion. A system is also specified for implementing a client and a proxy computer in accordance with the method. The system works transparently with standard HTTP-based video delivery systems and includes an HTTP proxy cache infrastructure to support bandwidth rate limiting and client rending rate limiting. The system further provides for administrative overrides of client bitrate selection and client bandwidth usage.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918535&OS=08918535&RS=08918535
owner: Telefonaktiebolaget LM Ericsson (Publ)
number: 08918535
owner_city: Stockholm
owner_country: SE
publication_date: 20121102
---
This invention relates in general to streaming media and more specifically to client rendering rate control in a mobile carrier environment.

Available bandwidth in mobile carrier networks can vary widely. In densely populated areas the number of subscribers connected to a single access point can reduce bandwidth allocations for all users. As mobile users are handed off between access points sparse coverage or dense population can affect bandwidth availability at any time. For streaming media which require long lived connections being able to adapt to the changing bandwidth can be advantageous. Though video bitrate adaptation is often used to combat bandwidth variations short term fluctuations can also be addressed with playout rate adaptation.

A mobile carrier network functioning as a video delivery network employs a proxy computer to enforce video streaming policies for clients using bitrate adaptation and video playout rate reduction. Among other functions the proxy computer caches video segments from a video content server and delivers cached video segments to the clients while monitoring a variety of operational information including subscriber service level agreement SLA information local network bandwidth at the proxy computer and presence of congestion in the network. The operational information is used to calculate desired operational parameters including a target optimal bitrate for delivery of the video segments and an optimal bitrate for prefetching and predicatively prefetching future video segments. During operation the clients are notified of network conditions and modifications to be made to the playout rate at which the video segments are to be rendered to obtain a desired mix of quality playback and conformance to the desired operational parameters of the network.

Methods and apparatus are disclosed for performing traffic management within a carrier network by controlling HTTP based streaming video rate adaptation and initiating client playout rate limiting for streaming video through the use of a proxy cache. Proxy caching is used within the carrier network to limit carrier backhaul network usage to limit radio access network usage and to decrease retrieval latency for clients. The proxy cache optimizes HTTP based video streaming. HTTP based video streaming schemes typically rely on segmented video formats. Segmented video takes full length video files and divides it into multiple smaller files which when played in succession render the complete video. Video segments referred to herein as segments are typically on the order of seconds or tens of seconds in duration. There are multiple schemes for HTTP based video streaming e.g. HTTP Live Streaming Silverlight Smooth Streaming and other proprietary schemes as should be known to those skilled in the art. Rate limiting policies can be applied to HTTP based video streaming with rate limiting being performed on a per segment basis.

HTTP based streaming schemes can support bitrate adaptation by providing multiple versions of each segment and allowing clients to explicitly specify the version in the segment retrieval requests where each version is encoded at a different bitrate. Client controlled rate adaptation however can only take into account localized bandwidth fluctuations. Greedy client controlled rate adaptation schemes can be detrimental to overall network health. The invention provides for carrier control over rate adaptation which allows for a more holistic approach to network management.

Rate adaptation is an important tool for managing network utilization however bitrate switching often involves latency which can cause playback interruptions. Bitrate switching is also sometimes overkill for short duration network interruptions. Bitrate switching can reduce quality for many tens of seconds or even minutes while waiting for the rate adaptation algorithms to converge. Playout rate reduction offers an alternative for short term rate adaptation. Playout rate reduction can use the existing data stream but render it slower than intended to stretch out the data s useful wall clock duration. Stretching the useful duration of already buffered segments can provide a few seconds of margin for a network interruption to resolve itself or to mask the latency of a bitrate switch when used in conjunction with bitrate adaptation.

Deep stream inspection DSI is performed to classify video streaming sessions and recognize video delivery rate requested by the client. Because HTTP based video streaming allows clients to request the video in segments using a plurality of requests monitoring individual requests is insufficient for identifying HTTP based video streaming sessions. Video sessions are recognized based on an initial HTTP request. In one embodiment a playlist or manifest file is requested by the client to get a list of segments. In another embodiment well formed URL and query strings are used to convey video information.

The DSI parses the initial requests and responses to glean information about the stream and that information is used to create a session. In one embodiment sessions are created for all requests. In another embodiment sessions are only created for non video content if the request if from a specific source or for a specific destination address. In another embodiment sessions are only created for video content. In another embodiment sessions are only created for popular video content. In one embodiment content popularity is based on requests rate for the content.

Once the session is created and the streaming scheme is identified segment prefetching may commence. Sessions are then associated with subscriber information provided by the carrier. The subscription information contains subscriber service level agreement SLA and rate limiting information. In one embodiment the SLA is used to determine if the client session should be throttled back if the requested video delivery rate exceeds the purchased subscription. The SLA information may also be used for basic access control if the subscriber has not purchased access to the content requested. In one embodiment the subscription information may include resolution limits e.g. only devices with resolutions less than 480 360 . In another embodiment the subscription information may include platform restrictions e.g. only iOS devices or only Android devices or only Windows devices . In another embodiment the subscription information may include make and model restrictions e.g. only iPad or only HTC Desire HD . In another embodiment the subscription information may include network restrictions e.g. only 3G networks or only 4G networks . In one embodiment sessions are only created for client devices whose platform conforms to the subscription restrictions. In one embodiment sessions are only created for client devices whose network connectivity conforms to the subscription restrictions. In one embodiment global rate limiting policies may be specified by the carrier. In one embodiment the SLA is used to determine if the client s video streaming session is eligible for client playout rate reduction. In one embodiment a list is kept of all clients accessing the proxy. The list is ordered based on the SLA information where clients with a lower level of service are targeted for video rate adaptation and client playout rate reduction first.

In one embodiment client segment requests are redirected by a proxy to a remote network location of the segment. In another embodiment a local cache is used for storing retrieved segments. The segments are distributed from the local cache to the client. In one embodiment segments are evicted from the cache based on popularity. In another embodiment segments are evicted from the cache based on temporal locality. Because video segments are typically viewed in sequential order temporal locality is an efficient metric especially for live video streams that provide no support or only limited support for digital video recorder DVR functionality e.g. pause and rewind . To support the near live nature of HTTP video streams a minimum backlog threshold is supported so that temporal eviction always keeps at least S seconds of data in the cache where S is the threshold value. Intelligent cache prefetching for streaming video segments can also be used. Once a stream is initiated sequential access to segments is expected and future segments may be prefetched. Given the current known delivery rates taking into account the current network load the subscriber SLA and the global policy settings the likely target delivery rates may be inferred and only those bitrates prefetched.

In one embodiment segments are cached for use by clients and subsequent segments are prefetched for the requesting client. The proxy cache provides a method for differentiating between streaming methods and for recognizing client initiated rate adaptation schemes using URI signatures to recognize and parse HTTP based video streaming requests. The proxy cache measures the backend carrier backhaul network bandwidth available for retrieving and prefetching segments as well as measuring frontend radio access network RAN bandwidth available for delivering segments to the clients. When congestion occurs the proxy cache can force video rate adaptation disable segment prefetching reduce client segment delivery rates and notify clients to reduce their segment request rates and or video rendering playout rates.

An HTTP server is used which services client requests for content. In one embodiment non video segment requests are transparently proxied. In another embodiment non video segment requests are redirected to a separate HTTP proxy. Requests for video segments are processed and both subscriber and global rate limiting policies are applied. Once a target bitrate possibly lower than what the client requested is determined for the response segment the segment is served from the cache if it is available. Alternatively the request may be spoofed and proxied to a content server i.e. a request for the target bitrate rather than the requested bitrate if they are different is sent to the content server on behalf of the client. The segment retrieved from the content server is cached and sent to the client. In one embodiment if the desired bitrate segment is not available in the cache but a segment of a different bitrate is available in the cache the cached segment may be used to respond to the client to reduce response latency regardless of the bitrate of the cached segment. In one embodiment prefetching of subsequent segments is initiated at this point for the target bitrate. In one embodiment a threshold for maximum cache occupancy is maintained for each session.

In one embodiment backend bandwidth is measured when proxying video segments. The time for retrieving the segment from the server is compared with the target segment duration to determine if sufficient bandwidth exists to retrieve that video. If the measured bandwidth is less than the target rendering bitrate plus some small percentage e.g. 5 then the client is signaled to reduce its playout rate. In one embodiment frontend bandwidth is measured when proxying video segments. The time for delivering the segment to the client is compared with the target segment duration to determine if sufficient bandwidth exists to retrieve that video. If the measured bandwidth is less than the target rendering bitrate plus some small percentage e.g. 5 then the client is signaled to reduce its playout rate. In one embodiment an additional carrier specified backend threshold is set such that if the estimated excess backend bandwidth on the backend network connection falls below the backend threshold then the client is signaled to reduce its playout rate. In one embodiment an additional carrier specified frontend threshold is set such that if the estimated excess frontend bandwidth on the radio network connection falls below the frontend threshold then the client is signaled to reduce its playout rate. The following pseudo code shows an example of this algorithm 

In one embodiment the bandwidth estimates are based on the client interpretation of the available bandwidth as communicated through a bitrate adaptation request. In one embodiment the algorithm also includes checks to verify that the resolution of the selected bitrate video does not exceed subscription resolution limits.

In the description herein for embodiments of the present invention numerous specific details are provided such as examples of components and or methods to provide a thorough understanding of embodiments of the present invention. One skilled in the relevant art will recognize however that an embodiment of the invention can be practiced without one or more of the specific details or with other apparatus systems assemblies methods components materials parts and or the like. In other instances well known structures materials or operations are not specifically shown or described in detail to avoid obscuring aspects of embodiments of the present invention.

In is a block diagram for one embodiment of the present invention. It shows a typical mobile carrier network starting at the mobile carrier gateway referred to herein as a gateway which fans out to a plurality of base stations over a mobile carrier backhaul network . The gateway moderates access between the internal carrier network and the public internet. The gateway is also responsible for managing access to the network by mobile client devices . The base stations provide client devices with access via a radio access network RAN .

When a client device wishes to connect to a base station over the RAN a registration request is first sent to the gateway which contacts an authentication authorization and accounting AAA server to verify the subscriber information associated with the client device . The subscriber information includes access controls bandwidth SLA information device policy information as well as content and service subscriptions that have been purchased and associated with the client device .

The diagram shows the content server which represents a server containing video content. In one embodiment the content server is part of a carrier walled garden and may be directly accessed by the gateway through the carrier network. In another embodiment the content server is part of a content delivery network CDN or is hosted independently by the content provider which the gateway must access over the public Internet.

The diagram also shows the placement of a proxy cache which sits in line between the base station and the carrier backhaul network so that it can monitor both the backend carrier backhaul network bandwidth as well as the frontend base station radio access network bandwidth. In one embodiment the proxy cache is implemented as a stand alone server with a processor and memory for running specialized software implementing functionality for various foreseeable embodiments of the present invention. The proxy cache implements content caching and performs deep stream inspection DSI to identify and classify streaming video sessions. The proxy cache further provides bandwidth monitoring and client playout rate reduction control for streaming video sessions.

In one embodiment all requests are routed through the proxy cache . The proxy cache transparently proxies non HTTP requests. In another embodiment only content requests in e.g. only HTTP requests or requests on specific TCP destination ports are routed through the proxy cache . When the client device is granted access to the carrier network it issues a request for content. The request is routed from the base station to the gateway through the proxy cache and on to the content server . If multiple requests for the same content are initiated by a plurality of client devices multiple connections between client devices and the content server are created. The backhaul network can become unnecessarily overloaded with duplicate data being sent to support the plurality of client devices . The proxy cache alleviates this congestion in the backhaul network and limits load on the gateway by caching data closer to the base stations . If the content exists in the proxy cache it is served directly from the cache to the client device . Otherwise the request is forwarded to the gateway and on to the content server . The response is returned through the proxy cache where it is cached for use in servicing future requests.

When the mobile client device connects to the mobile carrier base station the base station contacts the gateway to verify subscriber access. The gateway contacts the AAA server to verify the subscriber information and returns that information to the base station . The subscriber information includes bandwidth SLA information and device policy information. In one embodiment the subscriber information is provided to the proxy cache by the base station . In another embodiment the proxy cache requests subscriber information from the AAA server directly when a client device issues a content request. When the client device issues an HTTP request for content the base station routes all HTTP requests through the proxy cache . The proxy cache classifies the request through DSI comparing it to known HTTP based video streaming protocol signatures. In one embodiment the signature comparison checks for requests of video segment playlists or manifest files. In another embodiment the signature comparison checks for known segment retrieval URI formats. In another embodiment the signature comparison checks for known segment retrieval query string formats.

In one embodiment if a video streaming request is detected a video streaming session is created. In another embodiment if a video streaming request is detected a popularity check is performed to see if a session should be created. If the popularity exceeds a minimum popularity threshold a session is created. In one embodiment the proxy cache maintains a hit rate count for video requests to determine popularity. In one embodiment a client device platform check is performed to see if a session should be configured. Sessions are only created for client device platforms which are on an approved platform list. In one embodiment a client device make and model check is performed to see if a session should be configured. Sessions are only created for client device makes and models which are on an approved make and model list. In one embodiment a client device network connectivity check is performed to see if a session should be configured. Sessions are only created for client devices which connect using an approved network technology. The session stores information gleaned from the initial request to aid in identifying future requests which belong to the same session.

In one embodiment if the playlist or manifest file does not already exist in the cache or if the playlist is a live real time updated playlist that needs refreshing the proxy cache proxies the playlist or manifest file request to the content server and caches the response. In one embodiment if the playlist or manifest file already exists in the cache and has not expired and is not for live video the already parsed and cached video information is used. In one embodiment a playlist or manifest file is parsed to glean segment URL prefixes. In another embodiment the URI is parsed to glean segment URL prefixes. In one embodiment the proxy cache recognizes m3u8 playlists. The master m3u8 playlists are used to glean the available bitrates and the individual bitrate playlists are used to glean the segment locations and naming convention. In another embodiment the proxy cache recognizes Silverlight manifest file playlists. The bitrate attributes of the Silverlight manifest is used to glean the available bitrates. In another embodiment the proxy cache recognizes Flash media manifest file playlists. The bitrate attributes of the Flash manifest are used to glean the available bitrates and the URL attributes are used to determine media locations. In another embodiment the proxy cache recognizes custom XML playlists.

There are many existing virtual playlist schemes and may ways to implement alternate video playlist schemes as should be known to those skilled in the art. Any of those virtual playlist methods would be suitable for generating a signature for that playlist format and inclusion in the proxy cache for session classification. In one embodiment the proxy cache supports proxying HTTPS connections for playlist requests. The SSL TLS encrypted playlist request from the client is terminated by the proxy cache and issues a spoofed backend HTTPS request to the content server to retrieve the up to date playlist.

HTTP based video streaming schemes require the client to issue a plurality of subsequent requests for additional segment files to retrieve additional video data to render. These requests which are routed through the proxy cache by the base station are classified through DSI and found to match existing video streaming sessions created through previous requests. Retrieved video segments are cached in the proxy cache and future segments are prefetched based on the current segment bitrate. In one embodiment the proxy cache prefetches the next segment of the same bitrate. In another embodiment the proxy cache prefetches the next segment for a higher bitrate if excess bandwidth exists and the client SLA allows for it. In another embodiment the proxy cache prefetches the next segment for a lower bitrate if network congestion is detected. In one embodiment the segment bitrate is determined from the URL by matching it to information in the playlist or manifest file. In another embodiment the segment bitrate is determined from the segment file name. In another embodiment the segment bitrate is determined from the query string parameters in the request from the client . The bitrate is also used to determine if playout rate reduction should be enforced. In one embodiment the segment bitrate must also take into account the video resolution of the video encoded at that bitrate. If the resolution exceeds a maximum resolution as set by the carrier either globally or through the subscription or SLA information that bitrate must be excluded from selection.

Upon processing each segment request the proxy cache checks to see if the carrier has set any global rate limiting policies for either the carrier backhaul network or the radio access network . The proxy cache compares the backhaul network excess bandwidth estimates and the radio access network excess bandwidth estimates with the minimum excess bandwidth thresholds set by the carrier. The following pseudo code shows an example of this algorithm 

If either threshold has been violated a notification is sent to the client device with the segment instructing it to reduce its playout rate. In one embodiment the notification is sent in band via a custom HTTP header. In another embodiment the notification is sent out of band through a separate control channel. In one embodiment bandwidth estimates are provided to the proxy cache by the base station . In another embodiment bandwidth estimates are retrieved by the proxy cache from the base station e.g. using SNMP to retrieve RMON statistics. In another embodiment the bandwidth estimates are calculated by the proxy cache based on segment download times. The segment size divided by the segment retrieval time gives a bandwidth estimate for the carrier backhaul network . Though the segment retrieval time may be influenced by congestion in the public internet this just allows the carrier backhaul network usage to be optimized for end to end delivery. Similarly the segment size divided by the segment delivery time gives a bandwidth estimate for the local radio access network . The following pseudo code shows an example of this algorithm 

In one embodiment client playout rate reduction is limited to specific SLA levels. There may be multiple backend and frontend minimum bandwidth thresholds for the carrier backhaul and radio access networks and respectively. For example there could be one threshold for each service level e.g. silver gold platinum the higher the service level the lower the threshold. In this case the proxy cache looks up the service level for the client device and uses the corresponding bandwidth thresholds for that service level. The following pseudo code shows an example of this algorithm 

In one embodiment when the frontend RAN bandwidth is the reason for playout rate reduction the segment returned in the HTTP response is also replaced with a lower bitrate version of the segment. The proxy cache checks the cache to see if a corresponding segment exists. In one embodiment lower bitrate segments are identified based on the URL prefixes gleaned from the playlist or manifest files. In another embodiment lower bitrate segments are identified based on segment file names. If a lower bitrate version of the segment file exists it may be substituted to reduce delivery bandwidth requirements. Client playout rate reduction is still used to reduce segment playout and therefore segment request rate.

In one embodiment when playout rate reduction is in effect the segment prefetching is disabled. In another embodiment when playout rate reduction is in effect the segment prefetching continues however lower bitrate segments are retrieved and used to service subsequent segment requests from the client device . In one embodiment the proxy cache retrieves the lowest possible bitrate for the media in order to achieve the fastest reduction in bandwidth usage. In another embodiment the proxy cache retrieves the next lower bitrate for the media in order to minimize playback continuity disruption. In another embodiment the proxy cache retrieves the highest possible bitrate which is below the bandwidth estimate in order to maintain network usage optimality. In one embodiment lower bitrate segments are identified based on the URL prefixes gleaned from the playlist or manifest files. In another embodiment lower bitrate segments are identified based on segment file names.

If the HTTP request is not for streaming video the request is forwarded to the gateway . In one embodiment the non video request is proxied by the proxy cache and the content may be cached. In another embodiment the non video request is redirected to the gateway such that the response will not traverse the proxy cache . The gateway routes the request to the content server performing network address translation NAT as required.

Backhaul networks are typically closed networks which support multicast distribution of data. In one embodiment the proxy cache may request that responses from the content server be multicast by the gateway to multiple geographically adjacent proxy caches . In one embodiment the streaming proxies are co located with the base stations . The base stations have known geographic relationships to each other. The proxy caches join multicast groups based on these known geographic relationships in order to receive multicast distribution of segments based on geographic locality. In another embodiment each proxy cache services multiple base stations where all base stations associated with a given proxy cache share geographic locality. Given client devices that are mobile the client devices may be handed off to different base stations at any time. It is probable that the client device will be handed off to base stations that are geographically adjacent to the current base station . In one embodiment only prefetched segments are requested to be multicast to geographically adjacent streaming proxies . In another embodiment both the initially requested segments as well as the prefetched segments are requested to be multicast to geographically adjacent streaming proxies .

Requests from the client device are received by the HTTP server in the proxy cache after being routed by the base station . In one embodiment the base station recognizes HTTP traffic based on the TCP port e.g. ports and . In another embodiment the base station recognizes HTTP traffic through deep packet inspection of the TCP flow e.g. checking for HTTP headers in the TCP payload . In another embodiment the base station just sends all traffic to the proxy cache and relies on the proxy cache to redirect or proxy non HTTP requests to the gateway . The HTTP server terminates the HTTP connection from the client device and the session manager parses the request URI. The session manager creates video sessions maps segment requests to existing video sessions or determines a request to be non video related and proxies or redirects the request.

In one embodiment sessions are created for all requests. In another embodiment sessions are only created for non video related requests if the source or destination addresses are well known. In another embodiment sessions are only created for video related requests. In another embodiment sessions are only created for popular video related requests. In one embodiment video popularity is based on requests rate for the video as observed by the proxy cache . In one embodiment sessions are only created for client devices whose platforms are on an approved platform list. In one embodiment sessions are only created for client devices whose make and model are on an approved make and model list. In one embodiment sessions are only created for client devices whose network connection is through an approved network technology. In one embodiment non video related requests e.g. standard Web page requests are redirected to the gateway . In another embodiment non video related requests are processed by the proxy cache .

For non video sessions e.g. standard Web page requests the session manager creates a simple TCP based flow using a standard 5 tuple source IP address destination IP address source TCP port destination TCP port and protocol for tracking the request. For video sessions since multiple HTTP requests will be received from the client one request per segment TCP based flow tracking is not sufficient. A streaming session is created using the subscriber information for the client device the location of the video segments previous video segment request history and temporal locality of requests. Subscriber information and video segment location alone may not be sufficient as the video may be a mash up of multiple video sources. Video segment requests are further processed by the session manager to determine the target bitrate and the target segment to be returned to the client device . In one embodiment the video resolution is also considered when selecting the target bitrate. A maximum resolution check is used to screen for valid target bitrates. The cache manager checks the cache for the video or non video related content requested. If the content exists in the cache it is returned to the client device . If the content does not exist in the cache the cache miss handler is instructed to retrieve the content from the content server . For video segment requests the cache prefetch handler may also be instructed to begin prefetching subsequent video segments.

The session manager is responsible for managing subscriber information and retrieving the subscriber information if it is not already available. In one embodiment the subscriber information is pushed to the proxy cache by the base station when the client device is granted access to the network. Client devices cannot connect to just any cellular network. Access control is performed by each base station . The unique identifier of the client device must either be verified with the AAA server each time the client device is associated with a new base station or the client device must be registered with the new base station through the hand off process. In another embodiment the proxy cache requests the subscriber information directly from the AAA server using a standard protocol and API e.g. RADIUS or DIAMETER or through a proprietary API over a standard protocol e.g. XML Web Service . Different subscriber SLA information may be associated with the network depending upon whether it is the home network of the client device or if the client device is roaming.

The session manager also maintains an API for the carrier to push subscriber information or global rate limiting policies to the proxy cache . In one embodiment the proxy cache provides a RESTful HTTP based API for setting subscriber information and a separate RESTful HTTP based API for setting global rate limiting information. The API allows specifying a policy group and a rate limit or SLA. The policy group could be an individual user ID a service level ID e.g. gold silver bronze a media ID a media group ID e.g. channel name or the global policy ID specified in the RESTful URI. Either a numeric rate limit value is specified as part of the RESTful URI or an SLA in a known XML format is specified in the entity body.

The API allows for proactive synchronization of policy database information between the carrier subscriber management system and the proxy cache . In one embodiment subscriber information may include a bandwidth limit. In one embodiment the subscriber information may include media or media channel subscription information. In another embodiment the subscriber information may include a service level for which a global rate limit may be applied. In one embodiment the global rate limiting policy may include a bandwidth limit applied to all sessions on the proxy cache . In another embodiment the global rate limiting policy may include a bandwidth limit applied to all sessions on the proxy cache within a service level. In another embodiment the global rate limiting policy may include a bandwidth limit applied to a specific media or media channel. In another embodiment the global rate limit policy may include a global minimum bandwidth requirement for the backend carrier backhaul network . In another embodiment the global rate limit policy may include a per service level minimum bandwidth requirement for the backend carrier backhaul network . In another embodiment the global rate limit policy may include a per subscriber minimum bandwidth requirement for the backend carrier backhaul network . In another embodiment the global rate limit policy may include a per media or per media channel minimum bandwidth requirement for the backend carrier backhaul network . In another embodiment the global rate limit policy may include a global minimum bandwidth requirement for the frontend radio access network . In another embodiment the global rate limit policy may include a per service level minimum bandwidth requirement for the frontend radio access network . In another embodiment the global rate limit policy may include a per subscriber minimum bandwidth requirement for the frontend radio access network . In another embodiment the global rate limit policy may include a per media or per media channel minimum bandwidth requirement for the frontend radio access network .

For playlist or manifest based schemes video sessions may be created when the playlist or manifest is requested and the playlist or manifest response may be parsed to determine what bitrates are available for the requested video. The playlist or manifest file typically specifies the different bitrates available for retrieval. The available bitrates are used to determine the best bitrate to use when applying rate limiting policies. In one embodiment the playlist or manifest that is returned to the client device is not the playlist or manifest that was retrieved from the content server . In one embodiment bitrates which have been deemed too high for current network conditions or that exceed the global rate limiting policies may be omitted from the playlist returned to the client . In another embodiment bitrates may be reordered to suggest the starting bitrate to the client . In one embodiment the highest bitrate below the current bandwidth estimate is suggested as the starting bitrate to provide the highest quality initial playback. In another embodiment the lowest bitrate is suggested as the starting bitrate to minimize the retrieval latency and provide the fasted possible initial playback. In one embodiment a playlist or manifest that contains only a single bitrate may be generated by the playlist generator . The single bitrate playlist identifies the proxy cache as the location for the segments allowing the proxy cache to make the target bitrate determination at the time the segment is requested. This prevents client side rate adaptation schemes from attempting to switch to a bitrate which exceeds the subscriber s SLA or the global rate limiting policies.

Once the session is created the session manager queries the cache manager to retrieve the content from the cache . The content may be non video content a video playlist or manifest file or a video segment. The cache manager is responsible for keeping track of what is in the cache what should be fetched or prefetched and added to the cache as well as what should be evicted from the cache and when eviction should occur. If the content exists in the cache it is returned either to the session manager which passes it to the HTTP server or it is returned directly to the HTTP server to be delivered to the client device . In one embodiment playlist and manifest files should be returned to the session manager for further parsing and video session creation while non playlist or manifest files may be directly returned to the HTTP server . In another embodiment all content is returned through the session manager for session accounting purposes.

If the content does not already exist in the cache the cache manager issues a request for the content via the cache miss handler . In one embodiment the cache miss handler sends a request for content to the gateway which gets forwarded to the content server . In another embodiment content requests are also sent to neighboring proxy caches . Upon receiving the response the cache miss handler places the content in the cache and notifies the cache manager . The content is then returned to the session manager and passed to the HTTP server to be delivered to the client device . In one embodiment if the content is non video content then it is immediately evicted from the cache by the cache manager . In another embodiment the least recently used LRU non video content is always evicted first. In another embodiment popularity based eviction is employed which does not necessarily evict non video content first. For the popularity based eviction scheme video segments from live or near live streams which will never be accessed again should be evicted first. If no live or near live evictable content exists less popular content should be evicted first. In one embodiment popularity is based on a weighted request frequency where more recent requests are given a higher weight. In another embodiment popularity is based on values explicitly set by the carrier. Less popular content even for currently streaming sessions may be evicted as long as the content has already been delivered to all active streaming sessions. Prefetched and multicast push content which has not been played out yet is considered to have infinite popularity.

In one embodiment when video segment data is requested the HTTP server forwards the request to the session manager who checks if the bitrate of the requested segment matches the bitrate of the previously requested segment. If the bitrate is the different the session is updated. If the bitrate is lower than the previously requested bitrate then congestion may be inferred and should be noted. If the bitrate is higher than the previously requested bitrate then the new bitrate must be evaluated based on the global rate limiting and the per subscriber and per media rate limiting policies. Regardless of whether or not the bitrate changed the minimum bandwidth policies should be re evaluated and enforced on each request.

Once the target bitrate has been chosen the session manager asks the cache manager to check and see if the next sequential segments for that bitrate are available in the cache . If the segments are not in the cache then the cache manager issues a request to the cache prefetch handler to get the next sequential segments. A threshold for the maximum number of segments to prefetch is maintained by the cache manager . In one embodiment the prefetching threshold is measured in rendering duration and the number of segments is determined by the segment duration. In another embodiment the prefetching threshold is measured in cache occupancy and the number of segments is determined by the size in bytes of the segments. In one embodiment the cache prefetch handler sends a request for content to the gateway which gets forwarded to the content server . In another embodiment the cache prefetch handler also sends a request to the neighboring proxy caches . Upon receiving the response the cache prefetch handler places the content in the cache and notifies the cache manager . The cache manager performs cache eviction as necessary.

In one embodiment if the session manager has to enforce any global rate limiting policies the client is notified to begin playout rate reduction to reduce load on the network. In one embodiment if the session manager detects any client enacted rate adaptation the client is notified to begin playout rate reduction to increase prefetching time and reduce load on the network. In one embodiment the session manager instructs the HTTP server to insert a custom HTTP header to indicate that client playout rate reduction is in force.

In one embodiment segments of a video are prefetched according to an a priori configured schedule. The proxy cache maintains a schedule of programmed content. In one embodiment the proxy cache and content server are time synchronized via a separate mechanism such as the network time protocol NTP . This is particularly useful for distribution of real time streams such as live events or for pre positioning of popular pre recorded content such as TV shows.

In one embodiment the HTTP server delivers the video segment data to the client device in a paced manner. The data is paced at the segment bitrate. The segment bitrate is the bitrate at which the segment is encoded which should be less than or equal to the target bitrate. For media players that measure bandwidth in order to perform client side bitrate adaptation sending data at the target bitrate will limit the media player s desire to switch to a bitrate which exceeds the subscriber s SLA or the global rate limiting policies. An example of a suitable adaptive HTTP streaming server to perform paced delivery is described in PCT Application No. PCT US09 60120 filed Oct. 9 2009 and entitled Method And Apparatus For Efficient HTTP Data Streaming.

In one embodiment the proxy cache requests that video segments be multicast by the gateway to multiple streaming proxies . In one embodiment the gateway multicasts through a plurality of intermediate distribution nodes which then multicast to the proxy caches . In one embodiment the proxy cache requests that video segments be unicast by the gateway to multiple proxy caches . In one embodiment the gateway unicasts through a plurality of intermediate distribution nodes which then unicast to the proxy caches . Note that the rest of the discussion applies to the gateway or distribution nodes interchangeably with respect to the distribution of content to the proxy caches . The multicast push handler is responsible for receiving these unsolicited distributions of content. The multicast push handler is responsible for joining the proper multicast trees within the carrier backhaul network . The multicast trees are differentiated by IP multicast group ids which may correspond to different channels in the case of real time streams and different bitrates or to different geographic locations.

Multicast delivery requires a non stateful transport protocol like UDP as should be known to those skilled in the art. As such the reliable data delivery provided by stateful protocols like TCP is not available. In one embodiment the multicast push handler supports forward error correction FEC . There are many network data coding schemes which may be used to implement FEC as should be known to those skilled in the art. Any representative scheme should be applicable. The multicast push handler is responsible for verifying received content and applying FEC where necessary.

In one embodiment if FEC is not sufficient for recovering the data or if packet loss is detected negative acknowledgements NACK are used to request retransmission of data from the gateway . The NACKs are sent via a separate TCP control channel back to the sender. The multicast push handler is responsible for detecting packet loss and issuing NACKs. There are many methods for detecting packet loss as should be known to those skilled in the art. Any representative scheme should be applicable. Packet loss rates may be used to estimate congestion in the multicast network. In one embodiment the gateway may monitor NACK rates to determine when to reduce multicast load. In another embodiment when congestion occurs special NACKs may be sent to the gateway to notify it to reduce multicast load. In another embodiment multicast push handler may resign from one or more multicast trees when congestion is detected to reduce load on the local proxy cache .

In one embodiment the priority of the multicast trees is set by the carrier and lower priority trees are resigned from first. In another embodiment multicast trees for higher bitrates should be resigned from first as they have the most impact on network load. Once data is received by the multicast push handler it reassembles the video segment files from the packetized multicast data. The reconstituted files are placed into the cache by the multicast push handler which then notifies the cache manager . The cache manager performs cache eviction as necessary. These rules may be based on a content priority policy as indicated by a cache policy manager at the gateway where the policy itself may be based on content licensing such as take down rules featured content placement as well as content usage such as most popular etc. The eviction rules help control cache storage requirements.

In one embodiment prefetching of video segments according to an a priori configured schedule may be preempted by pre scheduled multicast push. This is particularly useful for distribution of real time streams such as live events or for pre positioning of popular pre recorded content such as TV shows. In one embodiment the proxy cache may subscribe to real time or live streaming push preload multicast trees. The client device would be made aware of activation and deactivation times for the content with the multicast push occurring before the activation time.

In step a video playlist or manifest request has been detected. A streaming session is created for the client device . In one embodiment a platform check is performed to ensure that the client device is a whitelisted or non blacklisted platform. In one embodiment a make and model check is performed to ensure that the client device is a whitelisted or non blacklisted make and model. In one embodiment a network check is performed to ensure that the client device is connecting through a whitelisted or non blacklisted network. In one embodiment a subscription check is performed to ensure that the client device has rights to view the content. The session manager performs steps and in parallel. In step the session manager checks to see if the client device subscriber SLA information is already known. Under normal circumstances the subscriber SLA information should be pushed to the session manager when the client device authenticates for access to the carrier network. If the subscriber information does not exist in the session manager a request is sent to the gateway to check the authentication server for the subscriber information.

In step the session manager requests the playlist or manifest file from the cache manager and the cache manager checks to see if the playlist or manifest file already exists in the cache . If the playlist of manifest already exists in the cache then the playlist or manifest is returned to the session manager and processing continues to step . If the playlist or manifest does not exist in the cache processing continues to step where the cache miss handler retrieves the playlist or manifest file from the content server . If necessary the cache manager performs cache eviction to make room in the cache for the new playlist or manifest file. Once retrieved the playlist or manifest file is added to the cache and returned to the session manager and processing continues to step .

In step the session manager determines whether or not to generate a spoofed playlist based on the rate limiting policies. In one embodiment only master playlists which specify a plurality of other playlists for different bitrates are spoofed. If the bitrates in the playlist do not exceed the rate limits and a spoofed playlist is not to be generated processing continues to step where the actual playlist or manifest is returned to the client device . If rate limiting is required and the proxy cache would like to hide the actual available bitrates from the client device then a spoofed playlist needs to be generated and processing continues to step where the playlist generator creates a spoofed playlist. In one embodiment a single bitrate playlist is generated which contains a list of segments similar to those in the actual playlist but with naming changes to make subsequent segment requests easily recognizable by the proxy cache . In another embodiment the bitrates which exceed the global or subscriber rate limits are removed from the actual playlist. In another embodiment the order of the remaining bitrates is changed so that the optimal bitrate will be played first by the client. Once the spoof playlist has been generated processing continues to step where the spoofed playlist is returned to the client device .

In step the session manager applies the current bitrate adaptation policies to the segment. Global policies may change over time and subscriber bandwidth limits may be exceeded at different points in time. The subscriber s bandwidth allocation for the client device is reevaluated on each segment request. The session manager selects a target bitrate and proceeds to step where the segment is requested from the cache manager . In one embodiment the target bitrate is only valid if the video resolution of that bitrate encoding does not exceed a maximum resolution as set by the global or subscriber policies. If the segment for the target bitrate already exists in the cache then the segment is returned to the session manager and processing continues to step . In one embodiment if a corresponding segment at a different bitrate is available then that segment is returned to the session manager and processing continues to step . If the no suitable segments exist in the cache processing continues to step where the cache miss handler retrieves the content from the content server . If necessary the cache manager performs cache eviction to make room in the cache for the new content. Once retrieved the content is added to the cache and returned to the session manager and processing continues to step .

In step the segment is returned to the client device . In one embodiment the session manager adds custom HTTP response headers to indicate to downstream networking devices the bandwidth necessary to deliver the segment. The bandwidth needed depends on the video quality parameters such as encoding bitrate resolution frame rate as well as complexity of the image sequence. In one embodiment the session manager adds custom HTTP response headers to indicate to the client device the current network conditions. In one embodiment the session manager adds customer HTTP response headers to indicate to the client device that client playout rate reduction should be enacted. Processing continues to step where the session manager checks with the cache manager to see if the next sequential segments exist in the cache . If the segments exist in the cache then processing ends. If the segments do not exist in the cache then processing proceeds to step where the next sequential segments are prefetched. In one embodiment only segments for the target bitrate are prefetched. In another embodiment segments for the target bitrate one bitrate higher and one bitrate lower are all prefetched. In another embodiment the lowest possible bitrate is always prefetched.

In step the session manager creates a simple 5 tuple flow for the non video content request then proceeds to step where the session manager requests the content from the cache manager . If the content already exists in the cache then the content is returned to the session manager and processing continues to step . If the content does not exist in the cache processing continues to step where the cache miss handler retrieves the content from the content server . If necessary the cache manager performs cache eviction to make room in the cache for the new content. Once retrieved the content is added to the cache and returned to the session manager and processing continues to step . In step the content is returned to the client device . Persistent HTTP requests may be processed on the same session. The session ends when the TCP connection is torn down.

Given a video distributed using HTTP Live Streaming a master m3u8 file is requested by the client device in step . The request is parsed by the session manager in step and determined to be for a playlist in step . The session manager then creates a video streaming session in step . The master m3u8 playlist is retrieved by the cache manager in steps and and returned to the session manger who parses it and finds contains references to 4 different individual bitrate m3u8 files for 64 kbps 160 kbps 320 kbps and 864 kbps. The session manager finds a global rate limit of 800 kbps and a subscriber rate limit of 700 kbps. The playlist generator generates a spoofed playlist containing only the 3 bitrates 64 kbps 160 kbps and 320 kbps which do not exceed the target bitrate in step and returns it to the client device . Subsequent requests for the individual bitrate playlists which are not spoofed and returned directly to the client device . The client device then requests the first 160 kbps segment in step . The request is parsed by the session manager in step and determined to be for a video segment in step . The target bitrate is recalculated in step . It is still set at 700 kbps so the 160 kbps segment is fine and no action is required. The segment is retrieved by the cache manager in steps and and the segment is returned to the client device in step . In step the cache manager checks to see if prefetching is needed if so it checks if prefetching has been initiated if not then the cache prefetch handler begins prefetching subsequent 160 kbps segments. The client device then requests the next segment at 320 kbps in step . The request is parsed by the session manager in step and determined to be for a video segment in step . The target bitrate is recalculated in step . It is assumed that the carrier has reset the global rate limit to 300 kbps causing the new target bitrate to be 300 kbps due to network congestion. The 320 kbps segment requested exceeds the target bitrate and the target segment is determined to be the 160 kbps segment. The prefetched 160 kbps segment is retrieved by the cache manager from the cache in step and the segment is returned to the client device in step .

Upon parsing the playlist manifest file in step the session manager instructs the cache manager to check the cache for the first segment and if it is not already in the cache to prefetch the first segment in anticipation of the next request from the client device . In one embodiment the first segment prefetched is always prefetched from the highest bitrate. In another embodiment the first segment prefetched is selected such that it is the highest bitrate which falls below the current bandwidth estimate in order to provide optimal network utilization. In another embodiment the first segment prefetched is always prefetched from the lowest non audio only bitrate to minimize retrieval and playback latency. The playlist generator then creates the spoofed playlist. In one embodiment the playlist manifest is modified to remove bitrates which exceed global rate limiting thresholds. In another embodiment the playlist manifest is modified to remove bitrates which exceed the subscriber SLA rate limiting thresholds for the client device . In one embodiment the playlist manifest is modified to remove bitrates whose video resolution exceed a maximum resolution as set by the global or subscriber policies. In another embodiment the order of the remaining bitrates is changed so that the lowest non audio only bitrate will be played first by the client. In another embodiment the order of the remaining bitrates is changed so that the highest bitrate will be played first by the client. In another embodiment the order of the remaining bitrates is changed so that the highest bitrate which falls below the current bandwidth estimate will be played first by the client. Once the session is created the spoofed playlist manifest is delivered to the client device . Because the returned playlist manifest may differ from the actual playlist manifest that was requested the transparent insertion of an alternate playlist manifest is referred to as spoofing the playlist.

If the request is not for a playlist or manifest file processing proceeds to step where the request is checked to see if it is for a video file segment. If the request is not for a file segment processing proceeds to step where the request is proxied to its destination and no further session processing is performed. If the request is for a file segment processing proceeds to steps and where the frontend and backend bandwidth thresholds are checked respectively and step where the segment bandwidth requirement is checked.

The bandwidth monitor tracks bandwidth measurements for the proxy cache . In one embodiment all network traffic between the base station and the gateway traverses the proxy cache giving the bandwidth monitor a comprehensive view of the network utilization. In step the bandwidth monitor is checked to get a current estimate of the frontend radio access network bandwidth. In step the bandwidth monitor is checked to get a current estimate of the backend carrier backhaul network bandwidth. If either the frontend bandwidth in step falls below the thresholds set by the carrier for the service level of the requesting client device or the backend bandwidth in step falls below the thresholds set by the carrier for the service level of the requesting client device or the available bandwidth falls below the bitrate of the requested segment in step then processing proceeds to step where bandwidth usage mitigation steps are initiated by the session manager . In one embodiment if the current segment has already been prefetched then that segment is selected for delivery to the client device . In another embodiment if the file has already been prefetched and the frontend bandwidth is below the threshold then the session manager instructs the cache manager to check to see if a lower bitrate version of the same segment resides in the cache and that segment is selected for delivery the lower bandwidth version if possible. In one embodiment prefetching is disabled when congestion occurs so the next segment is not prefetched. In this case in subsequent requests there may be no segment available in the cache to deliver to the client device and the request must be proxied in real time. In another embodiment when congestion is detected the segment to be prefetched is chosen from the lowest bitrate available for the media to minimize bandwidth usage. In another embodiment when congestion is detected the segment to be prefetched is chosen from the highest bitrate that does not exceed the current bandwidth estimate. The client playout rate reduction flag is also set in step .

Once the bandwidth usage mitigation actions have been defined processing proceeds to step where the spoofed segment is delivered to the client device . The spoofed segment is the segment selected for delivery. Because the selected segment may be of a lower bitrate than the segment that was requested the transparent insertion of an alternate segment is referred to as spoofing the segment. If a prefetch segment has been identified its retrieval from the content server is initiated in step as well. In one embodiment the client is notified to initiate client playout rate reduction by a custom HTTP header in the segment delivery response. The file segment delivery to the client device is monitored by the bandwidth monitor to estimate frontend bandwidth and file segment prefetching from the content server is monitored by the bandwidth monitor to estimate backend bandwidth.

If sufficient bandwidth exists in the checking of steps then processing proceeds to step where the segment request is checked to see if a rate change has occurred in the client. If the segment request is for the same bitrate as the previously requested segment processing proceeds to step where the segment is retrieved from the cache and delivered to the client and prefetching is initiated for the next segment by the session manager through the cache manager . In one embodiment the segment prefetched is for the same bitrate as the current segment being requested. In another embodiment the segment prefetched is chosen from the highest bitrate that does not exceed the current bandwidth. The file segment delivery to the client device is monitored by the bandwidth monitor to estimate frontend bandwidth and file segment prefetching from the content server is monitored to estimate backend bandwidth.

If the segment request in step is for a different bitrate than the previously requested segment processing proceeds to step where the session manager instructs the cache manager to check to see if the new bitrate version of the segment is in the cache . In one embodiment if the new bitrate version is not found the already prefetched segment is delivered to the client. In another embodiment if the new bitrate version is not found the client request must be proxied in real time. In one embodiment the segment prefetched is for the new bitrate. In another embodiment the segment prefetched is chosen from the highest bitrate that does not exceed the current bandwidth. In one embodiment if the segment was not found in the cache the client playout rate reduction flag is set in step to provide more time for prefetching. In another embodiment if the segment requested is for a lower bitrate than the previously requested segment the client playout rate reduction flag is set in step to further reduce load on the network. Once the rate adaptation actions have been defined processing proceeds to step where the selected segment is delivered to the client device and the session manager instructs the cache manager to prefetch the next segment from the content server . In one embodiment the client is notified to initiate client playout rate reduction by a custom HTTP header in the segment delivery response. The file segment delivery to the client device is monitored by the bandwidth monitor to estimate frontend bandwidth and file segment prefetching from the content server is monitored by the bandwidth monitor to estimate backend bandwidth.

In step the playlist is retrieved from the cache by the cache manager or a request is forwarded to the content server if the playlist is not already in the cache and the response is parsed. If the playlist is a master playlist containing other individual playlists all the individual playlists are also retrieved and parsed. In one embodiment though segments may not be cached playlist files are still cached in the cache . In parallel the subscriber information for the client device is retrieved from the carrier to ascertain the service level of the client device . In one embodiment a platform check is performed to ensure that the client device is a whitelisted or non blacklisted platform. In one embodiment a make and model check is performed to ensure that the client device is a whitelisted or non blacklisted make and model. In one embodiment a network check is performed to ensure that the client device is connecting through a whitelisted or non blacklisted network. In one embodiment a subscription check is performed to ensure that the client device has rights to view the content. A session is created by the session manager mapping the device and the content request to the service level and the parsed playlist manifest file. The playlists are parsed to determine the number of bitrates available and the number of segments associated with the content. Using this information a spoofed playlist is generated by the playlist generator .

The spoofed playlist contains a single bitrate with the segment locations point back to the proxy cache . This ensures that all segment requests will still traverse the proxy cache . The segment locations in the playlist do not indicate specific bitrate the bitrate will be chosen dynamically when the segment is requested. In one embodiment the segment locations identify the local session id to simplify session lookup for the session manger . Because the playlist returned to the client device is not the playlist it requested the transparent insertion of the single bitrate playlist is referred to as spoofing the playlist. In one embodiment each segment is marked as being discontinuous. Because each segment may be of a different bitrate or frame rate or resolution the discontinuity indication is needed by certain media players in order to provide the highest quality playback.

Once the initial spoofed playlist is created processing proceeds to step where a check is done to see if any stream splicing is necessary. If stream splicing is desired processing proceeds to step where segment splicing occurs. In one embodiment additional segments are added to the playlist to allow for ad insertion. In another embodiment mappings are generated for switching between different streams at specific segment boundaries. In one embodiment spliced segments are marked as being discontinuous. Because each segment may be from a different video stream the discontinuity indication is needed by certain media players for rectifying time boundaries and relative video references in order to provide the highest quality playback. Once stream splicing is complete or if no stream splicing was required in step processing proceeds to step . In step the spoofed playlist is returned to the client device .

In step if the request was not for a playlist or manifest file in step the request is checked to see if it is for a video file segment. Specifically the request is checked to see if the location is of a specific format which would indicate it is from a spoofed playlist for an existing session. If the request is not for a file segment processing proceeds to step where the request is proxied to its destination and no further session processing is performed. If the request is for a file segment the session manager looks up the session and processing proceeds to steps and where the frontend and backend bandwidth thresholds are checked respectively and step where the segment bandwidth requirement is checked.

The bandwidth monitor tracks bandwidth measurements for the proxy cache . In one embodiment all network traffic between the base station and the gateway traverses the proxy cache giving the bandwidth monitor a comprehensive view of the network utilization. In step the bandwidth monitor is checked to get a current estimate of the frontend radio access network bandwidth. In step the bandwidth monitor is checked to get a current estimate of the backend carrier backhaul network bandwidth. If either the frontend bandwidth in step falls below the thresholds set by the carrier for the service level of the requesting client device or the backend bandwidth in step falls below the thresholds set by the carrier for the service level of the requesting client device or the available bandwidth falls below the bitrate of the requested segment in step then processing proceeds to step where bandwidth usage mitigation steps are initiated by the session manager . If no bandwidth mitigation steps were required in steps or then processing proceeds directly to step . In step the client playout rate reduction flag is set and processing proceeds to step .

In step the session manager uses the current bandwidth estimates to select the target bitrate segment for the client device . In one embodiment the segment bitrate is chosen as the highest bitrate that does not exceed the current bandwidth the global bandwidth limits or the client SLA bandwidth limits. In one embodiment the target bitrate is only valid if the video resolution of that bitrate encoding does not exceed a maximum resolution as set by the global or subscriber policies. The session manager finds the actual source location of the segment as determined from the original playlist parsed in step and instructs the HTTP server to return an HTTP redirect to the client device redirecting the segment request to the location of the spoofed segment. The spoofed segment is the segment selected for delivery. Because the client device is unaware of and has no influence over the segment selection process the transparent insertion of the selected segment is referred to as spoofing the segment. In one embodiment the client is notified to initiate client playout rate reduction by a custom HTTP header in the segment delivery response.

Although the above description includes numerous specifics in the interest of a fully enabling teaching it will be appreciated that the present invention can be realized in a variety of other manners and encompasses all implementations falling within the scope of the claims herein.

