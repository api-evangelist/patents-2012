---

title: Advanced business query language
abstract: A new query language can be embedded in a business application programming language (e.g., the ABAP language). A query language consistent with implementations of the current subject matter can be based on a graph data-model of connected business objects (BO) or other data objects and can be designed as an efficient query language embedded into the business application programming language runtime, thereby allowing expression of business logic in a declarative manner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098546&OS=09098546&RS=09098546
owner: SAP SE
number: 09098546
owner_city: Walldorf
owner_country: DE
publication_date: 20121212
---
Ease of consumption and efficient execution of business logic implemented in business software programming languages and based on data retained in complex structured data models e.g. business object models can be key for the optimal performance maintainability and usability in a business software architecture such as for example an enterprise resource planning ERP system.

Business logic in applications supported by business software architectures can in many examples be implemented within a data structure service provider such as for example a business object service provider. A central framework which can be based on a business software programming language such as for example the advanced business application programming or ABAP language can access business objects or other data structures having one or more similar features by calling a generic data structure application programming interface API such as for example a business object API. Reading data can also be an important part of the implementation of any business object or comparable data structure.

Implementations of the current subject matter provide an improved query language that can be used in association with business software architectures. In one aspect a method includes determining at a language layer of a query language architecture a query syntax of a received query and a definition of a result set for the query. Semantics of the received query are checked at a compiler layer of the query language architecture and a field expression corresponding to the result set is read from a data dictionary in a persistent layer of a database from which query results are to be returned. The field expression is built by the compiler level into a query statement. The query including the query statement is executed at a runtime layer of the query language architecture and results to the query are returned per the result set based on execution of the query on the database.

In optional variations one or more additional features can be included in any feasible combination within the scope of the current subject matter. For example the query language architecture can optionally be implemented in a business software programming language as part of a business software architecture. The business software programming language can optionally include an advanced business application programming ABAP language. The query syntax can optionally include use of logical associations to represent connections between entities. The compiler layer of the query language architecture can optionally support a single data model usable on multiple application layers of a multi layer business software architecture. The method can optionally further include pushing logic used in data retrieval for response to the query to a database level from which the query results are returned.

Implementations of the current subject matter can include but are not limited to methods consistent with the descriptions provided herein as well as articles that comprise a tangibly embodied machine readable medium operable to cause one or more machines e.g. computers etc. to result in operations implementing one or more of the described features. Similarly computer systems are also described that may include one or more processors and one or more memories coupled to the one or more processors. A memory which can include a computer readable storage medium may include encode store or the like one or more programs that cause one or more processors to perform one or more of the operations described herein. Computer implemented methods consistent with one or more implementations of the current subject matter can be implemented by one or more data processors residing in a single computing system or multiple computing systems. Such multiple computing systems can be connected and can exchange data and or commands or other instructions or the like via one or more connections including but not limited to a connection over a network e.g. the Internet a wireless wide area network a local area network a wide area network a wired network or the like via a direct connection between one or more of the multiple computing systems etc.

The details of one or more variations of the subject matter described herein are set forth in the accompanying drawings and the description below. Other features and advantages of the subject matter described herein will be apparent from the description and drawings and from the claims. While certain features of the currently disclosed subject matter are described for illustrative purposes in relation to an enterprise resource software system or other business software solution or architecture it should be readily understood that such features are not intended to be limiting. The claims that follow this disclosure are intended to define the scope of the protected subject matter.

Implementations of the current subject matter can provide an easy to use powerful query interface that can be used for database related data retrieval tasks performed in a relational database system based on a business software programming language such as for example the advanced business application programming language ABAP implementations of the current subject matter can also be used with any database that can be queried by SQL as the query interface is independent of the underlying storage model. Consistent with implementations of the current subject matter performance can be improved by minimizing a number of application layers involved in query execution and data retrieval and by pushing down more logic to the relational database. A query interface having one or more of the features discussed below is referred to herein as an advanced business query language ABQL .

An ABQL consistent with implementations of the current subject matter can be embedded in a business software programming language such as for example the ABAP language. Syntax of queries performed in such an ABQL can therefore be checked by the business software programming language compiler which can support a one data model approach usable on all or at least on multiple application layers for example in a multi layer business software architecture or other complex software architecture. A developer can make use of a language integrated query interface similar to that provided by currently available approaches for example those based on Open SQL or the like. In some examples an ABQL can be used instead of Open SQL. If necessary or desired both query languages could be used side by side as well.

An ABQL can be declarative and SQL like and can allow the use of path expressions to address inter data element associations. Additionally queries can be executed directly on a relational database. In association with a high performance in memory database this approach can provide significant performance improvements. Advanced features such as for example structured query results aggregation ordering and paging can be supported using an ABQL consistent with implementations of the current subject matter.

Static and dynamic invocation of ABQL code can be supported via one or more respective interfaces in an ABQL consistent with implementations of the current subject matter. Static invocation of ABQL code can be important for hand written business software programming language code. Code resulting from static invocation of ABQL code can be relatively easy to use and can be readily checked and prepared at compile time. Dynamic invocation of ABQL code can be useful for frameworks that generate queries at runtime.

Many modern business software systems including but not limited to enterprise resource planning software systems relational database systems or the like can be built upon metadata which is generally defined as data that describes or otherwise provides information about other data. One type of metadata can include information regarding data elements of a data structure upon which a given data element has a dependency. The term data element as used herein can refer to any data format including but not limited to a data object or business object a node or a root node of a data or business object and the like. The term dependency as used herein can refer to any unidirectional relationship between data elements in which a dependent data element accesses data metadata data formats or structures or the like from a depended upon data element.

In general result sets from queries on business objects or other types of data objects or higher level aggregations of data elements can be deep in the sense that they are built on the hierarchies dependencies or other associations between the aggregated data elements. In order to support the efficient processing of those result sets a new ABAP entity called mesh shall be introduced. A mesh can be created by ABQL statements and can be further processed in a ABAP runtime environment.

Derived fields can optionally enhance business objects and other data structures. In other words derived fields can be based on other fields by using expressions. The actual value of a field value can be calculated by evaluating the field expression. Calculated fields can be accessed in an ABQL consistent with implementations of the current subject matter in the same manner as conventional persistent fields. The query language runtime environment can handle evaluating the field s expression before returning the result. An example of a calculated field is the computation of a person s age based on a provided the day of birth. Such information is not generally persisted in the database because it depends on the current date. As a further feature reusable functions can be used within an ABQL and calculated field expressions. Such functions can be defined as their own entities and can be referenced within a calculated fields expression or an ABQL statement.

Query execution in a relational database can also include authority checks. In a conventional approach permission control can typically be checked in the business software programming language e.g. the ABAP language for example after the data has been retrieved from the database. This approach can include a performance penalty because all of the query results are first fetched from the relational database before the result set provided in response to a query request is reduced in size by applying one or more authority check rule to exclude results for which the query originator lacks the appropriate permissions or authority to access.

An ABQL consistent with implementations of the current subject matter can also take into account transactional data currently maintained in a business programming language e.g. in the ABAP language . A mechanism can be provided within the ABQL to also include the state of transactional data in a query result. Transactional data can include data pertaining or relating to day to day business operations. A programmer can define one or more views with ABQL statements. Such views can be used as a data source in other ABQL statements or for building new views.

An ABQL consistent with implementations of the current subject matter can support advanced features for data retrieval such as for example basic searches or fuzzy searches such as are currently available in TREX Tree Regular Expressions for XML paging and the like.

An ABQL consistent with implementations of the current subject matter can improve application performance in general by providing one or more features such as for example pushing down logic e.g. sorting expressions authority checks used in data retrieval to the database level bypassing existing frameworks being efficiently implemented e.g. natively in the kernel of the business software programming language which can optionally be the ABAP language minimizing round trips to the database e.g. by using multi fetch making use of efficient data transfer formats e.g. multiple result sets and the like.

For improved performance as shown in a compiler layer and a runtime layer for an ABQL can be natively implemented in the business software programming language e.g. the ABAP language kernel. Different layers can be involved in statement execution in the business software programming language e.g. ABAP kernel. For example as shown in the diagram illustrating an example ABQL architecture of a language layer a compiler layer a runtime layer and a persistence layer can be included. The persistence layer can advantageously be part of the underlying database e.g. a relational database upon which queries are executed. One or more of the language layer the compiler layer and the runtime layer can be implemented on a computing system or systems that can include one or more programmable processors. As shown in such a system or systems are termed an application server . A database interface can provide necessary adaptation or transformation of commands queries data reads and writes data changes and deletions etc. passed to and from the database .

A language layer can be the user interface for an application programmer and can have as a main part syntax of the business software programming language. Queries can be received at the language layer in the form of queries composed in a semantic modeling language e.g. the semantic application design language or SADL as ad hoc queries as hand written code or the like. The language layer can set the query syntax itself e.g. What is selected and also establish a result set definition e.g. How is the data transferred into the business software programming language . The result set definition can be represented by the INTO clause of the query statement. The example illustrated in the code segment of shows an ABQL statement executing a simple select operation using path expressions. This example illustrates some similarities between an ABQL consistent with implementations of the current subject matter and SQL. As in Open SQL a select in an ABQL can begin with the keyword SELECT.

After the initial keyword the INTO clause follows which specifies the name of the business software programming language variable e.g. an ABAP variable holding the result set. For flat result sets INTO clauses from Open SQL including but not limited to INTO INTO . . . INTO and the like remain valid. A FROM clause typically follows an INTO clause. A business object node or other data structure element can be specified as a source in the FROM clause. As in Open SQL the INTO clause and the FROM clause can be permuted.

A sequence of node clauses can follow the INTO clause and FROM clause. Such node clauses can replace Open SQL SELECT clauses. Like such a SELECT clause the node clauses describe the structure of the result. In the example of only one node clause is shown. For each node in the result set one business object node or other similar data element of a data structure such as a data object or the like as the data source is specified. In the example of the node ROOT in the business object SALES ORDER serves as the data source. The content of each node can be specified by a comma separated list of scalar values.

In the business object that is queried using the example of the root node ROOT is connected by the association of BUYER PARTY to the root node of the business object BUSINESS PARTNER which again is connected to the business object node MAIL. Connections between entities are not represented by SQL style joins but rather by a simplified syntax using logical associations. Generally this coding style can be advantageous for business objects and other rich data structures for example because associations represent the logical relationship between entities and simplify the query language statement an SQL JOIN may be used as in some implementations of the current subject matter as a representation of an association .

The example code segment shown in can select for each sales order the total net and tax amount plus the name of buyer organization and the currently valid mail address. As illustrated in this example above an ABQL consistent with implementations of the current subject matter can provide a path expression syntax to follow the associations between different data elements in data structures such as for example data objects or business objects e.g. between business object nodes . In order to provide an abbreviated syntax an ABQL can include a prefix notation for repeated path expressions with a common prefix. The query in the example code segment of can thus be rewritten as shown in the code segment of .

In a compiler layer consistent with implementations of the current subject matter the query statement can be parsed and semantic checks can be performed. The query statement can be parsed at the compiler layer . As an example the text representation of the query statement can be transformed into a representation which can be used by the runtime layer for efficient statement transformation and execution. At this point the ABQL statement which can be originally presented in a business software programming language e.g. the ABAP language can be rewritten into native SQL statements which can be executed in the database . Associations which are used in ABQL can be transformed into an adequate runtime representation e.g. SQL joins . Authority checks and expressions for calculated fields can also be executed. shows an example code segment of native SQL that can be created by the compiler layer by transforming the ABQL statement shown in the example code segment of to native SQL. The associations in the ABQL query can be replaced as shown in by SQL LEFT OUTER JOINS in the example code segment . The filter condition can be represented in the join condition the ON clause of the second left outer join. Parts of the query that can be inserted for executing authority checks are underlined in the example code segment .

The runtime layer can be responsible for query execution. If the query is dynamic it can require compilation prior to execution. If so the query can be passed to the ABQL compiler layer and some steps that are performed usually at compile time may be executed here e.g. parsing semantic checks etc . If the query is completely dynamic the full compilation is generally done at runtime. If only parts of the query are dynamic e.g. node names or where clause the query could be pre compiled at compile time and the compilation can be completed at runtime when all information is available.

After the query has been prepared it is sent to the database . Depending on the nature of the query native SQL or SQLScript can be used as an implementation language. Native SQL is generally well understood and familiar to users for executing simple select statements. SQLScript can be used for query execution when multiple result sets are retrieved from the database. SQLScript can also be advantageous for implementation of reusable functions such as for example those that are used in ABQL statements directly or within expressions in calculated fields.

The runtime layer can also handle the integration of transactional buffers. In this context the term transactional buffer refers to a memory buffer providing storage for data valid in the current transactional context. In other words the scope of the buffered data can be bound to the current transaction. It can be advantageous to keep track of a data image from which data are requested such that the query can be executed accordingly. As an illustrative example when reading from a transactional data image a transactional buffer can advantageously be taken into account by the runtime layer . Database systems typically support the important properties of atomicity consistency isolation and durability ACID . Transactional buffers can be used to ensure the isolation property.

The persistence layer which can optionally include a data dictionary can contain data stored in the database . For a query language which is aware of business objects the data dictionary can be enriched by additional information such as for example a minimized business object model . In an example a minimized business object model can contain basic definitions of business object nodes optionally including calculated fields associations between the nodes including filter conditions and association valuations and the like.

This information can optionally be maintained in a metadata repository and replicated to the data dictionary which can serve as is the source for metadata during the runtime. Calculated fields can be stored in the data dictionary as well. At query compile time the field expression can be read from the data dictionary and built into the query statement for evaluation at runtime in the database . During query execution the node tables in the database that contain the data for the business object and role based access manager RBAM node tables can be accessed directly.

As described above an ABQL consistent with implementations of the current subject matter can generate a core data model and an ABQL query framework from a metadata repository business object. The core data model referred to in as a minimized business object model can be stored in the data dictionary as a business object structure. Business objects can form a graph of business object nodes connected by directed and attributed edges associations . Such a graph can reflect the structure of an underlying relational entity relationship model. Each node can represent an entity e.g. a table a view etc. and each edge in the graph can corresponds to a relationship between two nodes. Edges can carry arbitrarily complex join conditions between the entities. Each business object node can be mapped to an underlying persistent layer database table or view . Each association can be mapped to a join condition. Data elements in the minimized business object model can be mapped to a target data structure by position.

In the example code segment of inline declarations of ABAP tables e.g. data 1 itab can be made and aliases can be assigned. For example a default can be the name of the last path step e.g. total net amount content content . An escaping mechanism can also be provided e.g. group . The example code segments and of show examples of a simple SELECT operation with a WHERE condition. Literals and ABAP or other business programming language variables can be required to be typed exactly. A literal is a constant value explicitly given as part of a source code such as for example a ABQL SELECT statement. A SQL like WHERE condition can be used and an embedded condition can be supplied in place of the . . . in . For a simple SELECT operation with a WHERE condition the example code segment of shows an example of complex AND OR conditions the example code segment of shows an example of between and like conditions the example code segment of shows an example of In Range Table conditions the example code segment of shows an example of negation of conditions and the example code segment of shows an example of flagging of variables with a colon .

The example code segment of shows an example of an IN TABLE condition. Such a condition which can be similar to a SQL sub query can be used as a filter.

In the example code segments and of the following features are shown declarative use of associations between business object nodes by path expressions buyer company name prefixing of associations by a backslash use of a dash as a component selector and use of path expressions at different places e.g. field list WHERE condition or the like . The example code segment of and the example code segment of illustrate additional features that can appear in element list path expressions of an ABQL consistent with implementations of the current subject matter. A path expression can contain multiple associations and nested conditions e.g. language code D . In an element list all types of associations can be used. The use of to N associations can result in redundant data. The term To N associations refers to set valued association in contrast to single valued associations. An ABQL can be capable of handling the same association with different filter conditions e.g. description . . . with different conditions . Associations in the element list can be translated to left outer joins in SQL. Embedded conditions can be part of the ON condition of the left outer join. An ABQL consistent with implementations of the current subject matter can distinguish between different associations to the same business object node e.g. buyer and seller .

The example code segment of illustrates additional features that can appear in root path expressions of an ABQL consistent with implementations of the current subject matter. Path expressions can also be used to specify the leading business object node e.g. zabq1 sales order root node id so id item . The nested condition i.e. node id so id can reference the node id of the business object node zabq1 sales order root. The WHERE condition can reference the node id of the BO node targeted by the association item.

The example code segment of illustrates additional features that can appear in path prefix expressions of an ABQL consistent with implementations of the current subject matter. A plain list of elements can be integrated into the target structure. A new structure type with the corresponding elements can be created and integrated into the target structure. The example code segment of illustrates additional features that can appear in path expressions in WHERE conditions of an ABQL consistent with implementations of the current subject matter. Path expressions can be used in the WHERE condition on the left side of all comparison operations. Conditions with different path expressions and attributes can be combined arbitrarily.

The example code segments and of and illustrate additional features that can appear in to N associations in WHERE conditions of an ABQL consistent with implementations of the current subject matter. A to N association in the WHERE condition can be prefixed with a quantor e.g. ALL or EXISTS . As an example a SELECT operation can be for all sales orders that contain only items with a delivery period longer than 5. In another example a SELECT operation can designate all sales orders containing at least one item which has a delivery period longer than 5. Existential predicates can be set using the keywords EXISTS and ALL. EXISTS and ALL conditions can be nested and arbitrarily combined with other conditions. Translation of ABQL quantors to native SQL can for example include one or more of the following features EXISTS can map to a SQL Exists e.g. dependent on a sub select ALL can map to a SQL Not Exists e.g. dependent on a subs elect not .

The example code segments and of and illustrate additional features that can appear in nested ALL and EXISTS conditions in an ABQL consistent with implementations of the current subject matter. The example of shows a SELECT operation of sales orders which contain at least one products which neither has a German nor an English description while the example of shows a select of sales orders which only contain products which have a German and English description. This query would return empty sales orders as well. According to Boolean logic sales orders containing no items fulfill the ALL condition. The example of shows a SELECT operation of sales orders which only contain products which have a German and English description and which contain at least one item. In this example the condition node id x 00 is always true.

As a general note conditions in path expressions enclosed in cannot contain nested paths expressions with associations. Cardinality of the result set need not be checked at runtime. If several descriptions with language code D exist no error need be raised. In this case duplicate items can be returned.

Optionally the starting row can be specified for example by STARTING AT ROW . Both elements can be used in combination with an ORDER BY clause.

One or more aspects or features of the subject matter described herein can be realized in digital electronic circuitry integrated circuitry specially designed application specific integrated circuits ASICs field programmable gate arrays FPGAs computer hardware firmware software and or combinations thereof. These various aspects or features can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which can be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device. The programmable system or computing system may include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

These computer programs which can also be referred to as programs software software applications applications components or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the term machine readable medium refers to any computer program product apparatus and or device such as for example magnetic discs optical disks memory and Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor. The machine readable medium can store such machine instructions non transitorily such as for example as would a non transient solid state memory or a magnetic hard drive or any equivalent storage medium. The machine readable medium can alternatively or additionally store such machine instructions in a transient manner such as for example as would a processor cache or other random access memory associated with one or more physical processor cores.

To provide for interaction with a user one or more aspects or features of the subject matter described herein can be implemented on a computer having a display device such as for example a cathode ray tube CRT or a liquid crystal display LCD or a light emitting diode LED monitor for displaying information to the user and a keyboard and a pointing device such as for example a mouse or a trackball by which the user may provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well. For example feedback provided to the user can be any form of sensory feedback such as for example visual feedback auditory feedback or tactile feedback and input from the user may be received in any form including but not limited to acoustic speech or tactile input. Other possible input devices include but are not limited to touch screens or other touch sensitive devices such as single or multi point resistive or capacitive trackpads voice recognition hardware and software optical scanners optical pointers digital image capture devices and associated interpretation software and the like.

The subject matter described herein can be embodied in systems apparatus methods and or articles depending on the desired configuration. The implementations set forth in the foregoing description do not represent all implementations consistent with the subject matter described herein. Instead they are merely some examples consistent with aspects related to the described subject matter. Although a few variations have been described in detail above other modifications or additions are possible. In particular further features and or variations can be provided in addition to those set forth herein. For example the implementations described above can be directed to various combinations and subcombinations of the disclosed features and or combinations and subcombinations of several further features disclosed above. In addition the logic flows depicted in the accompanying figures and or described herein do not necessarily require the particular order shown or sequential order to achieve desirable results. Other implementations may be within the scope of the following claims.

