---

title: Cross-process media handling in a voice-over-internet protocol (VOIP) application platform
abstract: A computer-implemented system is provided that facilitates implementation of a voice-over-IP (VOIP) application. The system includes a host system and a user interface (UI) host process residing on the host system. The system also includes an agent host process residing on the host system which is being configured to process a VOIP call received by one or more VOIP applications executable on the host system. A moniker protocol is utilized for redirection of input and output between a media element which is utilized to render media on a display on the system. The redirection enables media processing to be allocated between the UI host process in the foreground and the agent host process in the background to thereby reduce latency perceived by a user during a VOIP experience.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09191417&OS=09191417&RS=09191417
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09191417
owner_city: Redmond
owner_country: US
publication_date: 20120628
---
Developing voice over Internet protocol VOIP applications to run on mobile phones or other limited resource devices e.g. tablets personal digital assistants presents a number of challenges. These challenges are even greater when the VOIP applications are to scale so that they are operational on low end hardware devices having limited resources as well as high end hardware devices having greater resources particularly when the quality of the VOIP call user experience is to remain relatively high in all cases.

One peculiarity of a mobile phone as a platform for a VOIP application as opposed to a personal computer tablet or the like is that a mobile phone has a pre existing telephony e.g. cellular module already built into it. Thus when developing a VOIP application for a mobile phone issues arise such as switching between different types of calls which do not arise when a personal computer or tablet is used as a platform for the VOIP application. More generally it becomes desirable to integrate the user experience of receiving and placing all types of calls including VOIP calls and cellular or other types of calls that are native to the mobile phone.

Another problem that arises when developing a VOIP application that does not arise with other types of calls native to the mobile phone or other limited resource devices concerns the sharing of hardware resources e.g. processing capability memory among various applications. If for example a user switches to another application while on a VOIP call hardware resources are allocated to the other application which may negatively impact the VOIP call user experience.

A system and method is provided that facilitates the development and operation of original equipment manufacturer OEM and third party VOIP applications on a host system. In some embodiments a platform for running VOIP applications is provided for a mobile e.g. cellular phone that serves as the host system. The platform allows VOIP applications to be developed which scale with the hardware resources of the host system while preserving the quality of the VOIP call user experience on both low end and high end host systems.

In one particular implementation the VOIP platform is partitioned into different processes in order to conserve resources and minimize the impact on battery life. One process implements UI user interface functions and only runs when the UI is being used and the other process implements call processing functionality and runs whenever a VOIP call is in progress. That is a UI host process may run in the foreground while an agent host process runs in the background when the application is not displaying any UI. Thus all of the code in the VOIP application that needs to run in the background will run in the agent host process and all code related to the UI of the VOIP application will run in the UI host process.

In yet another particular implementation in order to further conserve resources and battery life a push client service that is pre existing on the host system may be used to notify the agent host process that an incoming VOIP call is being received. In addition a keep alive agent may be provided for ensuring that the push notification channel used by the push client service remains active as well as for periodically communicating with the cloud service associated with the VOIP application.

In an illustrative embodiment of a VOIP application cross process media handling is realized in which a moniker protocol operates in a foreground application to indicate instances when an input into a media element i.e. a media player object comes from a cross process source. The foreground application is configured to own the responsibility for compositing a foreground application scene using the media element as a placeholder for the rendered output as part of a foreground process e.g. as a UI host process . However the bulk of the processing can be performed as a background process e.g. an agent host process and the application may be arranged to choose between in process or cross process elements so the latency between media transport and presentation is reduced. Advantageously the cross process media handling enables the video aspects to be optionally utilized or delayed in order to support an enhanced VOIP call experience to the user.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Simplified overviews are provided in the present section to help enable a basic or general understanding of various aspects of exemplary non limiting embodiments that follow in the more detailed description and the accompanying drawings. This overview section is not intended however to be considered extensive or exhaustive. Instead the sole purpose of the following embodiment overviews is to present some concepts related to some exemplary non limiting embodiments of the disclosed subject matter in a simplified form as a prelude to the more detailed description of these and various other embodiments of the disclosed subject matter that follow. It is understood that various modifications may be made by one skilled in the relevant art without departing from the scope of the disclosed subject matter. Accordingly it is the intent to include within the scope of the disclosed subject matter those modifications substitutions and variations as may come to those skilled in the art based on the teachings herein.

As used in this application the term host generally refers to a computer or a computer related entity at a specific location on a computer network. Typically a host can comprise a storage component e.g. volatile and non volatile storage and associated software for storage and or execution of data and or instructions a host central processing unit CPU e.g. for controlling the functions of the host according to data and or instructions and a communications component e.g. one or more network devices and associated software for communication with other network components . In addition a location on a network can be described by an IP address. Thus in addition to including such computer related entities as desktop computers laptop computers server computers network attached appliances with computing capability and so on the term host can include for example a tablet personal computer PC device a Smartphone and or a personal digital assistant PDA and so on.

Furthermore as used in this application the terms component process. module system and the like generally refer to a computer related entity either hardware firmware a combination of hardware and software software software in execution firmware middle ware microcode and or any combination thereof. For example a component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration not limitation both an application running on a computing device and the computing device can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. In addition these components can execute from various computer readable media having various data structures stored thereon. The components may communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal . Additionally components of systems described herein may be rearranged and or complemented by additional components in order to facilitate achieving the various aspects goals advantages etc. described with regard thereto and are not limited to the precise configurations set forth in a given figure as will be appreciated by one skilled in the art.

An application is a unit of installation and not a run time entity. It consists of a set of binaries and files installed onto the phone. An application is a security principal and at run time all binaries of an application are loaded only in processes that are running in the security context of the application.

A task is logical unit of functionality in the application model. All applications both first and third party are made up of one or more tasks. A task can be thought of as an entry point into an application.

A task instance is a task that is being executed. A task instance is a run time entity. Task instance is to task as process is to executable file. A task instance can be thought of as a unit of work being done by the application code at run time.

A host is a process that contains one or more task instances of a single application. All host processes for an application run under the security context of the application.

An agent host process is a host process that can only contain background agents. An agent host process may also be referred to as a headless host process.

 VOIP is an acronym for Voice over Internet Protocol. As used herein a VOIP application is an application that enables either voice only or voice and video and or text or other data over the internet.

In those implementations in which the host system is a mobile phone a number of components and services are already available which may be used by the VOIP application platform. These components and services are used to facilitate the provision of cellular phone service and may be extended to additionally facilitate the provision of VOIP services. Three such components and services are shown in .

One service made available by the host system is a phone service which serves as the authority on the state of all calls currently existing on the phone starting ending on hold ringing etc. . It provides the functionality needed to switch between calls and to handle multiple calls at the same time. The phone service also sends out notifications about call states to other interested first party components of the system. It provides application programming interfaces APIs to display the incoming call dialog and to control audio routing for calls which specify for example whether the audio is to be captured or played back from a Bluetooth headset or whether the phone speaker is to be used for call audio output. In addition the phone service in conjunction with the UI shell discussed below is responsible for the display of a minimized call UI when the primary call UI is not in the foreground.

Another set of services and components made available by the host system is the media foundation . The media foundation which may include hardware and software components exposes one or more APIs that can be called by the VOIP application to interact with audio video or other media. For example the media foundation may be thought of as existing at an infrastructure level of software that is executed on the host system. In other words the media foundation is a software layer used by the VOIP application to interact with the media. The media foundation may be utilized to control a number of aspects of the media such as output rendering storage and so on. Thus the media foundation may be utilized such that each application does not have to implement separate code for each type of media that may be used in the system. In this way the media foundation provides a set of reusable software components to do media specific tasks.

In particular the media foundation primarily provides the audio and video capture and playback APIs for use by the active call agent instance. In the media foundation includes a video playback component a video capture component an audio capture component and an audio playback component which respectively communicate with the display surface camera microphone and speaker of the host system. Its video playback pipeline allows the agent host process to output a raw or hardware decoded H.264 incoming video stream directly to a surface created by the UI host process with the minimum number of buffer copies. In this way displaying video that is being rendered by the agent host process will be as efficient as rendering it from the UI host process .

The execution model is another pre existing component of the host system which can be used to provide APIs to launch and control instances of the various types of VOIP agents described herein. A subcomponent of the execution model referred to as the resource manager may also be responsible for the management and allocation of resources e.g. CPU memory access to devices etc. used by the UI and agent host processes of the VOIP applications. The execution model can multiplex the resource utilization by various applications running on the host system so as to optimize the overall resource utilization. For example the execution model can reallocate resources used by instances of a background audio playback agent to an active call agent instance since there is no need to play music when a phone call is in progress. The execution model may also provide scheduling logic to initiate background activity in a battery friendly manner. For instance keep alive agent instances may be scheduled together with generic background agents in order to minimize the amount of time the network radios are active.

With continuing reference to execution of the VOIP application platform is divided into two primary processes a UI host process and an agent host process . The UI host process runs in the foreground while the agent host process runs in the background when the application is not displaying any UI. Thus all of the code in the VOIP application that needs to run in the background will run in the agent host process and all code related to the UI of the VOIP application will run in the UI host process . Generally the background process is always running to ensure that there are no dropped calls.

Background or headless execution of VOIP application code is employed for several reasons. First as discussed below background execution allows keep alive messages to be periodically sent to the appropriate VOIP server. Background notification also allows incoming call notifications to be processed. While processing incoming call notifications the application that is currently in the foreground is not interrupted. The VOIP application may display the UI only if the user accepts the incoming call. If the user declines the call the current foreground application continues without interruption. Background execution is also employed to process a VOIP call that is in progress when the VOIP application UI is not in the foreground. This scenario can occur either when the user accepts an incoming VOIP call and the screen is locked i.e. a state in which at least some normally user accessible functions of the device are not user accessible or when the user navigates away from the VOIP application UI in the middle of a VOIP call.

The partitioning of the VOIP application platform into two primary processes is advantageous for a number of reasons. In particular this arrangement facilitates the implementation of VOIP applications on lower end resource limited devices because each process can run only when necessary thereby avoiding the need to have one large process consuming resources at all times. For instance the UI host process will generally consume substantially more resources than the agent host process in order to handle UI functions such as the rendering of surfaces buttons and the like as well as the rendering of video. The UI host process is only executed when in the foreground since otherwise it is not being utilized. For instance when the user switches away e.g. places on hold from a VOIP call that is in progress to accept a cellular call or access another application for instance the UI host process may be terminated. The agent host process on the other hand is generally a much smaller process that consumes fewer resources than the UI host process . The agent host process is not terminated even if the UI host process is terminated. Moreover in some cases the foreground process may sponsor memory to the background process thus reducing the size of the background process unless necessary.

The agent host process runs whenever the VOIP application is to operate in the background. That is the agent host process runs whenever any agent instance is running in it. In particular the agent host process runs for the duration of a VOIP call as well as generally whenever the UI host process is running in the foreground. Among other things code runs in the agent host process which is responsible for communicating with the VOIP service . All communication with the VOIP service occurs from the agent host process even when the UI host process is in the foreground. The agent host process also captures video from the camera if available in the platform and renders it directly into the camera s preview surface which is created by the UI host process . Likewise the agent host process also decodes incoming video and renders it directly into an incoming video surface created by the UI host process . The agent host process also captures and encodes outgoing audio from the pertinent audio input device and receives decodes and plays back incoming audio to the pertinent audio output device. It should be noted that there is no audio or video data being transferred between the UI host process and the agent host process .

As shown in the agent host process includes a keep alive agent an incoming call agent a communication agent and an active call agent . The agents essentially serve as an entry point that is invoked by the execution model to perform different types of work. Each of these agents will be described in turn.

The purpose of the keep alive agent is two fold. First it periodically informs the VOIP cloud service that this endpoint is still connected. For example this agent can be used to renew any authorization tokens that the VOIP cloud service may have issued to this particular endpoint. Second the keep alive agent ensures that the push notification channel discussed below over which incoming call notifications are sent is still active. If not it creates a new push notification channel and registers it with the background scheduling service discussed below and with its own cloud service. In order to conserve resources and battery life the keep alive agent is small and lightweight it starts performs its operation and shuts down quickly.

The purpose of the incoming call agent is to receive information about an incoming VOIP call. In response the incoming call agent requests the phone service to display the incoming call dialog box appropriately customized with information about the incoming call.

An instance of the incoming call agent is launched or otherwise started by the background scheduling service when it receives a push notification on the notification channel previously registered by the VOIP application for this purpose. The incoming call agent is generally small and lightweight it is expected to start as soon as possible upon receipt of an incoming VOIP call retrieve information about the incoming call from the incoming push notification or the VOIP cloud service and request the phone service to display the incoming call dialog box. If the incoming call agent does not request the phone service to display the incoming call dialog box within a specified amount of time e.g. 5 seconds of being started it may be canceled. If the user declines the call the incoming call agent is shut down by the execution model.

If the user accepts the call the incoming call agent requests the phone service to start a call. The phone service in turn requests the execution model to start an active call agent instance to handle the new call. The execution model starts the active call agent instance in the same agent host process as the incoming call agent instance. The execution model then requests the incoming call agent instance to shut down. The agent host process then continues to run with the active call agent instance inside it.

The incoming call agent instance briefly shares its host process with the active call agent instance that is requested if any. This is significant because the incoming call agent instance may have state information e.g. open sockets to its service call routing information etc. that it wishes to share with the nascent active call agent instance having both instances share the same process makes this sharing easier.

The purpose of the active call agent is to perform the functionality used during a VOIP call both when the UI of the VOIP application is in the foreground and when it is not. In the former case the active call agent processes both video and audio information and in the latter it processes only audio information. An instance of this agent is started by the phone service when a VOIP call is started. A call can be started either by an incoming call agent instance when the user accepts an incoming call or by the communication agent instance when the user initiates an outgoing call from the VOIP application UI .

The active call agent may continuously communicate with the VOIP cloud service to send and receive audio video streams and call control information. It communicates with the phone service to deliver notifications about call status and to receive call control commands for instance commands to put the call on hold when accepting another call or commands to end the call . The active call agent uses media foundation APIs to 

Video capture and playback is performed only if the UI task instance of the VOIP application is in the foreground.

VOIP applications sometimes need to communicate with their affiliated cloud service to retrieve data for the UI even when there is no VOIP call in progress. For example the VOIP application may be requested to display a list of contacts in its UI and would therefore need to communicate with its cloud service to retrieve this list. However many VOIP applications are not resilient to having multiple instances of their communication libraries coexisting at runtime. Instantiating its communication library in the UI process and then again in the agent process would violate this constraint. To solve this problem the communication agent can be used. An instance of this agent can be launched directly by the UI task instance of the VOIP application. The UI task instance can then communicate with the VOIP application s cloud service via the communication agent instance thereby avoiding the problem of having to instantiate the communication library in both the UI and the agent host processes. The communication agent instance of a VOIP application if any is shut down by the execution model as soon as the UI task instance of the application goes out of the foreground.

The UI task instance contains the UI used to initiate and control VOIP calls. The UI task instance also displays incoming video and video capture previews from the camera. When a VOIP call is in progress the UI task instance communicates with the active call agent instance to deliver call control commands. It also creates two surfaces one for the active call agent to render the incoming video stream into and another for the camera driver to render the capture preview into.

The UI task host functions to render content from input that is provided to it. Managed application code incorporates the UI Host process of and executes within an application framework such as Microsoft Silverlight which includes an application domain such as Microsoft s common language runtime CLR . The UI task host may also include native application code an execution manager client and a runtime environment such as the Windows Runtime WinRT Platform to communicate with other processes.

The headless host functions to transport and track content. Managed application code incorporates the agent host process of and executes within an application framework such as Microsoft Silverlight which includes an application domain such as Microsoft s common language runtime CLR . The headless host also includes native application code an execution manager client and a runtime environment such as the Windows Runtime WinRT Platform to communicate with other processes. In some implementations the headless host is generally given access on a priority basis to system resources in order to preserve call quality. Resources are allocated to the processes based on the state of the phone at any given time. In other words all processes except for those incorporated in the headless host can be compromised if resources are limited.

The background scheduling service BSS and the package manager together maintain information concerning the rules that are to be applied for launching the keep alive and incoming call agents within each VOIP application. The BSS is responsible for initiating the launch of keep alive agent after every device reboot and periodically thereafter. The BSS also operates in conjunction with the push client service to launch incoming call agents. In particular the BSS and package manager provide and implement APIs to enable and disable the launching of the keep alive and incoming call agents upon the occurrence of various events. For instance the user may disable these agents. In addition the launching of these agents may be disabled if the VOIP application s license is revoked or the VOIP application is uninstalled. Likewise the launching of these agents may be enabled when the VOIP application s license is granted.

The push client service is used to notify the incoming call agent that an incoming VOIP call is being received. The push client service is generally pre existing on the host system and listens for push notifications received by various applications such as e mail applications and the like. The pre existing service also includes a registration mechanism which allows the push client service to begin running the appropriate application e.g. the VOIP application . In this way each VOIP application running on a host system does not need to listen for its own incoming VOIP calls. Rather a single component that implements the push client service listens for all incoming VOIP calls and upon receipt dispatches them to the appropriate application. As discussed above the keep alive agent is responsible for ensuring that the push notification channel remains active.

The navigation model provides events that inform the phone service when the UI of a VOIP application enters or leaves the foreground. These notifications are used by the phone service to hide or show the minimized call UI. The navigation model also provides APIs to the phone service to launch the VOIP application UI.

The illustrated mobile device can include a controller or processor e.g. signal processor microprocessor ASIC or other control and processing logic circuitry for performing such tasks as signal coding data processing input output processing power control and or other functions. An operating system OS can control the allocation and usage of the components including power states above lock states and below lock states and provide support for one or more application programs . The application programs can include common mobile computing applications e.g. image related applications email applications calendars contact managers web browsers messaging applications or any other computing application.

The illustrated mobile device can include memory . Memory can include non removable memory and or removable memory . The non removable memory can include RAM ROM flash memory a hard disk or other well known memory storage technologies. The removable memory can include flash memory or a Subscriber Identity Module SIM card which is well known in GSM communication systems or other well known memory storage technologies such as smart cards. The memory can be used for storing data and or code for running the operating system and the application programs . Example data can include web pages text images sound files video data or other data sets to be sent to and or received from one or more network servers or other devices via one or more wired or wireless networks. The memory can be used to store a subscriber identifier such as an International Mobile Subscriber Identity IMSI and an equipment identifier such as an International Mobile Equipment Identifier IMEI . Such identifiers can be transmitted to a network server to identify users and equipment.

The mobile device can support one or more input devices for responding to inputs from users and other sources. Such input devices may include a touch screen microphone camera physical keyboard trackball and or proximity sensor and one or more output devices such as a speaker and one or more displays . Other possible output devices not shown can include piezoelectric or haptic output devices. Some devices can serve more than one input output function. For example touch screen and display can be combined into a single input output device.

In some implementations the various input devices may support natural user interface NUI methods. Examples of NUI methods include those relying on speech recognition touch and stylus recognition gesture recognition both on screen and adjacent to the screen air gestures head and eye tracking voice and speech vision touch gestures and machine intelligence. Specific categories of NUI technologies on which Microsoft is working include touch sensitive displays voice and speech recognition intention and goal understanding motion gesture detection using depth cameras such as stereoscopic camera systems infrared camera systems red green blue camera systems and combinations of these motion gesture detection using accelerometers gyroscopes facial recognition 3D displays head eye and gaze tracking immersive augmented reality and virtual reality systems all of which provide a more natural interface as well as technologies for sensing brain activity using electric field sensing electrodes EEG and related methods .

A wireless modem can be coupled to an antenna not shown and can support two way communications between the processor and external devices as is well understood in the art. The modem is shown generically and can include a cellular modem for communicating with the mobile communication network and or other radio based modems e.g. Bluetooth or Wi Fi . The wireless modem is typically configured for communication with one or more cellular networks such as a GSM network for data and voice communications within a single cellular network between cellular networks or between the mobile device and a public switched telephone network PSTN .

The mobile device can further include at least one input output port a power supply a satellite navigation system receiver such as a Global Positioning System GPS receiver an accelerometer a gyroscope not shown and or a physical connector which can be a USB port IEEE 1394 FireWire port and or RS 232 port. The illustrated components are not required or all inclusive as any components can be deleted and other components can be added.

The architecture is arranged in layers and includes a VOIP application layer an OS layer and a hardware layer . The hardware layer typically provides an abstraction of the various hardware used by the host system e.g. input and output devices networking hardware etc. to the layers above it.

A media transport and presentation functionality executes in the VOIP application layer using a foreground application that is operative with background processes . The foreground application can typically be implemented using a UI host process as described above in text accompanying while the background processes may be implemented as agent host processes. As shown in the foreground application handles the task of compositing video for display in the UI as indicated by reference numeral . The background processes implement the tasks of video decoding playback and synchronization as respectively indicated by reference numerals and . It is emphasized that these particular tasks are illustrative and that other tasks can also be performed and allocated between in processing and cross processing as may be needed to meet the requirements of a particular VOIP scenario.

The choice between in process and cross process media handling is made using a dummy moniker that is implemented in the foreground application as described in more detail below so that media transport and presentation is optimized to be as close as possible to minimize the latency perceived by the end user during a VOIP call experience.

For the case of input from a cross process element referring back to the foreground application relies on a texture that is shared across all of the processes and via a shared handle as representatively indicated by reference numeral . Although the texture is populated by the processes the foreground application maintains ownership for compositing the texture into the foreground application scene as a foreground i.e. UI host process.

In the second process a media engine in response to instructions not shown in received from the third process which contain either raw or decoded video frames pumps audio and video into the texture using the shared handle as a background process. Here the media engine typically executes user code as a component of a Silverlight implementation for example when drawing video frames into the texture as an agent host i.e. background process.

The third process is executed in a media pipeline which populates data into the texture through the shared handle . The third process operates as the master process that initiates transactions with the other processes and receives media packets from the VOIP service decodes the packets renders audio to an appropriate audio device and sends decoded streams to the media engine for use in the second process .

At block the media pipeline receives packets from the VOIP service in a single UI less process and will typically decode the received packets. The media pipeline also separately renders audio so that audio response is quickened without blocking from the video processing. The decoding can be performed in software through an interface to the hardware layer or using a combination of software and hardware. At block the media pipeline sends instructions responsively to a call at block from the media engine . The instructions can comprise either raw or decoded video frames. The instructions are continuously sent as streams to the media engine as packets are received and decoded by the media pipeline . The media engine then draws the received data into the shared texture at block .

The claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter. For instance the claimed subject matter may be implemented as a computer readable storage medium embedded with a computer executable program which encompasses a computer program accessible from any computer readable storage device or storage media. For example computer readable storage media can include but are not limited to magnetic storage devices e.g. hard disk floppy disk magnetic strips . . . optical disks e.g. compact disk CD digital versatile disk DVD . . . smart cards and flash memory devices e.g. card stick key drive . . . . However computer readable storage media do not include transitory forms of storage such as propagating signals for example. Of course those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

