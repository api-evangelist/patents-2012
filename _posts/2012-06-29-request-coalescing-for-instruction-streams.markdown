---

title: Request coalescing for instruction streams
abstract: Sequential fetch requests from a set of fetch requests are combined into longer coalesced requests that match the width of a system memory interface in order to improve memory access efficiency for reading the data specified by the fetch requests. The fetch requests may be of different classes and each data class is coalesced separately, even when intervening fetch requests are of a different class. Data read from memory is ordered according to the order of the set of fetch requests to produce an instruction stream that includes the fetch requests for the different classes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09395997&OS=09395997&RS=09395997
owner: NVIDIA CORPORATION
number: 09395997
owner_city: Santa Clara
owner_country: US
publication_date: 20120629
---
This application is continuation of co pending U.S. patent application Ser. No. 11 688 480 filed Mar. 20 2007 now U.S. Pat. No. 8 219 786 which is herein incorporated by reference in its entirety.

The present invention generally relates to reading data from memory and more specifically to a system and method for coalescing sequential fetch requests for a data class that are interleaved with fetch requests for other data classes.

Current data processing includes systems and methods developed to read data from memory efficiently. Typically a cache is used to store data that is read from memory in portions sized based on the memory interface. A cache is particularly well suited to improve memory access efficiency when series of small memory reads fetches are in sequence. When the first fetch is completed a portion of the following fetch in the sequence is available in the cache since reading the small first fetch also read some of the adjacent memory locations that are needed for a part of the second fetch. A cache is not a good solution when the data for the second fetch is not present in memory when the data for the first fetch is read. In that case the cache stores the incorrect data for the part of the second fetch. In systems where the memory writes can be snooped the cache entry can be updated or invalidated when a corresponding memory write occurs in order to maintain cache coherency. However when the memory writes cannot be snooped it is not possible to determine whether or not the data for the part of the second fetch that is stored in the cache is correct.

Accordingly what is needed in the art is a system and method for performing a sequence of fetches from memory when a cache cannot be used to improve memory access efficiency.

One advantage of the disclosed system is that sequential fetch requests from a set of fetch requests are combined into longer coalesced requests that match the width of a system memory interface in order to improve memory access efficiency for reading the data specified by the fetch requests. Coalesced requests that exceed the system memory interface width may be read in bursts. Another advantage of the disclosed system and method is that the fetches are performed after the data is available in the memory. Therefore the data is correct and there is no need to maintain cache coherence by snooping memory writes. The fetch requests may be for different data classes and each data class is coalesced separately even when intervening fetch requests are of a different class. Data read from memory is ordered according to the order of the set of fetch requests to produce an instruction stream that includes the fetch requests for the different data classes.

Various embodiments of a method of the invention for coalescing fetch requests for multiple data classes include receiving a first fetch request for a first data class receiving a second fetch request for a second data class receiving a third fetch request for the first data class that is sequential to the first fetch request. The first fetch request and the third fetch request are combined to produce a coalesced fetch request for the first data class. First data specified by the coalesced fetch request is fetched from a memory and second data specified by the second fetch request is fetched from the memory. An instruction stream is output that includes the first data and the second data ordered according to the first fetch request the second fetch request and the third fetch request.

Various embodiments of the invention for coalescing fetch requests for multiple data classes include an instruction stream FIFO first in first out memory a memory and a coalesce unit. The instruction stream FIFO is configured to store the fetch requests in entries wherein fetch requests for different data classes are interleaved. The memory is configured to store data and instructions that are read when coalesced fetch requests are fulfilled. The coalesce unit is coupled to the memory and configured to read the entries of the instruction stream FIFO combine fetch requests of a same data class that are stored in sequential locations in a memory to produce coalesced fetch requests read data corresponding to the coalesced fetch requests from the memory and order the data according to an order of the fetch requests stored in the entries of the instruction stream FIFO to produce an instruction stream.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

A system disk is also connected to I O bridge . A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including USB or other port connections CD drives DVD drives film recording devices and the like may also be connected to I O bridge . Communication paths interconnecting the various components in may be implemented using any suitable protocols such as PCI Peripheral Component Interconnect PCI Express PCI E AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

An embodiment of parallel processing subsystem is shown in . Parallel processing subsystem includes one or more parallel processing units PPUs each of which is coupled to a local parallel processing PP memory . In general a parallel processing subsystem includes a number U of PPUs where U 1. Herein multiple instances of like objects are denoted with reference numbers identifying the object and parenthetical numbers identifying the instance where needed. PPUs and PP memories may be implemented e.g. using one or more integrated circuit devices such as programmable processors application specific integrated circuits ASICs and memory devices.

As shown in detail for PPU each PPU includes a host interface that communicates with the rest of system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. Host interface generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path and directs them to appropriate components of PPU . For example commands related to processing tasks may be directed to a front end unit while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a memory interface . Front end unit and memory interface may be of generally conventional design and a detailed description is omitted as not being critical to the present invention. Host interface includes a coalesce unit that obtains fetch requests from device driver that specify instructions and or data stored in a push buffer within PP memory . Coalesce unit combines the specified fetch requests to read data from push buffer . Coalesce unit may reorder the specified fetch requests when they are combined. After receiving the data for the combined fetch requests from push buffer via communication path the data may be saved and reordered. This reordering of the data is performed in a manner such that is the data appears in the same order in the instruction stream as if the specified fetch requests had not been reordered. Coalesce unit then outputs the data including program instructions and data for processing as the instruction stream to front end . The data read from a push buffer includes data and or program instructions.

Each PPU advantageously implements a highly parallel processor. As shown in detail for PPU a PPU includes a number C of cores where C 1. Each processing core is capable of executing a large number e.g. tens or hundreds of threads concurrently where each thread is an instance of a program one embodiment of a multithreaded processing core is described below. Cores receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from a front end unit . Work distribution unit can implement a variety of algorithms for distributing work. For instance in one embodiment work distribution unit receives a ready signal from each core indicating whether that core has sufficient resources to accept a new processing task. When a new processing task arrives work distribution unit assigns the task to a core that is asserting the ready signal if no core is asserting the ready signal work distribution unit holds the new processing task until a ready signal is asserted by a core . Those skilled in the art will recognize that other algorithms may also be used and that the particular manner in which work distribution unit distributes incoming processing tasks is not critical to the present invention.

Cores communicate with memory interface to read from or write to various external memory devices. In one embodiment memory interface includes an interface adapted to communicate with local PP memory as well as a connection to host interface thereby enabling the cores to communicate with system memory or other memory that is not local to PPU . Memory interface can be of generally conventional design and a detailed description is omitted.

Cores can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local PP memories into internal on chip memory process the data and write result data back to system memory and or local PP memories where such data can be accessed by other system components including e.g. CPU or another parallel processing subsystem .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local PP memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments PP subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated PP memory device s or no dedicated PP memory device s .

In operation CPU is the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments device driver writes a stream of commands for each PPU to a push buffer such as push buffer or which may be located in system memory PP memory or another storage location accessible to both CPU and PPU . Coalesce unit reads data and program instructions for the instruction stream from the push buffer using fetch requests provided by device driver in an instruction stream segment pointer FIFO . PPU executes the program instructions from the instruction stream asynchronously with operation of CPU .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of PPU to the rest of system may also be varied. In some embodiments PP system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

A PPU may be provided with any amount of local PP memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment in such embodiments little or no dedicated graphics PP memory is provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory e.g. via a bridge chip.

As noted above any number of PPUs can be included in a parallel processing subsystem. For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of the PPUs could be integrated into a bridge chip. The PPUs in a multi PPU system may be identical to or different from each other for instance different PPUs might have different numbers of cores different amounts of local PP memory and so on. Where multiple PPUs are present they may be operated in parallel to process data at higher throughput than is possible with a single PPU.

Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and so on.

In one embodiment each core includes an array of P e.g. 8 16 etc. parallel processing engines configured to receive SIMD instructions from a single instruction unit . Each processing engine advantageously includes an identical set of functional units e.g. arithmetic logic units etc. . The functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

Each processing engine uses space in a local register file LRF for storing its local input data intermediate results and the like. In one embodiment local register file is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each processing engine and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. In some embodiments each processing engine can only access LRF entries in the lane assigned to it. The total number of entries in local register file is advantageously large enough to support multiple concurrent threads per processing engine .

Each processing engine also has access to an on chip shared memory that is shared among all of the processing engines in core . Shared memory may be as large as desired and in some embodiments any processing engine can read to or write from any location in shared memory with equally low latency e.g. comparable to accessing local register file . In some embodiments shared memory is implemented as a shared register file in other embodiments shared memory can be implemented using shared cache memory.

In addition to shared memory some embodiments also provide additional on chip parameter memory and or cache s which may be implemented e.g. as a conventional RAM or cache. Parameter memory cache can be used e.g. to hold state parameters and or other data e.g. various constants that may be needed by multiple threads. Processing engines also have access via memory interface to off chip global memory which can include e.g. PP memory and or system memory with system memory being accessible by memory interface via host interface as described above. It is to be understood that any memory external to PPU may be used as global memory . Processing engines can be coupled to memory interface via an interconnect not explicitly shown that allows any processing engine to access global memory .

In one embodiment each processing engine is multithreaded and can execute up to some number G e.g. 24 of threads concurrently e.g. by maintaining current state information associated with each thread in a different portion of its assigned lane in local register file . Processing engines are advantageously designed to switch rapidly from one thread to another so that instructions from different threads can be issued in any sequence without loss of efficiency.

Instruction unit is configured such that for any given processing cycle the same instruction INSTR is issued to all P processing engines . Thus at the level of a single clock cycle core implements a P way SIMD microarchitecture. Since each processing engine is also multithreaded supporting up to G threads concurrently core in this embodiment can have up to P G threads executing concurrently. For instance if P 16 and G 24 then core supports up to concurrent threads.

Because instruction unit issues the same instruction to all P processing engines in parallel core is advantageously used to process threads in SIMD thread groups. As used herein a SIMD thread group refers to a group of up to P threads of execution of the same program on different input data with one thread of the group being assigned to each processing engine . A SIMD thread group may include fewer than P threads in which case some of processing engines will be idle during cycles when that SIMD thread group is being processed. A SIMD thread group may also include more than P threads in which case processing will take place over consecutive clock cycles. Since each processing engine can support up to G threads concurrently it follows that up to G SIMD thread groups can be executing in core at any given time.

On each clock cycle one instruction is issued to all P threads making up a selected one of the G SIMD thread groups. To indicate which thread is currently active an active mask for the associated thread may be included with the instruction. Processing engine uses the active mask as a context identifier e.g. to determine which portion of its assigned lane in local register file should be used when executing the instruction. Thus in a given cycle all processing engines in core are nominally executing the same instruction for different threads in the same SIMD thread group. In some instances some threads in a SIMD thread group may be temporarily idle e.g. due to conditional or predicated instructions divergence at branches in the program or the like. 

Operation of core is advantageously controlled via a core interface . In some embodiments core interface receives data to be processed e.g. primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed from work distribution unit . Core interface can load data to be processed into shared memory and parameters into parameter memory . Core interface also initializes each new thread or SIMD thread group in instruction unit then signals instruction unit to begin executing the threads. When execution of a thread or SIMD thread group is completed core advantageously notifies core interface . Core interface can then initiate other processes e.g. to retrieve output data from shared memory and or to prepare core for execution of additional threads or SIMD thread groups.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing engines may be included. In some embodiments each processing engine has its own local register file and the allocation of local register file entries per thread can be fixed or configurable as desired. Further while only one core is shown a PPU may include any number of cores which are advantageously of identical design to each other so that execution behavior does not depend on which core receives a particular processing task. Each core advantageously operates independently of other cores and has its own processing engines shared memory and so on.

In some embodiments multithreaded processing core of can execute general purpose computations using thread arrays. As used herein a thread array is a group consisting of a number n of threads that concurrently execute the same program on an input data set to produce an output data set. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

In some embodiments the thread arrays are cooperative thread arrays or CTAs. As with other types of thread arrays a CTA is a group of multiple threads that concurrently execute the same program referred to herein as a CTA program on an input data set to produce an output data set. In a CTA the threads can cooperate by sharing data with each other in a manner that depends on thread ID. For instance in a CTA data can be produced by one thread and consumed by another. In some embodiments synchronization instructions can be inserted into the CTA program code at points where data is to be shared to ensure that the data has actually been produced by the producing thread before the consuming thread attempts to access it. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program.

In some embodiments threads in a CTA share input data and or intermediate results with other threads in the same CTA using shared memory of . For example a CTA program might include an instruction to compute an address in shared memory to which particular data is to be written with the address being a function of thread ID. Each thread computes the function using its own thread ID and writes to the corresponding location. The address function is advantageously defined such that different threads write to different locations as long as the function is deterministic the location written to by any thread is predictable. The CTA program can also include an instruction to compute an address in shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA.

CTAs or other types of thread arrays are advantageously employed to perform computations that lend themselves to data parallel decomposition. As used herein a data parallel decomposition includes any situation in which a computational problem is solved by executing the same algorithm multiple times in parallel on input data to generate output data for instance one common instance of data parallel decomposition involves applying the same processing algorithm to different portions of an input data set in order to generate different portions an output data set. Examples of problems amenable to data parallel decomposition include matrix algebra linear and or nonlinear transforms in any number of dimensions e.g. Fast Fourier Transforms and various filtering algorithms including convolution filters in any number of dimensions separable filters in multiple dimensions and so on. The processing algorithm to be applied to each portion of the input data set is specified in the CTA program and each thread in a CTA executes the same CTA program on one portion of the input data set. A CTA program can implement algorithms using a wide range of mathematical and logical operations and the program can include conditional or branching execution paths and direct and or indirect memory access.

For example as is known in the art an array of data values e.g. pixels can be filtered using a 2 D kernel based filter algorithm in which the filtered value of each pixel is determined based on the pixel and its neighbors. In some instances the filter is separable and can be implemented by computing a first pass along the rows of the array to produce an intermediate array then computing a second pass along the columns of the intermediate array. In one CTA implementation of a separable 2 D filter the threads of the CTA load the input data set or a portion thereof into shared memory then synchronize. Each thread performs the row filter for one point of the data set and writes the intermediate result to shared memory . After all threads have written their row filter results to shared memory and have synchronized at that point each thread performs the column filter for one point of the data set. In the course of performing the column filter each thread reads the appropriate row filter results from shared memory and a thread may read row filter results that were written by any thread of the CTA. The threads write their column filter results to shared memory . The resulting data array can be stored to global memory or retained in shared memory for further processing. Where shared memory can be accessed with lower latency and or greater bandwidth than global memory storing intermediate results in shared memory advantageously improves processor throughput.

In one embodiment device driver executing on CPU of writes instructions defining the CTA to a push buffer or from which the instructions are read by a PPU . The instructions advantageously are associated with state parameters such as the number of threads in the CTA the location in global memory of an input data set to be processed using the CTA the location in global memory of the CTA program to be executed and the location in global memory where output data is to be written. The state parameters may be written to push buffer or together with the instructions. In response to the instructions core interface loads the state parameters into core e.g. into parameter memory then begins launching threads until the number of threads specified in the CTA parameters have been launched. In one embodiment core interface assigns thread IDs sequentially to threads as they are launched. More generally since all threads in a CTA execute the same program in the same core any thread can be assigned any thread ID as long as each valid thread ID is assigned to only one thread. Any unique identifier including but not limited to numeric identifiers can be used as a thread ID. In one embodiment if a CTA includes some number n of threads thread IDs are simply sequential one dimensional index values from 0 to n 1. In other embodiments multidimensional indexing schemes can be used. It should be noted that as long as data sharing is controlled by reference to thread IDs the particular assignment of threads to processing engines will not affect the result of the CTA execution. Thus a CTA program can be independent of the particular hardware on which it is to be executed.

Sequential entries of the same data class may be combined to form a coalesced fetch request. For example entry and entry can be combined to form a coalesced fetch request with a start address of 0x00000000 and length of 0x710. Reading the single coalesced fetch request from memory may be more efficient than reading separate fetch requests for entry and . Typically memory subsystems are more efficient when they are accessed at the full width of the memory and in a burst that begins on a particular alignment and continues for a particular burst length. If the requests to the memory subsystem are less than this ideal multiple memory accesses may be required causing a loss of memory bandwidth efficiency. For example if not reordered the sequence of fetches for entries may be inefficient since the fetch for may be smaller than the optimal memory fetch and the fetch for may not meet the alignment requirements. By coalescing fetches and memory efficiency may be increased. Persons skilled in the art however will understand that perhaps only a first portion of the request can be combined with request to fulfill the memory efficiency requirements and the remainder of fetch can be done after fetching .

Different portions of a push buffer may be written at different times. For example the data corresponding to entry may be written before the data corresponding to entry is written. Therefore using a cache to improve memory bandwidth utilization may result in incorrect data for entry if care is not taken when determining when fetches can be made for more data than was specified by their entries in instruction stream segment pointer FIFO or . Specifically if a portion of the data for entry is read and cached when the data for entry is fetched that portion of data for entry may not be correct since it may not have been written in the push buffer. Once an entry is written in instruction stream segment pointer FIFO the data is guaranteed to be present in the push buffer for the fetch request.

An alternative to coalescing the fetch requests is to copy the subroutines in memory to construct a push buffer with the data stored in sequential entries. Such a push buffer can be read efficiently without even needing a cache since the data is read and output in a linear order. A disadvantage of the alternative is that the data must be copied within memory to construct the linear push buffer so the memory bandwidth that is saved fetching the linear push buffer may not be greater than the memory bandwidth that is needed to create the linear push buffer.

Mainline registers and subroutine registers are used by coalesce controller to unroll generate and then store coalesced fetch requests as described in conjunction with . In some embodiments of the present invention mainline registers and subroutine registers each include 8 registers to store 8 coalesced fetch requests. An instruction stream controller reads coalesced fetch requests from mainline registers and subroutine registers and outputs the coalesced requests to fetch unit in order to read the data specified by each coalesced fetch request as described in conjunction with . Fetch unit tracks the data class for each fetch request and returns the read data to a FIFO corresponding to the data class. Mainline data is returned to a mainline FIFO and subroutine data is returned to a subroutine FIFO . In some embodiments of the present invention mainline FIFO and subroutine FIFO are each 64 or 128 bits wide. When data is available in mainline FIFO or subroutine FIFO instruction stream controller pops a fetch request from second local FIFO and reads data corresponding to the fetch request at the output of mainline FIFO or subroutine FIFO as described in conjunction with . Instruction stream controller orders the fetched data read from mainline FIFO and subroutine FIFO according to the entries popped from second local FIFO to produce an instruction stream.

If in step coalesce controller determines that the fetch request is not aligned then in step coalesce controller generates a partial fetch request to read less data than is supported by the memory width and proceeds to step . A partial fetch request may be generated at the start of a request at the end of a request or for a request that reads less data than the memory width. Coalesce controller indicates the bytes within the fetch request that are not needed. If in step coalesce controller determines that the fetch request is not aligned then in step coalesce controller generates an aligned maximum fetch request in order to segment the popped fetch request into multiple aligned requests memory width with the exception of the first and or last request that may be smaller than the memory width.

In step coalesce controller determines if the fetch data request class is mainline and if so in step coalesce controller determines if the fetch request can be combined with the last fetch request stored in mainline registers . Since only sequential fetch requests are combined it is only necessary to check if a fetch request can be combined with the last received fetch request not all of the fetch requests stored in mainline registers . In some embodiments of the present invention mainline registers and subroutine registers are FIFOs.

If in step coalesce controller determines that the fetch request can be combined with the last fetch request stored in mainline registers then in step the mainline fetch request is combined with the last received mainline fetch request producing a coalesced mainline fetch request. In step the coalesced mainline fetch request s is stored in mainline registers . Note that the fetch request popped in step may be stored as one or more coalesced mainline fetch requests in mainline registers . A partial fetch request generated in step may even be combined with the last received mainline fetch request so that an additional register in mainline registers is not written. If in step the mainline fetch request cannot be combined with the last received mainline fetch request then in step the mainline fetch request s is stored in mainline registers .

In step coalesce controller determines if coalescing of the FIFO entry popped in step is complete and if so then in step coalesce controller has completed processing and the steps shown in may be repeated to process another entry of instruction stream segment pointer FIFO or . If in step coalesce controller determines that coalescing of the FIFO entry popped in step is not complete i.e. the fetch request has not been completely coalesced then coalesce controller returns to step to continue coalescing the fetch request.

If in step coalesce controller determines that the fetch request data class is not mainline then the fetch request data class is subroutine and in step coalesce controller determines if the fetch request can be combined with the last fetch request stored in subroutine registers . If in step coalesce controller determines that the fetch request can be combined with the last fetch request stored in subroutine registers then in step the subroutine fetch request is combined with the last received subroutine fetch request producing a coalesced subroutine fetch request. In step the coalesced subroutine fetch request s is stored in subroutine registers . Note that the fetch request popped in step may be stored as one or more coalesced subroutine fetch requests in subroutine registers . A fetch request that is smaller than the maximum request size may even be combined with the last received subroutine fetch request so that an additional register in subroutine registers is not written. If in step the mainline fetch request cannot be combined with the last received subroutine fetch request then in step the subroutine fetch request s is stored in subroutine registers .

In step coalesce controller determines if coalescing of the FIFO entry popped in step is complete and if so then in step coalesce controller has completed processing and the steps shown in may be repeated to process another entry of instruction stream segment pointer FIFO or . If in step coalesce controller determines that coalescing of the FIFO entry popped in step is not complete i.e. the fetch request has not been completely coalesced then coalesce controller returns to step to continue coalescing the fetch request.

When space is available in mainline registers instruction stream controller may read a fetch request that has not been coalesced particular if a fetch request is not available in first local FIFO . Therefore when the processing is not memory bandwidth limited the fetch requests may be read before they are coalesced. Conversely when the processing is memory bandwidth limited the number of fetch requests output by fetch unit will be limited and fetch requests will remain in mainline registers for more clock cycles. During those clock cycles the fetch requests may be coalesced thereby improving memory bandwidth utilization. Therefore the present invention adaptively coalesces the fetch requests as the need to improve memory bandwidth utilization increases. The additional processing latency needed to perform the coalescing is only incurred when memory bandwidth is limited.

In step instruction stream controller outputs the mainline fetch request read in step to fetch unit in order to read the data specified by the fetch request. Note that data refers to data or instructions that are stored in a push buffer. In step the space available in mainline registers is updated reduced for the mainline fetch request output in step . When the fetched data and or instructions are returned by fetch unit they are stored in mainline FIFO . Note that multiple fetch requests may be in flight at any time in order to further increase memory bandwidth efficiency. Instruction stream controller then proceeds to order the data and instructions as specified by the original fetch requests in instruction stream segment pointer FIFO or as described in conjunction with .

If in step instruction stream controller determines that space is not available in mainline FIFO then in step instruction stream controller determines if space is available in subroutine FIFO . If in step instruction stream controller determines that space is not available in subroutine FIFO then command stream controller returns to step allowing for more requests to be coalesced. If in step instruction stream controller determines that space is available in subroutine FIFO then in step instruction stream controller determines if a fetch request is available in subroutine registers . If in step instruction stream controller determines that a fetch request is not available in subroutine registers then instruction stream controller returns to step .

If in step instruction stream controller determines that a fetch request is available in subroutine registers then in step instruction stream controller reads a coalesced fetch request from subroutine registers . In step instruction stream controller outputs the subroutine fetch request read in step to fetch unit in order to read the data specified by the coalesced fetch request. In step the space available in subroutine FIFO is updated reduced for the subroutine fetch request output in step . When the fetched data are returned by fetch unit it is stored in subroutine FIFO . As shown in mainline class fetch requests are given higher priority than subroutine class fetch requests. In other embodiments of the present invention different priority schemes are used to select either a mainline fetch request or a subroutine fetch request. Furthermore although only two different classes of fetch requests are described in other embodiments of the present invention additional classes of fetch requests are coalesced and included in the instruction stream.

Specifically instruction stream controller pops each entry from mainline FIFO that only contains data specified by the popped fetch request. An entry may include data specified by a subsequent fetch request that was coalesced with the popped fetch request. Therefore an entry should not be popped from mainline FIFO until all of the data included in the entry that is needed has been read for the instruction stream. As previously described a byte mask may be included in the coalesced fetch requests and returned with the data via mainline FIFO in order to determine which bytes are valid and needed for the instruction stream.

In step instruction stream controller determines if more valid data is present in the entry read from mainline FIFO in step than is needed to fulfill the original popped fetch request i.e. if there is excess valid data. Since several original fetch requests may be coalesced into a single coalesced fetch request the data in a single entry read from mainline FIFO may be needed to fulfill more than one of the popped fetch requests. Conversely several entries may need to be popped from mainline FIFO to fulfill an original fetch request with a long length. If all of the valid data in the entry is needed to fulfill the original fetch request then in step the entry read in step is popped and output in the instruction stream. Note that entries are also popped when the byte mask indicates that any unread bytes are not valid and therefore not needed to fulfill a coalesced fetch request. If in step there is excess valid data then instruction stream controller returns to step to pop another entry storing an original fetch request from second local FIFO . Note that any excess data is retained in mainline FIFO since the excess data is needed for a subsequent fetch request. In some embodiments of the present invention the excess data from mainline FIFO is popped and stored in a separate register so that it is available when needed for the subsequent original fetch request.

If in step instruction stream controller determines that the original fetch request is not a mainline class fetch request then in step instruction stream controller reads the subroutine data and or instructions from subroutine FIFO . When subroutine FIFO is empty instruction stream controller waits for data to be pushed onto subroutine FIFO before completing step . In step instruction stream controller determines if more valid data is present in the entry read from subroutine FIFO in step than is needed to fulfill the original fetch request. If in step there are not excess valid data then in step the entry read in step is popped and output in the instruction stream. Instruction stream controller reads and pops entries from mainline FIFO and subroutine FIFO to generate the instruction stream according to instruction stream segment pointer FIFO or . If in step there is excess valid data then instruction stream controller returns to step to pop another entry storing an original fetch request from second local FIFO . Note that any excess data is retained in subroutine FIFO since the excess data is needed for a subsequent fetch request. In some embodiments of the present invention the excess data from subroutine FIFO is popped and stored in a separate register so that it is available when needed for the subsequent original fetch request.

Coalesce unit advantageously combines sequential fetch requests from a set of fetch requests into longer fetch requests that match the width of a system memory interface in order to improve memory access efficiency for reading the data specified by the fetch requests. Another advantage of the disclosed system and method is that the fetches are performed after the data is available in the memory so that the fetched data is correct. The fetch requests may be for different data classes and each data class is coalesced separately even when intervening fetch requests are for a different data class. Finally the data read from memory is ordered according to the order of the set of fetch requests to produce the instruction stream specified by the original fetch requests.

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

