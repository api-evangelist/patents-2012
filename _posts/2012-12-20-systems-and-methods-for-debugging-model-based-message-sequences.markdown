---

title: Systems and methods for debugging model based message sequences
abstract: A system for simplifying message sequences is disclosed. The system includes a shrink component and a message simplification component. The shrink component is configured to receive a failure inducing message sequence and to provide a shrunk sequence based on the failure inducing message sequence. The shrunk sequence has less or equal number of messages than the failure inducing message sequence. The message simplification component is configured to receive the shrunk sequence and to simplify messages within the shrunk sequence to generate a simplified message sequence including debugging hints.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914678&OS=08914678&RS=08914678
owner: Intel Mobile Communications GmbH
number: 08914678
owner_city: Neubiberg
owner_country: DE
publication_date: 20121220
---
Traditionally devices have operated with a fairly specific set of functions and features. The functions and features of such traditional devices are specific to the type of a device. For example a traditional phone uses functions such as initiating calls receiving calls and the like related to a phone. In another example a traditional music device uses functions such as skipping to a next song playing pausing and the like.

Current devices often include many feature sets of traditional devices in a single device. For example a smart phone can include functions and features related to a phone music player electronic message system video player camera and the like. Having the multiple feature sets causes the current devices to be more complex than traditional devices. This complexity makes the design and debugging of such devices challenging. Therefore a need exists for an automated system for debugging designs of such devices.

The present invention will now be described with reference to the attached drawing figures wherein like reference numerals are used to refer to like elements throughout and wherein the illustrated structures and devices are not necessarily drawn to scale.

Devices of today may include a mobile device a personal computer a tablet device. Devices may also include system on chip SOC and embedded systems that include a variety of function and feature sets. These sets include phones cameras video playback multimedia and the like. One technique to enhance development and design of these devices is to utilize an abstract model to test and debug development of such devices.

In the simplest form an abstract model is represented as a labeled transition system. Each transition is labeled with a message or event which triggers a transition. The abstract model is an abstract representation of an actual system. The abstract model specifies various abstract system states and how each system state changes when the system is stimulated with incoming messages or events.

One issue is identified when a message sequence results in a system output or behavior that deviates from an expected or desired one. Such a message sequence is referred to as a failure inducing message sequence. This failure inducing message sequence can then be analyzed to identify the root cause of failure and to correct the design. However such failure inducing message sequences typically comprise a relatively large number of messages and high complexity. As a result debugging these failure inducing message sequences can be time consuming and difficult.

Systems and methods are disclosed that include techniques to automatically shrink and simplify failure inducing message sequences. As a result simplified sequences are provided along with hints that can drastically reduce debugging efforts associated in debugging devices in particular manual debugging efforts. Further the simplified sequences can also facilitate identification of a particular technology area to target for debugging such as a particular engineering department and therefore improve failure triage.

The device includes one or more processors a memory an input output I O component and a message sequence simplification system . The processor is configured to interact with the memory the I O component and the message sequence simplification system . The processor is further configured to execute instructions including sequences from the memory .

The memory includes program code data and the like for operation of the device. The memory may also include message sequences. The I O component is configured to receive information external to the device and to provide information from the device .

The message sequence simplification system receives failure inducing message sequences and generates simplified sequences with debugging hints therefrom. Additional details on the operation of such a system are provided below. The failure inducing message sequences can be received from the memory or by the I O component . Similarly the simplified sequences with debugging hints can be stored in the memory and or provided to the I O component .

The device is provided as an example to facilitate understanding. It is appreciated that other suitable devices can utilize message sequence simplification systems.

It is appreciated that at least a portion of the components of system can be implemented in software executed on one or more computers as machine readable instructions executable by one or more processors and the like. Furthermore the components of the system can be at least partially stored on and or utilize a computer readable medium. Alternatively system can be implemented as stand alone software tool. Moreover it is appreciated that it can interact with or can be part of a verification validation system.

The system includes an abstract model a sequence shrink component and a message simplification component . The abstract model is a model of a design or behavior for a device such as a mobile device. The device can include or can be part of a system on chip or embedded system. However an abstract model may represent design or behavior of devices other than mobile devices without departing the spirit and scope of the present disclosure for example devices that comprise a software system a hardware system or any combination of software and hardware systems. In addition the design or behavior of devices represented by the abstract model may be implemented in software hardware firmware or any combination thereof.

The abstract model is represented as a labeled transition system. The abstract model has states and transitions and describes how the represented or modeled system performs state transitions when stimulated by messages. A transition is triggered by an incoming message or event. Each transition is labeled with a message or an event that triggers a particular transition from a particular state. It is appreciated that the term event is used in a broad sense. It can be used for various modeling purposes for example represent function method calls in software.

The abstract model is utilized to annotate a failure inducing message sequence and to provide an annotated message sequence wherein each message is annotated with its triggering transition in the abstract model . The failure inducing message sequence is a sequence of messages that results in a particular failure. The annotated message sequence is the failure inducing message sequence but with transition annotations.

The abstract model can define which message sequences are valid and which are invalid. The abstract model can be interpreted as an executable specification of a public application programming interface. Invalid message sequences lead the model into a dedicated error state and violate the specification. An example abstract model is described below however the description of system continues after the example.

The model is depicted with a first state a second state and a third state . Transitions to and between the states are shown as a and b where a and b are abstract messages. The transitions occur in response to a message received while in a particular state. Initially the model is in the first state . From this state an a message causes a transition to the third state and a b message causes a transition to the second state .

A message sequence is a sequence of messages that causes a series of transitions to or among various states of the model. For example S0 a S1 a S3 b S2 can denote an initial transition a to state 1 S1 followed by a transition a to state 3 S3 followed by a transition b to state 2 S2 .

Returning to system and the message sequence is simulated on the abstract model by the shrink component . The result is the annotated message sequence . Alternatively the annotation can also be part of the message sequence itself i.e. the annotation can be added by the stimulus source or by the actual system. In this case the simulation on the abstract model can be omitted. The shrink component attempts to shrink or simplify the message sequence by minimizing or reducing the number of messages within the sequence. It is appreciated that variations of the message include variations where the shrink component operates on the non annotated sequence the failure inducing message sequence .

The shrink component systematically attempts to cut off parts of the sequence and then tests or re stimulates the system that is represented by the model with the remaining sequence referred to as a candidate. A shrink attempt or candidate is considered as successful if the system fails with the same failure produced by the failure inducing message sequence . A shrink attempt is considered as not successful if the system does not respond with the same failure produced by the failure inducing message sequence . The shrink component continues with another shrink attempt until a suitable termination condition is met. Some examples of suitable termination conditions include reaching a time limit or until all possible shrink attempts have been attempted. At this point the remaining sequence that results in the same failure produced by the failure inducing message sequence is provided as a shrunk or partially simplified sequence . In one example the shrunk sequence has a number of messages of less than 10 percent of the number of messages present in the original failure inducing message sequence .

The message shrink component utilizes information from the model to identify sub sequences in order to generate candidates. Instead of performing arbitrary cuts which may result in invalid sequences that are not conform with the model i.e. violate the specification only valid candidates are generated. As a result testing or evaluating of invalid candidates is avoided and the shrinking is performed relatively quicker.

An example of such sequence splitting and shrink attempts is provided below utilizing the example model of . An example failure inducing message sequence is shown as 

Where a and b represent transition triggering messages and SO represents an initial state S1 represents the first state S2 represents the second state and S3 represents the third state .

A sub sequence is a sequence of messages that begins and ends with the same state. In this example there are several sub sequences that start at state S1 and end at state S1. A first sub sequence is shown by

The postfix is a message sequence at the end of the failure inducing message sequence which starts with the split state.

A first simplification candidate is provided by eliminating the first sub sequence and the second sub sequence 

The simplification candidates can be tested by the sequence shrink component to determine if the candidates yield the same failure as the example failure inducing message. If so one of the successful candidates can be provided as the partially simplified or shrunk sequence. If there are multiple successful candidates one is chosen according to a selection criterion. In one example the criterion is a length of the simplification candidate. According to the example criterion the first simplification candidate if successful would be chosen as the shrunk sequence. Typically shorter simplification candidates are tested first in order to minimize the number of simplification attempts.

The above example failure inducing message sequence is provided in order to facilitate understanding. The failure inducing message sequence can have a relatively large number of messages and sub sequences rendering any manual simplification to be infeasible. For example the failure inducing message sequence can include up to 10 000 or millions of individual messages.

As a result the shrink component can utilize a suitable technique to select subsets of subsequences in order to generate simplification candidates. One example of a suitable technique is delta debugging. Generally delta debugging is a technique that automatically simplifies and isolates failure inducing inputs. This technique may be used to select subsets of sub sequences after splitting. After shrinking the message sequence to generate the shrunk sequence individual messages of the sequence can be further simplified and debugging hints can be generated as described below.

The message simplification component simplifies messages within a message sequence. The message simplification component receives the shrunk sequence from the sequence shrink component and provides a simplified sequence consisting of simplified messages with debugging hints. The message simplification component analyzes the messages in the shrunk sequence and considers various values for the message parts within the sequence . As a result of the analysis the message component generates a simplified sequence and hints associated with remaining message parts.

The hints identify which sequence and or message parts have an impact on whether the failure is observable or not.

The hints can also identify a technology group or area for analyzing the potential defects. For example if the hints are primarily related to power management messages the simplified sequence could be provided to a power management engineering group for analysis.

The portion is shown with a first message and a second message . The first message has a plurality of message parts from 1 to n. The second message has a plurality of message parts from 1 to m. Each message part can have one or more values including a default value a disabled value and the like. As can be seen the number of message parts per message can vary.

Returning to the message component analyzes set values for the message parts within the shrunk sequence . The message component can also modify values of message parts and test the shrunk sequence with the modified message part values.

Default values are generally considered to be more common and less likely to induce a particular failure. Typically failures occur for message parts set to non default values. As a result message parts that can be set to default values are deemed unlikely to have a connection to the identified failure. Thus the message parts that are not able to be set to default values can be deemed likely to have a connection to the identified failure.

Additionally message parts can be set to a disabled value that effectively disables the message part and or an associated system feature. Message parts that are disabled while the message sequence still yields the identified failure are deemed unlikely to have a connection to the identified failure.

As a result the message component returns a shrunk message sequence where individual message parts have been set to default values. Moreover the message sequence includes debugging hints and triggers the same observable failure as the original message sequence .

The method begins at block where one or more simplification candidates are identified for a message sequence. The message sequence is a sequence of messages usable in an event or message driven system. The message sequence typically causes a failure in a system. The message sequence can include annotations such as triggering transitions for each message in the sequence.

The simplification candidates can be identified from the message sequence using a suitable technique such as described above. Various portions of the message sequence are identified including a prefix portion beginning portion a postfix portion an ending portion and zero or more sub sequences in between. The sub sequences are identified using a suitable technique such as a greedy algorithm to identify portions of the message sequence that start and end with a particular state. The sub sequences are then compiled with the prefix portion and the postfix portion to generate the one or more simplification candidates.

The one or more simplification candidates are tested at block to identify one or more successful candidates. A successful candidate is a candidate that results in or reproduces the original failure.

A shrunk message sequence is generated at block according to the one or more successful candidates. The one or more successful candidate can be analyzed to determine which of the candidates are simplest. Shorter candidates are tested first and the successful candidate with the smallest length is selected and provided as the shrunk message sequence.

A list of message parts and possible values for the message parts are identified at block . The message parts are portions of individual messages such as shown in which can be set to the possible values. The possible values can include a default value a disabled value other values and the like. The default value indicates a value that the message part is most often or commonly set to. Generally a message part currently set to a default value is less likely to be a direct or proximate cause of the failure. Further if a message part can be disabled it is also less likely to be a cause of the failure.

Thus at block the message parts are set to default values and a portion of the message parts are identified as potential defects and provided as debugging hints. One group is identified from message parts that are set to default values that do not reproduce the failure. The message parts can also be used to identify and remove non relevant messages from the shrunk message sequence to generate a simplified message sequence.

The simplified message sequence and the debugging hints can be utilized to debug a system related to the message sequence. Further the message sequence and or the debugging hints can be utilized to identify or assign technology areas to perform debugging.

While the methods provided herein are illustrated and described as a series of acts or events the present disclosure is not limited by the illustrated ordering of such acts or events. For example some acts may occur in different orders and or concurrently with other acts or events apart from those illustrated and or described herein. In addition it may be that not all illustrated acts are required. Further one or more of the acts depicted herein may be carried out in one or more separate acts or phases.

It is noted that the claimed subject matter may be implemented as a method apparatus or article of manufacture using standard programming and or engineering techniques to produce software firmware hardware or any combination thereof to control a computer to implement the disclosed subject matter e.g. the systems shown above are non limiting examples of circuits that may be used to implement disclosed methods and or variations thereof . The term article of manufacture as used herein is intended to encompass a computer program accessible from any computer readable device carrier or media. Those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the disclosed subject matter.

A system for simplifying message sequences is disclosed. The system includes a message sequence shrink component and a message simplification component. The shrink component is configured to receive a failure inducing message sequence and to provide a shrunk sequence based on the failure inducing message sequence. The shrunk sequence has less or equal number of messages than the original failure inducing message sequence. The message simplification component is configured to receive the shrunk sequence and to simplify individual messages within the shrunk sequence to generate a simplified message sequence including debugging hints.

A method of simplifying a message sequence is disclosed. One or more simplification candidates are identified from a message sequence. The one or more simplification candidates are tested to identify at least one successful candidate. A shrunk message sequence is generated based on successful candidates. Additionally message parts of the shrunk message sequence can be identified and tested to identify likely defective message parts hints.

A method of simplifying a list of message parts is disclosed. A list of message parts from a message sequence is disclosed. Message parts are set to first values. Successful candidates are identified as message parts set to first values that reproduce an original message sequence failure. Unsuccessful candidate message parts are identified and provided as debugging hints.

Although the invention has been illustrated and described with respect to one or more implementations alterations and or modifications may be made to the illustrated examples without departing from the spirit and scope of the appended claims. Furthermore in particular regard to the various functions performed by the above described components or structures assemblies devices circuits systems etc. the terms including a reference to a means used to describe such components are intended to correspond unless otherwise indicated to any component or structure which performs the specified function of the described component e.g. that is functionally equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary implementations of the invention. In addition while a particular feature of the invention may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms including includes having has with or variants thereof are used in either the detailed description and the claims such terms are intended to be inclusive in a manner similar to the term comprising .

