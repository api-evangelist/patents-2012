---

title: Storage structures for stitching primitives in graphics processing
abstract: Techniques described in the disclosure are generally related to generating points of a domain. A tessellation unit may determine outer ring point coordinates for a point of an outer ring of the domain, and inner ring point coordinates for a point of an inner ring of the domain. The inner ring is inner to the outer ring within the domain. The tessellation unit may enqueue the inner ring point coordinates at a location of a queue, read the inner ring point coordinates from the queue, and read the outer ring point coordinates from the queue when the outer ring is not an outermost ring, where the outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring. The tessellation unit may connect the inner ring coordinates and the outer ring coordinates each of which being read from the queue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09082204&OS=09082204&RS=09082204
owner: QUALCOMM Incorporated
number: 09082204
owner_city: San Diego
owner_country: US
publication_date: 20120830
---
This disclosure relates to stitching of for primitives in graphics processing and more particularly to stitching with tessellation.

A graphics processing unit GPU may implement a graphics processing pipeline that includes a tessellation stage. The tessellation stage converts a surface into a plurality of primitives on the GPU resulting in a more detailed surface. For example the GPU can receive information for a coarse surface and generate a high resolution surface rather than receiving information for the high resolution surface. Receiving information for the high resolution surface rather than the coarse surface may be bandwidth inefficient because the amount of information needed to define the high resolution surface may be much greater than the amount of information needed to define coarse resolution surface.

In general the techniques described in this disclosure are direct to storing points of a domain that reside along an inner ring and an outer ring of the domain in one or more queues during stitching of a primitive formed by the stored points. A tessellation unit may generate the points which may comprise coordinates in the domain along the outer and inner rings and may store the points in storage structures such as queues. The tessellation unit may remove the points stored in the queues and stitch the points together. In some examples the storage structures may allow for the reuse of the points in subsequent stitching iterations without necessarily determining the points needed in the subsequent stitching iterations.

In one example the disclosure describes a method of generating points of a domain that includes determining with the tessellation unit outer ring point coordinates for a point of an outer ring of the domain determining with the tessellation unit inner ring point coordinates for a point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain enqueueing with the tessellation unit the inner ring point coordinates at a location of a queue reading with the tessellation unit the inner ring point coordinates from the queue reading with the tessellation unit the outer ring point coordinates from the queue when the outer ring is not an outermost ring wherein the outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring and connecting with the tessellation unit the inner ring coordinates and the outer ring coordinates each of which being read from the queue.

In another example a method of generating point for a domain includes determining with the tessellation unit outer ring point coordinates for a point of an outer ring of the domain determining with the tessellation unit inner ring point coordinates for a point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain enqueueing with the point generator the inner ring point coordinates at a first location of a first queue enqueueing with the tessellation unit the outer ring point coordinates in a second location of the first queue when the outer ring is not the outermost ring and when a number of points along the outermost ring is less than or equal to a threshold enqueueing with the tessellation unit the outer ring point coordinates in a first location of a second queue when the outer ring is the outermost ring or when the number of points along the outermost ring is greater than a threshold reading with the tessellation unit the inner ring point coordinates from the first location of the first queue reading with the tessellation unit the outer ring point coordinates from the second location of the first queue when the outer ring is not the outermost ring and when the number of points along the outermost ring is less than or equal to the threshold reading with the tessellation unit the outer ring point coordinates from the first location of the second queue when the outer ring is the outermost ring or when the number of points along the outermost edge is greater than the threshold and connecting with the tessellation unit the inner ring point coordinates and the outer ring point coordinates.

In another example the disclosure describes a tessellation unit that includes a point generator configured to determine first outer ring point coordinates for a first point of an outer ring of the domain determine first inner ring point coordinates for a first point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain enqueue the first inner ring point coordinates at a first location of a queue and a connectivity generator configured to read the first inner ring point coordinates from the queue read the first outer ring point coordinates from the queue when the outer ring is not an outermost ring wherein the first outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring and connect the first inner ring coordinates and the first outer ring coordinates each of which being read from the queue.

In another example the disclosure describes a tessellation unit that includes means for determining first outer ring point coordinates for a first point of an outer ring of the domain means for determining first inner ring point coordinates for a first point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain means for enqueueing the first inner ring point coordinates at a first location of a queue and means for reading the first inner ring point coordinates from the queue means for reading the first outer ring point coordinates from the queue when the outer ring is not an outermost ring wherein the first outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring and means for connecting the first inner ring coordinates and the first outer ring coordinates each of which being read from the queue.

In another example the disclosure describes a device that includes a queue and a tessellation unit configured to determine first outer ring point coordinates for a first point of an outer ring of the domain determine first inner ring point coordinates for a first point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain enqueue the first inner ring point coordinates at a first location of a queue read the first inner ring point coordinates from the queue read the first outer ring point coordinates from the queue when the outer ring is not an outermost ring wherein the first outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring and connect the first inner ring coordinates and the first outer ring coordinates each of which being read from the queue.

In another example the disclosure describes a computer readable storage medium. The computer readable storage medium having stored thereon instructions that upon execution cause one or more processors to determine first outer ring point coordinates for a first point of an outer ring of the domain determine first inner ring point coordinates for a first point of an inner ring of the domain wherein the inner ring is inner to the outer ring within the domain enqueue the first inner ring point coordinates at a first location of a queue read the first inner ring point coordinates from the queue read the first outer ring point coordinates from the queue when the outer ring is not an outermost ring wherein the first outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring and connect the first inner ring coordinates and the first outer ring coordinates each of which being read from the queue.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Modern mobile devices such as laptop computer tablet computers smartphones and digital media players may include a CPU Central Processing Unit a graphics processing unit GPU and system memory. When rendering graphics as part of executing an application the CPU transmits instructions and graphics data to the GPU. In some examples the graphics data may be in the form of vertices which may comprise one or more data structures that describes a point in 2D or 3D space.

The application executing on the CPU may communicate with the GPU in accordance with an application programming interface API . For instance the application may communicate with the GPU in accordance with the DirectX API developed by Microsoft or the OpenGL API developed by the Khronos Group as two examples. For purposes of illustration and to ease with understanding the techniques described in this disclosure are generally described in the context of the DirectX and OpenGL APIs. However aspects of this disclosure should not be considered limited to the DirectX and OpenGL APIs and the techniques described in this disclosure may be extended to other APIs as well.

DirectX and OpenGL each define graphics processing pipelines that are to be implemented by a GPU. These graphics processing pipelines may include a combination of programmable stages as well as fixed function stages. Some recent versions of the APIs such as the Direct3D 11 API and the OpenGL 4.x API include a tessellation process that is to be performed by the GPU.

The tessellation process refers to dividing a portion referred to as patch of a surface of an object into a plurality of smaller portions and interconnecting the smaller portions together. This results in a more highly detailed surface as compared to the surface prior to tessellation. Tessellation allows the application executing on the CPU to define the surface with low resolution which may require few points and allows the GPU to generate a higher resolution surface.

With tessellation computation efficiency may be realized because the application executing on the CPU may not need to generate the higher resolution surface and may instead offload the generation the higher resolution surface to the GPU. Furthermore bandwidth efficiency may also be realized because the CPU may need to transmit information for fewer points of the surface because the low resolution surface includes fewer points as compared to the higher resolution surface and the GPU may need to retrieve fewer points of the surface.

As described above the GPU applies the tessellation process to a patch. A patch may be considered as a specialized type of a primitive. A patch is defined by one or more control points that together form a portion of a surface. For example an object such as a sphere may be divided into a plurality of surfaces. In this example the surfaces may be curved surfaces that when combined form the sphere. Each one of the surfaces may be divided into one or more patches where each of the patches is defined by one or more control points.

The control points may be defined by coordinates e.g. x and y coordinates for two dimensional patches or x y and z coordinates for three dimensional patches and the control points may be considered as vertices of the patch. There may be any number of control points in a patch. For instance in some examples the number of control points in a patch may be between one control point up to 32 control points. The number of control points in a patch may be fixed or user defined.

Unlike other primitive types the control points within the patches may be connected to one another in any way. In other words there is no predefined way in which the control points of the patches are connected. For example a standard triangle primitive includes three vertices and the primitive is defined with a specific way in which the three vertices are connected with one another to form the triangle. The control points on the other hand may not need to be connected in any specific way to form a shape. Rather as one example some control points in a patch may be connected with one another to form a triangle other control points in the same patch may be connected with one another to form a rectangle and yet other control points in the same patch may be connected with one another to form an octagon. As another example it may be possible that the control points are connected with another to form the same type of shapes as well e.g. connected to only form a plurality of triangles .

The control points that define a patch of a surface may define a low resolution surface. With the tessellation process additional detail is added to create a higher resolution surface. For example referring back to the example of the sphere. If only the control points were used to form the sphere the sphere would appear jaggy with stair step like points rather than a smooth curved surface. After tessellation additional points are added such that when these points are connected the sphere appears as if it is a smooth sphere.

The tessellation process in accordance with the both the DirectX API and the OpenGL 4.x API includes two shaders and a fixed function unit. A shader is a software application that executes on a programmable shader core of the GPU and provides substantial functional flexibility. The fixed function unit is a hardwired logic unit that performs fixed functions and may not provide functional flexibility. However it may be possible to implement the functions of the fixed function unit using a programmable shader coder to provide additional functional flexibility. Solely for purposes of illustration the functions described in this disclosure for the fixed function unit are described with a fixed function unit that provides limited functional flexibility.

In the DirectX API a graphics processing pipeline that is configured to implement the tessellation process includes a hull shader stage coupled to a tessellation stage which is coupled to a domain shader stage. The hull shader stage and the domain shader stage in the DirectX API may form the two shaders of the tessellation process and the tessellation stage may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline are similar to those in DirectX APIs that do not implement the tessellation process.

In the OpenGL 4.x API a graphics processing pipeline that is configured to implement the tessellation process includes a tessellation control shader coupled to a primitive generator which is coupled to a tessellation evaluation shader. The tessellation control shader and the tessellation evaluation shader in OpenGL 4.x may form the two shaders of the tessellation process and the primitive generator may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline may be similar to those in OpenGL APIs that do not implement the tessellation process.

The techniques described in this disclosure are related generally to the fixed function unit of the tessellation process e.g. the tessellation stage of the DirectX graphics processing pipeline and the primitive generator of the OpenGL 4.x graphics processing pipeline . For purposes of brevity the fixed function unit of the tessellation process is referred to as a tessellation unit. For instance examples of the tessellation unit include the tessellation stage of the DirectX graphics processing pipeline the primitive generator of the OpenGL 4.x graphics processing pipeline or any other analogous unit for other types of graphics processing pipelines.

As described in more detail the shader preceding the tessellation unit e.g. the hull shader stage in DirectX or the tessellation control shader in OpenGL 4.x transmits values to the tessellation unit that indicate how many primitives are to be generated for the patch to increase the resolution i.e. increase the detail of the patch. The shader preceding the tessellation unit also transmits a domain type to the tessellation unit. The tessellation unit divides a domain into the primitives and indicates the manner in which the primitives in the domain are to be connected i.e. the manner in which the primitives in the domain are to be stitched .

The domain is a template shape that the tessellation unit divides into a plurality of primitives. It is these primitives that are then added to the patch to increase the resolution of patch. For example the additional primitives generated in the domain are then used to form a mesh on the patch thereby adding detail to the patch.

The shader subsequent to the tessellation unit e.g. the domain shader in DirectX or the tessellation evaluation shader in OpenGL 4.x receives the vertices of the primitives generated by the tessellation unit and connectivity information for the vertices from the tessellation unit. The shader subsequent to the tessellation unit then adds the primitives as generated by the tessellation unit to the patch to add more resolution to the surface.

Stitching may be considered as the process of connecting vertices together to form primitives. For example as part of the tessellation process the tessellation unit may determine points within the domain. These points form vertices of the primitives. Stitching refers to the process of determining which of these points should be used to generate a primitive within the domain.

Each patch may be subdivided into one or more concentric rings for the purposes of tessellating the patch. The number of rings may be determined based on parameters passed to the tessellation unit. The tessellation unit generates points in the domain on each of the edges of the patch starting with the points on the outermost edge of the patch and working inward. The tessellation unit generates the points along the outermost ring and the next outermost ring which is considered to be an inner ring to the outermost ring and connects or stitches the points of the two rings together. The tessellation unit repeats the process of connecting the points of an outer and an inner ring i.e. the next outermost ring relative to the outer ring until all the points of all the rings have been connected.

In accordance with techniques described in this disclosure the tessellation unit may utilize one or more storage structures such as queues or buffers to store the generated domain points of the outer and inner rings of the patch. Examples of queues include a first in first out FIFO queue and examples of buffers include a ring buffer although the storage structures should not be considered limited to queues and buffers or these specific types of queues and buffers and may be extended to other storage structures as well.

When the tessellation unit completes connecting the points of the outer ring with the points of a current inner ring the points of the outer ring no longer need to be stored. However for a subsequent stitching iteration the current inner ring may form the outer ring for a ring that is inner to the current inner ring. For this case the points of the current inner ring may be reused as points of the outer ring in a subsequent stitching iteration. A subsequent stitching iteration includes connecting the points along the edge of an inner ring inner relative to the previous inner ring with the points of an outer ring which is the inner ring of the previous stitching iteration in a subsequent iteration. In some examples the buffers or queues may allow the tessellation unit to reuse previously generated points of the inner ring from a current iteration as the outer ring points in a subsequent stitching iteration.

In this manner the techniques of this disclosure may increase stitching throughput and reduce the computation required during stitching. For example the tessellation may not need to restore the previously generated domain points as these points are already stored within the queues or buffers in accordance with one or more techniques described in this disclosure. The reduced computation may reduce the amount of power utilized during the stitching process.

CPU may execute various types of applications. Examples of the applications include web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. Instructions for execution of the one or more applications may be stored within system memory . CPU may transmit graphics data of the generated viewable objects to GPU for further processing.

For example GPU may be specialized hardware that allows for massive parallel processing which functions well for processing graphics data. In this way CPU offloads graphics processing that is better handled by GPU . CPU may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft and the OpenGL by the Khronos group however aspects of this disclosure are not limited to the DirectX and the OpenGL APIs and may be extended to other types of APIs that have been developed are currently being developed or are to be developed in the future.

In addition to defining the manner in which GPU is to receive graphics data from CPU the APIs may define a particular graphics processing pipeline that GPU is to implement. GPU in illustrates the graphics processing pipeline defined by the Direct3D 11 API. As described in more detail illustrates the graphics processing pipeline of the OpenGL 4.x API.

Examples of CPU and GPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing and may be referred to as a general purpose GPU GPGPU . The techniques described in this disclosure may also be applicable to examples where GPU is a GPGPU.

System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM flash memory or any other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Accordingly system memory may be a computer readable storage medium comprising instructions that cause one or more processors e.g. CPU and GPU to perform various functions.

System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable. As one example system memory may be removed from device and moved to another device. As another example a system memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

The execution of the applications on CPU causes CPU to generate a plurality of primitives that connect together to form the viewable content. Examples of the primitives include points lines triangles squares or any other type of polygon. CPU may define these primitives by their respective vertices. For example CPU may define coordinates and color values for the vertices. The coordinate values may be three dimensional 3D coordinates or 2D coordinates.

In some cases CPU may also generate a special type of primitive referred to as a patch. Similar to the other primitive types a patch may be defined by a plurality of vertices referred to as control points of a patch. Unlike other primitive types the patch may not be any particular shape. For example CPU may interconnect the control points of the patch in any manner so that the interconnected control points form any desired shape. For other primitive types such as triangles CPU may define the specific manner in which the vertices are interconnected e.g. such that interconnection of the vertices results in a triangle .

Also unlike other primitive types the number of control points in a patch may be variable. For example the application executing on CPU may define a maximum number of control points that are allowed for a patch or the maximum number of control points may be user defined. In some examples the number of control points in a patch may be one to thirty two control points however the techniques described in this disclosure are not so limited.

CPU may utilize the control patch for purposes of tessellation. As described above a tessellation process refers to CPU defining a portion of a surface of a viewable object in low resolution and tessellating the portion to generate a higher resolution version of the surface. For example CPU may define control points of the patch such that when the control points are interconnected the patch forms a portion of a surface of a viewable object. If a surface were to be formed only from the control points of the patch the surface may not appear with high resolution and may appear jaggy. With tessellation additional primitives are added to the patch such that when the primitives are interconnected they add detail to the patch which increases the resolution of the patch and results in higher quality viewable content.

GPU may be configured to implement tessellation. In this way CPU may not need to define the vertices for all the additional primitives needed to create the higher resolution patch which saves on computations performed by CPU . Also CPU may need to transmit fewer vertices e.g. the vertices of the control points and not the vertices of the primitives to be added and GPU may correspondingly need to receive fewer vertices which promotes bandwidth efficiency due to fewer accesses to system memory .

To perform graphics operations GPU may implement a graphics processing pipeline. The graphics processing pipeline includes performing functions as defined by software or firmware executing on GPU and performing functions by fixed function units that are hardwired to perform very specific functions. The software or firmware executing on the GPU may be referred to as shaders and the shaders may execute on one or more shader cores of GPU . Shaders provide users with functional flexibility because a user can design the shaders to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility.

As indicated above the graphics processing pipeline illustrated in is a graphic processing pipeline substantially as defined by Direct3D 11. In this example GPU may include one or more of input assembler stage vertex shader stage hull shader stage tessellation stage domain shader stage geometry shader stage rasterizer stage pixel shader stage and output merge stage . GPU may include more stages than those illustrated and in some examples GPU may not necessarily include all of the illustrated stages. Also the specific ordering of the stages is provided for purposes of illustration and should not be considered limiting.

In techniques described in this disclosure CPU may output the control points of a patch to system memory . GPU may then retrieve the control points from system memory . In this manner CPU may transmit the control points to GPU . As used in this disclosure CPU transmitting to GPU or GPU receiving from CPU may generally include CPU writing to system memory from which GPU receives. Alternatively it may be possible for CPU to directly transmit to GPU and for GPU to directly receive from CPU .

Input assembler stage may read the control points from system memory as defined by CPU and assemble the control points to form the patch. For instance input assembler stage may read the coordinates color values and other such information of the control points. The coordinates color values and other such information may be commonly referred to as attributes of the control points. Based on the attributes of the control points input assembler stage may determine the general layout of the patch. In this manner input assembler stage may assemble the control points to form the patch. Input assembler stage may be a fixed function unit.

Vertex shader stage may process the vertices e.g. the control points of the patch from input assembler stage . For example vertex shader stage may perform per vertex operations such as transformations skinning morphing and per vertex lighting. Vertex shader stage may be a shader.

Hull shader stage receives the control points of the patch as processed by vertex shader stage process the control points and outputs control points for a processed patch. In other words hull shader stage receives an input patch as processed by vertex shader stage processes the input patch and outputs an output patch. Hull shader stage may perform various functions for processing the input patch. For example hull shader stage may modify the coordinates of the control points to change the locations of the control points or may even add or delete control points.

In addition hull shader stage may determine values that indicate how many primitives are to be added to the patch generated by hull shader stage i.e. the output patch . Hull shader stage may utilize various criteria to determine how many primitives are to be added to the patch. Described below are two example criteria that hull shader stage may utilize to determine how many primitives are to be added to the patch. However aspects of this disclosure are not so limited and hull shader stage may utilize any criteria to determine how many primitives should be added to the patch.

As one example hull shader stage may utilize information indicative of the depth of the patch to determine how many primitives should be added. For instance a patch that is further away from the perspective of the viewer may not need high resolution because objects further in distance appear blurry in real life. However a patch that is closer from the perspective of the viewer may need higher resolution because objects closer in distance appear sharper in real life. In this example hull shader stage may determine that fewer primitives should be added to the patch that is further away and more primitives should be added to the patch that is closer relative to one another.

As another example hull shader stage may determine how many primitives should be added based on the size of the patch. For a smaller sized patch hull shader stage may determine that fewer primitives should be added because the patch encompasses a smaller area. For a larger sized patch hull shader stage may determine that more primitives should be added because the patch encompasses a larger area.

Based on a determination of how many primitives should be added hull shader stage may output a domain type and values that indicate how many primitives are to be added to the patch to tessellation stage . The values that indicate how many primitives are to be added to the patch in the Direct3D 11 API are referred to as tessfactors.

The domain may be a considered as a template shape that tessellation stage uses for tessellation purposes. Examples of the domain type include a line a triangle a quad e.g. a four sided polygon or any other type of polygon. The domain may be a two dimensional 2D shape even if the patches define a three dimensional 3D surface or a 2D surface. When the domain is a line the domain may be a one dimensional 1D shape i.e. a line even if the patches define a 3D surface a 2D surface or a 1D surface. For purposes of illustration the techniques described in this disclosure are described with respect to the domain being a 2D surface. For instance the techniques are described with domain shapes that are the triangle or quad.

In some examples hull shader stage may not explicitly indicate the domain type. Rather tessellation stage may determine the domain type based on the number of transmitted tessfactors. For example the presence of four tessfactors may indicate that the domain type is a triangle domain type and the presence of six tessfactors may indicate that the domain type is a quad domain type.

In some examples a quad domain may be defined by 2D Cartesian coordinates u v . In some examples a triangle domain may be defined by Barycentric coordinates. Barycentric coordinates utilize three coordinates to identify any point within the triangle. For example the vertices of the triangle domain may be defined as u v w as described below in more detail. The location of any point within the triangle is defined by vertex weighting that indicates its proximity to a vertex. For instance the closer a point is to a vertex the higher its vertex weighting and the further away the point is from the vertex the lower its vertex weighting.

As an example assume the vertices of the triangle are defined with Barycentric coordinates u v w as follows 1 0 0 0 1 0 and 0 0 1 . In this example the center point is located at because the center point is equally distant from each of the vertices. Also with the given definition of the vertex coordinates in this example the sum of the u v and w coordinates for any point within the triangle domain should equal one.

The Cartesian and Barycentric coordinates are described for purposes of illustration only and should not be considered limiting. In other examples it may be possible to define the quad domain with Barycentric coordinates or Cartesian coordinates and the triangle domain with Cartesian coordinates or Barycentric coordinates. In general a domain of any type may be defined using any coordinate system.

Tessellation stage may tessellate e.g. divide the domain into a plurality of primitives. It should be understood that in this example tessellation stage is not dividing the patch outputted by hull shader stage into primitives but rather dividing the domain into the primitives. In some examples tessellation stage may not even have access to the patch outputted by hull shader stage . Tessellation stage may be a fixed function unit although aspects of this disclosure need not be so limited.

Tessellation stage may utilize the tessfactors outputted by hull shader stage to tessellate e.g. divide the domain into a plurality of primitives. For example in addition to defining the domain type e.g. triangle or quad the tessfactors may define how many rings are to be included within the domain.

A ring may be a series of concentric shapes within the domain where the concentric shapes are the same shape as the domain shape. For example if the domain shape is a quad the perimeter of the quad may be considered as the outer ring. Hull shader stage may define the number of inner rings which may be series of smaller sized quads that reside within the quad domain. Similarly if the domain shape is a triangle the perimeter of the triangle may be considered as the outer ring and the inner rings may be series of smaller sized triangles that reside within the triangle domain.

In addition to defining the number of rings within a domain the tessfactors define the points that reside along the rings. The points that reside along the rings should not be confused with control points. The control points define the patch. The points that reside along the rings are points generated by tessellation stage based on the tessfactors. These points are generated within the domain and not within the patch.

Also it is these points that tessellation stage connects together to divide the domain into a plurality of primitives. For example assume that the primitives that tessellation stage will divide the domain into are triangles. In this example tessellation stage may connect one point that resides along the outer ring with two points that reside along the inner ring to form a triangle primitive. Alternatively tessellation stage may connect two points that reside along the outer ring with one point that resides along the inner ring to form a triangle primitive. In this way by defining the domain type the number of rings within the domain and the number of points along the outer and inner rings hull shader stage may define the number of primitives into which tessellation stage should divide the domain.

In some examples the number of points that can reside along an edge of ring may be one point to 64. For example if the domain type is a triangle than there may be up to 64 points per edge of the triangle domain. Similarly if the domain type is a quad than there may be up to 64 points per edge of the quad. However the techniques described in this disclosure are not limited to an edge having a maximum of 64 points.

Furthermore the number of points that reside along a ring may be different for outer and inner rings. For example the number of points that reside along an edge of the outer ring may be more than or less than the number points that reside along an edge of the inner ring. It may also be possible that number of points that reside along the edge of the outer ring and the inner ring are the same number of points.

Moreover the number points along an edge of the same ring may be different. For example for a triangle domain the number of points that reside along one of the edges may be different than the number of points that reside along one other edge or both edges. Similarly for a quad domain the number of points that reside along one of the edges may be different than the number of points that reside along one two or all three other remaining edges. It may also be possible for each of the edges of the rings to have the same number of points.

As described above in some examples tessellation stage may not divide the patch into a plurality of primitives. Accordingly in some examples tessellation stage may not receive any information such as the number of control points the locations of the control points or the size of the patch. Without any information as to the size of the patch and the locations of the control points tessellation stage may not be able to define the size of the domain that is used or the specific coordinates for the vertices of the domain.

To address this tessellation stage may rely upon a normalized coordinate system for defining the vertices of the domain as well as for determining the locations of the interconnected points within the domain. For example in a quad domain each of four edges may be normalized from 0 to 1. Accordingly a normalized quad domain may include Cartesian coordinates u v of 0 0 1 0 0 1 1 1 . Similarly in an example of triangular domain each of three edges may be normalized from 0 to 1. Accordingly a normalized triangle domain may have Barycentric coordinates u v w of 0 0 1 0 1 0 1 0 0 . Additionally when using normalized Barycentric coordinates in the triangular domain the sum of each coordinate set is always one e.g. for 0 0 1 0 0 1 1 for 0 1 0 0 1 0 1 and for 1 0 0 1 0 0 1. Once an edge has been normalized the tessellation unit may determine the coordinates of each point of the edge based on the tessellation factor.

Tessellation stage may store coordinates of the points as defined based on the normalized coordinate system along each edge in one or more queues or buffers. The coordinates of the normalized points may be referred as point coordinates. For ease of explanation the term queues may refer to queues or buffers unless specified otherwise. In one example tessellation stage may enqueue point coordinates from an outer ring of the domain in one queue and the point coordinates of an inner ring of the domain in two separate queues. In another example tessellation stage may store both the point coordinates of the outer ring and the point coordinates of the inner ring in the same queue. Enqueue or enqueuing as used in this disclosure refers to a tessellation unit such as tessellation stage storing point coordinates in the queue or queues. After tessellation stage has stored the normalized points of the outer and inner rings in the single queue or the two separate queues tessellation stage may connect the points and remove the points from the queue s .

In this manner a tessellation unit such as tessellation stage may be configured to determine first outer ring point coordinates for a first point of an outer ring of the domain and determine first inner ring point coordinates for a first point of an inner ring of the domain. In this example the inner ring is inner to the outer ring within the domain.

The tessellation unit may enqueue the first inner ring point coordinates at a first location of a queue read the first inner ring point coordinates from the queue and read the first outer ring point coordinates from the queue when the outer ring is not an outermost ring. In this example the first outer ring point coordinates were previously enqueued in the queue when the outer ring was a previous inner ring. The tessellation unit may connect the first inner ring coordinates and the first outer ring coordinates each of which being read from the queue. The connection of the first inner ring coordinate and the first outer ring coordinates may be referred to as a stitching iteration.

For example as described above the domain may include a series of concentric rings. In this example the perimeter of the domain may form the outermost ring. The next outermost ring may form an inner ring to the outermost ring and may form an outer ring for the next concentric ring.

In some examples the points that reside along the outermost ring and the next outermost ring may be connected together to form a plurality of triangles in what is referred to as a first stitching iteration. Then in the next stitching iteration the points that reside along the next outermost ring may be connected with points that reside along the next concentric ring which is an inner ring to the next outermost ring.

In some examples described in this disclosure the point coordinates for the next outermost ring which is the case when the outer ring is not the outermost ring may have already been previously enqueued in the queue. For example these point coordinates may be been previously enqueued in the queue when the next outermost ring functioned as the inner ring to the outermost ring during the first stitching iteration. In this case the tessellation unit may not need to re determine the point coordinates for the points that reside along the next outermost ring and may be able to read the point coordinates from the queue.

Tessellation stage may output the vertices of the plurality of primitives of the domain to domain shader stage in the normalized coordinate system e.g. the u v coordinates or the u v w coordinates as applicable . The function of domain shader stage may be to map the vertex coordinates as received from tessellation stage on to the patch. For example while tessellation stage may not receive information of the patch as defined by hull shader stage domain shader stage may receive such information from hull shader stage .

Domain shader stage may execute for each vertex coordinate outputted by tessellation stage . With the coordinates of the control points of the patch from hull shader stage domain shader stage may determine the location of the vertex as outputted by tessellation stage on the patch. Because tessellation stage outputs vertices of the plurality of primitives generated by tessellation stage and domain shader stage adds these primitives to the patch the combination of hull shader stage tessellation stage and domain shader stage together add additional primitives to the patch. This results in a mesh of primitives that are added to the patch creating a higher resolution more detailed patch as compared to the patch defined by CPU . In this manner hull shader stage tessellation stage and domain shader stage implement a tessellation process.

Geometry shader stage receives the vertices of the primitives added to the patch by domain shader stage and may further generate additional vertices for the primitives to add even more resolution. Rasterizer stage receives the primitives from geometry shader stage and converts the primitives into pixels for the display. For example the primitives may be defined as vectors that indicate the interconnection of the primitives and may be defined in a coordinate space that is independent of the display on which the image is to be displayed. Rasterizer stage converts these vectors into the display coordinates and performs any additional functions such as removing points within primitives that are occluded.

Pixel shader stage receives the pixels as outputted by rasterizer stage and performs post processing to assign color values to each of the pixels that are to be displayed. For example pixel shader stage may receive constant values stored in system memory texture data stored in system memory and any other data to generate per pixel outputs such as color values. Pixel shader stage may also output opacity values that indicate the opaqueness of the pixels.

Output merge stage may perform any final pixel processing. For example output merge stage may utilize depth information to further determine whether any of the pixels should be removed from being displayed. Output merge stage may also perform blending operations to generate final pixel values.

Output merge stage may output the final pixel values to a frame buffer generally located within system memory but which may be located within GPU . A display processor not shown may retrieve the pixel values from the frame buffer and cause pixels of a display not shown of device to illuminate accordingly to the pixel values to cause the display to display the image.

As described above tessellation stage interconnects points of the outer and inner rings within the domain to generate a plurality of primitives within the domain. In accordance with techniques described in this disclosure tessellation stage may utilize one or more queues to store the points of the outer and inner rings which tessellation stage interconnects.

In some examples GPU may include queues such as first in first out FIFO queues and or buffers such as ring buffers that may be used solely for storing points of outer and inner rings. The queues may be coupled with tessellation stage in such a manner that tessellation stage may quickly access the contents of the queues. In some examples GPU may comprise local memory such as cache memory and the cache memory may store the queues. In some other examples system memory may store the queues. For purposes of bandwidth efficiency it may be desirable for the local memory of GPU to store the queues rather than system memory .

The specific way in which the points are to be connected may define how many points are to be read from each of the queues. For example assume that tessellation stage divides a quad domain into triangle primitives. In this example two points may be taken from a location of the queues that contains points from the outer ring and one point may be read from the location of the queues that contains points of the inner ring edge of the domain to form the triangle. In some examples when tessellation stage reads points from the queues tessellation stage may also remove dequeue or pop the read points from the queues. In another example tessellation stage may read one point from a location of one of the queues that contains points of the outer ring edge and may read two points from a location of one of the queues that contains points of the inner ring edge to form a triangle.

For stitching e.g. connecting points that reside along the outer and inner rings the outer ring edge and the inner ring edge may be parallel with one another. In other words the edges that are used for forming the primitives are corresponding edges in the outer and inner rings. For example when stitching primitives with points along the left edge of an outer ring of a quad domain tessellation stage may utilize the points along the left edge of the inner ring of the quad domain. The same may apply for the top bottom and right edges of the outer and inner rings.

In some examples the tessfactor that indicates the number of points that reside along the outer ring edge may define whether one queue may be used to hold the points that reside along both the inner and outer rings or whether two separate queues will be used to hold the points from the inner and outer rings. When two separate queues are used tessellation stage may regenerate the values of the point coordinates for the outer and inner rings for each stitching iteration.

For example as described above in some examples the points that reside along an outer ring when the outer ring is not the outermost ring may have been previously enqueued and therefore re determining the point coordinates may not be necessary. However this may not be the case in every example. In some examples the number of points that reside along a ring as indicated by the tessfactors may determine whether the points that reside along the outer ring and the inner ring should be stored in the same queue or two different queues. When stored in two different queues tessellation stage may regenerate the values of the point coordinates as described above.

If the tessfactors indicate that a number of points that reside along a ring that is inner to the outermost ring is greater than a threshold number of points tessellation stage may store the points in two different queues. If the number of points that reside along the outermost ring is less than or equal to the threshold number of points tessellation stage may store the points that reside on the inner and outer rings in a single queue. In some examples the queue may be a ring buffer. Tessellation stage may write the points the points that reside along an outer ring to the buffer at a location specified by an inner ring write pointer.

Tessellation stage may read the points of the outer ring buffer from a location of the ring buffer indicated by an outer ring pointer. Tessellation stage may read the points that reside along an inner ring from a location of the ring buffer indicated by an inner ring read pointer. The points of the inner ring and the outer ring may be logically separated from each other in the ring buffer by an end of ring value which tessellation stage may also store in the ring buffer.

Accordingly in some examples the techniques described in this disclosure may increase the computational efficiency of the graphics processing pipeline of GPU relative to the case where tessellation stage regenerates the point coordinates of both the inner and outer rings for each stitching iteration. Furthermore because tessellation stage may use only one queue rather than two separate queues when the outer ring is not the outermost ring to write and read the points of the domain the number of accesses to the queues the local memory of GPU or system memory may be reduced resulting in a reduction in power consumption and an increase in bandwidth efficiency. In a case where the queues comprise hardware queues tessellation stage may also be able to turn off or disable transistors associated with unused hardware queues resulting in decreased power consumption.

The OpenGL 4.x graphics processing pipeline may function in a substantially similar fashion as the Direct3D 11 graphics processing pipeline. Accordingly for purposes of brevity reference is made to to describe components that are similar to both the Direct3D 11 graphics processing pipeline and the OpenGL 4.x graphics processing pipeline.

As illustrated in the example of GPU includes input assembler vertex shader tessellation control shader primitive generator tessellation evaluation shader geometry shader clipping unit rasterizer fragment shader and post processor . Similar to in the example illustrated in GPU may include more or fewer components than those illustrated in . Also the specific ordering of the unit is provided for purposes of illustration and should not be considered limiting.

In some ways the tessellation process with the OpenGL 4.x graphics processing pipeline may be substantially similar to the tessellation process with the Direct3D 11 graphics processing pipeline. For example OpenGL 4.x tessellation process may rely upon patches and control points in the manner similar to that described above with respect to . For instance input assembler and vertex shader of may function substantially similar as input assembler stage and vertex shader stage of respectively.

As more examples for tessellation tessellation control shader of may function substantially similarly to hull shader stage of . However tessellation control shader outputs tessellation levels which may be analogous to the tessfactors of Direct3D 11. For example the tessellation levels of OpenGL 4.x may define the domain type the number of rings within the domain and the number of points per ring edge.

Primitive generator may function in a substantially similar manner as tessellation stage . For example primitive generator may utilize the tessellation levels and the domain type to divide the domain into a plurality of primitives.

Tessellation evaluation shader of may function substantially similarly to domain shader stage of . For example tessellation evaluation shader may receive the vertices of the generated primitives from primitive generator and add the primitive to the patch outputted by tessellation control shader . In this manner the graphics processing pipeline of the OpenGL 4.x API may perform tessellation on a patch to increase the resolution of the patch.

Geometry shader may function substantially similar to geometry shader stage . The combination of clipping unit and rasterizer in may function substantially similarly to rasterizer stage in . Fragment shader and post processor in may function substantially similar to pixel shader stage and output merge stage in respectively. Post processor may output the final pixel values to a frame buffer and the display processor may retrieve the pixel values from the frame buffer and cause a display to illuminate according to the pixel values to display the image.

As described above tessellation control shader primitive generator and tessellation evaluation shader of function substantially similar to hull shader stage tessellation stage and domain shader stage of respectively for implementing the tessellation process. Accordingly both the Direct3D 11 and the OpenGL 4.x APIs rely upon two programmable shader units and one fixed function unit to implement the tessellation process.

For purposes of generality the techniques described in this disclosure may be described with a first tessellation shader unit a tessellation unit and a second tessellation shader unit. Examples of the first tessellation shader unit include hull shader stage and tessellation control shader . Examples of the tessellation unit include tessellation stage and primitive generator . Examples of the second tessellation shader unit include domain shader stage and tessellation evaluation shader .

Also Direct3D 11 uses the term tessfactors and OpenGL 4.x uses the term tessellation levels which may be considered analogous terms. For purposes of generality this disclosure uses the term tessellation factor examples of which include tessfactors and tessellation levels. In this way the first shader unit may be considered as outputting tessellation factors to the tessellation unit and the tessellation unit may output vertices to the second shader unit in response to the tessellation factors.

It should be noted that while the Direct3D 11 and OpenGL 4.x utilize two shader units and one fixed function unit the techniques described in this disclosure are not so limited. For example it may be possible in other systems for the first and second shader units to be fixed function units and the tessellation unit to be a shader unit. As another example all may be fixed function units or all may be shader units or any combination thereof.

Therefore in some examples it may be considered that a first unit performs functions similar to the first shader unit but may be a shader unit or a fixed function unit a second unit performs functions similar to the tessellation unit but may be a shader unit or a fixed function unit and a third unit performs functions similar to the second shader unit but may be a shader unit or a fixed function unit. Moreover although the first shader unit the tessellation unit and the second shader unit are illustrated as separate units in aspects of this disclosure are not so limited. These units and possibly any unit of the graphics processing pipelines illustrated in may be combined together into a common unit. Accordingly while the functionality of these units is described separately for ease of description these units may be implemented in shared hardware or as distinct components.

In triangle domain includes outer ring inner ring and inner ring . Outer ring includes outer ring edge and inner ring includes inner ring edge . Outer ring edge and inner ring edge are parallel with one another. In aspects described in this disclosure the tessellation unit may interconnect i.e. stitch points along outer ring edge with the points along inner ring edge . For example the tessellation factors may define the number of points that reside along outer ring edge and the number of points that reside along inner ring edge . As indicated in there is an addition inner ring which is inner to inner ring edge .

During each stitching iteration the tessellation unit may determine the points along an outer edge and an inner edge. The tessellation unit may store the points in one or more queues. The tessellation unit may read the generated points from the queues and interconnect the points. The tessellation unit repeats this process for each ring of the domain until the points from the rings have been connected.

As an example in a first stitching iteration tessellation stage may begin determining the coordinates of the points along outer ring and inner ring . The tessellation unit may store the coordinates for the points e.g. point coordinates in one or more queues as the point coordinates are determined. The tessellation unit may read the outer ring point coordinates from the queues and the inner ring point coordinates from the queues and may interconnect the points together.

After generating the primitive whose vertices reside along outer ring edge and inner ring edge the tessellation unit may advance to the other two edges of outer ring and inner ring in a clockwise fashion in this example. For each of these edges of outer ring and inner ring the tessellation unit may determine the points along each edge. Each point may be comprised of coordinates of the normalized coordinates system. The tessellation unit may store the point coordinates in the queues read the points from the queues and interconnect the points.

In some examples after the tessellation unit completes the stitching of the primitives whose vertices reside along outer ring and inner ring the tessellation unit may proceed with the next inner ring. In this case inner ring becomes the outer ring and the ring following inner ring becomes the inner ring and the process of determining points along each edge storing the points in the queues and connecting the points repeats until upon progressively proceeding inward until there are no more rings.

During the first stitching iteration the tessellation unit may store the points of outer ring and inner ring in separate queues. In subsequent stitching iterations in some but not all examples as described below the tessellation unit may store the points of the inner and outer rings in the same queue. For example in the next stitching iteration ring becomes the outer ring and ring becomes the inner ring. In this example the point coordinates for ring were previously enqueued e.g. stored in the queue during the first iteration and the tessellation unit may store the point coordinates for the points along ring which is the inner ring in this iteration within the same queue in which the tessellation unit stored the point coordinates for ring which is the outer ring in this iteration and the inner ring the previous iteration. In this manner the tessellation unit may also reuse the inner ring points stored in the queue in a previous stitching iteration as outer ring points in a subsequent stitching iteration.

In some alternate examples it may not be necessary for the tessellation unit to always store the point coordinates for the inner and outer ring is the same queue. In these alternate examples the tessellation unit may utilize the tessellation factors to determine whether to utilize a single queue or two separate queues when storing the points of the inner and outer rings of the domain.

For instance the tessellation factors may define how many points along outer ring and how many points along inner ring the tessellation unit should interconnect to form the primitives whose vertices reside along outer ring and inner ring . If the number of points on inner ring is greater than a threshold number of points the tessellation unit may use two queues to store the inner and outer ring points.

Storing point coordinates in different queues based on a threshold number of points may be beneficial in terms of the amount of needed memory for storing the point coordinates. For example if the number of points along one of or both ring and ring i.e. the outer ring and inner ring respectively in this example is relatively large then the size of queue may be relatively large so that the queue can store the point coordinates for ring and ring . By utilizing two queues based on when the number points is greater than a threshold value it may be possible to size the two queues in such a way that the total size of the two queues is less than the size of a single queue.

In other words if the number of points on inner ring is greater than the threshold number of points issues in terms of memory area and or power for a queue that could hold a number of points greater than the threshold number of points may be relatively large. Accordingly when the number of points on inner ring exceeds the threshold the tessellation unit may simply store points from an outer ring such as outer ring in one queue and the points from an inner ring such as inner ring in a separate different queue. In this example the points from inner ring which were determined in a previous stitching iteration may not be reused as the points of an outer ring in a subsequent iteration.

In this example if the number of points on inner ring is less than the threshold and the outer ring is not the outermost ring of the domain the tessellation unit may use a single queue to store both the points of the inner ring and the outer ring. The single queue may be large enough to store all the points generated for one ring such that the tessellation unit may reuse the previously determined points of an inner edge as points along an outer edge in a subsequent stitching iteration. In the subsequent iteration the tessellation unit may read the inner ring points of the previous stitching iteration from the single queue connect the points and remove them from the queue after connecting them.

During a first stitching iteration when the outer ring is the outermost ring e.g. when outer ring is the outer ring and ring is the inner ring the tessellation unit may utilize two different queues to store the points of the outer ring and the points of the inner ring. If the number of points that reside on inner ring is less than or equal to the threshold number of points the tessellation unit may store the points of both the inner and outer rings in the same queue for subsequent iterations i.e. iterations where the outer ring is not outer ring . If the number of points that reside on the ring that is inner to the outermost ring e.g. ring is greater than the threshold number of points the tessellation unit may use two different queues to store the points of the inner and outer rings as described above.

The tessellation unit may perform similar function on quad domain . For example in quad domain includes outer ring and inner ring . As illustrated there is another inner ring i.e. ring which is inner to inner ring . Outer ring includes outer ring edge and inner ring includes inner ring edge . Outer ring edge and inner ring edge are parallel with one another and the points along these edges may form primitives e.g. may be vertices of the primitives .

Similar to the example of the tessellation unit may utilize one queue or two different queues to store the points generated along ring and ring . The tessellation factors for inner ring edge may determine whether the tessellation unit uses one or two queues to store the points from the two rings. In one example if the number of points that reside on inner ring is less than or equal to the threshold number of points the tessellation unit may use one queue to store the points of the inner and outer rings such as inner ring which may also be an outer ring in some iterations and inner ring . In another example the tessellation unit may use a single queue to store the points of the inner and outer rings regardless of the number of points that reside along inner edge when the outer ring is not the outermost ring outer ring . The tessellation unit may connect e.g. stitch the points of the outer and inner rings utilizing any technique for determining which points along the outer ring and which points along the inner ring.

After generating the primitive whose vertices reside along outer ring edge and inner ring edge the tessellation unit may advance to the other two edges of outer ring and inner ring in a clockwise fashion in this example. Based on the number of number of points along each edge which may be defined by one or more tessellation factors the tessellation unit may determine whether to use one queue or two separate queues to store the points along the inner and outer rings. In some examples after the tessellation unit completes the stitching of the primitives whose vertices reside along outer ring and inner ring the tessellation unit may proceed with the next inner ring. In this case inner ring becomes the outer ring and the ring following inner ring i.e. ring becomes the inner ring and the process of storing i.e. enqueueing points in the one or more queues reading the points from the queues and connecting the one or more points repeats until upon progressively proceeding inward there are no more rings.

Tessellation unit may include setup unit point generator and connectivity generator which may be fixed function hardware units of tessellation unit . Setup unit point generator and connectivity generator are illustrated as separate components for ease of description. Setup unit point generator and connectivity generator may be formed as a single unit as separate units or a combination thereof. Queues A and B queues are illustrated as being within point generator for ease of illustration. However queues may reside within connectivity generator as separate hardware that sits between point generator and connectivity generator within tessellation unit within the local memory of GPU or system memory .

Setup unit may receive the tessellation factors as input from a first shader unit such as hull shader stage of and tessellation control shader and may determine the domain type from the tessellation factors. For example if there are four tessellation factors setup unit may determine that the domain type is a triangle and if there are six tessellation factors setup unit may determine that the domain type is a quad. Setup unit may perform other setup functions such as correcting rounding problems ceiling and floor functions determining half tessellation factors and reducing and combining tessellation factors. In general setup unit may process the tessellation factors to ensure that the other components of tessellation unit can perform respective functions.

Point generator may determine how many points reside along each edge of each ring of the domain from the tessellation factors and the locations of the points e.g. the u v coordinates or the u v w coordinates of the points . Based on the number of points along the outermost ring of the domain point generator may determine whether to use separate queues for the outer and inner rings during the stitching process or whether to use a single queue to store the points of the rings such that the points from the inner ring of a previous iteration may be reused in a subsequent stitching iteration as the points of the outer ring. Connectivity generator may connect i.e. stitch the points to form a plurality of primitives in the domain such as those illustrated in .

According to empirical data in 10 of cases the number of points on the ring inner to the outermost ring e.g. ring may be greater than 32 points. Accordingly 90 of the time the number of points on inner ring may be less than or equal to the threshold number of points and point generator and connectivity generator may utilize only a single queue to store the points that reside along inner rings etc. Using only the single queue may provide various advantages as described above.

For example point generator may determine coordinates of points along an outer ring such as outer ring and outer ring of respectively and coordinates of points along an inner ring such as inner ring and inner ring of respectively. In some examples point generator may store the determined coordinates in queues A and B. For example queue A may store the coordinates of points along the inner ring edge and queue B may store the coordinates of points along the outer ring edge.

As point generator determines the coordinates of points point generator may store the points in one or more of queues . In some examples queues may be limited in size. That is queues may store no more than a certain maximum number of points. In some examples the maximum capacity of the queue A may be the same as or different from the maximum capacity of queue B. If one of queues is currently storing the maximum number of points i.e. there is no available space in the queue point generator may not store any more points in the queue until points are removed from the queue e.g. by connectivity generator as described below.

In one example tessellation unit may store the points from the inner ring in queue A and the points of an outer ring in queue B. If queue A is full point generator may not store any more points in the first queue but may continue to generate points of the outer ring and to store the points of the outer ring in queue B until queue B is full. The reverse may also be true i.e. if queue B is full but queue A is not full point generator may not store points of the outer ring in queue B. However point generator may continue to generate points of the inner ring and may store the points of the inner ring in queue A.

For each edge of the outer ring that is parallel with an edge of the inner ring connectivity generator may determine how the points of the outer ring edge should connect with the points of the inner ring edge to form primitives. For instance there may be at least two different ways in which points along the outer ring edge and the points along the inner ring edge can form triangles. As one example connectivity generator may form a triangle using two points from the outer ring edge and one point from the inner ring edge and connect them together to form a triangle. As another example connectivity generator may form a triangle using two points from the inner ring edge and one point from the outer ring edge to form the triangle.

Connectivity generator may determine how the coordinates of the points stored in queues should be utilized to form the primitives. In some examples there may be specific predefined ways in which connectivity generator should connect the points for a given number of points along the outer ring edge and a number of points along the inner ring edge.

Based on the determination of how to connect the points stored in queues and based the determination of point generator of how many of queues should be used connectivity generator may read points from one or more of queues . In one example connectivity generator may read multiple points from one queue and a single point from the other queue. In another example connectivity generator may read inner ring and outer ring points from queues . In some examples reading one or more points from queues may remove the points from queues . In other examples points read from queues may remain in queues for future reuse for example as an outer ring point in a subsequent stitching iteration. Connectivity generator may repeat these steps until connectivity generator generates a predetermined number of primitives.

In this manner connectivity generator may determine how many points of the outer ring and how many points of the inner ring edge to use to generate each of the plurality of primitives. The shader unit after the tessellation unit e.g. domain shader or tessellation evaluation shader uses the resulting plurality of primitives in the domain to add primitives in the patch. The resulting patch with the additional primitives is then further processed through the graphics processing pipeline and ultimately rasterized to render an image.

In some examples outer ring queue may hold a maximum of four points and inner ring queue may hold a maximum of 260 points. Inner ring queue may hold 260 points so that inner ring queue may hold the maximum number 256 of points for a ring and may still have capacity for four additional points. Although inner ring queue is illustrated as having room for four additional points inner ring queue may have room for as little as two additional points as well as room for more than four additional points in some examples. The room in inner ring queue for four additional points may allow the maximum of two points to be read from or written to inner ring queue while still providing additional buffer space. Each edge of a domain may have up to 64 points. For a triangle domain there may be a maximum of 64 3 192 points that may reside on a ring. For a quad there are four edges meaning there is a maximum of 64 4 256 points that may reside on a ring. Thus by having a queue of size 260 points the maximum number of points for a ring may be stored in the queue as well as four additional points of a subsequent ring. The maximum point storage capacities of outer ring queue and inner ring queue are described merely for the purposes of example and should be considered as non limiting examples. Different maximum capacities of points may also possible for each of outer ring queue and inner ring queue .

If the outer ring of the domain is an outermost ring point generator may store or enqueue the points of the outer ring in outer ring queue . However if outer ring queue is full i.e. is currently storing the maximum of 4 points point generator may wait for outer ring queue to have available space before enqueueing additional points in outer ring queue . Although outer ring queue is illustrated as having a maximum capacity of four points outer ring queue may also store as few as two points or a number greater than four points.

In general point generator may enqueue points at the head of outer ring queue or at the head of inner ring queue . Each of outer ring queue and inner ring queue may keep track of the number of points in each of the queues so that connectivity generator reads the first enqueued point i.e. the point that has been in the queue the longest from the tail of the outer ring queue or the tail of the inner ring queue . Because tail of inner ring queue indicates a location of the queue that contains outer ring points tail may also be referred to as an outer ring pointer.

When connectivity generator reads one or more points from outer ring queue the one or more points may also be removed from the queue and more points may again be stored in outer ring queue . Responsive to removing one or more points from one of the outer ring queues the tail of the queue is set to the location of the outer ring queue containing a subsequently determined point. If no points are in the outer ring queue the location indicated by the tail may be set to the head of the queue.

Connectivity generator may also read inner ring queue from the location of inner ring pointer . Inner ring pointer may generally indicate a location of inner ring queue that contains the first inner ring point which point generator has enqueued but which has not been interconnected with one or more points of an outer ring. After reading an inner ring point from inner ring pointer inner ring pointer may be set to the next subsequently enqueued inner ring point which has not been connected to one or more outer ring points. When one or more points are read from the location of inner ring pointer the points are not removed from the queue. Rather the points remain in inner ring queue for later reuse as outer ring points in a subsequent stitching iteration. Also if after reading the one or more points from the location indicated by inner ring pointer there are no more points in inner ring queue the inner ring pointer may be set to the head of inner ring queue .

In some examples outer ring queue and inner ring queue may comprise first in first out queues FIFOs . A FIFO is a particular type of queue in which items are added to the head of the queue and removed from the tail of the queue. The effect of the FIFO is that items that are enqueued first are generally the first to be removed or dequeued from the queue.

The process of stitching with respect to begins with point generator determining the coordinates for an outer ring. If the outer ring is an outermost ring point generator may enqueue the points of the outer ring at the head of outer ring queue and enqueue the inner ring points at the head of inner ring queue . Connectivity generator may read one or more points from the tail of the outer ring queue and may read one or more inner ring points from the inner ring pointer of inner ring queue . The read outer ring points are removed from outer ring queue after reading the points from the tail of outer ring queue . The inner ring points stored in inner ring queue remain i.e. are not removed and are kept for reuse in subsequent iterations. Connectivity generator may interconnect the one or more outer ring points and the one or more inner ring points.

At the beginning of a subsequent iteration point generator sets the location of the inner ring pointer to the head of the inner ring queue . The tail or outer ring pointer is set to the first enqueued inner ring point of inner ring queue . Connectivity generator may read one or more inner ring points from the location of inner ring pointer . Connectivity generator may read one or more outer ring points from the location of inner ring queue indicated by tail pointer or outer ring pointer . As described above inner ring pointer is updated to a location of inner ring queue containing a subsequently determined and enqueued inner ring point. Tail outer ring pointer is updated to a location of inner ring queue containing a subsequently generated and enqueued outer ring point. Any points read from tail are removed from inner ring queue . Connectivity generator may connect the points read from outer ring queue and inner ring queue .

In the example of outer ring queue may store a maximum of 4 points and ring buffer may store a maximum of 36 points. The maximum storage capacity of outer ring queue and ring buffer are illustrated for the purposes of example and other maximum storage capacities may be possible for either queue. The maximum storage capacity of ring buffer may be chosen such that the maximum number of points of the outermost edge of the domain does not exceed the maximum storage capacity of ring buffer for a certain percentage of domains tessellated and such that some additional storage capacity is available for storing inner ring points. In the example of ring buffer may be configured to store 32 points from a previous stitching iteration for reuse in a subsequent iteration. In addition to the storage capacity used to store previously generated points ring buffer may also include four points of storage capacity for newly generated points of an inner ring.

If the number of points on the outermost ring of the domain is less than or equal to the threshold outer ring queue and ring buffer may operate similarly to the implementation of outer ring queue and inner ring queue illustrated in . Point generator may enqueue and connectivity generator may read the points of the outer ring with outer ring queue and the inner ring points with ring buffer when the outer ring is an outer most ring i.e. during the first stitching iteration .

During subsequent iterations i.e. when the outer ring is not the outermost ring ring buffer stores the inner ring points for use in a subsequent stitching iteration as points of the outer ring. Ring buffer may comprise a data structure that uses a single fixed size buffer as if it were connected end to end. In the example of point generator stores the inner ring points at a location of ring buffer specified by an inner ring write pointer . At the beginning of each iteration inner ring write pointer begins at a location of ring buffer immediately after the end of ring indicator EOR . After each point is written to ring buffer the inner ring write pointer advances one location in the buffer. If the pointer reaches the end of the buffer the pointer wraps around to the beginning of the buffer.

While point generator is writing to ring buffer connectivity generator may read one or more inner ring points and or outer ring points from ring buffer from the locations indicated by an inner ring read pointer and outer ring read pointer . At the beginning of each stitching iteration inner ring read pointer begins immediately after to the right of in the EOR. When connectivity generator reads an inner ring point from the location of inner ring read pointer the inner ring read pointer advances to the right in the example of to a location of a subsequently written inner ring point. Connectivity generator may read inner ring points from the location of the inner ring read pointer until inner ring reaches the location of inner ring write pointer . When inner ring read pointer reaches the location of inner ring write pointer there may be no more inner ring points to be read from ring buffer and connectivity generator may not read more inner ring points from ring buffer .

Connectivity generator may read outer ring points from the location of specified by outer ring read pointer . At the beginning of each stitching iteration the outer ring read pointer begins at the location of the EOR of the previous stitching iteration. After connectivity generator reads an outer ring point the outer ring read pointer advances to a subsequently enqueued outer ring point. Connectivity generator may continue to read points from the location of the outer ring read pointer until all outer ring points have been read which may be indicated by the outer ring read pointer pointing to the same location as the EOR . As detailed above point generator may write inner ring points to the location of write pointer . However point generator may not write points to the location of the inner ring write pointer if the inner ring write pointer points to the location of the outer ring read pointer as any writes to ring buffer would overwrite previously stored outer ring points that have not already been read.

Once connectivity generator has read and connected all the points from the inner and outer rings the EOR is set to the location of ring buffer immediately after inner ring write pointer . Point generator and connectivity generator may repeat the process of connecting the points of an inner ring and an outer ring until all the point of the inner and outer rings of the domain have been connected.

If the number of points on the outermost ring of the domain exceeds the threshold number of points outer ring queue and ring buffer may operate similar to outer ring queue and inner ring queue of . If the number of points on the outer most ring exceeds the threshold number of points point generator may enqueue outer ring points at head of outer ring queue and may enqueue inner ring points of the domain at the location of ring buffer indicated by inner ring write pointer .

In the case where the threshold number of points is exceeded ring buffer operates as a FIFO queue. Writes to the location of the inner ring write pointer are always at the head of the ring buffer indicated by inner ring write pointer . Reads from ring buffer always occur at the tail of the ring buffer which is indicated by inner ring read pointer . For each additional point that is stored in ring buffer inner ring read pointer points to the location of the first enqueue inner ring point. Inner ring write pointer points to the head of the ring buffer . Reading one or more coordinates from the location of the inner ring read buffer removes the one or more inner ring coordinates from ring buffer and updates inner ring read buffer . No coordinates are stored for reuse in subsequent stitching iterations. Outer ring read pointer is not used and no outer ring points are stored in ring buffer when the number of outermost ring coordinates exceeds the threshold number of coordinates.

After reading the outer ring and inner ring coordinates from outer ring queue and ring buffer connectivity generator may interconnect the points of the inner and outer rings. The process of connecting the rings may be repeated until connectivity generator has connected all the points of all the inner and outer rings of the domain.

In point generator may be configured to determine a number of outer ring point coordinates for a point of an outer ring of the domain . Point generator may also determine a number of inner ring point coordinates for a point of an inner ring domain where the inner ring is inner to the outer ring within the domain. Point generator may enqueue the inner ring point coordinates at a location of a queue such as inner ring queue .

Connectivity generator may read the inner ring point coordinates and the outer ring point coordinates from inner ring queue . The outer ring point coordinates may have previously been enqueued in inner ring queue when the outer ring was a previous inner ring.

Connectivity generator may connect the inner ring coordinates and the outer ring coordinates read each of which being read from inner ring queue . In some examples outer ring queue and inner ring queue may comprise first in first out queues FIFOs . In some examples outer ring queue may be configured to store a maximum of 4 point coordinates and inner ring queue may be configured to store a maximum of 260 point coordinates.

In some examples connectivity generator may read the outer ring point coordinates from a location of inner ring queue indicated by an outer ring pointer. Connectivity generator may read the inner ring point coordinates from a location of the queue indicated by an inner ring pointer.

In some examples the inner ring point coordinates may comprise first inner ring point coordinates and the location of inner ring queue indicated by the inner ring pointer may comprise a first location of the queue inner ring queue . Point generator may set the inner ring pointer to a second location of inner ring queue that contains second inner ring pointer coordinates after connectivity generator reads the first inner ring point coordinates form the first location of inner ring queue indicated by the inner ring pointer. Connectivity generator may read the second point coordinates from the second location of inner ring indicated by the inner ring pointer.

Connectivity generator may read all the outer ring point coordinates from inner ring queue . After connectivity generator reads all the outer ring point coordinates point generator may set the outer ring point to the location of inner ring queue that contains the inner ring point coordinates. In some examples all of the inner ring coordinates and the outer ring coordinates may be stored in inner ring queue .

When the outer ring is an outermost ring inner ring queue may comprise a first queue the location of inner ring queue may comprise a first location of the first queue point generator may enqueue the first outer ring point coordinates at a second location of a second queue such as outer ring queue and connectivity generator may read the first outer ring point coordinates from a second location of a second queue. To connect the first inner ring coordinates and the second ring coordinates connectivity generator may connect the first inner ring coordinates from the first location of inner ring queue and the first outer ring coordinates from the second location of outer ring queue .

In some examples connectivity generator may read the outer ring point coordinates from outer ring queue when the outer ring is an outermost ring by removing the outer ring point coordinates from outer ring queue when the outer ring is an outermost ring. To read the inner ring point coordinates from the first queue when the outer ring is an outermost ring connectivity generator may remove the inner ring point coordinates from inner ring queue when the outer ring is an outermost ring.

In point generator may be configured to determine a number of outer ring point coordinates for a point of an outer ring of the domain . Point generator may also determine a number of inner ring point coordinates for a point of an inner ring domain where the inner ring is inner to the outer ring within the domain.

Point generator may enqueue the inner ring point coordinates at a first location of a first queue such as ring buffer . Point generator may enqueue the outer ring point coordinates at a second location of a second queue such as outer ring queue when the outer ring is not the outermost ring and when a number of points along the outermost ring is less than or equal to a threshold . Ring buffer may comprise a first queue and point generator may may enqueue the outer ring point coordinates at a first location of a second queue such as outer ring queue when the outer ring is the outermost ring or when the number of points along the outermost ring is greater than a threshold .

Connectivity generator may read the inner ring point coordinates from the first location of the first queue ring buffer . Connectivity generator may read the outer ring point coordinates from the second location of the first queue ring buffer when the outer ring is not the outermost ring and when the number of points along the outer most ring is less than or equal to the threshold . Connectivity generator may read the outer ring point coordinates from the first location of the first queue outer ring queue when the outer ring is not the outermost ring and when the number of points along the outer most ring is less than or equal to the threshold . Connectivity generator may connect the inner ring point coordinates and the outer ring point coordinates .

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

