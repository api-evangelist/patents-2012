---

title: Rendering components within different browser environments
abstract: Embodiments of the invention relate to rendering components within different browser environments. A request for a portal page is received from a client system. The portal page is aggregated by a computer and a renderer is selected based on a client system browser specific environment. A browser specific markup, provided by at least one portlet, is transmitted from the renderer to the client system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09143378&OS=09143378&RS=09143378
owner: International Business Machines Corporation
number: 09143378
owner_city: Armonk
owner_country: US
publication_date: 20120420
---
The present application claims priority to European Application No. 11172326.8 filed Jul. 1 2011 the contents of which are herein incorporated by reference in its entirety with all the benefits accruing therefrom under 35 U.S.C. 119.

The present invention relates generally to computers and more specifically to rendering components within different browser environments.

In general a rich web user interface involves several different concepts of rendering web content within a browser. Two of the fundamental concepts are client side aggregation of web pages and server side aggregation of web pages.

Server side aggregation is characterized by having a server performing the aggregation of pages and content into a full page which is sent to the browser. Any dynamic components are executed on the server side. Typical dynamic components are portlets based on the specification Java Specification Request 286 JSR286 for example. Java and all Java based trademarks and logos are trademarks or registered trademarks of Oracle and or its affiliates. 

Client side aggregation is characterized by doing the final aggregation of pages and content within the browser itself. The server provides page fragments page feeds etc. Dynamic components such as widgets are executed on the browser side. Typical components are described in the specifications for iWidgets Open Social etc.

These two concepts have different programming models. Having components and pages which support both programming models at the same time is difficult. It is especially hard to optimize both the rendering at the server and the client side while at the same time exploiting each side s best capabilities.

U.S. Pat. No. 7 685 603 B2 Selecting Client Adapters by Singler et al. discloses methods and apparatuses including computer program products for selecting client adapters. In the disclosed system a client abstraction layer identifies one or more selection data elements in a client request and selects an adapter to communicate with the client based on the selection data elements. Each selection data element specifies an adapter type a client type or data describing the client. The adapter may be selected based on a multi stage selection process that involves performing an adapter request process for selecting an adapter based on the selection data elements that specify the adapter type. If the adapter request process fails to select an adapter then a client identification process for selecting an adapter based on the selection data elements that specify the client type is performed. If the client identification process fails to select an adapter a client description process for selecting an adapter based on the selection data elements that specify data describing the client is performed.

Embodiments include a method system and computer program product for rendering components within different browser environments. A request for a portal page is received from a client system. The portal page is aggregated by a computer and a renderer is selected based on a client system browser specific environment. A browser specific markup provided by at least one portlet is transmitted from the renderer to the client system.

The above embodiments as well as additional purposes features and advantages of the present invention will become apparent in the following detailed written description.

In the embodiment of the client browser requests one of the portal pages by sending a request e.g. a hypertext transfer protocol HTTP get request to the portal server . The requested portal page i.e. one of the portal pages is addressed via a uniform resource locator URL . Upon receiving the request the portal server decodes the incoming URL to determine which of the portal pages is to be rendered.

Before starting the modeling process S the portal framework of the portal server determines the render mode of the selected portal page using a target selection module . This decision is made based on the capabilities of the client browser and model information that includes metadata of the requested portal page.

The selected render mode i.e. one of the render modes of the requested portal page is determined by inspecting the metadata that is associated with the requested portal page. The page metadata is one or more parameters that are stored in a portal database. One parameter of the metadata specifies the proper render mode of the requested portal page. The selected render mode is set by a portal administrator when the portal page requested portal page is created.

The capabilities of the client browser are analyzed to check if the selected render mode may be used. In order to determine the capabilities of the client browsers the client browser is identified. This is done by inspecting a user agent header which is sent together with a HTTP get request e.g. User Agent Mozilla 4.0 compatible MSIE 7.0 Windows NT 5.1 Trident 4.0 .NET CLR 2.0.50727 .NET CLR 3.0.4506.2152 .NET CLR 3.5.30729 .

The concrete capabilities of the client browser are looked up in the portal database. If the selected render mode is client side aggregation CSA the client should be a modern web browser which supports JavaScript and fulfills the JavaScript performance requirements that are required to support a highly dynamic web page e.g. web 2.0 code compatible . If the client capabilities are not sufficient to support a highly dynamic web page the portal server page renderer applies server side aggregation SSA .

After determining the render mode the respective portal page renderer i.e. one of the portal page renderers is executed to initiate the rendering of the requested portal page during the rendering process S. For client side aggregation rendering the page renderer is executed and produces a page skeleton markup that contains sections which are filled by the client browser through separate requests. For server side aggregation the page renderer produces a complete markup representation of the requested portal page which includes the markup . . . . . . . of all portlets of the requested portal page. A corresponding page model is created during a modeling process S.

On the portal server all of the page components are represented as portlets . How the portlets are rendered is determined by the portal framework and the selected portlet. The portlets may influence the rendering decision by providing an artifact that is optimized for the respective client side component runtime. For a SSA the selected portal page is aggregated and rendered on the portal server during the aggregation process S and the rendering process S. Accordingly the page rendering process S directly invokes the portlets to request their markup . . . . . . .. For a CSA the portal framework checks if the portlets provide an optimized and or native implementation that may be directly executed in the client side component runtime. For example if an iWidget runtime is present on the client browser the portal framework checks to see if the selected portlet provides a native iWidget implementation. If it does the iWidget of the selected portlet is returned.

During the rendering S the portlet may determine based on for example the Java portlet API if an iWidget is requested or not PortletRequest getResponseContentType . If the iWidget mime type is requested the portlet produces a markup that includes iWidget specific microformats which are understood by the iWidget runtime that resides in the client browser .

The decision about the concrete mime type is made by the portal page renderer that has been selected by the portal framework based on the capabilities of the client runtime i.e. the CSA . If the client runtime only supports iWidgets the portal page renderer of requests the portlet markup for the iWidget mime type.

In an embodiment this process is realized using a portlet filter which is executed in front of each portlet . The portlet filter is responsible for checking to see if the portlet natively supports the iWidget runtime by inspecting its deployment descriptor . If the portlet provides its own iWidget implementation the portlet filter calls the portlet directly and passes the iWidget mime type to the portlet . If not the portlet will be directly wrapped into an iWidget by invoking an iWidget microformat service . The latter approach is realized using a web services for remote portlets WSRP based portlet iWidget wrapper for example and is discussed below with regard to .

At block one of the portal pages is requested from the portal server by the client browser . At block the requested portal page is aggregated by the portal server . At block the portal server chooses an appropriate renderer from the portal renders based on a browser specific environment. At block the chosen renderer delivers one of the browser specific markups . . . . . . . which is provided by the at least one portlet . . .

In an embodiment a user navigates to a portal page for example to a portal page P with two portlets on it a portlet A . and a portlet B .. Upon receiving the navigation event triggered by the user a navigation iWidget sends an HTTP get request to the portal server to get a markup representation of the portal page P.

Upon receiving the incoming request by a portal servlet the portal server invokes the page renderer which is responsible for aggregating the page markup. The page renderer requests the markup for portlet A . and portlet B . from the portlet runtime. For a CSA page the portlet filter intercepts the markup requests for portlet A . and B .. Instead of calling the portlets to get their real markup the portlet filter invokes the iWidget microformat service to produce an HTML microformat as specified in the iWidget specification.

Upon receiving the markup at the client browser a live text parser detects the iWidget microformats in the markup of the portal page P and invokes the registered handler that is responsible for processing iWidget microformats i.e. the iWidget Handler .

The iWidget handler instantiates the two iWidgets . and . representing portlet A and portlet B respectively and registers them with the client browser iWidget runtime . The instantiated iWidgets are called portlet iWidgets because they are used to wrap portlets.

In addition the iWidget handler initializes the created portlet iWidgets . . by requesting their iWidget definition. The URL to request the iWidget definition is part of the iWidget HTML microformat. The iWidget handler sends two HTTP get requests to a portal representational state transfer REST servlet to get the iWidget definitions for portlet A . and B ..

On the portal server the incoming requests are processed by an iWidget definition service . The iWidget definition service is responsible for generating an iWidget definition for a given portlet A . B .. The iWidget definition service generates the iWidget definition by inspecting the portlet deployment descriptor . . and mapping the information found to the corresponding iWidget concepts. For example the portlet event definitions are mapped to corresponding iWidget event definitions the supported portlet modes are mapped to the corresponding iWidget modes and the definition of public render parameters are mapped to a corresponding shared item set definition as specified in the iWidget specification. In addition to inspecting the portlet deployment descriptor . . the iWidget definition service adds additional information to the iWidget definition. For example it includes links to all JavaScript resources that are needed to run the iWidget on the client browser . The resources that are needed by the portlet iWidget . . include a client side WSRP consumer which is able to communicate with a server side portlet . ..

After receiving the iWidget onView event which is an event triggered when the iWidget is loaded by a browser the portlet iWidget . . calls the Client side WSRP consumer to request the portlet markup from the portal server . The client side WSRP consumer sends a WSRP getMarkup operation to a WSRP REST proxy which runs on the portal server using an HTTP get request.

The WSRP REST proxy is responsible for translating the incoming REST based WSRP message received from the client side WSRP consumer into a corresponding WSRP simple object access protocol SOAP message. After translating the incoming request the WSRP REST proxy forwards the SOAP based WSRP message to a WSRP producer .

The WSRP producer invokes the portlet . . to get its markup and creates a WSRP getMarkup response. The response is passed back to the WSRP REST proxy . After retrieving the HTTP caching headers from the WSRP getMarkup response the response is passed back to the client side WSRP consumer .

Upon receiving the WSRP response from the portal server the client side WSRP consumer interprets the response. For a getMarkup response the client side WSRP consumer retrieves the portlet markup from the message parses the markup for URL rewriting purposes and passes the processed markup back to the portlet iWidget . .. The portlet iWidget . . injects the portlet markup into a document object model DOM that is displayed by the client browser . The URL rewriting step mentioned above ensures that any interaction with the portlet e.g. by clicking on a link is mapped to an invocation of the client side WSRP consumer .

An embodiment is a method for rendering components within different browser environments where each application includes multiple renderers where each renderer controls a communication between a corresponding application and a browser specific runtime and where each application further includes at least one portlet providing at least one runtime specific markup.

A portal page is requested from a portal server by a client system. The portal page is aggregated by the portal server. The portal server chooses an appropriate renderer based on a browser specific environment and delivers a browser specific markup which is provided by at least one portlet.

In further embodiments the portal server communicates with the browser specific environment negotiates the capabilities that the browser specific environment has available and determines a proper rendering mode for the requested page to be displayed based on the capabilities of the browser specific environment.

In further embodiments the proper rendering mode includes a server side rendering or a client side rendering.

In further embodiments using server side rendering the renderer is executed to produce a complete markup representation of the portal page including the markup of all of the portlets. For client side rendering the renderer is executed to produce a page skeleton markup containing sections that are filled by the client system through separate requests.

In another embodiment in a system for rendering components within different browser environments a client system requests a portal page from a portal server which aggregates the portal page and chooses the appropriate renderer based on a browser specific environment. The renderer delivers a browser specific markup which is provided by at least one portlet. Each application includes multiple renderers and each renderer controls a communication between a corresponding application and a browser specific runtime. Each application further includes at the least one portlet providing at least one runtime specific markup.

In further embodiments the portal server chooses the render mode of the requested portal page based on the capabilities of the browser specific environment and metadata of the portal page where the metadata are parameters stored in a portal database which includes a specific set parameter specifying the proper render mode of the portal page where the capabilities of the browser specific environment are analyzed to check if the proper render mode is executable by the browser specific environment.

In further embodiments the portal server identifies the browser specific environment by inspecting a user agent header and looking up the capabilities of the browser specific environment in the portal database. Server side rendering is used as a fallback if the capabilities of the browser specific environment are not sufficient for client side rendering.

In further embodiments if using client side rendering a portlet filter is executed on the portal server to check if a corresponding portlet natively supports an iWidget runtime. This is performed by inspecting the iWidget deployment descriptor. If the portlet provides its own iWidget implementation the portlet filter directly calls a corresponding portlet and passes a corresponding mime type to the portlet otherwise the portlet filter invokes an iWidget microformat service to directly wrap the portlet in an iWidget. The iWidget microformat service produces an HTML microformat as specified in an iWidget specification.

In further embodiments a live text parser on the client system detects the iWidget microformat in the markup of a portal page upon receiving the markup on the client system and invokes a registered handler that is responsible for processing iWidget microformats. The registered handler instantiates an iWidget representing a corresponding portlet registers the portlet with an iWidget runtime and initializes the created portlet iWidget by requesting a corresponding iWidget definition from an iWidget definition service on the portal server. The iWidget definition service generates a definition for a given portlet by analyzing the portlet deployment descriptor and maps found information to a corresponding iWidget.

In further embodiments the portlet iWidget calls a client side WSRP consumer to request the portlet markup from the portal server. The client side WSRP consumer interprets a response received from the portal server and the client side WSRP consumer retrieves the portlet markups from the response message parses the markup for rewriting purpose and passes a processed markup back to the portlet iWidget to get displayed by the browser specific environment.

In another embodiment a data processing program for execution in a data processing system comprises software code portions for performing a method for rendering components within different browser environments when the program is run on the data processing system.

In yet another embodiment a computer program product stored on a computer usable medium comprises computer readable program means for causing a computer to perform a method for rendering components within different browser environments when the program is run on the computer.

Embodiments support rendering on server and client side at the same time and therefore exploits the best capabilities available.

In an embodiment the packaging of portlets is extended to include an implementation for the client side i.e. an iWidget and another implementation for the server side i.e. a portlet and additional other alternative implementations e.g. Flex Open Social .

Embodiments employ a portal server communicating with the client browser and negotiating the capabilities that the client browser has available. The portal server also determines the proper rendering mode of the page that should be displayed. Further the portal server determines the different implementations of the components which are packaged and or provided. Based on this the client server chooses the component implementation and rendering mode which suits it best e.g. based on a table which maps capabilities to selected choices.

An embodiment for address translation may be implemented as an entirely software embodiment or an embodiment containing both hardware and software elements. Embodiments may be implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore embodiments may take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium may be any apparatus that contains stores communicates propagates or transports the program for use by or in connection with the instruction execution system apparatus or device.

The computer readable medium may be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples include computer readable storage medium such as a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disc and an optical disc. Current examples of optical discs include Compact Disc read only memory CD ROM Compact Disc read write CD R W DVD etc. A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements may include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution. Input output or I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and ethernet cards are just a few of the currently available types of network adapters.

