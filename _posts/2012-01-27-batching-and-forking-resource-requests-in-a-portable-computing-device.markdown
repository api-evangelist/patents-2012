---

title: Batching and forking resource requests in a portable computing device
abstract: In a portable computing device having a node-based resource architecture, resource requests are batched or otherwise transactionized to help minimize inter-processing entity messaging or other messaging or provide other benefits. In a resource graph defining the architecture, each node or resource of the graph represents an encapsulation of functionality of one or more resources controlled by a processor or other processing entity, each edge represents a client request, and adjacent nodes of the graph represent resource dependencies. A single transaction of resource requests may be provided against two or more of the resources. Additionally, this single transaction may become forked so that parallel processing among a client issuing the single transaction and the resources handling the requests of the single transaction may occur.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09152523&OS=09152523&RS=09152523
owner: QUALCOMM Incorporated
number: 09152523
owner_city: San Diego
owner_country: US
publication_date: 20120127
---
This application claims priority under 35 U.S.C. 119 e to U.S. Provisional Patent Application No. 61 567 963 filed Dec. 7 2011 entitled BATCHING AND FORKING RESOURCE REQUESTS IN A PORTABLE COMPUTING DEVICE the entire contents of which are hereby incorporated by reference.

Further this application is a continuation in part of U.S. patent application Ser. No. 12 882 395 filed Sep. 15 2010 entitled SYSTEM AND METHOD FOR MANAGING RESOURCES OF A PORTABLE COMPUTING DEVICE the contents of which are incorporated herein by this reference.

Portable computing devices PCDs are becoming increasingly popular. These devices may include cellular telephones portable personal digital assistants PDAs portable game consoles portable navigation units palmtop computers and other portable electronic devices. Each of these devices may have a primary function. For example a cellular telephone generally has the primary function of receiving and transmitting telephone calls.

In addition to the primary function of these devices many include peripheral functions. For example a cellular telephone may include the primary function of making cellular telephone calls as described above and the peripheral functions of a still camera a video camera global positioning system GPS navigation web browsing sending and receiving e mails sending and receiving text messages and push to talk capabilities etc. As the functionality of PCDs increases the computing or processing power required to support such functionality also increases. Processing power may be increased by increasing the number of processors in the PCD. As the computing power and number of processors increases there exists a greater need to effectively manage the processors.

Functions such as those described above may be embodied in various corresponding hardware and software elements that may be referred to as resources. A processor may request various resources at various times under control of software such as an application program. In a multi processor PCD a first processor may control resources that are different from the resources controlled by a second processor. However it may be desirable for the first processor to be able to request resources controlled by the second processor.

A method and system for batching or otherwise transactionizing resource requests in a portable computing device having a plurality of resources may help minimize inter processor messaging or other messaging or provide other benefits. In a portable computing device having a node based software architecture a resource may be included in a node. In an exemplary method a plurality of nodes are instantiated. The plurality of resources of the nodes may be defined by a directed acyclic graph. Each node or resource of the graph represents an encapsulation of functionality of one or more resources controlled by a processor or other processing entity. Each edge of the graph represents a client request. Adjacent nodes of the graph represent resource dependencies. In accordance with the exemplary method a single transaction of resource requests may be provided against two or more of the resources.

Additionally this single transaction of resource requests may be forked so that parallel processing may occur. For example with a forked transaction the client which issues the single transaction of resource requests may continue to run issuing other requests or perform some other processing without waiting for the transaction to be complete i.e. for the requests issued within the transaction to be serviced by the resources. The resources receiving and who are responsible for the requests in the transaction may process these requests in parallel to the client continuing to run as described above.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects.

In this description the term application may also include files having executable content such as object code scripts byte code markup language files and patches. In addition an application referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

The term content may also include files having executable content such as object code scripts byte code markup language files and patches. In addition content referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

As used in this description the terms component database module system and the like are intended to refer to a computer related entity either hardware firmware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and the computing device may be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. In addition these components may execute from various computer readable media having various data structures stored thereon. The components may communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

In this description the terms communication device wireless device wireless telephone wireless communication device and wireless handset are used interchangeably. With the advent of third generation 3G and fourth generation 4G wireless technology greater bandwidth availability has enabled more portable computing devices with a greater variety of wireless capabilities.

In this description the term portable computing device PCD is used to describe any device operating on a limited capacity power supply such as a battery. Although battery operated PCDs have been in use for decades technological advances in rechargeable batteries coupled with the advent of third generation 3G and fourth generation 4G wireless technology have enabled numerous PCDs with multiple capabilities. Therefore a PCD may be a cellular telephone a satellite telephone a pager a personal digital assistant PDA a smartphone a navigation device a smartbook or reader a media player a combination of the aforementioned devices and a laptop computer with a wireless connection among others.

The CPU A may comprise a zeroth core a first core etc. through an Nth core as understood by one of ordinary skill in the art. In alternative embodiments instead of CPU A and a graphics processor B one or more digital signal processors DSPs may also be employed as understood by one of ordinary skill in the art. Further in alternative embodiments two or more multi core processors may be included.

As illustrated in a display controller and a touchscreen controller are coupled to the multi core CPU A. A touchscreen display external to the on chip system is coupled to the display controller and the touchscreen controller . Also included in PCD is a video coder decoder codec e.g. a phase alternating line PAL encoder a sequential couleur avec memoire SECAM encoder a national television system s committee NTSC encoder or any other type of video encoder coupled to the multi core central processing unit CPU A. A video amplifier is coupled to the video encoder and the touchscreen display . A video port is coupled to the video amplifier . As depicted in a universal serial bus USB controller is coupled to the CPU A. Also a USB port is coupled to the USB controller . A subscriber identity module SIM card may also be coupled to the CPU A. Further as shown in a digital camera may be coupled to the CPU A. In an exemplary aspect the digital camera is a charge coupled device CCD camera or a complementary metal oxide semiconductor CMOS camera.

As further illustrated in a stereo audio CODEC may be coupled to the analog signal processor . Moreover an audio amplifier may be coupled to the stereo audio CODEC . In an exemplary aspect a first stereo speaker and a second stereo speaker are coupled to the audio amplifier . shows that a microphone amplifier may be also coupled to the stereo audio CODEC . Additionally a microphone may be coupled to the microphone amplifier . In a particular aspect a frequency modulation FM radio tuner may be coupled to the stereo audio CODEC . Also an FM antenna is coupled to the FM radio tuner . Further stereo headphones may be coupled to the stereo audio CODEC .

Some of the above described elements of the PCD may comprise hardware while others may comprise software and still others may comprise a combination of hardware and software. The term resource is used herein to refer to any such element whether hardware software or a combination thereof that is controllable by a processor. A resource may be defined in one aspect as an encapsulation of the functionality of such an element. Except where it may otherwise be indicated the term processor is used herein to refer to a processor such as the CPU graphics processor B the analog signal processor or to any other processor controller or similar element that operates under the control of software firmware or similar control logic. A reference to two or more processing entities includes processors on different chips different processing cores of the same processor chip threads of execution on the same core or any other processing entities between which there may be a data transport penalty or inefficiency.

As described in further detail below an example of a resource is a software element that executes on a processor. A thread of execution on a processor such as for example a thread relating to an executing application program may access a resource by causing a request to be issued on the resource. As described below resource requests are processed through a software based system referred to in this disclosure as a framework. The term client is used broadly in this disclosure to refer to an element that effects the function of requesting a resource. Thus as the terms are used herein a thread may create or make use of a client for the purpose of issuing resource requests. It should be noted that in some instances a resource may create or use a client such that a resource may cause a resource request to be issued against another resource. As described in further detail below such other resource may be referred to herein as a dependent resource due to a dependency relationship between the requesting resource and requested resource. Resources and clients may be represented by data structures in memory.

Since resources are controlled by specific processors in a multi processor PCD not every processor in PCD has access to every resource in PCD . illustrates an example of an instance in which it may be desirable for a first processor in PCD to issue a resource request against a resource controlled by a second processor in PCD . Note that the first processor may also control a plurality of resources . Likewise the second processor may control a plurality of additional resources .

In an instance in which the first processor is executing a thread relating to for example a video player application program the thread may call for adjustment of one or more operating parameters of the first processor that enhance the performance of the first processor . Although thread and resource are conceptually illustrated as residing in their respective processors and for purposes of clarity one of ordinary skill in the art understands that such elements are executed or otherwise operated upon by the processor in the processor s memory space in accordance with well understood computing principles. Such operating parameters may include for example clock speed and bus speed. For example various processors may use the same bus clock but only one of the processors may have direct hardware level control of the bus clock. Increasing clock speed may result in better performance by for example a video player application program since the playback of video is generally a more processing power intensive task than some other tasks. As processing power is commonly expressed in millions of instructions per second MIPS the thread may issue a call for a certain number of MIPS. The resource power manager may include an algorithm that in response to a request for a specified number of MIPS causes changes in signals that may represent clock speed bus speed or other parameters that promote the first processor operating at the requested MIPS level.

It may be possible for a thread to access the resource power manager through an application program interface API specific to a bus or protocol through which the first processor may communicate with the second processor . However the framework described below may provide a more uniform way to handle resource requests than a resource specific and bus specific API. As described below via the framework resource requests are issued and serviced in a uniform manner without regard to whether the request is against a resource controlled by the same processor from which the resource request is issued or against a resource controlled by a different processor. A resource controlled by the same processor from which the resource request is issued may be referred to as a native resource. A resource controlled by a processor other than that from which the resource request is issued may be referred to herein as a remote resource or distributed resource. 

In addition issuing a request against a remote resource incurs processing overhead in the form of a time delay or latency. That is a certain amount of time is required for the message or messages relating to the resource request to be sent between processors. In some instances a single resource request may result in multiple inter processor messages. The resource request batching feature described in this specification may help minimize the number of inter processor messages in some instances.

A framework manager which may comprise a library of computer instructions manages nodes that encapsulate functionality of the resources. That is the nodes may be accessed to indirectly access the resources. For convenience a node encapsulating the functionality of a resource may be referred to herein as including comprising having etc. the resource. Each node may include one or more resources. The nodes may be defined in software code firmware or a similar medium and instantiated as data structures in for example memory during operation of the PCD . The nodes may be instantiated during a start up power up initialization boot up etc. sequence or at any other suitable time during operation of the PCD . It should be noted that a reference herein to instantiating issuing a request on or otherwise interacting with a resource should be understood as meaning interacting with a node that includes that resource. For the remainder of this disclosure a generic or non specific node will be designated with reference numeral as described below with reference to .

Nodes may include for example a first node having a single resource that generally corresponds with the first hardware element or central processing unit . With the software architecture described in this disclosure each resource of a node may be provided with a unique name comprising one or more alphanumeric characters. In the exemplary embodiment illustrated in the resource of the first node has been assigned the resource name of core cpu. This exemplary resource name generally corresponds to conventional file naming structures known to one of ordinary skill in the art. However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alpha numeric characters and or symbols are well within the scope of this disclosure.

Nodes may further include for example a second node having a plurality of resources. In this exemplary embodiment the second node has a first resource comprising a single hardware element corresponding to the bus arbiter or scheduler . The second resource of the second node comprises a software element generally corresponding to the first software element of the bus program A A. The third resource of the second node comprises another software element generally corresponding to the second software element of the bus program B B. One of ordinary skill in the art recognizes that any combination and any number of resources and resource types for a given node are well within the scope of this disclosure.

Other relationships displayed in include dependencies illustrated with dashed lines . Dependencies are relationships between respective resources of another node . A dependency relationship usually indicates that a first resource A is reliant upon a second resource B that may provide the first resource A with information or implement some behavior. This information may be a result of an operation performed by a second resource B or it may simply comprise status information that is needed by the first resource A or any combination thereof. The first resource A and second resource B may be part of the same node or they may be part of different nodes . It should be noted that client requests may originate not only from threads of execution such as in the example of the above described keypress action but also from other nodes . To obtain information or behavior from a dependent node a node may issue a client request to its dependent node . Thus the dashed lines that indicate dependencies may also indicate the direction of potential client requests .

In the first node is dependent upon the second node as indicated by the dependency arrow B which originates with the first node and extends to the second node at . also illustrates that the first node is also dependent upon the third node as illustrated by the dependency arrow A. also illustrates that the second node is dependent upon the fourth node as illustrated by the dependency arrow C. One of ordinary skill in the art recognizes that the dependencies illustrated with the dashed arrows of are only exemplary in nature and that other combinations of dependencies between respective nodes are within the scope of this disclosure.

The framework manager is responsible for maintaining the relationships described above that include but are not limited to the client requests and the dependencies illustrated in . Some such relationships such as dependencies exist at a PCD start up time i.e. power up initialization boot up etc. by virtue of the way the resources and their nodes have been defined in the software code in PCD that the framework manager accesses at such a start up time to begin the node instantiation process. Other such relationships such as client requests arise after nodes have been instantiated such as during execution of an application program thread in which an application program invokes a resource. Whether client requests originate from executing application program threads or similar elements other than nodes e.g. client request A or originate from a node client requests are directed through the framework manager . The framework manager directs the transfer of information among the nodes . Conceptually the framework manager serves as a matrix through which multiple threads may essentially concurrently communicate with the nodes . Though different threads may involve different data the same framework manager software code may service multiple threads.

As described below in further detail the framework manager may instantiate a node as soon as the node s dependent nodes are instantiated i.e. when the dependencies for any given node have been resolved. The framework manager attempts to instantiate all nodes that have been defined in the software architecture of PCD . A dependency is completed or resolved when a resource that supports a dependency is in existence or is in a ready state for handling information that relates to the dependency .

For example the first node comprising the single resource core cpu may not be instantiated by the framework manager if the third node comprising the single resource clk cpu has not been instantiated because of the dependency relationship A that exists between the first node and the third node . Once the third node has been instantiated by the framework manager then the framework manager may instantiate the first node because of the dependency relationship A.

If the framework manager is unable to instantiate a particular node because one or more of its dependencies are incomplete or unresolved the framework manager will continue running or executing steps corresponding to those nodes that were instantiated successfully. The framework manger will usually skip over a call for a particular node that may not exist due to incomplete dependencies in which dependent resources have not been created and return messages to that call which reflect that incomplete status.

In a multi core environment such as illustrated in the framework manager may create or instantiate nodes on separate cores such as the 0th first and Nth cores and of . Nodes may generally be created in a multi core environment on separate cores and in parallel as long as the nodes are not dependent on one another and if all of a particular node s corresponding dependencies as described below are complete. In a multi processor environment the nodes may be created or instantiated on various processors such as the CPU A graphics processor B etc. of . That is some nodes may exist in the memory space of one processor while other nodes may exist in the memory space of another processor. It should be noted however that nodes on one processor may not be accessible to nodes on the other processor via only framework manager .

A remoting framework manager that is similar to the above described main framework manager may exist in parallel with and as an extension to the framework manager . The remoting framework manager cooperates with or works with the framework manager to coordinate inter processor information transfers between nodes on different processors. That is the remoting framework manager helps framework manager maintain the relationships described above such as dependencies and client requests in instances in which the nodes that are involved exist on different processors. Thus nodes on one processor may not rendered accessible to nodes on another other processor via the combined effect of framework managers and . Moreover the combination of framework managers and may perform all of the functions ascribed in this disclosure to framework manager whether the nodes that are involved exist on the same processor different processors. In such a multi processor embodiment individual copies of the software that framework managers and comprise may reside in the domain of each of the processors. Thus each processor has access to the same framework manager software.

Although this disclosure may for purposes of clarity and convenience reference a node rather than a resource of the node it should be understood that client requests may be directed to specified resources rather than nodes. In other words a node which as described above may be a data structure encapsulating of the functionality of one or more resources may be transparent from the perspective of a client or other issuer of a client request such as another node . From the perspective of a client a request is issued against a resource rather than a node. Likewise from the perspective of a client a state query event or other element of the architecture is associated with a resource rather than a node.

A resource graph such as the exemplary graph is useful for understanding the instantiation of nodes in accordance with dependencies described below with regard to . Leaf nodes such as the nodes and are instantiated before non leaf nodes because leaf nodes have no dependencies. In general a node must be instantiated before a node that depends on it may be instantiated. Furthermore it can be seen that servicing a resource request corresponds to traversing a directed acyclic graph in which the vertices correspond to the nodes the edges correspond to client requests and adjacent nodes or vertices represent resource dependencies.

In a multi processor PCD a first processor may have access to or be capable of controlling a first set of nodes in a first resource graph while a second processor may have access to or be capable of controlling a second set of nodes in a second resource graph where the first and second resource graphs do not share any resources i.e. they are mutually exclusive resource graphs. That is in such an environment each processor has its own resource graph that defines relationships among resources and other elements that are not accessible to other processors. The distributed resource management of the present disclosure relates to maintaining the relationships described above such as dependencies and client requests in instances in which two or more processors each have access to resources in their own resource graphs and do not have access to resources in other processors resource graphs.

The above referenced limitation upon access to resources may in some embodiments be limited by hardware configuration. That is a processor may have no means by which it can affect a hardware device such as a register because the hardware device is controlled by or in the memory space of another processor. Alternatively or in addition the limitation upon access to resources may be imposed in software for reasons such as minimizing exposure of a processor to security risks e.g. a virus that may be infecting another processor .

For example the first node has a dependency arrow B to indicate that the first node is dependent upon the three resources of the second node . Similarly the third resource bus ahb sysB comprising the second software element B and generally designated with the reference letter C in has a dependency arrow C that indicates this third resource C is dependent upon the single clk sys ahb resource of the fourth node .

The node or resource graphs B of represent relationships which exist in memory under the control of a processor and which are managed by the framework manager . The node or resource graph B may be automatically generated by the framework manager as a useful tool for identifying relationships between respective elements managed by the framework manager and for troubleshooting by a software team.

Next in block the framework manager may review the dependency data that is part of the node structure data received in block . In decision block the framework manager may determine if the node structure data defines a leaf node . A leaf node generally means that the node to be created based on the node structure data does not have any dependencies such as the nodes and in . If the inquiry to decision block is positive meaning that the node structure data for creating the current node does not have any dependencies then the framework manager continues to routine block .

If the inquiry to decision block is negative then the No branch is followed to decision block in which the framework manager determines if all of the hard dependencies within the node structure data exist. A hard dependency may comprise one in which a resource cannot exist without it. Meanwhile a soft dependency may comprise one in which a resource may use the dependent resource as an optional step. A soft dependency means that a node or resource of the node which has a soft dependency may be created or instantiated within the node architecture even when the soft dependency does not exist.

An example of a soft dependency may comprise an optimization feature that is not critical to the operation for a resource oriented node containing multiple resources. The framework manager may create or instantiate a node or a resource for all hard dependencies that are present even when a soft is dependency is not present for those nodes or resources which have soft dependencies that are not created. A call back feature may be used to reference the soft dependency so that when the soft dependency becomes available to the framework manager the framework manager will inform each callback referencing the soft dependency that the soft dependencies are now available.

If the inquiry to decision block is negative then the No branch is followed to block in which the node structure data is stored by the framework manager in temporary storage such as memory and the framework manager creates a call back feature associated with this un instantiated node.

If the inquiry to decision block is positive then the Yes branch is followed to routine in which a node is created or instantiated based on the node structure data received in routine block . Further details of routine block will be described below in connection with . Next in block the framework manager publishes the newly created node using its unique resource name s so that other nodes may send information to or receive information from the newly created node .

Referring now to which is a continuation flow chart of in block the framework manager notifies other nodes which are dependent on the newly created node that the newly created node has been instantiated and is ready to receive or transmit information. According to one exemplary aspect notifications are triggered immediately when a dependent node like node B of is created i.e. the notifications are performed recursively. So if node B of is constructed node A is immediately notified. This notification may allow node A to be constructed since node B was node A s final dependency . Construction of node B may causes other nodes to be notified and so on. Node B does not get completed until the final resource dependent on node B is completed.

A second slightly more complex implementation is to put all of the notifications onto a separate notification queue and then run through the queue beginning at a single point in time i.e. the notifications are performed iteratively. So when node B of is constructed the notification to node A is pushed onto a list. Then that list is executed and node A is notified. This causes the notification to other additional nodes besides node A not illustrated in to be put on the same list and that notification is then sent after the notification to node A is sent. The notifications to other nodes besides the notification to node A does not occur until after all the work associated with node B and node A has been completed.

Logically these two implementations are equivalent but they have different memory consumption properties when implemented. The recursive realization is simple but can consume an arbitrary amount of stack space with the stack consumption being a function of the depth of the dependency graph. The iterative implementation is slightly more complex and requires a bit more static memory the notification list but stack usage is constant irrespective of the depth of a dependency graph such as illustrated in .

Also notification of node creation in block is not limited to other nodes. It may also used internally for alias construction. Any arbitrary element in the system A may use the same mechanism to request for notification when a node becomes available not just other nodes. Both nodes and non nodes may use the same notification mechanism.

In decision block the framework manager determines if other nodes or soft dependencies are now released for creation or instantiation based on the creation of the current node . Decision block generally determines whether resources may be created because certain dependency relationships have been fulfilled by the current node which has recently undergone creation or instantiation.

If the inquiry to decision block is positive then the Yes branch is followed back to routine block in which the released node may now be created or instantiated because of the fulfillment of a dependency by the node that was just created.

If the inquiry to decision block is negative then the No branch is followed to block in which the frame work manager may manage communications between elements of the software architecture as illustrated in . Next in block the framework manager may continue to log or record actions taken by resources by using the resource names associated with a particular resource. Block may be executed by the framework manager after any action taken by the framework manager or any of the elements managed by the framework manager such as the resources nodes clients events and query functions . Block shows another aspect of the node architecture in which the framework manager may maintain a running log of activity that lists actions performed by each element according to their unique identifier or name provided by the authors who created a particular element such as a resource of a node .

Compared to the prior art this logging of activity in block that lists unique names assigned to each resource of a system is unique and may provide significant advantages such as used in debugging and error troubleshooting. Another unique aspect of the node architecture A is that separate teams may work on different hardware and or software elements independently of one another in which each team will be able to use resource names that are unique and easy to track without the need for creating tables to translate less meaningful and usually confusing resource names assigned by other teams and or the original equipment manufacturer OEM .

Next in decision block the framework manager determines if a log of activity recorded by the framework manager has been requested. If the inquiry to decision block is negative then the No branch is followed to the end of the process in which the process returns back to routine . If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager sends the activity log comprising meaningful resource names and respective actions performed by the resource names to an output device such as a printer or a display screen and or both. The process then returns to routine block described above.

For convenience a conventional tree file naming structure or file naming metaphor that employs forward slash characters for creating unique names may be employed such as but not limited to core cpu for CPU and clk cpu for clock . However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alphanumeric characters and or symbols are well within the scope of this disclosure.

Next in block the framework manager may receive data for one or more driver functions associated with one or more resources of the node being created. A driver function generally comprises the action to be completed by one or more resources for a particular node . For example in the driver function for the resource core cpu of node may request the amount of bus bandwidth and the CPU clock frequency it requires in order to provide the requested amount of processing that has been requested. These requests would be made via clients of the resources in nodes and node . The driver function for clk cpu in node would usually be responsible for actually setting the physical clock frequency in accordance with the request it received from the core cpu resource of node .

In block the framework manager may receive node attribute data. The node attribute data generally comprises data that defines the node policies such as security can the node be accessed via user space applications remotability can the node be accessed from other processors in the system and accessibility can the resource support multiple concurrent clients . The framework manager may also define attributes that allow a resource to override default framework behavior such as request evaluation or logging policy.

Subsequently in block the framework manager may receive customized user data for the particular node being created. The user data may comprise a void star field as understood by one of ordinary skill in the art with respect to the C programming language. User data is also known to one of ordinary skill in the art as a trust me field. Exemplary customized user data may include but is not limited to tables such as frequency tables register maps etc. The user data received in block is not referenced by the system A but allows for customization of a resource if the customization is not recognized or fully supported by the framework manager . This user data structure is a base class in the C programming language intended to be extended for particular or specific uses.

One of ordinary skill the art recognizes that other kinds of data structures for extending specific uses of a particular class are within the scope of this disclosure. For example in the programming language of C C plus plus an equivalent structure may comprise the key word public which would become an extension mechanism for a resource within a node .

Next in block the framework manager may receive dependency array data. The dependency array data may comprise the unique and specific names of one or more resources on which the node being created is dependent. For example if the first node of was being created then in this block the dependency array data may comprise the resource names of the three resources of the second node and the single resource name of the third node on which the first node is dependent.

Subsequently in block the framework manager may receive resource array data. The resource array data may comprise parameters for the current node being created such as parameters relevant to the first node of if this first node was being created. The resource array data may comprise one or more of the following data the names of other resources unit maximum value resource attributes plug in data and any customized resource data similar to the customize user data of block . The plug in data generally identifies functions retrieved from a software library and usually lists the client types that may be supported by the particular node or plurality of nodes being created. The plug in data also allows for customization of client creation and destruction. After block the process returns to block of .

In the attribute data block customized user data block and the dependency array data block have been illustrated with dashed lines to indicate that these particular steps are optional and not required for any given node . Meanwhile the unique name block a driver function block and resource array data block have been illustrated with solid lines to indicate that these steps of routine are generally important for creating a node .

In block the framework manager may create or instantiate the one or more resources corresponding to the node structure data of block . Next in block the framework manager may activate the driver functions received in routine block of routine block . According to one exemplary aspect the driver functions may be activated using the maximum values received in the resource array data block of routine block . According to another preferred exemplary aspect each driver function may be activated with an optional initial value that is passed along with the node structure data from routine . If initial data is not provided the driver function is initialized at 0 the minimum value. The driver function is also usually activated in manner such that it is known that it is being initialized. This enables the resource to perform any operations that are specific to initialization but do not need to be performed during normal or routine operation. The process then returns to step of .

Next in block customized user data may be received by the framework manager if there are any particular customizations for this client being created. Block has been illustrated with dashed lines to indicate that the step is optional. The customized user data of block is similar to the customized user data discussed above in connection with the creation of resources for nodes .

In block the framework manager receives the client type category assigned to the particular client being created. The client type category as of this writing may comprise one of four types a required b impulse c vector and d isochronous. The client type category list may be expanded depending upon the resources being managed by the system and upon the application programs relying upon the resources of the nodes .

The required category generally corresponds with the processing of a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . Meanwhile the impulse category generally corresponds with the processing of a request to complete some activity within a certain period of time without any designation of a start time or stop time.

An isochronous category generally corresponds with a request for an action that is typically reoccurring and has a well defined start time and a well defined end time. A vector category generally corresponds with an array of data that usually is part of multiple actions that are required in series or in parallel.

Subsequently in block the framework manager receives data that indicates whether the client has been designated as synchronous or asynchronous. A synchronous client is one that typically requires the framework manager to lock a resource of a node until the resource returns data and an indication that the resource has finished completing the requested task from the synchronous client .

On the other hand an asynchronous client may be handled by one or more threads in parallel which are accessed by the framework manager . The framework may create a callback to a thread and may return a value when the callback has been executed by a respective thread. One of ordinary skill the art recognizes that the asynchronous client does not lock up a resource like a synchronous client does when the task of the synchronous client is being executed.

After block in decision block the framework manager determines if the resource identified by the client are available. If the inquiry to decision block is negative then the No branch is followed to block in which a null value or message is returned to a user indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to decision block in which the framework manager determines if each resource identified by the client supports the client type provided in block . If the inquiry to decision block is negative then the No branch is followed back to block in which a null value or message is returned indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager creates or instantiates the client in memory. Next in block if any customized user data is received in block such as optional arguments then these optional arguments may be mapped with their respective resources to a particular node . Next in block the newly created client is coupled to its corresponding one or more resources in an idle state or on requested state as described above. The process then returns to block of .

Block is the first step in the method for creating a client request against the resource . This method will describe how the following three types of client requests are handled by the framework manager a required b impulse and c vector. As the names of the requests mentioned above suggest client requests generally correspond with client types that were created and described above.

In block the framework manager may receive the data associated with a particular client request such as one of the three mentioned above a required b impulse and c vector. The data associated with a required request generally comprises a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . An impulse request comprises a request to complete some activity within a certain period of time without any designation of a start time or stop time. Data for a vector request generally comprises an array of multiple actions that are required to be completed in series or in parallel. A vector request may comprise an arbitrary length of values. A vector request usually has a size value and an array of values. Each resource of a node may be extended to have a pointer field in order to support a vector request. In the C programming language the pointer field is supported by the union function as understood by one of ordinary skill in the art.

Next in block the framework manager issues the request through the client that was created by the method described above in connection with . Subsequently in block the framework manager double buffers the request data being passed through the client if the request is a required type or a vector type. If the request is an impulse type then block is skipped by the framework manager .

For required requests in this block values from a prior request are maintained in memory so that the framework manager may determine if there is any difference between the previous requested values in the current set of requested values. For vector requests prior requests are usually not maintained in memory although a resource of a node may maintain it as desired for a particular implementation. Therefore block is optional for vector types of requests.

In block the framework manager calculates the delta or difference between the previous set of requested values in the current set of requested values. In decision block the framework manager determines if the current set of requested values is identical to the previous set of requested values. In other words the framework manager determines if a difference exists between the current set of requested values and the previous set of requested values. If there is no difference between the current set and previous set of requested values then the Yes branch is followed which skips blocks through block to block in which the process ends.

If the inquiry to decision block is negative meaning that the set of requested values are different relative to the set of pre previous requested values then the No branch is followed to decision block .

In decision block the framework manager determines if the current request is an asynchronous request. If the inquiry to decision block is negative then the No branch is followed to block in which the resource corresponding to the client request is locked by the framework manager . If the inquiry to decision block is positive meaning that the current request is asynchronous request type then the Yes branch is followed to block in which the request may be pushed onto another thread and may be executed by another core if a multi core system like that of is currently managed by the framework manager . Block has been illustrated with dashed lines to indicate that this step may be optional if the PCD is a single core central processing system.

Subsequently in block the resources corresponding to the request is locked by the framework manager . Next in block the resource executes the update function which generally corresponds to the plug in data of the resource array data received in block of . The update function generally comprises a function responsible for the new resource state in light of a new client request. The update function compares its previous state with the requested state in the client request. If the requested state is greater than the previous state then the update function will perform the client request. However if the requested state is equal to or less than the current state and which the resource is operating at then the client request will not be performed in order to increase the efficiency since the old state achieves or satisfies the requested state. An update function takes a new request from the client and aggregates it with all the other active requests to determine the new state for the resource.

As an example multiple clients may be requesting a bus clock frequency. The update function for the bus clock would usually take the maximum of all the client requests and use that as the new desired state for the bus clock. It is not the case that all resources will use the same update function although there are some update functions that will be used by multiple resources. Some common update functions are to take the maximum of client requests to take the minimum of client requests and to sum the client request. Or resources may define their own custom update function if their resource needs to aggregate requests in some unique way.

Next in block the framework manager passes the data to the resource corresponding to the client so that the resource may execute the driver function which is specific to the resource of a node . A driver function applies the resource state as computed by the update function. This may entail updating hardware settings issuing requests to dependent resources calling legacy functions or some combination of the above.

In the previous example the update function computed the requested bus clock frequency. The driver function may receive that requested frequency and it may update the clock frequency control HW to run at that frequency. Note that sometimes it is not possible for the driver function to meet the exact requested state that update function has computed. In this case the driver function may choose the frequency that best meets the request. For example the bus clock HW may only be able to run at 128 MHz and 160 MHz but the requested state might be 150 MHz. In this case the driver function should run at 160 MHz as that exceeds the requested state.

Next in block the framework receives state control from the resource which has executed the driver function in block . Subsequently in block if defined against the resource events may be triggered so that data is passed back to the client which corresponds to the event . Events may be processed in another thread. This may minimize the amount of time spent with the resources locked and allows for parallel operation in a multi core system as illustrated in . One or more events may be defined against a resource in a manner similar to how a request may be defined against a resource as described in this method . In other words the event creation process may largely parallel the client creation process. One thing that is different with the events is that it is possible to define events that only get triggered when certain thresholds are crossed.

This defining of events that only get triggered based on thresholds allows for notification of when a resource is getting oversubscribed it has more concurrent users than it can support which is indicative of a system overloading condition or when a resource goes low off which may allow other things to be shut off restore functionality that was disabled when the system became oversubscribed etc. Because the event registration may be done with thresholds it reduces the amount of work the system has to do on event notification to only happen when there is something really necessary. It is also possible to register for an event on every state change.

Next in optional block if the request being processed is a vector request then this optional block is usually performed. Optional block generally comprises a check or determination to assess whether the vector pointer is still positioned on the same data that the user passed into the vector. If the inquiry to this optional block is positive meaning that the pointer is still pointing to the same data which was passed by the user into the vector then the pointer is cleared out so that references to old data is not maintained. This optional block is generally performed to account for the double buffering block described above when a vector request is being processed compared to an impulse request and a required request.

Subsequently in block the framework unlocks the requested resource so that other client requests may be handled by the current but now released requested resource of a particular node . The process then returns to the first block for receiving the next client request.

The above described methods and data structures are essentially as applicable to a multi processor PCD as they are to a single processor PCD . However the remoting framework may provide additional features that may enhance operation in a multi processor embodiment. For example the remoting framework may advantageously render the details of inter processor communication transparent to an application programmer or similar person. Thus an application program for example may define a client that issues a request on a target resource without having to include in the client definition any identification of the processor domain that controls that resource. Rather the remoting framework ensures that the request will reach the target resource regardless of which processor controls the client and which processor controls the target resource. In addition the remoting framework manages the inter processor communication so that for example an application program need not include any instructions relating to the protocol or other aspects of the communication paths e.g. buses between processors. Furthermore as different inter processor communication paths may use different protocols the remoting framework allows the resource definition to specify a protocol along with other aspects of the resource. These and other features relating to distributed resource management are described below with regard to .

A broken line illustrates a division between resources controlled by the first processor to the left of the line and resources controlled by the second processor to the right of the line . The first resource is one of two or more resources that are controlled by the first processor. One such resource may be a protocol resource on which the first resource depends. Likewise the second resource is one of two or more resources that are controlled by the second processor. In some embodiments only a distributed resource and not a native resource depends on a protocol resource. Therefore in such embodiments only the first distributed resource depends on a protocol resource . However in other embodiments any resource may depend on a protocol resource. Thus in an alternative embodiment the second resource could also depend on a protocol resource not shown . The first and second resources and may also depend on additional resources in the same manner as described above with regard to resources or nodes in general but such additional resources are not shown in for purposes of clarity. Note that the resources controlled by the first processor are defined by a first resource graph i.e. a directed acyclic graph and the resources controlled by the second processor are defined by a second such resource graph that does not share any resources with the first resource graph.

The first and second resources and under control of their respective processors are capable of communicating information via a communication path . The communication path represents the combination of the physical medium between the first and second processors and the one or more layers of transport protocols used to communicate via that medium. Accordingly any communications between the first resource and the second resource must conform to the protocols. Protocol resources and define a protocol or may point to a protocol definition in a library not shown . The remoting framework and main framework operate in conjunction with one another to manage the resources and communications between them. As described below a client under control of the first processor may issue one or more resource requests on the first resource . The first resource uses the functionality of the corresponding second resource to service the resource request.

As indicated by block the framework managers and receive node structure data that defines a node such as that containing the first resource . In the exemplary embodiment dependencies are handled in essentially the same way as described above with regard to except that as indicated by block protocol resources may be instantiated at any time. A resource that depends on a protocol resource does not need to wait until its protocol resource is instantiated. Instantiation of dependencies in the manner described above with regard to is illustrated generally by block .

Although instantiation generally follows the methods described above with regard to it should be noted that a distributed resource cannot be instantiated until the native resource to which it corresponds has been instantiated. Thus instantiation of a native resource may delay instantiation of the distributed resource in the same manner as instantiation of dependent resources may delay instantiation of a resource that depends on them. Also note that messages relating to the state of instantiation of the native resource that are communicated between the first and second processors via the communication path and the framework managers and generally conform to the specified protocol. For example after the protocol resource on the first processor is instantiated the first process operating in accordance with the remoting framework manager may send a request for notification encoded or otherwise conforming to the protocol to the second processor. When the second resource has been instantiated the second processor operating in accordance with the remoting framework manager may respond to the request for notification by sending a response to the first processor indicating that the second resource has been instantiated. The remoting framework manager may manage such communications and others as part of the process of instantiating the software architecture.

The protocol resource on the first processor may include among other functions a function to create a client such as the client shown in and return a handle to the client that may be used by a thread of execution. A thread of execution e.g. part of the execution of an application program or other software element may invoke the function to create such a client . The thread may use the client to issue resource requests and otherwise use the client in the same manner as described above with regard to clients in general. The resource request is protocol specific and allows the thread to access the second resource without the thread having to provide any information relating to the protocol. From the perspective of the thread and its clients the protocol may be irrelevant or transparent.

As indicated by block the frameworks and determine if an aggregation method is specified in the received node structure data. If it is determined that an aggregation method is specified the aggregation method is set in the distributed and native resources nodes as indicated by block . There are two aggregation types local and proxy. In defining a resource one of the two aggregation types may be selected. Accordingly in instantiating a resource node the resource is set to perform either local aggregation or remote aggregation.

A resource performs local aggregation by applying an algorithm to multiple resource requests that it may receive concurrently. In this context two or more requests are concurrent for the time during which they both remain active. For example a first processor may issue a resource request to set its speed to 50 MIPS and before the first processor s request has been completed or otherwise terminated a second processor may issue a resource request to set its speed to 100 MIPS. Aggregation may be performed in accordance with a method such as adding the argument of each of the multiple concurrent resource requests by determining the maximum argument from among those of all the multiple resource requests by determining the minimum argument from among those of all the multiple resource requests or by any other suitable method. The aggregation method may be specified or defined along with the aggregation type in the node structure data that defines the resource node .

The node structure data may indicate that the node is to be instantiated as a proxied node or a non proxied node. The manner in which this feature may be used is described below with regard to . As indicated by block the node type is set to the indicated type. In the case of a non proxied node client requests are aggregated locally in a manner determined by the node structure and a driver function is used that sends the locally aggregated request to the native resource. Queries and events are handled by the distributed resource. In the case of a proxied node client requests are not aggregated but instead are sent individually to the native resources. Additionally all queries and events are forwarded to the native resource.

As indicated by block any remaining steps in the instantiation process occur. Such aspects of instantiating the distributed node may be essentially the same as described above with regard to . As indicated by block if additional nodes are defined the method repeats or continues for those nodes.

As indicated by block the distributed resource such as that of the first node in receives a client request. As indicated by block it is determined whether the aggregation type associated with the requested resource is local or remote. If the aggregation type is local then the requested resource aggregates the request argument with others occurring within the same window as indicated by block . As described above aggregation relates to handling concurrent resource requests. If the aggregation type associated with the requested resource is remote then it will be left up to the corresponding native resource such as the second resource in to aggregate the request with others.

Whether local or remote aggregation implicates three sequential states of a client request 1 Request Issued 2 Request in Progress and 3 Request Applied. In an instance in which client requests are issued concurrently i.e. two client requests each begin the Request Issued state at effectively the same time or within the above referenced window of each other the client request that occurred first causes the requested resource to be locked and the client request that occurred second is handled after the client request that occurred first. A client request is handled or serviced during the Request In Progress state. After the client request has been completed the client request is assigned the Request Applied state. Aggregation comes into play in an instance in which multiple concurrent client requests have reached the Request Applied state. For example if a resource has been defined as using the above referenced maximum aggregation method and client A requests 50 MIPS while perhaps a few microseconds later client B requests 100 MIPS these initial requests will be serialized. Accordingly when the first client request is processed the resource will be set to the argument of the first client request or 50 MIPS. Then when the second client request is processed the resource in accordance with the maximum aggregation method will be set to 100 because 100 is the maximum of 50 and 100. Thereafter when both of these initial client requests are in the Request Applied state client B may issue another client request for 25 MIPS. The requested resource in accordance with the maximum aggregation method will be set to 50 because 50 is the maximum of 50 and 25.

As indicated by block it is determined whether the requested resource depends on a protocol resource such as the protocol resource in . If the requested resource depends on a protocol resource then the protocol resource is invoked and used to conform the resource request to the protocol that the protocol resource defines as indicated by block and respectively. As indicated by block in conformance with the protocol a resource request reflecting the aggregation result result of block is sent or if the remote resource is to perform the aggregation the resource request is forwarded to the native resource such as the second resource in . The driver function not shown of the distributed resource invokes the protocol.

Although not shown in events involving distributed resources may be handled in essentially the same manner as described above with regard to . Events of a type that monitor for a value crossing a threshold may be especially useful in combination with a proxied resource as described below.

As indicated by block the distributed resource such as that of the first node in receives a state query. In this example the first node represents a non proxied node or resource. As indicated by block the state query is forwarded to the corresponding native resource such as the second resource in . As indicated by block the state of the native resource is sent back to the distributed resource in response to the state query. As indicated by block the distributed resource may then provide a state indication which represents the state of the native resource to the query requestor client .

As indicated by block the state query is forwarded to the corresponding native resource such as the second resource in . As indicated by block the state of the native resource is sent back to the distributed resource in response to the state query.

The use of proxied distributed resources in appropriate instances may promote the desirable goal of minimizing inter processor traffic because state information is only sent from the native resource s processor to the distributed resource s processor when the native resource s state changes. In contrast in the case of a non proxied resource a state query is sent and state information is returned each time the distributed resource receives a state query. Proxied resources may be used in instances in which for example it is the state of the distributed resource rather than the corresponding native resource that is most relevant to the task to be performed under control of the first processor.

As noted above with regard to events and queries are related aspects of the software architecture. Events of a type that monitor for a value crossing a threshold may be especially useful in combination with a proxied resource because inter processor messages are only sent when the when the native resource s state crosses a threshold rather than every time the native resource s state changes.

In some instances it may be desirable to group or batch a number of separate resource requests together in a single transaction of resource requests. In instances in which the multiple resource requests are against remote or distributed resources controlled by the same processor as each other transactionizing the resource requests may help minimize the number of messages transmitted through the communication path between the first and second processors. As well understood by a person of ordinary skill in the art a transaction is an action that occurs in accordance with properties commonly referred to by the acronym ACID atomicity consistency isolation and durability. Atomicity means that either all of the constituent steps of the transaction are performed or none of them are performed so as to avoid problems associated with partially performed transactions. Consistency means that a transaction will take the system from one consistent coherent state to another. Isolation means that other operations cannot access data that has been modified during a transaction that has not yet completed. Locking access to data is commonly used to ensure the isolation property of a transaction. As described above a resource is locked when it is accessed in response to a resource request and unlocked when the resource request is completed. Durability relates to recovery from system failures. The term transaction is used in this specification to refer to a group of resource requests that are performed together in accordance with at least the properties of atomicity and isolation. The framework or programming interface for resource request transactions supports consistency in its design but whether the system reaches a consistent state following a transaction is dependent on the actions of the individual transactionized resource requests and thus is not necessarily a property of the framework or programming interface.

Providing a transaction of resource requests may involve two aspects. In one aspect a transaction of resource requests may be defined. In defining a transaction of resource requests the transaction of resource requests is assigned a unique name or identifier a locking type is specified and the resources that may be involved in the transaction of resource requests are listed. The result of defining a transaction of resource requests may be a handle that can be referenced by an entity in order to issue or create an instance of the transaction of resource requests.

The second aspect of providing a transaction of resource requests relates to issuing or creating an instance of the defined transaction of resource requests. A transaction of resource requests may be issued by a resource e.g. as a batch of resource requests to other resources it depends upon or alternatively by an entity other than a resource such as by an executing thread or by a device driver that is not included in one of a resources defined by the above described resource graph of the PCD . A transaction of resources request is like other resource requests a type of client request. Any entity that is capable of issuing a client request or in common computer science parlance that owns the client in the manner described above may issue a transaction of resource requests.

To issue a transaction of resource requests the resource thread or other such entity executes software code that starts or sets up the previously defined transaction of resource requests issues resource requests to the various resources that are defined to be part of the transaction of resource requests and then ends the transaction of resource requests initiating processing of the batched requests and ending the transaction of resource requests. The process of ending a transaction of resource requests may involve transmitting the batch of requests from the first processing entity to the second processing entity processing the batched requests at the second processing entity waiting at the first processing entity for a notification of completion of processing and then on receipt of the notification executing any updates to local resource proxies or registered callbacks at the first processing entity.

As indicated by block in an indication of a sequence of events is provided. For example the sequence of events may be provided by means of the execution of the code represented by the pseudocode above. The sequence of events that is indicated includes an indication of the beginning of the transaction of resource requests represented in the exemplary pseudocode by BEGIN TRANSACTION HANDLE an indication of the end of the transaction of resource requests represented in the exemplary pseudocode by END TRANSACTION and indications of the two or more resource requests that are to occur as part of the transaction i.e. between the beginning of the transaction and the end of the transaction. The pseudocode BEGIN TRANSACTION HANDLE represents the setting up of a transaction of resource requests on a handle that has been defined in the manner described above. As the process of issuing a transaction of resource requests spans these many steps any transaction of resource requests on a handle is to be performed in accordance with the locking type associated with that handle and the resources associated with that handle at the time the transaction of resource requests was defined.

Although not reflected in the pseudocode above for purposes of clarity it is useful to note that a transaction of resource requests may include conditional logic. For example the code representing a transaction of resource requests may include logic having the form IF condition THEN issue resource request or similar logic that when evaluated in response to input conditions results in providing requests to a subset of the resources that are listed in the definition of the transaction of resource requests. In other words a transaction of resource requests may be defined that includes a certain resource request only if specified conditions are met at the time of issuance of the transaction of resource requests i.e. at the time that code is executed that represents the transaction of resource requests. For example a transaction of resource requests may be defined as involving resources A B C and D but evaluation of conditional logic in a given instance may provide only indications of resource requests against resources A B and C. That is as a result of the evaluation of the conditional logic in this exemplary instance of a transaction of resource requests a resource request against resource D may not be included in the actual transaction of resource requests. Not all resources that are defined as potentially involved in a transaction of resource requests may be needed in all instances. For purposes of clarity the exemplary pseudocode above shows only the resource requests that are indicated in a given instance and does not show any conditional logic. Nevertheless it should be understood that a transaction of resource requests may include any number of resource requests and any suitable conditional logic that may determine which resource requests are included in a given instance.

As indicated by block a queue for resource requests involved in the transaction of resource requests is set up. As indicated by block each resource involved in a transaction of resource requests is locked for the duration of the transaction of resource requests. As described below resources may be locked in accordance with different locking types such as a first locking type referred to below as pessimistic locking or a second locking type referred to below as lazy locking. As described above the locking type is defined when the transaction of resource requests is defined. Thus when the transaction of resource requests is issued it will have been predetermined at the time of issuance whether the transaction of resource requests is to be performed in accordance with the pessimistic locking method or alternatively in accordance with the lazy locking method. Depending on the locking method the resources involved in the transaction of resource requests may be locked at different times as described in further detail below. Also depending on the locking type either all of the resources defined as being part of the transaction of resource requests are locked pessimistic locking or only the subset of these resources to which requests are issued as part of the transaction are locked lazy locking .

In another embodiment when the locking type associated with the transaction of resource requests is lazy as described further below the entity defining and issuing the transaction of resource requests need not be constrained in having to define or list all the resources that may be part of the transaction during the definition aspect of a transaction of resource requests. It is wholly possible for the resources that are or in the case become part of the transaction to be dynamically included in the transaction by virtue of one or more requests to these resources being issued in context of the transaction. As an example in the pseudocode above the entity issuing the transaction need not define A B and C as being part of the transaction during the definition aspect if the locking type it associates with the transaction is lazy. It can begin the transaction and then issue requests to two or more of A B and C. These resources then implicitly become part of the transaction of resource requests and the requests to them are only batched and not processed immediately. Thus in this embodiment it is possible to construct a dynamic or run time defined transaction in the sense that any number of resources can be added to the transaction after beginning the transaction without having to define them all upfront. As will be evident from the description of locking types further below such a dynamic or run time defined transaction of resource requests cannot be of the pessimistic locking type.

As indicated by block information associated with each of the resource requests included in the transaction of resource requests is added to the queue. With reference to the pseudocode above in an instance in which REQUEST A represents a request against resource A for for example processing throughput of 50 MIPS resource A or its distributed counterpart in an instance in which resource A is controlled by a processor other than that which is issuing the transaction of resource requests may add a value of 50 to the queue. Likewise any suitable parameters associated with other resource requests that are part of the transaction of resource requests are added to the queue at the time of execution of the corresponding code such as the code represented by the pseudocode REQUEST B . For purposes of clarity the pseudocode above does not reflect all parameters that may be included in a resource request such as a parameter representing the 50 in this example.

It should be noted that the locking and adding to queue steps indicated by blocks and respectively may be performed in any order and involve one or more sub steps. For example as described below in a transaction of resource requests that has been defined to be of the pessimistic locking type all resources indicated in the definition of the transaction of resource requests are locked before any information associated with the resource requests is added to the queue. However in a transaction of resource requests that has been defined to be of the lazy locking type each resource request in turn results in locking of the requested resource and adding information associated with only that resource request to the queue. In other words in a transaction of resource requests the locking and adding to queue steps may be performed in an alternating manner with each other. Pessimistic and lazy locking are described in further detail below.

As indicated by block the queue is transmitted to a recipient in response to the indication of the end of the transaction. The recipient may be for example another processor. The recipient may be for example another processor i.e. a processor other than the processor from which the transaction of resource requests is issued. In such an instance the queue takes the place of multiple messages associated with multiple resource requests that would have been issued if the resource requests had not been transactionized in the manner described above. At the issuing entity the thread of execution is blocked until there is notification from the recipient that the queue of requests has been processed. Then any residual processing at the issuing entity is completed this may involve any updates to local resource proxies or executing any registered callbacks and the transaction is deemed completed. All of this is represented by the END TRANSACTION HANDLE in the pseudocode above.

As indicated by block all of the resources indicated in the transaction of resource requests are unlocked following the end of the transaction as represented by the END TRANSACTION in the pseudocode above. Thus the resources are unlocked after the queue is transmitted and batched requests processed.

It should be noted that while this text refers to resource requests issued within a transaction of resource requests as being added to a queue the queue need not possess any of the properties of a standard queue such as ordering of elements in a first in first out manner. This is not to say that in a particular implementation a standard queue cannot be used to batch requests. While such a queue may well be used in other implementations requests may be added into any sort of container or buffer that can receive elements one or more at a time and store them until eventual transmission or processing. In such cases the queue may be considered a bag or bucket of resource requests.

In an instance in which the transaction of resource requests has been defined to be of the lazy locking type in response to a first resource request against resource A resource A becomes locked and the information associated with the first resource request is added to the above referenced queue. Resource A then issues a second resource request against resource B because resource A depends on resource B. In response to the second resource request resource B becomes locked and the information associated with the second resource request is added to the queue. Resource A then issues a third resource request against resource C because resource C depends on resource B. In response to the third resource request resource C becomes locked and the information associated with the third resource request is added to the queue. With reference to the pseudocode above resource A is locked at the time the code represented by the pseudocode REQUEST A is executed resource B is locked at the time the code represented by the pseudocode REQUEST B is executed and resource C is locked at the time the code represented by the pseudocode REQUEST C is executed.

The lazy locking method may be satisfactory if the properties of the resource graph that defines the set of the resources involved in the transaction of resource requests preclude the possibility of a deadlock condition. illustrates an exemplary resource graph that is similar to resource graph but that does not preclude the possibility of a deadlock condition. With further reference to the event timeline of in an exemplary instance a first thread and a second thread each request resources indicated by the resource graph . A first thread issues a first transactionized resource request against resource A which locks resource A. As resource A depends on resource B resource A then issues a second resource request against resource B thereby locking resource B. As resource B depends on resource D resource B then issues a third resource request against resource D thereby locking resource D. Then a second thread issues a fourth resource request against resource C thereby locking resource C. As resource C depends on resource D resource C then issues a fifth resource request against resource D. However as resource D has already been locked as a result of resource request resource request is blocked and therefore cannot be completed until resource D becomes unlocked. But a sixth resource request against resource C as a result of the dependence of resource A on resource C issued in the context of the first thread will also be blocked because resource C was locked as a result of resource request by the second thread. In this instance there is a deadlock condition because the first thread cannot complete its resource request until the resources on which resource A depends are unlocked yet the second thread cannot complete its resource request until the resources on which resource C depends are unlocked.

To avoid the possibility of a deadlock condition in such an instance a transaction of resource requests may be defined to be of the pessimistic locking type rather than the lazy locking type. In a transaction of resource requests of the pessimistic locking type all resources indicated in the transaction of resource requests are locked in response to the indication of the beginning of the transaction before any indications of the individual resource requests or before any individual resource requests are issued . Thus with reference to the pseudocode above and to resources A B and C are all locked in response to execution of the code represented by BEGIN TRANSACTION. The resources may be locked in an order indicated by a topological sort of the resource graph. As methods of topologically sorting a directed acyclic graph are well understood by a person of ordinary skill in the art they are not described in this specification in further detail. Any suitable topological sort method may be used. In an exemplary instance represented by the event timeline of the results of the topological sort of the resource graph may be for example A B C D. Thus in response to an indication of the beginning of the transaction of resource requests against resource A resource B is locked after resource A is locked then resource C is locked after resource B is locked and finally resource D is locked after resource C is locked. After all of the resources A B C and D are locked the indicated resource requests may proceed against resources B C and D. In another embodiment or implementation the resources may be locked in the order indicated by the topological sort as part of the setup of the transaction of resource requests represented in the pseudocode by BEGIN TRANSACTION. 

As indicated by block the resource determines whether it is involved in a transaction of resource requests. A status indicator may be included in each resource that may be set at the beginning of a transaction of resource requests to indicate that the resource is included in the transaction of resource requests. In another embodiment or implementation a status indicator may be set in the thread after it executes the pseudocode represented by BEGIN TRANSACTION indicating that the current thread has begun a transaction of resource requests. If the resource determines that it is not involved in a transaction of resource requests then the resource performs the resource request in the normal manner as indicated by block . That is the resource may perform and complete the resource request in the normal manner described above with regard to . Note that as described above with regard to at the beginning of performance of a non transactionized resource request the resource is locked and at the completion of the resource request the resource is unlocked.

If the resource determines that it is involved in a transaction of resource requests then the resource determines whether the above referenced queue has been created by for example another resource or by the pseudocode represented by BEGIN TRANSACTION as indicated by block . If the resource determines that a queue does not exist then the resource creates a queue as indicated by block . As indicated by block a resource involved in a transaction of resource requests then adds the information associated with the request against it to the queue. Note that the resource is in a locked state prior to adding the information to the queue as a result of either the lazy locking method or the alternative pessimistic locking method. The lock is not removed after the resource adds the information to the queue. Rather as described above the lock is removed only upon an indication of the end of the transaction and transmittal of the queue to and subsequent processing of the batch of requests at another processor or other recipient.

The owner of two proxy resources RES0 A and RES1 B illustrated in is the resource power manager RPM which is also illustrated in . The RPM as illustrated in as the owner of these two proxy resources RES 0 A and RES 1 B fulfills any of the requests issued to these two proxy resources in a transaction.

RES 0 A and RES 1 B as illustrated in are proxies. Proxies are logical representations of real resources as understood by one of ordinary skill in the art. They are representations in memory of remotely located hardware or software that is accessible by a local processing entity such as the modem via the RPM . The RPM is in control of the real resources which are remotely located relative to the modem .

These two proxies of RES 0 A and RES 1 B may be part of the framework manager . In some embodiments the two proxy resources A B may manage the queue of batched requests as described below and which was described earlier in connection with block of . In other embodiments in which the framework manager exists the framework manager may manage the queue as described below.

As mentioned above the real resources which are managed by the RPM and which are located in closer proximity to the RPM and which are not illustrated for brevity are contained or reside within the RPM . Meanwhile these proxies A B are managed in software and stored in memory by the modem as understood by one of ordinary skill in the art. The proxies may receive requests and then pass these requests to the real resources located adjacent or within the RPM .

Client applications such as first client are owners the modem which is the first processing entity in this exemplary embodiment. The client applications typically issue requests to the two proxy resources RES0 A and RES0 B which are managed by the RPM .

Since the first client needs to access two proxy resources A B for a particular transaction and for the sake of optimization the first client may decide to batch its requests to these two separate proxy resources A B together into a transaction at position in the timeline illustrated in . At time line position of the two proxy resources A B are alerted of an incoming batched request.

Further details of how requests may be batched together into a transaction are discussed above in connection with . At position the proxy resources A B via the framework manager have acknowledged the initiation of the batched request that is being formulated by the first client .

At position the first client issues the first request to the first proxy resource RES 0 A. The first request is not serviced by the first proxy resource A. Instead the first proxy resource A is locked from other clients accessing the first proxy resource A. At position the first proxy resource A forwards the received first request to a queue .

The queue may or may not have any specific ordering with respect to the information contained therein. It may or may not have any standard queue requirements governing its data structure. In other words the queue may comprise any type of logical bucket as understood by one of ordinary skill in the art. The first proxy resource A at position issues an acknowledgment or call return back to the first client .

At position the first client issues the second request to the second proxy resource B. Similar to the first proxy resource A the second proxy resource B is locked from other clients accessing the second proxy resource B. At position the second proxy resource B forwards the received first request to the batch queue . And the second proxy resource B issues an acknowledgment or call return back to the first client at position .

At position a forked transaction call has been initialized by the first client . Position also marks the instant in time in which a regular batch transaction call would have ended as described above in connection with . In both cases the batched requests would be transmitted to the RPM here.

The real resources not illustrated in this figure represented by first proxy resource A and second proxy resource B would be locked during the batched transaction and they would have completed their assigned requests of the batched transaction s at position . After completing the batched transaction s then the real resources via their proxies A B would have then returned an acknowledgement to the first client .

The first and second proxy resources A B would then be unlocked under the normal batched transaction scenario illustrated in . Instead of initializing starting the execution of a normal batched transaction at position the inventive system as illustrated in initializes a forked transaction at position .

In a forked transaction tasks and or operations are split up so that the tasks and or operations may be performed in parallel. From time line position assigned to a dashed line the batched transaction is transmitted by the framework manager to the RPM in an asynchronous manner and without waiting for any response from the RPM .

At position which is immediately after the asynchronous call that contains the batched request from position the framework manager unlocks the first proxy resource A and second proxy resource B. The first and second proxy resources A B are unlocked and so may accept but not process any subsequent requests as understood by one of ordinary skill the art.

At position the call returns to the first client and indicates that proxy resources A and B are unlocked. The first and second proxy resources A B are in an incoherent state at this stage. These two proxy resources A B have accepted the requests but the requests have not been processed at this stage.

Time line position has been characterized as a potential first parallel processing block. At position the first client may continue to issue other requests and or execute other tasks while not waiting for the requests issued to the first and second proxy resources A B to be completed under control from the RPM . In conventional systems a first client would have been blocked at position .

Position which corresponds with position may be characterized as a second parallel processing block. This second parallel processing block at position relates to the processing of the two requests relayed by the first and second resource proxies A B which are performed by the actual resources not illustrated and which are under control of the RPM .

While these two parallel processing blocks and have been illustrated as occurring on separate processors it is possible that this parallel processing could occur within the same system on a chip between different cores in a multi core system or among two different processing threads in a single core system as understood by one of ordinary skill in the art.

Next at time line position the first client may issue a third request to the first proxy resource A. At position it is possible that another client not illustrated may issue this third request to the first proxy resource A. This third request is either a single request or part of another transaction.

The framework manager or proxy resource A would monitor this third request being issued since the framework manager or proxy resource A has received notice that the previous two requests issued by the first client have been forked off from a transaction flagged as forked requests for parallel processing.

The framework manager or first proxy resource A holds onto the third request and waits until it receives notice at positions and from the RPM that the first request and second request constituting the batch request have been completed and serviced by the first proxy resource A.

The messages at positions and are generated by an interrupt service routine ISR that received a completion notice from the RPM . The ISR is a message vehicle or message medium in which the RPM may signal the issuing entity as represented by the local proxies that the forked batched requests have been serviced and completed. The ISR is just a convenient conventional mechanism that may be utilized in this manner. The system is not limited to the ISR for relaying communications between the RPM and the first client and could employ other mechanisms for sending messages to indicate that a forked batched request has been completed.

Any other communication medium for relaying messages between two processing entities besides ISR may be employed as understood by one of ordinary skill in the art. One advantage of the ISR for relaying communications is that communications between the two processing entities may be relayed asynchronously in that a modem does not need to look for the forked batched request complete signal from the RPM .

Using the ISR the RPM may send the forked batched request complete signal to the modem . In another exemplary embodiment instead of using the ISR the modem may be designed to poll the RPM and to search for the forked batched request complete signal to be issued by the RPM . Such alternatives of communicating the forked batched request complete signal are understood by one of ordinary skill the art.

If the forked batched request comprising the first and second request were already completed at position or prior to position the time in which the third request was issued then the framework manager or proxy first proxy resource A would not wait and hold onto the third request but instead immediately start processing the third request issued by the first client .

Subsequently at position the first proxy resource A forwards the third request to the RPM . After the third request has been serviced by the real resource not illustrated corresponding to the first resource A the RPM issues a third request complete signal at position that is related to the first proxy resource A.

Taking a step back and looking at at its entirety at time line position this position may be characterized as the fork point for the first proxy resource A and the second proxy resource B. This is where the first proxy resource A and the second proxy resource B have been forked because they were part of a forked transaction. These two proxy resources A B were forked implicitly because they were part of a forked transaction.

This means that the batched transaction of is forked while the two proxy resources A B are also forked. In other words three separate logical entities or representations have been forked at fork point the transaction itself the first proxy resource A and the second proxy resource B. At the fork point the first and second proxy resources A B enter into an incoherent state meaning that they cannot service a new request until they are joined at a join point as will be described below.

In this incoherent state the first and second proxy resources A B cannot service new requests until the forked request has been completed and all related clean up tasks have been completed locally. With this scenario several join points may be possible. Join points will now be described as follows.

In the exemplary embodiment illustrated in a join point exists where the batch request completion signal at time line position intersects the first proxy resource A. This join point may be characterized as the join point for the first proxy resource A and the transaction comprising the batch request.

At join point despite the fact that the transaction contained two requests the first request destined for the first proxy resource A and a second request destined for the second proxy resource B it is only the first proxy resource A that is joined at join point . Since the first proxy resource A is the only entity that the first client is concerned about with respect to the third request any cleanup work needed to join the second proxy resource B may continue to be deferred. Cleanup work may refer to additional tasks or work needed to bring the second resource represented by the second proxy resource B into a coherent state in which the second resource may service another request.

Even though the first proxy resource A and second proxy resource B are joinable at join point only the first proxy resource A is joined at join point since the third request only requires the first proxy resource A. The second proxy resource B may be characterized as in an incoherent state at join point . The second proxy resource B is joinable at this stage but since it is not required by the third request it can remain in its incoherent state.

A forked resource such as the second proxy resource B in this exemplary embodiment is not joined until it is needed by another request. While in this incoherent state the second proxy resource B does not need to complete any cleanup work or cleanup tasks associated with the fork request if another entity does not need services from the second proxy resource. This allows the cleanup work or cleanup tasks to be completed at a later time. Deferring cleanup work or cleanup tasks for a later time conserves processing power it allows cleanup work until absolutely necessary when services from a resource which may be in the incoherent state may be needed .

At that point in time when services from a resource that is in an incoherent state are needed like the second resource represented by the second proxy resource B illustrated in such as later fourth request not illustrated that is issued from the first client or some other client then this cleanup work or cleanup tasks may be completed by the second real resource represented by the second proxy resource B prior to processing or handling of the fourth request issued to this second resource currently in the incoherent state.

Therefore upon the receipt of a request like the fourth request a resource that was in an incoherent state based on a previous forked request may perform cleanup work and enter back into a coherent state when it receives a formal request from an entity such as the first client .

A transaction joins or enters into a coherent state whenever a request is made against any one resource that is being utilized for servicing a transaction. Multiple join points may exist when separate requests are made against each of the resources that were part of a transaction but the transaction entity is deem to be joined at the first join point that is executed i.e. when the first subsequent request arrives at any of the resources in the transaction or when the transaction itself is explicitly joined as described further below.

So for example a second join point not illustrated may occur at a later position relative to the first join point and against the second proxy resource B if a fourth request was issued by the first client against the second proxy resource B. A mechanism may be provided to explicitly join a transaction. This mechanism would join the transaction as well as every single resource that was part of the transaction.

This mechanism for joining a transaction may be characterized as a blocking call since it is designed to have the system wait until all requests of the transaction have been completed. So for example an entity such as the first client made an explicit call join the transaction the join transaction call would block the client until the first request and second request are completed by the real first and second resources under the control of the RPM .

Once the join transaction call received notice that the first and second requests have been completed as indicated by positions and then the join transaction call would join the first and second proxy resources A B together since the first and second proxy resources A B were part of the transaction. The join transaction call would then send a notice a call back to the requesting entity such as the first client indicating that first and second proxy resources A B are back in a coherent state ready to process any other further requests without undue delay. Delay would have existed due to cleanup if these proxy resources A B happened to be in an incoherent state absent the join transaction call.

Exemplary scenarios in which a join transaction call would be utilized are as follows a join transaction may be utilized when there is need for explicit synchronization or gating of a set of requests and or tasks. So for example suppose a request needed to be issued against the RPM in order to turn on some power rails. The individual requests to each power rail may be bundled up or batched into a transaction.

In this scenario with requests issued to the power rails while the RPM is turning on some power rails to various types of resources A B suppose the client needs to issue a request to a local resource which needs those rails to be on before it can process that request.

An explicit join call may be utilized here so that the system client waits until the rails have been powered up before issuing servicing the local request. Opposite to an explicit join call is a call that may be characterized as a lazy join or a fire and forget call. The lazy join call requires resources A B to be brought back into a coherent state but at the time when only a subsequent request is made against these resource or after a certain predetermined time period.

The system allows for bringing back all resources A B to coherency at the point where the transaction has joined itself into a coherent state . The third issued request at position may have easily brought everything the transaction itself as well as the two proxy resources A B back into a coherent state as understood by one of ordinary skill in the art. As discussed above it was for the sake of optimization for the particular embodiment of discussed above that not all proxy resources A B were brought back into a coherent state. In the embodiment described above it was advantageous to defer cleanup work with respect to some resources which means that all resources were not in a coherent state after the transaction was joined.

As described above a client may specify that a proxy resource A B may be forkable as well as a transaction comprising multiple requests. A client may also specify that a proxy resource A B or a transaction may not be forkable in the negative context .

A resource may fork itself even though the transaction may not have been designated by the client has been forked or forkable. For example suppose the second resource B was a local resource and not a proxy. Meanwhile the first resource A as illustrated in remains a proxy and is under control by the RPM . In this scenario in which the second resource B is a local resource relative to the modem then the second resource B would not be under control by the RPM .

If the client issued a transaction comprising a batch request for the first and second resources A B and even though the client may not have designated the transaction to be forkable the second resource B may on its own accord fork off from the transaction and process its request independently of the request being processed by the first resource A which again is a proxy relative to the newly designated second local resource B. This is an example where the second local resource B has forked itself from a transaction even though the transaction may not have been designated by the client as being forkable.

In view of the above transactions one of ordinary skill in the art will recognize that multiple transactions may be nested. In a nested multiple transaction scenario it is possible for an inner transaction of nested local transactions to desire to end synchronously while the outer transaction desires to become forkable. In such a scenario it is the outer transaction of the nested multiple transaction which controls the behavior of the nested group of transactions. So in the scenario just described if the outer transaction desire to be forkable then the inner transactions would permit such forking.

The system described above also supports join callbacks. The join callbacks are just paths that are executed conditional to and after the transaction is joined. Join callbacks may be explained in connection with a specific example in which clock settings of a CPU are desired to be changed. In such a scenario calls and requests may be made to locally managed resources as well as remote resources such as those illustrated in that may be under control of the RPM .

The clock may require the system to be running or operating at a certain voltage to maintain a certain processing speed. So for example if you wanted to change the clock speed from 200 MHz to 400 MHz then a voltage change may be needed. The voltage may be controlled by the RPM i.e. one or more requests may need to be dispatched to remote resources in order to increase the CPU s operating voltage.

So for efficiency sake a transaction should be created to bundle the set of remote requests. Additionally the transaction may be forked so that the client may continue to do other tasks while the change in voltage is effected by the RPM . However in the scenario where the voltage is not at the required level for the new clock speed the voltage will need to be raised before the clock speed is.

If the clock was increased before the new voltage got raised then some hardware may become damaged which is undesirable. In this scenario it is possible for a resource to issue a forked transaction to the RPM to change the voltage and then bind to the completion of that request a join call back the call back which will issue the request to the local clock.

A join callback containing the logic to increase the local clock frequency by issuing a request to that clock resource may thus be used to ensure that this request is processed only after the necessary dependency i.e. the voltage is in place. Suppose that the first client wanted to turn on two rails controlled by the RPM . Also suppose that the first client needs to turn on a local clock. This local clock may not be set to a particular value until these two rails are turned on.

Since the first client needs to turn on multiple rails with the RPM the first client may batch its requests for these two rails into a single transaction. It is only when this single transaction is complete can the first client request that the change to the local clock to occur.

In a forked transaction the first client does not know exactly when the requests are serviced and in this particular scenario the first client would not know when the first and second rails have been turned on by the RPM . So the first client may attach its transaction containing the two requests for the two rails to the local clock as a join call back. In this exemplary embodiment the join call back would occur at position as illustrated in . After position then the local clock may be adjusted since the callback would have indicated that the first and second rails have been turned on by the RPM . The join callback feature is part of the process of a resource or a transaction achieving coherency after the request or transaction has been serviced.

A forked transaction may be joined at multiple points. These multiple join points are managed by use of a construct called a join token. The join token has state information that is used to ensure that the transaction is only joined once either by the first subsequent request on one of the resources in the transaction or by an explicit client call to join the transaction.

The mechanics of a fork how it is accomplished is determined by constructs called extension s attached to a transaction. In the RPM s case for example as illustrated in the extension would be an implementation of the RPM transport protocol how requests from the modem are conveyed to the RPM and responses received .

The design also provides a mechanism by which a client may specify a fork preference. This is used by the extension when deciding whether to fork a transaction or complete it synchronously. With transactions just like with resources a call to fork the transaction is a request. If the extension is unable to fork the transaction it will complete the transaction synchronously and then invoke the registered join callback.

Note also that the design of transactions allows a client to issue requests on local resources not illustrated in which include those that are not serviced by the RPM after calling a function entitled begin transaction. These requests while ostensibly part of the transaction are not included in the batch. The associated resources however are locked and unlocked with the other resources in the transaction.

In the case of fork join this becomes important in the case where the local request is in itself forked during servicing. To accommodate this the reference to the join token of the transaction is distinct from the resource s own join token. Such an approach allows a resource to be forked both on its own and as part of a transaction.

Forked transactions may be supported by an application programming interface API . Each transaction API will be extended to include the following functions a fork transaction is an request to fork this transaction and is called in lieu of end transaction. It accepts a callback that will be invoked when the transaction later joins. If the extension does not fork the transaction this callback will be called synchronously.

While a transaction implicitly joins when a subsequent request arrives on any one of the resources in the transaction there may be cases where the client wishes to force a join without making a new request.

A join transaction function will join the transaction explicitly. This function may be implemented such that it either joins all the resources involved in the transaction alongside the transaction itself or it may only join the transaction entity while allowing the resources to become coherent later when processing subsequent requests.

A fork preference FORK ALLOWED DISALLOWED DEFAULT function may be queried or set using the transaction get set fork pref APIs. Extensions invoke the mark transaction forked API to obtain a join token and actually fork the transaction.

Additional APIs such as attach client to transaction and attach resource to transaction functions may be provided to enable attaching arbitrary resources to a transaction so that a subsequent request on those resources will also cause the transaction to join. This is useful in the case where the transaction is begun and requests issued from within the driver function of a parent resource. The parent can attach itself to the transaction despite not being part of it so that a subsequent request on it will cause the forked transaction to join.

In view of the disclosure above one of ordinary skill in the art is able to write computer code or identify appropriate hardware and or other logic or circuitry to implement the distributed resource management system and method without difficulty based on the flowcharts and associated description in this specification for example. Therefore disclosure of a particular set of program code instructions or detailed hardware devices is not considered necessary for an adequate understanding of how to make and use the distributed resource management system and method. The inventive functionality of the claimed computer implemented processes is explained in more detail in the above description and in conjunction with the drawing figures which may illustrate various process flows. Further the processors etc. in combination with the memory and the instructions stored therein may serve as a means for performing one or more of the method steps described herein.

In one or more exemplary aspects the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted as one or more instructions or code on a computer readable medium. Computer readable media include both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage medium may be any available medium that may be accessed by a computer. By way of example and not limitation such computer readable media may comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other optical or magnetic storage devices or any other medium that may be used to carry or store desired program code in the form of instructions or data structures and that may be accessed by a computer. The term disk or disc as used herein includes but is not limited to compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc. Combinations of the above should also be included within the scope of computer readable media.

Although selected aspects have been illustrated and described in detail it will be understood that various substitutions and alterations may be made therein without departing from the spirit and scope of the present disclosure as defined by the following claims.

