---

title: Heuristics for programming data in a non-volatile memory
abstract: Systems and methods are disclosed for heuristics associated with programming data in a non-volatile memory (“NVM”). One or more applications can generate information that notifies a system of the amounts of recoverable and unrecoverable new data that will be programmed to an NVM. Based on this information, the system can calculate the amount of new data that needs to be placed in a bulk mode instead of a SLC mode. By utilizing multi-modal modes of an NVM effectively, the system can improve overall performance and reduce the probability of unnecessary garbage collection.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08935459&OS=08935459&RS=08935459
owner: Apple Inc.
number: 08935459
owner_city: Cupertino
owner_country: US
publication_date: 20120308
---
NAND flash memory as well as other types of non volatile memories NVMs are commonly used for mass storage. For example consumer electronics such as portable media players often include flash memory to store music videos and other media.

An NVM may include blocks containing multiple memory cells where each memory cell can be configured either as a single level cell SLC or a multi level cell MLC . When a block is operating in a MLC mode the block is capable of storing more data as compared to a block operating in a SLC mode. However the MLC mode is generally less reliable than the SLC mode. That is a block operating in a MLC mode may be more susceptible to read errors as compared to a block operating in a SLC mode.

For performance purposes a system having an NVM can initially store data in a SLC mode. Then when additional space needs to be freed up in the NVM the stored data can be compacted to a MLC mode. Such a compacting process however may be inefficient and may unnecessarily wear out the NVM. Furthermore such a compacting process can cause a loss of bandwidth and increase the probability of user perceptible delays.

Systems and methods are disclosed for heuristics associated with programming data in a non volatile memory NVM . One or more applications can generate information that notifies a system of the amounts of recoverable and unrecoverable new data that will be programmed to an NVM. Based on this information the system can calculate the amount of new data that needs to be placed in a bulk mode instead of a SLC mode. As used herein a bulk mode can refer to a mode in which a block or super block of the NVM is capable of storing multiple bits per memory cell. In contrast a SLC mode can refer to a mode in which a block or super block of the NVM is capable of storing a single bit per memory cell. By utilizing multi modal modes of an NVM effectively the system can improve overall performance and reduce the probability of unnecessary garbage collection.

Systems and methods for heuristics associated with programming data in a non volatile memory NVM are provided. One or more applications can generate information that notifies an NVM interface of a system of the amounts of recoverable and unrecoverable new data that will be programmed to an NVM. As used herein recoverable data can refer to a class of data that is capable of being restored e.g. by downloading the data from a remote and or local data source . In contrast unrecoverable data can refer to a class of data that is not capable of being restored. Thus once unrecoverable data becomes corrupted or missing the data is no longer available.

Based on this information the NVM interface can calculate the amount of new data that needs to be placed in a bulk mode instead of a SLC mode. As used herein a bulk mode can refer to a mode in which a block or super block of the NVM is capable of storing multiple bits per memory cell. A SLC mode can refer to a mode in which a block or super block of the NVM is capable of storing a single bit per memory cell.

An application can be associated with e.g. can have or can download one or more assets e.g. one or more files . In some embodiments the NVM interface can sort assets based on reliability attributes e.g. recoverable and unrecoverable attributes and or locality attributes e.g. static and dynamic attributes of the assets. In some embodiments as a result of this sorting the NVM interface can internally separate data corresponding to the assets into a SLC flow and a bulk flow. In particular the NVM interface can first attempt to program all of the data in a SLC mode. However if the NVM interface determines that not all of the data can be stored in the SLC mode the NVM interface can determine an amount of new data to program in a bulk mode.

In other embodiments instead of separating data into flows that are associated with characteristics of super blocks of a NVM e.g. a SLC flow and a bulk flow the NVM interface can separate data into flows or streams that are associated with particular reliability attributes and or locality attributes. That is based on the reliability attributes and or the locality attributes of data and particularly macroscale or microscale alternating patterns of the reliability attributes and or the locality attributes the NVM interface can separate the data into a suitable number of streams.

Electronic device can include system on a chip SoC and non volatile memory NVM . Non volatile memory can include a NAND flash memory based on floating gate or charge trapping technology NOR flash memory erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM Ferroelectric RAM FRAM magnetoresistive RAM MRAM semiconductor based or non semiconductor based non volatile memory or any combination thereof.

NVM can be organized into blocks which can the smallest erasable unit and further organized into pages which can be the smallest unit that can be programmed or read. In some embodiments NVM can include multiple integrated circuits where each integrated circuit may have multiple blocks. Memory locations e.g. blocks or pages of blocks from corresponding integrated circuits may form super blocks . Each memory location e.g. page or block of NVM can be referenced using a physical address e.g. a physical page address or physical block address .

Physically a block of NVM can include an array of memory cells aligned in rows corresponding to word lines . The memory cells of a block may be configured to store any suitable number of bits per memory cell. For example memory cells that are referred to as single level cells SLC may be capable of storing one bit per cell. As another example memory cells that are referred to as multi level cells MLC or bulk cells may be capable of storing multiple bits per cell e.g. two bits per cell three bits per cell etc. . The number of pages in a given block may correspond to the number of bits stored per memory cell. For example a block being used as a 2 bit bulk block may include twice the number of pages as when the same block is being used as an SLC block.

The increased density of storage associated with bulk memory cells can improve space efficiency. That is a block or super block configured in a bulk mode may be capable of storing more data as compared to a block or super block configured in a SLC mode. However the increased density of storage associated with bulk memory cells can also reduce storage reliability and access speed e.g. increasing the amount of time needed for reading programming and or trimming . Thus a block or super block configured in a SLC mode may be more reliable e.g. less susceptible to read errors less space efficient and faster as compared to a block or super block configured in a bulk mode. In some embodiments one or more blocks or super blocks of NVM can be configured in parity modes e.g. XOR parity modes or redundant array of independent disks RAID parity modes . For example when combined with SLC a block or super block can have a SLC XOR mode. As another example when combined with bulk a block or super block can have a bulk XOR mode. The parity mode can be considered more reliable than the non parity mode e.g. probability of failure of the parity mode can be the square of the probability of failure of the non parity mode .

System on a chip can include SoC control circuitry memory and NVM interface . SoC control circuitry can control the general operations and functions of SoC and the other components of SoC or device . For example responsive to user inputs and or the instructions of an application or operating system SoC control circuitry can issue read or write requests to NVM interface to obtain data from or store data in NVM . For clarity data that SoC control circuitry may request for storage or retrieval may be referred to as user data even though the data may not be directly associated with a user or user application. Rather the user data can be any suitable sequence of digital information generated or obtained by SoC control circuitry e.g. via an application or operating system .

SoC control circuitry can include any combination of hardware software and firmware and any components circuitry or logic operative to drive the functionality of electronic device . For example SoC control circuitry can include one or more processors that operate under the control of software firmware stored in NVM or memory .

Memory can include any suitable type of volatile memory such as random access memory RAM e.g. static RAM SRAM dynamic random access memory DRAM synchronous dynamic random access memory SDRAM double data rate DDR RAM cache memory read only memory ROM or any combination thereof. Memory can include a data source that can temporarily store user data for programming into or reading from non volatile memory . In some embodiments memory may act as the main memory for any processors implemented as part of SoC control circuitry .

NVM interface may include any suitable combination of hardware software and or firmware configured to act as an interface or driver between SoC control circuitry and NVM . For any software modules included in NVM interface corresponding program code may be stored in NVM or memory .

NVM interface can perform a variety of functions that allow SoC control circuitry to access NVM and to manage the memory locations e.g. pages blocks super blocks integrated circuits of NVM and the data stored therein e.g. user data . For example NVM interface can interpret the read or write requests from SoC control circuitry perform wear leveling and generate read and program instructions compatible with the bus protocol of NVM .

While NVM interface and SoC control circuitry are shown as separate modules this is intended only to simplify the description of the embodiments of the invention. It should be understood that these modules may share hardware components software components or both. For example SoC control circuitry may execute a software based memory driver for NVM interface .

In some embodiments electronic device can include a target device such as a flash memory drive or SD card that includes NVM and some or all portions of NVM interface . In these embodiments SoC or SoC control circuitry may act as the host controller for the target device. For example as the host controller SoC can issue read and write requests to the target device.

Electronic device can include file system NVM driver NVM bus controller and NVM . In some embodiments file system and NVM driver may be software or firmware modules and NVM bus controller and NVM may be hardware modules. Accordingly in these embodiments NVM driver may represent the software or firmware aspect of NVM interface and NVM bus controller may represent the hardware aspect of NVM interface .

File system can include any suitable type of file system such as a File Allocation Table FAT file system or a Hierarchical File System Plus HFS and may be part of the operating system of electronic device e.g. part of SoC control circuitry of . In some embodiments file system may include a flash file system which provides a logical to physical mapping of pages. In these embodiments file system may perform some or all of the functionalities of NVM driver discussed below and therefore file system and NVM driver may or may not be separate modules.

File system may manage file and folder structures for the application and operating system. File system may operate under the control of an application or operating system running on electronic device and may provide write and read requests to NVM driver when the application or operating system requests that information be read from or stored in NVM . Along with each read or write request file system can provide a logical address to indicate where the user data should be read from or written to such as a logical page address or a logical block address with a page offset.

File system may provide read and write requests to NVM driver that are not directly compatible with NVM . For example the logical addresses may use conventions or protocols typical of hard drive based systems. A hard drive based system unlike flash memory can overwrite a memory location without first performing a block erase. Moreover hard drives may not need wear leveling to increase the lifespan of the device. Therefore NVM interface can perform any functions that are memory specific vendor specific or both to handle file system requests and perform other management functions in a manner suitable for NVM .

NVM driver can include translation layer . In some embodiments translation layer may be or include a flash translation layer FTL . On a write request translation layer can map the provided logical address to a free erased physical location on NVM . On a read request translation layer can use the provided logical address to determine the physical address at which the requested data is stored. Because each NVM may have a different layout depending on the size or vendor of the NVM this mapping operation may be memory and or vendor specific.

In addition to logical to physical address mapping translation layer can perform any other suitable functions that may be typical of flash translation layers such as garbage collection GC and wear leveling.

In some embodiments NVM driver may interface with NVM bus controller to complete NVM access requests e.g. program read and erase requests . Bus controller may act as the hardware interface to NVM and can communicate with NVM using the bus protocol data rate and other specifications of NVM .

NVM interface may manage NVM based on memory management data sometimes referred to herein as metadata . The metadata may be generated by NVM driver or may be generated by a module operating under the control of NVM driver . For example metadata can include any information used for managing the mapping between logical and physical addresses bad block management wear leveling ECC data used for detecting or correcting data errors or any combination thereof. The metadata may include data provided by file system along with the user data such as a logical address. Thus in general metadata may refer to any information about or relating to user data or used generally to manage the operation and memory locations of a non volatile memory.

NVM interface may be configured to store metadata in NVM . In some embodiments NVM interface may store metadata associated with user data at the same memory location e.g. page in which the user data is stored. For example NVM interface may store user data the associated logical address and ECC data for the user data at one or more memory locations of NVM . NVM interface may also store other types of metadata about the user data in the same memory location.

NVM interface may store the logical address so that on power up of NVM or during operation of NVM electronic device can determine what data resides at that location. In particular because file system may reference the user data according to its logical address and not its physical address NVM interface may store the user data and logical address together to maintain their association. This way even if a separate table maintaining the physical to logical mapping in NVM becomes outdated NVM interface may still determine the proper mapping at power up or reboot of electronic device for example.

Conventionally by default a system may store data in blocks of an NVM e.g. NVM of or NVM of that are configured in bulk modes. All of the data is consequently stored in the least reliable mode.

In other devices in order to improve performance a system may initially store data in blocks that are configured in SLC modes. Then when additional space needs to be freed up in the NVM the stored data can be compacted to a bulk mode. For example during garbage collection the stored data can be moved to blocks that are configured in bulk modes.

This compacting process can be relatively efficient when only a small portion of an NVM e.g. 40 50 is storing data. However when an NVM becomes substantially full such a compacting process may take a long time to complete. In addition for an NVM that is substantially full this compacting process can require more energy and can wear out the NVM at a faster rate in comparison to a system that initially selects to store the data in a bulk mode.

Accordingly an NVM interface of a system e.g. NVM interface of or NVM interface of can utilize information provided by one or more applications in order to determine an appropriate mode for programming data associated with a particular application. In particular the one or more applications can generate information that notifies the NVM interface of the amount of new data that will be programmed to an NVM. Based on this information the NVM interface can calculate the amount of new data that needs to be placed in a bulk mode instead of a SLC mode. By utilizing multi modal modes of an NVM effectively the system can improve performance and reduce the probability of unnecessary garbage collection.

In addition to instead of an NVM interface persons skilled in the art will appreciate that any other suitable component of the system e.g. a controller of an NVM such as NVM of or NVM of can determine an appropriate mode for programming data. Persons skilled in the art will also appreciate that instead of selecting to store data in two modes e.g. a bulk mode and a SLC mode the NVM interface can select to store data in three or more modes. For example the NVM interface can select to store data in a one bit per cell mode a two bits per cell mode and a three bits per cell mode. As another example the NVM interface can select to store data in a SLC mode a bulk mode a SLC XOR mode and a bulk XOR mode.

Persons skilled in the art will further appreciate that the two modes that are selected may be arbitrary so long as one of the two modes is more reliable and less space efficient e.g. one of the modes may have more bits per cell than the other mode . Thus in some embodiments instead of a bulk mode and a SLC mode the NVM interface can select to place a first amount of data in a two bits per cell mode and a second amount of data in a three bits per cell mode. In other embodiments the two modes can include a parity mode e.g. a XOR parity mode or a RAID parity mode and a non parity mode. For the sake of simplicity however the discussion below will refer to one mode as a SLC mode and the other mode as a bulk mode.

Turning now to a flowchart of illustrative process is shown for configuring an NVM e.g. NVM of or NVM of . Process may begin at step and at step an NVM interface e.g. NVM interface of or NVM interface of can receive a command from an application e.g. a daemon of the system that includes information associated with new data where the information associated with the new data includes an amount of recoverable new data and an amount of unrecoverable new data. That is the application may transmit its expectations regarding the quality and quantity of new data before actually transmitting the new data to the NVM interface. In particular the quantity of new data can allow the NVM interface to determine the frequencies of use of the different NVM modes. In some embodiments the new data may include only non replacement data e.g. data that is not already stored on an NVM .

As used herein recoverable data can refer to a class of data that is capable of being restored e.g. by downloading the data from a remote and or a local data source . For example once a system discovers that recoverable data stored on the system is corrupted or missing the data can be downloaded from a data source via a wired or wireless link. In contrast unrecoverable data can refer to a class of data that is not capable of being restored. Thus once unrecoverable data becomes corrupted or missing the data is no longer available.

Continuing to step the NVM interface can determine an estimated consumption of available space of an NVM by the new data and data that is currently stored in the NVM. For example the available space of the NVM can correspond to a total number of super blocks of the NVM that are available for programming. In some embodiments the available space of the NVM may exclude an amount of reserved space. As used herein the reserved space can be a pre determined amount of space of the NVM that can be used during garbage collection or for other purposes e.g. for moving invalid data . In some cases the amount of reserved space can be equal to a pre determined percentage of the total storage capacity of the NVM e.g. 7 20 .

The estimated consumption can equal the number of super blocks of the NVM that may be consumed by the new data and the data that is currently stored in the NVM. In some embodiments the estimated consumption may not correspond to the actual physical consumption by the new data and the data currently stored in the NVM. Rather the estimated consumption may correspond to the consumption of an ideal arrangement of data on the NVM. In some cases this arrangement may be similar to an arrangement of data after a garbage collection process performed on the NVM.

In some embodiments the NVM interface can calculate the estimated consumption according to current recoverable new recoverable bulk cost current unrecoverable new unrecoverable  cost 1 where C corresponds to the estimated consumption current recoverable corresponds to recoverable data currently stored in the NVM new recoverable corresponds to new recoverable data that will be received bulk cost corresponds to the cost of storing data in a bulk mode current unrecoverable corresponds to unrecoverable data currently stored in the NVM new unrecoverable corresponds to new unrecoverable data that will be received and SLC cost corresponds to the cost of storing data in a SLC mode.

In some embodiments the costs of storing data in the various modes can be normalized based on a default mode. For example the default mode can be a bulk mode where bulk cost can be defined to have a default value of one. Thus if the bulk mode corresponds to two bits per cell SLC cost can be equal to two. Likewise if the bulk mode corresponds to three bits per cell SLC cost can be equal to three.

At step the NVM interface can determine whether a difference between the available space and the estimated consumption is greater than a pre determined threshold. The pre determined threshold can have any suitable value such as for example 40 of the available space of the NVM.

If at step the NVM interface determines that the difference between the available space and the estimated consumption is greater than the pre determined threshold process may move to step . That is the NVM interface may determine that there is a constraint on the amount of space that is available for programming the new data.

For example an NVM may have an available space of 32 GB. Thus the pre determined threshold can be equal to 12.8 GB e.g. 32 GB 0.4 . If there is 8 GB of unrecoverable data currently stored in a SLC mode current unrecoverable and the NVM interface receives information that 2 GB of new unrecoverable data will be transmitted new unrecoverable C can be equal to 20 if the SLC cost is defined to have a value of two e.g. 8 GB 2 GB 2 . Thus because the difference between the available space and C e.g. 32 20 12 is less than the pre determined threshold e.g. 12.8 the NVM interface may determine that there is a constraint on the amount of space that is available for programming the new data.

Continuing to step the NVM interface can determine an amount of the new data that needs to be programmed in a first mode e.g. a bulk mode of the NVM. Then at step the NVM interface can determine to program a remaining amount of the new data in a second mode of the NVM e.g. a SLC mode . In other embodiments the NVM interface can determine to program a remaining amount of the new data in two or more modes of the NVM e.g. a SLC mode a SLC XOR mode and or a bulk XOR mode . Process may then end at step .

If at step the NVM interface instead determines that the difference between the available space and the estimated consumption is less than or equal to the pre determined threshold process may move to step . That is the NVM interface may determine that there is no constraint on the amount of space that is available for programming the new data.

At step the NVM interface can determine to program the new data in the second mode e.g. the SLC mode of the NVM. Process may then end at step .

Turning first to in a scenario where the usage is less than 40 100 of the available space of an NVM e.g. NVM of or NVM of can be configured in a SLC mode. Thus if a user has a device where less than 40 of the NVM is currently being used a more reliable and faster performance can be obtained from the NVM.

As another example as shown in in a scenario where the usage is greater than 90 100 of the available space of an NVM can be configured in a bulk mode. Hence if an NVM is mostly full all of the available space of the NVM can be configured in a bulk mode.

As yet another example as shown in in a scenario where the usage is between 40 and 90 a particular percentage of the available space of an NVM can be configured in a bulk mode and the remaining percentage of the available space can be configured in a SLC mode. As shown in 60 of the available space is configured in a bulk mode and 40 of the available space is configured in a SLC mode.

The actual percentages of the available space that are configured in a bulk mode versus a SLC mode can vary based on one or more factors such as for example the amount of space that is available one or more reliability attributes of the data e.g. recoverable or unrecoverable data and or one or more locality attributes of the data e.g. static or dynamic data . Reliability and locality attributes will be discussed in more detail in connection with .

Given the usage models of a worst case scenario may occur when the current usage of a system is at 39 e.g. corresponding to the usage model of and the system subsequently receives information that the amount of new data that will be transmitted is equal to 61 of the available space. In such a case the system may need to perform garbage collection on the NVM. That is the system may need to move data that is currently stored in a SLC mode and instead store the data in a bulk mode. Although this may be an inefficient process the magnitude of inefficiency may be reduced because block modality decisions are made with a larger scope of information e.g. on the order of GBs and not MBs .

Thus by varying the storage configurations of an NVM based on usage models the device can appear to function more reliably particularly in comparison to an approach where data is only stored in a MLC mode. Moreover by receiving information associated with new data from an application in advance of the actual arrival of the new data the system can make longer term decisions regarding the storage configurations of the NVM as compared to a conventional approach where applications do not provide such information. In these conventional approaches the scope of information that is available to a system is limited e.g. equal to the depth of a command queue . Finally higher write bandwidth rates of the NVM can be observed e.g. assuming there are no system bottlenecks .

Continuing to step the NVM interface can trim data associated with the assets that are already stored on an NVM. For example data associated the assets to be downloaded may include a new version of an asset already stored on the NVM. Thus by trimming the data the NVM interface can ensure that there are no overlaps between existing data and data to be downloaded. Consequently all of the data associated with the assets to be downloaded can be considered unique.

Then at step the NVM interface can sort the assets based on reliability attributes and or locality attributes of the assets. In some embodiments reliability attributes can include whether an asset e.g. data associated with the asset is recoverable or unrecoverable. Generally in terms of reliability attributes assets having unrecoverable attributes may be ranked higher than assets having recoverable attributes.

In other embodiments locality attributes can include whether an asset is static or dynamic. As used herein a static asset may be an asset that is rarely updated or changed. In contrast a dynamic asset may be an asset that is frequently updated or changed. Generally in terms of locality attributes assets having static attributes may be ranked higher than assets having dynamic attributes.

For example turning now to a table of illustrative rankings of assets is shown. As shown in table assets may be classified as having four different sets of attributes e.g. reliability and locality attributes static recoverable dynamic recoverable static unrecoverable and dynamic unrecoverable. In particular assets having static recoverable attributes may include assets such as music movies other media and device applications for example. These assets may be rarely updated and may also be recovered from a remote or local data source.

In comparison assets having dynamic recoverable attributes may include assets such as photos information associated with a user s contacts application screen shots for example. Although these assets can be recovered from a remote or local data source they may also be frequently updated.

Assets having static unrecoverable attributes may include assets such as an operating system image kernel s frameworks and internal applications for example. These assets may be rarely updated and may not be recovered from a remote or local data source. However they may be essential for proper functioning of a device e.g. assets may be required during device boot up .

Finally assets having dynamic unrecoverable attributes may include assets such as newly captured photos and private data e.g. passwords for example. In some cases these assets may have been transiently captured on a device and the device may not yet have had an opportunity to synchronize the assets with a data source. This class of assets may also include assets that a user has selected not to synchronize with a data source e.g. non data source application data .

The numbers shown in e.g. 1 to 4 may correspond to the rankings of the different classes of assets where 1 is considered the least reliable asset e.g. static unrecoverable and 4 is considered the most reliable asset e.g. dynamic recoverable . Persons skilled in the art will appreciate these rankings are merely illustrative and that the different classes of assets may be ranked differently depending on one or more characteristics of a system. For example in some embodiments dynamic recoverable assets may be considered less reliable than static recoverable assets.

Referring back to after sorting the assets based on reliability and or locality attributes at step the NVM interface can notify the NVM of an amount of new data associated with the assets. For example the amount of new data can include a first amount of new data associated with recoverable assets and a second amount of new data associated with unrecoverable assets. In some embodiments these two amounts can be transmitted to the NVM as two parameters in a function e.g. an application programming interface API function .

Then at step the NVM interface can download the new data associated with the assets. In some embodiments the NVM interface can receive one or more write commands associated with the new data where each write command can include a designator indicating if data associated with the command corresponds to a recoverable or unrecoverable asset.

Continuing to step the NVM interface can program the new data to the NVM e.g. one or more blocks or super blocks of the NVM based on the sorting of the assets. In some embodiments the NVM interface can program the new data associated with the recoverable assets before the new data associated with the unrecoverable assets. Process may then end at step .

In some embodiments based on the reliability and or locality attributes of the assets that are received the NVM interface can internally separate corresponding new data into one or more flows or streams while programming the new data. For example if the reliability attributes indicate that an asset is recoverable or unrecoverable the NVM interface can employ a process similar to process to determine one or more flows e.g. a SLC flow and or a bulk flow for programming corresponding new data.

That is the NVM interface can first attempt to program all of the new data in a SLC mode. If the NVM interface determines that not all of the new data can be stored in the SLC mode the NVM interface can determine an amount of the new data to program in a bulk mode. In some cases there may be a strong preference for storing new unrecoverable data in the most reliable mode. Hence the NVM interface can attempt to program new data associated with unrecoverable assets in block s or super block s that are configured in SLC modes.

For example turning now to an illustrative configuration of NVM is shown. NVM may include reserved space that is not available for programming. Persons skilled in the art will appreciate that NVM may also include other portions that are not shown in . For example NVM may include one or more portions that are already stored with data.

If an NVM interface e.g. NVM interface of or NVM interface of determines that not all new data can be programmed in a SLC mode the NVM interface can first program new recoverable data in a bulk mode. This may free up an amount of space in NVM that would not otherwise be available if new recoverable data was programmed in a SLC mode.

After programming new recoverable data if there is still a constraint on the amount of space that is available for programming the NVM interface can program a portion of new unrecoverable data in a bulk mode. Generally however the NVM interface will attempt to reduce the amount of unrecoverable data that is saved in the bulk mode. Once the NVM interface determines that there is no longer a constraint on the amount of space that is available for programming the NVM interface can program remaining new unrecoverable data in a SLC mode.

As another example if the NVM interface receives reliability attributes indicating whether an asset is recoverable or unrecoverable and also locality attributes indicating whether the asset is static or dynamic the NVM interface can employ a different process to determine one or more flows or streams for programming the new data. For instance turning now to an illustrative configuration of NVM is shown. The numbers e.g. 1 4 shown in can correspond to the rankings of different classes of assets provided in . That is 1 can correspond to static unrecoverable assets 2 can correspond to dynamic unrecoverable assets and so forth.

Persons skilled in the art will appreciate that the configuration shown in may include only a portion of NVM . For example NVM may also include a reserved space not shown in . As another example NVM may include one or more portions that are already stored with data.

Based on the rankings of the different classes of assets the NVM interface can internally separate corresponding new data into a SLC flow and a bulk flow while programming the new data. Thus as an example new static unrecoverable data and new dynamic unrecoverable data can be programmed in a SLC mode. In contrast new dynamic recoverable data can be programmed in a bulk mode. Moreover depending on the amount of available space on NVM the NVM interface can program a first portion of new static recoverable data in a SLC mode and a second portion of new static recoverable data in a bulk mode. Persons skilled in the art will appreciate that this is merely an illustrative example and that new data can be sorted in any suitable manner based on one or more factors such as for example the corresponding classes of assets and the amount of available space on the NVM.

In other embodiments instead of separating new data into flows associated with modes of blocks or super blocks of an NVM e.g. a SLC flow and a bulk flow the NVM interface can separate the new data into flows or streams associated with particular attributes. For example turning now to a flowchart of illustrative process for programming data in multiple flows is shown.

Process may begin at step and at step an NVM interface e.g. NVM interface of or NVM interface of can receive data from a file system e.g. file system of . For example the data may be transmitted from one or more applications.

Continuing to step the NVM interface can determine whether reliability attributes of the data have a macroscale alternating pattern. As used herein data can have a macroscale alternating pattern when there are interleaving patterns of reliability attributes e.g. recoverable unrecoverable recoverable etc. at a coarse granularity. That is the write order of the data can be sorted based on different reliability classes. This can be in contrast to a microscale alternating pattern which can refer to a scenario where there are interleaving patterns of reliability attributes at a fine granularity. Persons skilled in the art will appreciate that in other embodiments the NVM interface can determine whether locality attributes of the data have a macroscale alternating pattern.

If at step the NVM interface determines that the reliability attributes of the data do not have a macroscale alternating pattern process may move to step . In other words the NVM interface may have determined that the reliability attributes have a microscale alternating pattern.

At step the NVM interface can program the data in four streams e.g. four open host flows to four super blocks of an NVM e.g. NVM of or NVM of . The four streams can correspond to four sets of attributes static recoverable dynamic recoverable static unrecoverable and dynamic unrecoverable.

For example a first portion of data having static unrecoverable attributes can be programmed to a first super block and a second portion of data having dynamic recoverable attributes can be programmed to a second super block. In some embodiments the first super block can be configured in a SLC mode e.g. single bit per cell mode and the second super block can be configured in a bulk mode e.g. multiple bits per cell mode . In addition the remaining portions of data e.g. data associated with attributes of static recoverable and dynamic unrecoverable can be stored in third and fourth super blocks. The third and fourth super blocks can be configured in modes that are based on one or more suitable factor s such as for example the amount of current consumption and the available space in the NVM. In some cases the sorting of the data into the four streams can be performed inside the NVM software stack at the time of programming.

Accordingly by separating the data into four streams associated with four different super blocks there can be no blending of data having different attributes in the physical space. Persons skilled in the art will appreciate that flows can also be directed to different portions of an NVM such as for example different blocks of the NVM. Process may then end at step .

Referring back to step if the NVM interface instead determines that the reliability attributes of the data have a macroscale alternating pattern process may move to step . At step the NVM interface can identify attributes associated with the macroscale alternating pattern. For example the NVM interface can identify that the macroscale alternating pattern includes recoverable attributes followed by unrecoverable attributes and further followed by recoverable attributes etc. e.g. recoverable unrecoverable recoverable .

Continuing to step the NVM interface can program the data in two streams e.g. two open host flows to two super blocks of the NVM based on the attributes associated with the macroscale alternating pattern. For example if the macroscale alternating pattern is recoverable unrecoverable recoverable one of the streams can be a static stream that is programmed to a first super block and the other stream can be a dynamic stream that is programmed to a second super block. Persons skilled in the art will appreciate that the super blocks can be configured in any suitable mode based on the characteristics of the data and the NVM e.g. an amount of available space in the NVM . Process may then end at step .

In some embodiments while the NVM interface is programming the data in two streams the NVM interface can simultaneously monitor other attributes of the data. For example if the two streams are static and dynamic streams the NVM interface can monitor the recoverable unrecoverable reliability attributes of the data. Similarly if the two streams are recoverable and unrecoverable streams the NVM interface can monitor the static dynamic locality attributes of the data. Consequently when it is later determined to be necessary the NVM interface can separate the data into any suitable number of streams e.g. one or more streams . For example the NVM interface can use a garbage collection process to sort the data based on the attributes.

In other embodiments instead of using multiple flows the NVM interface can program data in a single flow where the flow can change its properties based on changes in the attributes of incoming data. For example responsive to receiving a large amount of data all sharing a particular set of attributes e.g. static recoverable dynamic recoverable static unrecoverable or dynamic unrecoverable the NVM interface can begin to program the data in a single flow to a super block configured in a mode e.g. SLC or bulk mode that is based on the set of attributes. Then as additional data is received the NVM interface may detect a change in the set of attributes that is associated with the new data.

Based on this detection the NVM interface can apply a suitable policy for programming the new data. For example if more than a particular percentage of the super block that is currently being programmed has already been filled e.g. 75 the NVM interface may continue programming the new data to the super block until the super block is fully programmed. However if the super block has not been filled to the particular percentage the NVM interface can allocate a new super block that is configured in a mode based on the changed set of attributes.

In further embodiments the NVM interface can algorithmically place data in different modes based on the age of the data. For example if the data is older data the NVM interface can place the data on a block or super block of the NVM that is configured in a MLC mode. In some embodiments in order to accomplish this result the NVM interface can configure a destination block or super block of garbage collection e.g. a free block or super block in a MLC mode. In contrast if the data is newer data the NVM interface can place e.g. program the data on a super block that is configured in a SLC mode. As a result in such a system newer data may be accessed more quickly than older data.

It should be understood that processes and of and may be executed by one or more components in a system e.g. electronic device of or electronic device of . Persons skilled in the art will appreciate that one or more of the steps may be performed by a control circuitry e.g. SoC control circuitry of an NVM interface e.g. NVM interface of or NVM interface of or a controller of the NVM.

Furthermore it should be understood that processes and of and are merely illustrative. Any of the steps may be removed modified or combined and any additional steps may be added without departing from the scope of the invention.

The described embodiments of the invention are presented for the purpose of illustration and not of limitation.

