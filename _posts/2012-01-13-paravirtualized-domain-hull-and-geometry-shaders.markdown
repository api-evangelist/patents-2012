---

title: Para-virtualized domain, hull, and geometry shaders
abstract: The present invention extends to methods, systems, and computer program products for providing domain, hull, and geometry shaders in a para-virtualized environment. As such, a guest application executing in a child partition is enabled use a programmable GPU pipeline of a physical GPU. A vGPU (executing in the child partition) is presented to the guest application. The vGPU exposes DDIs of a rendering framework. The DDIs enable the guest application to send graphics commands to the vGPU, including commands for utilizing a domain shader, a hull shader, and/or a geometric shader at a physical GPU. A render component (executing within the root partition) receives physical GPU-specific commands from the vGPU, including commands for using the domain shader, the hull shader, and/or the geometric shader. The render component schedules the physical GPU-specific command(s) for execution at the physical GPU.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08941671&OS=08941671&RS=08941671
owner: Microsoft Corporation
number: 08941671
owner_city: Redmond
owner_country: US
publication_date: 20120113
---
Computer systems and related technology affect many aspects of society. Indeed the computer system s ability to process information has transformed the way we live and work. Computer systems now commonly perform a host of tasks e.g. word processing scheduling accounting etc. that prior to the advent of the computer system were performed manually. More recently computer systems have been coupled to one another and to other electronic devices to form both wired and wireless computer networks over which the computer systems and other electronic devices can transfer electronic data. Accordingly the performance of many computing tasks is distributed across a number of different computer systems and or a number of different computing environments.

Some computer systems are configured to provide para virtualized execution environments which allow guest software to share hardware devices of a single computer system in an isolated manner. Generally para virtualized execution environments provide a plurality of partitions supported by a hypervisor. Each partition comprises an isolated execution environment for software executing therein. The partitions generally include a root partition and one or more child partitions. The root partition runs a host operating system and manages a virtualization stack. The root partition may gain access to physical devices. Each child partition hosts guest software e.g. guest operating systems and guest applications . Child partitions are provided access to physical devices through virtual devices and software interfaces of the hypervisor.

Some para virtualized execution environments provide child partitions and guest software executing therein with para virtualized access to one or more physical graphics processing units GPUs . Each implementation of para virtualized access to physical GPUs typically supports a single rendering framework. As such guest software may be unable to access one or more GPU functions of a physical GPU if that guest software is executing within a para virtualized execution environment that does not support those GPU functions. For example if the para virtualized execution environment supports a legacy version of a rendering framework then guest software executing within the para virtualized execution environment cannot leverage GPU functions implemented by newer versions of the rendering framework. This is true even though those functions are supported by the physical GPU.

Thus guest software may need to perform a GPU function not supported by the para virtualized environment in which it is running. When this occurs the guest software may rely on using a fully virtualized processing unit may use a translation layer to perform the GPU function and or may use an inferior GPU function that is supported by the para virtualized environment. Any of these solutions can incur potentially significant performance penalties for the guest software. In some cases the guest software may be unable to perform the GPU function at all leading to errors and or decreased functionality of the guest software.

The present invention extends to methods systems and computer program products for providing domain hull and geometry shaders in a para virtualized environment. As such embodiments of the invention provide a rich programmable GPU pipeline to guest applications.

Embodiments include a method for providing a programmable GPU pipeline to a guest application executing in a child partition of a para virtualized execution environment. A virtual machine session is instantiated. The virtual machine session includes a hypervisor that provides i a root partition which has access to a physical GPU and ii a child partition which executes a guest application .

A virtualized graphics processing unit vGPU which also executes within the child partition is presented to the guest application. The vGPU presents device driver interfaces DDIs of a rendering framework to the guest application as part of a user mode driver UMD . The DDIs provide an API that enables the guest application to send commands to the vGPU. The API enables the guest application to program a GPU pipeline of the physical GPU to utilize one or more features of the rendering framework including utilizing a domain shader a hull shader and or a geometric shader.

A render component which executes within the root partition receives one or more physical GPU specific commands from the vGPU. The physical GPU specific commands are for using the domain shader the hull shader or the geometric shader at the physical GPU. The render component schedules the physical GPU specific command s for execution at the physical GPU.

This summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Additional features and advantages of the invention will be set forth in the description which follows and in part will be obvious from the description or may be learned by the practice of the invention. The features and advantages of the invention may be realized and obtained by means of the instruments and combinations particularly pointed out in the appended claims. These and other features of the present invention will become more fully apparent from the following description and appended claims or may be learned by the practice of the invention as set forth hereinafter.

The present invention extends to methods systems and computer program products for providing domain hull and geometry shaders in a para virtualized environment. As such embodiments of the invention provide a rich programmable GPU pipeline to guest applications.

Embodiments include a method for providing a programmable GPU pipeline to a guest application executing in a child partition of a para virtualized execution environment. A virtual machine session is instantiated. The virtual machine session includes a hypervisor that provides i a root partition which has access to a physical GPU and ii a child partition which executes a guest application .

A virtualized graphics processing unit vGPU which also executes within the child partition is presented to the guest application. The vGPU presents device driver interfaces DDIs of a rendering framework to the guest application as part of a user mode driver UMD . The DDIs provide an API that enables the guest application to send commands to the vGPU. The API enables the guest application to program a GPU pipeline of the physical GPU to utilize one or more features of the rendering framework including utilizing a domain shader a hull shader and or a geometric shader.

A render component which executes within the root partition receives one or more physical GPU specific commands from the vGPU. The physical GPU specific commands are for using the domain shader the hull shader or the geometric shader at the physical GPU. The render component schedules the physical GPU specific command s for execution at the physical GPU.

Embodiments of the present invention may comprise or utilize a special purpose or general purpose computer including computer hardware such as for example one or more processors and system memory as discussed in greater detail below. Embodiments within the scope of the present invention also include physical and other computer readable media for carrying or storing computer executable instructions and or data structures. Such computer readable media can be any available media that can be accessed by a general purpose or special purpose computer system. Computer readable media that store computer executable instructions are computer storage media devices . Computer readable media that carry computer executable instructions are transmission media. Thus by way of example and not limitation embodiments of the invention can comprise at least two distinctly different kinds of computer readable media computer storage media devices and transmission media.

Computer storage media devices includes RAM ROM EEPROM CD ROM solid state drives SSDs e.g. based on RAM Flash memory phase change memory PCM other types of memory other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium which can be used to store desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer.

A network is defined as one or more data links that enable the transport of electronic data between computer systems and or modules and or other electronic devices. When information is transferred or provided over a network or another communications connection either hardwired wireless or a combination of hardwired or wireless to a computer the computer properly views the connection as a transmission medium. Transmissions media can include a network and or data links which can be used to carry desired program code means in the form of computer executable instructions or data structures and which can be accessed by a general purpose or special purpose computer. Combinations of the above should also be included within the scope of computer readable media.

Further upon reaching various computer system components program code means in the form of computer executable instructions or data structures can be transferred automatically from transmission media to computer storage media devices or vice versa . For example computer executable instructions or data structures received over a network or data link can be buffered in RAM within a network interface module e.g. a NIC and then eventually transferred to computer system RAM and or to less volatile computer storage media devices at a computer system. Thus it should be understood that computer storage media devices can be included in computer system components that also or even primarily utilize transmission media.

Computer executable instructions comprise for example instructions and data which when executed at a processor cause a general purpose computer special purpose computer or special purpose processing device to perform a certain function or group of functions. The computer executable instructions may be for example binaries intermediate format instructions such as assembly language or even source code. Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the described features or acts described above. Rather the described features and acts are disclosed as example forms of implementing the claims.

Those skilled in the art will appreciate that the invention may be practiced in network computing environments with many types of computer system configurations including personal computers desktop computers laptop computers message processors hand held devices multi processor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers mobile telephones PDAs tablets pagers routers switches and the like. The invention may also be practiced in distributed system environments where local and remote computer systems which are linked either by hardwired data links wireless data links or by a combination of hardwired and wireless data links through a network both perform tasks. In a distributed system environment program modules may be located in both local and remote memory storage devices.

Physical GPU is a processing device configured to perform parallel processing tasks such as graphics rendering tasks. Physical GPU supports a variety of GPU functions. Some supported GPU functions are fixed functions and some supported GPU functions are programmable functions. Programmable functions provide for a programmable rendering pipeline as opposed to a merely fixed rendering pipeline . A programmable rendering pipeline enables the output of one GPU function to become the input of another GPU function. In particular physical GPU supports both legacy programmable functions i.e. functions supported by legacy rendering frameworks and newer programmable functions i.e. functions supported by newer rendering frameworks . Legacy programmable functions may include vertex shaders and pixel shaders. Newer programmable functions may include domain shaders hull shaders and geometric shaders.

Computer architecture also includes hypervisor . Hypervisor executes on top of physical hardware and supports a virtualization platform. The virtualization platform provides a plurality of partitions. Each partition provides a logical unit of isolation in which guest software executes. As depicted computer architecture includes root partition and child partition .

Root partition executes a host operating system and has direct access to physical hardware as depicted by root partition appearing over physical hardware . Each child partition provides an execution environment for executing guest software e.g. operating systems and or applications and may access physical hardware indirectly in a para virtualized manner. That is each child partition provides one or more software interfaces e.g. virtualized hardware to guest software. The guest software in turn uses the software interface s to access physical hardware . Computer architecture can include a plurality of child partitions.

As depicted guest software executes within child partition . Guest software comprises an operating system and or an application program executing within an operating system. Guest software includes or uses graphics runtime . Guest software may be an operating system that includes graphics runtime or may be an application executing within the operating system that uses graphics runtime provided by the operating system. Graphics runtime corresponds to one or more graphics rendering frameworks and provides APIs which enable guest software to request execution of GPU functions of the supported rendering framework s e.g. various shaders .

Child partition provides guest software access to vGPU . vGPU virtualizes physical GPU enabling guest software to indirectly access physical GPU . As such vGPU is configured to expose all or a subset of the functionality of rendering frameworks supported by graphics runtime to guest software along with any corresponding functionality of physical GPU .

In particular vGPU is configured to expose one or more software interfaces to guest software that enable guest software to call vGPU for accessing GPU functions of physical GPU . vGPU in turn works in conjunction with render component in root partition to execute any requested GPU functions on physical GPU .

As depicted vGPU includes user mode driver and legacy user mode driver executing in a user mode of child partition . Each user mode driver exposes one or more device driver interfaces DDIs that enable guest software to indirectly request execution of GPU functions at physical GPU through calls to vGPU . Legacy user mode driver exposes legacy DDIs corresponding to GPU functionality that is supported by a legacy rendering framework. For example legacy DDIs may include DDIs related to fixed GPU functions or DDIs related to some programmable GPU functions supported by legacy rendering frameworks such as vertex shaders and or pixel shaders. As such legacy user mode driver of vGPU enables graphics runtime to make use of a legacy rendering framework.

User mode driver on the other hand exposes DDIs corresponding to GPU functionality that is supported by one or more newer rendering frameworks and that was not supported by the legacy rendering framework. For example DDIs may include DDIs related to additional programmable GPU functions such as domain shaders hull shaders and or geometric shaders. In some embodiments DDI s expose all DDIs supported by one or more newer rendering frameworks.

In some embodiments each user mode driver exposes DDIs from the DirectX rendering framework from Microsoft Corporation. For example legacy user mode driver may support the version 9 series of DirectX e.g. version 9.0c . As such legacy DDIs may include DDIs from the version 9 series of Direct3D e.g. DDIs relating to fixed GPU functions and some programmable GPU functions supported by Direct3D version 9 such as vertex shaders and or pixel shaders . Continuing the DirectX example user mode driver may support one or more newer versions of DirectX such as the version 10 and or the version 11 series of DirectX . As such DDIs can include DDIs from one or more of versions 10 and or 11 of Direct3D e.g. DDIs relating to domain hull and or geometric shaders . In addition DDIs may also include Direct2D DDIs. In some embodiments DDIs include all DirectX version 10 and 11 DDIs such that graphics runtime can utilize the full range of DirectX version 10 and 11 functionality.

In other embodiments legacy user mode driver exposes DDIs of a legacy version of another rendering framework such as OpenGL from Silicon Graphics Inc and user mode driver exposes DDIs of a newer version of the other rendering framework.

Generally user mode driver and legacy user mode driver are each configured to construct hardware contexts and command buffers. In particular each user mode driver converts graphic commands issued by guest software or graphics runtime into hardware specific commands for execution on physical GPU .

As depicted for example user mode driver may receive graphics commands which request that GPU functions e.g. domain hull or geometric shaders Direct2D functions be executed at physical GPU on behalf of guest software . User mode driver is configured to convert the received graphics commands into hardware specific commands i.e. commands that are specific to physical GPU . As part of the conversion user mode driver maintains proper hardware context for physical GPU . For example user mode driver translates logical values for settings affecting a rendering pipeline into values and corresponding physical settings. User mode driver is also configured to store converted hardware specific commands in a command buffer. Legacy user mode driver is similarly configured.

vGPU also includes kernel mode driver executing in a kernel mode of child partition . Kernel mode driver is configured to receive command buffers from user mode driver and legacy user mode driver and to construct corresponding direct memory access DMA buffers. When it is time for a DMA buffer to be processed kernel mode driver is configured to submit the DMA buffer to physical GPU .

As depicted kernel mode driver includes processing component which is configured to process command buffers from user mode driver and legacy processing component which is configured to process command buffers from legacy user mode driver . For example depicts kernel mode driver receiving command buffer from user mode driver . Kernel mode driver is configured to process command buffers received from user mode driver using processing component to generate a DMA buffer. While not depicted kernel mode driver can also communicate with graphics runtime directly. As such one or both of processing component and or legacy processing component can process commands received directly from graphics runtime . For example kernel mode driver can receive and process commands related to geometry hull and or domain shaders and Direct2D functions.

As indicated previously root partition includes render component which is configured execute any requested GPU functions on physical GPU . As depicted render component includes renderer which is configured to initiate execution of GPU functions corresponding to DDIs and legacy renderer which is configured to initiate execution of GPU functions corresponding to legacy DDIs . As such render component is configured to execute GPU functions from both a newer rendering framework and a legacy rendering framework.

In particular render component is configured to schedule any physical GPU specific rendering commands graphics commands received from vGPU for execution on physical GPU and to create proper context for executing those commands. For example render component is configured to create any appropriate composition device s at physical GPU . The composition device typically represents a desktop running in connection with guest software .

As depicted computer architecture includes communications connections between render component and user mode driver legacy user mode driver and kernel mode driver . In addition computer architecture enables negotiation of communications protocol s among these components.

Negotiation can include determining an appropriate composition device to create at physical GPU so that GPU functions requested by graphics runtime guest software can be accelerated at physical GPU . During boot time of a guest operating system within child partition for example the composition device may be determined to correspond to user mode driver of a newer rendering framework or correspond to legacy user mode driver and a legacy rendering framework. After this initial communications protocol negotiation process protocol negotiation may be repeated for each guest application run as part of guest software to create an appropriate composition device representing each application. Composition devices can concurrently be created for applications using both newer rendering framework s and a legacy rendering framework. As such computer architecture supports execution of GPU functions from multiple rendering frameworks at physical GPU including newer rendering frameworks represented by user mode driver and a legacy rendering framework represented legacy user mode driver .

Once appropriate composition device s is are determined each of the supported DDIs are represented by one or more tokens. These tokens are communicated between each user mode driver and corresponding components at kernel mode driver and render component . Thus any GPU functions corresponding to any supported DDIs are enabled by computer architecture .

Method includes an act of instantiating a virtual machine session including instantiating a hypervisor that provides i a root partition having access to the physical GPU and ii the child partition which executes the guest application act . For example hypervisor is instantiated. Hypervisor is used to provide root partition and child partition . Child partition can execute guest software .

Method also includes an act of presenting a vGPU to the guest application the vGPU executing within the child partition including presenting a plurality of DDIs of a rendering framework to the guest application as part of a UMD of the vGPU the plurality of DDIs providing an API that enables the guest application to send commands to the vGPU for programming a GPU pipeline of the physical GPU to utilize one or more features of the rendering framework including utilizing at least one of a domain shader a hull shader or a geometric shader act . For example child partition presents vGPU to guest software rendering framework . vGPU virtualizes physical GPU . vGPU includes user mode driver . User mode driver exposes DDIs which correspond to a rendering framework that includes one or more of domain shader a hull shader or a geometric shader. In some embodiments DDIs expose all DDIs of one or more rendering frameworks.

Method also includes an act of a render component executing within the root partition receiving at least one physical GPU specific command from the vGPU for using one or more of a domain shader a hull shader or a geometric shader act . For example render component which executes in root partition can receive GPU commands and data from user mode driver and or kernel mode driver . These commands and data can include physical GPU specific commands that were generated by user mode driver in response to receiving graphics commands from graphics runtime . These physical GPU specific commands can include commands related to a newer graphics runtime such as commands related to a domain shader a hull shader or a geometric shader.

Method also includes an act of the render component scheduling the at least one physical GPU specific command for execution at the physical GPU act . For example renderer can schedule the received physical GPU specific commands for execution on physical GPU . This can involve setting up appropriate context and composition device s at physical GPU .

Accordingly the present invention provides domain hull and geometry shaders in a para virtualized environment. Thus a guest application executing in a child partition is enabled use a rich programmable GPU pipeline of a physical GPU.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes that come within the meaning and range of equivalency of the claims are to be embraced within their scope.

