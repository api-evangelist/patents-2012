---

title: Work-queue-based graphics processing unit work creation
abstract: One embodiment of the present invention enables threads executing on a processor to locally generate and execute work within that processor by way of work queues and command blocks. A device driver, as an initialization procedure for establishing memory objects that enable the threads to locally generate and execute work, generates a work queue, and sets a GP_GET pointer of the work queue to the first entry in the work queue. The device driver also, during the initialization procedure, sets a GP_PUT pointer of the work queue to the last free entry included in the work queue, thereby establishing a range of entries in the work queue into which new work generated by the threads can be loaded and subsequently executed by the processor. The threads then populate command blocks with generated work and point entries in the work queue to the command blocks to effect processor execution of the work stored in the command blocks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489245&OS=09489245&RS=09489245
owner: NVIDIA Corporation
number: 09489245
owner_city: Santa Clara
owner_country: US
publication_date: 20121026
---
The present invention generally relates to computer processing and more specifically to enabling local generation of work within a graphics processing unit GPU .

Graphics processing units GPUs are designed to process a variety of intensive tasks within a computing system such as graphics processing work and compute application work. In a typical configuration a central processing unit CPU generates GPU based work and loads the GPU based work into a global memory that is accessible to both the CPU and the GPU. The CPU then accesses a work queue of the GPU often referred to as a channel through which the CPU is able to cause the GPU to process the GPU based work stored in the global memory.

In one configuration the processing activity of the GPU is controlled by the manipulation of two separate pointers that each refer to an entry in the work queue referred to herein as the GP GET pointer and the GP PUT pointer. The GP GET pointer points to a particular entry in the work queue and indicates to the CPU how far along the GPU is in executing the work stored in the work queue. Alternatively the GP PUT pointer points to the entry in the work queue right after the last entry written by the CPU. When the GPU completes execution of GPU based work pointed to by a given work queue entry the GPU increments GP GET. Notably when GP GET reaches the entry count of the work queue GP GET is reset to a value of zero since the work queue is circular. If after being incremented GP GET is equal to GP PUT then no more entries in the work queue remain to be processed. Otherwise the GPU executes the work pointed to by GP GET. Also If GP GET is equal to GP PUT 1 modulo number of entries in the work queue then the work queue is considered as full. As long as the work queue is not full the CPU can increment the GP PUT pointer in order to submit new entries written in the work queue for GPU processing. The GPU monitors changes to GP PUT performed by the CPU such that the CPU submitted work queue entries are processed in a timely manner.

In many cases it is desirable to enable the GPU to generate additional i.e. nested work that can be loaded into the work queue by the GPU and processed by the GPU. Unfortunately specific hardware limitations exist between popular CPU to GPU communication channels such as Peripheral Component Interconnect Express PCI E and prevent the GPU from being able to modify the GP PUT pointer which as described above needs to be incremented after inserting new work into the work queue. As a result the GPU must rely on the CPU to generate and execute nested work which is inefficient in comparison to locally generating and executing nested work within the GPU.

Accordingly what is needed in the art is a technique for enabling a GPU to locally generate work in the presence of CPU to GPU communication channel hardware limitations.

One embodiment of the present invention sets forth a method for generating work within a parallel processing subsystem. The method includes the steps of generating a first command block that includes one or more entries generating instructions to be executed by the parallel processing subsystem loading the instructions into N command blocks generating one additional command block loading a Semaphore Acquire command into the single entry of the additional command block determining via atomic increment of a first pointer and comparison to a second pointer that at least N 1 entries in the plurality of entries of a work queue are free pointing N entries in the plurality of entries of a work queue starting at the result of the atomic increment to the first N command blocks and pointing an Nth 1 entry in the plurality of entries of a work queue to the additional command block.

One advantage of the disclosed embodiments of the present invention is that they enable threads executing on the processing unit to create nested work within the processing unit without needing to issue requests to a CPU to do so. As a result less bandwidth is consumed across the communication path between the CPU and processing unit and further the workload of the CPU is reduced thereby increasing efficiency. Moreover the threads are capable of executing useful nested work without relying on the CPU for authorization or having to wait for the CPU to respond to a request to submit the generated nested work to the GPU.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including universal serial bus USB or other port connections compact disc CD drives digital versatile disc DVD drives film recording devices and the like may also be connected to I O bridge . The various communication paths shown in including the specifically named communication paths and may be implemented using any suitable protocols such as PCI Express AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements in a single subsystem such as joining the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip instead of existing as one or more discrete devices. Large embodiments may include two or more CPUs and two or more parallel processing subsystems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to as well as in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various operations related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and the second communication path interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have a dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs in parallel processing subsystem may output data to display device or each PPU in parallel processing subsystem may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a data structure not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . A pointer to each data structure is written to a work queue to initiate processing of the stream of commands in the data structure. The PPU reads command streams from one or more work queues and then executes commands asynchronously relative to the operation of CPU . Execution priorities may be specified for each work queue by an application program via the device driver to control scheduling of the different work queues.

Referring back now to as well as each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI Express link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each work queue and outputs the command stream stored in the work queue to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed from a work distribution unit within a task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in the command stream that is stored as a work queue and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices of data to be processed as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule execution of the processing task. Processing tasks can also be received from the processing cluster array . Optionally the TMD can include a parameter that controls whether the TMD is added to the head or the tail for a list of processing tasks or list of pointers to the processing tasks thereby providing another level of control over priority.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of dynamic random access memory DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons of ordinary skill in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI Express connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Multiple processing tasks may be executed concurrently on the GPCs and a processing task may generate one or more child processing tasks during execution. The task work unit receives the tasks and dynamically schedules the processing tasks and child processing tasks for execution by the GPCs .

The work distribution unit includes a task table with slots that may each be occupied by the TMD for a task that is being executed. The task management unit may schedule tasks for execution when there is a free slot in the task table . When there is not a free slot a higher priority task that does not occupy a slot may evict a lower priority task that does occupy a slot. When a task is evicted the task is stopped and if execution of the task is not complete then a pointer to the task is added to a list of task pointers to be scheduled so that execution of the task will resume at a later time. When a child processing task is generated during execution of a task a pointer to the child task is added to the list of task pointers to be scheduled. A child task may be generated by a TMD executing in the processing cluster array .

Unlike a task that is received by the task work unit from the front end child tasks are received from the processing cluster array . Child tasks are not inserted into work queues or transmitted to the front end. The CPU is not notified when a child task is generated or data for the child task is stored in memory. Another difference between the tasks that are provided through work queues and child tasks is that the tasks provided through the work queues are defined by the application program whereas the child tasks are dynamically generated during execution of the tasks.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment each GPC includes a number M of SMs where M 1 each SM configured to process one or more thread groups. Also each SM advantageously includes an identical set of functional execution units e.g. execution units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SM . A thread group may include fewer threads than the number of processing engines within the SM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SM in which case processing will take place over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SM and m is the number of thread groups simultaneously active within the SM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SM contains a level one L1 cache shown in or uses space in a corresponding L1 cache outside of the SM that is used to perform load and store operations. Each SM also has access to level two L2 caches that are shared among all GPCs and may be used to transfer data between threads. Finally SMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally a level one point five L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SM including instructions uniform data and constant data and provide the requested data to SM . Embodiments having multiple SMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units . The cache line index may be used to determine whether or not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SM and is fetched from an L2 cache that is shared between all GPCs parallel processing memory or system memory as needed. Each SM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SMs or texture units preROPs may be included within a GPC . Further as shown in a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches to execute tasks for one or more application programs.

Persons of ordinary skill in the art will understand that the architecture described in in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during the thread s execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each thread s position. In one embodiment special registers include one register per thread or per exec unit within SM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all threads that execute the same processing task represented by a TMD or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs or queue position if the TMD encodes a queue task instead of a grid task and an identifier of the TMD to which the CTA is assigned.

If the TMD is a grid TMD execution of the TMD causes a fixed number of CTAs to be launched and executed to process the fixed amount of data stored in the queue . The number of CTAs is specified as the product of the grid width height and depth. The fixed amount of data may be stored in the TMD or the TMD may store a pointer to the data that will be processed by the CTAs. The TMD also stores a starting address of the program that is executed by the CTAs.

If the TMD is a queue TMD then a queue feature of the TMD is used meaning that the amount of data to be processed is not necessarily fixed. Queue entries store data for processing by the CTAs assigned to the TMD . The queue entries may also represent a child task that is generated by another TMD during execution of a thread thereby providing nested parallelism. Typically execution of the thread or CTA that includes the thread is suspended until execution of the child task completes. The queue may be stored in the TMD or separately from the TMD in which case the TMD stores a queue pointer to the queue. Advantageously data generated by the child task may be written to the queue while the TMD representing the child task is executing. The queue may be implemented as a circular queue so that the total amount of data is not limited to the size of the queue.

CTAs that belong to a grid have implicit grid width height and depth parameters indicating the position of the respective CTA within the grid. Special registers are written during initialization in response to commands received via front end from device driver and do not change during execution of a processing task. The front end schedules each processing task for execution. Each CTA is associated with a specific TMD for concurrent execution of one or more tasks. Additionally a single GPC may execute multiple tasks concurrently.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any thread within the same CTA or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SM to begin execution of a task that uses these parameters. Any thread within any CTA or any exec unit within SM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the thread to which the register is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers. Additionally a uniform L1 cache stores uniform or constant values for each lane of the N exec units and P load store units LSU .

Shared memory is accessible to threads within a single CTA in other words any location in shared memory is accessible to any thread within the same CTA or to any processing engine within SM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and task ID as well as CTA and grid dimensions or queue position implementing portions of the special registers. Each LSU in SM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 cache in each SM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to the shared memory and the L1 cache via a memory and cache interconnect .

As set forth in greater detail herein the present invention enables threads executing on a PPU to locally generate and execute work within that PPU by way of work queues and command blocks. In one embodiment device driver as an initialization procedure for establishing memory objects that enable the threads to locally generate and execute work generates a PPU owned work queue and sets a GP GET pointer of the PPU owned work queue to a first entry included the PPU owned work queue. Device driver also during the initialization procedure sets a GP PUT pointer of the PPU owned work queue to a last entry included in the PPU owned work queue thereby establishing a range of entries in the PPU owned work queue into which new work generated by the threads can be loaded and subsequently executed by the PPU . A detailed description of the initialization procedure is provided below in conjunction with .

To organize the manner in which the GP GET pointer advances through the PPU owned work queue which as set forth herein controls what PPU generated work is executed by the PPU embodiments of the invention employ the use of semaphores which are objects stored in global memory accessible to both the CPU and the PPU e.g. the PP memory . As is described in further detail below commands to Acquire or Release semaphores are inserted based on the work generated by the threads executing locally on PPU into different command blocks pointed to by entries of the work queue in order to establish a controlled schedule by which the PPU executes the locally generated work. A detailed description of how the threads insert work into the work queue is described below in conjunction with .

As shown the method begins at step where device driver receives a work request while executing on CPU and the work request includes instructions that cause threads executing on the PPU to locally generate and execute additional work within the PPU . In one embodiment the work request references functions within a particular application programming interface API supported by device driver that enables a developer to indicate to the device driver that the work request when executed will cause one or more threads executing on the PPU to locally generate additional i.e. nested work to be executed by the PPU . In this way device driver is caused to set up the work queue according to steps described below.

At step device driver generates a PPU owned work queue where the PPU owned work queue includes a plurality of entries and each entry can be configured to point to a non empty command block. An example of the PPU owned work queue is illustrated as work queue in which includes a plurality of entries . At step the device driver also allocates two memory blocks in the PPU owned work queue one for a semaphore X and one for a semaphore Y which are referenced in semaphore Acquire and Release commands in and initializes the semaphore X and the semaphore Y to zero. For each work request received at step the device driver generates command blocks that contain Kernel Launch Wait for Idle Semaphore Release X and Semaphore Acquire Y commands and points one or more entries in a CPU owned channel e.g. the CPU owned channel illustrated in to these generated command blocks as illustrated in and described in further detail below.

At step device driver generates a command block containing a Semaphore Acquire command that blocks until a value is written into semaphore X s memory block. In this way the GP GET pointer which points indirectly to the Semaphore Acquire command prevents the host interface from incrementing the GP GET pointer until semaphore X is unblocked. An example of this command block is illustrated in as command block where the first the Semaphore Acquire command in command block is directed to a semaphore which exists at a particular area of memory. The Semaphore Acquire command blocks the Host Interface until a value is written into that area of memory i.e. the semaphore is released . In one embodiment multiple semaphores are organized into a data object that includes the same number of entries as the PPU owned work queue which is illustrated in as semaphores . Also shown in is a one to one correspondence that exists between the semaphore entries of semaphores and the entries of the work queue .

As described herein the GP GET pointer is the index of the first available entry of the plurality of entries of the PPU owned work queue. At step device driver reads the GP GET pointer of the PPU owned work queue e.g. the PPU owned channel of and points the first available entry in the work queue to the command block generated at step . This is illustrated in as GP GET pointing to the first entry of work queue . At step device driver points the GP PUT pointer to a last entry in the plurality of entries of the PPU owned work queue to allow the threads to point free entries that lie between GP GET and GP PUT to generated command blocks that include locally generated PPU work. In one embodiment the GP PUT pointer is pointed to the return value produced by the function wrap GP GET 1 work queue entry count where work queue entry count represents the total number of entries in the work queue. In one embodiment the wrap function is executed in a manner that is based upon the number of entries in the work queue. More specifically if the value of work queue entry count is not a power of two then the wrap function is executed as follows 

Otherwise if the value of work queue entry count is a power of two then the wrap function is executed as follows 

Due to limitations in the PCI Express specification the values of GP GET and GP PUT for any channel are not accessible to the threads running on the PPU . As a result the threads have no way of adding work into the PPU owned work queue by manipulating these values. To cure this deficiency a method by which the threads are able to concurrently add work into the work queue in a controlled manner is described at step . In this step device driver generates a soft GP PUT pointer and a shadow GP PUT pointer where the soft GP PUT pointer is initialized to point to an entry subsequent to the entry pointed to by the GP GET pointer of the PPU owned work queue and the shadow GP PUT pointer is initialized to point to the same entry as GP PUT pointer of the PPU owned work queue. Unlike the GP GET pointer and the GP PUT pointers both the soft GP PUT pointer and the shadow GP PUT pointer are accessible to the threads. In this manner the threads can atomically update and read the soft GP PUT pointer and the shadow GP PUT pointer to determine the next available entry the PPU owned work queue into which new work can be inserted.

At step host interface executes the Wait for Idle command inserted at step waiting until all the threads executing on PPU have indicated that they have completed execution including all the memory transactions they generated. This step illustrated in as a WFI command prevents GP GET from being incremented until the threads have completed. Upon receiving such indication method proceeds to step where host interface executes a Semaphore Release command which releases the semaphore generated at step to cause the PPU generated work in the PPU owned work queue to begin executing. An example illustration of what occurs after the host interface releases the semaphore is described below in conjunction with .

As shown method begins at step where a thread executing within one of the PPUs receives 1 a pointer to a PPU owned work queue which is generated by the device driver according to step of that is configured to enable local generation and execution of work on the PPU 2 a soft GP PUT pointer which is also generated by the device driver according to step of and 3 a shadow GP PUT pointer which is further generated by the device driver according to step of .

At step the thread generates N command blocks each including a plurality of commands. An example of such a command block is illustrated in as command block which includes a plurality of PPU based commands generated by a thread. At step the thread populates the command block with PPU based instructions.

At step the thread generates another command block and it inserts a Semaphore Acquire command in into a first entry of the command block. This command when later executed by host interface will cause it to block until a value is written into the area of memory corresponding to the semaphore. An example of such a single entry command block is illustrated as command block in . At step the thread issues an atomic request to increment soft GP PUT by N 1. The value returned by the atomic increment request is used as the index of the first entry in a sequence of N 1 entries in the PPU owned worked queue that have been allocated for the thread s work N entries that will be used to point to the command blocks generated in step and one that will be used to point to the command block generated in step .

At step the thread determines whether there are enough free entries available in the PPU owned work queue that can be pointed to the N 1 command blocks generated at steps and respectively. In one embodiment this determination is made by comparing the value returned by the atomic increment request of step against the shadow GP PUT pointer to ensure that the addition of soft GP PUT plus N 1 does not exceed the shadow GP PUT pointer which indicates that there is are enough free entries available in the PPU owned work queue. The thread then points the N entries in the PPU owned work queue to the command blocks generated in step and further points the last of the N 1 allocated entries in the PPU owned work queue to point to the command block with the Semaphore Acquire command generated at step .

At step the thread determines whether all of the new work generated by the thread has been fully inserted into the PPU owned work queue. When all of the new work has in fact been fully inserted into the work queue then at step the thread releases the semaphore that corresponds to the work queue entry immediately before the entry that resulted from the atomic increment at step . The semaphore release in this case is performed by writing to the semaphore s memory block the value for which the corresponding Semaphore Acquire command is configured to wait. This will allow the execution by Host Interface of the work commands included in the command blocks generated by the thread in steps and as soon as the host interface can schedule them. This will only happen after execution of all command blocks inserted in the work queue before those generated by the thread in steps and which may include Semaphore Acquire commands such as those inserted in step or in step that would be preventing host interface from making forward progress pending their release. An example scenario of step is illustrated in .

At step the thread determines by means of application specific logic if any additional work needs to be inserted into the PPU owned work queue. If so then method proceeds to step where the thread inserts into the PPU owned work queue an entry pointing to a command block that contains a Wait for Idle WFI command a Semaphore Release Y command and a Semaphore Acquire X command following the approach described in steps through . When host interface executes these commands first the Wait for Idle command guarantees that all work in the PPU owned channel also known as PPU owned work queue has completed second the Semaphore Release Y command writes a value into semaphore Y s memory block that unblocks any work on the CPU owned work queue that was blocked by the Semaphore Acquire Y command generated at step . Finally the Semaphore Acquire X command blocks further progress by host interface while processing PPU Owned Channel . An example scenario of this event is illustrated in .

In the GP GET pointer points to a kernel launch that includes references to functions within a particular API supported by device driver that enables a developer to indicate to host interface that the work request when executed will cause one or more threads executing on the PPU to locally generate additional i.e. nested work that is to be executed by the PPU . The device driver initializes a PPU owned channel illustrated in according to the techniques described above in conjunction with .

As shown in the PPU owned channel includes a plurality of entries which include an Acquire X entry that is unblocked when the Release X entry within the CPU owned channel is pointed to the GP GET . Also shown in is GP PUT which has been set to point to a last entry of the work queue to establish a range of entries into which the threads can insert new work to be executed. Also shown in is a first command block PBS which is followed by an Acquire A semaphore entry that is unblocked by the thread when the thread that generates PBS indicates that no additional work will be generated by the thread. The PPU owned channel also includes a second command block PBS which is followed by an Acquire B semaphore entry that is unblocked when a thread determines that no additional work needs to be generated and performs step .

In combination disclosed embodiments of the present invention enable threads executing on a PPU to locally generate and execute work within the PPU by way of a PPU owned work queue and command blocks. The GP GET and GP PUT pointers of the PPU owned work queue are set by the device driver to create a range of entries within the PPU owned work queue into which the threads can directly insert new work for execution where the work is stored in command blocks pointed to by entries of the PPU owned work queue. The threads also point entries in the PPU owned work queue to semaphores to prevent GP GET from advancing through the PPU owned work queue and executing work included therein prior to the threads completing their generation of work.

One advantage of the disclosed embodiments is that the threads executing on the PPU can create nested work within the PPU without needing to issue requests to the CPU to do so. As a result less bandwidth is consumed across the communication path and further the workload of the CPU is reduced thereby increasing efficiency. Moreover the threads are capable of executing useful nested work without relying on the CPU for authorization or having to wait for the CPU to respond to a request to execute the nested work.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

