---

title: Methods and apparatuses for improving database search performance
abstract: Methods and apparatuses for improving performance of database searches are disclosed herein. For example, in some implementations, the methods and apparatuses use a data node structure that prevents the need to duplicate data nodes shared by a plurality of data trees. Additionally, the methods and apparatus facilitate improved database lookup times by implementing an adaptive presence detection system based on the Bloom Filter, performance characteristics of the computing device evaluated at run time and status of the database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09143449&OS=09143449&RS=09143449
owner: Cisco Technology, Inc.
number: 09143449
owner_city: San Jose
owner_country: US
publication_date: 20120731
---
Databases are ubiquitous in packet forwarding devices e.g. routers . Databases are typically implemented in the form of well balanced trees such as WAVL trees for example. These well balanced trees provide acceptable performance. For example the lookup insertion and deletion times of a WAVL tree can be defined as O log n where n is the number of data nodes in the WAVL tree. However packet forwarding devices tend to handle increasing amounts of traffic. As databases in packet forwarding devices increase in size the number of data nodes make any existing scheme suffer and eventually affect the performance of the packet forwarding device.

As an example when a First Sign of Life FSOL is detected for a new session on a broadband network gateway BNG router the new session is searched on a Session Attribute Database SADB for example to avoid creating duplicates or to manage dual stack IPv4 IPv6 sessions. After performing the search on the SADB other activities required to properly start up the new session are executed. is a graph illustrating measured session start time cost on an example BNG router. In the measured start time and the average start time are shown. The graph illustrates the session start execution time in nanoseconds versus the number of started sessions 0

Bloom Filters BFs have been used in database applications in related art. The structure of a BF is basically that of an array of m bits each of which is initially set to zero. An element x of the set is represented in the BF by applying K distinct hash functions h . . . hk to x and setting to 1 the bits at positions h1 x . . . hk x in the array. Because of its randomized and hashing based mechanism the price to pay for BF s small memory footprint is the presence of a certain and known amount of false positives. For example when responding to membership queries on a BF e.g. Is element x in set S it is possible to receive a false positive even if the BF returns a positive response. However it is not possible to receive a false negative. In other words if a membership query on a BF returns a negative response the queried element does not belong to the set represented by the BF. In most applications the advantages of using a BF outweigh the risks of receiving false positives. Additionally false positives are controllable and occur at a known rate. Specifically when

Referring now to processes of constructing a BF and performing a lookup using the BF are shown. As shown in the process of constructing a BF representing the set of elements x y is shown. Initially the BF is empty and all of the bits are set to 0. Then the hash functions e.g. h1 h2 h3 are computed on element x and the bits pointed by the arrows are set to 1 based on the result of the hash functions. The hash functions e.g. h1 h2 h3 are then computed on element y and the bits pointed by the arrows are set to 1 based on the results of the hash functions. The resulting BF representing the set of elements x y is shown.

In the process of performing a lookup using the BF is shown. For example when searching a BF representing the set of elements x y for element x the hash functions are computed on element x. A determination is made that all bits pointed by the results of the hash functions bits and for example are set to 1. This indicates that element x is a member of the set of elements x y. On the other hand when searching a BF representing the set of elements x y for element t the hash functions are computed on element t. The hash functions return bits and for example. Because bits and are set to 0 t is not a member of the set of elements x y. Additionally when searching a BF representing the set of elements x y for element z the hash functions return bits and for example. Because bins and are set to 1 but z is not a member of the set of elements x y a false positive is returned.

BFs however fail to support deletion of items from a data set. Thus Counting Bloom Filters CBFs have been developed to provide a way to implement a delete operation on a BF without recreating the BF. In a CBF the array positions or bins buckets slots etc. are extended from being a single bit to an n bit counter. In fact regular BFs can be considered as CBFs with a bucket size of one bit. The insert operation is extended to increment the value of the buckets and the lookup operation checks that each of the required buckets is non zero. The delete operation includes decrementing the value of each of the respective buckets. The size of counters is typically set to 3 or 4 bits. Hence CBFs typically use 3 to 4 times more space than regular BFs.

CBFs have been used within a database system called a Shared Fast Hash Table SFHT which is discussed in detail in Song et al. SIGCOMM 05 Aug. 21 26 2005 . In a SFHT the CBF is extended in order to also maintain a pointer to a list of elements contained in each CBF bin. Referring now to an example Shared Fast Hash Table representing elements x y z w is shown. The SFHT is a CBF having an array of bins and corresponding pointers . The pointers are capable of pointing to a list of elements contained in each of the bins and each of the bins is a counter. In element x element y element z and element w are inserted into the CBF as discussed above e.g. compute the hash functions for the element increment the counter etc. . Additionally a pointer is maintained to a list of elements contained by each of the bins . As shown in the elements are not completely shared because element w is duplicated. When a search is executed the hash functions are computed on the membership query and assuming all of the bins are non zero the search is performed on the list associated with the bin having the lowest counter value.

However as the number of hash functions and the number of elements in the set of elements increase the number of collisions increases which causes performance of a search using the CBF to degrade with respect to a search of the standard database tree i.e. a WAVL tree .

Methods and apparatuses for improving database search performance are disclosed herein. For example in some implementations the methods and apparatuses use a data node structure that prevents the need to duplicate data nodes shared by a plurality of data trees. Additionally the methods and apparatus facilitate improved database lookup times by implementing an adaptive presence detection system based on the Bloom Filter performance characteristics of the computing device and status of the database.

An example method for performing a lookup can include providing a plurality of data nodes where each data node includes a data section and an array section. The array section can include a plurality of pointers capable of linking each data node to at least one of the data nodes. Additionally the method can include providing a plurality of data trees each having at least one of the data nodes and providing an array having a plurality of bins where each bin includes a counter indicating a number of data nodes associated the bin and a pointer capable of linking the bin to at least one of the data trees. The method can also include receiving a lookup request performing a plurality of hash functions on the lookup request to obtain a plurality of outputs that are associated with bins of the array identifying the bin associated with each of the outputs determining whether a counter of the bin associated with each of the outputs is nonzero identifying the bin having the counter with a lowest value upon determining that the counter of the bin associated with each of the outputs is nonzero identifying a data tree linked to the bin having the counter with the lowest value and retrieving an entry corresponding to the lookup request from the identified data tree.

In some implementations the method can include performing K hash functions on the lookup request. Additionally the array section of each of the data nodes can include K 1 sets of pointers when K hash functions are computed. For example each set of pointers in the K 1 sets of pointers can include at least two pointers.

Alternatively or additionally pointers of at least one set of pointers in the K 1 sets of pointers of one of the data nodes can be set to a memory address of at least one of the data nodes.

In some implementations the K 1 sets of pointers include a set of pointers associated each of the K hash functions. Additionally the K 1 sets of pointers can further include a set of pointers associated with a main data tree that comprises each of the data nodes.

In other implementations the method can include performing the K hash functions on a new entry to obtain K outputs that are associated with bins of the array. If a bin associated with one of the K outputs is zero the method can include incrementing a counter of the bin and setting a pointer of the bin to a memory address of the new entry. On the other hand if a bin associated with one of the K outputs is nonzero the method can include incrementing a counter of the bin and setting a pointer of at least one of the K 1 sets of pointers of one of the data nodes of a data tree linked to the bin to a memory address of the new entry.

In some implementations the array is a Counting Bloom Filter. Alternatively or additionally the plurality of data trees are WAVL trees.

Another example method for performing a lookup can include providing a plurality of data nodes where each data node includes a data section and an array section. The array section can include a plurality of pointers capable of linking each data node to at least one of the data nodes. Additionally the method can include providing a plurality of data trees each having at least one of the data nodes and at least one of the data trees having each of the data nodes and providing an array having a plurality of bins where each bin includes a counter indicating a number of data nodes associated the bin and a pointer capable of linking the bin to at least one of the data trees. The method can also include receiving a lookup request and upon receiving the lookup request determining a performance characteristic of the computing device. If the performance characteristic is less than a predetermined threshold the method can include retrieving the lookup requests by performing a plurality of hash functions on the lookup request to obtain a plurality of outputs that are associated with bins of the array identifying the bin associated with each of the outputs determining whether a counter of the bin associated with each of the outputs is nonzero identifying the bin having the counter with a lowest value upon determining that the counter of the bin associated with each of the outputs is nonzero identifying a data tree linked to the bin having the counter with the lowest value and retrieving an entry corresponding to the lookup request from the identified data tree. On the other hand if the performance characteristic is greater than the predetermined threshold the method can include retrieving the lookup request by retrieving an entry corresponding to the lookup request from the at least one of the data trees including each of the data nodes.

In some implementations the performance characteristic can include a ratio of a time constant related to performing the K hash functions to a time constant related to retrieving the lookup request from the at least one of the data trees including each of the data nodes.

In some implementations the array is a Counting Bloom Filter. Alternatively or additionally the plurality of data trees are WAVL trees.

It should be understood that the above described subject matter may also be implemented as a computer controlled apparatus a computer process a computing system or an article of manufacture such as a computer readable storage medium.

Other systems methods features and or advantages will be or may become apparent to one with skill in the art upon examination of the following drawings and detailed description. It is intended that all such additional systems methods features and or advantages be included within this description and be protected by the accompanying claims.

Unless defined otherwise all technical and scientific terms used herein have the same meaning as commonly understood by one of ordinary skill in the art. Methods and materials similar or equivalent to those described herein can be used in the practice or testing of the present disclosure. As used in the specification and in the appended claims the singular forms a an the include plural referents unless the context clearly dictates otherwise. The term comprising and variations thereof as used herein is used synonymously with the term including and variations thereof and are open non limiting terms. While implementations will be described for improving performance of database searches in packet forwarding devices it will become evident to those skilled in the art that the implementations are not limited thereto but are applicable for improving database search performance in other environments.

As discussed above CBFs have previously been used in database applications. For example SFHTs have been used to improve performance over standard database searches e.g. standard WAVL tree searches by reducing the number of memory accesses needed for the most time consuming lookups. Referring to graphs illustrating example relationships between standard WAVL tree searches and SFHT searches are shown. In example best case time ratios between standard WAVL tree searches and SFHT searches are shown. It should be understood that the search time on a standard WAVL tree can be defined as O log n and the search time on an SFHT is linear with the number of hash functions. Specifically the search times on a standard WAVL tree and an SFHT are shown in Eqns. 1 and 2 below. log 1 2 As discussed herein N is the maximum number of possible data nodes to be stored and searched in the database n is the current number of data nodes in the database at run time of the search e.g. n 0 1 2 . . . N Tw n is the search time on a standard WAVL tree filled with n elements Tb n is the search time on the SFHT e.g. a modified CBF and K is the number of hash functions used for the CBF.

In the best case scenario a queried item is available in a 1 length list when searching the SFHT. Assuming that n data nodes are present in the database if the queried item is present in the database the search time is Tb seconds. Thus in the best case the ratio of the search time using the SFHT to the search time on the standard WAVL tree is defined by Eqn. 3 below.

In the worst case scenario a queried item is available in an n length list when search the SFHT. This is due to the collisions occurring with a probability of f 2 that fit within the same bins of the CBF. The time to search an n length list is defined by Eqn. 4 below. 4 Accordingly in the worst case the ratio of the search time using the SFHT to the search time on the standard WAVL tree is defined by Eqn. 5 below.

Thus the search using the SFHT has several issues. First even if trying to have shared data nodes among the CBF bins the sharing is not fully achievable which produces an overhead in terms of extra memory. For example as shown in element w is duplicated. Next the best case SFHT does not always perform better than the standard WAVL tree search as shown by curves and of . Additionally the worst case SFHT search often provides poor performance as compared to the standard WAVL tree search as shown in .

The issue of data node sharing and worst case performance is partly due the fact that pointed lists are used by the SFHT. Improvements can be realized by using threaded data trees such as threaded WAVL trees. Referring now to a data structure e.g. a data node for use with threaded data trees is shown. The data node includes a data section and an array section . The data section includes a node key that is used when searching the database and node data which is the data related to the node key . The array section includes a plurality of pointers . In some implementations the array section includes a plurality of sets of pointers . For example as shown in each set of pointers includes at least two pointers . It should be understood that each set of pointers can contain more than two pointers . Each set of pointers can include a left pointer and a right pointer for example and each set of pointers can identify a data tree such as a WAVL tree. Each set of pointers can optionally identify a different data tree. Additionally the array section can include K 1 sets of pointers where K is the number of hash functions. When the array section includes K 1 sets of pointers the data node can be shared among K 1 data trees. For example the data node can be shared by a main data tree that includes each of the plurality of data nodes of the database and a plurality of sub data trees that include at least one data node. The main data tree including each of the data nodes can include all of the data nodes. Each of the sub data trees can be one of the K threads used to add entries to the K data trees associated with each CBF bin. As discussed above each of the data trees can be a WAVL tree for example.

Referring now to example operations for inserting a new entry are shown. In the CBF includes an array of bins and corresponding pointers . The pointers are capable of pointing to a list of elements contained in each of the bins and each of the bins is a counter. Additionally in three hash functions e.g. h1 h2 and h3 are computed for each new entry i.e. K 3 . It should be understood that more or less than three hash functions can be computed for each entry. When the first new entry x is inserted three hash functions are computed. For example the outputs of the hash function computations for element x are h1 x 2 h2 x 5 and h3 x 7. After computing each of the hash functions the corresponding counters are incremented by 1 and the corresponding pointers i.e. P P and P are set to a memory address related to the entry x. Additionally a main tree pointer is set to the memory address related to entry x. The reason for setting the main tree pointer to the memory address related to entry x is discussed in detail below.

Next the second new element y is inserted. For example the three hash functions e.g. h1 h2 and h3 are computed for each new entry i.e. K 3 . The outputs of the hash function computations for element y are h1 y 3 h2 y 5 and h3 y 8. Because the outputs for h1 and h3 do not conflict in the CBF i.e. the corresponding counter values for the bins are 0 the corresponding counters are incremented by 1 and the corresponding pointers i.e. P and P are set to a memory address related to the entry y. The output for h2 instead is related to a non zero counter in bin . Thus the corresponding counter is incremented by 1 and a pointer of at least one of the K 1 sets of pointers of one of the data nodes of a data tree linked to the bin to is set to the memory address of entry y. Referring now to an example data structure e.g. a data node A is shown. The data node A represents the new entry such as entries x y z a etc. shown in . includes many of the same reference numerals as and the similar reference numerals are therefore not discussed in more detail below. However as shown in each set of pointers can correspond to a different data tree. For example pointers A can correspond to the main data tree that includes each of the data nodes in the database. As such pointers A are capable of linking the data nodes of the main data tree. The pointers A can be referred to as thread . Pointers B C and D can each correspond to the sub data trees or threads. As such pointers B C and D are capable of linking the data nodes of the sub data trees. The pointers B C and D can be referred to as threads and respectively. As shown in the memory address related to entry y is inserted on the data tree pointed by P on thread i.e. one of the pointers C . Additionally the memory address related to entry y is also inserted on the data tree pointed by P on thread i.e. one of the pointers A . Accordingly new entry y is shared by the main data tree and a sub data tree.

As shown in the same process is repeated for new entries z and a. As a result the entries x y z and a are shared by K 1 data trees. Specifically each of the m bins includes a pointer to a data tree whose search insert thread is determined by the value of the hash functions applied to the new entry. Referring now to example data trees available on the database are shown. It should be understood that is only one example. In some implementations the data trees can contain more or fewer data nodes than shown in . For example in some implementations in the average case each of the data trees will include only a single data node.

Referring now to example operations for searching for an entry are shown. shows the CBF including the bins and corresponding pointers after entries x y z and a are inserted as discussed above with regard to . For example assuming that entry z is searched the three hash functions i.e. h1 h2 and h3 are computed for entry z. The output of the hash functions can be CBF h1 1 CBF h2 4 and CBF h3 2. As shown in there is one bin in the CBF i.e. CBF h1 associated with a data tree including one data node i.e. entry z . The other bins of the CBF i.e. CBF h2 and CBF h3 are associated with data trees including more than one data node. Therefore the data related to entry z is searched and retrieved from the data tree associated with the bin of the CBF having the lowest counter value i.e. counter 1 .

Referring now to graphs illustrating example relationships between standard WAVL tree searches and searches of the data trees discussed in are shown. As discussed herein databases including nodes and the data trees discussed in are referred to as the new system. Assuming the worst case scenario where collisions occur on the same bins of the CBF the ratio of the search time on the new system to the search time on the standard WAVL tree is defined by Eqn. 6 below.

In the best case the ratio of the search time on the new system to the search time on the standard WAVL tree is defined by Eqn. 7 below.

At run time a determination can be made as to whether to perform the standard WAVL tree search or the new system search. This determination can be made based on one or more performance characteristics of a computing device that performs the search. The performance characteristic can be calculated at boot time of the computing device and or at run time of the search. In some implementations the computing device is a packet forwarding device such as a router for example. It should be understood that the computing device is not limited to the packet forwarding device and can be any other type of computing device. For example if the performance characteristic is less than a predetermined threshold then the new system search can be executed. In this case the new system search is predicted to perform better than the standard WAVL search. If however the performance characteristic is greater than the predetermined threshold then the standard WAVL tree search can be executed. In this case the new system search is predicted to perform worse than the standard WAVL tree search.

Because p h K and N are known at boot time and n is known at run time the determination as to whether to perform the new system search or the standard WAVL tree search is adaptive. The adaptive algorithm can be defined as shown in Eqn. 10 below.

Referring now to a system for implementing the adaptive algorithm is shown. The system includes database clients a CBF and a database . The database includes a plurality of data nodes. The data nodes can be the data node discussed with regard to . Additionally the database can include a plurality of data trees A B C D . . . N. For example the data tree A can be a main data tree including each of the data nodes. The data nodes B C D . . . N can be data trees including at least one data node. For example the data nodes B C D . . . N can be the data trees associated with the threads that share data nodes as discussed above. The system can also include a search manager configured to coordinate search requests. Additionally the system can include an update manager A a CBF update manager B and a database update manager C configured to coordinate updates e.g. insert delete entries from the database the data trees and or the CBF .

The system also includes a selector and an adaptive algorithm that provide the selection criteria in order to select between the standard WAVL tree search in the database or the CBF processing. For example when the search manager receives a search request for an item the request is forwarded to the selector . Depending on the status of the adaptive algorithm the search is executed on the main data tree A or one of the sub data trees B C D . . . N managed by the CBF . After the item is retrieved from either the main data tree A or one of the sub data trees B C D . . . N the item is returned to the search manager . Additionally if an update request is received from the database clients the update manager A coordinates with the CBF update manager B and the database update manager C to update the database data trees and or CBF.

Referring now to a flow diagram illustrating example operations for performing the adaptive algorithm are shown. At the computing device is booted. After booting the computing device in order to calculate time constants p and h the database is filled with M dummy data nodes at . At the CBF is updated with the M data nodes. Thereafter at and time constants p and h are calculated. At the performance characteristic which is defined as

At run time i.e. the time a lookup request is received the database status is determined. For example at a number of data nodes i.e. n in the database is determined. Thereafter at the value of

It should be appreciated that the logical operations described herein with respect to the various figures may be implemented 1 as a sequence of computer implemented acts or program modules i.e. software running on a computing device 2 as interconnected machine logic circuits or circuit modules i.e. hardware within the computing device and or 3 a combination of software and hardware of the computing device. Thus the logical operations discussed herein are not limited to any specific combination of hardware and software. The implementation is a matter of choice dependent on the performance and other requirements of the computing device. Accordingly the logical operations described herein are referred to variously as operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. It should also be appreciated that more or fewer operations may be performed than shown in the figures and described herein. These operations may also be performed in a different order than those described herein.

Referring now to a flow diagram illustrating example operations for performing a lookup are shown. At a plurality of data nodes are provided. The data nodes can optionally be the data node discussed with regard to . At a plurality of data trees can be provided. Each data tree includes at least one of the data nodes. At an array having a plurality of bins is provided. Each of the bins includes a counter indicating a number of data nodes associated the bin and a pointer capable of linking the bin to at least one of the data trees. For example in some implementations the array can be a CBF. At a lookup request is received. Then at a plurality of hash functions are computed on the lookup request to obtain outputs of the hash functions. Each of the outputs can be associated with one of the bins of the array. At the bins associated with each of the outputs of the hash functions are identified. At the bin having a counter with a lowest value among the bins associated with each of the outputs is identified. Then a data tree linked to the bin having a counter with a lowest value is identified at . An entry is retrieved from the identified data tree at .

Referring now to a flow diagram illustrating example operations for performing a lookup are shown. includes a number of the same operations that are discussed above with regard to . The similar operations are identified by the same reference numerals and these operations are not discussed in further detail below. As shown in a lookup request is received at . Upon receiving the lookup request a determination is made as to whether a performance characteristic is greater than a predetermined threshold at . If NO the operations proceed to steps and an entry is retrieved from one of the sub data trees as discussed above. If YES the operations proceed to step and an entry is retrieved from a main data tree. When the performance characteristic exceeds the predetermined threshold performance of the search of the sub data trees e.g. using the CBF is predicted to be worse than the standard WAVL search. Accordingly using an adaptive algorithm it is possible to improve database lookup times by implementing an adaptive presence detection system based on the Bloom Filter performance characteristics of the computing device evaluated at run time and status of the database.

When the logical operations described herein are implemented in software the process may execute on any type of computing architecture or platform. For example referring to an example computing device upon which embodiments of the invention may be implemented is illustrated. In particular the packet forwarding device discussed above may be a computing device such as computing device shown in . The computing device may include a bus or other communication mechanism for communicating information among various components of the computing device . In its most basic configuration computing device typically includes at least one processing unit and system memory . Depending on the exact configuration and type of computing device system memory may be volatile such as random access memory RAM non volatile such as read only memory ROM flash memory etc. or some combination of the two. This most basic configuration is illustrated in by dashed line . The processing unit may be a standard programmable processor that performs arithmetic and logic operations necessary for operation of the computing device .

Computing device may have additional features functionality. For example computing device may include additional storage such as removable storage and non removable storage including but not limited to magnetic or optical disks or tapes. Computing device may also contain network connection s that allow the device to communicate with other devices. Computing device may also have input device s such as a keyboard mouse touch screen etc. Output device s such as a display speakers printer etc. may also be included. The additional devices may be connected to the bus in order to facilitate communication of data among the components of the computing device . All these devices are well known in the art and need not be discussed at length here.

The processing unit may be configured to execute program code encoded in tangible computer readable media. Computer readable media refers to any media that is capable of providing data that causes the computing device i.e. a machine to operate in a particular fashion. Various computer readable media may be utilized to provide instructions to the processing unit for execution. Common forms of computer readable media include for example magnetic media optical media physical media memory chips or cartridges a carrier wave or any other medium from which a computer can read. Example computer readable media may include but is not limited to volatile media non volatile media and transmission media. Volatile and non volatile media may be implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data and common forms are discussed in detail below. Transmission media may include coaxial cables copper wires and or fiber optic cables as well as acoustic or light waves such as those generated during radio wave and infra red data communication. Example tangible computer readable recording media include but are not limited to an integrated circuit e.g. field programmable gate array or application specific IC a hard disk an optical disk a magneto optical disk a floppy disk a magnetic tape a holographic storage medium a solid state device RAM ROM electrically erasable program read only memory EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices.

In an example implementation the processing unit may execute program code stored in the system memory . For example the bus may carry data to the system memory from which the processing unit receives and executes instructions. The data received by the system memory may optionally be stored on the removable storage or the non removable storage before or after execution by the processing unit .

Computing device typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by device and includes both volatile and non volatile media removable and non removable media. Computer storage media include volatile and non volatile and removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media include but are not limited to RAM ROM electrically erasable program read only memory EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media may be part of computing device .

It should be understood that the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination thereof. Thus the methods and apparatuses of the presently disclosed subject matter or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computing device the machine becomes an apparatus for practicing the presently disclosed subject matter. In the case of program code execution on programmable computers the computing device generally includes a processor a storage medium readable by the processor including volatile and non volatile memory and or storage elements at least one input device and at least one output device. One or more programs may implement or utilize the processes described in connection with the presently disclosed subject matter e.g. through the use of an application programming interface API reusable controls or the like. Such programs may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the program s can be implemented in assembly or machine language if desired. In any case the language may be a compiled or interpreted language and it may be combined with hardware implementations.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

