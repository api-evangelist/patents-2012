---

title: Target typing of overloaded method and constructor arguments
abstract: Methods and apparatus for target typing of overloaded method and constructor arguments are described. A method comprises determining whether source code of a program includes, as an argument to an overloaded operation invocation, an expression whose type is context-dependent. The method further comprises, if the source code includes such an argument, providing the expression as an input to an overload resolver, and determining at the overload resolver whether (a) each argument of the invocation is compatible with types of corresponding parameters in one or more declarations and (b) whether a particular declaration among such a set of declarations can be identified as the most specific. If both conditions are met, the method comprises generating executable instructions for the invocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09524175&OS=09524175&RS=09524175
owner: Oracle International Corporation
number: 09524175
owner_city: Redwood City
owner_country: US
publication_date: 20121114
---
In recent years object oriented programming languages such as Java have become increasingly popular for a wide variety of applications running on many different types of platforms. Many such programming languages support overloading of invocable operations such as methods and constructors allowing programmers to create several methods with the same name within a given class or several constructors for a given class. Within a given set of overloaded invocable operations the individual operations may differ from one another in various ways e.g. in the number of parameters the types of the parameters or the return types in the case of methods. Support for overloading relieves programmers of the burden of having to make up different names for methods or constructors that provide similar functionality and therefore should ideally not be forced to have different names. Compilers or other tools that perform type checking such as certain kinds of interpreters for programming languages that support overloading have to perform overload resolution i.e. they have to determine for a given invocation which among a set of overloaded methods or constructors is the appropriate or intended one for which executable code should be generated.

Historically it is common for many such programming languages to require that the arguments to an invocation e.g. an invocation of an overloaded method be completely typed i.e. that the types of all the arguments be determined before the invocation can itself be typed by the compiler. However the type of many constructs that are of increasing interest to programmers and are therefore being considered for inclusion in various programming languages such as lambda expressions may be context dependent that is the type of the construct may differ depending on the surrounding context in which the construct is used. For example the same lambda expression done has different types in the following two contexts 

This may present difficulties when a programming language is to support the use of such constructs as arguments to methods or constructors. Traditionally the overload resolution component of a compiler relied upon being provided the types of the arguments to an invocation but such argument type information may not be available when expressions whose type is context dependent are used as arguments.

Various embodiments of apparatus and methods for target typing of overloaded method and constructor arguments are described. The term target typing may be used herein to refer to the process of inferring the type of an expression whose type may vary depending on the surrounding context the type expected in a particular context may be referred to as the target type . More broadly in at least some embodiments the target type may be considered as the source of type information that allows the type of such an expression to be inferred. For example using the latter broader definition if E is the expression being considered and T is a target type the equation typeof E f T may be generally applicable where f is some function of the target type f may be the identity function in some but not all cases . According to one embodiment a system may include one or more computing devices configured to determine for an overloaded operation invocation such as an invocation of an overloaded method or an invocation of an overloaded constructor identified in source code for a computer program whether the source code includes as an argument to the invocation an expression whose type is context dependent. If the invocation does have such an argument the expression itself rather than the type of the expression may be provided as input to an overload resolver implemented at the computing device s in such an embodiment. The overload resolver may then determine whether at least the following two conditions hold a whether each of the arguments of the invocation including the expression is compatible with a type of a corresponding parameter indicated in one or more invocable operation declarations e.g. among the set of overloaded method declarations corresponding to the invocation identified from the source code and b whether a particular invocable operation declaration of the one or more invocable operation declarations is identifiable as the most specific invocable operation declaration for the invocation based at least in part on one or more specificity criteria defined for the language. Thus in checking the first condition the overload resolver may attempt to find a set of candidate method or constructor declarations whose parameter types are compatible with the expression and in checking the second condition the overload resolver attempts to select one of the candidate declarations if any were found as the most specific declaration and therefore the declaration inferred to be the intended declaration to be used to resolve the overloading in such an embodiment.

If both conditions hold overload resolution may be deemed to have succeeded in such an embodiment and the computing devices may generate executable instructions for the overloaded operation invocation in accordance with the particular declaration identified as the most specific declaration. If either condition does not hold the overloading cannot be resolved and an error indication may be generated in at least some embodiments. If multiple compatible candidate declarations are found i.e. the first condition holds in one embodiment but the overload resolver cannot narrow down the multiple candidates to one most suitable candidate where the relative suitability of the candidates may have to be determined based on language dependent specificity criteria the overload resolution fails and an error indication such as an Ambiguous argument error message may be generated. Several different kinds of arguments whose type is context dependent may be supported in various embodiments e.g. lambda expressions may be used as arguments or method references may be used.

In various embodiments the computing devices may implement a tool such as a compiler or an interpreter which may be responsible for generating executable instructions corresponding to the source code program. In order to check the first condition e.g. to find candidate compatible method or constructor declarations in some embodiments the tool may perform speculative typing analysis. Such speculative typing may involve using one or more potentially complex tests for assignability of an expression rather than relatively simple tests for assignability of just a type. As part of the analysis the tool may type an expression as if it appeared in a particular context and then decide if an error would have occurred. Portions or branches of a parse tree for the source code may be generated speculatively for various candidate target declarations discarded if found inapplicable and retained if found applicable. Using this approach the tool may check for each of a set of overloaded method or constructor declarations whether an assignment of the expression to a corresponding parameter of the declaration would fail or succeed. If the assignment would fail the declaration may be discarded as incompatible. If all the arguments to the invocation can be assigned to corresponding parameters of the declaration without encountering errors the declaration may be deemed compatible in such an embodiment.

In some embodiments if a plurality of compatible declarations are found by the tool further analysis may be conducted in accordance with rules or criteria specified for the language in use e.g. criteria defined in the programming language specification or in other standards related documents associated with the language. In one such embodiment the plurality of candidates may be examined in pairs with the intent of determining which of a given pair is more specific according to the criteria and discarding the other declaration of the pair. In cases where the parameters of the declarations can be represented using function descriptors for example the tests may first compare the parameter types of the pair of declarations and if the comparison of the parameter types is insufficient to indicate that one declaration of the pair is more specific than the other the return types of the function descriptors may be compared. If the tests succeed in identifying a single declaration as the most specific that declaration may be used for generation of executable code.

It is noted that while much of the following description refers to the use of a compiler for various operations similar operations may be performed in some embodiments by a different tool such as an interpreter that is also responsible for type checking and overload resolution. For example an interpreter may consume source code as input just as a compiler does and generate executable instructions using similar logic as described below with respect to a compiler. In cases where an interpreter is being used the generated instructions may be executed forthwith and may not be stored in a persistent form e.g. as an executable version of the source program as they typically would be if a compiler were used. The kinds of errors thrown when overload resolution fails and the error messages provided may differ in some cases between the compiler and the interpreter. It is also noted that while for purposes of illustration the following description is provided largely in the context of using the Java programming language or a language closely related to Java the techniques described may be used for any programming language that supports overloading of invocation operations such as methods constructors or functions. The techniques may be used for object oriented languages in some embodiments or for non object oriented languages such as various procedural languages in other embodiments. The term invocable operation may be used herein to refer to methods constructors or to methods and constructors collectively. Method invocations constructor invocations or method invocations and constructor invocations collectively may be termed operation invocations or simply invocations herein.

The compiler may analyze the source code to produce an executable version of the program such as bytecode files e.g. .class files or .jar files in the case of Java in the depicted embodiment. Different types of executable code formats may be used in various embodiments for example binary machine language may be used instead of bytecodes. In some scenarios parts of the executable code may be in bytecode while others are in a native binary machine language. As part of compiling program source code into executable code the compiler may perform a sequence of analysis operations and generate various intermediate data structures before generating the executable version as described below in further detail with reference to . The compiler may for example identify various method and constructor invocations analyze the invocations based on the corresponding declarations and decide based on the information that can be determined at compile time whether a compile time error should be generated. If a given invocation is determined to be acceptable for compilation appropriate code may be generated for it.

As illustrated in executable code may be passed to an execution environment such as run time environment which executes the code on an execution platform thereby creating various output data and or behavior. In various embodiments the run time environment may include a virtual machine e.g. a Java Virtual Machine or JVM . The virtual machine may in turn comprise a number of different components such as a memory manager which may include a garbage collector a bytecode verifier to check the validity of the executable code an interpreter and or a just in time JIT compiler such as the HotSpot compiler. The JIT compiler may in some embodiments be responsible for translating some or all of the bytecode for example heavily used portions of bytecode into platform specific machine code to improve performance of the program execution. A run time environment such as the Java Runtime Environment or JRE may also include code to implement a number of application programming interface API libraries in some embodiments. The run time environment may run on top of lower level software such as an operating system in some embodiments. In embodiments where virtualized compute resources are being used as the execution platform virtualization software such as a hypervisor may be used to configure the execution platform for the operating system i.e. the operating system may run as an application on top of the hypervisor .

In different embodiments the output or behavior produced as a result of the execution of the compiled code may include data stored in various levels of system memory e.g. in memory objects and or data structures on persistent storage e.g. files on a file system etc. The behavior may also include various program functionalities such as displaying output on a screen sending messages over a network and or otherwise interacting with various users and or components.

In at least some embodiments a compiler or a similar tool may support target typing of overloaded method and constructor arguments. The term target typing may be used herein to refer to the process of inferring a type of an expression whose type may vary depending on the surrounding context e.g. on the tokens that surround the expression in the source code the type expected in a particular context may be referred to as the target type . Expressions whose type is context dependent may be referred to herein as poly expressions . For an example of a poly expression consider the constructor expression new ArrayList in Source Code Example 1 below 

In the first context line 1.1 the expression returns a List of Strings in the second context it returns a List of Integers. Thus the type of the expression cannot be determined by examining the expression alone instead the context in which the expression appears has to be taken into account.

Some programming languages may support lambda expressions . Lambda expressions are a lightweight way to describe functions that can be treated as values by a programming language. In the case of some object oriented programming languages lambda expressions may be used as a lightweight mechanism for defining objects that have just one method and no state. In at least some embodiments lambda expressions may be expressed using syntax such as the following 

Lambda expressions may be considered examples of poly expressions in at least some languages in other languages lambda expressions may simply be normal expressions with a functional or arrow type S T. Source Code Example 2 illustrates three lambda expressions according to one embodiment.

In line 2.1 the arguments of the lambda expression comprise two integer values and the body computes the sum of the two values as the return value. In line 2.2 the lambda expression takes no arguments and returns the integer 42. In line 2.3 the lambda expression takes a single String argument prints it out to the system output and returns nothing. Note that lambda expression are anonymous in the depicted embodiment in that they are not named. Next consider an example of a lambda expression whose type is context dependent according to one embodiment 

The same lambda expression done can thus have different types depending on the surrounding context. There are at least two ways in which lambda expressions may be context dependent in at least some programming languages used in various embodiments. First lambda expressions may produce objects that implement a particular interface and the interface and thus the expression may be context dependent. Second in some cases lambda expressions may have parameters that do not have declared types e.g. x y x y . In this latter scenario the types of the body expressions may also be context dependent. Lambda expressions are often expected to be used in nested contexts such as arguments to method invocations or as results of other lambda expressions. The task of target typing for lambda expressions in nested contexts may be somewhat harder than in un nested contexts such as straightforward assignments.

Lambda expressions enable definition of anonymous methods and enable treating such anonymous methods as instances of functional interfaces. A similar approach may be used with existing methods as well using a construct called method references . According to one embodiment a method reference may be treated in the same way as a lambda expression but instead of providing a method body a reference to an existing method of a class or object may be indicated e.g. using the following syntax . Source Code Example 4 illustrates one example of a method reference 

The Arrays.sort call in line 4.8 includes as an argument the method reference Person compareByAge . The method reference in this example may be considered shorthand for a lambda expression whose parameter list is copied from Comparator.compare and whose body calls Person.compareByAge. As with lambda expressions therefore a compiler may have to perform target typing for method references passed as arguments in at least some embodiments. Given the similarities in the treatment of lambda expressions and method references the techniques described for various embodiments below with respect to lambda expressions may also be applied to method references in various embodiments.

According to the illustrated embodiment compiler may include lexical analyzer which may be configured to break the input source code into tokens such as tokens . Each token may correspond to a single atomic unit of the given language such as keywords identifiers etc. In various embodiments the token syntax may be represented as a regular language. Compiler may include preprocessor in the depicted embodiment which may be used to support macro substitution in some languages. In some embodiments preprocessor may modify various ones of tokens which may result in a set of modified tokens such as .

Compiler may also include a syntactic analyzer in some embodiments which may be configured to parse the modified tokens to identify syntactic structure of the input program. The syntactic analyzer may be configured to build a parse tree such as parse tree which may organize the tokens into a tree structure according to the formal grammar of the programming language of the source code.

In the depicted embodiment the compiler may further include a semantic analyzer which may be configured to add semantic information to parse tree to create an annotated internal representation of the program such as intermediate representation . In some embodiments a code generator such as code generator may convert the intermediate representation into an executable program such as . Executable program may be encoded in binary and or bytecode and may correspond to executable code in .

In some embodiments semantic analyzer may also build and or maintain a symbol table such as symbol table which maps various symbols in the source code to associated information such as the location scope and or type. The semantic analyzer may also include an overload resolution module such as module to determine which among an overloaded set of methods or constructors is the one for which code should be generated for a given overloaded invocation. In some embodiments the overload resolution module which may also be referred to herein as an overload resolver may be a subcomponent of a type checker module of the semantic analyzer. If an overloaded invocation cannot be resolved a compile time error may be generated such as the logical equivalent of Ambiguous invocation and at least in some embodiments the compilation may fail. In some instances warnings may be generated for certain invocations instead of or in addition to compile time errors. In various embodiments different components of compiler shown in may be combined or further deconstructed into multiple components. The compiler may also implement various additional types of functions such as optimization line reconstruction and the like not shown explicitly in in some embodiments.

The following example of overload resolution according to one embodiment in which method arguments do not include expressions with context dependent types is provided as a preliminary to the subsequent discussion of the target typing for argument expressions with context dependent types that may be performed by a compiler or another similar tool in various embodiments. Consider the following overloaded declarations for a method in one embodiment followed by an invocation 

In this example the type of the invocation argument the integer or int is not context dependent. The overload resolver is provided the type of the argument integer and tries to find method signatures among the overloaded methods for which the argument type is a subtype e.g. in accordance to the programming language s type hierarchy for predefined types and libraries of the language or in accordance with the source code for programmer generated classes . In this case declarations 5.2 5.3 and 5.4 have such signatures foo Integer foo Number and foo Object so these three are chosen as candidates from which a further selection may be performed to disambiguate the invocation in this embodiment. The first declaration which has a String argument is rejected as a candidate because the type of the argument int is incompatible with the type of the parameter String in the first declaration. From among the compatible candidate signatures the compiler may select the one that is most specific where specificity may be defined in the programming language specification or associated documentation e.g. the method whose parameter type is lower in a type hierarchy than any of the other candidate methods parameters may be deemed the most specific in some embodiments . In this case assuming that subtype hierarchy depth is used as the criterion for specificity since an Integer is a subtype of a Number and a Number is a subtype of Object the foo Integer declaration may be deemed the most specific and hence the result of the overload resolution process so executable code corresponding to the foo Integer declaration may be generated.

It is noted that while for simplicity the majority of the source code examples provided herein cover methods and constructors with a single parameter the techniques described may be extended to invocable operations with any number of parameters in various embodiments. Thus for example the approach described as being taken for target typing a single argument may be repeated N times for target typing of N arguments in some embodiments. In some implementations overload resolution for different parameters may be performed in parallel.

In contrast to the relatively straightforward example of the overloaded foo method above where the invocation argument s type was not context dependent consider the following example involving an argument to an overloaded method foo2 that is a poly expression.

Here unlike in the case where 23 was passed as an argument in Source Code Example 5 the type of the argument expression new ArrayList cannot be determined simply by examining the expression. As a result at least in some embodiments the overload resolver component of a tool such as a compiler or interpreter may be provided the argument expression itself as input instead of for example being provided the type of the argument as input . The overload resolver may examine the poly expression argument speculatively testing for compatibility with the different parameter types of the overloaded declarations as described in more detail below. Such an approach may be termed speculative typing herein.

Generally speaking type checking may be considered a routine that progressively attaches type information to the nodes of a parse tree that is internally used by a compiler or similar tool to store information about a source program. Such a tree may be initially blank i.e. no type information may be contained within it type checking may be thought of as coloring this tree with the appropriate type information. After type information is added to the tree for a given expression it can later be used to perform other useful checks without re examining the entire expression. In a simple scenario like the foo 23 example above the parse tree would be colored with the type information int for 23 . This would mean that checking as to whether a method is applicable or not may simply amount to checking whether the type information associated with the expression 23 is compatible with the type information associated with a formal parameter of the method. The type information int in this case would itself be passed to the overload resolution module of the type checker. In a more complex example such as foo2 new ArrayList speculative typing may be required in some embodiments. During speculative typing a target type T may be selected from one of the method declarations and a copy of the initially blank parse tree for the expression may be colored under the assumption that the target type is T. That is type checking may be speculatively performed for the statement T t new ArrayList This may be done in some implementations by passing the argument expression itself not the type of the argument as well as the type T as parameters for overload resolution. One significant difference between the two examples is that in the first example 23 is type checked only once regardless of the number of overloads. In the second example in at least some embodiments new ArrayList may have to be type checked once for each overloaded method hence the term speculative typing . It is noted that in some implementations optimizations to reduce the number of speculative type checks may be feasible . Several passes on the parse tree may thus be performed in such embodiments without knowing exactly which version of the tree will be retained at the end of the resolution process.

In some embodiments separate branches of a parse tree representation of the program may be generated in the manner described above for speculative typing corresponding to each overloaded declaration. In such embodiments the branches corresponding to the declarations found incompatible may be discarded while the branches corresponding to the declarations found compatible may be retained for a subsequent phase of overload resolution. The test for compatibility may be considered logically equivalent to determining whether an assignment of the expression to the parameter would result in an error e.g. in this example would the assignments ArrayList arg new ArrayList and Set arg new ArrayList succeed or result in an error. If the assignment would not result in an error the corresponding declaration may be deemed a candidate for the next phase of overload resolution in which if more than one candidate is found one particular candidate is selected as the most specific declaration or the inferred intended declaration . If the assignment would result in an error the corresponding declaration may be rejected as a candidate for further consideration. In the above example of method foo2 declaration 6.2 would be rejected as the corresponding assignment would not succeed while declaration 6.1 would be selected as a candidate. If only one candidate declaration were found that declaration would be selected as the most specific or most appropriate declaration and the process of target typing of the argument would conclude in at least some embodiments. If no candidate were found overload resolution would fail and an error indication may be generated e.g. an Incompatible argument message or similar error message may be provided at least in some embodiments.

The process of selecting candidate declarations is described in more detail below with respect to the description of . If more than one candidate declaration is found a second phase of overload resolution may be initiated in some embodiments in which an attempt to identify the single most specific or most appropriate candidate from among the set of candidates is made e.g. using one or more specificity criteria. Further details regarding this phase for specific kinds of argument expressions are provided below in conjunction with the description of . It may be the case that no single most specific candidate may be found in which case the second phase of the overload resolution may end in failure and in some embodiments an error indication may be provided e.g. a message such as Ambiguous invocation detected may be generated . Source Code Example 7 a slight variation on Source Code Example 6 illustrates one such scenario.

In this example the List declaration would be rejected using similar reasoning as in the case of Source Code Example 6. The remaining two declarations 7.1 and 7.3 would be deemed compatible with the invocation. However based on the specificity criteria being used it may be impossible to choose one of the two candidates as being more specific than the other and as a result a compile time error may occur.

Source Code Example 8 illustrates a scenario in which a lambda expression is used as a method argument according to one embodiment.

In order to perform target typing for the lambda expression done in this example in such a scenario where the overloaded declarations have function types e.g. Callable as parameters the function descriptors of the parameters in the foo4 declarations may have to be analyzed in the embodiment illustrated. A function type represents a set of invocable operation definitions with a given signature i.e. the invocable operations that have the same formal parameter types and return types. Function types may be represented in some object oriented programming languages using functional interfaces as illustrated in Source Code Example 9 below for one embodiment. A function descriptor for a function type such as Callable may comprise a representation of the combination of at least the list of parameter types and return type in at least some embodiments. In one embodiment the function descriptor may also include a representation of the thrown types. For example in the illustrated embodiment the function descriptor for Callable may be represented as String indicating that it has no arguments and returns a String. Similarly the function descriptor for PrivilegedAction may be represented as Integer indicating that PrivilegedAction has no parameters and returns an Integer. The function descriptor for ActionListener may be represented as ActionEvent void indicating that it has one parameter of type ActionEvent and does not return anything. Upon analyzing the source code of Example 8 and the corresponding function descriptors a compiler in some embodiments may determine the lambda expression done is incompatible with the ActionListener parameter of declaration 8.3 since the lambda expression has no parameters while the ActionListener has one parameter. The lambda expression may also be found incompatible with declaration 8.2 since the lambda expression returns a String rather than an Integer. However the lambda expression may be found compatible with declaration 8.1 since the number zero of parameters for Callable matches the number of parameters of the lambda expression the types of the parameters are not an issue as there are no parameters and the return type String matches as well. As a result in the illustrated embodiment declaration 8.1 may be deemed the result of the overload resolution and executable instructions may be generated accordingly. If multiple declarations were found compatible on the basis of the analysis of their function descriptors a determination for the most specific declaration among them may be conducted in the illustrated embodiment e.g. using the kind of logic illustrated below with respect to . The term descriptors may be used to refer to function descriptors herein.

The argument expression may be provided as input to the overload resolver element . The overload resolver may determine whether the following two conditions hold one corresponding to the candidate declaration determination phase described above and one corresponding to the selection of a best or most specific candidate among the candidates in the depicted embodiment element . The first condition is that each of the arguments of the invocation including the argument expression be compatible with the type of a corresponding parameter indicated in one or more invocable operation declarations e.g. using the equivalent of the speculative typing based on assignment tests described above .

If the argument list of the invocation comprises more than one expression including potentially more than one poly expression each of the expressions may have to meet the compatibility criteria in such an embodiment. For each poly expression among the parameters the speculative typing approach may be used in turn or in parallel with the analysis of other parameters in some embodiments . For expressions whose type is not content dependent subtyping analysis of the kind illustrated in Source Code Example 4 above may be used. If even one argument expression is found incompatible with the corresponding parameter i.e. the parameter in the same relative position within the list of parameters in a declaration the declaration may be deemed incompatible. For example consider a declaration foo5 Type1 p1 Type2 p2 Type3 p3 with three parameters and an invocation foo5 arg1 arg2 arg3 . For this declaration of foo5 to be found compatible in one embodiment and to be considered a candidate for the next phase of overload resolution arg1 has to be compatible with p1 arg2 has to be compatible with p2 and arg3 has to be compatible with p3.

The second condition in the embodiment depicted in is that using one or more specificity criteria defined to narrow down the set of candidates to a single candidate a particular invocable operation declaration of the compatible declarations in the earlier analysis be identifiable as the most specific operation declaration for the invocation. Of course in the trivial case that only one compatible declaration is found the second condition would hold since the only compatible declaration would by default be the most specific declaration . If both conditions hold overload resolution and target typing may be deemed to have succeeded and executable instructions corresponding to the invocation may be generated element . If either condition does not hold an error indication may be generated.

As shown in element a determination may be made e.g. using the speculative parse tree branch generation operations discussed earlier as to whether an assignment of the argument to the corresponding parameter i.e. the parameter that appears in the same position in the list of parameters as the poly expression argument appears in the list of arguments would succeed or fail. If the assignment would fail as in the case of declaration 6.2 in Source Code Example 6 above the declaration may be rejected as a candidate for further analysis in the depicted embodiment element . If the assignment would succeed as also determined in element the declaration may be added to a compatible set of declarations element as in the case of declaration 6.1 of Source Code Example 6 .

If more declarations remain to be examined as determined in element the next declaration to be considered may be identified and the operations corresponding to elements onwards may be repeated. If no more declarations remain the size of the compatible set may be examined. If the size is zero i.e. no compatible declarations were found as determined in element an error may be indicated element since no suitable declaration can be used for executable code generation. If the size is one as determined in element no ambiguity regarding overload resolution remains and the single compatible declaration may be used for code generation purposes element . If more than one compatible declaration is found further analysis to determine the most specific declaration among them may be required in the depicted embodiment element . Such further analysis may comprise in at least some embodiments a pairwise comparison of the candidates similar to that illustrated in .

Source Code Example 9 provides examples of the kinds of scenarios in which specificity analysis among a candidate set of compatible overloaded declarations may have to be performed in some embodiments.

In Source Code Example 9 lines 9.9 through 9.15 show example overloaded declarations of method m whose single parameter in each case is one of the function types represented by the functional interfaces of lines 9.1 through 9.7. The invocation of m with a lambda expression as an argument shown in line 9.17 is assumed to result in the determination e.g. using the speculative typing approach described earlier of a compatible candidate set that includes several of the declarations of lines 9.9 through 9.15. In such a scenario a compiler or similar tool may be required to determine which among the compatible declarations is the most specific. Such analysis may include comparisons of the function descriptors corresponding to the declarations taken two at a time pairwise comparisons using a set of specificity rules or criteria defined for the language being used in some embodiments. In one embodiment based on a particular set of such specificity criteria some of the results of the comparisons may include the following 

 m StringGetter is more specific than m ObjectGetter because the parameter type String is a subtype of the parameter type Object.

 m ToInteger is more specific than m ToNumber because the return type Integer is a subtype of the return type Number.

 m StringMapper and m IntMapper conflict i.e. neither is more specific than the other because their function descriptors have different parameter types. As a result an error may be indicated in some embodiments if these two declarations are being analyzed for relative specificity.

 m IntMapper is more specific than m ToInteger if the lambda body returns only primitives. Primitive types may be predefined by the language specification and may be named using reserved keywords such as int or float in contrast to primitives a data type for which when an object of that data type is instantiated a reference in effect a pointer to a heap location storing the value of the instantiated object is created may be called a reference type. Additional details regarding primitive types reference types and associated type conversion operations are provided below with reference to . It is noted that some programming languages may automatically convert expressions of a certain type to expressions of a different type but the overload resolution mechanisms used may prefer to avoid these kinds of conversions if a candidate does not require them.

 m StringGetter is more specific than m Runnable because StringGetter returns a String while Runnable returns void.

Using the results of such pairwise comparisons a single declaration that is more specific than all the other candidates may eventually be found in some embodiments. If such a single most specific declaration is found that declaration may be used for code generation otherwise an error may be indicated.

As shown in element a determination may be made as to whether Decl1 s parameter types are subtypes of the corresponding Decl2 parameter types. If Decl1 s parameter types are subtypes of Decl2 s parameter types Decl1 may be deemed more specific than Decl2 element . If there are other declarations that are yet to be examined as determined in element the next pair which may include Decl1 and one of the remaining declarations may be examined starting with the operations of element onwards.

If Decl1 s parameter types are not subtypes of Decl2 s parameter types as determined in element the compiler or interpreter may check whether D1 and D2 have the same parameter types element . If they do not have the same parameter types an error may be indicated element since the overload cannot be resolved as in the case of comparing m StringMapper and m IntMapper in Source Code Example 9.

If D1 and D2 have the same parameter types as also determined in element further analysis may begin based on their respective return types. The four conditions illustrated in element may be checked. If D1 s return type is a subtype of D2 s return type Decl1 may be deemed more specific than Decl2 as in the case of the comparison of m ToInteger to m ToNumber above. If D1 s return type is not void while D2 s is void Decl1 may be deemed more specific as in the case of m StringGetter being deemed more specific than m Runnable in Source Code Example 9 .

In at least some programming languages that support primitive and reference types a set of wrapper reference types may be defined for the primitive types for example the wrapper type Integer may be defined for the primitive type int in one embodiment. Conversion of a primitive value to an object of the corresponding wrapper type may be referred to as boxing the primitive value with the result of the conversion being termed the boxed form of the value and the extraction of the primitive value from an object of the corresponding wrapper class may be referred to as unboxing the wrapper with the result being termed the unboxed form of the object . If the D1 return type is an unboxed form of D2 s return type and all of the lambda expression s return values are unboxed Decl1 may also be deemed more specific than Decl2 see the discussion of the comparison of m IntMapper and m ToInteger in Source Code Example 9 . If the D1 return type is a boxed form of D2 s return type and if the returns from the lambda expression are all boxed then Decl1 may also de determined to be more specific than Decl2.

If any of the conditions listed in element are found to be true a specificity ordering between Decl1 and decl2 may be made element otherwise an error may be indicated. Similar analysis may be repeated for other unexamined pairs of declarations until either an error is indicated because the overload cannot be resolved or all the declarations have been examined and one declaration is found that is more specific than all the rest. If such a single most specific declaration is identified element it may be used to resolve the overload and generate the executable instructions for the invocation element . It is noted that the rules or criteria used for specificity ordering may differ in different embodiments e.g. the order in which the parameter types and return types are analyzed may differ in some embodiments from that shown in . It is also noted that some of the operations illustrated in may be performed in a different order in parallel rather than sequentially or may be omitted in different embodiments. The operations illustrated in with respect to lambda expressions and or method references may be applied to other kinds of argument expressions whose type is context dependent in various embodiments.

In various embodiments computing device may be a uniprocessor system including one processor or a multiprocessor system including several cores or processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the SPARC x86 PowerPC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store program instructions implementing a compiler an interpreter source code of various programs to be compiled executable code generated by the compiler or other compilers and an execution environment similar to runtime environment of . System memory may also include program instructions and or data for various other applications. Program instructions may be encoded in platform native binary any interpreted language such as Java bytecode or in any other language such as C C Java etc or in any combination thereof. In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory.

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing device and other devices attached to a network or networks for example. In various embodiments network interface may support communication via any suitable wired or wireless general data networks such as types of Ethernet network for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

In some embodiments system memory may be one embodiment of a computer accessible medium configured to store program instructions and data as described above for through for implementing embodiments of the corresponding methods and apparatus. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. Generally speaking a computer accessible medium may include non transitory storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computing device via I O interface . A non transitory computer accessible storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc that may be included in some embodiments of computing device as system memory or another type of memory. Further a computer accessible medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in may be used to implement the described functionality in various embodiments for example software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments portions of the described functionality may be implemented using storage devices network devices or special purpose computer systems in addition to or instead of being implemented using general purpose computer systems. The term computing device as used herein refers to at least all these types of devices and is not limited to these types of devices.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer accessible medium. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc as well as transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the Figures and described herein represent example embodiments of methods. The methods may be implemented in software hardware or a combination thereof. The order of method may be changed and various elements may be added reordered combined omitted modified etc.

Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

