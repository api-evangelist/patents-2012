---

title: Static sorted index replication
abstract: Static sorted index replication is described. A method may include receiving data to store in a memory tree of a replica in a partitioned distributed data store. The method may also include storing the received data in the respective memory tree of one of a plurality of replicas. The method may further include storing the received data sequentially in a static sorted index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08965849&OS=08965849&RS=08965849
owner: Amazon Technologies, Inc.
number: 08965849
owner_city: Reno
owner_country: US
publication_date: 20120806
---
For various data stores index storage often becomes highly fragmented in the face of random writes. One example of an index store that becomes highly fragmented from random writes is a B Tree based index store e.g. Berkeley DB BDB InnoDB etc. . Traditional B Trees perform well for sequential writes and random access search but suffer greatly when faced with highly entropic random writes. B Tree based index stores degrade and become blocked by random I O for insertion which may only be a mere fraction of hard disk or solid state drive SSD bandwidth. Further range queries on such aged trees suffer due to leaf nodes being scattered on the disk. Such fragmentation also increases the total cost of ownership TCO of the data store in terms of overhead to store the index store and speed to recover the store from disaster e.g. iterating over the index store can cost O N random seeks on disk .

Specific embodiments are shown by way of example in the drawings and will be described herein in detail. It should be understood however that the drawings and detailed description are not intended to limit the claims to the particular embodiments disclosed even where only a single embodiment is described with respect to a particular feature. On the contrary the intent is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Examples of features provided in the disclosure are intended to be illustrative rather than restrictive unless stated otherwise.

The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . The words include including and includes indicate open ended relationships and therefore mean including but not limited to. Similarly the words have having and has also indicate open ended relationships and thus mean having but not limited to. The terms first second third and so forth as used herein are used as labels for nouns that they precede and do not imply any type of ordering e.g. spatial temporal logical etc. unless such an ordering is otherwise explicitly indicated.

Various components may be described as configured to perform a task or tasks. In such contexts configured to is a broad recitation generally meaning having structure that performs the task or tasks during operation. As such the component can be configured to perform the task even when the component is not currently performing that task e.g. a computer system may be configured to perform operations even when the operations are not currently being performed . In some contexts configured to may be a broad recitation of structure generally meaning having circuitry that performs the task or tasks during operation. As such the component can be configured to perform the task even when the component is not currently on. In general the circuitry that forms the structure corresponding to configured to may include hardware circuits.

Various components may be described as performing a task or tasks for convenience in the description. Such descriptions should be interpreted as including the phrase configured to. Reciting a component that is configured to perform one or more tasks is expressly intended not to invoke 35 U.S.C. 112 paragraph six interpretation for that component.

 First Second etc. As used herein these terms are used as labels for nouns that they precede and do not imply any type of ordering e.g. spatial temporal logical etc. . For example for a system configured to perform static sorted index replication the terms first and second replicas can be used to refer to any two replicas. In other words the first and second replicas are not limited to logical replicas 0 and 1.

 Based On. As used herein this term is used to describe one or more factors that affect a determination. This term does not foreclose additional factors that may affect a determination. That is a determination may be solely based on those factors or based at least in part on those factors. Consider the phrase determine A based on B. While B may be a factor that affects the determination of A such a phrase does not foreclose the determination of A from also being based on C. In other instances A may be determined based solely on B.

The scope of the present disclosure includes any feature or combination of features disclosed herein either explicitly or implicitly or any generalization thereof whether or not it mitigates any or all of the problems addressed herein. Accordingly new claims may be formulated during prosecution of this application or an application claiming priority thereto to any such combination of features. In particular with reference to the appended claims features from dependent claims may be combined with those of the independent claims and features from respective independent claims may be combined in any appropriate manner and not merely in the specific combinations enumerated in the appended claims.

Various embodiments of systems and methods for static sorted index based e.g. log structured merge LSM based replication are disclosed. Various ones of the present embodiments may include creating a static sorted index that is live queryable and that may answer range queries more efficiently than fragmented index replicas. In some embodiments the static sorted index may compressed and may be used as a snapshot for garbage collection to replace fragmented index replicas and or for disaster recovery e.g. to replace a failed index replica 

The specification first describes a flowchart of one embodiment of a method for static sorted index replication followed by flowcharts for using the static sorted index for merging and garbage collection disaster recovery and performing queries. The specification then describes an example system that may implement the disclosed static sorted index updating and merging techniques followed by example querying on the static sorted index. Various examples are provided throughout the specification.

Turning now to one embodiment of a method for static sorted index replication is depicted. While the blocks are shown in a particular order for ease of understanding other orders may be used. In some embodiments the method of may include additional or fewer blocks than shown. Blocks may be performed automatically or may receive user input. Additionally the method of may be used in conjunction with one or more blocks of the methods of .

At data may be received. The received data may also be referred to as an update message an insert message an upsert update insert message and or a dataset. A dataset may refer to a single item of data e.g. a single bit of data or it may refer to multiple separately storable items of data such as multiple blocks of data e.g. 64 KB 256 KB 1 MB etc. . A dataset may correspond to a logical collection of records which may be stored in one or more index replicas as described herein. Examples of data records may include price changes for items for sale inventory for items for sale catalog information customer cart information etc.

The data may be storable in a partitioned e.g. hash partitioned distributed data store. In some embodiments such a data store may be a key value store such as a NoSQL database service e.g. DynamoDB offered by Amazon Web Services or some other data store. In one embodiment the data store may include multiple stores such as a combination of DynamoDB and some other data store. In such an example the multiple different data stores may collectively be referred to as a data store or they may be referred to as multiple data stores.

The distributed data store may include a plurality of index replicas that are implemented as data structures in memory trees. For example memory trees may be b trees e.g. b trees such as those used in Berkeley databases BDBs BDB Java Edition or LevelDB. As described herein the distributed data store may also include one or more static sorted index replicas apart from the plurality of index replicas.

As illustrated at the received data may be stored in one of the plurality of replicas. For example the data may be stored in the memory tree of one of the plurality of replicas. Storage writes of the data in the replica may be highly entropic e.g. random .

Additional data may also be received and stored in one of the replicas. As the storage of the data in the replicas may be random over time the data in the replicas may be highly fragmented. The fragmentation may cause the replicas to degrade and become blocked by random I O for insertion.

As shown at the data may be stored sequentially in a static sorted index of the partitioned data store. The static sorted index is sorted in that the data is stored sequentially in the index. Moreover note that after the data is stored sequentially in the static sorted index the data in the index may be made static e.g. read only . Until data is stored sequentially in the static sorted index however it may be writeable. The static sorted index may also be referred to as an index data structure or replica. In various embodiments the static sorted index may not be implemented in the same manner as the plurality of replicas. For example instead of being implemented as a simple b tree the static sorted index may be log structured merge LSM based e.g. as Sorted String Tables SSTables or may be based on other schemes such as Cache Oblivious Lookahead Array COLA . In a COLA embodiment the index may be implemented as a cache oblivious streaming b tree.

As part of block the static sorted index may be generated and data from the in memory trees e.g. red black tree skip list for a concurrent implementation etc. of the replicas may be stored into the generated static sorted index. In some embodiments creation generation of a static sorted index may be performed as a batch commit of received data. For example a new static sorted index may not necessarily be created each time data is received. Instead in such embodiments a static sorted index may be created periodically e.g. after a certain period of time such as once an hour 3 times a day etc. after a certain amount of data has been received e.g. after every 64 KB of data is received etc. or upon encountering a system failure e.g. failure of a replica etc. Accordingly until the static sorted index is generated and data is stored sequentially in that static sorted index various received data may be stored randomly amongst one or more of the plurality of replicas resulting in fragmented replicas. Note that over time the method of may be repeated such that multiple static sorted indexes exist. For example in an embodiment in which the static sorted index is performed periodically once an hour after three hours three separate static sorted indexes may exist.

Data may be stored sequentially in the static sorted index according to a number of different techniques. For example data stored in the various fragmented replicas may be associated with respective timestamps key or other indication of an order. The data may then be ordered in the static sorted index according to the indication of the order. In one embodiment an indication of the data received at may be stored in one or more transaction logs. A common transaction log may be associated with each of the plurality of replicas or each replica may be associated with its own transaction log.

In some embodiments the static sorted index may be used along with another data store for durable backup. For example the other data store may be an online storage web service such as S3 offered by Amazon Web Services which provides storage through web services interfaces such as REST SOAP and BitTorrent or some other data store.

In some embodiments the static sorted index may be slipped into the final tier of a B Tree to create a hybrid 2 level LSM tree where live updates are made in the B Tree.

In various embodiments received data is described as being written to various ones of the replicas e.g. B Tree replicas . In some embodiments the sorted index may not be static and data may be written directly to the sorted index.

In some embodiments as described herein a segment for bloom filters may be added to the static sorted indexes to increase query performance.

As will be described in more detail at the static sorted index may be used for garbage collection disaster recovery and for performing queries e.g. range queries .

Turning now to one embodiment of a method for using a static sorted index for merging and garbage collection is depicted. While the blocks are shown in a particular order for ease of understanding other orders may be used. In some embodiments the method of may include additional or fewer blocks than shown. Blocks may be performed automatically or may receive user input. Additionally the method of may be used in conjunction with one or more blocks of the methods of FIGS. and .

As noted above multiple static sorted indexes may exist. As shown at the static sorted index e.g. from block may be merged or compacted with one or more previously generated static sorted indexes. The result of the merge may be a single merged static sorted index. As a simple example consider a scenario in which three static sorted indexes have been generated. The three static sorted indexes may be merged into a single static sorted index. As a result the sorted data from the three indexes is sequentially stored in the single static sorted index such that the data is compacted together.

Merging may be performed in response to reach a threshold quantity of static sorted indexes e.g. 4 static sorted indexes 8 static sorted indexes etc. in response to reaching a threshold quantity of data e.g. 256 MB 512 MB etc. in the static sorted indexes periodically e.g. once an hour once a day etc. upon failure of a replica node or based on other criteria.

In some embodiments compacting the sequential data together may allow the single static sorted index to be compressed. Because some of the data may be static e.g. cold data in a catalog space data may be compressed in large blocks e.g. 64 k . Each block may be compressed and associated with a table to facilitate random block reads. With the compression table random access decompression may be achieved which may be transparent to the data structure. By compressing cold data additional I O per read may be saved. In some instances a 10 compression factor may achieved. Compression metadata may specify the compression algorithm e.g. DEFLATE LZF delta encoding incremental encoding etc. as well as static dictionaries to aid in compression e.g. ZLIB with dictionary .

As illustrated at sequential data from the merged static sorted index may be provided to a new replica. The new replica may be of the same type B Tree as the plurality of replicas. The new replica may be configured to accept subsequent writes of newly received data such that it is a read write replica. One or more replicas of the plurality of replicas may be modified to be read only such that the read only replica s may be queried but not written to. At the point the sequential data is provided to the new replica at the new replica includes the same data that is on the plurality of replicas except that the new replica is flatter e.g. a flatter b tree and the data on the new replica is sequentially sorted thereby facilitating faster and cheaper reads. Accordingly at one or more of the plurality of replicas may be purged removed. Note that as random writes are performed on the new replica the new replica may become fragmented. Then the blocks of may be repeated such that eventually the new replica may be purged in favor of an even newer replica.

Turning now to one embodiment of a method for using a static sorted index for disaster recovery is depicted. While the blocks are shown in a particular order for ease of understanding other orders may be used. In some embodiments the method of may include additional or fewer blocks than shown. Blocks may be performed automatically or may receive user input. Additionally the method of may be used in conjunction with one or more blocks of the methods of and .

As shown at prior to storing the received data sequentially in the static sorted index an indication of the received data may be stored in a transaction log. Storing the indication of the received data in the transaction log may be performed as part of storing the data in the memory tree of the replica. As described herein the transaction log may in some embodiments actually include multiple transaction logs distributed among the plurality of replicas. Each of those logs may include an indication of the data stored in the respective replica. Accordingly the various logs may collectively store indications of each of the received and stored data.

As noted above the transaction logs may be used as part of the sequential storing of block of . For example the transaction log may have ordering information e.g. an ordered key a timestamp that permits the in memory table data of the various replicas to be serialized into the static sorted index.

In some embodiments the transaction log s may be purged. For example each time a static sorted index is generated the transaction log s may be purged as the static sorted index includes the updates inserts upserts that were indicated in the transaction log s .

In some instances however a replica may fail at some point in time when the transaction log s is not empty or purged and includes indications of updates inserts upserts that are not reflected in any static sorted index. And as illustrated at a new replica may be generated to replace a failed replica. The new replica may generated by applying updates inserts upserts indicated in the transaction log to a copy of the sequentially stored data from the static sorted index. Accordingly the static sorted index and the transaction log are usable to create a new replica to replace a failed replica.

Turning now to one embodiment of a method for using a static sorted index for performing queries is depicted. While the blocks are shown in a particular order for ease of understanding other orders may be used. In some embodiments the method of may include additional or fewer blocks than shown. Blocks may be performed automatically or may receive user input. Additionally the method of may be used in conjunction with one or more blocks of the methods of .

At a request to perform a range query on the partitioned distributed data store may be received. A range query may be a query from one identifier to another identifier in a partition. As shown at in response to receiving the request to perform the range query the range query may be performed on the static sorted index.

Requests to perform other types of queries may also be received. Certain types of queries e.g. range queries may be more effectively performed e.g. faster fewer CPU cycles etc. on the static sorted index whereas other types of queries may be more effectively performed on one of the b tree replicas. In some embodiments the system may include an intelligent query router that determines a type of the query. In such embodiments in response to a determination that a query request is a range query the range query may be performed on the static sorted index as in block . For a determination that the query is another type of query the query may be performed on one of the plurality of replicas.

The disclosed techniques may result in a snapshot of the data in non fragmented form. This may permit range queries to be answered more efficiently than a fragment B Tree on the main replicas thereby allowing certain operations to be more cost effective on the replica. This may also permit garbage collection and or disaster recovery to be performed. Moreover by keeping the other replicas in addition to the static sorted indexes benefits of the other replicas are maintained but without the degradation of performance and space of dealing with random writes over time.

A system that may be configured to perform updates and or merges into a static sorted index is shown in . illustrates an example progression from memory and disk to memory and disk respectively.

At an insert may be committed durably into an in memory tree e.g. a b tree replica of memory e.g. partionable data store . The insert or an indication corresponding to the insert may be stored in a transaction log . In the example shown three different static sorted indexes static sorted index and already exist in disk . At some point as described herein a new static sorted index may be created as represented by memory table flush merge and the dashed line from memory tree to static sorted index . The cost of the memory table flush merge may be the cost of a file append e.g. to the log and O log M on the in memory tree which if M has a fixed size bound may be constant with respect to the input size N . The flush into the disk persisted index e.g. static sorted index may be purely sequential I O with insertions amortized into a batch operation.

Once the in memory table is serialized as static sorted index the transaction log may be purged or checkpointed as shown by the hashed lines in transaction log . Also at some point to help ensure that there are not O N small index files the various static sorted indexes may be merged into a single static sorted index as shown by disk file merge . The result is single static sorted index . In some embodiments there may be O log N static sorted indexes. Once there are more than O log N merge may take place. In other embodiments to try to leverage excess disk bandwidth and excess CPU the limit on static sorted indexes may be O 1 . Note that not all of the static sorted indexes may be merged together. In the example shown static sorted indexes and may be merged into single static sorted index without merging static sorted index . Static sorted index may be merged in a subsequent disk file merge . In other embodiments each of the static sorted indexes may be merged as part of disk file merge .

As described herein the merge process may be configured to reduce the number of static index files thereby limiting the impact of how many random disk I O operations need to be done for a query. Note that additional sequential I O bandwidth may be used at the gain of reduced random I O. Because sequential I O is generally a richer resource than random I O increased performance may result with such a configuration.

Moreover caching into memory from disk indexes for queries may become easier as a result. Because dirty pages in a B Tree index are no longer a concern in a system that utilizes the static sorted indexes the OS file cache may be relied upon to make hot read queries efficient. Further note that if stale reads are sufficient as in cold start queries servicing queries from the oldest generation e.g. last full merge may be sufficiently fast.

An embodiment of a computer system including computer accessible media is illustrated in . As illustrated computer system includes one or more processors coupled to a system memory via an input output I O interface . Computer system further includes a network interface coupled to I O interface . The disclosed techniques may be implemented using a single instance of computer system while in other embodiments multiple such systems may be configured to host different portions or instances of the disclosed techniques. Moreover in some embodiments some techniques may be implemented via instances of computer system that are distinct from those instances implementing other techniques.

In various embodiments computer system may be a single processor system including one processor or a multiprocessor system including several processors e.g. two four eight or another suitable number . Processors may be any suitable processor capable of executing instructions. For example in various embodiments processors may be a general purpose or embedded processor implementing any of a variety of instruction set architectures ISAs such as the x96 PowerPC SPARC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store instructions and data accessible by process . In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory. In the illustrated embodiment program instructions and data implementing desired functions such as those described above are shown stored within system memory as code .

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computer system and other devices attached to a network such as other computer systems for example. In various embodiments network interface may support communication via wired or wireless general data networks such as any suitable type of Ethernet network for example via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

Embodiments may be provided as a computer program product including a non transitory machine readable storage medium having stored thereon instructions in compressed or uncompressed form that may be used to program a computer or other electronic device to perform processes or methods described herein. System memory may be one embodiment of a computer accessible machine readable storage medium configured to store program instructions and data as described above. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. The machine readable storage medium may include but is not limited to hard drives floppy diskettes optical disks CD ROMs DVDs read only memories ROMs random access memories RAMs EPROMs EEPROMs flash memory magnetic or optical cards solid state memory devices or other types of media machine readable medium suitable for storing electronic instructions. Further embodiments may also be provided as a computer program product including a transitory machine readable signal in compressed or uncompressed form . Examples of machine readable signals whether modulated using a carrier or not include but are not limited to signals that a computer system or machine hosting or running a computer program can be configured to access including signals downloaded through the Internet or other networks. For example distribution of software may be Internet downloaded.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

