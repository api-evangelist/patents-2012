---

title: Keystore management system
abstract: A keystore management system is provided that manages a keystore. The keystore management system creates a mapping of a plurality of keystore identity parameters to a plurality of keystore repository parameters. The keystore identity parameters identify the keystore. The keystore repository parameters identify a repository that stores the keystore. The keystore is a storage entity stored on the repository. The keystore management system further stores the mapping within a configuration file. The keystore management system further translates the keystore identity parameters into the keystore repository parameters based on the mapping stored within the configuration file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08761399&OS=08761399&RS=08761399
owner: Oracle International Corporation
number: 08761399
owner_city: Redwood Shores
owner_country: US
publication_date: 20121019
---
One embodiment is directed to a computer system and more particularly to a computer system that manages one or more keystores.

Complex software systems that include multiple software application components such as Java 2 Enterprise Edition J2EE systems generally require that each software application component be able to establish secure communications with each other such as secure sockets layer SSL communication encryption or message protection. In the context of secure communication software systems generally rely on public key infrastructure PKI based communications which generally require the presentation of a cryptographic key or certificate authorization of the key or certificate and a secure exchange of information between the two or more software application components.

 Keystores can be used to store cryptographic keys and certificates for such secure communications where a keystore is defined as a storage entity that is configured to store cryptographic keys and certificates where the storage entity is stored within a repository. A common repository example for a keystore is a physical computer file also identified as a file on a file system. Other repository examples for a keystore are a lightweight directory access protocol LDAP server a database or a hardware device e.g. a hardware storage module .

However even though a PKI infrastructure allows for generation of a key or certificate the PKI infrastructure does not address how to manage the storage of the key or certificate i.e. how to manage the keystore . Management of such a keystore especially a keystore that is stored in a file in the past has generally been accomplished by using a command line tool e.g. a Java Development Kit JDK keytool which is executed on a physical machine or device where the keystore is present. Such an execution generally requires physical access to the machine or device. Thus in general managing the keystore has previously required access to the machine or device where the keystore is present.

One embodiment is directed to a keystore management system that manages a keystore. The keystore management system creates a mapping of a plurality of keystore identity parameters to a plurality of keystore repository parameters. The keystore identity parameters identify the keystore. The keystore repository parameters identify a repository that stores the keystore. The keystore is a storage entity stored on the repository. The keystore management system further stores the mapping within a configuration file. The keystore management system further receives a request to access content of the keystore from a software application. The request includes the keystore identity parameters. The keystore management system further translates the keystore identity parameters into the keystore repository parameters based on the mapping stored within the configuration file. The keystore management system further retrieves the content of the keystore from the keystore using the keystore repository parameters. The keystore management system further sends the content of the keystore to the software application.

In one embodiment a keystore management system is provided that can facilitate a uniform representation of a keystore using keystore identity parameters regardless of what type of repository the keystore is physically persisted in such as for example in a file in an LDAP server in a database or in a hardware device such as a hardware storage module . The keystore management system can receive keystore requests from software application components that include these keystore identity parameters rather than any information relating to repositories that store the keystores. This can eliminate a need for a software application component to remember keystore repository parameters such as a physical location of the keystore or a connection parameter for example a host a port a connection credential etc. as a software application component is not required to provide any keystore repository parameters in order to access one or more keystores. Thus access to the keystore can be virtualized through keystore identity parameters such as an application stripe name parameter which can represent a software application component that the keystore is associated with and a keystore name parameter which can represent a unique name of the keystore . Through the use of the keystore identity parameters the keystore management system can provide a unique identification for each keystore of an enterprise software application environment and can also separate the representation of the keystore from the repository information of the keystore so that the requesting software application component is not required to know the repository information of the keystore.

As previously described management of a keystore in the past has generally been accomplished by physically accessing a machine or device where the keystore is stored and thus has previously required access to the machine or device. In a large scale deployment with n servers and m keystores this can require having to login to n servers and accessing m keystore paths. Further if each keystore of the m keystores requires a unique password to access the keystore itself this requires the management of m keystore passwords. Further in a large scale deployment that includes a large number of software application components this may require sharing m keystores with multiple software application components. If one or more of the m keystores are moved this requires a significant overhead to manage the m keystores to ensure that the multiple software application components can access the m keystores. Moreover if one or more keys or certificates of the m keystores expire an administrator may have to go to each host that includes the keystore for the specific application component and renew the individual keys or certificates. Thus a significant amount of managerial overhead can be created by previous keystore management techniques. According to certain embodiments of the invention a keystore management system can at least in part manage one or more keystores while avoiding the managerial overhead previously described as will be described below in greater detail.

A computer readable medium may be any available medium that can be accessed by processor . A computer readable medium may include both a volatile and nonvolatile medium a removable and non removable medium a communication medium and a storage medium. A communication medium may include computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and may include any other form of information delivery medium known in the art. A storage medium may include RAM flash memory ROM erasable programmable read only memory EPROM electrically erasable programmable read only memory EEPROM registers hard disk a removable disk a compact disk read only memory CD ROM or any other form of storage medium known in the art.

Processor can also be operatively coupled via bus to a display such as a Liquid Crystal Display LCD . Display can display information to the user. A keyboard and a cursor control device such as a computer mouse can also be operatively coupled to bus to enable the user to interface with keystore management system .

According to one embodiment memory can store software modules that may provide functionality when executed by processor . The modules can include an operating system a keystore management module as well as other functional modules . Operating system can provide an operating system functionality for keystore management system . Keystore management module can provide functionality for managing a keystore as will be described in more detail below. In certain embodiments keystore management module can comprise a plurality of modules where each module provides specific individual functionality for managing a keystore. Keystore management system can also be part of a larger system. Thus keystore management system can include one or more additional functional modules to include the additional functionality. For example functional modules may include modules that provide additional functionality such as a module of the Oracle Fusion Middleware product from Oracle Corporation.

Processor can also be operatively coupled via bus to a repository . Repository can store data such as one or more keystores. In one embodiment repository is a database. In this embodiment repository can store data in an integrated collection of logically related records or files. Further in this embodiment repository can be an operational database an analytical database a data warehouse a distributed database an end user database an external database a navigational database an in memory database a document oriented database a real time database a relational database an object oriented database or any other database known in the art. In an alternate embodiment repository can be a file of a file system. In another alternate embodiment repository can be an LDAP server. In yet another alternate embodiment repository can be a hardware device such as a hardware storage module .

As previously described software application components and can establish secure communications with each other in order to send and receive information while reducing the risk that the communications with be intercepted by a third party. Such secure communications can be based on PKI based communications which can require a presentation of a cryptographic key or certificate authorization of the key or certificate and a secure exchange of information between the two or more software application components. Thus application components and can require access to one or more keys or certificates in order to securely communicate with each other or external entities in other systems. As is described below in greater detail these keys and certificates can be stored within one or more keystores and keystore management system can at least in part manage access to the one or more keystores by providing a uniform representation of the one or more keystores that is not dependent on how the one or more keystores are physically stored.

According to an embodiment keystore management system can virtualize access to the one or more keystores through a set of keystore identity parameters where the keystore identity parameters identify a keystore. Within the enterprise software application environment each software application component such as software application components and can have its own namespace identified as an application stripe and each software application component can have one or more keystores stored within the software application component s application stripe. Thus keystore management system can represent each keystore using a set of keystore identity parameters. In one embodiment each set of keystore identity parameters for a keystore can include two parameters an application stripe name parameter that uniquely identifies a software application component that the keystore is associated with and a keystore name parameter that uniquely identifies the keystore. Because a software application component can have a plurality of keystores stored within the software application component s application stripe the keystore name parameter can be used to distinguish between the keystores stored within the software application component s application stripe. According to the embodiment the keystore identity parameters do not require any information regarding where the keystore is physically stored or persisted. As is described below in greater detail keystore management system can determine this information based on the set of keystore identity parameters provided by an software application component such as software application components and . Thus a software application component is not required to know any information regarding where the keystore is physically stored or persisted in order to request access to keystore. Instead the software application component can provide keystore management system with the set of keystore identity parameters and keystore management system can locate the keystore using the set of keystore identity parameters.

According to the illustrated embodiment keystore management system includes service provider interface SPI which is configured to retrieve store or edit a keystore based on a set of keystore identity parameters. In one embodiment SPI can be configured to retrieve store or edit a keystore based on an application stripe name parameter and a key store name parameter. SPI can provide a collection of methods where the methods can facilitate retrieving a keystore from a repository retrieving one or more keys or certificates from the keystore creating a keystore creating one or more keys or certificates within the keystore updating one or more keys or certificates within the keystore deleting a keystore or deleting one or more keys or certificates from the keystore.

As is described below in greater detail one or more keystores can be stored in one or more types of repositories. Examples of such repository types include a file of a file system an LDAP server a database or a hardware device such as a hardware storage module . According to the embodiment as is also described below in greater detail the methods of SPI can receive the set of keystore identity parameters such as an application stripe name parameter and a keystore name parameter and can translate the set of keystore identity parameters into a set of keystore repository parameters where the keystore repository parameters identify a repository that stores the keystore. The methods of SPI can then use the set of keystore repository parameters to access and retrieve content of the keystore. According to an embodiment a class for each repository type not illustrated in can implement the methods of SPI and thus can facilitate retrieving a keystore from a repository retrieving one or more keys or certificates from the keystore creating a keystore creating one or more keys or certificates within the keystore updating one or more keys or certificates within the keystore deleting a keystore or deleting one or more keys or certificates from the keystore.

According to the illustrated embodiment keystore management system further includes configuration file . Configuration file can store information regarding one or more repositories where each repository can store one or more keystores. In one embodiment configuration file can store this information in the format of one or more keystore repository parameters. Thus configuration file can store one or more keystore repository parameters where the one or more keystore repository parameters can be used by one or more keystores. In one embodiment the one or more keystore repository parameters can include a repository type parameter that identifies a type of repository and one or more repository connection parameters that identify information used to connect to the repository. Example types of repositories include a file an LDAP server a database or a hardware device such as a hardware storage module . The repository connection parameters can depend on the type of the repository. For example in one embodiment if the type of repository is a file the repository connection parameters can include a file system parameter that identifies a location of a file that stores a keystore and a file path parameter that identifies a path of a file that stores the keystore. According to the embodiment if the type of repository is an LDAP server the repository connection parameters can include a host name parameter that identifies a location of the LDAP server a port parameter that identifies a port of the LDAP server a user name parameter that identifies a user name that is used to connect to the LDAP server and a password parameter that identifies a password that is used to connect to the LDAP server. Further according to the embodiment if the type of repository is a database the repository connection parameters can include a host name parameter that identifies a location of the database a port parameter that identifies a port of the database a user name parameter that identifies a user name that is used to connect to the database and a password parameter that identifies a password that is used to connect to the database. In one embodiment a loading process can be executed to load the information regarding one or more repositories into configuration file . Further in this embodiment when a new repository is created the information regarding the repository can be loaded into configuration file through a supplemental loading process.

Further according to the illustrated embodiment configuration file can map a set of keystore identity parameters to a set of keystore repository parameters. In other words configuration file can associate a set of keystore identity parameters that identify the keystore with a set of keystore repository parameters that identify a repository that stores the keystore. These one or more associations can be further stored within configuration file as a mapping. Such a mapping of configuration file is further described below in relation to . In one embodiment where a new keystore is created within a repository a set of keystore identity parameters that correspond to the new keystore can be mapped to a set of keystore identity parameters that identity a repository that stores the new keystore. In this embodiment the new mapping can be used by SPI to access the repository and create the new keystore within the repository.

Thus SPI when provided a set of keystore identity parameters can search the mapping of configuration file and locate a corresponding set of keystore repository parameters. Based on the mapping of configuration file SPI can translate a set of keystore identity parameters into a set of keystore repository parameters. Thus according to the embodiment SPI can identify and locate a keystore associated with the set of keystore identity parameters no matter where the keystore is persisted. Furthermore a software application component that requests access to a keystore does not need to know information regarding a repository where the keystore is persisted. Instead the software application component only is required to provide the set of keystore identity parameters. SPI is an example SPI that can be provided within keystore management system according to an example embodiment. In other embodiments another SPI can be provided within keystore management system that performs the aforementioned functionality of SPI .

According to the illustrated embodiment keystore management system further includes repositories and where repository includes keystore repository includes keystore and repository includes keystore . However this is merely an example embodiment and in alternate embodiments keystore management system can include any number of repositories where each repository can include any number of keystores. As previously described a repository is a storage entity configured to store one or more keystores and a keystore is a storage entity configured to store one or more cryptographic keys or certificates. As also previously described application components and can require access to one or more keys or certificates in order to securely communicate with each other or with an external entity. In addition as also previously described these keys and certificates can be stored within one or more keystores where one or more keystores can be stored within one or more repositories. Further repositories and can be repositories of any type. Example types of repositories include a file an LDAP server a database and a hardware device such as a hardware storage module .

After SPI has translated a set of keystore identity parameters into a set of keystore repository parameters SPI can use the keystore repository parameters to access one or more keystores such as keystores and that are stored within one or more repositories such as repositories and . The accessing the one or more keystores can include retrieving the one or more keystores from the one or more repositories and storing the one or more keystores within a memory of keystore management system not illustrated in . For example in one embodiment if the type of repository is a file SPI can access the file using the file system parameter and the file path parameter and access one or more keystores stored within the file. In another embodiment if the type of repository is an LDAP server SPI can connect to the LDAP server using the host name parameter the port parameter the user name parameter and the password parameter and access one or more keystores stored within the LDAP server. Further in another embodiment if the type of repository is a database SPI can connect to the database using the host name parameter the port parameter the user name parameter and the password parameter and access one or more keystores stored within the database. In certain embodiments accessing a key store can include retrieving the keystore from the repository retrieving one or more keys or certificates from the keystore creating one or more keys or certificates within the keystore updating one or more keys or certificates within the keystore deleting the keystore or deleting one or more keys or certificates from the keystores. In other embodiments SPI can use the keystore repository parameters to create one or more keystores. According to one embodiment a class for each repository type not illustrated in can use the keystore repository parameters to access one or more keystores such as keystores and that are stored within one or more repositories such as repositories and . Thus according to the embodiment SPI can interact with repositories of any repository type and can be implemented in any enterprise software application environment.

An example embodiment is now described. In the example embodiment software application component sends a request to access one or more keys or certificates of keystore which is stored within repository . Of course this is only an example embodiment and in alternate embodiments any software application component can send a request to access any keys or certificates of any keystore which can be stored within any repository. In one embodiment the request can be a request to retrieve one or more keys or certificates of keystore . In an alternate embodiment the request can be a request to create one or more keys or certificates of keystore . In another alternate embodiment the request can be a request to update one or more keys or certificates of keystore . In yet another alternate embodiment the request can be a request to delete keystore . In yet another alternate embodiment the request can be a request to delete one or more keys or certificates of keystore . In addition in an alternate embodiment rather than a request to access one or more keys or certificates of keystore software application component can send a request to create a new keystore within repository .

According to the example embodiment software application component sends the request to SPI where the request includes a set of keystore identity parameters that correspond to keystore . In one embodiment the set of keystore identity parameters can include an application stripe name parameter and a keystore name parameter that collectively correspond to keystore . SPI subsequently accesses a mapping stored within configuration file and retrieves a set of keystore repository parameters that are mapped to the set of keystore identity parameters. In one embodiment the set of keystore repository parameters can include a repository type parameter that identifies a type of repository for repository and one or more repository connection parameters that identify information used to connect to repository . By retrieving the set of keystore repository parameters that are mapped to the set of keystore identity parameters SPI effectively translates the set of keystore identity parameters into the set of keystore repository parameters. SPI or a class implementing a method of SPI uses the set of keystore repository parameters to access one or more keys or certificates of keystore that is stored within repository . If the request to access one or more keys or certificates of keystore sent by software application component requires keystore management system to return the one or more keys or certificates of keystore or possibly keystore itself SPI can send the one or more keys or certificates of keystore or keystore itself to software application component .

In one embodiment a keystore such as keystore can be moved from a first repository such as repository to a second repository such as repository or repository . In this embodiment the mapping in configuration file is updated where the set of keystore identity parameters that correspond to the keystore are associated with a set of keystore repository parameters that correspond to the second repository rather than the first repository. Thus a software application component such as software application components and can continue to refer to the keystore by the same set of keystore identity parameters and SPI can use the updated mapping in configuration file to provide access to the correct keystore.

According to one embodiment SPI can provide a custom runtime keystore provider interface for accessing a keystore at runtime. For example this method can be a LoadStoreParameter interface. SPI can provide a LoadStoreParameter interface that can be implemented by a repository type class not illustrated in where the LoadStoreParameter interface specifies a set of keystore identity parameters that identify a keystore. In one embodiment the set of keystore identity parameters for the LoadStoreParameter interface can include an application stripe name parameter that uniquely identifies a software application component that the keystore is associated with and a keystore name parameter that uniquely identifies the keystore. In an alternate embodiment the set of keystore identity parameters can also include a password parameter that identifies a password used to access the keystore.

Below is an example of psuedocode for a requesting software application component such as software application components and that can send a request to SPI to access a keystore using the LoadStoreParameter interface 

Below is another example of psuedocode for a requesting software application component such as software application components and that can send a request to SPI to access a keystore using the LoadStoreParameter interface 

According to an alternate embodiment SPI can introduce additional application programming interfaces APIs that can return a keystore. The following APIs can be introduced within SPI a public KeyStore get FarmTrustStore which can return a common domain level trust store and does not require a password b public KeyStore getKeyStore String stripeName String keystoreName char password which can return a specified keystore from an application strip protected by the given password and c public KeyStore getDefaultApplicationKeyStore char password which can return a default application key store .

Below is an example of psuedocode for a requesting software application component such as software application components and that can send a request to SPI to access a keystore using the getKeyStore API 

Below is another example of psuedocode for a requesting software application component such as software application components and that can send a request to SPI to access a keystore using the getKeyStore API 

In the illustrated embodiment each row of the rows within mapping i.e. rows and represents a keystore. One of ordinary skill in the art would readily appreciate that the illustrated embodiment is an example embodiment and that in alternate embodiments mapping can include any number of rows where the number of rows corresponds to a number of keystores.

Further according to the embodiment each row includes a set of keystore identity parameters where each set of keystore identity parameters includes an application stripe name parameter and a keystore name parameter. The application stripe name parameter uniquely identifies a software application that the keystore corresponds to. The keystore name parameter uniquely identifies the keystore. In addition according to the embodiment each row also includes a set of keystore repository parameters where each set of keystore repository parameters includes a repository type parameter and one or more repository connection parameters. The repository type parameter identifies a type of the repository and the one or more repository connection parameters identify information used to connect to the repository.

According to the embodiment the repository connection parameters can depend on the type of the repository. For example if the type of repository is a file the repository connection parameters can include a file system parameter that identifies a location of a file that stores a keystore and a file path parameter that identifies a path of a file that stores the keystore. If the type of repository is an LDAP server the repository connection parameters can include a host name parameter that identifies a location of the LDAP server a port parameter that identifies a port of the LDAP server a user name parameter that identifies a user name that is used to connect to the LDAP server and a password parameter that identifies a password that is used to connect to the LDAP server. Further if the type of repository is a database the repository connection parameters can include a host name parameter that identifies a location of the database a port parameter that identifies a port of the database a user name parameter that identifies a user name that is used to connect to the database and a password parameter that identifies a password that is used to connect to the database.

Thus in the illustrated embodiment row includes an application stripe name parameter with the value Application1 a keystore name parameter with the value Identity Keystore a repository type parameter with the value File a file system parameter with the value System1 and a file path parameter with the value system1 application1 identity keystore.ks. Row includes an application stripe name parameter with the value Application1 a keystore name parameter with the value Trust Keystore a repository type parameter with the value File a file system parameter with the value System1 and a file path parameter with the value system1 application1 trust keystore.ks. Row includes an application stripe name parameter with the value Application2 a keystore name parameter with the value Identity Keystore a repository type parameter with the value File a file system parameter with the value System2 and a file path parameter with the value system2 application2 identity keystore.ks. Row includes an application stripe name parameter with the value Application3 a keystore name parameter with the value Identity Keystore a repository type parameter with the value LDAP server a host name parameter with the value System3 a port parameter with a value 10 a user name parameter with the value LDAP1 and a password parameter with the value keystore. Row includes an application stripe name parameter with the value Application4 a keystore name parameter with the value Identity Keystore a repository type parameter with the value Database a host name parameter with the value System4 a port parameter with a value 10 a user name parameter with the value Database1 and a password parameter with the value keystore. 

As one of ordinary skill in the art would appreciate illustrates an example diagram of mapping according to one embodiment. However in alternate embodiments mapping could be of a different format and still be within a scope of the invention.

The flow begins and proceeds to . At a mapping of a plurality of keystore identity parameters to a plurality of keystore repository parameters is created. The keystore identity parameters of the plurality of keystore identity parameters identify the keystore. The keystore repository parameters of the plurality of keystore repository parameters identify a repository that stores the keystore. The keystore includes a storage entity stored on the repository.

In one embodiment the keystore identity parameters of the plurality of keystore identity parameters include an application stripe name parameter that uniquely identifies a software application component and a keystore name parameter that uniquely identifies the keystore. Also in the embodiment the keystore repository parameters include a repository type parameter that identifies a type of the repository and one or more repository connection parameters that identify information used to connect to the repository. In one embodiment the type of repository is one of a file an LDAP server a database or a hardware device such as a hardware storage module .

In one embodiment when the type of repository is a file the repository connection parameters include a file system parameter that identifies a location of the file that stores the keystore and a file path parameter that identifies a path of the file that stores the keystore. In the embodiment when the type of repository is an LDAP server the repository connection parameters include a host name parameter that identifies a location of the LDAP server a port parameter that identifies a port of the LDAP server a user name parameter that identifies a user name that is used to connect to the LDAP server and a password parameter that identifies a password that is used to connect to the LDAP server. In the embodiment when the type of repository is a database the repository connection parameters include a host name parameter that identifies a location of the database a port parameter that identifies a port of the database a user name parameter that identifies a user name that is used to connect to the database and a password parameter that identifies a password that is used to connect to the database. The flow proceeds to .

At the mapping is stored within a configuration file. The flow proceeds to . At a request to access content of the keystore is received from a software application component. The request includes the keystore identity parameters of the plurality of keystore identity parameters. In one embodiment the content of the keystore includes at least one of one or more cryptographic keys or one or more cryptographic certificates. In another embodiment the content of the keystore includes the entire keystore. The flow then proceeds to .

At the keystore identity parameters of the plurality of the keystore identity parameters are translated into the keystore repository parameters of the plurality of keystore repository parameters based on the mapping stored within the configuration file. The flow then proceeds to . At the content of the keystore is retrieved from the keystore using the keystore repository parameters of the plurality of keystore repository parameters. The flow then proceeds to . At the content of the keystore is sent to the software application component. The flow then ends.

Thus according to an embodiment a keystore management system can at least in part manage one or more keystores by providing a uniform representation of the one or more keystores using keystore identity parameters such as an application stripe name parameter and a key store name parameter. Details regarding how the keystore is physical stored can be abstracted by using keystore identity parameters. Thus software application components do not require knowledge of the physical storage details of each keystore. This allows administrators of the software application components to focus on the use of keys and certificates provided by the keystores rather than the storage and management of the keystores. Further a software application component s usage of keys and certificates provided by the keystores can stay unchanged regardless of where and how the keystore is persisted and secured for example whether the keystore is persisted within a file stored on a disk or persisted in a database that is centrally managed .

In addition the flexibility of using various repositories for storing one or more keystores can allow an enterprise software application to leverage the capabilities of the various repositories without having to do it from scratch for the keystore. For example using a database or an LDAP server as a repository to store one or more keystores can provide for a centralized repository that can be accessed from multiple hosts and can allow sharing of keystores without duplicating copying content. Further separating out the details regarding the persistence of the keystores can leverage abilities of the repository which can improve scalability. For example if a keystore needs to be accessible from a large number of software application components storing the keystore in a central repository such as an LDAP server or a database can allow the enterprise software application to scale. Finally a uniform representation of the one or more keystores allows a software application component to request access to a plurality of keystores in a consistent way rather than requesting access differently depending on how and where the keystore is stored.

The features structures or characteristics of the invention described throughout this specification may be combined in any suitable manner in one or more embodiments. For example the usage of one embodiment some embodiments certain embodiment certain embodiments or other similar language throughout this specification refers to the fact that a particular feature structure or characteristic described in connection with the embodiment may be included in at least one embodiment of the present invention. Thus appearances of the phrases one embodiment some embodiments a certain embodiment certain embodiments or other similar language throughout this specification do not necessarily all refer to the same group of embodiments and the described features structures or characteristics may be combined in any suitable manner in one or more embodiments.

One having ordinary skill in the art will readily understand that the invention as discussed above may be practiced with steps in a different order and or with elements in configurations which are different than those which are disclosed. Therefore although the invention has been described based upon these preferred embodiments it would be apparent to those of skill in the art that certain modifications variations and alternative constructions would be apparent while remaining within the spirit and scope of the invention. In order to determine the metes and bounds of the invention therefore reference should be made to the appended claims.

