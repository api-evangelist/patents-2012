---

title: Process for serializing and deserializing data described by a schema
abstract: A process for serializing and deserializing instance data from a schema is disclosed. A schema can be used to automatically and dynamically generate classes and methods. First, the raw schema may be parsed into an intermediate data structure consisting of <key,value> pairs representing object properties and attributes of the properties. Then, an exemplary process generates new parser classes and methods by iterating over the intermediate data structure's keys and generating classes or class variables based on the property type. Accessors and mutators are generated for each class variable. Additionally, a serialization method and a constructor method are generated for each class. These classes and methods are stored in memory and can be used by a host programming language to transmit, receive, and manipulate data to or from an API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460198&OS=09460198&RS=09460198
owner: Google Inc.
number: 09460198
owner_city: Mountain View
owner_country: US
publication_date: 20120726
---
Web services provide access to various types of data such as maps email news and social networking information. Web service providers often provide application programming interfaces APIs so that software developers can have controlled access to web services and data. An API is a code based specification which allows software components to communicate with one another. APIs may contain information such as the methods available and the data returned by the available methods from a particular web service.

For example a web service provider may create a web mapping service and provide a Map API for software developers to access the mapping service s functionality. The Map API may contain information about the web mapping service including methods to obtain directions to a place the travel distance between places the travel time between places and a place s elevation. If a software developer is building an application for a fast food restaurant the developer may want to use the Map API to allow a user to request directions to the restaurant from the user s current location. The developer does not have to write the map specific code to obtain directions but can instead use the Map API to access the web service provider s functionality and obtain the directions. The developer can write code that calls the methods that are defined by the API and uses the data that is returned from the methods.

Most API providers also give developers a client library and or documentation which demonstrates how to retrieve data objects from their respective APIs. An API client library may include a discovery document as generated code which shows a developer how to access objects and methods. The discovery document is structured data that may contain 1 a list of API resource schemas that describe the data developers have access to in each API 2 a list of API methods and available parameters for each method and 3 the format of the information that will be returned from each method when the method is accessed.

Data typically needs to be serialized by a web service before it is sent to a remote client. Serialization is the process of converting classes and objects into a linear sequence of bytes for either storage or transmission to another location. Often the linear sequence of bytes is represented as a string. Data also needs to be deserialized into classes and objects when the data is received via an API by the remote client. Deserialization is the process of taking in the linear sequence of bytes and recreating classes and objects from these bytes. Most data conversion software for serialization and deserialization is written by hand and parses data into manually created classes and objects. While this approach may be viable for a small number of APIs mistakes are likely when data must be parsed for numerous APIs or when APIs are frequently updated.

This specification describes technologies relating to serializing and deserializing data and specifically to a method for dynamically generating classes and objects from a schema at runtime.

In general one aspect of the subject matter described in this specification can be embodied in a system and method for dynamically generating classes and methods in memory. An exemplary system includes one or more processing devices and one or more storage devices. The storage devices store instructions that when executed by the one or more processing devices cause the one or more processing devices to receive a schema which describes the format and properties of instance data to be transmitted or received use a client library to convert the raw schema data into an intermediate key value pair data structure with each key representing a property of the object dynamically generate parser classes and methods using associative values representing the attributes of the corresponding property which include a type attribute and store the generated parser classes and methods in memory. An exemplary method includes receiving a schema which describes the format and properties of instance data to be transmitted or received using a client library to convert the raw schema data into an intermediate key value pair data structure with each key representing a property of the object dynamically generating parser classes and methods using associative values representing the attributes of the corresponding property which include a type attribute and storing the generated parser classes and methods in memory.

These and other embodiments can optionally include one or more of the following features dynamically generating parser classes and methods comprises iterating over the property keys for each property using the associative values representing the attributes of the property to generate a class variable and defining accessors and mutators for each class variable defining a new parser class for the property if the property s type attribute is of non scalar non array value responsive to the presence of a validation attribute adding validation information to the accessor or mutator of the corresponding property responsive to the presence of a data transformation attribute adding data transformation information to the accessor or mutator of the corresponding property generating a serialization method on the new parser class that converts the parser class into a serialized format generating a parser class constructor which takes unparsed instance data as a parameter and returns an instance object with properties set to values from the instance data and matching the property to the defined types in the order that the types are listed in the schema and responsive to a match using the matching type to create the class property.

The details of one or more embodiments of the invention are set forth in the accompanying drawings which are given by way of illustration only and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims. Like reference numbers and designations in the various drawings indicate like elements.

 Parser class means the in memory representation of a schema that can be used to process instance data.

 Instance data may refer to either the serialized unprocessed data an API uses in request and response bodies and as parameters to remote procedure calls. Instance data may also refer to the intermediate partially processed form generated by JSON or XML libraries.

According to an exemplary embodiment a schema can be used to automatically and dynamically serialize and deserialize instance data that is transmitted to or received from an API client.

A schema is a framework that helps organize and interpret information. A schema is typically used to define validation rules and verify received data. Some schemas describe data objects data objects interrelationships and methods. A schema may be available through a customary discovery document. The schema in the discovery document may describe the data to which a developer has access from an API. Although a schema may be obtained through a discovery document there are alternative mechanisms by which a schema may be obtained.

Schemas may additionally be defined in separate files from one another. For example in the properties adr and geo defining an address and a geographic location respectively contain definitions that reference urls. The actual object definitions of these properties exist in the file that is defined by the url. These properties schemas are shown in and

Schemas may also extend other schemas creating an inheritance relationship between the schemas. A schema that extends another schema is called a child schema and will inherit all properties and constraints from the inherited parent schema. The inheritance relationship requires that any instance of a child schema be validated against the parent schema.

Schemas may also reference themselves as illustrated in . shows a schema which defines a binary tree node called node.json. The schema has references to itself in each of its properties. The schema defines two properties left and right which refer to node.json since both properties are also binary tree nodes.

As discussed above instance data typically needs to be serialized and deserialized when it is transmitted to and from a remote client. Parser classes are created in order to perform deserialization. Instance objects are used to perform generation. Parser classes parse data often from strings and generators generate objects from the parsed data. Often these classes are created manually. Although the manual creation of parsers and generators for serialization and deserialization is typically time consuming and error prone a schema may be used to automate the process making it more efficient and consistent.

As illustrated in an exemplary process for automatically and dynamically serializing and deserializing instance data that is transmitted to or received from an API begins with receiving schema data that describes the expected format of instance data which is transmitted from an API method . In some embodiments this schema is included with a discovery document. A typical discovery document may contain several schemas. For very large complex APIs a discovery document may contain hundreds of schemas.

The raw schema data may then be parsed into an intermediate pair data structure such as a hash table . Parsing is the process of analyzing data and separating the data into parts by following a set of defined rules. For example given the JSON schema of an intermediate parsing step may divide the JSON into pairs based on given delimiters. This intermediate parsing step is usually done by a library such as a JSON or XML parsing library. A serialization format may use delimiters such as and to separate the data into pairs. illustrates how the business card schema of may be parsed into a data structure of nested pairs. In the top level keys of the business card data structure are description type and properties. Under properties there are several nested pairs representing the properties of a business card . Each property may contain more nested pairs representing the attributes of that property.

Once schema data is deconstructed into an intermediate data structure an exemplary process generates new parser classes and methods based on the structured properties . These parser classes and their methods are stored in memory and can be used by a host programming language to transmit receive and manipulate instance data to or from an API .

A host programming language is a language in which the application using the API is written. If a host programming language is a compiled language the classes and methods are generated prior to compiling. If the host programming language is a dynamic language the new parser classes and methods may be generated at runtime. One difference between a compiled language and a dynamic language is that a compiled language requires code generation and a subsequent compile step. These compiled languages usually cannot define a class and corresponding methods at runtime. Examples of compiled languages are Java and C . Dynamic languages can create classes and methods at runtime. Examples of dynamic languages include Ruby PHP and Python. Dynamically defining the classes and corresponding methods at runtime is beneficial to developers because dynamic definitions of classes and methods can respond to changes in a schema without recompiling and potentially without even restarting the application.

Aspects of the inventive concepts include an exemplary process for analyzing schema data to create a parser class defined by the given schema. The process iterates over the list of properties defined by the schema as illustrated in . For each property in the schema the process reads associative values representing the attributes of the property to generate a class variable . If the property references another schema the reference or memory address is followed to obtain the actual referenced schema. The given schema is then checked to see if it or any of its referenced schemas extend other schemas. If there are inheritance relationships all parent properties are incorporated into the children. Additionally any definition of a property in the child schema that shares a name with a property in the parent schema is merged with the parent schema s property definition.

Next a new parser class may be generated for non scalar non array properties defined by the given schema . Non scalar non array properties are often types of objects or unions. An object type is an entity that consists of data properties and methods. A union type is an entity that can be one of several types or formats. A union type is represented as an array of several formats from which the actual data type can be chosen. For example the binary tree schema of describes a union. In the binary tree type is defined as object null . Given this union type definition the exemplary process will try to assign the property data first as an object type since that was the first type declared. If the property does not match an object the process will define the property data as null. Once the actual type of a union property has been determined either a class or a class variable can be created for that property.

A new parser class is created for every object type in a schema and for the schema itself. The parser class may include class variables as discussed below and accessors and mutators to update and retrieve these variables. Every new parser class also stores the schema from which it was generated and contains a static method that returns this raw schema. Each parser class additionally includes a constructor which takes a single parameter that is an unparsed schema data. The constructor returns an instance object with the instance data that was passed to the constructor via the schema data. New parser classes may furthermore be generated with a serialize method that when called will translate the class object into serialized data that can be transmitted or stored.

While some new parser classes are generated with names so that they can be accessed directly such as the business card class in other new parser classes are generated without named identifiers and can only be accessed by reference. These classes are referred to as anonymous classes.

In addition to generating parser classes the exemplary process generates class variables for each data property in a schema and associates these properties with their corresponding class based on the schema definition and the nested hierarchy . For example given the business card schema of a business card class may have class variables for a formatted name family name given name additional names honorific prefix honorific suffix nickname url email address telephone number address geographic location photo logo sound birthday title role and organization.

The process may also generate accessor and mutator methods for each defined class variable . These accessor and mutator methods may perform all necessary type checking bounds checking and format checking for the data variable as required by the schema . These methods may also perform any data transformations required during serialization or deserialization. illustrates an exemplary Ruby class based on the schema from . attr accessor is short hand notation for accessors and mutators. The constructor is represented by the initialize method which takes in schema data. Parser classes for email telephone address geographic location and organization are also shown. Although all parser classes are shown in the same file in some embodiments these classes can be generated in several different files and can also be generated one per file.

In some embodiments non scalar non array type variables are represented by automatically generated classes. For example the email variable of may be its own class. The email class may contain class variables such as type and value to keep track of a type of email account such as home or work and the actual email address value. Class variables can be one of several types including string a particular object integer any which is considered a completely unparsed value and array.

An instance object may have a serialization method as depicted in the Business card class illustrated in . This serialization method may be created when the class is generated and may show how to marshal the object meaning convert the instance object into a serialized format. When a developer calls the serialization method the class object is changed from an object into a linear sequence of bytes for either storage or transmission to another location. By using dynamically generated classes and methods to serialize and deserialize instance data from a schema data conversion can be consistent and efficient.

Aspects of the inventive concepts are designed to simplify the creation of parser classes to perform deserialization and instance objects to perform serialization. An exemplary embodiment allows for a single client per programming language to automatically create parser and generator classes in the programming language for serialization and deserialization instead of these classes having to be created manually. Schema data is used in order to automatically create parser classes and instance objects. Although schemas were originally intended to validate instance data in an exemplary embodiment schemas may be used to dynamically generate object oriented in memory representations of serialized instance data. Clients provide developers with interfaces that are easy to use easy to maintain and capable of the serialization and deserialization necessary when data is being transmitted.

Depending on the desired configuration the processor can be of any type including but not limited to a microprocessor P a microcontroller C a digital signal processor DSP or any combination thereof. The processor can include one more levels of caching such as a level one cache and a level two cache a processor core and registers . The processor core can include an arithmetic logic unit ALU a floating point unit FPU a digital signal processing core DSP Core or any combination thereof. A memory controller can also be used with the processor or in some implementations the memory controller can be an internal part of the processor .

Depending on the desired configuration the system memory can be of any type including but not limited to volatile memory such as RAM non volatile memory such as ROM flash memory etc. or any combination thereof. System memory typically includes an operating system one or more applications and program data . The application includes an application that can perform large scale data processing using parallel processing. Program Data includes storing instructions that when executed by the one or more processing devices implement a method for serializing and deserializing data described by a schema. In some embodiments the application can be arranged to operate with program data on an operating system .

The computing device can have additional features or functionality and additional interfaces to facilitate communications between the basic configuration and any required devices and interfaces. For example a bus interface controller can be used to facilitate communications between the basic configuration and one or more data storage devices via a storage interface bus . The data storage devices can be removable storage devices non removable storage devices or a combination thereof. Examples of removable storage and non removable storage devices include magnetic disk devices such as flexible disk drives and hard disk drives HDD optical disk drives such as compact disk CD drives or digital versatile disk DVD drives solid state drives SSD and tape drives to name a few. Example computer storage media can include volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data.

System memory removable storage and non removable storage are all examples of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media can be part of the device .

The computing device can be implemented as a portion of a small form factor portable or mobile electronic device such as a cell phone a personal data assistant PDA a personal media player device a wireless web watch device a personal headset device an application specific device or a hybrid device that include any of the above functions. The computing device can also be implemented as a personal computer including both laptop computer and non laptop computer configurations.

The foregoing detailed description has set forth various embodiments of the devices and or processes via the use of block diagrams flowcharts and or examples. Insofar as such block diagrams flowcharts and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams flowcharts or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof. In one embodiment several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs digital signal processors DSPs or other integrated formats. However those skilled in the art will recognize that some aspects of the embodiments disclosed herein in whole or in part can be equivalently implemented in integrated circuits as one or more computer programs running on one or more computers e.g. as one or more programs running on one or more computer systems as one or more programs running on one or more processors e.g. as one or more programs running on one or more microprocessors as firmware or as virtually any combination thereof and that designing the circuitry and or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of non transitory signal bearing medium used to actually carry out the distribution. Examples of a non transitory signal bearing medium include but are not limited to the following a recordable type medium such as a floppy disk a hard disk drive a Compact Disc CD a Digital Video Disk DVD a digital tape a computer memory etc. and a transmission type medium such as a digital and or an analog communication medium. e.g. a fiber optic cable a waveguide a wired communications link a wireless communication link etc. 

With respect to the use of substantially any plural and or singular terms herein those having skill in the art can translate from the plural to the singular and or from the singular to the plural as is appropriate to the context and or application. The various singular plural permutations may be expressly set forth herein for sake of clarity.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

