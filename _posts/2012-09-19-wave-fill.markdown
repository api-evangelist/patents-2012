---

title: Wave fill
abstract: A method, system, apparatus, article of manufacture, and computer readable storage medium provide the ability to fill pixels of an image. An area of the image is obtained and one of the pixels is identified as an anchor pixel. Waves are created based on the anchor pixel and placed into a collection of waves waiting to be processed. Each of the waves in the collection is processed. A type of pixel in front of a current wave being processed is determined. If the pixel is fillable, the pixel is filled, the wave is advanced, and child waves are updated. If the pixel is blocking the advancement of the wave, the current wave is updated (e.g., via shrinking or splitting), and child waves are updated. Once all waves have been processed, the area of the image is displayed based on the fill.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08952979&OS=08952979&RS=08952979
owner: Autodesk, Inc.
number: 08952979
owner_city: San Rafael
owner_country: US
publication_date: 20120919
---
The present invention relates generally to image processing and in particular to a method apparatus and article of manufacture for filling an area of an image.

A common thing users of drawing painting and image processing software do is fill an area of an image with a solid color color gradient two or more colors fading into one another or texture. This operation is usually called flood fill . Another common thing users do in such software is select an area of more or less uniform color to which they want to limit the effects of subsequent actions. This is usually called magic wand selection. In both cases the user clicks on a pixel in the image referred to herein as the anchor pixel and a system methodology is needed to find fillable pixels pixels similar in color to the anchor pixel and adjacent to either the anchor pixel or to another fillable pixel. There are lots of different ways such a system and methodology can be implemented. The efficiency and complexity of the system and methodology can vary widely. Efficiency is very important since the system and methodology needs to examine potentially millions of pixels to determine whether they are fillable. Complexity is less critical than efficiency but still important since a complex system and methodology is harder for a software development team to understand maintain and enhance than a simple one.

Prior art systems for performing flood fill operations often examine the value of each pixel in an image at least four times. In this regard prior art solutions utilize a collection of pixels to be processed. Having determined a pixel to be fillable the pixels above below to the left and to the right of the fillable pixel are added to the collection of pixels to be processed. This means it is common for a given pixel of the image to be checked four times.

Accordingly what is needed is a system and methodology for determining locating and filling pixels in an efficient and simple manner.

This invention solves the problem of identifying fillable pixels efficiently in a fairly simple and easy to understand way. Embodiments of the invention examine potentially fillable pixels slightly more than once on average which is close to optimal. An optimal system in terms of efficiency would examine each potentially fillable pixel exactly once.

Embodiments of the invention are also simple enough to describe to a competent software developer in a matter of minutes with the aid of a few sketches. This is in contrast to many other systems methodologies solving the same problem which require some study to understand.

Embodiments of the invention analyze pixels based on an analogy of waves traveling through the image. As each wave advances through the image the pixels in front of the wave are examined to determine if they are border pixels. As the wave advances it also grows child waves on its left and right ends like a wake forming behind a boat. Once all waves including child waves and further descendant waves have been analyzed all fillable pixels have been identified and can be filled.

In the following description reference is made to the accompanying drawings which form a part hereof and which show by way of illustration several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.

In one embodiment the computer operates by the general purpose processor A performing instructions defined by the computer program under control of an operating system . The computer program and or the operating system may be stored in the memory and may interface with the user and or other devices to accept input and commands and based on such input and commands and the instructions defined by the computer program and operating system to provide output and results.

Output results may be presented on the display or provided to another device for presentation or further processing or action. In one embodiment the display comprises a liquid crystal display LCD having a plurality of separately addressable liquid crystals. Alternatively the display may comprise a light emitting diode LED display having clusters of red green and blue diodes driven together to form full color pixels. Each liquid crystal or pixel of the display changes to an opaque or translucent state to form a part of the image on the display in response to the data or information generated by the processor from the application of the instructions of the computer program and or operating system to the input and commands. The image may be provided through a graphical user interface GUI module . Although the GUI module is depicted as a separate module the instructions performing the GUI functions can be resident or distributed in the operating system the computer program or implemented with special purpose memory and processors.

In one or more embodiments the display is integrated with into the computer and comprises a multi touch device having a touch sensing surface e.g. track pod or touch screen with the ability to recognize the presence of two or more points of contact with the surface. Examples of multi touch devices include mobile devices e.g. iPhone Nexus S Droid devices etc. tablet computers e.g. iPad HP Touchpad portable handheld game music video player console devices e.g. iPod Touch MP3 players Nintendo 3DS PlayStation Portable etc. touch tables and walls e.g. where an image is projected through acrylic and or glass and the image is then backlit with LEDs .

Some or all of the operations performed by the computer according to the computer program instructions may be implemented in a special purpose processor B. In this embodiment the some or all of the computer program instructions may be implemented via firmware instructions stored in a read only memory ROM a programmable read only memory PROM or flash memory within the special purpose processor B or in memory . The special purpose processor B may also be hardwired through circuit design to perform some or all of the operations to implement the present invention. Further the special purpose processor B may be a hybrid processor which includes dedicated circuitry for performing a subset of functions and other circuits for performing more general functions such as responding to computer program instructions. In one embodiment the special purpose processor is an application specific integrated circuit ASIC .

The computer may also implement a compiler that allows an application program written in a programming language such as COBOL Pascal C FORTRAN or other language to be translated into processor readable code. Alternatively the compiler may be an interpreter that executes instructions source code directly translates source code into an intermediate representation that is executed or that executes stored precompiled code. Such source code may be written in a variety of programming languages such as Java Perl Basic etc. After completion the application or computer program accesses and manipulates data accepted from I O devices and stored in the memory of the computer using the relationships and logic that were generated using the compiler .

The computer also optionally comprises an external communication device such as a modem satellite link Ethernet card or other device for accepting input from and providing output to other computers .

In one embodiment instructions implementing the operating system the computer program and the compiler are tangibly embodied in a non transient computer readable medium e.g. data storage device which could include one or more fixed or removable data storage devices such as a zip drive floppy disc drive hard drive CD ROM drive tape drive etc. Further the operating system and the computer program are comprised of computer program instructions which when accessed read and executed by the computer cause the computer to perform the steps necessary to implement and or use the present invention or to load the program of instructions into a memory thus creating a special purpose data structure causing the computer to operate as a specially programmed computer executing the method steps described herein. Computer program and or operating instructions may also be tangibly embodied in memory and or data communications devices thereby making a computer program product or article of manufacture according to the invention. As such the terms article of manufacture program storage device and computer program product as used herein are intended to encompass a computer program accessible from any computer readable device or media.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with the computer .

A network such as the Internet connects clients to server computers . Network may utilize ethernet coaxial cable wireless communications radio frequency RF etc. to connect and provide the communication between clients and servers . Clients may execute a client application or web browser and communicate with server computers executing web servers . Such a web browser is typically a program such as MICROSOFT INTERNET EXPLORER MOZILLA FIREFOX OPERA APPLE SAFARI etc. Further the software executing on clients may be downloaded from server computer to client computers and installed as a plug in or ACTIVEX control of a web browser. Accordingly clients may utilize ACTIVEX components component object model COM or distributed COM DCOM components to provide a user interface on a display of client . The web server is typically a program such as MICROSOFT S INTERNET INFORMATION SERVER .

Web server may host an Active Server Page ASP or Internet Server Application Programming Interface ISAPI application which may be executing scripts. The scripts invoke objects that execute business logic referred to as business objects . The business objects then manipulate data in database through a database management system DBMS . Alternatively database may be part of or connected directly to client instead of communicating obtaining the information from database across network . When a developer encapsulates the business functionality into objects the system may be referred to as a component object model COM system. Accordingly the scripts executing on web server and or application invoke COM objects that implement the business logic. Further server may utilize MICROSOFT S Transaction Server MTS to access required data stored in database via an interface such as ADO Active Data Objects OLE DB Object Linking and Embedding DataBase or ODBC Open DataBase Connectivity .

Generally these components all comprise logic and or data that is embodied in or retrievable from device medium signal or carrier e.g. a data storage device a data communications device a remote computer or device coupled to the computer via a network or via another data communications device etc. Moreover this logic and or data when read executed and or interpreted results in the steps necessary to implement and or use the present invention being performed.

Although the terms user computer client computer and or server computer are referred to herein it is understood that such computers and may be interchangeable and may further include thin client devices with limited or full processing capabilities portable devices such as cell phones notebook computers pocket computers multi touch devices and or any other devices with suitable processing communication and input output capability.

Of course those skilled in the art will recognize that any combination of the above components or any number of different components peripherals and other devices may be used with computers and .

Embodiments of the invention are implemented as a software application on a client or server computer . Further as described above the client or server computer may comprise a thin client device or a portable device that has a multi touch based display.

Anchor pixel The pixel clicked on by the user as a starting point for a fill or magic wand operation.

Color distance A measure of the difference between two colors. Two very similar colors would have a small color distance while two very different colors would have a large color distance. System methodologies of the invention may only refer to the color distance between the color of the anchor pixel and the color of a pixel that is being considered for filling. As used herein the color distance of a pixel refers to the color distance of that pixel with respect to the anchor pixel. The color distance can be determined based on any known computation including Euclidean distance in a device independent color space such as RGB red green blue CMYK cyan magenta yellow and key YUV luma Y and two chrominance components UV LCh lightness chroma and hue HSL hue saturation and lightness HSV hue saturation and value HIS hue saturation and intensity etc. .

While embodiments of the invention refer to color distance system methodologies of the invention may apply to any data structure of values arranged in a manner that may be thought of as a two dimensional 2D grid wherein each value may be compared using some comparison function against a reference value to determine if the difference between those values exceeds some tolerance or threshold. The values do not necessarily need to be colors although this is a common problem domain to which the methodology applies. The values do not need to be arranged spatially in a 2D manner they merely need to be arranged in a manner that can readily be thought of as such.

Tolerance A value usually specified directly or indirectly by the user used to determine whether a pixel is considered a border pixel.

Border pixel A pixel whose color distance exceeds the tolerance. The fill does not pass through border pixels.

Fill region The anchor pixel and all pixels directly or indirectly adjacent to the anchor pixel whose color distances do not exceed the tolerance. Embodiments of the invention grow the fill region starting from the anchor pixel until the fill region is bounded on all sides by border pixels and or the sides of the image itself.

Systems and methodologies of embodiments of the invention are built around the analogy of waves traveling through the image. As each wave advances through the image the pixels in front of the wave are examined to determine if they are border pixels. As the wave advances it also grows child waves on its left and right ends like a wake forming behind a boat.

Embodiments of the invention process one wave at a time except when multi threaded in which case each CPU core e.g. processors A and or B may process one wave at a time provided each core is filling a portion of the image that does not overlap portions being filled by other cores . This wave i.e. the wave being processed is called the current wave . Waves are not yet entered into the collection of waves to be processed. Instead waves remain attached to wave until the left end for A and or right end for B of wave can no longer advance at which point such waves A and or B are released from parent wave and are entered into the collection of waves waiting to be processed.

Processing the current wave means advancing the wave through pixels of the image until no part of the wave can advance any further. To advance a wave and hence expand the fill region the row or column of pixels in front of the wave are examined to determine if the wave can proceed through them. There are three kinds of pixels that might be found in front of a wave previously filled pixels border pixels or fillable pixels. The wave proceeds through fillable pixels but is blocked by border pixels and by pixels already filled by earlier waves .

When a wave encounters a border pixel an or a previously filled pixel the wave may shrink on the left end if the border pixel and or previously filled pixel blocks the left end shrink on the right end if the border pixel and or previously filled pixel blocks the right end or split into two waves if the border pixel and or previously filled pixel blocks the wave somewhere other than the left or right ends . Any time a wave shrinks the child wave on the shrinking end is released from its parent and added to the collection of waves waiting to be processed.

In step the left end of the current wave continues to advance but the right end A has split off and is now in the collection of waves waiting to be processed. The right child wave of the current wave is now the right child wave of the right end wave A and has not yet been entered into the collection of waves waiting to be processed.

In step the current wave continues to advance filling pixels . As the wave advances the length of child wave A grows. In addition once the initial border pixel that was blocking the wave has been passed a new child wave B is formed on the right side. Such a formation ensures that all pixels are considered. In this regard if a region of border pixels blocking a wave contains fillable pixels adjacent to pixels the wave will eventually fill embodiments of the invention will discover and fill those pixels during subsequent processing of child waves. Alternatively when forming child waves a determination may be conducted to determine if border pixels would prevent such a wave from forming.

Once a wave has reached the end of the image or cannot proceed any further e.g. is blocked the wave is marked as being processed and a new wave from the waves waiting to be processed is selected for processing.

One or more embodiments of the invention may be performed in a 3D environment. In this regard the system methodology described above may apply to a voxel a voxel is a mix of volume and pixel representation of a 3D space. In other words the 3D space that is to be flood filled needs to be represented by a 3D array of cubes. Voxels are analogous to pixels in the 2D methodology described herein. Voxels are fairly commonly used to represent 3D space for certain kinds of problems.

Each voxel needs to have a value you can compare against the value of the anchor voxel. This value is analogous to the color values of image pixels and the anchor pixel. Most likely in a 3D flood fill this value would represent something other than color e.g. density temperature etc. depending on the application .

Instead of each wave being thought of as a line segment travelling through 2D space each wave would lie on a plane travelling through 3D space. From the anchor voxel six initial waves may be created heading in the six possible directions in 3D space e.g. X X Y Y Z Z . This may be thought of as making a copy of the six faces of the anchor voxel and sending them outward from the anchor voxel.

As each of the six waves travels through the voxel space it builds four child waves pointed in different directions. The initial wave heading in the X direction would build child waves pointed in the Y Y Z and Z directions. When the initial X wave is blocked by a border voxel or previously filled voxel the four child waves would be released into the collection of waves to be processed.

Representing splitting and shrinking the waves may be somewhat different in a 3D environment. For a wave the size of one face of a voxel the representation splitting and shrinking of a wave may be fairly simple. However typically a wave may be many voxels wide and many voxels high. If one thinks of a wave as a tablecloth being lowered onto a table the center of the wave is blocked as the tablecloth strikes the table but the edges of the wave the portions not yet touching the table must break away from the blocked region and continue to travel in the direction the tablecloth was originally travelling.

In view of the above embodiments of the invention may represent the wave as a rectangle travelling through the voxel field. The rectangle has four edges each of which usually has a child wave associated with it. The rectangle advances one layer slice of voxels at a time. To advance the wave the voxels that the wave needs to proceed through are iterated over.

In other words the voxels that the wave needs to proceed through may be represented imagined as rows of voxels stacked on top of each other. The method iterates along each row starting from the top row and working towards the bottom row looking for fillable voxels. If a non fillable i.e. border or previously filled voxel is encountered the current wave rectangle is split into up to three wave rectangles. The first wave rectangle contains every complete unblocked row if any found so far in the iteration. The second wave rectangle contains the unblocked portion of the current row if any and the same portion of every subsequent row in front of the original wave rectangle. The third wave rectangle contains the remaining portion of the current row and the same portion of every subsequent row. The first and second waves rectangles if any are entered into the collection of waves to be processed and the third wave continues to be processed.

In addition if the first voxel of the first row is blocked the first row and potentially subsequent rows continues to be processed until a fillable voxel is encountered. At that point the wave rectangle is split into two. The first wave rectangle does not contain the blocked portion of the current row but does contain the same portion of every subsequent row. The second wave rectangle contains the remaining portion of the current row and the same portion of every subsequent row. The first wave rectangle is entered into the collection of waves to be processed and the second wave continues to be processed.

Each time a wave is advanced the borders of its child wave rectangles are extended or new child wave rectangles are created on each edge of the parent rectangle that doesn t already have a child.

In view of the above all fillable voxels reachable from an anchor voxel may be filled in reasonably efficient time. As with the 2D method described above the 3D methodology would typically examine each voxel once.

At step an anchor pixel of an area of an image to be filled is identified. The anchor pixel may be located at a certain location e.g. lower left corner of an image or may be identified by the user. Further the image area of the image may be obtained by a user retrieving identifying or creating an image area of an image.

At step the method for filling pixels using a wave is initialized by creating four 4 waves on the top bottom left and right sides of the anchor pixel. The four waves are placed into the collection of waves to be processed. The method completes when all waves have been removed from the collection of waves to be processed and processed.

At step one of the waves from the waves waiting to be processed becomes the current wave and processing begins.

At step the row or columns of pixels in front of the wave is examined to determine if the wave can proceed through them. As described above there are three types kinds of pixels that may be found in front of a wave previously filled pixels border pixels or fillable pixels. Thus at step a determination is made regarding what type of pixel is in front of the wave.

If the pixel in front of the wave is blocking the wave the pixel is either a previously filled pixel or a border pixel and processing is performed in accordance with steps . However if the pixel is a fillable pixel processing is performed in accordance with steps . In this regard each of the pixels in front of the wave is examined from one end of the wave to the other i.e. from left to right or from right to left filling fillable pixels shrinking the wave if it is blocked at the ends splitting the wave if it is blocked in the middle or terminating the wave if it is entirely blocked.

When a wave encounters a filled pixel or a border pixel a determination may be made at step regarding the extent of the blockage. If the entire wave is blocked the wave cannot advance further and processing continues at step . If the blocking pixel extends to the end of the wave i.e. to the right or left edge of the wave the wave is shrunk as described above with respect to . In other words the end e.g. left or right end of the wave is shrunk enough to allow the wave to advance where it isn t blocked by the blocking pixels.

If the blocking pixel is in the middle of the wave i.e. with portions of the wave remaining unblocked on both sides of the blocking pixel the wave is split as described above with respect to .

Once the wave is finished processing shrunk or split the processing continues at step where one child wave or both child waves of the current wave is released to the collection of waves waiting to be processed. A child wave is released if its respective end of the advancing wave is blocked. In this regard if the wave is shrunk on the left side due to a blocking pixel on the left side of the advancing wave the left child wave is no longer attached to the advancing wave . Accordingly the left child wave is now ready to be processed as a new wave and is released into the collection of waves . Similarly if the wave is split the portion of the wave that is no longer attached to the advancing wave as well any child waves of the unattached split away wave are released to the collection of waves ready to be processed. In this regard once a wave is shrunk or split any unattached split away waves and child waves are released to the collection of waves waiting to be processed. Any waves that are still attached to advancing wave are still being formed as child waves .

Once the wave is shrunk split appropriately and child waves have been released a determination is made at step regarding whether wave is finished processing. If the entire wave is blocked or the edge of the image has been reached the wave is finished processing and additional waves if any are processed via steps and the repeat of steps . Once all waves have been processed the method is complete at step .

Per step if the wave is still advancing the process continues back at step . Once a fillable pixel has been located for the advancing wave the fillable pixel is filled at step and advances to the next pixel at step . Once the wave advances any attached child waves are expanded. Alternatively if there is a missing child wave on either the left or the right side of the wave a new child wave may be created at step if possible . In this regard in one or more embodiments if the blocking pixel is still blocking the formation advancement of a child wave a child wave is not formed. Alternatively the wave may still be formed but when processed via steps such a wave may not advance any further.

In view of the above an advancing wave has child waves that grow expand on the left right sides until a blocking pixel is met at which point one or more of the child waves transition to waves waiting to be processed. Once all waves have been removed from the collection of waves to be processed and processed the method is complete at step .

This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example any type of computer such as a mainframe minicomputer or personal computer or computer configuration such as a timesharing mainframe local area network or standalone personal computer could be used with the present invention. In summary embodiments of the invention provide the ability to fill an area of an image based on the concept of an advancing wave. Organizing such a flood fill operation using waves as described herein provides an efficient manner for performing the fill. As the current wave advances embodiments of the invention merely check pixels in front of the wave to determine if they are fillable. It is reasonably uncommon for the methodology set forth herein to check a given pixel of the image more than once.

The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description but rather by the claims appended hereto.

