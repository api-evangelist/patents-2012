---

title: Shader serialization and instance unrolling
abstract: A graphics engine with shader unit thread serializing and instance unrolling functionality that executes multi-threaded shader logic in a single hardware thread is described. Hardware accelerated tessellation functionality is implemented utilizing programmable pipeline stages that allow custom, runtime configuration of graphics hardware utilizing programs compiled from a high level shader language that are executed using one or more shader execution cores. In one embodiment, multiple shader unit program threads are serialized to run in one hardware thread to allow a greater number of instructions to be executed on the shader cores and preserve hardware threads for primitive processing by other shader units.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09123167&OS=09123167&RS=09123167
owner: Intel Corporation
number: 09123167
owner_city: Santa Clara
owner_country: US
publication_date: 20120929
---
The described embodiments are generally related to the field of computer graphics. More particularly embodiments relate to the load balancing and merging of computer graphics shader core workloads.

Three Dimensional 3D models with low geometric detail may not fully convey the desired complexity of a 3D object. Higher detailed objects with a larger number of smaller polygons and an increased number of vertices may be better suited for use in some scenarios. However using a finely detailed object defined by a larger number of vertices requires a larger amount of system resources than a coarsely detailed object. Accordingly as the number of polygons and vertices increases in accordance with higher geometric detail the 3D graphics engine will approach the limit of available processing capability and system bandwidth.

Graphics engines featuring support for hardware accelerated tessellation provide one solution by allowing the creation of geometrically complex 3D objects for use in the final 3D scene while storing and animating less complex objects using a relatively low number of polygons. Coarse geometric models are stored and animated then the polygons of the geometric model are increased in detail by subdividing the polygons into smaller more finely detail polygons during the rendering of the final 3D object allowing an adaptable level of geometric detail. Hardware accelerated tessellation can be accomplished utilizing small programs known as shaders that execute on the graphics engine. Graphics applications generally supply shader programs in a high level language along with polygons textures and other object data as defined by one or more published Application Programming Interface API . Such high level shaders are not hardware specific so manufacturers of graphics hardware provide functionality to convert high level shader input into low level commands tailored for specific hardware. In some instances those commands are run in parallel on the graphics hardware when multi threaded shader execution is supported.

Modern graphics engines utilize multiple parallel processors referred to as shader cores to execute multiple simultaneous threads of shader instructions. As high level shader programs are converted into low level commands hardware specific optimizations are often included into the programs to better utilize the features of specific graphics hardware. Some graphics engines are designed explicitly to perform a large number of parallel operations using a larger number of shader cores each executing a small number of instructions while other graphics engines feature a smaller number of relatively more powerful shader cores capable of performing a larger number of instructions per core.

Described herein are embodiments of a graphics engine with shader unit thread serializing and instance unrolling functionality that executes multi threaded shader logic in a single hardware thread allowing a greater number of instructions to execute on the shader cores while limiting the number of shader unit threads that must be managed and scheduled. Embodiments of the invention implement hardware accelerated tessellation functionality utilizing programmable pipeline stages that allow custom runtime configuration of graphics hardware utilizing programs compiled from a high level shader language that are executed using one or more shader execution cores. In one embodiment multiple shader unit program threads are serialized to run in a single hardware thread to allow a greater number of instructions to be executed on the shader cores and preserve hardware threads for use by other shader units.

Processors exchange information with a chipset via individual P P interfaces using point to point interface circuits . Chipset can optionally exchange information with the coprocessor via a high performance interface . In one embodiment the coprocessor is a special purpose processor such as high throughput Many Integrated Core MIC processor a graphics engine or the like. A shared cache not shown is included in both processors and optionally outside of both processors and connected with the processors via P P interconnect such that either or both processors local cache information is stored in the shared cache if a processor is placed into a low power mode.

Chipset is coupled to a first bus via an interface . In one embodiment first bus is a Peripheral Component Interconnect PCI bus or a bus such as a PCI Express bus or another third generation I O interconnect bus although the scope of the present invention is not so limited. As shown in various I O devices are coupled to first bus along with a bus bridge which couples first bus to a low pin count bus . In one embodiment one or more additional processor s e.g. MIC processors graphics engines Digital Signal Processors are coupled to first bus . Various devices couple to the low pin count bus including a keyboard and or mouse communication devices and a storage unit such as a disk drive or other mass storage device which includes instructions code or data . Further an audio I O can couple to the second bus . Note that other architectures are possible. For example instead of the point to point architecture of a system can implement a multi drop bus or other such architecture.

Each of the processors and are some version of the processor of which shows a block diagram of a processor that has one or more cores and an optional integrated memory controller and integrated graphics. The solid lined boxes in illustrate a processor with a single core A a system agent a set of one or more bus controller units while the optional addition of the dashed lined boxes illustrates an alternative processor with multiple cores A N a set of one or more integrated memory controller unit s in the system agent unit and special purpose logic .

Different implementations of the processor include 1 a CPU with the special purpose logic being integrated graphics and or scientific throughput logic which includes one or more cores and the cores A N being one or more general purpose cores e.g. general purpose in order cores general purpose out of order cores a combination of the two 2 a coprocessor with the cores A N being a large number of special purpose cores for graphics and or scientific calculations and 3 a coprocessor with the cores A N being a large number of general purpose in order cores. Thus the processor is either a general purpose processor coprocessor or special purpose processor such as for example a network or communication processor compression engine graphics processor GPGPU general purpose graphics processing unit a high throughput many integrated core MIC coprocessor including 30 or more cores embedded processor or the like. The processor can also be implemented across several chips or entirely on one chip.

The memory hierarchy includes one or more levels of cache within the cores a set of one or more shared cache units and external memory not shown coupled to the set of integrated memory controller units . The set of shared cache units includes one or more mid level caches such as level 2 L2 level 3 L3 level 4 L4 or other levels of cache a last level cache LLC and or combinations thereof. While in one embodiment a ring based interconnect unit interconnects the integrated graphics logic the set of shared cache units and the system agent unit integrated memory controller unit s alternative embodiments use any number of well known techniques for interconnecting such units. In one embodiment coherency is maintained between one or more cache units and cores A N.

The system agent includes those components coordinating and operating cores A N. The system agent unit includes for example a power control unit PCU and a display unit. The PCU includes logic and components needed for regulating the power state of the cores A N and the integrated graphics logic . The display unit is for driving one or more externally connected displays. The cores A N can be homogenous or heterogeneous in terms of architecture instruction set. In one embodiment cores A N use the same instruction set. Alternatively two or more of the cores A N execute the same instruction set while one or more cores execute a subset of that instruction set or a different instruction set. For example in one embodiment the processor contains 4 cores A D to execute a general purpose instruction set and also contains core E and optionally core F to execute an instruction set containing graphics specific instructions.

Embodiments of the invention include implementations of the processor coupled to special purpose logic configured as shown in . In one embodiment graphics logic as in contains a ring based interconnect unit coupled to ring based interconnect unit . Commands coming from the ring based interconnect are interpreted by a command streamer which supplies instructions to individual components of a 3D graphics pipeline. The command streamer directs the operation of a vertex fetcher component which reads vertex data from memory and executes 3D vertex level commands provided by the command streamer . The vertex fetcher provides vertex data to a vertex shader which performs coordinate space transformation and lighting operations to each vertex. The vertex fetcher and vertex shader execute command threads via a thread dispatcher to acquire and process vertex data. Dispatched commands run via one or more shader arrays containing numerous special purpose cores to process commands from a programmable graphics pipeline.

The shader arrays have an attached cache which is specific for each shader array or shared between the arrays. The cache can be configured as a data cache an instruction cache or a single cache which is partitioned to contain data and instructions in different partitions. Embodiments of the invention also feature tessellation components in the graphics pipeline to perform hardware accelerated tessellation of 3D objects. A programmable tessellation controller and programmable tessellation evaluator each execute one or more threads in sequence or concurrently on one or more special purpose cores contained within the shader core arrays . The tessellation controller is programmed via a shader program referred to as a Hull Shader in the Direct3D API or a Tessellation Control Shader in the OpenGL API. Different APIs program the tessellation controller differently but shader programs from each API accept a group of vertices known as a patch which is processed to generate a set of tessellation control data and constant data. The control data is used by the tessellation evaluator to interpret the generated vertices while the tessellation controller sends an output patch and patch constant data to the tessellation generator .

The tessellation generator functions at the direction of the tessellation controller and contains special purpose logic to generate a set of finely detailed geometric objects based on the coarse geometric model that is provided as input to the graphics pipeline. A tessellation evaluator post processes the set of geometric objects generated by the tessellation generator to determine among other things the proper positioning coordinates for the vertices in the set of newly generated geometric objects. The tessellation evaluator is configured by a shader program referred to as a tessellation evaluation shader program in the OpenGL API or a domain shader as is known in the Direct3D API.

The geometric objects are then processed by a geometry shader via one or more threads dispatched to the shader core arrays or can proceed directly to the clipper . The geometry shader operates on entire geometric objects rather than vertices or patches of vertices as in previous stages of the graphics pipeline. If the tessellation units are not enabled the geometry shader receives input directly from the vertex shader . The geometry shader is programmable by a geometry shader program to perform geometry tessellation if the tessellation units are disabled however the geometry shader lacks the special purpose logic of the tessellation generator and will not perform as efficiently in most cases. If an application is to bypass the rasterizer and needs access to vertex data the processed vertex data is written to one or memory buffers via a ring bus interconnect by an output streamer . Vertex data destined for the rasterizer is then processed by a clipper which is either a fixed function clipper or a programmable clipper with both clipping and geometry shader functions. After the clipper vertex data is dispatched over an interconnect bus to the render output pipeline where a rasterizer dispatches pixel shaders to convert the geometric objects into their per pixel representations. The render output pipeline is discussed in more detail below.

One embodiment of a graphics engine contains a media engine 2D engine and display controller that contains special purpose fixed function logic and operates independently of the 3D pipeline or alternatively contains programmable elements that use the shader cores for execution. The display controller is generally connected to a display device not shown which may be an integrated display device as in a laptop computer or is an external display device attached via an external display device connector such as for example a display port or thunderbolt connector.

The graphics engine of has an interconnect bus to allow data and message passing amongst the major components of the graphics engine. In one embodiment the shader core array and associated caches and texture sampler unit connect to this data bus through a data port to perform memory access and communicate with render output pipeline components of the graphics engine. The render output pipeline contains a rasterizer and depth test component which converts vertex based objects into their associated pixel based representation. An associated render cache and depth cache are also available in some embodiments. A pixel operations component is available to perform pixel based operations on the data though in some instances pixel operations associated with 2D operations e.g. bit block image transfers with blending are performed by the 2D engine or substituted at display time by the display controller using overlay display planes. In one embodiment a cache is available that is shared amongst all graphics components allowing the sharing of data without the use of main system memory.

Embodiments of the invention are not specific to any one application programming interface as graphics driver software is used to translate API calls specific to one graphics library to hardware specific commands. One embodiment provides support to the Open Graphics Library supported by the Khronos Group the Direct3D library from the Microsoft Corporation or in one embodiment both OpenGL and D3D. If tessellation support using these APIs is desired then at least OpenGL 4.0 or Direct3D 11.0 would be optimal. Future APIs with a compatible 3D pipeline would also be supported if a mapping can be made from the render pipeline of that future API to the pipeline embodied in the graphics hardware.

Tessellation as embodied operates on a group of vertices known as patches that contain a group of vertices that will be tessellated. Patches of vertices will not have an explicit or implied geometric ordering but provide a framework from which to interpolate vertices during tessellation. The Direct3D domain shader or OpenGL tessellation evaluation shader then transforms the generated vertices into a polygonal form. In one embodiment an OpenGL vertex shader provides an array of vertices along with attributes corresponding to various output variables. The tessellation control shader will then execute for each vertex and generate two sets of data control variables that the tessellation evaluator will use to interpret the additional vertices generated by the tessellation generator and tessellation values that the tessellation generator will use to generate new vertices.

In one embodiment tessellation control is enabled utilizing the Direct3D API. In Direct3D a shader program named a hull shader controls the tessellation controller to perform the tessellation control functionality that enables the patch to be tessellated by the tessellation generator . In the hull shader program the vertices are processed to define the control points used by the domain shader to position the generated vertices after tessellation. Additionally the hull shader specifies the tessellation factors that define how the new vertices are generated. The Direct3D API refers to the vertices in the vertex patch as control points. These vertices are the edge points of the control polygon the domain shader uses when positioning the new vertices. In OpenGL the equivalent of the Direct3D hull shader is the tessellation control shader.

The tessellation generator generates new vertices by creating new primitives inside of the patch of vertices. In one embodiment triangles quads e.g. rectangles and squares or lines can be drawn within the vertex patch and then new vertices are generated by subdividing the polygons to make new smaller polygons. New vertices are then interpolated based on the smaller polygons. For example a patch containing four vertices can be drawn as a quad primitive and then subdivided into two triangles. Those two triangles are then subdivided into smaller triangles based on the tessellation factors. Alternately a quad can be subdivided by a tile of smaller quads. Numerous configurations are possible. The inner tessellation factor controls the number of primitives that are generated within the patch of vertices and the outer tessellation level controls the number of times to subdivide along the edge of the vertex patch. The vertices generated by the tessellation generator are based on the vertex patch without regard to the larger set of vertices in the geometric object. The output control points define how the tessellation evaluator transforms the newly generated vertices for use within the 3D scene.

Each control point is referenced with a control point identification number to allow the multiple threads of a shader program to determine which output control point to generate. In one embodiment the number of patch constant phase threads is runtime managed to limit the number of threads that are dispatched to the graphics engine based on the current state of the graphics hardware such as the number of available shader cores and number of threads pending dispatch from other shader units. In some instances all of the shader unit logic from multiple threads is merged into a single execution thread which will increase the number of free threads available to other shader units at the expense of in some cases slightly longer execution time for the single threaded logic in comparison to the multi threaded logic. Overall graphics pipeline performance is then improved by reducing the amount of contention among shader units in certain high throughput scenarios.

Additionally it is beneficial to merge operations into a common thread when executing vector operations that exploit data parallelism via Single Instruction Multiple Data SIMD operations. SIMD operations can perform a single instruction across multiple vectors of data and allow parallel operations on information without requiring additional execution threads. The ability to limit the number of threads or to ensure a minimum number of instructions per thread is desirable because the programmable elements of the graphics pipeline can in certain high throughput scenarios attempt to dispatch more hardware execution threads to the shader array than the shader array infrastructure can support which will slow overall pipeline speed. This is notable in the instance that numerous small threads are dispatched from multiple shader units on the data pipeline and delay the execution of larger more critical threads. For example if the tessellation controller dispatches enough threads to the shader array to prevent vertex shader or geometry shader operations from executing timely then overall pipeline performance is limited.

Tessellation control shaders that compute per patch tessellation constant data execute in a separate phase of the tessellation control program and can be instanced multiple times. Utilizing operation and operation patch constant data phases that would normally run in separate execution threads execute within a single execution thread. In operation each patch constant data phase contains different logic components for calculating different constants and each phase is executed serially in a single thread instead. A single patch constant data phase utilizing the same logic can be executed in multiple instances such that the same section of logic is executed multiple times each directing output to a separate output register on the graphics engine. In such a case one embodiment in operation serially executes each instance of the patch constant logic and then directs the output of each of the iterations of that phase to the appropriate output register as specified by the shader control program. In this manner a shader core capable of efficient SIMD operations can perform parallel execution on multiple groups of data without consuming an additional execution thread which will free graphics engine thread dispatch logic to dispatch threads for other components of the graphics pipeline allowing the graphics engine to more effectively manage data flow through the graphics render pipeline.

During the execution of a 3D application utilizing shader code written in a high level language the high level shader program is converted or assembled into one or more low level shader languages including shader byte code shader assembly or operation codes for hardware specific instructions. Assembly shader code is used as an example in the tables below the shader assembly code illustrates the discrete phases and multi threaded logic of a shader program. While examples of shader merge operations will be illustrated using assembly level shader code embodiments of the invention are not limited to operating at the assembly level and may operate on other stages of execution.

A shader program for a tessellation controller e.g. tessellation controller of consists of a per control point phase and a per patch patch constant phase as illustrated in . Calculations for dynamic level of detail or other tessellation techniques or optimizations are performed in this phase however in some instances no computations are made and an individual phase will pass through input data to the appropriate output registers without making modifications. In one embodiment a pass through control point phase is replaced with a generic pass through control point shader. Alternately the control point shader is completely bypassed and replaced with low level hardware instructions outside of the shader code that copies the memory locations of the input vertex control point data to the memory location assigned to the output control point data.

Partial examples of a tessellation control shader are shown in Tables I IV below. Table I shows a portion of a hull shader program of Direct3D used to control the tessellation controller of .

Table I is an example of a hull shader program that operates on an input patch with a single control point. The input control point has three elements a position element as i0 a color element as i1 and a texture coordinate element as i2. Generally the Direct3D API indicates that a hull shader will execute a shader thread for each output control point which means in the case of Table I thirty two threads will be executed. A system control point identification number declared on line as vOutputControlPointID is used as input to each thread to allow the shader logic to programmatically determine which output control point is to be calculated. In this example on line the value of vOutputControlPointID is copied into a temporary register which is then used to index the three elements of each of the thirty two output control points.

Table II below illustrates how in one embodiment the logic of Table I above is executed using a single thread.

In line of Table II above the same input and output control points illustrated in Table I are used. Additionally the state information for the 3D API external to the shader is configured to spawn only a single thread for this shader unit. In line currentOutputControlPointID is initialized to zero and in the example loop instruction block shown in lines through the instructions will loop for each required output control point using currentOutputControlpointID as an index substituting iterated single threaded logic in place of multi threaded logic. On line a register is used as a substitute for the current output control point ID system variable. The register is used as an index into the three elements of each output control point and the register is then incremented on line .

In addition to optimizing low level shader logic one embodiment of the graphics engine will bypass certain sections of shader code entirely when it is possible replace sections of shader instructions with graphics engine hardware instructions. shows an illustration of data flow in one embodiment of a graphics engine during shader unit program execution. After the data processed by one shader unit the output register data is copied to graphics engine shared memory or if possible the graphics engine shared cache. When the output data from one shader unit becomes input data for the next shader unit in the pipeline data is copied from shared memory or shared cache into the input registers for use by the next shader unit. In one embodiment output vertex data from the vertex shader is cached to become input vertex data for the tessellation controller. This is loaded into shader program input register where shader program calculations are performed before writing the result data to the shader program output register . When the shader program execution is complete as part of the thread termination process the output registers are copied as output vertex data to a data location in the graphics engine shared cache or alternatively the graphics engine local memory.

In one embodiment instanced patch constant phase logic that would be otherwise performed in multiple threads is performed within a single execution thread. For example sample logic of a low level shader that is instanced three times and normally is executed using three threads is illustrated in Table III.

In Table III the hs fork phase instruction shown on line indicates this section of logic is computed in a separate execution thread from the rest of the shader program. Additionally line indicates that three separate instances of the logic are executed in three separate threads. Lines each indicate the three separate output registers that correspond to the three system variables. Once the calculation of the output data is complete each thread will write to the corresponding output register based on the logic illustrated on lines . The vForkInstanceID.x input is modified by the system based on which instance is in execution and the output results are written in parallel to the output register corresponding to the instance identification number of the thread.

In some instances however the overall system performance is improved by executing all of the instructions serially in a single thread instead of multiple parallel threads. In one embodiment the low level code illustrated in Table III is reconfigured to execute the logic of each instance as a single thread. When the shader cores complete execution of the shader logic the output data for the multiple instances is directly written to the appropriate instance output register. One example of logic of Table III reconfigured to execute in a single thread instead of multiple parallel threads is illustrated in Table IV below.

As illustrated in Table IV the instancing logic is bypassed and each operation executes serially. The output registers are then directly loaded with the appropriate values as illustrated in lines . The overall system efficiency is enhanced by executing the logic of Table IV as opposed to the logic of Table III. The same functionality is performed while allowing two threads from other shader units to execute in the place of the two tessellation control shaders threads that have been eliminated. Any additional execution time required for the single threaded logic is hidden by increased overall pipeline performance.

In one embodiment the operating system is a Microsoft Windows operating system from the Microsoft Corporation or alternately is a UNIX based operating system. When utilizing the Direct3D API the operating system contains a front end shader compiler to convert shaders written in a high level shader language to shaders represented by a low level shader language. In one embodiment however the OpenGL API is enabled which passes the high level shader directly to the user mode graphics driver which is capable of performing high level shader compilation. The user mode graphics driver contains a back end shader compiler to convert the shader code into a hardware specific representation. In one embodiment the methods discussed above are implemented in the user mode graphics driver or back end shader compiler as appropriate under the circumstances depending on the capability or configuration of the graphics engine. Embodiments of the processor with integrated graphics can also perform the thread management logic within the graphics pipeline hardware or microcode.

The user mode graphics driver uses OS kernel mode functions to communicate with a kernel mode graphics driver and the kernel mode graphics driver communicates with a processor which in one embodiment is a processor with integrated graphics containing general purpose processor cores and graphics specific shader execution cores . In the alternative a discrete non integrated graphics core attached to the processor via a bus is also possible. In one embodiment all or part of the threading enhancement logic is implemented in one or more of the graphics specific shader cores or within the thread dispatch logic of the graphics engine as illustrated in .

To the extent various operations or functions are described herein they can be described or defined as hardware circuitry software code instructions configuration and or data. The content can be embodied in hardware logic or as directly executable software object or executable form source code high level shader code designed for execution on a graphics engine or low level assembly language code in an instruction set for a specific processor or graphics core. The software content of the embodiments described herein can be provided via an article of manufacture with the content stored thereon or via a method of operating a communication interface to send data via the communication interface. A non transitory machine readable storage medium can cause a machine to perform the functions or operations described and includes any mechanism that stores information in a form accessible by a machine e.g. computing device electronic system etc. such as recordable non recordable media e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. . A communication interface includes any mechanism that interfaces to any of a hardwired wireless optical etc. medium to communicate to another device such as a memory bus interface a processor bus interface an Internet connection a disk controller etc. The communication interface can be configured by providing configuration parameters and or sending signals to prepare the communication interface to provide a data signal describing the software content. The communication interface can be accessed via one or more commands or signals sent to the communication interface.

Various components described herein can be a means for performing the operations or functions described. Each component described herein includes software hardware or a combination of these. The components can be implemented as software modules hardware modules special purpose hardware e.g. application specific hardware application specific integrated circuits ASICs digital signal processors DSPs etc. embedded controllers hardwired circuitry etc. Besides what is described herein various modifications can be made to the disclosed embodiments and implementations of the invention without departing from their scope. Therefore the illustrations and examples herein should be construed in an illustrative and not a restrictive sense. The scope of the invention should be measured solely by reference to the claims that follow.

