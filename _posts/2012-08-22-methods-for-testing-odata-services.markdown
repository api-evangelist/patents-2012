---

title: Methods for testing OData services
abstract: The present disclosure describes computer implemented methods, computer systems, and computer readable mediums for recursively testing an OData service. One method may include extracting resource identifiers from an initial service document, and for each of the resource identifiers, retrieving a respective response document from the OData service. The method may further include applying a test function to each of the resource identifiers and respective response documents and recording a result of the test function for each of the resource identifiers. The method may further include recursively extracting new resource identifiers from the response documents and retrieving respective new response documents for each new resource identifier from the OData service until no additional resource identifiers are extracted from the new response documents.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713368&OS=08713368&RS=08713368
owner: SAP AG
number: 08713368
owner_city: Walldorf
owner_country: DE
publication_date: 20120822
---
This application relates to a computer implemented method a computer system and a computer readable medium for testing OData services.

Open Data Protocol OData is a hypertext transfer protocol HTTP based application protocol that supports the exchange of application data between a business logic server and an external user interface UI component such as an application on a mobile device. A client requests retrieving creating or manipulating a resource on a server by a uniform resource identifier URI . URIs identify resources. Data in requests and their responses are represented e.g. by extensible markup language XML documents whose format is defined by the OData specification. OData documents contain URIs that are used to navigate to resources.

The present disclosure describes computer implemented methods computer systems and computer readable mediums for testing an OData service. One method may include extracting resource identifiers from an initial service document and for each of the resource identifiers retrieving a respective response document from the OData service. The method may further include applying a test function to each of the resource identifiers and respective response documents and recording a result of the test function for each of the resource identifiers. The method may further include recursively extracting new resource identifiers from the response documents and retrieving respective new response documents for each new resource identifier from the OData service until no additional resource identifiers are extracted from the new response documents.

While generally described as computer implemented software embodied on non transitory media that processes and transforms the respective data some or all of the aspects may be computer implemented methods or further included in respective systems or other devices for performing this described functionality. The details of these and other aspects and embodiments of the present disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

In the following a detailed description of embodiments will be given with reference to the drawings. It should be understood that various modifications to the embodiments may be made. In particular one or more elements of one or more embodiments may isolated from each other and may be combined and or used in other embodiments to form new embodiments.

In general the system uses the representational state transfer REST architecture. The REST architecture is a style of software architecture for distributed systems that includes clients and servers. The test method component executing on a client device sends a request to the HTTP OData Client Connector which sends the request to the HTTP OData Server Connector which then sends the request to the server. The request can specify a URI for a response document provided by the OData service.

The server accesses the database and provides a response. The application programming interface API between the test method component and the HTTP OData Client Connector belongs to the HTTP OData Client Connector and the API between the HTTP OData Server Connector and the server belongs to the HTTP OData Server Connector.

The test method component includes a main test function module a test and validation module and storage for test state and reports . The test method component stores in the storage the current state of execution and a result of testing from the test and validation module. For example the test method component can store a report including any URIs extracted from an OData Document and the result of retrieving a response document for those URIs and testing the URIs and responsive documents. The result can be an indication of success or failure.

In general the test method component begins by receiving an initial service document from the OData service using the service root URI. The initial service document can include metadata for the OData service. The test method component extracts URIs from the initial service document. For example the test method component can extract all the URIs or a random sample of the URIs from the initial service document. The test method component then retrieves a response document from the OData service for each of the extracted URIs.

The test and validation module applies a test function to each of the URIs and the response documents and for each tested URI records the result of the test function in the storage. The test and validation functions express qualities related to the OData service definition. Successfully executing test and validation functions establishes that the service implementation fulfills the defined qualities. Examples of defined qualities include an access to an URI does not break an invalid URI returns a proper error message an URI behaves consistently in relation to the metadata of the service. The test and validation module is general and extensible because for any URI definition in a document a corresponding test routine can be associated with the URI definition to test corresponding conditions for that URI.

The test method then continues recursively extracting new URIs from the response documents and retrieving new response documents until no additional URIs are extracted. The test method can determine that no additional URIs are to be extracted for various reasons for example because a time limit has been reached because there are no new URIs in the new response documents or because a threshold number of URIs have been extracted.

The test and validation module applies a test function to each of the new URIs and new response documents and records in the storage the result of the test function. Because an OData service denotes a finite number of resources the test method component is guaranteed to terminate.

In some implementations the test method component guarantees that each URI of the OData service is requested at least once. For example while recursively extracting new URIs the system can extract all new URIs from new response documents instead of sampling from the new response documents.

In some implementations the test method component avoids requesting the same URI and HTTP operation more than once. For example the system can maintain a list of tested URIs in the storage for test and state reports. The system can compare new URIs against the list of tested URIs and avoid retrieving new response documents for already tested URIs.

In some implementations the test method component avoids testing the same document more than once. A document is identified by its ATOM ID which is stored in the document. For example the system can maintain a list of tested ATOM IDs. The system can compare the ATOM ID of a retrieved document against the list of URIs tested documents and avoid testing this document again. An ATOM ID is an example of a URI. For example the test method component can merge the list of tested URIs with the list of visited ATOM IDs.

For documents that adhere to the Atom standard the test method component can use the ATOM ID element of the documents to maintain the list of tested URIs. The Atom standard refers to the Atom Syndication Format or the Atom Publishing Protocol or both and it is an HTTP based protocol for creating and updating documents. The ATOM ID is an element that uniquely denotes the resource. The element name is ID and the qualifier ATOM refers to the proper schema the Atom standard.

The following provides a description of some functionality of the main test function module using example pseudo code. The pseudo code abstracts from XML processing. A parser transforms an XML document type ODATA XML into some object representation type ODATA DOC .

The test method can optionally randomly select which subset of URIs of a collection document it adds to the uriSet. The randomization can happen in the following code line 

The pair of origin and uri represents navigation paths and can be used in the testing function e.g. the example TestAndValidate function describe below.

The TestFunction Self origin uri objMeta function tests that the request itself does not break. It can test the request for example using the self reference contained in a element where rel self . . . . Hence for any single atom resource that can be accessed e.g. via a filter or navigation property the resource can also be accessed by the URI that is the unique representative of that resource. This test functionality can be covered by the function retrieve .

The TestFunction Queries uri function tests via the QueryOption that filterable properties can be filtered. Filterable properties can be specified by the service metadata in object ojbMeta. The function also tests that nonfilterable properties can be filtered which can produce an error. The function generates a set of meaningful QueryOptions for some subset of possible queries tests the paging functionality using the query options stop skip and inlinecount and tests expand with increasing depth of the navigation path using the query option EXPAND. For each depth of navigation path the expand clauses are generated by transitive closure over the navigation properties as specified in the metadata. In general a query is generated and appended to the URI e.g. as illustrated in the following pseudo code 

The TestFunction Editable uri tests create Modify and Delete operations. The function depends on application knowledge specific to the OData service being tested.

The TestFunction ErrorMessage uri function generates meaningful erroneous URIs and requests to test if the proper error code and message are returned. For example the function can request a Read on a non readable resource request a Modify on a read only resource request a Create on a non creatable resource request a Delete on a non deletable resource and so on. The function can request GET ENTITY on a 1 to many navigation and the function can request GET ENTITYSET on a 1 to 1 navigation. The function can test not providing mandatory fields in Create and Modify test violations of scale and precision and test on semantically wrong values e.g. out of domain and invalid material number. The function can test requesting a resource for which the test users does not have permission to request.

The TestFunction Conversions uri function tests various operations related to conversions. For example the function request to modify PUT a property that requires value conversions on the server e.g. Date Time. The function can request a subsequent Read GET and the function can then test on equality. Other examples include testing currency conversion with respect to corresponding meta data testing unit of measurement conversions testing null value conversion on non domain values for null able properties to confirm that the null rendered and testing exit functions.

The TestFunction MetaDataConsistency uri objMeta function tests if properties defined in the MetaData are provisioned e.g. contained in the response. The function can test referential constraints on associations e.g. so that when a leading object is deleted its dependent objects are also deleted.

The system includes a testing tool which can be for example an extended Computer Aided Test Tool eCATT client. The eCATT client is a tool for creating and executing functional tests for software.

The testing tool is coupled to a connector system which is in turn coupled to a subject test system that provides an OData Service. The connector system includes a test client which can be controlled using the testing tool. The test client sends requests to an OData Channel of the connector system which then sends an OData request to the subject test system. For example the testing tool can use a remote function call RFC . The OData Channel can also send the request using a generic RFC.

The subject test system includes a corresponding OData Channel which processes the request and sends it to an OData Adapter . The OData Adapater sends the request to a database . The database can be accessed by a business logic module or various other types of OData services.

The system receives an initial service document . The system extracts URIs from the initial service document . For each of the URIs the system retrieves a respective response document from the OData service . The system applies a test function to each of the URIs and response documents and records a result of the test function for each of the URIs .

Beginning with each of the response documents the system recursively extracts new URIs from the response documents and retrieves respective new response documents for each new URI from the OData service until no new URIs are extracted from new response documents . The system applies the test function to each of the new URIs and respective new response documents and records a result of the test function for each of the URIs.

The server may further include a hard disk drive for reading from and writing to a hard disk not shown and an external disk drive for reading from or writing to a removable disk . The removable disk may be a magnetic disk for a magnetic disk driver or an optical disk such as a CD ROM for an optical disk drive. The hard disk drive and the external disk drive are connected to the system bus by a hard disk drive interface and an external disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the server . The data structures may include relevant data for the implementation of the method as described above. The relevant data may be organized in a database for example a relational database management system or an object oriented database management system.

Although the exemplary environment described herein employs a hard disk not shown and an external disk other types of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards digital video disks random access memories read only memories and the like may also be used in the exemplary operating environment.

A number of program modules may be stored on the hard disk external disk ROM or RAM including an operating system not shown one or more application programs other program modules not shown and program data . The application programs may include at least a part of the functionality as depicted in .

A user may enter commands and information as discussed below into the server through input devices such as keyboard and mouse . Other input devices not shown may include a microphone or other sensors joystick game pad scanner or the like. These and other input devices may be connected to the processing unit through a serial port interface that is coupled to the system bus or may be collected by other interfaces such as a parallel port interface game port or a universal serial bus USB . Further information may be printed using printer . The printer and other parallel input output devices may be connected to the processing unit through parallel port interface . A monitor or other type of display device is also connected to the system bus via an interface such as a video input output . In addition to the monitor computing environment may include other peripheral output devices not shown such as speakers or other audible output.

The computing environment may communicate with other electronic devices such as a computer telephone wired or wireless personal digital assistant television or the like. To communicate the computer environment may operate in a networked environment using connections to one or more electronic devices. depicts the computer environment networked with remote computer i.e. mobile device . The remote computer may be another computing environment such as a mobile device such as a smart phone or tablet and may include many of the elements described above relative to the computing environment . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet and may particularly be encrypted.

When used in a LAN networking environment the computing environment may be connected to the LAN through a network I O . When used in a WAN networking environment the computing environment may include a modem or other means for establishing communications over the WAN . The modem which may be internal or external to computing environment is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the computing environment or portions thereof may be stored in a remote memory storage device resident on or accessible to remote computer . Furthermore other data relevant to the method may be resident on or accessible via the remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the electronic devices may be used.

The above described computing system is only one example of the type of computing system that may be used to in the method described above.

