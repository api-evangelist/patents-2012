---

title: Methods and apparatus for interactive debugging on a non-preemptible graphics processing unit
abstract: Systems and methods are disclosed for performing interactive debugging of shader programs using a non-preemptible graphics processing unit (GPU). An iterative process is employed to repeatedly re-launch a workload for processing by the shader program on the GPU. When the GPU encounters a hardware stop event, such as by reaching a breakpoint in any thread of the shader program, encountering a hardware exception, or failing a software assertion in the shader program, the state of any executing threads is saved, graphics memory is copied to system memory, and any currently executing threads are killed to enable the GPU to process graphics data for updating a display device. Each pass of the workload may result in incrementally more data being processed. In effect, the changing state and variable data resulting from each pass of the workload has the effect that the debugger is incrementally stepping through the shader program.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08572573&OS=08572573&RS=08572573
owner: Nvidia Corporation
number: 08572573
owner_city: Santa Clara
owner_country: US
publication_date: 20120309
---
The present disclosure generally relates to debugging and more specifically to methods and apparatus for interactive debugging on a non preemptible graphics processing unit GPU .

Conventional debugging tools provide the capability to halt execution of a program at a given point in the program and evaluate the processor context i.e. memory registers etc. at that point in the program using a user interface of some type typically a graphical user interface displayed on a monitor coupled to the debugging platform. Typically debugging tools are categorized as software implementations or hardware implementations.

Software debugging includes many techniques for detecting errors in a program. One technique for debugging a program is to modify the program so that various variable values are written to an alternate location or replace the normal program output during execution of the program. The program is then re executed to collect the desired output. While such techniques may be beneficial for detecting some types of errors these techniques have many disadvantages. Requiring a user to execute a modified program may not allow a user to analyze the program in real time. If the program is not deterministic then re executing the program may display inconsistent values for variables. In addition only trusted parties that have access to the program s source code may perform debugging operations. Further re executing the program may require large memory transfers in order to reset state variables which may introduce additional delays or inconsistencies. Modifying the program may also hide some errors caused by the specific timing of instructions as executed by the system or change the order of the instruction stream generated by the compiler thereby leading to entirely different results. Further a user may not be able to analyze the efficiency of the unmodified program to determine where some types of processing bottlenecks are occurring. Another technique based on software debugging implementations may utilize a software emulator to simulate the execution of a program on a targeted platform. The software emulator allows the user to step through instructions and understand the effects of those instructions on a processor context of the targeted platform. However because the software emulator merely simulates the targeted platform debugging certain transient errors caused by asynchronous execution of instructions may be difficult using the software emulator. Furthermore the software emulator may behave differently than the targeted hardware platform due to bugs inherent in the software emulator or tradeoffs between simulation performance and accuracy thus confounding the debugging issue.

In addition to software debugging tools many hardware platforms implement various hardware debugging tools that may be used in lieu of or in addition to software debugging techniques. For example some processors enable hardware breakpoints to be implemented by a debugger that halts the execution of the program on the processor when a specific instruction is executed and waits for a resume command to be issued. Other processors implement some type of debugging port such as a JTAG Joint Test Action Group port that enables access to internal debug modules implemented on the integrated circuit of the target platform.

Conventionally debugging may be implemented via software emulators or via remote debugging that requires a targeted platform connected to a computer that is executing the debugger. One reason for implementing debugging on a target platform that is separate from a development platform is that halting execution of a source program executing on the same platform of the debugger may also halt critical hardware needed to run the debugger. For example utilizing a breakpoint on a CPU executing a source program may prevent the CPU from running the operating system thereby preventing the programmer from viewing the state of the CPU or making changes to memory using the software debugging tools.

Accordingly what is needed in the art is a system and method that allows for interactive debugging of a target GPU while also allowing the target GPU to continue normal screen drawing operations received from the operating system.

One example embodiment of the disclosure sets forth a method for performing interactive debugging on non preemptible graphics processing units. The method includes the steps of causing a shader program to be loaded onto a parallel processing unit where the parallel processing unit is configured to render a graphical user interface for an interactive debugging environment for display on a display device coupled to the parallel processing unit and issuing a workload to the parallel processing unit for processing during a first pass where the workload is processed by a plurality of threads executing in parallel on separate input data included in the workload and wherein the parallel processing unit is configured to halt processing of the workload when a hardware trap is triggered by any thread in the plurality of threads. The method further includes the steps of detecting that a hardware trap has occurred during a first point in the processing of the workload and entering a re launch loop that comprises disabling processing of the workload to allow the graphical user interface to be updated by the parallel processing unit and re issuing the workload to the parallel processing unit for processing during one or more subsequent passes.

Another example embodiment of the disclosure sets forth a computer readable storage medium including a debugger configured to perform the steps of the method set forth above. Yet another example embodiment of the disclosure sets forth a system configured to perform interactive debugging on non preemptible graphics processing units.

One advantage of the disclosed approach is that a computer used for debugging purposes may use a single GPU for both hardware debugging and screen updates. Other advantages include the ability to debug non deterministic applications and the ability to debug programs for which no source code is available.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present disclosure. However it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements in a single subsystem such as joining the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip instead of existing as one or more discrete devices. Large embodiments may include two or more CPUs and two or more parallel processing systems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to as well as in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various operations related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and the second communication path interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have a dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs in parallel processing subsystem may output data to display device or each PPU in parallel processing subsystem may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a data structure not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . A pointer to each data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from one or more pushbuffers and then executes commands asynchronously relative to the operation of CPU . Execution priorities may be specified for each pushbuffer by an application program via the device driver to control scheduling of the different pushbuffers.

Referring back now to as well as each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI Express link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the command stream stored in the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed from a work distribution unit within a task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in the command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices of data to be processed as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule execution of the processing task. Processing tasks can also be received from the processing cluster array . Optionally the TMD can include a parameter that controls whether the TMD is added to the head or the tail for a list of processing tasks or list of pointers to the processing tasks thereby providing another level of control over priority.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of dynamic random access memory DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons of ordinary skill in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI Express connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Multiple processing tasks may be executed concurrently on the GPCs and a processing task may generate one or more child processing tasks during execution. The task work unit receives the tasks and dynamically schedules the processing tasks and child processing tasks for execution by the GPCs .

The work distribution unit includes a task table with slots that may each be occupied by the TMD for a task that is being executed. The task management unit may schedule tasks for execution when there is a free slot in the task table . When there is not a free slot a higher priority task that does not occupy a slot may evict a lower priority task that does occupy a slot. When a task is evicted the task is stopped and if execution of the task is not complete then a pointer to the task is added to a list of task pointers to be scheduled so that execution of the task will resume at a later time. When a child processing task is generated during execution of a task a pointer to the child task is added to the list of task pointers to be scheduled. A child task may be generated by a TMD executing in the processing cluster array .

Unlike a task that is received by the task work unit from the front end child tasks are received from the processing cluster array . Child tasks are not inserted into pushbuffers or transmitted to the front end. The CPU is not notified when a child task is generated or data for the child task is stored in memory. Another difference between the tasks that are provided through pushbuffers and child tasks is that the tasks provided through the pushbuffers are defined by the application program whereas the child tasks are dynamically generated during execution of the tasks.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment each GPC includes a number M of SMs where M 1 each SM configured to process one or more thread groups. Also each SM advantageously includes an identical set of functional execution units e.g. execution units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SM . A thread group may include fewer threads than the number of processing engines within the SM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SM in which case processing will take place over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SM and m is the number of thread groups simultaneously active within the SM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SM contains a level one L1 cache shown in or uses space in a corresponding L1 cache outside of the SM that is used to perform load and store operations. Each SM also has access to level two L2 caches that are shared among all GPCs and may be used to transfer data between threads. Finally SMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally a level one point five L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SM including instructions uniform data and constant data and provide the requested data to SM . Embodiments having multiple SMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units . The cache line index may be used to determine whether or not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SM and is fetched from an L2 cache that is shared between all GPCs parallel processing memory or system memory as needed. Each SM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SMs or texture units preROPs may be included within a GPC . Further as shown in a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches to execute tasks for one or more application programs.

Persons of ordinary skill in the art will understand that the architecture described in A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during the thread s execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each thread s position. In one embodiment special registers include one register per thread or per exec unit within SM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all threads that execute the same processing task represented by a TMD or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs or queue position if the TMD encodes a queue task instead of a grid task and an identifier of the TMD to which the CTA is assigned.

If the TMD is a grid TMD execution of the TMD causes a fixed number of CTAs to be launched and executed to process the fixed amount of data stored in the queue . The number of CTAs is specified as the product of the grid width height and depth. The fixed amount of data may be stored in the TMD or the TMD may store a pointer to the data that will be processed by the CTAs. The TMD also stores a starting address of the program that is executed by the CTAs.

If the TMD is a queue TMD then a queue feature of the TMD is used meaning that the amount of data to be processed is not necessarily fixed. Queue entries store data for processing by the CTAs assigned to the TMD . The queue entries may also represent a child task that is generated by another TMD during execution of a thread thereby providing nested parallelism. Typically execution of the thread or CTA that includes the thread is suspended until execution of the child task completes. The queue may be stored in the TMD or separately from the TMD in which case the TMD stores a queue pointer to the queue. Advantageously data generated by the child task may be written to the queue while the TMD representing the child task is executing. The queue may be implemented as a circular queue so that the total amount of data is not limited to the size of the queue.

CTAs that belong to a grid have implicit grid width height and depth parameters indicating the position of the respective CTA within the grid. Special registers are written during initialization in response to commands received via front end from device driver and do not change during execution of a processing task. The front end schedules each processing task for execution. Each CTA is associated with a specific TMD for concurrent execution of one or more tasks. Additionally a single GPC may execute multiple tasks concurrently.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any thread within the same CTA or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SM to begin execution of a task that uses these parameters. Any thread within any CTA or any exec unit within SM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the thread to which the register is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers. Additionally a uniform L1 cache stores uniform or constant values for each lane of the N exec units and P load store units LSU .

Shared memory is accessible to threads within a single CTA in other words any location in shared memory is accessible to any thread within the same CTA or to any processing engine within SM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CIA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and task ID as well as CTA and grid dimensions or queue position implementing portions of the special registers. Each LSU in SM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 cache in each SM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to the shared memory and the L1 cache via a memory and cache interconnect .

The task management unit manages compute tasks to be scheduled as an array of TMD groups that are stored in the scheduler table . A TMD group is a set of compute tasks with the same scheduling priority. The number of TMD groups or priority levels may be one or more. Within each TMD group the compute tasks at the respective priority level are stored in a list which can be implemented with a linked list and hereinafter a linked list is assumed. Each entry in a linked list stores a task pointer to a TMD in memory and a pointer to the next entry in the respective linked list. A head pointer and a tail pointer for the linked list are stored for each TMD group. A TMD group having no tasks has a head pointer that equals the tail pointer and an empty bit is set TRUE.

When compute tasks are received from the host interface the task management unit inserts the compute tasks into a TMD group. More specifically a task pointer to the TMD corresponding to the compute task is added to the tail of the linked list for that group unless a special TMD bit is set which causes the task to be added to the head of the linked list. Even though all tasks within a TMD group have the same scheduling priority level the head of the TMD group linked list is the first compute task that is selected by the task management unit and scheduled for execution. Thus the compute task at the head of the linked list has a relatively higher priority compared with other compute tasks at the same priority level. Similarly each successive compute task in the linked list at the same priority level as a lower priority relative to preceding compute tasks in the linked list. Therefore the task management unit is able to schedule the compute tasks within a TMD group in input order relative to one another assuming none are specially marked to add to the head of the TMD group . Since the TMD group is specified as part of the TMD structure the TMD group of a compute task cannot be changed while the compute task is being executed. Compute tasks can also be received from the processing cluster array .

The collection of compute tasks into groups based on priority levels prior to scheduling the compute tasks allows for a decoupling of the rate at which compute tasks are received by the task management unit from the rate at which compute tasks are output to the work distribution unit for execution. The task management unit is generally able to accept compute tasks from one or more push buffers output by the host interface at a faster rate than the compute tasks may be output for execution by the work distribution unit . The input from the different push buffers are independent streams typically generated by the same application program in order to have multiple sets of dependent tasks but in some embodiments multiple application programs can write to the pushbuffers. The task management unit may be configured to buffer the compute tasks in the scheduler table and later select one or more compute tasks from the scheduler table for output to the work distribution unit . By selecting the compute tasks after they are buffered the task management unit may make the selection based on more information compared with selecting a compute task as compute tasks are received. For example the task management unit may buffer several low priority tasks that are received before a high priority task. The buffering enables the task management unit to select the high priority task for output before the low priority tasks.

The task management unit may perform selection to schedule the compute tasks using several different techniques round robin priority or partitioned priority scheduling. For each of the different scheduling techniques when a compute task is selected to be scheduled the selected compute task is removed from the TMD group in which the selected compute task is stored. Regardless of the scheduling technique the task management unit is able to quickly select a compute task by selecting the first entry in the linked list of the appropriate group. The task management unit may easily organize and if needed reorder the compute tasks by simply changing the ordering of the task pointers in the linked lists of the TMD groups. Therefore the compute tasks may be scheduled and or executed in an order that is different than the order in which the task pointers are received by the task management unit from the host interface .

The simplest scheduling scheme is for the task management unit to schedule the compute task at the head of each group if a compute task exists in the group and rotate through the groups in round robin order. Another scheduling technique is priority scheduling that selects the compute tasks in strict priority order. The task management unit selects a compute task from the highest priority TMD group that has at least one compute task starting at the head of the group.

In one embodiment debugger selects application program and or shader code that a programmer wants to debug based on user input. Typically performing a hardware debug on a target platform i.e. PPU requires a remote hardware platform that is separate and distinct from the debugging system. For example PPU is typically configured to perform graphics operations transmitted by an operating system and or one or more other applications running on CPU in computer system as well as render and display a screen image on display device . Hardware debugging typically utilizes stop events such as breakpoints set in the source code for application program and or shader programs that allows the programmer to execute code up to a particular instruction so that the programmer may examine intermediate values stored in memory to ensure proper operation of the programs. Other stop events may be caused by failed software assertions or illegal instructions that cause an exception. Attempting to debug the shader programs using PPU may cause PPU to halt execution of all incoming operations from the application program as well as any other operations transmitted by for example the operating system or the one or more other applications . Halting all graphics operations may prevent any additional updates to a frame buffer stored in PP memory and used to update the image shown on the screen on display device thereby killing screen refresh. Killing the screen refresh capability of PPU prevents the programmer from examining any of the intermediate data on display device or even sending a resume command to continue executing the program if the resume command is tied to a graphical user interface of the debugger .

A conventional solution to this problem was to connect the debugger to a second PPU to be used as the target platform for hardware debugging while continuing to update display device via a first PPU . The second PPU could be connected to the computer system directly through communications path in a shared bus configuration or a second similar communications path. Alternately the second PPU could be connected to the computer system indirectly via network adapter and accessed over a network.

The limitations of such conventional debugging systems are obvious. The required additional hardware increases the debugging platform cost as each debugging platform requires at a minimum two CPUs. In addition managing multiple channels for graphics commands between two different graphics platforms increases the complexity of the system. Consequently a better solution would be to utilize a single PPU for both screen refresh and debugging which enables virtually any computer with a graphics card to perform hardware debugging operations.

In contrast to conventional debugging systems illustrates a debugging system in which PPU is a single non preemptible GPU that may be used for both screen updates and hardware debugging. In one embodiment PPU may be context switched between applications. Typically once a workload is launched on the PPU the workload may need to be completed or flushed before PPU may be switched to a different context. In normal operation operating system or the other applications may send graphics commands to the device driver which compiles those commands into machine instructions and transmits the machine instructions to the PPU for execution. However during debugging the machine instructions transmitted to the PPU via program application may result in the PPU being halted due to the occurrence of a hardware trap such as a breakpoint or an exception which could prevent any further graphics commands from being executed by the PPU . Thus PPU must inform the debugger that a hardware trap has occurred through device driver and then the debugger may handle the hardware trap by performing any operations necessary to save thread state and memory values of currently executing threads kill i.e. terminate the execution of any currently stalled threads as well as any dependent child threads and enable additional graphics commands transmitted by the operating system and the other applications to be executed by PPU . Consequently debugger enables PPU to continue updating the screen image displayed on display device .

Typically a workload is executed by PPU in a relatively short time period. For example workloads may consist of a graphics draw call that renders a frame to be displayed on the screen. Because the frame rate of an application will typically be in the range of 30 frames per second the graphics draw call will typically execute in less than 30 milliseconds. Similarly compute workloads such as physics computations will also be executed in similar timeframes. Thus even though submitting a workload for debugging purposes may prevent screen updates for a short time the PPU will typically finish executing the workload or the debugger will interrupt the workload save thread state and kill the threads associated with the workload in a fast enough time such that the PPU can be made available to process graphics workloads necessary for performing screen updates.

In one embodiment a programmer may select an application program containing shader programs to debug using PPU . The source code for the application program may be written in C or C or some other high level programming language that when compiled into a binary executable such as application program may be executed by CPU . The source code may include graphics commands structured as API calls to a graphics API such as OpenGL or DirectX that is implemented by the device driver . The source code may also incorporate API calls for loading certain shader programs i.e. graphics programs configured specifically to be executed by a GPU on PPU for processing workloads created by the application program . The source code for the shader programs may be written in a high level shader language such as Cg or the OpenGL Shading Language GLSL . The shader programs are binary executables that are configured to run on each of the SMs of PPU . Debugger is configured to enable a programmer to debug one or more shader programs on the hardware platform of PPU .

In another embodiment debugger may be configured to enable a programmer to debug shader programs directly on PPU without executing application program on CPU . For example debugger may be configured to issue API calls to device driver that load a shader program directly onto PPU . Once the shader program is loaded onto PPU the debugger may be configured to create a test workload for processing by the shader program selected to be debugged. It will be appreciated that workloads may need to be predefined by a programmer to provide a known input to the shader program in order to evaluate whether the shader program produces a correct output. Typically early stages of debugging may consist of low level evaluation of each shader program whereas late stages of debugging may incorporate the interaction of the main application program executed by CPU with the shader programs executed on PPU .

Upon executing the application program using the debugger the debugger may intercept workloads generated by application program and transmitted to PPU for execution. In one embodiment the application program executes on CPU and may be configured to create workloads for PPU such as for example by generating TMDs in PP memory and issuing a Kernel launch command to device driver that specifies one or more TMDs . In one embodiment debugger is configured to intercept the creation of workloads by CPU generate lists to track the threads launched to process the workloads issue new workloads generated by the debugger and flush workloads transmitted to PPU to ensure that the additional workloads submitted by other applications will be processed.

In one embodiment when debugger intercepts a workload transmitted to PPU via device driver the debugger generates and maintains lists of threads associated with the workload. A first list tracks logically complete threads that stores thread identifiers ThreadID x for each thread associated with the workload that has completed execution. A second list tracks in progress threads that stores thread identifiers for each thread associated with the workload that is currently executing. A third list tracks not yet launched threads that stores thread identifiers for each thread associated with the workload that has yet to begin execution. Initially the third list may be populated with the thread identifiers for each thread that is scheduled to be launched to process the intercepted workload while the first list and the second list are empty. Once the debugger has generated the lists the debugger issues the workload to the device driver to be executed by PPU and enters a re launch loop.

The re launch loop is an iterative loop for emulating hardware debugging that makes it appear that PPU is stepping through a shader program by a small portion of instructions at a time while in actuality each step of the program is accomplished by re issuing the original workload on the PPU and halting execution at different points in the process based on where breakpoints are encountered. Processing the workload is performed by restoring the state of all in progress threads that were saved during the previous pass so that already completed threads and portions of threads in progress are not re executed. Instead any thread that had already completed will be terminated when the PPU attempts to re launch the thread and any thread that was being executed during the previous pass will be restored to the point in the thread at which execution was halted.

In one embodiment the workload may be associated with a TMD created in PP memory that specifies a plurality of threads to execute for the workload. For example the TMD may include pointers to a grid i.e. a collection of CTAs in up to three dimensions. The grid may include an x dimension of size 10 CTAs a y dimension of size 10 CTAs and a z dimension of size 5 CTAs for a total of 500 CTAs included in a workload. As a workload is executed CTAs from the grid may be issued to one or more SMs of PPU . Each thread in a CTA is an instance of a particular shader program specified by the application program . In some embodiments PPU may implement a feature that allows debugger to specify a start index for each of the dimensions of a CTA grid. Thus if debugger has determined that the CTAs in the first 4 slots in the x dimension have already finished executing during a previous execution cycle i.e. pass then debugger may specify that PPU should begin execution at the 5CTA in the x dimension.

As shown in as the PPU executes the workload threads are scheduled on an SM for execution. As threads are run by a particular SM some threads may complete execution. Debugger is configured to track which threads as specified by thread ID have been scheduled for execution on PPU and moves these thread IDs from the third list i.e. not yet launched to the second list i.e. in progress . As threads complete execution debugger moves the thread IDs from the second list to the first list i.e. logically complete . It will be appreciated that in alternative embodiments debugger may track threads in other technically feasible ways such as tracking threads with a single list and associating the thread IDs in the single list with a marker indicating the status of that particular thread e.g. not yet launched in progress or logically complete . For example debugger may assume by default that all threads have an inherent status of not yet launched . As PPU launches threads on SMs during processing of a workload debugger may add the corresponding thread IDs for the launched threads to an array i.e. a list . As threads complete execution the thread IDs may be associated with a marker that indicates that the thread associated with that thread ID is logically complete . Thus all threads included in the array are in progress unless associated with the marker that indicates that they are logically complete . If a thread ID for a particular thread is not included in the array then debugger assumes that the thread corresponding to that thread ID was not yet launched . In yet other embodiments debugger may utilize two separate arrays i.e. lists one list to indicate that a thread is in progress and another list to indicate that the thread is logically complete . When a thread finishes execution debugger may remove the thread ID from the first array and add the thread ID to the second array. Thus a thread will be considered in progress if the thread ID is included in the first array logically complete if the thread ID is included in the second array and not yet launched if the thread ID is not included in either the first or second array.

At some point PPU may encounter a hardware trap that halts execution of all threads running on the SMs . At this point PPU notifies device driver that PPU has halted execution and is stalled due to the occurrence of the hardware trap. In one embodiment device driver in turn notifies debugger of the hardware stop event. In another embodiment debugger may poll device driver or PPU to determine whether a hardware trap has occurred. When debugger is notified of the hardware stop event debugger saves the thread state for each thread included in the second list . In other words for any threads currently in progress debugger saves any thread state information necessary to restore these threads to the current point of execution. For example debugger may save values stored in special registers per thread local memory and shared global memory to system memory . Then debugger may change the global state of PPU to kill i.e. terminate any newly created threads as well as any threads that are currently executing. For example debugger may set a special register that causes PPU to kill any active threads when execution resumes. Debugger then resumes execution of PPU which kills off all threads associated with the current workload such that PPU can begin processing new workloads. The new workloads may include graphics commands transmitted to PPU by the operating system or the other applications that cause the image on display device to be updated.

Once the PPU has been returned to normal operation by the debugger the GUI for debugger may be updated such that the programmer can inspect any of the saved processing state or variable data associated with the stalled shader program . The debugger then waits for a resume command to be issued by the programmer. For example the programmer may set a new breakpoint and select a button to resume execution of the shader program . When the debugger receives the resume command the debugger re issues the previous workload to the PPU . The workload will be restored to the point of execution where the previous hardware trap occurred and allowed to execute until the next stop event caused by a hardware trap such as reaching a new breakpoint set by the programmer or failing a software assertion in the shader program . Once again the debugger will save the processor state flush memory from PP memory kill any active threads associated with the workload and return PPU to normal operation. By looping through this re launch process debugger may iteratively enable a programmer to step through a shader program for debugging purposes while preventing the hardware stop events from causing display device to stop being updated.

In one embodiment debugger causes PPU to execute a thread entry routine prior to running any instructions for a particular thread. The thread entry routine is a set of instructions that determine whether a thread should be executed based on the lists e.g. 512 514 516 maintained by debugger . For example when a thread is launched the thread entry routine checks whether that thread is included in the first list i.e. logically complete as having already been completely executed. If the thread ID is included in the first list then the thread entry routine kills the thread such that the SM may execute another thread instead. In other words that particular thread specified by the workload was already executed during a previous re launch loop and the output of that thread has been incorporated into the stored frame buffer or processor state. Therefore that thread does not need to be executed during the current re launch pass. However if the thread ID is not included in the first list then the thread entry routine determines whether the thread ID is included in the second list i.e. in progress thereby requiring some amount of state or memory stored during the previous re launch pass to be restored on PPU or in PP memory . If the thread ID is included in the second list then the thread entry routine restores the thread state for that thread and allows the thread to continue executing from the point where the thread was killed during the last re launch pass. If the thread ID is not included in either the first list or the second list then the thread should be included in the third list i.e. not yet launched and the thread entry routine will launch execution of that thread on one of the SMs of PPU .

In other embodiments some resources of PPU may not be re storable. For example some hardware registers may be read only e.g. hardware thread ID or other state may be stored in special registers and therefore debugger may not be able to restore these state variables during subsequent passes of the workload on PPU . For example PPU may not enable debugger to specify on which particular SM of PPU a particular thread is launched. Because some shader programs may include instructions that use these special registers as input for calculating some intermediate address or data these shader programs may not function correctly if on a subsequent pass thread state corresponding to one SM is restored to a thread that is now executing on a different SM . One solution to this problem is to virtualize these resources using thread local memory in PP memory and to then change the instructions in the threads to use these virtual locations for any calculations rather than the special read only registers or other non restorable resources. Another possible solution to this problem would be to limit parallelism of the PPU such that threads may only execute on a single SM of PPU thereby ensuring that the indexes stored by these registers are always the same because the threads will always be launched at the same hardware location. However this solution has the drawback that CTA execution is serialized thereby hiding any errors caused by the parallel nature of the shader execution such as race conditions and other synchronization issues.

In some embodiments PPU may include a feature that allows a programmer to set a timeout limit that automatically interrupts any program i.e. workload being executed by the PPU if the workload has not been fully processed by the expiration of the timeout limit. This interruption constitutes the completion of a re launch pass. In other words the timeout limit prevents the PPU from crashing in the event of a software bug in the shader program that causes PPU to hang. One advantage of the currently disclosed technique over conventional debugging techniques is that conventional techniques typically required the timeout protection of a PPU to be disabled because while the hardware is halted the operating system considers the workload to be active. The time the user spends inspecting state while at a breakpoint counts against the timeout limit. In the disclosed technique however timeout protection doesn t need to be disabled but may remain enabled during each pass of the workload although the timeout limit may need to be increased to encompass delays caused by the hardware trap and state saving functions performed by the CPU before resume while allowing the user to inspect state in the debugger for an unbounded duration of time.

In some embodiments debugger may be configured to only allow in progress threads to be restored during subsequent re launch passes. In other words debugger may be configured to issue a workload to PPU and wait for a hardware trap to occur that stalls processing of the workload. At this point in the processing of a thread debugger has generated a list of threads that are in progress as well as a list of threads that are logically complete . In these embodiments during subsequent passes debugger may be configured to kill any thread that PPU attempts to launch that is associated with a thread ID in either the logically complete state or the not yet launched state. This configuration may prevent not yet launched threads from being launched prior to threads that were previously in progress which if not prevented could cause a subsequent hardware trap to occur in a completely unrelated section of code diverting the programmer s attention from the location in the code that caused the previous hardware trap. Thus the size of the in progress list cannot grow unbounded during each subsequent pass. A disadvantage to this technique however is that deadlocks may occur where the in progress thread is stalled waiting for a related thread to execute when the related thread is not yet launched .

Method begins at step where debugger receives application program and shader programs to debug using a non preemptible GPU such as PPU . The PPU may be the only graphics processor included in the debugging platform and may be used for both debugging purposes as well as screen updates. In one embodiment application program is written in a high level programming language such as C while shader programs are written in a high level shading language such as Cg. At step the debugger intercepts a command generated by the application program to transmit a workload to the PPU . The debugger generates a list to track the threads associated with the workload. At step debugger issues the workload to the PPU which causes at least one shader program to be loaded onto PPU to process the workload. In one embodiment debugger may be able to load a shader program directly onto PPU and issue a pre defined workload directly to shader program without executing the source program on CPU .

At step debugger determines whether a hardware trap has occurred. In one embodiment device driver is informed whenever a hardware trap has occurred by PPU and is configured to notify debugger when the hardware trap has occurred. In another embodiment debugger polls device driver to determine the state of PPU . If debugger determines that a hardware trap has not occurred then method proceeds to step where debugger determines whether the workload has finished processing. At step if the workload has finished processing then method terminates. However if the workload is still being processed then method returns to step where debugger waits until a hardware trap occurs and then method proceeds to step . At step debugger saves thread state and variable data associated with any active threads processing the workload. In one embodiment debugger copies register values from PPU as well as copying per thread local memory from PP memory to system memory . Debugger may also copy shared memory from PP memory to system memory . At step debugger updates the processor state of PPU such that when PPU resumes operation all currently active threads and newly created threads associated with the current workload will be killed. Then debugger causes PPU to resume operation which eventually results in all threads generated by the workload to be killed and frees PPU to process additional workloads.

At step debugger determines whether the programmer wishes to resume debugging the shader program using the current workload. For example the GUI for debugger may include a step command that indicates the shader program should execute the next instruction or the GUI for debugger may include a resume command that indicates that the shader program should continue execution until the next hardware stop event i.e. a breakpoint exception or a failed assertion etc. . If debugger determines that the programmer has not issued a command to resume execution then debugger waits allowing PPU to continue processing graphics workloads from other applications that result in updated images being displayed on display device . However if debugger determines that the programmer has issued a resume command then method proceeds to step where debugger re issues the workload to the PPU . In one embodiment debugger tracks the state of threads generated to process the workload. If a thread has already completed executing during a previous issuing of the workload then the thread may be killed and skipped or if they thread has not been issued then the thread may be executed from the beginning of the thread. However if the thread was previously partially executed i.e. in progress then the debugger may restore the thread state and execute the thread from a point corresponding to the previously interrupted point of the thread. Method returns to step and waits for either the workload to finish being processed or the next hardware trap.

In sum a parallel processing unit is configured to perform hardware debugging of shader programs while substantially simultaneously generating and updating images displayed on a display device that enable a GUI for a development environment to be viewed by a programmer. The iterative partial processing of a workload via the parallel processing unit allows the debugger to appear to stall the parallel processing unit between breakpoints while actually interrupting processing of the workload to enable graphics updates to be processed by the parallel processing unit. In other words a debugger saves processor state and memory to enable the parallel processing unit to switch contexts even though the hardware does not support context switching while execution of a workload is stalled due to a hardware trap.

While the foregoing is directed to embodiments of the invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the invention.

The disclosure has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the disclosure as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

