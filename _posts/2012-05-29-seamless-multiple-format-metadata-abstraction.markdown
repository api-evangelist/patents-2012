---

title: Seamless multiple format metadata abstraction
abstract: For seamlessly abstracting metadata in multiple formats, an abstraction module converts first metadata of an incoming object and additional metadata for the incoming object from an annotation map contained by the first metadata into a common format useable. The additional metadata is not part of an original format of the first metadata. A communication module communicates the converted metadata to an adapter in the common format, the adapter processing the first metadata and the additional metadata independent of the original format of the first metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08635634&OS=08635634&RS=08635634
owner: International Business Machines Corporation
number: 08635634
owner_city: Armonk
owner_country: US
publication_date: 20120529
---
This is a continuation application of and claims priority to U.S. patent application Ser. No. 11 777 744 entitled APPARATUS SYSTEM AND METHOD FOR SEAMLESS MULTIPLE FORMAT METADATA ABSTRACTION and filed on Jul. 13 2007 for Madhavi Katari which is incorporated herein by reference.

This invention relates to adapters for use with an enterprise information system EIS and more particularly relates to abstracting metadata of various different formats into a common format for use by an EIS.

Adapters allow business events to flow from an enterprise information system EIS to a listening client such as a business process or other application. The Java 2 Enterprise Edition J2EE standard defines a standard approach to building these adapters as outlined in the J2EE connector architecture JCA specification.

Advanced implementations of adapters are metadata driven This implies that the adapter is not hard coded for each object type in the system but rather has a form of discovery in which a representation of the object metadata in the EIS is constructed at build time such that at runtime the adapter uses this metadata along with the object data to process the object. In most implementations metadata is in a pre existing format such as a standardized EIS schema. Standardized metadata includes such information as property name property type maximum length cardinality and anything else that can be described in a standard schema. Metadata may also be in a format defined by the adapter. This form of metadata is called Application Specific Information or ASI.

ASI can typically occur in three forms object level metadata operation level metadata and property level metadata. Object level metadata includes the information about what type is being processed. Operation level metadata is context specific object metadata that is valid for the operation being processed at the present time. Property level metadata is information about a particular property in an EIS schema such as a column name as it occurs in the EIS which may be different than the property name in the object. Generally this ASI data is structured such that it may be described as a Map table or Map of Maps tree .

Conventional adapters may also have the capability to handle data in multiple end formats depending on the runtime system they are running in. This is accomplished via a Data Exchange API. In some embodiments the Data Exchange API allows the adapter to interact with data such as by reading or writing a particular value through a set of interfaces known as a Data Exchange Service Provider Interface DESPI . These interfaces are implemented by the runtime in which the adapter is running in order to allow the adapter to deal with the runtime s data format instead of the runtime having to convert the adapter s data format to its own. For instance if a J2EE application deals with data in the JavaBean format a Data Exchange implementation for JavaBean will read and write to the bean on behalf of the adapter. The same is true for other data formats such as Service Data Objects SDO . In effect the DESPI makes the incoming data format received by the adapter pluggable .

However even though conventional technologies such as a DESPI allow the handling of multiple data formats such technologies do not address how to plug in multiple different formats for metadata. For example an adapter is typically concerned with certain metadata information or ASI such as type information facets such as maximum length cardinality of children and annotations. In conventional systems ASI is used to drive the adapter which means that the specific adapter code is embedded with and depends on the ASI. Therefore in order to support more than one metadata format it is critical to provide an abstraction of pertinent metadata information from incoming objects into a form compatible with the adapter code. Thus by providing an interface for abstracting pertinent metadata from a variety of different metadata formats it becomes possible to overcome some or all of the current needs in the art.

An apparatus for seamlessly abstracting metadata in multiple formats is disclosed. An abstraction module converts first metadata of an incoming object and additional metadata for the incoming object from an annotation map contained by the first metadata into a common format useable. The additional metadata is not part of an original format of the first metadata. A communication module communicates the converted metadata to an adapter in the common format the adapter processing the first metadata and the additional metadata independent of the original format of the first metadata. Methods and a computer program product that perform the functions of the apparatus are also disclosed.

Many of the functional units described in this specification have been labeled as modules in order to more particularly emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like.

Modules may also be implemented in software for execution by various types of processors. An identified module of executable code may for instance comprise one or more physical or logical blocks of computer instructions which may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose for the module.

Indeed a module of executable code may be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices and may exist at least partially merely as electronic signals on a system or network.

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus appearances of the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment.

Reference to a signal bearing medium may take any form capable of generating a signal causing a signal to be generated or causing execution of a program of machine readable instructions on a digital processing apparatus. A signal bearing medium may be embodied by a computer readable storage medium and or a transmission medium. The transmission medium may be embodied by a transmission line. The computer readable storage medium may be embodied in a compact disk a digital video disk a magnetic tape a Bernoulli drive a magnetic disk a punch card flash memory integrated circuits and or other digital processing apparatus memory device.

Furthermore the described features structures or characteristics of the invention may be combined in any suitable manner in one or more embodiments. In the following description numerous specific details are provided such as examples of programming software modules user selections network transactions database queries database structures hardware modules hardware circuits hardware chips etc. to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention may be practiced without one or more of the specific details or with other methods components materials and so forth. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

The schematic flow chart diagrams that follow are generally set forth as logical flow chart diagrams. As such the depicted order and labeled steps are indicative of one embodiment of the presented method. Other steps and methods may be conceived that are equivalent in function logic or effect to one or more steps or portions thereof of the illustrated method. Additionally the format and symbols employed are provided to explain the logical steps of the method and are understood not to limit the scope of the method. Although various arrow types and line types may be employed in the flow chart diagrams they are understood not to limit the scope of the corresponding method. Indeed some arrows or other connectors may be used to indicate only the logical flow of the method. For instance an arrow may indicate a waiting or monitoring period of unspecified duration between enumerated steps of the depicted method. Additionally the order in which a particular method occurs may or may not strictly adhere to the order of the corresponding steps shown.

The EIS is generally any kind of computing system that is of enterprise class which typically means a system with high quality of service that is capable of dealing with large volumes of data and capable of supporting some large organization or enterprise. EISs are particularly useful in eliminating the problem of information fragmentation caused by multiple information systems in an organization by creating a standard data structure. In one embodiment the EIS provides a technology platform that enables an organization to integrate and coordinate its business processes. Preferably the EIS is a single system that is central to an organization to ensure that information can be shared across all functional levels and management hierarchies however other configurations are possible as well as will be recognized by one of skill in the art.

In one embodiment the EIS may be housed in one or more data centers and typically runs enterprise software which may include applications such as content management systems. Preferably the enterprise software is application software that performs common business functions such as accounting production scheduling customer information management bank account maintenance etc. The enterprise software in one embodiment is hosted on one or more servers and simultaneously provides service to a large number of users typically over a computer network.

The EIS is in electronic communication with the adapter . The adapter is provided between the EIS and other system components such as client in order to provide a standard system level pluggability between the EIS and the client . The adapter is preferably a system level software driver used by the client to connect to the EIS in order to obtain the proper underlying mechanisms transactions security and connection pooling mechanisms necessary to provide seamless communication with the EIS . The Java 2 Enterprise Edition J2EE provided by Sun Microsystems of Santa Clara Calif. defines a standard approach to building the adapter as outlined in the J2EE Connector Architecture JCA specification. In one embodiment the adapter is based on the JCA architecture and is a WebSphere adapter available from IBM of Armonk N.Y.

The adapter is in electronic communication with at least one client . The client may be any type of device or application that accesses the EIS . Examples of the client include an application server an application client a personal computer a PDA a laptop or some other networking device or application.

The specific adapter code is the code that defines the functionality of the adapter . In one embodiment the specific adapter code is configured to drive the adapter based on the metadata of incoming data objects. In particular the specific adapter code drives the adapter based on application specific information ASI such as type information facets such as maximum length cardinality of children and annotations. For example ASI in business object definitions provides the adapter with application dependent instructions on how to process that particular business object. In one embodiment the adapter parses the ASI from the attributes or verb of a business object or from the business object itself to generate queries for create update retrieve and delete operations.

Because the specific adapter code relies on the ASI to drive the adapter the specific adapter code may include numerous references to the ASI throughout the code. Therefore in order to plugably handle multiple metadata formats the ASI must be provided in a standard format compatible with the specific adapter code . The Metadata API discussed below abstracts metadata ASI received in non standard format into the standard format as defined by the specific adapter code such that metadata from two or more different data formats may be utilized without substantially changing the specific adapter code .

The Data Exchange API is a set of interfaces that allows data structured under a source schema to be transformed into a target schema so that the resulting target data is an accurate representation of the original source data. In one embodiment the Data Exchange API provides the functionality for the adapter to plugably handle a variety of different data object formats. For example if a J2EE application utilizes data in the JavaBean format a Data Exchange implementation for JavaBean will read and write to the bean on behalf of the adapter. The same is true for other data formats such as SDO. In this manner the incoming data formats are essentially pluggable with the adapter . A Data Exchange API that provides plugability is typically referred as a Data Exchange Smart Plug in DESPI . Therefore the Data Exchange API allows the plugability of different data formats whereas the Metadata API allows the plugability of different metadata formats.

In one embodiment a cache is provided with the adapter . The cache is provided to store and quickly retrieve metadata information. The lookup and reading of metadata in some data formats such as SDO can be very expensive. Therefore the cache is provided to allow the caching of metadata of any incoming format in a generic manner for quick retrieval and use by the adapter . In this manner the expensive cost associated with the repeated lookup of commonly used metadata information can be avoided.

In one embodiment the Metadata API is configured to abstract and provide metadata information related to a business object to the adapter for processing. In a further embodiment the Metadata API is configured to operate on two or more different metadata formats such as JavaBean and SDO such that the adapter seamlessly processes the metadata in accordance with the specific adapter code . In one embodiment the Metadata API is preferably implemented by the runtime where the adapter is running such that the Metadata API and its associated modules operate with seamless pluggabililty.

In one embodiment the abstraction module is configured to abstract pertinent metadata information related to an incoming business object. As used in accordance with this invention to abstract means to obtain particular and relevant metadata information such as ASI related to an incoming object regardless of the format of the incoming metadata and such that the metadata information can be provided to the adapter in a common format.

For example in one embodiment the abstraction module is configured to register and instantiate a type class and a property class for two or more different metadata formats such that the type class is configured to convert type metadata from the original metadata format to a common metadata format and the property class is configured to convert property metadata from the original metadata format to a common metadata format. Thus if metadata related to an incoming business object is received in a format such as SDO or JavaBean the abstraction module may utilize the type class and property class to convert the incoming metadata to the common format defined by the adapter so that the adapter is insulated from the original metadata format.

In one embodiment a type module may be provided to provide a type interface for seamlessly retrieving object level metadata in a common format regardless of the original format of the metadata. The type module provides access to object level metadata such as type name property iterations property lists property objects annotations operation specific object metadata key properties etc. A property module may also be provided to provide a property interface for seamlessly retrieving property level metadata in a common format regardless of the original format of the metadata. Property level metadata may include information such as property containing type default property value property name property class property containment whether or not the property contains a particular type max length of the property annotations for the property property key information whether or not the property is a key etc. In this manner the Metadata API allows the adapter to utilize the type interface and property interface to obtain metadata information within adapter runtime environment and without regard to the original format of the metadata.

The implementation of different metadata formats within the Metadata API may require some format specific interfacing. For example if SDO is used the Metadata API will simply pass through type and property calls to the type and property interfaces described above. However if JavaBean is used then some metadata such as containedType and maxLength which are not normal parts of the JavaBean structure may be implemented as part of an annotation map. Annotations are not normally part of a Java Bean structure but JavaBeans may be configured to contain annotations in a specific format that is usable by the Metadata API . Furthermore JavaBean APIs typically cannot detect the order of properties present in a class file. Thus in one embodiment the JavaBean may be configured to include a string array called propertyOrder containing the names of all properties in the desired order. In this manner a format such as JavaBean becomes pluggable with the Metadata API .

The communication module is configured to communicate abstracted metadata to the adapter in a common format such that the adapter processes the abstracted metadata information without regard to an original format of the metadata. Thus the communication module in one embodiment provides the communication link between the Metadata API and the adapter .

The cache module is configured to store and retrieve abstracted metadata for a particular business object type in a cache . As previously discussed the lookup and reading of metadata for some formats like SDO can be very expensive. Thus the cache module provides a metadata cache implementation which allows for the caching of metadata in any format to be stored in a generic manner. By caching incoming metadata the Metadata API can avoid the cost of repeatedly looking up metadata information. Instead once the lookup of metadata is completed for a particular business object type the information is stored in the cache for quick access at a later time. Then when the same business object type metadata is needed again the Metadata API can access the cache rather than looking up the metadata a second time.

In one embodiment the cache may be limited by a predefined size limit. At adapter runtime it is often very likely that there will be frequent requests events involving certain business object types while there are other business object types that will be rarely invoked. For example a business type Order within an EIS system may be the type on which multiple transactions run every day whereas the Product type may be an object type which is invoked only occasionally. Therefore when the size of the cache reaches the predefined size limit the cache module may utilize a Least Frequently Used LFU algorithm to discard the least frequently used business object type from the cache . For instance the cache or cache module may utilize a counter for counting the number of times each particular business object type has been referenced in the cache . Then when a new business object type that causes the cache to exceed the predefined size limit is processed the least used business object type found within the cache may be discarded. Thus the most commonly used business object types will remain available for quick access in the cache and the least commonly used business object types will be discarded.

In one embodiment each data format specific implementation of the Metadata API instantiates a hashmap instance and uses it to cache metadata using the type of business object as the key. This allows for improved performance because at runtime there may be multiple instances of a given type of business object existing and any calls to retrieve the metadata of these business objects will reuse the metadata objects from the cache .

Preferably the object level metadata cache is structured as a map of maps where each cache entry is a map containing the metadata entries for a given business object type. Similarly property level metadata is preferably structured as a map of maps where each cache entry in the cache is a map containing the metadata entries for a given property type.

The Metadata API registers and instantiates a type class and a property class for the incoming metadata format. The Metadata API is configured in at least one embodiment to operate on two or more different metadata formats. The type class is configured to convert type metadata from the original metadata format to a common metadata format and the property class is configured to do the same with regard to property metadata. Type and property interfaces may also be provided for accessing object level metadata and property level metadata respectively.

Next the abstraction module abstracts relevant metadata such as ASI into a common format from the incoming business object wherein the common format is usable by the adapter . The Metadata API communicates the abstracted metadata to the adapter in the common format so that processing of the incoming business object may occur based on the abstracted metadata and independent of the original format of the metadata.

Finally the abstracted metadata may be cached in a cache for later use by the Metadata API . The cache may utilize a Least Frequently Used algorithm to discard rarely used items and to make available the most commonly used items for quick access. The method ends.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

