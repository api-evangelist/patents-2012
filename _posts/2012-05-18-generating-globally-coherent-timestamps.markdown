---

title: Generating globally coherent timestamps
abstract: The present technology proposes techniques for generating globally coherent timestamps. This technology may allow distributed systems to causally order transactions without incurring various types of communication delays inherent in explicit synchronization. By globally deploying a number of time masters that are based on various types of time references, the time masters may serve as primary time references. Through an interactive interface, the techniques may track, calculate and record data relative to each time master thus providing the distributed systems with causal timestamps.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08938636&OS=08938636&RS=08938636
owner: Google Inc.
number: 08938636
owner_city: Mountain View
owner_country: US
publication_date: 20120518
---
In a distributed system many applications rely on event ordering to be successful. Event ordering can be made easier if systems can accurately timestamp events but clocks in a distributed system are not always synchronized. One way of obtaining synchronized timestamps is with a network time protocol NTP service. By using a NTP service clients may attempt to synchronize themselves by periodically querying a time master that may respond with a timestamp packet. The time queries and responses from the time master may allow a client to estimate its clock phase and frequency error and adjust clock rates accordingly.

Several forms of uncertainty may afflict such query based measurements. For example delays induced by scheduling network congestion interrupt coalescing routing asymmetry system overloads and other causes can prove to be as unpredictable as they are asymmetric. Moreover a typical NTP s notion of time synchronization may be fundamentally flawed because no master can be entirely trustworthy. Thus it may be prudent for clients not to make time adjustments based solely on a single master s response.

Aspects of this disclosure may be advantageous for generating globally synchronized timestamps without incurring various types of network delay inherent in explicit synchronization. The globally synchronized timestamps can be used by various services e.g. to validate local timestamps and clocks or to provide causality respecting timestamps for database updates. By introducing techniques to track calculate and record time data relative to a number of reliable time references an easy to manage and low cost time base may be provided for host machines in a distributed system.

One aspect of the disclosure provides a method that includes receiving an initial local timestamp receiving reference timestamps transmitted from a plurality of time references receiving a time of arrival local timestamp determining transmission delays associated with the time references and calculating using a processor time offset intervals corresponding to the time references. Each time offset interval includes a set of time offsets that represent differences between a given reference timestamp and the initial and time of arrival local timestamps. In this regard the set of time offsets compensate for the transmission delay associated with the corresponding time reference. The method also includes selecting at least one of the time offset intervals based on an occurrence of that time offset interval among the calculated time offset intervals. In one example the selected time offset interval has a highest occurrence among the calculated time offset intervals. In another example determining transmission delays includes estimating an amount of time associated with receiving reference timestamps from a given time reference. The method may also include determining a timing error in local timestamps generated based on a local clock by comparing the local timestamps to the reference timestamps and adjusting the local timestamps with the time offsets from the selected time offset interval. In one example adjusting the local timestamps includes waiting for a period of time to pass.

Another aspect of the disclosure provides a system that includes a memory a local clock a receiver module adapted to receive reference and time of arrival local timestamps from a plurality of time references and a processor coupled to the memory. The processor may be configured to receive an initial local timestamp based on the local clock register in memory reference timestamps received by the receiver module determine transmission delays associated with the time references and calculate time offset intervals corresponding to the time references. Each time offset interval includes a set of time offsets that represent differences between a given reference timestamp and the initial and time of arrival local timestamps. In this regard the set of time offsets compensates for the transmission delay associated with the corresponding time reference. The processor is also configured to select at least one of the time offset intervals based on an occurrence of that time offset interval among the calculated time offset intervals.

Yet another aspect of the disclosure provides a tangible computer readable storage medium that includes instructions that when executed by a processor cause the processor to perform a method. The method includes receiving an initial local timestamp receiving reference timestamps transmitted from a plurality of time references receiving a time of arrival local timestamp determining transmission delays associated with the time references and calculating using a processor time offset intervals corresponding to the time references. Each time offset interval includes a set of time offsets that represent differences between a given reference timestamp and the initial and time of arrival local timestamps. In this regard the set of time offsets compensates for the transmission delay associated with the corresponding time reference. The method also includes selecting at least one of the time offset intervals based on an occurrence of that time offset interval among the calculated time offset intervals.

Aspects features and advantages of this disclosure will be appreciated when considered with reference to the following description of embodiments and accompanying figures. It should be noted that the same reference numbers in different drawings may identify the same or similar elements. Furthermore the following description is not limiting the scope of the present technology is defined by the appended claims and equivalents.

In this disclosure systems and methods are provided for generating globally coherent timestamps. This technology may allow distributed systems to causally order transactions without incurring various types of communication delays inherent in explicit synchronization. By globally deploying a number of time masters that are based on various types of time references e.g. Global Positioning Systems GPS and atomic clocks the masters may serve as primary time references for the distributed systems. Techniques described herein may be used to request track calculate and record data relative to each time master. This data can be cross checked against a number of time masters in order to assess which time masters may be malfunctioning and which time masters may provide validated causal timestamps to clients.

A server may contain a processor memory and other components typically present in general purpose computers. The memory may store information accessible by the processor including instructions that may be executed by the processor . Memory may also include data that can be retrieved manipulated or stored by the processor . The memory may be a type of non transitory computer readable medium capable of storing information accessible by the processor such as a hard drive memory card ROM RAM DVD CD ROM write capable and read only memories. The processor may be a well known processor such as processors from Intel Corporation or Advanced Micro Devices. Alternatively the processor may be a dedicated controller such as an ASIC.

The instructions may be a set of instructions executed directly such as machine code or indirectly such as scripts by the processor . In this regard the terms instructions steps and programs may be used interchangeably herein. The instructions may be stored in object code format for direct processing by the processor or other types of computer language including scripts or collections of independent source code modules that are interpreted on demand or compiled in advance. Functions methods and routines of the instructions are explained in more detail below.

The data may be retrieved stored or modified by the processor in accordance with the instructions . For instance although the system and method is not limited by a particular data structure the data may be stored in computer registers in a relational database as a table having a plurality of different fields and records or XML documents. The data may also be formatted in a computer readable format such as but not limited to binary values ASCII or Unicode. Moreover the data may comprise information sufficient to identify relevant information such as numbers descriptive text proprietary codes pointers references to data stored in other memories including other network locations or information that is used by a function to calculate relevant data.

Although functionally illustrates the processor and memory as being within the same block it will be understood by those of ordinary skill in the art that the processor and memory may actually comprise multiple processors and memories that may or may not be stored within the same physical housing. For example some of the instructions and data may be stored on a removable CD ROM and others within a read only computer chip. Some or all of the instructions and data may be stored in a location physically remote from yet still accessible by the processor . Similarly the processor may actually comprise a collection of processors which may or may not operate in parallel.

As shown in servers and may also include a time master module . The time master module may be operable in conjunction with a receiver for receiving time signals. Time masters may serve as accurate time references in a distributed system for 1 synchronizing machines and devices and 2 validating and monitoring that synchronization. This may include serving a reference time to a core network of machines and their supporting infrastructure. For example an incoming time query from a client may receive a timestamp determined by the time master . The timestamps may be based on various types of systems known in the arts for providing an accurate and reliable time reference e.g. a GPS system .

According to aspects servers and may consist of middleware software that may manage and integrate the time master module with internal components of the servers and . In one aspect the middleware may consist of a set of services that allow multiple processes running from the time master module to interact with the processor memory instructions and data . In some aspects it may be neither desirable nor possible to run other types of NTP services on a host server in conjunction with a time master module . For example system conflicts can occur over ports assigned to the NTP service severely impacting a time master s reliability.

Servers and may be at a node of network and capable of directly and indirectly communicating with other nodes of the network . For example the servers and may comprise a web server that may be capable of communicating with client device via network such that it uses the network to transmit information to a client application. Servers and may also comprise a plurality of computers e.g. a load balanced server farm that exchange information with different nodes of a network for the purpose of receiving processing and transmitting data to client devices. In this instance the client computer will typically still be at different nodes of the network than the computers comprising servers and . Although only a few servers are depicted in it should be appreciated that a typical system can include a large number of connected servers with each being at a different node of the network .

Each client may be configured similarly to servers and with a processor memory instructions and data . Each client may be a personal computer intended for use by a person having all the internal components normally found in a personal computer such as a central processing unit CPU an optional display device for example a monitor having a screen a projector a touch screen a small LCD screen a television or another device such as an electrical device that can be operable to display information processed by the processor CD ROM hard drive user input for example a mouse keyboard touch screen or microphone speakers modem and or network interface device telephone cable or otherwise and all of the components used for connecting these elements to one another. Moreover computers in accordance with the systems and methods described herein may comprise devices capable of processing instructions and transmitting data to and from humans and other computers including general purpose computers PDAs network computers lacking local storage capability set top boxes for televisions and other networked devices.

Although the client may comprise a full sized personal computer the systems and methods of this disclosure may also be used in connection with mobile devices capable of wirelessly exchanging data over a network such as the Internet. By way of example only a client may be a wireless enabled PDA tablet PC or a cellular phone capable of sending information via the Internet. The user may input information for example using a small keyboard a keypad or a touch screen.

As shown in the client may include an application interface module . The application interface module may be used to access a service made available by a server such as servers and . The application interface module may be a software module operable in conjunction with several types of operating systems known in the arts. For example the client may be connected to a SQL Structured Query Language database server that may operate in conjunction with the application interface module for saving and retrieving information data. Memory coupled to a client may store data accessed by the application module . The data can also be stored on a removable medium such as a disk tape SD Card or CD ROM which can be connected to client .

Servers and and client may be capable of direct and indirect communication such as over network . For example using an Internet socket a client may connect to a service operating on remote servers and through an Internet protocol suite. Servers and may set up listening sockets that may accept an initiating connection for sending and receiving information.

The network and intervening nodes may comprise various configurations and protocols including the Internet World Wide Web intranets virtual private networks wide area networks local networks private networks using communication protocols proprietary to one or more companies Ethernet WiFi such as 802.11 802.11b g n or other such standards and HTTP and various combinations of the foregoing. Such communication may be facilitated by a device capable of transmitting data to and from other computers such as modems e.g. dial up cable or fiber optic and wireless interfaces.

Although certain advantages are obtained when information is transmitted or received as noted above other aspects of the system and method are not limited to a particular manner of transmission of information. Yet further although some functions may be indicated as taking place on a single server having a single processor various aspects of the system and method may be implemented by a plurality of servers for example communicating information over network .

As previously discussed each host server may be connected to a receiver such as a GPS receiver for receiving time signals. For resilience it may be preferable to employ several varieties of GPS receivers e.g. SPECTRACOM Model TSync PCIe SYMMETRICOM Model bc637PCI V2 and MEINBERG. The GPS receivers may require roof mounted antennas and which may be located on the roof above data centers and . Host servers may be housed in server racks located in the data centers and . As such conduits may be installed to route antenna cables from a host server to the roof top antennas. It may be possible to share one antenna across several receivers. This can be achieved for example with an antenna splitter. However antenna sharing may be undesirable because of the low possibility of an antenna failure.

It is conceivable that a GPS receiver may fail. For example possible scenarios may include latent bugs in GPS receivers software and satellite software upgrades and a global catastrophe. In the case of a GPS failure the ability of a time master to freewheel e.g. run without a GPS time reference for several months may allow for enough time to make alternate arrangements. This type of specially configured time master implemented for emergency situations is described in greater detail with respects to .

As shown in the server may include a Recovery master module which may replace a time master module. In this configuration the Recovery master may be frequency locked to a very stable oscillator instead of for example a GPS system. The stability of the oscillator may determine how long and how accurately a Recovery master can serve time. For example based on empirical data an oven controlled crystal oscillator OCXO may have a short term frequency stability of 50 ppb parts per billion 10 with an aging rate of instability at 5 ppb per day and a rubidium oscillator may have a frequency stability of 1 ppb with an aging rate of instability at 0.03 ppb per day. It should be noted that time instability errors can accumulate linearly with the short term stability and quadratically with the aging rate.

According to aspects a Recovery master can be calibrated against a fleet of time masters and over a network . During re calibration all available ordinary time masters may participate. Each time master and may be synched for example to an individual time reference such as a GPS feed. Although only one Recovery master is depicted in it should be appreciated that a typical system can include a number of Recovery masters with each being at a different node of the network . According to aspects re calibrations may be staggered across several Recovery masters to avoid injecting undetected failures e.g. GPS signal failures into multiple Recovery masters.

An initial re calibration interval between a Recovery master and the ordinary time masters and may be short to achieve a relatively rapid approximate synchronization. To achieve an increasingly accurate calibration the interval may be doubled in each subsequent re calibration until it reaches a configured constant e.g. days for Rubidium based Recovery master and 2 days for OXCO based Recovery master . Calibration parameters may be stored in a persistent file so that the parameters survive software restarts and server re boots. For example a calibrations file can be loaded into memory whenever a server starts. The calibrations file may contain a reference number corresponding to time master and and corresponding calibration parameters. The re calibrations may be discarded whenever a frequency reference is disturbed e.g. when a time reference is power cycled .

In addition to the components described above and illustrated in the figures various operations will now be described. It should be understood that the following operations do not have to be performed in the precise order described below. Rather various steps may be handled in a different order or simultaneously. Steps may also be added or omitted unless otherwise stated.

According to aspects to ensure that timestamps computed in a disturbed system are trustworthy a subroutine referred to herein as a time synchronization daemon may be executed. Time synchronization daemons may be employed on one or a number of host machines simultaneously e.g. client and time master host machines . By querying a fleet of time masters to determine a current timestamp the time synchronization daemons may periodically compare the host s machines notion of time against the fleet of time masters. Once the fleet time masters have been queried for the current time the time synchronization daemon may track the round trip query delay associated with querying each time master. In some aspects the time synchronization daemon can calculate synchronization offset intervals that may be relative to a time master e.g. an interval between local time and a time master s notion of current time .

To detect and reject offset intervals derived from possibly malfunctioning time masters e.g. time masters that have failed but are still producing timestamps a voting method may be used such as a variant of Marzullo s algorithm. As a result of the voting method the time synchronization daemon may accept output from validated time masters or reject output from certain time masters for example malfunctioning time masters.

In block an initial local timestamp may be retrieved. For example method may access a registry for storing a host machine s notion of a current date and time. This may reflect time from an internal time clock on the host machine. The timestamps can be encoded in various time formats used to describe instants of time such as Coordinated Universal Time UTC Unix epoch and the unambiguous International Atomic Time epoch TAI .

In block time queries may be sent to a predetermined number of time masters e.g. 5 to 10 time masters . For example an application interface may be utilized to make a connection to a time master for sending and receiving information. In one aspect the time masters may operate at Stratum 1 or Stratum 2. It is also possible for time masters to operate at any arbitrary number such as from 1 . . . K . The basic definition of a Stratum 1 time master is that it may be directly linked e.g. not over a network connection to a reliable source of time such as a GPS receiver. A Stratum 2 time master may be connected to one or more Stratum 1 time masters over for example a network connection. In this example a Stratum 2 time master may get its time via a network request to one or more Stratum 1 time master. In this regard if a Stratum master is fed by a master operating at stratum K or less it may be described as a Stratum K 1 .

In block responses may be received from the time masters queried in block . For example as a result of the time request a time master may generate a timestamp. According to aspects time masters may publish timestamps over a network connection in a distributed system. In one aspect the application interface used to request a timestamp in block may also be used to retrieve timestamp responses. Various other techniques for transmitting data over a network socket can be used to publish and receive timestamp responses e.g. Transmission Control Protocol Internet Protocol TCP IP World Wide Web s Hypertext Transfer Protocol HTTP File Transfer Protocol FTP Telnet Telnet protocols and other types of communication protocols.

In block a received time query response may be associated with a current local timestamp. For example the current local timestamp may denote respective events of reception of the time query response according to a local time scale. In some aspects associating the current local time with the time query response may be accomplished by storing both in memory a data structure or by inserting both in a suitable computer readable medium capable of storing information accessible by a processor.

In block a time offset interval may be calculated for each time masters that was queried in block . The offset interval s width e.g. a length of time duration may represent transmission delays associated with a time request to and from a particular time master. The timestamps from each non malfunctioning time master may correspond to an instant of time somewhere between the initial local timestamp taken in block and the local timestamp associated with a time master s response in block .

A level of uncertainty e.g. transmission delays may also affect the time offset interval calculation. In this regard to calculate the offset interval for each time master the following equations may be used 0 2 0 2

In the above equations D m represents the time offset relative to time master m T m represents the timestamp provided by master m U m represents an uncertainty related to a time master m L m represents the local time captured at the time when a time query response was received from time master m and L 0 represents a local timestamp taken prior to dispatching the time queries to the time masters. Thus with respects to a time master m local time may be in error by an offset D m plus or minus the uncertainty calculation U m or in other words an interval range of D m U m to D m U m .

In block it may be continually tested whether the total number of time query responses has been reached. If the number has been reached then method may proceed to block . Otherwise method may repeat block and receive another time query response.

In block an agreement algorithm may be employed to analyze an aggregate of the time master offset intervals calculated in block . Because time masters may occasionally fail an agreement algorithm e.g. Marzullo s algorithm may determine a smallest time offset interval consistent among a selected group of time masters. In some aspects the agreement algorithm may be employed more than once.

In an initial run of the agreement algorithm a group of local time offsets calculated in block may be selected. The selection may be based on a corresponding time master s configuration such as whether a time master is operating at Stratum 1. Each calculated offset may represent the local clock error relative to a particular time master. A determination may be made by method for a maximal set of intersecting local time offsets from the group. In one example if no two offset intervals intersect method may stop. Method may also stop if more offsets in the group disagree than agree. If at least two offset intervals intersect than an agreement validated offset interval e.g. a smallest interval containing all points lying in the intersection of at least k 1 of the k intervals in the group may be assigned for the group.

In one aspect a level of uncertainty may be reflected in a group of offsets in an interval e.g. the width of the group from smallest to largest offset . This level of uncertainty may be relatively small because typically several time masters may be nearby. Thus the agreement validated offset determined in block should be relatively accurate plus or minus a level of group uncertainty.

According to some aspects the agreement algorithm may be employed a second time. In this iteration of the agreement algorithm local time offsets calculated in block may be selected from a group of time masters configured differently than the first group. For example this selection may be based on time masters not operating at Stratum 1. The offset intervals corresponding to the non Stratum 1 time masters may be clipped against the Stratum 1 offset interval. The second round may be used to steer local clocks when there is no nearby Stratum 1 time master thus improving consistency among nearby hosts.

The second iteration of the agreement algorithm may be then applied to the clipped non Stratum 1 offsets. This second iteration may yield a final validated offset interval which may be accurate plus or minus a level of uncertainty related to the second group of time masters. Typically this final validated offset interval should be within the uncertainty range resulting from the first run of the agreement algorithm. In one example the second iteration results may be discarded if the results are outside of the uncertainty range of the first iteration.

In block local time on a host machine may be disciplined or validated depending on the machine s configuration. For example if the machine employing method is a GPS fed time master the offset interval from block may be used to validate time published by the GED fed master. If the machine is a client host or a Recovery master the offset interval from block may be used to adjust the host machine s local clock. For example if the offset interval is 2 1 the local clock can be somewhere between 1 and 2 seconds ahead of the masters. If the interval is 1 2 the local clock can be 1 to 2 seconds behind the masters. If the interval is 1 1 the local clock can be somewhere between 1 second behind to 1 second ahead of the master.

In this regard a host server s local system clock may be disciplined to help keep precise time. For example small adjustments e.g. the validated offset from block may be applied to the system clock periodically. These adjustments may be applied using various utilities for accessing a system s local clock such as the utility application adjtimex. In one aspect adjtimex may be used in PLL mode phase locked loop . In this example PLL constants and offset clamps values may be chosen to bind the local clock rate error to approximately 1000 ppm. Some applications for example distributed lease protocols may depend on time progressing at a similar rate on each host. For such applications to work properly clock rates need to be controlled.

In block a request for a timestamp may be received. For example a client may open a socket connection to time master s host server to initiate a connection for sending and receiving information. Through this connection the time master may act as a NTP server that transmits timestamps to the client.

In block time signals may be provided from a reliable time reference. For example GPS timestamps may be provided by a GPS disciplined oscillator e.g. a SPECTRACOM PCI Express Model TSync PCIe connected to a host server In some aspects timestamps may be served directly from the system s oscillator. According to aspects this may help avoid several sources of time corruption such as time keeping bugs related to operating systems and Time Stamp Control TSC deficiencies that plague many microprocessors.

In block GPS timestamps may be adjusted based on a leap second. A leap second may be a positive or negative one second adjustment to a time scale that may keep it close to mean solar time. In some aspects leap seconds may be amortized over a period of ten hours on either side of the leap second thus rendering the leap second invisible to a client requesting a timestamp. Several techniques may be used to amortize leap seconds for example they may be linearly amortized over a window of time e.g. 10 hours on either side . A standard leap file disseminated by the National Institute of Standards and Technology NIST may govern leap second insertions.

In block possible system failure conditions may be continually monitored. For example a failure can be a discovered disagreement between the NIST leap file and leap seconds advertised by a connected GPS system. Other possible failures may include when the NIST file is about to expire poor satellite signal reception a shorted antenna cable parity errors etc. If a failure condition is detected method may raise an alert at block . Otherwise it may proceed to block .

In block a failure alert may be raised. Once a failure condition has been detected a time master may block or discard incoming time queries until the alert has been resolved. Typically many failures may require some type of repair to be preformed. For example some alerts may be resolved by making a request to a service for an updated NIST file for adjusting leap seconds. In this example method may optionally repeat block to adjust leap seconds based on the newly provisioned NIST file. Other failures may be resolved by repairing a GPS receiver or other hardware.

In block timestamps may be synchronized with an external reference. For example timestamps from a secondary device such as a High Precision Event Timer HPET attached to a time master host may be used as a sanity check. According to aspects on a server running an Intel processor the HPET may be a fairly reliable timing device. HPET accesses can impact processing time by several microseconds. This however may be an acceptable impact in performance.

In block timestamp spikes may be detected. If a timestamp lies outside of a determined range it may be considered a spike. The spikes may be logged but not transmitted to clients. In one example spikes may be detected by planting guideposts to demark an acceptable range for the timestamps. In this example a guidepost can be correlated GPS and HPET timestamps planted periodically. Each GPS timestamp may be checked against the bounds since the last guidepost was planted. This check may provide a measure of protection against for example GPS system faults and satellite signal spoofing attacks. The spike detection process employed in block is further described with respects to .

As illustrated emanating from the initial guidepost are rays and positioned at angles. A shaded region e.g. the cone of uncertainty between the rays reflects an uncertainty about the precision of the HPET frequency plus or minus a predetermined tolerance level. According to aspects if a subsequent reading of a GPS timestamp intersects the shaded region it may be accepted as a valid timestamp. If it does not intersect the shaded region it may then be declared a spike because it violates the HPET frequency error bounds and .

The guidepost may be advanced at a rate determined by roughly balancing the uncertainty induced by HPET frequency errors the GPS system and HPET read latencies. In one example guideposts are advanced approximately every 100 milliseconds. A new guidepost such as guidepost may be planted when the previous guidepost expires and a new valid GPS timestamp is obtained for verification. The newly obtained GPS timestamp may also become an anchor in the new guidepost. For example plot points and of guidepost are determined by a subsequent pair of GPS and HPET time stamp readings. In one aspect the guidepost may be associated with three timestamps taken in the following order a 3HPET timestamp a 2GPS timestamp and a 4HPET timestamp.

According to aspects spikes with high frequency synchronization errors that exceed approximately 20 microseconds may be detected. As well as low frequency wander spikes exceeding the worst case HPET variation. In some aspects it may be desirable to use a number of spike detectors each advancing at a different rate. In this regard a spike detector advancing at a rapid rate may be better at detecting high speed spikes while a detector advancing at a slower rate may be better at detecting gradual frequency shifts in a time master.

According to aspects time masters and may serve as primary time references in a distributed system. As previously discussed the time masters internal clocks may be synchronized with e.g. a GPS signal atomic clock or other types of accurate timekeeping technologies known in the arts. The time masters may be designed for high reliability and may be deployed at multiple sites throughout a distributed system. Although only two time masters are depicted in it should be appreciated that a typical system can include a large number of time masters communicating with each other over e.g. a network connection .

The time synchronization daemon may periodically query multiple time masters and for a current timestamp. The daemons may calculate synchronization offset intervals relative to each time master and by tracking round trip delays related to a time query. Sets of time master offsets may be validated against each other using e.g. clock synchronizing techniques as described with respects to . As previously discussed the clock synchronizing techniques may employ an agreement algorithm to detect and reject offsets from malfunctioning time masters. An intersection of surviving offset intervals may be used to determine a client s local time synchronization error which may have occurred at the time a query was made to a time master and . Accordingly the client s local clock rate may be updated based on the surviving offset intervals.

A TrueTime library interface may be employed to transmit validated timestamps requested by client applications. For example a client may use an application programming interface API that may be operable in conjunction with the TrueTime library in order to communicate with modules of system . The TrueTime library may also calculate a local time offset interval e.g. a difference between local time and a time reference based on such factors as a local clock known rate errors related to the local clock and an offset interval determined by the time synchronization daemon at the last time the time masters and were polled.

In some instances it may be difficult to determine an order of events in a distributed system because system clocks are not always synchronized. However event ordering can be determined using timestamps generated with the TrueTime library rather than using a machine local approximation of current time. In one aspect timestamps determined by employing the TrueTime library can be used as a basis for making causally dependant information available to host clients in a distributed system. For example this information can be used by an application associated with a host client to causally order event transactions.

In block an initial local timestamp may be retrieved. For example a host client s notion of a current date and time may be accessed and stored. This may reflect time from an internal time clock memory registry or other means of tracking time on the host machine.

In block a time interval may be determined e.g. a difference between the local timestamp and a time reference . For example a software module operable in conjunction with a TrueTime library interface may request a time interval provided by the TrueTime library. As previously discussed the TrueTime library may provide a time interval interface to host clients requiring meaningful globally coherent timestamps. The TrueTime library may determine the time interval from a time synchronization daemon employed locally on a host client. As described with respect to host clients may employ a time synchronization daemon which may track a correlation between local clocks and causal time by computing uncertainty bounds on that correlation. The time synchronization daemon may derive a causal time by querying a number of time masters deployed throughout a distributed system. In some aspects the time synchronization daemon may determine a time interval consistent among a selected group of time masters by employing an agreement algorithm on the selected group.

In block a timestamp from the time interval may be recorded. For example the latest timestamp in the time interval determined in block may be selected. According to aspects this timestamp may be larger than the timestamp of other causal predecessors. In one aspect the timestamp may be recorded and maintained in a predetermined format. For example the timestamp can be encoded in a time format used to describe instants of time such as UTC. Consistent time formatting may for example allow for comparison of the timestamp with local timestamps from one or more different systems.

In block a period of time may pass after a timestamp is recorded from the time interval. The time period for waiting may be chosen so that after the waiting period the time of recorded timestamp has passed. According to aspects waiting may preserve the causal order of events by ensuring that causal successors e.g. logically ordered transactions will be assigned respectively larger timestamps. For example if the current time is between 3 50 PM and 4 00 PM and a 10 minute waiting period is chosen then after the waiting period it will be later than 4 00 PM and thus any future chosen timestamps will be later than 4 00 PM. It will be appreciated that in some aspects other types of client computations can occur in block while the time period is passing.

In block the recorded timestamp may be provided. For example a programming interface may be used by a host client to access the recorded timestamp from block . The timestamp may also be returned as a result of a call to a computer program library class function or other types of programming techniques known in the arts. The host client may then associate the timestamp e.g. with host client events thereby ensuring a causal order of event transactions for services accessed at the client.

The above described aspects of the technology may be advantageous for generating globally synchronized timestamps without incurring various types of network delay inherent in explicit synchronization. The globally synchronized timestamps can be used by various services e.g. to validate local timestamps and clocks or to provide causality respecting timestamps for database updates. By introducing techniques to track calculate and record time data relative to a number of reliable time references an easy to manage and low cost time base may be provided for host machines in a distributed system. Moreover the various techniques and parameters disclosed within may be further reconfigured to increase overall timestamp accuracy.

Although the present technology has been described with reference to particular embodiments it should be understood that these examples are merely illustrative of the principles and applications of the present technology. For example it should be understood that the described systems and methods can be performed in part or in their entirety on a mobile client device e.g. a mobile phone on a remote computing device e.g. a server or on some combination thereof. Additionally it should be understood that numerous other modifications could be made to the illustrative embodiments. However these and other arrangements may be devised without departing from the spirit and scope of the present technology as defined by the appended claims.

