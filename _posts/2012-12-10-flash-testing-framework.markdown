---

title: Flash testing framework
abstract: A computer-based automated testing framework tests a multimedia application (such as a Flash application running in a player module) that includes one or more Flash objects by executing test scripts in an external Java-based test module that uses proxy objects in the test module to represent the Flash objects in the player module. Correspondence between the proxy object and Flash objects is maintained by translating the first test script into a command, sending the command from the external test module to the player module, interpreting the command by accessing a lookup table at the player module, and then returning a value to the external test module in response to the command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009674&OS=09009674&RS=09009674
owner: Versata Development Group, Inc.
number: 09009674
owner_city: Austin
owner_country: US
publication_date: 20121210
---
This application is a continuation of co pending U.S. application Ser. No. 11 474 790 filed Jun. 26 2006 which is incorporated herein by reference in its entirety.

The present invention relates in general to the field of program testing. In one aspect the present invention relates to a system and method for testing multimedia applications such as Macromedia Flash applications.

In recent years multimedia works containing different types of media content such as text sound video still and animated graphics etc. have been used to deliver information to viewers via televisions computers or computer networks such as the Internet. illustrates an Internet based system for distributing multimedia works using server deployed software that enables developers to easily and economically create network aware applications with rich interactive user interfaces. In the illustration the application server includes a browser with a player and an authoring program for creating object code of a given multimedia work. The object code may be sent to a client for playback at a remote user interface such as on the player at the client browser . Communication between the various elements can be via network dedicated connection wireless connection or any other connection that is suitable for appropriate communication. At the remote client a player is provided as a software environment hardware or a set of one or more software programs etc. that can display graphics and play sound.

An example of a multimedia authoring program and player for creating and playing multimedia works is the Macromedia Flash suite of programs. Flash and Macromedia Flash are registered trademarks of Adobe Systems Inc. Flash is an interactive alternative to traditional graphical user interface GUI technologies such as HyperText Markup Language HTML . In contrast to HTML which employs a static page based model Flash can support dynamic graphical interfaces that programmatically change on the fly. In addition Flash applications are stateful networked programs that support a rich programming environment. Strictly speaking Macromedia Flash is the authoring environment and Flash Player is the program used to run the Shockwave Flash SWF files or applications but the term Flash is sometimes used interchangeably to refer to the authoring environment the player or the application files.

With Flash applications or movies the authoring tool such as Flash MX 2004 Interactive Development Environment IDE uses vector and raster graphics a scripting language called ActionScript and bidirectional streaming of video and audio to generate Flash files or movies as a compressed stream of bytecodes a SWF file . Nearly all complex Flash applications are written entirely as ActionScript programs with minimal use of the IDE other than for compilation. Macromedia Flash applications are typically created using an IDE such as Macromedia Corporation s Flash MX2004 although the SWF file format is an open standard and other means of creating such files exist. Flash applications may include images sound video user interface components and other program code or data. Flash program code is written in the ActionScript language which supports object oriented programming OOP exceptions events and has a native user interface component library. A Flash application is deployed from an application server as a SWF file that is referenced from web pages e.g. at client through the use of or tags that are interpreted by a browser plugin. The browser interprets these tags to start up the Flash player which loads the SWF file and begins execution. The tag determines the height and width of the region on the page in which the Flash player will have control. The Flash player handles all user interface UI events that occur over this region such as mouse movements or click or key presses and exercises total graphical control over the pixels specified.

When creating a multimedia work testing is required to assess the work for performance functionality and playback. Traditionally Flash applications have been tested by hand. This involves human interaction with the application usually following a planned test script and the manual recording of errors. This process can be error prone unreliable time consuming and or expensive. While automated test frameworks do exist they primarily support only unit tests written in ActionScript the Flash programming language. Such ActionScript based test frameworks suffer from a number of disadvantages. First ActionScript code cannot generate native user interface UI events such as mouse movement clicks and keyboard events or other events generated and handled at the host operating system level. In addition because current implementations of the Flash player present a single threaded execution environment to ActionScript code when running as a browser plugin an ActionScript test script cannot run in concert with an executing Flash application which means that the Flash application cannot make progress while a block of test code is executing. Another drawback with ActionScript tests is that the ActionScript language cannot access the actual graphical output of the Flash player for verification which means that such tests cannot be considered true end to end tests for a Flash application. In addition ActionScript tests cannot be integrated into existing web testing frameworks without significant extra work which requires that separate test suites for Flash and HTML be maintained rather than testing a website as an integrated whole. Moreover a web page containing two or more separate Flash movies cannot be effectively tested with a test script written in ActionScript since it must execute in one and only one Flash player at a time. Finally ActionScript does not provide a large and feature rich language that more sophisticated systems programming languages such as Java support. Java is a trademark of Sun Microsystems Inc. These libraries can be useful when writing sophisticated tests of an application.

As seen from the foregoing a need exists for an improved automated testing framework for testing multimedia works such as Flash applications. Conventional testing approaches suffer from the numerous drawbacks and limitations or are otherwise ineffective as explained hereinabove. Further limitations and disadvantages of conventional systems will become apparent to one of skill in the art after reviewing the remainder of the present application with reference to the drawings and detailed description which follow.

In accordance with one or more embodiments of the present invention a system and method are provided for testing graphical programs such as interactive Flash applications that are deployed via the web and execute within a web browser. In accordance with various illustrative embodiments Flash application test scripts may be executed externally from the player running the Flash application under test by using an external application programming interface API to communicate with the Flash application under test. Commands from the external API are translated by a command interpreter at the Flash player which responds to each command with a result such as a requested value. For example the command interpreter returns proxy objects to represent any symbolic value in the Flash application execution environment being accessed for reading or writing for any function to be called or for supporting any other command. In a selected embodiment the command interpreter uses an object lookup table or similar functionality to return proxy objects corresponding to the symbolic value being accessed. With the approach of using an external testing tool to manipulate proxy objects in place of symbolic values in the Flash memory space the test tool language for the external testing tool may be selected from any desired language to provide enhanced testing functionality. For example a Java based API may be used to write test code which provides methods for generating native user input events capturing and processing the image output of the Flash player accessing arbitrary data from the Flash player and executing arbitrary code within the Flash player.

The objects advantages and other novel features of the present invention will be apparent from the following detailed description when read in conjunction with the appended claims and attached drawings.

It is noted that elements illustrated in the figures are illustrated in diagrammatic form for simplicity and clarity. Further where considered appropriate reference numerals have been repeated among the drawings to represent corresponding or analogous elements.

An automated testing framework for Flash applications is described which uses externally executed test scripts to generate native UI events in the host operating system natively capture the graphical or auditory output of the Flash player read and write data values in the Flash player and execute functions defined in the Flash player. While various details are set forth in the following description it will be appreciated that the present invention may be practiced without these specific details and that numerous implementation specific decisions may be made to the invention described herein to achieve the device designer s specific goals such as compliance with process technology or design related constraints which will vary from one implementation to another. While such a development effort might be complex and time consuming it would nevertheless be a routine undertaking for those of ordinary skill in the art having the benefit of this disclosure. For example selected aspects are shown in block diagram form rather than in detail in order to avoid limiting or obscuring the present invention. In addition some portions of the detailed descriptions provided herein are presented in terms of algorithms or operations on data within a computer memory. Such descriptions and representations are used by those skilled in the art to describe and convey the substance of their work to others skilled in the art. Various illustrative embodiments of the present invention will now be described in detail below with reference to the figures.

Referring now to there is illustrated an architectural diagram of an exemplary computer system for authoring and testing multimedia works in accordance with various illustrative embodiments of the present invention. The computer system may be found in many forms including for example mainframes minicomputers workstations servers personal computers internet terminals notebooks wireless or mobile computing devices including personal digital assistants embedded systems and other information handling systems which are designed to provide computing power to one or more users either locally or remotely. In the example depicted in the computer system is implemented as an application server which includes a memory storage device which may include mass storage memory and local RAM memory one or more microprocessor or central processing units CPU an input device e.g. keyboard mouse etc. and an output device e.g. display speakers etc. .

The memory storage device stores program and data files that are used for creating testing and playing multimedia works including a multimedia authoring program a multimedia testing program a multimedia playback program and multimedia data files or applications . In particular the memory storage device includes an addressable memory that is used to load the multimedia authoring program for operation by the processor during the creation of a multimedia application and for temporarily storing the application during its creation. The memory also stores a browser program and player program which are used to playback a multimedia application . In addition the memory stores a testing tool program which is used to test the multimedia application after or as the application is created by the multimedia authoring program . These program and data files are accessed by the processor as needed for the creating playback and testing of multimedia works.

The processor in one embodiment is a 32 bit or 64 bit microprocessor manufactured by IBM by Motorola such as the 680X0 processor or by Intel such as the 80X86 or Pentium processor . However any other suitable single or multiple microprocessors or microcomputers may be utilized. Computer programs and data are generally stored as instructions and data in mass storage until loaded into main memory for execution. Main memory may be comprised of dynamic random access memory DRAM . As will be appreciated by those skilled in the art the processor may be connected directly or through an interface or bus to a variety of peripheral and system components such as a hard disk drive cache memory traditional I O devices such as display monitors mouse type input devices floppy disk drives speaker systems keyboards hard drive CD ROM drive modems printers network interfaces terminal devices televisions sound devices voice recognition devices electronic pen devices and mass storage devices such as tape drives hard disks compact disk CD drives digital versatile disk DVD drives and magneto optical drives. The peripheral devices usually communicate with the processor over one or more buses and or bridges. Thus persons of ordinary skill in the art will recognize that the foregoing components and devices are used as examples for the sake of conceptual clarity and that various configuration modifications are common.

The processor receives inputs from a variety of different sources that are used to create interactive graphical multimedia works. For example a keyboard is used to input commands and data for controlling the operation of the processor and the multimedia programs in a conventional manner and for providing content for a multimedia art work. An electronic pointing device such as a mouse a touch pad a joystick and the like may also be used to control the multimedia programs . Additional content may be input from an image source such as a scanner for scanning text graphics photographs and other images a video source and or an audio source such as a MIDI source or MP3 player that provides coded audio information .

As multimedia works increasingly become interactive and feature rich the size and complexity of the code for such works also increases. For example an HTML web page being executed at the browser may include one or more Flash application components which consist of large amounts of code in multiple files including sound video graphics and text files. To ensure correctness reliability performance and maintainability over time this code needs to be tested. depicts a framework to facilitate complex and comprehensive testing of graphical programs such as Flash applications. The framework may be implemented as a software package that includes a test tool for testing a multimedia application that is executed by a playback program such as a browser . In the test tool a test driver invokes code for the test case which executes outside of the player execution environment . The driver may call invoke or execute one or more of the test case scripts sequentially or in parallel. To support external execution of the test cases the test tool uses a test API in the test tool to communicate with a command interpreter in the player . In particular the test API communicates the externally executed test cases to the player using a sequence of commands and responses that are exchanged over a communications channel with a command interpreter .

By executing test cases in a separate process that is external to the player the test scripts may be written in any language and then communicated with the player using the test API . The separately executed test script feature provides improved or different test script functionality than would otherwise be allowed if the test scripts were executed within the execution environment of the player . For example by writing the test cases and test API with a sophisticated systems programming language such as Java a larger and more feature rich API is provided than would otherwise be available if the test scripts and testing framework were written with the language of the player such as ActionScript . This allows test scripts to leverage existing libraries of code including existing testing frameworks for other UI technologies that integrate with Flash such as HTML. In particular test code written using a Java based test API provides methods for generating native user input events capturing and processing the image output of the Flash player accessing arbitrary data from the Flash player testing multiple movies at the same time and or executing arbitrary code within the Flash player. In addition Java based test scripts support a wide range of platforms and browsers and allow a test script to be written independently of the platform and browser being used for the test. This facilitates cross platform and cross browser testing. Any or all of these features may be used to provide improved testing of complex and feature rich applications such as Flash applications. Since the test scripts are external to the player they can be randomized data driven and synchronized in complex ways that simulate real user behavior in a way that is not readily feasible for ActionScript test scripts to support given current technology.

To implement external test script execution the system includes a command interpreter in the player that accepts commands from the Test API and responds to each command with its result . The command interpreter may be configured to allow any symbolic value in the memory space of the player to be accessed for reading or writing. In addition the command interpreter may be designed to call any method or function in the player memory space and to support other commands. At the command interpreter each interpreted command results in a return value which is serialized and sent as the response to the Test API .

Communications between the Test API and command interpreter are exchanged over a communications channel . The channel allows the Test API to send commands to the interpreter which is listening for them in the player . In a selected embodiment the communications channel may be implemented as a full duplex TCP IP socket where messages are null terminated text strings. However any communication technology may be used to implement the channel that provides adequate speed reliability efficiency etc.

An example sequence is illustrated in for a test case which issues a Java read command that requests a variable value x associated with a Flash object Object A in an application being executed by the Flash player . To retrieve the value the read command e.g. FlashObject proxy.get x in the test case references a proxy object e.g. FlashObject ObjectID 2 that has previously been assigned to the requested object e.g. Object A . The test API implements the Java read command as a read command in the language of the Flash player e.g. get objectID 2 x and sends the command to a command interpreter at the Flash player . The command interpreter treats the command as a request to return or output a variable associated with the identified object and uses an object lookup table to translate the proxy object identifier e.g. ObjectID 2 into the actual requested object Object A in the Flash execution environment. While the lookup operation may be performed in any desired way a selected embodiment of the command interpreter uses script commands e.g. var o o lookup 2 return o.x to access the object lookup table at a location corresponding to or specified by the proxy object ID e.g. entry 2 which stores a pointer or location for the requested object e.g. Object A in the Flash execution environment . Using the stored pointer or location information from the lookup table the command interpreter issues a read request to the Flash application for the value x for the requested object Object A and this value is then returned to the command interpreter . The command interpreter then sends a response to the test API which provides the requested value for the proxy object objectID 2 in the response to the testcase . As seen from the foregoing the use of proxy objects allows code in one language Java to effectively reference and manipulate an object in another Flash . Thus proxy objects are used to represent objects returned by the command interpreter from the Flash execution environment.

As disclosed herein externally executed test scripts can be used with proxy objects to facilitate complex and comprehensive testing of interactive graphical applications that include large amounts of code in multiple files such as Macromedia Flash applications to ensure correctness reliability performance and maintainability over time. To illustrate this an example test sequence for a Flash test framework is illustrated in to show how such a framework can be used to execute a sequence of test scripts to assess how a Flash object for a Price button on a web page reacts to a user interaction in the form of a mouse click.

Starting with the Flash test framework is diagrammatically depicted as a computer system including a monitor or screen and a memory in which is stored a test machine module and a Flash player module . In the Flash player a Flash application is running as part of a browser program not shown to display a web page on the monitor or screen . In this example the web page includes information concerning Ford F 150 Trucks. For each Flash object in the web page being displayed by the Flash application the Flash memory space stores a corresponding object as part of a connected object tree which is constructed in accordance with the Flash programming principles. Thus to specify a Price button located in a menu region on the web page the object space includes a first Root object which identifies the starting location coordinates for the display region for the web page. Connected to the Root object is a menu region object which symbolically identifies the location coordinates for the menu region for the web page. Finally a Price object is connected to the menu region object to symbolically identify the location coordinates for the Price button in relation to the menu region .

Rather than testing the Flash application by directly manipulating the objects in the execution environment of the Flash player the test machine creates a proxy object memory space for storing values that stand in place of the Flash objects . This is accomplished by using a test API and command interpreter to allow any symbolic value in the Flash object memory space to be represented by proxy objects in the proxy object memory space . An example of how proxy objects are created and used is illustrated in which shows that the testcase issues a first test step to the test API as indicated at communication line . In this example the first test step e.g. FlashMovieClip root FlashPlayer.getRoot requests the root location information for the Flash movie being executed using a first language e.g. Java . At the test API the first test step is translated for purposes of issuing a command e.g. get root to the command interpreter in a second language e.g. ActionScript . At the command interpreter the command is executed by assigning an ID e.g. ID0 to the requested Root object storing the Root object in the object lookup table in a location corresponding to the assigned ID or alternatively storing location or pointer information for the Root object in the table and then sending the assigned ID e.g. ID0 as a response to the test API . At the test API the response e.g. ID0 is used to construct a new proxy object if the object is being referenced for the first time or to look up an existing proxy object if the object had been previously referenced . The constructed retrieved proxy object is forwarded to the testcase as indicated at communication line for storage as a proxy object in the proxy object memory space as indicated at communication line .

For purposes of further illustrating various illustrative embodiments of the present invention diagrammatically depicts the execution of a second test step on the Flash test framework . As illustrated the testcase issues a second test step to the test API as indicated at communication line where the second test step e.g. menu root.getMovieClip menu requests the location information for the menu region in the Flash movie being played. At the test API the second test step is translated from a first language to a second language for purposes of issuing a command e.g. get ID0 menu to the command interpreter . At the command interpreter the command is executed by assigning an ID e.g. ID1 to the requested Menu object storing the Menu object in the object lookup table in the table location corresponding to the assigned ID or alternatively storing location or pointer information for the Menu object in the table and then sending the assigned ID e.g. ID1 as a response to the test API . At the test API the response e.g. ID1 is used to construct or look up a proxy object that is forwarded to the testcase as indicated at communication line for storage as a proxy object in the proxy object memory space as indicated at communication line .

For purposes of further illustrating various illustrative embodiments of the present invention diagrammatically depicts the execution of a third test step on the Flash test framework . As illustrated in the testcase issues a third test step to the test API as indicated at communication line where the third test step e.g. price menu.get price requests the location information for the Price button in the Flash movie being played. At the test API the third test step is translated from a first language to a second language for purposes of issuing a command e.g. get ID1 price to the command interpreter . At the command interpreter the command is executed by assigning an ID e.g. ID2 to the requested Price object storing the Price object in the object lookup table in the table location corresponding to the assigned ID or alternatively storing location or pointer information for the Price object in the table and then sending the assigned ID e.g. ID2 as a response to the test API . At the test API the response e.g. ID2 is used to construct or look up a proxy object that is forwarded to the testcase as indicated at communication line for storage as a proxy object in the proxy object memory space as indicated at communication line .

As a result of the foregoing sequence of steps a proxy object tree is constructed in the proxy object memory space that corresponds directly to the Flash object tree stored in the Flash object memory space . With such a proxy object representation the test machine module may execute functions defined in the Flash player thereby providing additional testing functionality for better simulating user interaction with a Flash application . An example is provided with reference to which diagrammatically depicts the execution of a fourth test step on the Flash test framework . As illustrated in the testcase issues the fourth test step to the test API as indicated at communication line where the fourth test step e.g. priceClick performs a native user input event such as placing and clicking the cursor over the Price button in the Flash movie being played. At the test API the fourth test step may be translated and or processed using a first sequence of commands to retrieve the location coordinates for the Price button in the Flash movie e.g. x get x y get y translate those coordinates to screen coordinates e.g. translate.to.screen move the mouse cursor to the screen coordinates e.g. mouse.move x y and then click the mouse cursor e.g. mouse.click .

In order to precisely specify the location of a point or group of points within the Flash player s graphical region in terms of screen coordinates the location of the Flash movie on the screen is required. Knowing the position of the movie allows the test framework to support methods that click on a graphical component or retrieve the pixels that represent it onscreen. A selected embodiment of the present invention uses a movie location tool in the external test machine tool to determine the position of the Flash movie . For example the movie location tool finds an arbitrarily small movie on the screen by moving the mouse cursor to a predetermined pattern of points on the screen and checking to see if the mouse is over the player s graphical region. While any pattern of points may be used one approach is to divide the screen into increasingly smaller regions by making a series of passes across the screen . In a first pass the center point the screen is checked. In a second pass four points on the screen are checked by moving the cursor to the center of each screen quadrant and to each mid point position there between. In a third pass each screen quadrant is divided into sub quadrants and the center point of each sub quadrant is checked. The process may continue to check increasingly small regions until a Flash movie is located or until a predetermined termination event occurs such as failing to detect a movie after checking regions of a predetermined size. Regardless of the algorithm used to move the mouse and see if the mouse is over the player s graphical region the extra knowledge of the position of the Flash movie on the screen is indispensible to performing graphical testing.

By invoking the movie location tool to determine the location of the Flash movie the test API can then process the first sequence of commands into a second sequence of commands e.g. get ID2 x get ID2 y which are issued to the command interpreter . At the command interpreter the second sequence of commands are executed by using the assigned ID for the Price button e.g. ID2 to directly access the Price button the object lookup table or to indirectly access the Price button by using pointer information for the Price object from the object lookup table . The requested coordinate values x 100 y 200 are then retrieved from a data table associated with the Price object and sent back to the test API as a response . At the test API the response e.g. 100 200 is treated as a proxy object that is forwarded to the testcase which uses the response to execute the first sequence of commands e.g. translate to screen mouse.move x y mouse.click and or for storage with Price proxy object in the proxy object memory space as indicated at communication line .

Having used the test steps to locate and click on the Price button the test machine may now use the proxy objects to test the Flash application to confirm that a drop down menu for the Price button is working properly when the cursor is clicked over the Price button . This is illustrated in which diagrammatically depicts the execution of a fifth test step on the Flash test framework . As illustrated in the testcase issues a fifth test step to the test API as indicated at communication line where the fifth test step e.g. assert Price.is.Expanded inquires if the Price button is expanded into a drop down menu in the Flash movie being played. At the test API the fifth test step is translated for purposes of issuing a command e.g. get ID2 expanded to the command interpreter . At the command interpreter the command is executed by using the assigned ID for the Price button e.g. ID2 to access pointer information for the Price object from the object lookup table . The requested information from the expanded field e.g. True is then retrieved from the data table associated with the Price object and sent back to the test API as a response . At the test API the response e.g. True is treated as a proxy object that is forwarded to the testcase which uses the response as part of the test steps to assess if the Price button is expanded when the cursor is located and clicked over the Price button . In addition or in the alternative the response may be stored with proxy object in the proxy object memory space as indicated at communication line .

As will be appreciated the external test machine tool may be used to perform other testing functions on the Flash application including reading and writing data values in the Flash player . For example the test API may be configured to issue a write command e.g. set ID2 x 200 to the command interpreter for purposes of setting a data value in one of the Flash objects e.g. changing the x value in the Price object from 100 to 200 . Other functions in the Flash player may also be invoked by the test steps in the test machine . For example the test API may be configured to issue a command e.g. call ID2 turn red which causes the command interpreter to execute a function defined in the Flash player e.g. accessing the table associated with the Price object to change the color of the Price button to red . While the Flash test framework supports arbitrarily complex test scripts it also can support simple keyword driven test scripts. Keyword based scripts are very simple text descriptions of a test that can be written by non programmers. In a selected embodiment the Flash test framework supports these by adding another layer of code on top of the test API that maps a keyword based script to a series of calls against the test API .

In the computer based system and methodology described herein automated testing of a multimedia application is disclosed. Under the framework a multimedia application such as a Flash application to be tested is written in a first language such as ActionScript is executed in a player module such as a Flash player and includes a first object. The multimedia application is tested with externally executed test scripts written in a second language such as Java which uses a proxy object in an external test module to represent the first object in the player module. With this approach the functional testing limitations of the first language may be supplemented with the testing capabilities of the second language. For example the test scripts written in the second language may be used to generate a native user interface event in the external test module or may be used to capture at least one graphical or auditory output of the player module or may be used to read or write data values in the player module or may be used to execute functions defined in the player module. Correspondence between the proxy object and the first object is maintained by translating the first test script into a command sending the command from the external test module to the player module interpreting the command by accessing a lookup table at the player module and then returning a value to the external test module in response to the command which serves as a proxy object in the external test module.

In accordance with various embodiments of the present invention an automated testing framework for Flash applications is implemented as an article of manufacture having at least one recordable medium having stored thereon executable instructions and data. When the instructions and data are executed by one or more processing devices a Flash application having a first object is executed in a Flash player module written in a first language e.g. ActionScript and one or more test scripts are executed to test the Flash application in an external test module that is written in a second language e.g. Java . In operation the external test module uses one or more proxy objects to represent corresponding objects in the Flash application. In an example implementation external test module translates a first test script into a command or sequence of commands e.g. a command sequence and then sends the command sequence to the Flash player module where it is interpreted by accessing a table at the Flash player module to return a value to the external test module in response to the command sequence. The returned value is used to create or reference a proxy object in the external test module to represent various operations at the Flash player such as a native user interface event a graphical or auditory output of the Flash player or a data read write operation. In this way an automated testing framework for Flash applications is provided which includes an external test machine for generating native user interface events in the host system. The external test machine tests the Flash application under test by issuing a test script as a command. The command is translated into or implemented in a language of the Flash player using an application programming interface at the external test machine and a command interpreter at the Flash player to return a value representing a symbolic value in the Flash application under test. As translated the test script may be used to generate native UI events capture a graphical or auditory output of the Flash player read and write data values in the Flash player or execute functions defined in the Flash player.

The methods and systems for automatically testing complex interactive multimedia applications as shown and described herein may be implemented in software stored on a computer readable medium and executed as a computer program on a general purpose or special purpose computer to perform certain tasks. The software discussed herein may include script batch or other executable files. The software may be stored on a machine readable or computer readable storage medium and is otherwise available to direct the operation of the computer system as described herein and claimed below. In one embodiment the software uses instructions and data stored in a local or database memory to implement a Flash application testing framework that supports arbitrarily complex and comprehensive tests for a Flash application. The local or database memory used for storing firmware or hardware modules in accordance with an embodiment of the invention may also include a semiconductor based memory which may be permanently removably or remotely coupled to a microprocessor system. Other new and various types of computer readable storage media may be used to store the modules discussed herein. Additionally those skilled in the art will recognize that the separation of functionality into modules is for illustrative purposes. Alternative embodiments may merge the functionality of multiple software modules into a single module or may impose an alternate decomposition of functionality of modules. For example a software module for calling sub modules may be decomposed so that each sub module performs its function and passes control directly to another sub module. The computer based data processing system described above is for purposes of example only and may be implemented in any type of computer system or programming or processing environment or in a computer program alone or in conjunction with hardware. It is contemplated that the present invention may be run on a stand alone computer system or may be run from a server computer system that can be accessed by a plurality of client computer systems interconnected over an intranet network or that is accessible to clients over the Internet. In addition many embodiments of the present invention have application to a wide range of industries including the following computer hardware and software manufacturing and sales professional services financial services automotive sales and manufacturing telecommunications sales and manufacturing medical and pharmaceutical sales and manufacturing and construction industries. In addition some portions of the description provided herein are presented in terms of algorithms or operations on data within a computer memory. Such descriptions and representations are used by those skilled in the art to describe and convey the substance of their work to others skilled in the art. In general an algorithm refers to a self consistent sequence of steps leading to a desired result where a step refers to a manipulation of physical quantities which may though need not necessarily take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It is common usage to refer to these signals as bits values elements symbols characters terms numbers or the like. These and similar terms may be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions using terms such as processing computing assessing calculating determining displaying or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and or transforms data represented as physical electronic and or magnetic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Although the present invention has been described in detail it is not intended to limit the invention to the particular form set forth but on the contrary is intended to cover such alternatives modifications and equivalents as may be included within the spirit and scope of the invention as defined by the appended claims so that those skilled in the art should understand that they can make various changes substitutions and alterations without departing from the spirit and scope of the invention in its broadest form.

