---

title: Annotation mapping
abstract: A method for annotation mapping includes identifying a set of differences between a first version of a document and a second version of the document, the first version comprising annotations. The method further includes generating a position map that maps differences between the first version and the second version, where the position map facilitates the migration of the annotations from the first version to the second version.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09275368&OS=09275368&RS=09275368
owner: Amazon Technologies, Inc.
number: 09275368
owner_city: Reno
owner_country: US
publication_date: 20120925
---
Publishers and other content providers often make changes in the content of a book after publishing the first copy especially in digital books where the distribution costs are extremely low. These changes can be versioned and can include changes such as correction of a typographical error or an optical character recognition OCR error errors in translation or conversion of printed material removal of extra white spaces formatting changes insertion or deletion of paragraphs words images chapters or any combination thereof. eReader software allows users to annotate such digital books by inserting comments highlights notes reminders links and so forth. However a customer who has an old version of a digital book is unable to upgrade to a newer version of the content without losing the annotations they have made on this content because the annotations are tied to that particular version of content and are not portable.

Thus when a content provider makes new content available customers are forced to choose between receiving the updated content and losing all of their custom annotations or manually reentering their custom annotations or retaining the old content and preserving their annotations. Some marketplace statistics show that among all the customers who are offered an upgrade with the condition that they lose all their existing annotations only about 20 of customers choose to upgrade. This means that the customer can not judge how much the new content has been improved without losing their annotations and has a difficult time making this decision.

Described herein are methods systems and non transitory computer readable storage media for mapping differences between versions of a document to facilitate migration of annotations between versions. Differences between versions include any portions of text images formatting and other content in a document that changes from one version to another version. Differences can be very small such as correcting a typographical error or can be very large such as inserting an entire new chapter in a book. In one embodiment the document is an electronic textbook and the annotations can include typed or handwritten student notes highlighted portions of text images video audio tags links to network content last read position bookmarks favorites and so forth. An example is provided of a textbook but the principles set forth herein are applicable to any electronic document. As is often the case with textbooks a publisher releases frequent updates with new material corrections to typographical errors content errors or other types of errors content additions content deletions updated formatting and so forth. Either a server or a client device can correlate the differences between the old version and the new version of the electronic textbook and use that information to migrate annotations of the old version of the electronic textbook to the new version of the electronic textbook. In this way the user can have access to the newest content and the newest version of the electronic textbook without sacrificing existing annotations. This can be an important consideration for some users as the amount of time and effort spent to generate annotations as well as their corresponding value to the user can be very high. The solution set forth herein aligns and maps byte offsets of words images and other types of content of different versions of an electronic book so that annotations or user metadata can be freely migrated and preserved from one version to another. While the example embodiments set forth herein focus primarily on mapping for migrating annotations between versions the same mapping principles can be applied to page numbers page navigation table of contents or any other content layout or design aspect of an eBook.

Rather than just computing the differences between versions this approach can align the old and new content on a word by word basis so that each word and image in the old version can be mapped to the new version in addition to identifying the changes that occurred. This version to version mapping can allow annotations to be migrated from any version to any other version as long as either a single mapping between those versions exists or an uninterrupted chain of valid mappings between the two versions exists. In one embodiment annotations are stored as references of byte offsets of the old version of the book and are not usable with the new content version without adaptation to byte offsets that correspond to the new content version. The position maps align content between versions and allow for migration of annotations from one version of content to another preserving customer annotations during an upgrade. Further if a string of text is moved from one location to another location in the document then the system can identify this move and mark the change as a transposition instead of a delete at one location and a separate unrelated insert at another location.

In one embodiment of annotation mapping map creation is separate from position mapping. In map creation when a new update is released the system can create position maps for all prior versions to the latest version. This approach can save time versus creating the same maps over and over for different customers. Position mapping then can look up the maps created and translate the positions using the pre created maps. In some cases with personal documents the system can incorporate on the fly map creation where map creation and position mapping occur back to back or at the same time. The position mapper could then run on server side if the client backs up annotation to the server. If annotations are not backed up to the server the client can perform position mapping itself.

The content provider can submit an updated version to the digital marketplace . The digital marketplace can notify the user device of the updated version or the user device can query the digital marketplace to check for a new version. In some embodiments the user device interacts directly with the content provider . When the digital marketplace is preparing to receive receives or has already received the updated version the digital marketplace can cause the versioning map creator to generate a map between the first version and any other previous versions and the updated version. The versioning map creator can include local software or hardware components of the digital marketplace can be a web service or some other network accessible service having an application programming interface API for other devices to access the service or some combination thereof. The versioning map creator and the content position mapper can operate on the same device or on different devices as shown in . The content versioning system or versioning map creator creates the position maps while the content position mapper can translate any position data from one version to another using the position maps created by the content versioning system.

In some embodiments the versioning map creator and the content position mapper operate with the digital marketplace e.g. on one or more server machines that are part of the digital marketplace . For example user device can provide user annotations to the digital marketplace e.g. by periodically backing up the annotations to the digital marketplace and the digital marketplace can use the content position mapper to perform annotation migration for a new version prior to downloading the new version to the user device . Depending on the user preferences e.g. as specified in the user profile the annotations can be migrated automatically or upon receiving a confirmation from the user. For example before downloading the new version to the user device the digital marketplace can display a message on the screen of the user device asking whether the annotations should be migrated from the old version to the new version. In some embodiments the content position mapper distributes annotations of the user of the user device to other user devices e.g. in response to the user request or based on user preferences . For example the user of the user device may be a teacher who wants to distribute annotations to students operating the other devices .

In other embodiments the content position mapper operates on the user device . The content position mapper can operate on the user device if a backup annotation option is disabled on the user device to protect user privacy. The content position mapper may receive position maps from the digital marketplace the versioning map creator and use these position maps to perform annotation migration locally. Depending on user preferences the content position mapper can perform annotation migration automatically e.g. upon receiving a new version of content or when the user attempts to open the new version of content or upon receiving a confirmation from the user. The user may also request that his or her annotations be distributed to other devices .

While illustrates a simple operation of comparing two versions the versioning map creator can process multiple versions in series or in parallel. In one embodiment the versioning map creator takes an input version that is a most recent version of an eBook and generates forward and reverse maps for all previous versions of the eBook. In this way the versioning map creator can facilitate migration or distribution of annotations from one version of an eBook to any other version of an eBook. For example annotations created by a user operating on version 5 of an eBook can be migrated or shared using maps generated for all previous versions of the eBook to a second user operating on version 2 of the eBook as well as a third user operating on version 13 of the eBook.

The versioning map creator identifies differences between the two versions of content via a difference detection subsystem . In one embodiment the difference detection subsystem uses a difference algorithm e.g. a UNIX diff algorithm customized to compute differences between words of the book using a longest common subsequence of words. In another embodiment the difference detection subsystem uses a string comparison on a word by word basis. Identifying the longest common subsequence can be memory intensive so a more efficient implementation computes differences in subsequences chunks of N words such as 1 000 words thus improving the speed and memory footprint of the whole algorithm. However in some cases 1000 words may not provide sufficient context to compute a difference accurately. For example if a new chapter was inserted then the difference detection subsystem might improperly flag the new chapter as a misaligned chunk of 1000 words. For this reason the difference detection subsystem can automatically expand or shrink the chunk size up to a maximum value such as 10 000 words if the current chunk size has less similarity. When the chunk size reaches the maximum value and the difference is greater than a threshold the difference detection subsystem can stop calculating further differences and conclude that the two versions are completely different or that the content has drastically changed.

Computing differences by chunks can lead to misalignment if adjacent chunks are not stitched correctly together to account for insertions and deletions. Thus the difference detection subsystem can gracefully carry forward insertions deletions or changes from the previous difference iteration to the next so that they are a part of the next chunk.

In one embodiment the versioning map creator implements a word sequence alignment algorithm to avoid excessively computationally intensive difference calculations. The problem of aligning two different word sequences is somewhat similar to DNA sequence alignment so in another embodiment DNA sequence alignment can be applied to word alignment for content versioning in which instead of aligning character sequences the word sequent alignment algorithm aligns word sequences based on the similarity matrices of words. In one example the difference detection subsystem uses a Smith Waterman Sequence alignment algorithm customized for aligning word sequences and generating a word similarity matrix instead of character sequences. The difference detection subsystem can choose to use the more costly similarity matrix approach in addition to or as a substitute for the simpler difference algorithm in cases where the difference algorithm encounters difficulty in locating differences. A fuzzy string match algorithm that uses fuzzy word similarity matrix can approximate the alignment in these cases.

In some cases publishers use the same identifier to publish a completely new title which should ideally be not permitted as the metadata associated with the original content would not match the newly submitted content resulting in a poor customer experience. A customer would think they are buying the original title but would end up with different entirely new content. The difference detection subsystem can identify cases where the alignment between one version of content and another is below a similarity threshold. In these cases the difference detection subsystem can generate a message or error indicating that the versions are too different. A user or administrator or the content provider can then step in to identify or correct the problem.

After the difference detection subsystem has located the differences the difference transformation subsystem can transpose differences clean up the differences and identify transpositions and moves. The difference transformation subsystem can iterate over all differences to check if any differences are very close. For example if two differences are only a single character apart then the difference transformation subsystem can merge the two differences. The difference transformation subsystem can rely on a distance threshold to determine whether two differences are close enough to merge. The distance threshold can vary based on the size of the differences considered.

Merging close differences can be used to remove false matches such as when the largest common subsequence algorithm creates a false positive link between two texts having common words like this the when where etc. After the difference transformation subsystem removes false links the difference transformation subsystem iterates through all the differences and compares each delete from the old version to each insert in the new version to identify differences between them. If the difference transformation subsystem finds any matches the system can mark the difference as a case of transposition where the content is moved from one position to another.

Returning to the word alignment subsystem can align reference and comparison words using the transformed differences. Once the differences are detected computed cleaned up and transpositions identified the word alignment subsystem can iterate through the differences and generate an alignment of words between the old and the new version of the book. Depending on the type of difference such as insert delete change or transposition the word alignment subsystem aligns the stream of words from the old and new versions. For inserts and deletes the word alignment subsystem can align the word with a dummy word called NOMATCH that denotes the missing word in corresponding version or with some other indicator of a missing word such as a null value. Change differences are more complex and can involve treatment of several edge cases.

If the difference is an OCR error a typo or a very small replacement such as a change that is less than 3 words the word alignment subsystem can align the corresponding words directly. If the difference is a split word such as one word in the first version becomes multiple words in the updated version then the old word was likely split into multiple words due to an issue with missing whitespace or it was replaced by a set of other words. In this case the word alignment subsystem aligns the old word with all the new words in the change. If the difference is a merged word or multiple words deleted and replaced with a single one word inserted then the old words were likely replaced by one word or extra whitespace characters were removed. In this case the word alignment subsystem aligns the old words to the corresponding new word. If the change does not satisfy any of the above cases e.g. multiple words in the old version are changed to multiple words in the new revision which was not identified in the strict difference algorithm then the word alignment subsystem can use a sequence alignment algorithm to make a best effort to align these two word sequences. For transposition type changes the word alignment subsystem can align the deletion and insertion section using the word sequence alignment algorithm 212 so that they are aligned on a best effort basis.

After each word in the old version is aligned to the new version the position map generator can generate two position maps a forward map and a reverse map to accommodate the deletion and insertion differences in the correct direction. A forward map provides information for translating an annotation in the old version to the appropriate place in the new version. Likewise the reverse map provides information for translating an annotation in the new version to the appropriate place in the old version. The position map generator outputs the position of every word in the old revision along with the corresponding position of the new word in the alignment. If the new word is missing in cases of deletion the position map generator maps the old word to the previous closest word in the new revision in the reverse map. Similarly in case of insertion the position map generator maps the position of the new words to the closest word in the old revision in the reverse map. Insertions or deletions can be indicated by negative entries in the maps . Transpositions which contain insertion or deletion differences can be inserted or deleted inside the forward map or the reverse map at the closest word to the original location.

The position maps can then be used to cause the annotations to be transferred from the old document version to the new document version. In one embodiment this is achieved by the server performing the annotation transfer. In another embodiment this is achieved by sending the position maps to the user device which then performs the annotation transfer locally.

Returning to the user device can share annotations with other devices through the content position mapper even if the other devices have a different versions than the version in which the annotations were created on the user device . The annotations and other communications between the user device and the other devices can be transmitted via wired wireless or other connection. In some embodiments the content position mapper serves as a versioning service that allows users to share annotations across versions. For example a professor may need to share notes with students who have a different version of the textbook. Using the content position mapper as a versioning system the professor s device can map and share annotations such as notes or teaching supplements across versions. Without this versioning system shared annotations would be limited to single version of content.

In some embodiments the content position mapper is used to publish popular highlights. Popular highlights are created when highlight annotations are compiled from a group of customers on a content version and published to all users in the form of a downloadable sidecar or metadata package. The content position mapper avoids creating a unique sidecar for every version of content that customers own which can be a lot of duplicated effort and time as well as allows a highlight to be shared from one version of the content to another.

In some cases content providers publish portions of a book in serial fashion. The publisher considers the additional content not as new material or a separate book but rather as a continuation of existing content and intends to deliver this content as it is published to consumers. The content position mapper allows a publisher to publish and distribute the first version of a serial book and to continue to add new content to the title and redistribute the content while retaining annotations provided by the customer.

Alternately the annotation migration process can be performed on the user device . For example the user device can download one or more other versions of the content in addition to the latest version to facilitate mapping to other content versions or to use a document version for which a more direct mapping is available. The versioning map creator can abstract words and positions for a difference as a single entity represented as Word text position and store this data for each version and for each difference as position maps . For every pair of the latest version and the previous version of an eBook the versioning map creator can compute and align differences to generate forward and reverse position maps . Then when the user device requests a new version of the content the digital marketplace provides the appropriate position maps to the user device in addition to the new version of the content. The user device then uses the position maps to migrate the digital asset annotations to the new version of the content as discussed above.

The server receives a new document version corresponding to an old document version which may have user generated annotations. The server identifies a set of differences between the new document version and the old document version . illustrates a flow diagram of one embodiment of a method for identifying differences between new and old document versions. The server can identify differences by applying a difference algorithm to an old document version and a new document version using a chunk size and expanding the chunk size to provide additional context when the current chunk size provides insufficient context for the difference or when the difference is larger than the chunk size. If the chunk size expands to a maximum size such as 10 000 characters then the server can make a determination that the old document version and the new document version are either completely different or are too different to migrate annotations between . If the chunk size remains under the maximum size the server can use the differences detected in the words to enrich or modify an existing position map or to generate a new position map.

Next the server performs word alignments. In one embodiment the word alignments are performed by first determining the type for each difference. If the type for a respective difference is an insert or a delete the server aligns the respective difference with a dummy word indicating a missing word. If the type for the respective difference is a small replacement less than a word size threshold the server aligns corresponding words directly. If the type for the respective difference is a split word the server aligns an old word in the old version with new words in the new version and if the type for the respective difference is a merge word the server aligns old words in the old version with a new word in the new version.

Referring to the server generates a position map based on the word alignments that maps differences from the old document version to the new document version . illustrates a flow diagram of one embodiment of method for generating a position map. Each word in the old document version maps to a location word or other entity in the new document version . Then the server can generate a forward position map that maps each word in the old document version to a position in the new document version and vice versa so that a reverse position map maps each word in the new document version to a position in the old document version . The server can further link the forward and reverse position maps in a version mapping chain so that annotations can be easily migrated to earlier or later document versions by transforming the annotations through each position map in the chain in the proper direction.

Referring again to the server can further migrate the user generated annotations to the new document version based on the position map . illustrates a flow diagram of one embodiment of a method for migrating annotations from an old document version to a new document version. A user can generate for a document annotations locally on his or her device and the device transmits those annotations to the server such as for a backup or for sharing with others. The server can then process the annotations using various forward or reverse position maps and map the annotations to every other available version of the document or just to a subset of versions in circulation among client devices. In particular the server can extract locations of each of a set of annotations for an old document version and translate those locations to new locations in the new document version using the forward position map . When the locations are all translated the server can output the new locations as a new set of annotations for the new document version or can modify the existing annotations using the new locations. The server can optionally associate the new set of annotations with the new document version . In one embodiment the server can generate a sidecar file containing the annotations for a particular version or containing the annotations and maps for adapting the annotations to another version. The server can then provide to various client devices the sidecar file containing annotations specifically for the version of the document at the various client devices or a universal sidecar that includes annotations and the necessary maps or instructions for adapting the annotations to any version of the document. A sidecar can be a separate file that stores data or metadata associated with a particular file or document. A sidecar can be associated with the document based on file name metadata file extension or some other mechanism.

In another embodiment the server provides position maps to a user device when for example providing the new version to the user device or subsequently upon receiving a request for position maps from the user device. The user device may request position maps for the entire document version or for particular portions of the document version e.g. if the user is only interested in annotations for a text book chapter that was recently covered in class .

The user device can receive position maps extract locations of each of a set of annotations for an old document version and translate those locations to new locations in the new document version using the forward position map. When the locations are all translated the user device can output the new locations as a new set of annotations for the new document version or can modify the existing annotations using the new locations. The user device can then associate the new set of annotations with the new document version.

In some embodiments the user device uses the position maps to generate a list of changes between the old document version and the new document version and presents the list of changes to the user. The user can review the list of changes and decide whether to request the annotations to be migrated to the new version. For example if the changes are significant the user may not want the annotations to be migrated.

In some embodiments while migrating annotations from the old version to the new version the user device can detect that an annotated section from the old version is no longer present in the new version. The user device can notify the user that the annotated section is not present in the new version and can optionally display this section and the associated annotations. The user device can also ask the user e.g. by displaying a list of selectable options on the screen of the user device to specify whether the annotations should be disregarded or added to a different section of the new document version.

In some embodiments the user device can generates a list of annotations that have been migrated to the new document version and a list of annotations that have not been migrated to the new document version e.g. if a corresponding section was no longer present in the new document version . The user device can present these lists to the user and can allow the user to modify the migrated annotations. For example the user may request to remove some annotations or to move some annotations from one section to another section in the new document version.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processing device is configured to execute processing logic e.g. instructions for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse other user input device such as a touch screen or a microphone and a signal generation device e.g. a speaker .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions embodying any one or more of the methodologies or functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine readable storage media.

The computer readable storage medium may also be used to store instructions which may correspond to the content position mapper m of and or a software library containing methods that call a content position mapper . While the computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present set forth herein. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as receiving identifying generating migrating transmitting determining instructing or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present disclosure also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The present disclosure may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the principles disclosed herein. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium such as a read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the description includes references to specific exemplary embodiments it will be recognized that the disclosure is not limited to the embodiments described but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the disclosure should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

