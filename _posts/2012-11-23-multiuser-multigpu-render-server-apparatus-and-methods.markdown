---

title: Multi-user multi-GPU render server apparatus and methods
abstract: The invention provides, in some aspects, a system for rendering images, the system having one or more client digital data processors and a server digital data processor in communications coupling with the one or more client digital data processors, the server digital data processor having one or more graphics processing units. The system additionally comprises a render server module executing on the server digital data processor and in communications coupling with the graphics processing units, where the render server module issues a command in response to a request from a first client digital data processor. The graphics processing units on the server digital data processor simultaneously process image data in response to interleaved commands from (i) the render server module on behalf of the first client digital data processor, and (ii) one or more requests from (a) the render server module on behalf of any of the other client digital data processors, and (b) other functionality on the server digital data processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09355616&OS=09355616&RS=09355616
owner: PME IP PTY LTD
number: 09355616
owner_city: Richmond
owner_country: AU
publication_date: 20121123
---
This application is a continuation of U.S. application Ser. No. 12 275 421 filed Nov. 21 2008 which claims the benefit of priority of U.S. Patent Application Ser. No. 60 989 881 filed Nov. 23 2007 the teachings of which are incorporated herein by reference.

The invention pertains to digital data processing and more particularly by way of example to the visualization of image data. It has application to areas including medical imaging atmospheric studies astrophysics and geophysics.

3D and 4D image data is routinely acquired with computer tomographic scanners CT magnetic resonance imaging scanners MRI confocal microscopes 3D ultrasound devices positron emission tomographics PET and other imaging devices. The medical imaging market is just one example of a market that uses these devices. It is growing rapidly with new CT scanners collecting ever greater amounts of data even more quickly than previous generation scanners. As this trend continues across many markets the demand for better and faster visualization methods that allow users to interact with the image data in real time will increase.

Standard visualization methods fall within the scope of volume rendering techniques VRT shaded volume rendering techniques sVRT maximum intensity projection MIP oblique slicing or multi planar reformats MPR axial sagittal and coronal slice display and thick slices also called slabs . In the following these and other related techniques are collectively referred to as volume rendering. In medical imaging for example volume rendering is used to display 3D images from 3D image data sets where a typical 3D image data set is a large number of 2D slice images acquired by a CT or MRI scanner and stored in a data structure.

The rendition of such images can be quite compute intensive and therefore can take a long time on a standard computer especially when the data sets are large. Too long compute times can for example prevent the interactive exploration of data sets where a user wants to change viewing parameters such as the viewing position interactively which requires several screen updates per second typically 5 25 updates second thus requiring rendering times of fractions of a second or less per image.

Several approaches have been taken to tackle this performance problem. Special purchase chips have been constructed to implement volume rendering in hardware. Another approach is to employ texture hardware built into high end graphics workstations or graphics super computers such as for example Silicon Graphics Onyx computers with Infinite Reality and graphics. More recently standard graphics boards such as NVIDIA s Geforce and Quadro FX series as well as AMD ATI s respective products are also offering the same or greater capabilities as far as programmability and texture memory access are concerned.

Typically hardware for accelerated volume rendering must be installed in the computer e.g. workstation that is used for data analysis. While this has the advantage of permitting ready visualization of data sets that are under analysis it has several drawbacks. First of all every computer which is to be used for data analysis needs to be equipped with appropriate volume rendering hardware as well as enough main memory to handle large data sets. Second the data sets often need to be transferred from a central store e.g. a main enterprise server where they are normally stored to those local Workstations prior to analysis and visualization thus potentially causing long wait times for the user during transfer.

Several solutions have been proposed in which data processing applications running on a server are controlled from a client computer thus avoiding the need to equip it with the full hardware needed for image processing visualization and also making data transfer to the client unnecessary. Such solutions include Microsoft s Windows 2003 server with the corresponding remote desktop protocol RDP Citrix Presentation Server VNC or SGI s OpenGL Vizserver. However most of these solutions do not allow applications to use graphics hardware acceleration. The SGI OpenGL Vizserver did allow hardware accelerated graphics applications to be run over the network it allocated an InfiniteReality pipeline to an application controlled over the network. However that pipeline could then not be used locally any longer and was also blocked for other users. Thus effectively all that the Vizserver was doing was extending a single workplace to a different location in the network. The same is true for VNC.

For general graphics applications i.e. not specifically volume rendering applications such as computer games solutions have been proposed to combine two graphics cards on a single computer i.e. the user s computer in order to increase the rendering performance specifically NVIDIA s SLI and AMD ATI s Crossfire products. In these products both graphics cards receive the exact same stream of commands and duplicate all resources such as textures . Each of the cards then renders a different portion of the screen or in another mode one of the cards renders every second image and the other card renders every other image. While such a solution is transparent to the application and therefore convenient for the application developers it is very limited too. Specifically the duplication of all textures effectively eliminates half of the available physical texture memory.

An object of the invention is to provide digital data processing methods and apparatus and more particularly by way of example to provide improved such methods and apparatus for visualization of image data.

A still further object of the invention is to provide such methods and apparatus for rendering images as have improved real time response to a user s interaction.

Yet a still further object of the invention is to provide such methods and apparatus as allow users to interactively explore the rendered images.

The aforementioned are among the objects attained by the invention which provides in one aspect a graphics system including a render server that has one or more graphics boards in one or more host systems. One or more client computers can simultaneously connect to the render server which receives messages from the client computers creates rendered images of data set and sends those rendered images to the client computers for display.

Related aspects of the invention provide a graphics system for example as described above in which rendered data sets are kept in memory attached to the render server such as RAM memory installed in the host systems e.g. for reuse in response to subsequent messaging by the client computers.

Further related aspects of the invention provide a graphics system for example as described above in which the render server maintains a queue of so called render requests i.e. a list of images to render. These can comprise render requests received directly in messages from the client computers and or they can comprise requests generated as a result of such messages. One message received from the client computer can result in zero one or multiple render requests being generated.

A further aspect of the invention provides a graphics system for example of the type described above in which the render server breaks down selected render requests into multiple smaller requests i.e. requests which require less compute time and or less graphics resources. A related aspect of the invention provides for scheduling the smaller and other requests so as to minimize an average time that a client computer waits for a response to a request. This allows by way of non limiting example for concurrent treatment of requests and for serving multiple client computers with a single GPU without compromising interactivity.

Another aspect of the invention provides a graphics system For example of the type described above that processes render requests in an order determined by a prioritization function that takes into account the nature of the request e.g. interactive rendering vs. non interactive the client from which the request was received the order in which the requests were received the resources currently allocated on the graphics boards and or other parameters.

Yet another aspect of the invention provides a graphics system for example of the type described above that processes multiple render requests simultaneously. The render server of such a system can for example issue multiple render commands to a single graphics board and process them in time slices in a manner analogous to a multi tasking operating system on a CPU thereby switching between processing different render requests multiple times before a single render request is completed.

A related aspect of the invention provides a system for example as described above wherein the render server combines render requests for simultaneous processing in such a way that their total graphics resource requirements can be satisfied by resources e.g. texture and frame buffer memory on board a single graphics board. This allows by way of example time slicing between the simultaneously processed render requests without the computationally expensive swapping of graphics memory chunks in and out of main memory of the host i.e. host memory .

Another aspect of the invention provides a graphics system for example of the type described above that renders images at different resolution levels e.g. rendering a low resolution image from a low resolution version of the input data while rotating the data set thus enabling faster rendering times and thereby smoother interaction. A related aspect of the invention provides such a system that adapts the resolution to the network speed and or the available processing resources. Another related aspect of the invention provides such a system wherein the render server continuously monitors one or more of these parameters and thereby allows for continuous adaptation of the resolution.

Another aspect of the invention provides a graphics system for example of the type described above wherein the render server keeps local resources such as texture memory on one of the graphics boards allocated for the processing of a particular set of related render requests. Related aspects of the invention provide for example for re use of such allocated resources for the processing of a subsequent render request in the set thus eliminating the need to re upload the data from host memory to texture memory for such subsequent render requests. By way of example the render server of such a system can keep the texture memory of a graphics board allocated to the rendition of interactive render requests for low resolution versions of a data set e.g. user driven requests for rotation of the data set which need to be processed with a minimal latency to allow for smooth interaction but only require a small amount of texture memory.

Another aspect of the invention provides a graphics system for example of the type described above wherein the render server dispatches render commands to different graphics boards. A related aspect provides such a system that takes into account the data sets resident on these different graphics boards and uses this information to optimize such dispatching.

Further aspects of the invention provide systems employing combinations of the features described above.

Further aspects of the invention provide methods for processing images that parallel the features described above.

These and other aspects of the invention are evident in the drawings and in the description that follows.

One or more client computers or client digital data processors are coupled to render server for communications via the networks . Client software running on each of the client computers allows the respective client computers to establish a network connection to render server on which server software is running. As the user interacts with the client software messages are sent from the client computers to the render server . Render server generates render commands in response to the messages further processing the render requests to generate images or partial images which are then sent back to the respective client computers for further processing and or display.

The make up of a typical such client computer is shown by way of example in the break out on . As illustrated client computer includes CPU dynamic memory RAM input output section and optional graphics processing unit all configured and operated in the conventional manner known in the art as adapted in accord with the teachings hereof.

The components illustrated in comprise conventional components of the type known in the art as adapted in accord with the teachings hereof. Thus by way of non limiting example illustrated render server and client computers comprise conventional workstations personal computers and other digital data processing apparatus of the type available in the market place as adapted in accord with the teachings hereof.

It will be appreciated that the system of illustrates just one configuration of digital data processing devices with which the invention may be practiced. Other embodiments may for example utilize greater or fewer numbers of client computers networks networking apparatus e.g. switches or hubs and so forth. Moreover it will be appreciated that the invention may be practiced with additional server digital data processors. Still further it will be appreciated that the server digital data processor may itself function at least in part in the role of a client computer e.g. generating and servicing its own requests and or generating requests for servicing by other computers and vice versa.

In the following section we describe the render server in more detail and how it is used to perform volume rendering.

GPU boards can be connected to other system components and namely for example to CPUs using the PCI Express bus but other bus systems such as PCI or AGP can be used as well by way of non limiting example. In this regard standard host mainboards exist which provide multiple PC Express slots so that multiple graphics cards can be installed. If the host system does not have sufficient slots a daughter card can be used e.g. of a type such as that disclosed in co pending commonly assigned U.S. patent application Ser. No. 11 129 123 entitled Daughter Card Approach to Employing Multiple Graphics Cards Within a System the teachings of which are incorporated herein by reference . Alternatively or in addition such cards can be provided via external cable connected cages.

Each graphics board has amongst other components local on board memory coupled as shown referred to elsewhere herein as graphics memory Graphics Memory texture memory and the like and a graphics processing unit GPU . In order to perform volume rendering of a data set the data set or the portion to be processed preferably resides in graphics memories .

The texture or graphics memory is normally more limited than host memory and often smaller than the total amount of data to be rendered specifically for example as in the case of the illustrated embodiment if render server is used by multiple users concurrently visualizing different data sets. Therefore not all data needed for rendering can at least in the illustrated embodiment be kept on graphics boards .

Instead in the illustrated embodiment in order to render an image the respective portion of the data set is transferred from either an external storage device or more typically host memory into the graphics memories via the system bus . Once the data is transferred commands issued to GPUs by Render Server Software described below cause it to render an image with the respective rendering parameters. The resulting image is generated in graphics memories on graphics boards and once finished can be downloaded from graphics boards i.e. transferred into host memory and then after optional post processing and compression be transferred via network interfaces to client computers .

The components of host may be interconnected by a system bus as shown. Those skilled in the art will appreciate that other connections and interconnections may be provided as well or in addition.

The process described above as well as aspects described subsequently is controlled by software more specifically software running on Render Server Render Server Software and software running on client computers Client Software . The Render Server Software handles network communication data management actual rendering and other data processing tasks such as filtering by way of employing CPUs GPUs or a combination thereof. The Client Software is responsible for allowing the user to interact for example to choose a data set to visualize to choose render parameters such as color data window or the view point or camera position when e.g. rotating the data set. The client software also handles network communication with render server and client side display.

In the following we describe one way how the Render Server Software and Client Software can be implemented. In this regard see for example steps . A component of the Render Server software listens for incoming network connections. Once a client computer client computer attempts to connect the Render Server Software may accept or reject that connection potentially after exchanging authentication credentials such as a username and password and checking whether there are enough resources available on the render server. The Render Server software listens on all established connections for incoming messages. This can be implemented for example by a loop sequentially checking each connection or by multiple threads one for each connection possibly being executed simultaneously on different CPUs or different CPU cores. Once a message is received it is either processed immediately or added to a queue for later processing. Depending on the message type a response may be sent. Examples for message types are i Request for a list of data sets available on the server potentially along with filter criteria ii Request to load a data set for subsequent rendering m Request to render a data set with specified rendering parameters and a specified resolution level iv Message to terminate a given connection v message to apply a filter for example noise removal or sharpening etc.

In the illustrated embodiment a component e.g. software module within the Render Server Software prioritizes the requests added to the queue of pending requests thereby determining the order in which they are executed. Other such components of the illustrated embodiment alter requests in the queue i.e. remove requests which are obsoleted or break down requests into multiple smaller ones see step . In these and other embodiments still another such component of the Render Server Software determines which resources are used to process a request. Other embodiments may lack one or more of these components and or may include additional components directed toward image rendering and related functions.

When the Render Server Software handles a render request by way of using the GPU it transfers the data set in question or as is discussed below portions of it into the local Graphics Memory via the system bus then issues the commands necessary to create a rendered image and then transfers back the rendered image into main memory for subsequent processing and network transfer. Even a single data set can exceed the size of the graphics memory. In order to render such a data set efficiently it is broken down into smaller pieces which can be rendered independently. We refer to this process as bricking. As discussed later the ability to break down one render request into multiple smaller requests where smaller can mean that less graphics memory and or less GPU processing time is required is also helpful for efficiently handling multiple requests concurrently.

We now describe how such a break down can be performed. As an example we first discuss the MIP rendering mode though it will be appreciated that such a methodology can be used with other rendering modes. The 3D data set can be viewed as a cuboid in three space consisting of a number of voxels carrying gray values. depicts that data volume viewed from a certain camera position by way of displaying a bounding box. Referring to which illustrates a method for bricking according to one practice of the invention for a given camera position each pixel on a computer screen screen pixel can be associated with a viewing ray. See step . The voxels intersected by each such viewing ray which intersects the cuboid are then determined. See step . In the MIP rendering mode the screen pixel is assigned the maximum gray value of any of the voxels which the viewing ray corresponding to the screen pixel intersects. See step . The resulting rendered image can be seen in .

If the Render Server Software subdivides the original data volume into multiple smaller data volumes for example if it divides the data volume into four sub volumes then each of the sub volumes can be rendered independently thus effectively producing four rendered images. See steps and . The subdivision for this example is illustrated in by way of showing the bounding boxes of the four sub volumes. shows the individual MIP rendition of each of the four sub volumes for an example data set depicting a Magnet Resonance Angiography image. For better orientation the bounding box of the original data volume is shown as well. If the rendered images are then composed in such a way that for each pixel in the composed image the brightest value for that pixel from the four rendered images is chosen see step then the resulting composed image which is shown in is identical to the MIP rendition of the full data set seen in .

Using the correct composition function the same break down approach can be used for other rendering modes as well. For example for VRT mode standard alpha blending composition can be used i.e. for each pixel of the resulting image the color and opacity is computed as follows. The sub images are blended over each other in back to front order one after the other using the formula c result I 1 a front c back a front c front where a front and c front denote the opacity and color of the front picture respectively and c back denotes the color of the back picture. As those skilled in the art will appreciate other schemes such as front to back or pre multiplied alpha may be used with the respective formulas found in general computer graphics literature. The resulting image for VRT rendering is shown in .

The time it takes to render an image depends on several criteria such as the rendering mode the resolution i.e. number of pixels of the rendered target image and the size of the input data set. For large data sets and high resolution renditions rendering can take up to several seconds even on a fast GPU. However when a user wants to interactively manipulate the data set i.e. rotate it on the screen multiple screen updates per second typically 5 25 updates second are required to permit a smooth interaction. This means that the rendition of a single image must not take longer than few hundred milliseconds ideally less than 100 milliseconds.

One way to ensure smooth rendering during users interactive manipulations of data sets is by rendering images at a resolution according to the level of a user s interaction. One way to guarantee this is illustrated in . Here by way of example the system checks whether the user is rotating the data set see Step .

If so the render server uses a lower resolution version of the input data and renders the images at a lower target resolution. See steps and . Once the user stops interacting e.g. by releasing the mouse button a full resolution image is rendered with the full resolution data set and the screen is updated with that image potentially a few seconds later. See steps and . Schemes with more than two resolutions can be used in the same way.

In the subsequent discussion we refer to the above scenario to illustrate certain aspects of the invention. We refer to the low resolution renderings as interactive render requests and to the larger full resolution renditions as high resolution render requests . The methodologies described below are not restricted to an interaction scheme which uses two resolutions in the way described above.

In order to build an effective multi user multi GPU render server another component of the Render Server Software is provided which dispatches schedules and processes the render requests in a way that maximizes rendering efficiency. For example the number of client computers which can access the render server concurrently may not be limited to the number of GPUs. That is two or more clients might share one GPU. Render requests received by such clients therefore need to be scheduled. This section describes some factors that may be considered for the scheduling and illustrates why a trivial scheduling may not be sufficient in all cases.

In one example the smaller render requests A1 . . . A5 and B1 . . . B5 are interactive render requests e.g. requests received while the user is rotating the data set while C1 may be a high resolution render request. By way of example the interactive render requests might require 50 ms to process while the high resolution render request might take 2 seconds to render. If only one GPU was available to handle these render requests and if the render requests were scheduled in a trivial way on a first come first serve basis the result would not yield a good user experience. illustrates such a case where request A1 is processed first followed by C1 B1 A2 While render request C1 is processed which in this example is assumed to take 5 seconds no render requests for client A and client B would be processed. However this example assumes that the users using client A and client B are at this given time interactively manipulating e.g. rotating the data sets. Therefore if those clients would not receive a screen update for 2 seconds the interaction would stall prohibiting a smooth and interactive user experience.

An alternative strategy of not processing any high resolution render requests as long as any interactive render requests are still pending also would not be optimal. If in the above example the users using clients A or B rotated their data sets for a longer period of time. e.g. half a minute or longer then during that time they would constantly generate render requests effectively prohibiting the request from client C to be processed at all until both other users have completed their interaction . This is also not desired.

Methods of improved scheduling to reduce average wait time for a response to a client computer s render request are needed. We are now going to describe two alternative strategies for a better scheduling and will later describe how a combination of both leads to even better results.

The first strategy illustrated in involves the situation where large render requests are broken down into multiple smaller render requests which are processed individually. For example here request C1 is broken down into multiple smaller requests. Once this is done those smaller requests can be scheduled more flexibly for example as shown in . Such a scheduling has the advantage that none of the clients would see any significant stalling only a somewhat reduced rate of screen updates per second. Still however also the high resolution render request would not be postponed indefinitely but be processed in a timely manner.

The second strategy is to issue multiple render commands to the same graphics board simultaneously i.e. issue a first command e.g. in response to a request received from a first client computer and then issue a second command e.g. in response to a request received from a second client computer before the first request is completed. Preferably this is done so as to interleave commands that correspond to different respective client requests so that the requests are processed in smaller time slices in an alternating fashion.

This can be done in multiple ways. One way is to use multiple processes or multiple threads each rendering using the same graphics board. In this case the operating system and graphics driver respectively handle the simultaneous execution of the requests. In fact of course the execution is not really simultaneous but broken down into small time slices in which the requests are processed in an alternating fashion. The same can be achieved by a single thread or process issuing the primitive graphics commands forming the render requests in an alternating fashion thereby assuring that texture bindings and render target assignments are also switched accordingly.

The reason why it may be advantageous to issue multiple render commands simultaneously in contrast to a fully sequential processing as depicted e.g. in is two fold. First it can be the case that even after breaking down larger render requests into smaller ones each request may still take more processing time than one would like to accept for stalling other smaller interactive requests. Second a graphics board is a complex sub system with many different processing and data transfer units some of which can work in parallel. Therefore certain aspects of two or more render requests being processed simultaneously can be executed truly simultaneously e.g. while one render request consumes the compute resources on the GPU the other consumes data transfer resources. Thus executing the two requests simultaneously may be faster than executing them sequentially. Additionally although the GPU simultaneously processes render commands issued by the render server CPU on behalf of multiple remote client computers the GPU may also simultaneously process render requests or other requests issued by or on behalf of other functionality e.g. requests issued by the render server CPU on behalf of a local user operating the server computer directly .

Another aspect taken into account by the Render Server Software when issuing render requests simultaneously is the total graphics resource consumption. If the sum of required graphics memory for all simultaneously processed render requests would exceed the total graphics resources on the graphics board then a significant performance decrease would be the consequence. The reason is that whenever the operating system or graphics driver switched from execution of request 1 to request 2 then first the data required for the processing of request 1 would have to be swapped out from graphics memory to host memory to make room for the data needed for request 2. Then the data needed for the processing of request 2 would have to be swapped in from host memory into graphics memory. This would be very time consuming and inefficient.

The Render Server Software additionally implements schemes to take advantage of data persistency during scheduling and or dispatching of requests. Very often subsequent render requests use some of the same data. For example if a user rotates a data set then many different images will be generated all depicting the same input data set only rendered from different viewing angles. Therefore if one request has been processed it can be of advantage to not purge the input data from the graphics memory but instead keep it persistent in anticipation of a future render request potentially requiring the same data. As illustrated in in this way a repeated data upload from host memory into graphics memory can be avoided. See step .

In single GPU systems a scheduler component of the Render Server Software may take data persistency into account and re arrange the order of requests in such a way as to optimize the benefit drawn from persistency. In the case of for example the scheduler might rearrange the order of the requests so that render request 3 is processed immediately subsequent to render request 1.

In a multi GPU system on the other hand the dispatcher component of the Render Server Software takes persistency into account when deciding which GPU to use to satisfy a specific render request. For example as mentioned above and depicted in render requests in multi GPU systems are typically dispatched to all of the GPUs following the same basic scheme as described above. See step . To take advantage of data persistency the dispatcher component attempts to dispatch the current request to a graphics processing unit in which the data set specified by the request is stored. See steps and . This will often lead to subsequent interactive render requests from the same client computer being handled by the same GPUs.

But not all render requests need to be executed on the GPUs. Depending on resource use and the type of request it may also be feasible to use one or more CPU cores on one or more CPUs to process a render request or a combination of CPU and GPU. For example rendering requests For MPR mode and oblique slicing can be executed on the CPU unless the data required is already on the GPU. See steps and

Rendering requests are only one example. As those skilled in the art will appreciate the described embodiment can also be used in the same way to perform other data processing tasks such as filtering feature detection segmentation image registration and other tasks.

Described above are methods and systems meeting the desired objects among others. It will be appreciated that the embodiments shown and described herein are merely examples of the invention and that other embodiments incorporating changes therein may fall within the scope of the invention.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor further comprises one or more central processing units in communications coupling with the render server the one or more central processing units processing image data in response to plural interleaved commands from the render server.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor comprises a host memory in communications coupling with the render server the host memory storing one or more data sets to be rendered.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor comprises one or more queues in communications coupling with the render server and with the one or more graphics processing units and the render server maintaining render requests in the one or more queues.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor comprises one or more queues in communications coupling with the render server and with the one or more graphics processing units and the render server maintaining render requests in the one or more queues wherein the render server prioritizes render requests in the one or more queues.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor comprises one or more queues in communications coupling with the render server and with the one or more graphics processing units and the render server maintaining render requests in the one or more queues wherein the render server prioritizes render requests in the one or more queues wherein the render server prioritizes a said render request based on at least one of a rendering mode associated with that render request a client digital data processor associated with that render request an order of receipt of that render request and available resources.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the server digital data processor comprises one or more queues in communications coupling with the render server and with the one or more graphics processing units and the render server maintaining render requests in the one or more queues wherein the render server breaks down a said render request in a said queue into plural smaller render requests.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server breaks down requests received from the one or more client digital data processors into multiple smaller render requests each requiring less compute time and or less graphics resources than the render request from which it was broken down.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server schedules one or more of the smaller requests to minimize an average wait time.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein a said graphics processing unit renders an image at a rendering resolution determined by one or more parameters including at least one of a user interaction type a network speed and available processing resources.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein a said graphics processing unit renders an image at a rendering resolution determined by one or more parameters including at least one of a user interaction type a network speed and available processing resources wherein the render server monitors at least one of user interaction type network speed and available processing resources and generates said one or more parameters in response thereto.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server allocates at least a portion of one or more server digital data processor resources in response to one of the render requests.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server allocates at least a portion of one or more server digital data processor resources in response to one of the render requests wherein the one or more server digital data processor resources comprise a graphics memory that is coupled to any of said one or more graphics processing. units.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server allocates at least a portion of one or more server digital data processor resources in response to one of the render requests wherein the one or more server digital data processor resources comprise a graphics memory that is coupled to any of said one or more graphics processing wherein the render server allocates as a said digital data processor resource a said graphics memory having a data set specified by a said request.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein the render server allocates at least a portion of one or more server digital data processor resources in response to one of the render requests wherein the one or more server digital data processor resources comprise a graphics memory that is coupled to any of said one or more graphics processing wherein the render server allocates as a said digital data processor resource a said graphics memory having a data set specified by a said request wherein the render server causes a said graphics memory to maintain a said data set.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units and a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion wherein a said graphics processing unit concurrently renders images in response to the one or more interleaved commands each of the commands associated with a different request by using one of multi processing or multi threading.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion and the render server breaking down render requests received from the one or more client digital data processors into multiple smaller render requests each requiring less compute time and or less graphics resources than the render request from which it was broken down.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server responding to a render request from a said client digital data processor by issuing one or more render commands to the one or graphics processing units where the render server responds to render requests from a plurality of said client digital data processors by issuing interleaved render commands to the one or more graphics processing units so that commands corresponding to different respective render are processed by the one or more graphics processing units in an alternating fashion and the render server breaking down render requests received from the one or more client digital data processors into multiple smaller render requests each requiring less compute time and or less graphics resources than the render request from which it was broken down wherein the render server breaks down render requests so that the amount of memory required for concurrent rendering of the smaller render requests generated as a result thereof is less than or equal to the amount of memory available on the graphics processing unit.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising storing one or more data sets in a host memory associated with the server digital data processor.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising maintaining requests received from one or more said client digital data processors in one or more queues associated with the server digital data processor such maintaining including any of prioritizing the requests removing requests and or breaking down one or more requests into two or more smaller requests.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising maintaining requests received from one or more said client digital data processors in one or more queues associated with the server digital data processor such maintaining including any of prioritizing the requests removing requests and or breaking down one or more requests into two or more smaller requests wherein the prioritizing step includes any of prioritizing a said render request based on at least one of a rendering mode associated therewith a client associated therewith an order of receipt thereof and available resources.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising maintaining requests received from one or more said client digital data processors in one or more queues associated with the server digital data processor such maintaining including any of prioritizing the requests removing requests and or breaking down one or more requests into two or more smaller requests comprising breaking down render requests received from one or more client digital data processors into multiple smaller render requests each requiring less compute time and or fewer graphics resources than the request from which it was broken down.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising scheduling one or more of the smaller requests to minimize an average wait time.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising maintaining requests received from one or more said client digital data processors in one or more queues associated with the server digital data processor such maintaining including any of prioritizing the requests removing requests and or breaking down one or more requests into two or more smaller requests comprising breaking down render requests received from one or more client digital data processors into multiple smaller render requests each requiring less compute time and or fewer graphics resources than the request from which it was broken down wherein the rendering step comprises rendering images with the one or more graphics processing units in response to interleaved commands that are based on the multiple smaller render requests.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising maintaining requests received from one or more said client digital data processors in one or more queues associated with the server digital data processor such maintaining including any of prioritizing the requests removing requests and or breaking down one or more requests into two or more smaller requests comprising breaking down render requests received from one or more client digital data processors into multiple smaller render requests each requiring less compute time and or fewer graphics resources than the request from which it was broken down wherein the rendering step comprises rendering images with the one or more graphics processing units in response to interleaved commands that are based on the multiple smaller render requests comprising processing with the one or more graphics processing units multiple interleaved commands each based on smaller requests broken down from a said render request received from the one or more client digital data processors before completing rendering of an image associated with any such received request.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising rendering with a said graphics processing unit an image at a rendering resolution determined by one or more parameters including at least one of a user interaction type a network speed and available processing resources.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising allocating at least a portion of one or more server digital data processor resources in response to one or more requests received from a said client digital data processor.

A method for rendering images comprising executing on a server digital data processor a render server issuing one or more interleaved commands with the render server in response to one or more render requests from one or more client digital data processors and rendering images with one or more graphics processing units in response to the interleaved commands from the render server on behalf of the one or more client digital data processors comprising allocating at least a portion of one or more server digital data processor resources in response to one or more requests received from a said client digital data processor comprising allocating as a said server digital data processor resource a graphics memory that is coupled to any of said one or more graphics processing units.

A system for rendering images comprising one or more client digital data processors a server digital data processor in communications coupling with the one or more client digital data processors the server digital data processor comprising one or more graphics processing units a render server executing on the server digital data processor and in communications coupling with the graphics processing units the render server issuing one or more interleaved commands in response to one or more render requests from one or more client digital data processors and one or more graphics processing units rendering images in response to the one or more interleaved commands from the render server on behalf of the one or more client digital data processors.

