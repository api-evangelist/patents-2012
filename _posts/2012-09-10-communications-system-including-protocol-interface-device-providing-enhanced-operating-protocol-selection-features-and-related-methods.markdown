---

title: Communications system including protocol interface device providing enhanced operating protocol selection features and related methods
abstract: A communications system may include data storage devices each using at least one of a plurality of different operating protocols. Further, at least one of the data storage devices may operate using multiple operating protocols. The system may also include mobile wireless communications devices for accessing the at least one data storage device, and each may use at least one of the plurality of operating protocols. Moreover, the system may further include a protocol interface device. The protocol interface device may include a front-end proxy module for communicating with the plurality of mobile wireless communications devices using respective operating protocols. The protocol interface may also include a protocol engine module for communicating with the data storage devices using respective operating protocols. The protocol engine module may also select a desired operating protocol for communicating with the at least one data storage device from the multiple operating protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08463864&OS=08463864&RS=08463864
owner: Teamon Systems, Inc.
number: 08463864
owner_city: Wilmington
owner_country: US
publication_date: 20120910
---
This application is a continuation of Ser. No. 13 210 872 filed Aug. 16 2011 now U.S. Pat. No. 8 285 805 issued Oct. 9 2012 which in turn is a continuation of Ser. No. 10 777 731 filed Feb. 12 2004 now U.S. Pat. No. 8 028 078 issued Sep. 27 2011 and claims the benefit of U.S. Provisional Application Nos. 60 493 165 and 60 493 163 filed Aug. 7 2003 all of which are hereby incorporated herein in their entireties by reference.

The present invention relates to the field of communications systems and more particularly to communications systems using multiple operating protocols for data access operations and related methods.

Software clients operating on or in conjunction with a computer system are often used to access data stored at a server with which the computer system can establish communications such as through a local area network LAN . Clients are typically configured so that data on a data system is accessed using a particular protocol that is supported by the client. However some data storage devices are also accessible through other protocols each of which may support different features.

In an electronic mail e mail system for example in which users have respective mailboxes on a mail server a mailbox might be accessible using Outlook Web Access OWA Internet Mail Access Protocol IMAP or Post Office Protocol POP . Although a user might have configured an e mail client to access his or her mailbox using POP mailbox access using the more capable OWA and IMAP which provide more advanced features than POP may be desired when another client is used or when multiple mailboxes that support different protocols are to be accessed for example.

Various prior art approaches have been developed for providing communications between systems and devices using different operating protocols. One such approach is set forth in U.S. Pat. No. 6 615 212 to Dutta et al. in which a transcoding proxy server receives a request for content from a client machine. The transcoding proxy server retrieves the content from an originating server. The retrieved content is provided in a first format type. In response to a determination that an increase in efficiency would be obtained by allowing the client to process the content in the first format type prior to transcoding the content into a second format type the transcoding proxy server sends the content to the client in the first format type.

Furthermore in response to a determination that the client does not have content processing software for processing the content in the first format the transcoding proxy server sends content processing software for the first format type along with the content in the first format type to the client. The transcoding proxy server then transcodes the content from the first format type into the second format type and sends the content in the second format to the client.

Despite such prior art approaches further protocol translation and or conversion functionality may be desirable in certain applications.

In view of the foregoing background it is therefore an object of the present invention to provide a communications system providing enhanced operating protocol conversion features and related methods.

This and other objects features and advantages in accordance with the present invention are provided by a communications system which may include a plurality of data storage devices each using at least one of a plurality of operating protocols. Further at least one of the data storage devices may operate using multiple operating protocols. The system may also include a plurality of mobile wireless communications devices for accessing the at least one data storage device and each may use at least one of the plurality of operating protocols.

Moreover the system may further include a protocol interface device. The protocol interface device may include a front end proxy module for communicating with the plurality of mobile wireless communications devices using respective operating protocols. The protocol interface may also include a protocol engine module for communicating with the plurality of data storage devices using respective operating protocols. The protocol engine module may also select a desired operating protocol for communicating with the at least one data storage device from the multiple operating protocols.

More particularly the protocol engine module may select the desired operating protocol based upon a ranking of the plurality of operating protocols. Moreover the ranking may be based upon protocol supported elements associated with the various protocols. By way of example the operating protocols may be electronic mail e mail protocols such as Outlook Web Access OWA Internet Mail Access Protocol IMAP and the Post Office Protocol POP . As such the protocols may be ranked based upon their respective protocol supported elements or features. Thus OWA would typically be ranked higher than POP based the number of elements or features each supports and the protocol engine module would use this ranking when selecting between the two.

In addition the protocol interface device may further include a memory connected to the protocol engine module for storing per account information associated with each mobile wireless communications device. For example the per account information may relate to the various protocol s supported by each mobile wireless communications device. Thus the protocol engine module may not only base its selection of the desired protocol upon the protocol ranking but it may also do so based upon the capabilities of a given mobile wireless communications device.

Furthermore the front end proxy module and the protocol engine module may advantageously communicate using a common interface protocol able to represent a desired number of protocol supported elements for a desired operating protocol. More particularly the common interface protocol may be able to represent all protocol supported elements for a most capable operating protocol. Thus using the above example in which OWA is the most capable protocol the common interface protocol would support all of the elements or features of OWA although it may support other features as well. By way of example the common interface protocol may be based upon a Web based distributed authoring and versioning WebDAV protocol.

The plurality of data storage devices the plurality of mobile wireless communications devices and the protocol interface device may process electronic mail e mail messages for example. Also the mobile wireless communications devices may send access requests and the data storage devices may send data e.g. e mail data responsive to access requests. Additionally one or more of the data storage devices may respond to an access request with a root folder and target e mailbox capabilities.

The protocol interface may generate an error responsive to at least one non supported operating protocol. Furthermore the communications system may also include a wide area network WAN e.g. the Internet connecting at least one of the mobile wireless communications devices with the protocol interface device. Such a wide area network WAN may also be used to connect at least one of the data storage devices with the protocol interface device.

A method aspect of the invention is for interfacing a plurality of mobile wireless communications devices with a plurality of data storage devices. The mobile wireless communications devices and the data storage devices may each use at least one of a plurality of operating protocols and at least one data storage device may operate using multiple operating protocols. The method may include providing a front end proxy module for communicating with the plurality of mobile wireless communications devices using respective operating protocols. The method may further include providing a protocol engine module for communicating with the plurality of data storage devices using respective operating protocols and for communicating with the front end proxy module. The method may also include causing the protocol engine module to select a desired operating protocol for communicating with the at least one data storage device from the multiple operating protocols.

A protocol interface device in accordance with the present invention may include a front end proxy module and a protocol engine module such as those described briefly above. In addition a computer readable medium in accordance with the invention may similarly include a front end proxy module and a protocol engine module.

The present invention will now be described more fully hereinafter with reference to the accompanying drawings in which preferred embodiments of the invention are shown. This invention may however be embodied in many different forms and should not be construed as limited to the embodiments set forth herein. Rather these embodiments are provided so that this disclosure will be thorough and complete and will fully convey the scope of the invention to those skilled in the art. Like numbers refer to like elements throughout and prime notation and multiple prime notation are used to indicate similar elements in alternate embodiments.

Turning now to a communications system includes a protocol interface device that provides access to a plurality of data storage devices or systems . The communications system illustratively includes a plurality of communications devices namely a mobile wireless communications device and a communications device connected to the system via a wired connection. By way of example various mobile wireless communications devices may be used in accordance with the invention such as personal data assistants PDAs cellular telephones etc. An exemplary mobile wireless communications device suitable for use with the present invention is described in the example provided below with reference to . Moreover examples of wired communications devices include personal computers telephones fax machines etc. Of course numerous wired and wireless devices may be used although only two are shown in the exemplary embodiment for clarity of illustration.

The communications devices typically include software clients which are software modules or applications that operate on or in conjunction with their respective communications device to provide access to data stored at one or more of the data storage devices and through the protocol interface device . Those skilled in the art will appreciate that such communications devices also include further components and or software modules which have not been explicitly shown in for clarity of illustration. With respect to the mobile wireless communications device its software client communicates with the protocol interface device via a wireless communication network and perhaps other networks as well e.g. a public switched telephone network PSTN or the Internet as will be appreciated by those skilled in the art.

The various functions and operations of the protocol interface device are preferably implemented in software operating thereon or in conjunction therewith. The protocol interface device illustratively bridges the software clients of the communications devices and the data storage devices . Communications between the protocol interface device the communications devices and the data storage devices are preferably via a wide area network WAN such as the Internet. That is the communications devices may communicate with the protocol interface device via the Internet as noted above and so too may the protocol interface device communicate with the data storage devices .

Of course other implementations are also contemplated. For example the protocol interface device may be implemented in a private network that also includes the data storage devices the communications devices or both the data storage devices and the communications devices e.g. in a WAN . It should be noted that the present invention is in no way limited to any particular connection or communication scheme.

The data storage devices store data to be accessed by the software clients of the communications devices . Although some software clients are configurable to directly access certain types of data storage devices they are often data system specific or protocol specific as described briefly above. More particularly on constrained electronic devices such as the mobile wireless communication device processor power memory resources and communication channel characteristics may preclude the installation and operation of software clients having the same capabilities as those commonly used on desktop and laptop computer systems for example. In addition while the installation of multiple software clients for accessing data storage devices associated with different protocols is feasible for desktop and laptop computer systems providing multiple protocol support on such constrained devices may not be possible.

The data storage devices are accessible using different operating protocols or access schemes. As such the protocol interface device accesses the data storage devices via an operating protocol supported by respective data storage devices and provides data to the communications device via a respective client supported operating protocol. The protocol conversion functionality of the protocol interface device provides a unified approach to support access to multiple types of data system. As described in further detail below the protocol interface device provides an any to any bridge between different protocols or access schemes.

The protocol interface device is illustrated in further detail in . As noted above the protocol interface device bridges different types of communications devices with different types of data storage devices. In the illustrated embodiment data storage devices are systems servers for storing electronic mail e mail . However it should be noted that the present invention is not limited to mail system access. Each of the mail systems supports a different operating protocol or access scheme. More particularly the mail system supports Outlook Web Access OWA the mail system supports Microsoft Messaging Application Programming Interface MAPI and the mail system supports a proprietary protocol such as that used by America Online AOL for example.

The protocol interface system illustratively includes a front end proxy module . The front end proxy module illustratively includes proxy modules which respectively support the Wireless Application Protocol WAP the Post Office Protocol POP the Internet Message Access Protocol IMAP and the Hypertext Transfer Protocol HTTP for communication with clients.

The front end proxy also communicates with a protocol engine module . The protocol engine module translates OWA MAPI the proprietary protocol of the mail system and other protocols if desired into a format compatible with the front end proxy module . To this end a respective interface connector module may be coupled to the protocol engine module for each of the operating protocols used by the mail systems as will be discussed further below. In a preferred embodiment the front end proxy module and the protocol engine module are extensible or expandable to accommodate additional operating protocols as they become available as will also be discussed further below.

In operation a user accesses a mailbox on one of the mail systems through client software on his communications device. For example a WAP browser on a mobile wireless communication device communicates with the WAP proxy module to access the mail system . Access commands or instructions received by the WAP proxy are converted into a format compatible with the protocol engine module . Communications between the front end proxy module and the protocol engine module are preferably achieved via a common interface protocol which may be a proprietary protocol or an established public protocol.

The protocol engine module then translates the access commands or instructions received from the front end proxy module into a protocol associated with the mail system to be accessed e.g. OWA for the mail system . Data received from the mail system e.g. e mail messages a list of new messages calendar appointments tasks etc. depending on the particular mail system the features that its access protocol supports and the nature of the access command are translated into the common interface protocol and transferred to the front end proxy.

The active proxy module i.e. the WAP proxy module in the present example then formats the received data or at least portions thereof for the requesting client. Further commands from the client are also translated by the protocol interface device . Access commands from other types of clients are similarly processed. It should be noted that several mail systems may be accessed in response to a single access command where a user has enabled multiple mailbox access through the protocol interface device .

The protocol interface device thus allows clients using different operating protocols to access the mail systems which also use different operating protocols. Access commands such as move delete create send fetch and view for example that are generated at a client affect the data stored at the mail systems instead of copies of the data. Through the protocol interface device a client compatible with any one of the proxy modules is provided access to one or more of the mail systems . The client itself advantageously need not support the access protocol or scheme associated with the mail system s to be accessed.

Since the mail system protocol and the client protocol need not be compatible feature support between the protocols may be different. For example a POP client does not support the same features as OWA. The interface protocol used between the protocol engine module and the front end proxy module is preferably designed to be able to represent a desired number of protocol supported elements or features for a desired operating protocol. More specifically the common interface protocol is preferably able to represent all protocol supported elements for the most capable protocol OWA in the present example to provide the broadest possible feature support. Further still the common interface protocol may support a full feature set across all supported protocols if desired.

By way of example the common interface protocol may be a proprietary protocol based on the Web based Distributed Authoring and Versioning WebDAV protocol. An example of an authentication request using such a common interface protocol is provided as program listing below. This exemplary authentication request routine allows the protocol interface device to be authenticated by a mail system using a user identifier and password provided by a user and it also retrieves a root folder and basic capabilities of a target mailbox on the mail system.

An exemplary inbox request in accordance with a WebDAV based common interface protocol is set forth below as program listing . In accordance with this routine responsive to an inbox request the capabilities of the inbox in a target mailbox are queried and then its contents are queried. Another example is provided below as program listing which is for a folder search request in accordance with the aforementioned WebDAV based common interface protocol. Here a list of subfolders for a given folder is returned in response to this request. It will be appreciated by those skilled in the art that numerous other requests and operations may be used as well.

It should be noted that the software clients need not initiate data access requests in all embodiments. For example in some embodiments the protocol interface device may include or communicate with a polling or aggregation engine module not shown that prompts the protocol engine module to aggregate messages for respective users from the mail systems at predetermined intervals as will be appreciated by those skilled in the art. The protocol engine module would then cooperate with the front end proxy module to provide the aggregated messages to the respective software clients as described above. Additionally the front end proxy module need not communicate directly with the communications devices in all embodiments but it may instead communicate therewith via an intervening mail system or server for example. Thus in the case where an aggregation engine module is used the aggregated messages may be first transferred by the front end proxy module to an intervening mail server which in turn provides the messages to the appropriate communications device as will also be appreciated by those skilled in the art. Here again the front end proxy module would use the appropriate protocol s supported by such intervening mail server for communicating therewith.

A method for providing access to a plurality of data storage devices such as the mail systems using the protocol interface system is illustrated in . Beginning at Block an access command or data is first received at Block . The access command or data is translated into the common interface protocol at Block . An access command is then translated Block into a data system protocol associated with the data system to be accessed such as OWA for the mail system for example.

On the other hand data is translated into the client protocol at Block . Depending upon the particular features supported by the client protocol only those portions of the data corresponding to elements of the interface protocol that are supported by the client protocol are translated during this step. The protocol interface device may generate an error responsive to a non supported operating protocol. More particularly non supported interface protocol elements are preferably ignored or processed according to a default or error processing scheme. Translated access commands or data are then transferred to a data system or a client at Block thus concluding the illustrated method Block .

Turning now additionally to an exemplary embodiment of the front end proxy module is now described. The front end proxy module illustratively includes the proxy modules a renderer module an extensible stylesheet language transformations XSLT engine module a memory or template store a flow controller module and handlers 

As noted above each proxy module effectively fronts the protocol engine module and translates respective operating protocols for different client types. For example a WAP proxy module provides information retrieved from one or more of the handlers in the form of WML documents targeted for display on devices such as cell phones and PDAs. A POP proxy makes use of at least some of the same proxy components including the flow controller module and the renderer module to render data in the form required by the POP protocol.

One particularly advantageous benefit of the illustrated front end proxy module is that each proxy module makes use of the same core services to route traffic access data and render data. In other words the renderer module XSLT engine module template memory flow controller module and handlers provide a common core service module for the proxy modules . The only differences between translations by the different proxy modules would be in the configuration of the flow controller the handlers and the XSL templates used to translate the data into its final form. It many cases the same handlers will be re used between by the various proxy modules as will be appreciated by those skilled in the art.

During operation a data access request from a client is passed to the appropriate proxy module using standard mechanisms for the client protocol. For a WAP client for example parameters are passed via a query string and or form variables. The WAP proxy module determines a component identifier which identifies a target item such as a mail folder an action identifier which identifies an action to be performed and any parameters based on data in the request. In the case of WAP the component and action identifiers are passed in the query string or form. Other parameters in the query string or form are packaged into a parameter list.

The active proxy module then calls the flow controller passing along the identifiers and parameter list. The flow controller looks up the appropriate handler via the component and action identifiers and constructs the handler passing the parameters as arguments to a constructor not shown . Using the handler as an example this handler would processes the request using a data layer to gather information needed for a response.

For mail system access for instance the data layer communicates with the protocol engine module for any information related to the contents of the user s mailbox calendar or address book for example. Communications with other components may be established for different types of information such as information related to authentication services and a user s e mail account. The handler then decides whether the request should be forwarded to another handler or if its results should be rendered.

All information passed back by the handlers is preferably in a common format such as org.xml.sax.InputSource for example a provider of extensible mark up language XML data. The active proxy module then calls the renderer module passing along the InputSource locale information the name of the template to be rendered and an OutputStream. The renderer module making use of the XSLT engine renders the page into the OutputStream. The OutputStream is then provided to the client by the active proxy module using the client protocol.

The above system provides a generic application framework following the classic model view controller MVC architecture that implements most of the application infrastructure. One important feature is that a base set of functionality may be defined for similar services and then extended to provide the service specific functionality required to fully implement a given service. Within a given implementation the flow controller the handlers and or the data access layer are fully extensible or replaceable.

With this in mind supporting a brand new service simply involves defining and implementing the data layer defining the control flow and discrete actions within the system i.e. the flow controller module and defining and implementing the interface with the service i.e. the renderer module . On the other hand supporting a new type of client with an existing service involves making minor changes to and extending actions within the flow controller module and handlers to support additional client required functionality and defining and implementing the interface between the client and the system i.e. the renderer module .

Operation of the front end proxy module to perform protocol translation is further described with respect to the block diagram of . Certain of the illustrated operations have been described in detail above and thus will be described only briefly below to avoid undue repetition. Beginning at Block an access request or command is received at a proxy module at Block . The access request is translated into the common interface protocol by one or more of the handlers at Block .

Data is received from a given mail system in response to the request at Block . This data which has already been translated into the common interface protocol by the protocol engine module is rendered Block and returned to the client at Block thus concluding the illustrated method Block . Depending upon the particular features supported by the client protocol only portions of the data corresponding to elements of the common interface protocol that are supported by the client protocol are rendered or translated. Non supported interface protocol elements may be ignored or processed according to a default or error processing scheme as noted above.

It should be noted that the extensible common core service architecture of the front end proxy module may also be used for a variety of applications. One such application is to address various shortcomings of the disparate methods used to respond to HTTP requests from a Web application. Referring now to a Web data access system having an extensible architecture in accordance with the present invention is now described. The components of the Web data access system communicate bi directionally and they illustratively include a user request a Web server a proxy server and an extensible controller system .

More particularly the user request refers to a user using a web browser or web application to request a web page e.g. from a PDA or personal computer . Once the request is made the Web server processes the request. The proxy server assists the Web server in processing the request. For comparison purposes the proxy server here functions similar to the protocol interface device discussed above and the extensible controller system would be implemented as a software module that is run on or in conjunction with the proxy server as will be appreciated by those skilled in the art. Of course in some embodiments the proxy server and extensible controller system could be implemented in different physical devices or servers for example.

The proxy server provides a process of providing cached or storage items available on other servers which are slower or more resource intensive to access. The proxy server accepts URLs with a special prefix. When it receives a request for such a URL it strips off the prefix and looks for the resulting URL in its local cache. If found it returns the document immediately otherwise it fetches it from the remote server saves a copy in the cache and returns it to the requester. The pages returned by the proxy server can be either static or dynamic in nature. The proxy server may communicate with application servers or data servers and in this specific embodiment the extensible controller system .

More particularly the components of the proxy server illustratively include an aggregate server a renderer module an XSLT engine module and a memory for storing a series of templates similar to those described above. The components of the extensible controller system include an action map and a series of handlers also similar to those discussed above.

The aggregate server performs the processing of incoming information and passes it onto other components for assistance. The renderer module renders the resultant data into a viewable format. The renderer module makes use of the XSLT engine module and any necessary templates from the memory to render the page.

The aggregate server sends data to the action map which maintains the control flow and handles the business logic in the system. The action map interacts with a series of handlers . The handler utilizes the data layer to retrieve information from other data sources . The other data sources may include for example XML for web data a universal proxy for any information related to the contents of user applications e.g. e mail calendar or contact or a provisioning API for authentication services and data relating to a user account.

The system functions by having a user send in a URL as a user request . This request is received at the Web server which passes on to the proxy server for processing using standard mechanisms for the protocol. For example a WML request would pass a WAP parameter query string and or form variables. The aggregate server component of the proxy server determines the component ID action ID and any parameters based on data in the request. Using the same WAP example the component and action IDs are passed in the query string or form. All other parameters in the query string or form are packaged up into a parameter list.

The aggregate server then calls the action map of the extensible controller system and passes along the IDs and parameter list. The action map looks up the appropriate handler via the component and action IDs and constructs the handler passing the parameters as arguments to the constructor. The handler processes the request using the data layer to gather information needed for a response. The data layer will retrieve information from other data sources located within the network or external to the network. The handler then decides whether the request should be forwarded to another handler or if its results should be rendered.

If the system decides to render the data the data is passed from the handler back to the action map and back to aggregate server of the proxy server . The aggregate server then calls the renderer module which invokes the XSLT engine module and any necessary templates to render the data into a viewable output. This output is then returned to the Web server to serve the data as a viewable web page as a result of the user request .

The various steps involved in processing Web data using the extensible controller system will now be further described with reference to . More particularly this diagram illustrates in greater detail the processing and interaction of the proxy server and the extensible controller system . The system flow begins with a user request . This request is sent to the Web server which passes the information to the proxy server for processing. The proxy server invokes the aggregate server for processing.

The aggregate server determines whether a context is available at Block . If it is available the system will move to the next step to mine the IDs Block . If it is not available the system will first create the context at Block and then continue onto the step to mine the IDs at Block . The action ID and component ID are also mined out of the system. These IDs along with the request parameters and any form data are packaged into an envelope and gathered together at Block .

An invoke procedure is called to pass the data from the aggregate server to the action map of the extensible controller system . This invoke procedure will pass information pertaining to the envelope an action code the component ID and context info to the action map . The action map looks up the action at Block and determines whether the action exists at Block . If it does then it moves to the next step to determine whether the action requires authentication at Block . If the action does not exist the system retrieves the default action at Block and then determines whether the action requires authentication at Block .

At this point if the action does not require authentication the system determines if any requests are pending at Block . If the action does require authentication the system then determines whether the context is in an authenticated state at Block . If the context is in an authenticated state the system then determines whether a request is pending at Block . However if the context is not in an authenticated state the system returns the request to the retrieve default action at Block until authentication is accepted.

At Block the system determines if a request is pending. If a request is pending the system executes on the pending request and jumps to next stage determining whether a process is in queue at Block . If no request is pending the system executes on the action and validates on the envelope data at Block and passes control to the handler to create the action handler at Block . Once the action handler is created it is initialized at Block .

The system then determines whether background processing is allowed at Block . If so a background handler is created at Block and the system determines whether a process is in queue at Block . However if background processing is not allowed the system then processes the action handler at Block and then returns the result at Block . Revisiting the system at Block the system determines whether a process is in the queue. If the process is in the queue it then determines whether the action is complete at Block . If the process is not in the queue then it submits it to the queue at Block and then determines whether the action handler is complete at Block .

If the action handler is complete the system returns the action handler result at Block . If the action handler is not complete the system returns the pending render result at Block . The output of the steps illustrated at Blocks and returning either an action handler result or pending renderer result will be used to determine whether to render the result at Block .

More particularly the results of the steps illustrated at Blocks return result return action handler result and return pending render result are used to determine whether to render the result Block . If the system decides to render the result the system sends the data from the extensible controller system to the proxy server and renders the data at Block at the renderer module . The data is then passed onto the Web server to display the result at Block as a response to the user request . However if the system decides not to render the result and has instead decided to forward the request to another action handler for processing the system retrieves the ID keys at Block retrieves the envelope data at Block and then looks up the appropriate action at Block . The system will loop around at this point until a decision to render a result is ultimately accepted at Block .

The above described method involves using a single source for defining the components within the system. In this particular embodiment the source is an XML file but other formats could be used as well as will be appreciated by those skilled in the art. This source would define the code that handles the request the URL syntax and parameters templates or code used to generate the response for the request and the routing information for the request for example.

The code that handles the request along with the parameter definition is used by the system to create the action handler pass the correctly typed parameters and pass control to it for processing. The parameters include type information allowing for strongly typed data. The parameters may also be defined as optional or required. The template or templates are used to generate the response for the request. If an attempt is made to generate a response other than to what was defined an error is generated.

The source would also define the routing information for the request. Often times it is desirable for a handler to perform work within its scope and then hand off control to another handler to allow it to perform its work. However if the handler attempts to hand control to something not defined in the source an error is generated.

Other variations are also possible. For example the source may be used whenever generating URL s for use within the system. Moreover request routing may be separated from the actual processing of those requests. Control flow is then handled by one component of the system not by each handler. The handler would then simply ask the controller to forward a request to another handler. Thus incoming data may be kept in a known state for the life of a particular request.

Yet another approach involves enforcing control flow through the system where one handler does not call another handler directly to do its work. Still another approach involves keeping the handlers relatively small and simple. That is this will limit the handler s purpose and scope to receiving requests and calling the appropriate business logic to gather the desired results. Another variation involves keeping each handler focused on one task and upon completion of the task allowing the results to be rendered or forwarded on to the next handler.

A further variation involves providing an extensible mechanism for handling requests that can handle immediate needs as well as grow over time without becoming overly complex. When loading the system the user is able to specify a primary and secondary action map. In this way generic business logic and control flow may be specified by the primary action map while still providing the user with a method of adding or modifying the functionality. Another approach is to provide the developer with a generic mechanism for responding quickly to long running requests to avoid generating a timeout. This enables the developer to specify background processing at either a handler level or at the entire system.

The above described extensible controller is particularly advantageous for addressing shortcomings in Web or HTTP based applications. Of course it will be also appreciated by those skilled in the art that this same architecture may be extended to support other types of non HTTP based applications as well.

Turning now to an alternate embodiment of the protocol interface device is now described. In the illustrated embodiment all requests to a data storage device such as the mail systems are defined in configuration files stored in a configuration file store or memory . In this way for a given client category an application developer can easily request only those properties required to support the client for which it was written.

A resource manager which may be part of the front end proxy module or a separate component of the protocol interface device advantageously allows a user to specify a primary and secondary set of configuration files. If a secondary configuration file is specified any resources defined in it will override those specified in the primary configuration file. This allows the user to specify a core set of resources and then tweak them to fit a particular implementation.

Moreover configuration files may be stored for processing operations at different network layers. For example configuration files for data layer operations for interfacing the front end proxy module and protocol engine module may be stored in the memory as well for upper network layer operations performed by the flow controller module for example. Other types of configurations files may be used as well as will be appreciated by those skilled in the art.

A configuration file also preferably specifies the implementation class that is created to handle the response to a given request. This makes it a simple matter to slightly change the behavior of an object in a data model or even completely replace it. Caching behavior and strength for each request may also be specified in a configuration file. With a combination of these two properties a developer can have much greater control over memory consumption and response request performance.

In addition configuration files also allow a user to specify multiple requests for a given resource. This makes it possible to support data systems with different request response formats. An exemplary configuration file is provided below as program listing . This configuration file is suitable for a data store that supports a WebDAV interface as discussed above or in the case of the protocol interface device a protocol engine that supports a WebDAV interface. However it could be used for other types interfaces data stores as well.

It should also be noted that in addition to the content class specified for the resource a user may also specify a command to further identify a given resource. This allows the user to perform multiple different operations on a given resource type as will be appreciated by those skilled in the art.

Operation of the protocol interface device using configuration files will now be described further with reference to . Beginning at Block an access request or command is received at a proxy module at Block . The access request is translated into the common interface protocol by a handler at Block with reference to one or more configuration files. Data that is received from the data system Block in response to the request and which has already been translated into the common interface protocol by the protocol engine module is formatted into a response and rendered at Block . Again this is done with reference to one or more configuration files. The rendered response is then returned to the client Block thus concluding the illustrated methods at Block .

Referring now additionally to the protocol engine module will now be described in further detail. The protocol engine module provides a framework to incorporate various interface connector modules that communicate with various mail systems using different protocols. The protocol engine module also provides a common interface XML and WebDAV for example that the clients through the front end proxy module use to access various mail accounts. Common operations like retrieving only the essential headers of new mail and determining the presence and size of attachments without downloading them are highly efficient. All operations are performed directly on the source and only the essential data is retrieved.

The protocol engine module uses an appropriate one of a plurality of interface connector modules to access a mail account. All of the connector modules preferably support a common application programming interface API such that adapting the protocol engine module to support a new protocol amounts to simply adding a new interface connector module. The connector modules may be written in Java for example although other suitable languages or protocols may also be used. Overall system performance and availability may be improved for example by providing multiple dynamically load balanced protocol engine machines.

Results received by the protocol engine module from the mail systems are similarly translated into the common interface protocol for translation into a client supported protocol if necessary and transmission to a client. The results communicated back to a client preferably include only data that was requested by the client. Data corresponding to features that are supported by a mail system protocol but not by a client protocol may be translated into the common interface protocol but it may also be ignored or handled according to a default or error processing scheme as noted above.

A method of protocol translation using the protocol engine module and interface connector modules is now described with reference to . Beginning at Block an access request or command is received at Block . The access request is translated into a protocol supported by the target data system at Block . Data is received from the data system in response to the request at Block and it is translated into the common interface protocol at Block . Further translation of the data into a client protocol may be performed if necessary at Block and the data transmitted to the client at Block thus concluding the illustrated method at Block .

Again depending upon the particular features supported by the client protocol only portions of the data corresponding to elements of the common interface protocol that are supported by the client protocol are translated. As described above non supported interface protocol elements may be ignored or processed according to a default or error processing scheme.

Turning now to an alternate embodiment of the above described protocol conversion module architecture is now described. Here the protocol engine module takes the form of a universal proxy UP servlet module and each interface connector module and a respective provider module are associated with different operating protocols. In the illustrated example the different protocols are OWA IMAP and POP. Further or different protocols may be supported by corresponding provider connection pairs as will be appreciated by those skilled in the art.

For a common interface protocol such as the proprietary interface protocol described above the UP servlet module takes incoming common format requests and translates them into balls using the defined interfaces to the interface connector modules . The UP servlet module also takes the results of these calls and formats them into common format requests. Each common format request includes a method request and a path in the form of a URL. It may also include an XML document that provides additional parameters for the request.

Conceptually below the UP servlet module there is a provider module for each supported mail system protocol. The providers take care of handling the calls made by the UP servlet module . As shown each provider has a connection which takes care of communicating with the source mailbox account on a target mail system. Initially the connection will also be the provider.

The interfaces used by the UP servlet and implemented by the provider modules define a loose folder hierarchy. In fact it may be conceptualized as a collection of collections of items. An item can be a message a folder or a contact for example or any other data item to be represented. Each item has a defined type e.g. mail contact appointment . An interface for each type of item defines the properties and actions that are available for that type of item. A folder item includes a collection of items and provides methods to enumerate the items within a folder.

The connector interface modules provide a common way for the UP servlet module to communicate with different provider modules interface connector modules. Some connector modules may only implement a subset of the protocol and or may only support a single folder collection of items as in the case of POP.

The basic flow for an exemplary common format request proceeds as follows. The UP servlet module receives the request and it either retrieves or creates the appropriate provider connection. The UP servlet module then calls an appropriate get folder or similar function associated with the interface connector module passing a target mail system identifier such as a URL that was included in the common format request. The interface connection module returns a reference to some object that implements the folder interface and represents the requested folder. In its simplest implementation e.g. POP a single object could be the interface connector module and also represent the mailbox folder.

The UP servlet module uses the returned folder reference to make additional calls to satisfy the common format request. For example if the UP servlet module needs to retrieve a specific item it may first call a get folder function passing the requested URL and after it has the folder it will then call a get item function again passing the URL. The results of the call s are then formatted into an appropriate format such as XML and returned in an HTTP response.

It will be up to the provider module interface connection module to interpret a URL passed in and return the appropriate reference. This will not be complicated because the provider module interface connection module provides the URLs in the first place. The only URL that any interface connection module will be required to know about is . All other URLs are generated by the provider connection. As long as the URLs within the hierarchy collections are unique the provider will be able to resolve to the correct item when a get function is called.

The provider modules and interface connection modules preferably support a root folder. If only a root folder is supported then inbox calendar and contact items as appropriate should be items within that folder if they are to be accessible through a protocol engine.

In accordance with one aspect of the invention a single advantageous mechanism to access various types of protocols is provided. This mechanism supports the full functionality of each data system protocol for similarly capable client protocols and degrades when a specific data system protocol feature is not supported by a client protocol. Requests received in a common format are translated into a provider protocol specific format before forwarding the request on to the destination server. Responses from the destination server which are in provider protocol specific format are translated back into the common format.

A mechanism for a client to query supported functionality for a specific provider module giving the client greater control over how it generates requests to the provider is also provided. Any client written to support the common protocol format directly or through a proxy can easily provide access to any mail store without concerning itself with the details of the mail store provider module protocol.

Referring now additionally to another embodiment of the protocol interface device is now described. Here user e mail account information associated with e mail accounts to be accessed through the protocol interface device is stored in a data store . The per account information preferably includes an indication of the access protocols supported for each e mail account.

Records in the data store may be arranged by an account identifier such as an e mail address or by a user name associated with the protocol interface device such that all e mail account. information for particular users is grouped in the data store for example. Where access protocol support is the same for all e mail accounts on each of the mail systems the per account information may include mail system information indicating the operating protocols supported by each mail system.

A data store stores a list of all operating protocols supported by the protocol engine module and corresponding metrics i.e. ranking representing protocol preferences. These metrics are calculated based on capability criteria such as the degree to which features of each mail system are supported by a protocol and the security level of a protocol for example. Other criteria may also be used and will be apparent to those skilled in the art. In the data store OWA would typically have a higher metric or ranking than MAPI and IMAP would generally be ranked higher than POP. Each of the data stores may be implemented for example in a database on a local hard disk or other memory at the protocol interface device or on a file server with which the protocol interface device communicates.

The protocol engine module determines to which mailbox es or account s the command or instruction relates and then accesses the per account information in the data store to determine whether more than one access protocol is supported for each account to be accessed. If only one access protocol is supported then that protocol is selected. Where more than one access protocol is supported for the account then the protocol engine module accesses the data store to determine which supported protocol is preferred or desired and the supported protocol with the highest metric or ranking is selected. For the mail system OWA is preferably selected over MAPI and for the mail system IMAP is preferably selected over POP.

The protocol interface device thus allows access to the mail systems using a most capable supported protocol. Through the protocol interface device a client compatible with any of the proxy modules is provided access to one or more of the mail systems . The client itself need not support the access protocol or scheme associated with the mail system s to be accessed.

A method of data system access protocol selection using the protocol interface device is now described with reference to . Beginning at Block an access command is received from a client at Block . A determination is made Block as to whether each data system to be accessed in response to the command supports more than one access protocol. If so then the most capable supported protocol is selected at Block . Otherwise the one supported protocol is selected at Block . Each data system is accessed using the selected protocol at Block thus concluding the illustrated method at Block . Where more than one data system is to be accessed the protocol selection steps illustrated at Blocks are preferably repeated for each data system.

It should be noted that the protocol and metric data store is but one example exemplary of a protocol preference ranking technique that may be used in accordance with the present invention. Protocol preferences may be inherent in the ordering of a list of supported protocols for example.

Further criteria than metrics or overall preferences may also be considered when selecting a protocol. The type of client from which the access command is received may also affect protocol selection. Where the access command is received from a POP client for example many of the enhanced features supported by OWA cannot be represented in POP for transfer to the device. If a user has only one type of client for accessing the protocol interface device then the per account information may be adapted to reflect the type of client or to limit the list of supported protocol based on the type of client. Otherwise a further step in protocol selection may be to determine the type of client from which an access request is received.

Alternatively a most capable protocol supported by a data system to be accessed may always be selected and any incompatibility between the selected access protocol and the protocol supported by the client is handled during translation of data to the client protocol. Portions of data corresponding to elements of the interface protocol that are supported by the client protocol are translated whereas non supported interface protocol elements are ignored or processed according to a default or error processing scheme.

Generally speaking clients often access servers through proxies. Also the latency is often positively correlated to the cardinality of the collection being accessed e.g. number of email messages in the mailbox being accessed . As will be evident from the following description the present invention provides an apparatus and technique that may be used by the proxy to give the client the illusion that the collection being accessed is smaller than it really is. For example a proxy may show only the 100 most recent messages in a mailbox while the mailbox itself has 2000 messages. The present invention advantageously allows this proxy to select a small subset of the collection that can be presented to the client in lieu of the entire collection without a significant impact to the user experience.

More particularly turning now to another advantageous embodiment of the protocol interface device is now described. Generally speaking when a data access request is received from a client the protocol interface device accesses one or more of the data systems . However in some cases accessing the data systems and providing a response to the client might otherwise cause timeouts for certain client protocols and longer than desired wait times for a user of a client after a request has been sent. Yet in accordance with the present aspect of the invention certain data may be stored at the protocol interface device which may be used to reduce response times.

More particularly the protocol engine module polls the data systems to determine whether they currently store data items associated with users that have been configured for access thereof. Users are configured in the protocol interface device by establishing a user account associated therewith for example. Polling is preferably performed in accordance with a polling interval. The polling interface may be a static predetermined polling interval or an adaptive polling interval that can be adjusted based on operating conditions or the occurrence of particular events as will be appreciated by those skilled in the art.

In response to a poll from the protocol engine module a given data system returns data items or at least data item identifiers that can be used to retrieve the data items to the protocol interface device . These data items or identifiers are then stored by the protocol engine module in the data store or memory .

In particular the protocol engine module may determine whether new data items for a user are stored in any of the data systems . Where the data systems are e mail systems for example the protocol engine module queries mailboxes associated with each user configured for e mail access through the protocol interface device . For each mailbox query a mail system returns at a minimum a list of unique identifiers UIDs associated with e mail messages stored in the mailbox.

A current UID list is then compared with a previous UID list for the mailbox in the UID store to determine whether new messages have been stored in the mailbox at the mail system. If new messages are detected an alert is preferably sent to a user s client by the protocol engine module in cooperation with the front end proxy module or another component of the protocol interface device and the current UID list including the new messages is stored to the UID store .

One of the most common data access operations is viewing a listing of data items currently stored at data systems especially where the data items are messages stored on mail systems. As described above the protocol engine module polls one or more of the data systems to detect new data items based on a list of UIDs stored in the UID store . Therefore the protocol interface device has a local listing of UIDs of data items that were stored at the data systems the last time the data systems were polled.

In accordance with the present aspect of the invention the protocol engine module retrieves the stored UID list from the UID store when a view items or similar access request is received. This stored UID list which is accurate to within the current polling interval is then returned to the requesting client. This provides a much faster response time than accessing the data systems when the request is received as will be appreciated by those skilled in the art.

In the case of a POP client for example the client times out if no response to a request is received within 30 seconds. Where the POP client is operating on a mobile wireless communications device latency within the wireless communications network can cause delays that are significant relative to this limited response time. The faster response time associated with providing a stored UID list in response to a data access request is particularly advantageous in these types of scenarios. Even in the absence of such time constraints a faster response time enhances the user experience at a client by reducing the wait time between sending a data access request and receiving a response.

As described above the stored UID list is accurate to within the polling interval. When the stored UID list is provided to a client in response to a data access request the protocol engine module preferably polls the data system s to determine whether the stored UID list is still accurate. If new items have been stored at the data system s since the last poll then a new UID list is sent to the client. This further polling of the data systems is performed either according to the polling interval or initiated by the data access request.

It will be appreciated that the preceding description relates to view items or similar data access requests. Other types of data access requests may be processed by other components or modules of the protocol interface device . For example such data access requests are translated if necessary by the front end proxy module as described above.

The protocol interface device thereby allows access to the data systems and provides for reduced response times for various types of data access requests. Through the protocol interface device a client compatible with any of the protocols handled by the front end proxy module is provided access to one or more of the data systems . The client itself need not support the access protocol or scheme associated with the data system s to be accessed as noted above.

A method of reducing response times for data system access requests using the protocol interface device is now described with respect to . Beginning at Block a data access request is received at Block . A determination is then made at Block as to whether data pertinent to the data access request i.e. a UID list is locally stored. Where such data is in a local store then the stored data is provided to the requesting client at Block . After the stored data has been transmitted to the client or if no such data has been stored the data system s to which the data access request relates is polled at Block .

An optional step of determining whether the polled data received in response to a poll is different from the stored data may then be performed at Block . If so this means that there is new data stored on the data system s and the data received in response to the poll is provided to the client at Block . It is also locally stored in the data store at Block thus concluding the illustrated method Block .

By way of example data access systems and methods according to aspects of the invention may be applied to other types of data storage devices than mail systems and other protocols and access schemes than those specifically described above and shown in the drawings.

Additional features of the invention may be found in applications entitled COMMUNICATIONS SYSTEM PROVIDING REDUCED ACCESS LATENCY AND RELATED METHODS Ser. No. 10 777 871 filed Feb. 12 2004 now U.S. Pat. No. 8 032 593 issued Oct. 4 2011 COMMUNICATIONS SYSTEM INCLUDING PROTOCOL INTERFACE DEVICE FOR USE WITH MULTIPLE OPERATING PROTOCOLS AND RELATED METHODS Ser. No. 10 777 577 filed Feb. 12 2004 now U.S. Pat. No. 8 135 759 issued Mar. 13 2012 COMMUNICATIONS SYSTEM PROVIDING MULTI LAYERED EXTENSIBLE PROTOCOL INTERFACE AND RELATED METHODS Ser. No. 10 778 709 filed Feb. 12 2004 now U.S. Pat. No. 7 774 486 issued Aug. 10 2010 COMMUNICATIONS SYSTEM PROVIDING EXTENSIBLE PROTOCOL TRANSLATION FEATURES AND RELATED METHODS Ser. No. 10 777 958 filed Feb. 12 2004 now U.S. Pat. No. 7 644 170 issued Jan. 5 2010 COMMUNICATIONS SYSTEM WITH DATA STORAGE DEVICE INTERFACE PROTOCOL CONNECTORS AND RELATED METHODS Ser. No. 10 777 959 filed Feb. 12 2004 now U.S. Pat. No. 7 289 975 issued Oct. 3 2007 and COMMUNICATIONS SYSTEM PROVIDING EXTENSIBLE PROTOCOL TRANSLATION AND CONFIGURATION FEATURES AND RELATED METHODS Ser. No. 10 777 936 filed Feb. 12 2004 now U.S. Pat. No. 7 685 302 issued Mar. 23 2010 the entire disclosures of which are hereby incorporated herein by reference.

An exemplary hand held mobile wireless communications device that can be used in the present invention is further described in the example below with reference to . The device includes a housing a keyboard and an output device . The output device shown is a display which is preferably a full graphic LCD. Other types of output devices may alternatively be utilized. A processing device is contained within the housing and is coupled between the keyboard and the display . The processing device controls the operation of the display as well as the overall operation of the mobile device in response to actuation of keys on the keyboard by the user.

The housing may be elongated vertically or may take on other sizes and shapes including clamshell housing structures . The keyboard may include a mode selection key or other hardware or software for switching between text entry and telephony entry.

In addition to the processing device other parts of the mobile device are shown schematically in . These include a communications subsystem a short range communications subsystem the keyboard and the display along with other input output devices and as well as memory devices and various other device subsystems . The mobile device is preferably a two way RF communications device having voice and data communications capabilities. In addition the mobile device preferably has the capability to communicate with other computer systems via the Internet.

Operating system software executed by the processing device is preferably stored in a persistent store such as the flash memory but may be stored in other types of memory devices such as a read only memory ROM or similar storage element. In addition system software specific device applications or parts thereof may be temporarily loaded into a volatile store such as the random access memory RAM . Communications signals received by the mobile device may also be stored in the RAM .

The processing device in addition to its operating system functions enables execution of software applications A N on the device . A predetermined set of applications that control basic device operations such as data and voice communications A and B may be installed on the device during manufacture. In addition a personal information manager PIM application may be installed during manufacture. The PIM is preferably capable of organizing and managing data items such as e mail calendar events voice mails appointments and task items. The PIM application is also preferably capable of sending and receiving data items via a wireless network . Preferably the PIM data items are seamlessly integrated synchronized and updated via the wireless network with the device user s corresponding data items stored or associated with a host computer system.

Communication functions including data and voice communications are performed through the communications subsystem and possibly through the short range communications subsystem. The communications subsystem includes a receiver a transmitter and one or more antennas and . In addition the communications subsystem also includes a processing module such as a digital signal processor DSP and local oscillators LOS . The specific design and implementation of the communications subsystem is dependent upon the communications network in which the mobile device is intended to operate. For example a mobile device may include a communications subsystem designed to operate with the Mobitex Data TAC or General Packet Radio Service GPRS mobile data communications networks and also designed to operate with any of a variety of voice communications networks such as AMPS TDMA CDMA PCS GSM etc. Other types of data and voice networks both separate and integrated may also be utilized with the mobile device .

Network access requirements vary depending upon the type of communication system. For example in the Mobitex and DataTAC networks mobile devices are registered on the network using a unique personal identification number or PIN associated with each device. In GPRS networks however network access is associated with a subscriber or user of a device. A GPRS device therefore requires a subscriber identity module commonly referred to as a SIM card in order to operate on a GPRS network.

When required network registration or activation procedures have been completed the mobile device may send and receive communications signals over the communication network . Signals received from the communications network by the antenna are routed to the receiver which provides for signal amplification frequency down conversion filtering channel selection etc. and may also provide analog to digital conversion. Analog to digital conversion of the received signal allows the DSP to perform more complex communications functions such as demodulation and decoding. In a similar manner signals to be transmitted to the network are processed e.g. modulated and encoded by the DSP and are then provided to the transmitter for digital to analog conversion frequency up conversion filtering amplification and transmission to the communication network or networks via the antenna .

In addition to processing communications signals the DSP provides for control of the receiver and the transmitter . For example gains applied to communications signals in the receiver and transmitter may be adaptively controlled through automatic gain control algorithms implemented in the DSP .

In a data communications mode a received signal such as a text message or web page download is processed by the communications subsystem and is input to the processing device . The received signal is then further processed by the processing device for an output to the display or alternatively to some other auxiliary I O device . A device user may also compose data items such as e mail messages using the keyboard and or some other auxiliary I O device such as a touchpad a rocker switch a thumb wheel or some other type of input device. The composed data items may then be transmitted over the communications network via the communications subsystem .

In a voice communications mode overall operation of the device is substantially similar to the data communications mode except that received signals are output to a speaker and signals for transmission are generated by a microphone . Alternative voice or audio I O subsystems such as a voice message recording subsystem may also be implemented on the device . In addition the display may also be utilized in voice communications mode for example to display the identity of a calling party the duration of a voice call or other voice call related information.

The short range communications subsystem enables communication between the mobile device and other proximate systems or devices which need not necessarily be similar devices. For example the short range communications subsystem may include an infrared device and associated circuits and components or a Bluetooth communications module to provide for communication with similarly enabled systems and devices.

Many modifications and other embodiments of the invention will come to the mind of one skilled in the art having the benefit of the teachings presented in the foregoing descriptions and the associated drawings. Therefore it is understood that the invention is not to be limited to the specific embodiments disclosed and that modifications and embodiments are intended to be included within the scope of the appended claims.

