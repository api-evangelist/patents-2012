---

title: Web input through drag and drop
abstract: A system for enabling the drag and drop behavior detects a cursor over a non-input element and creates a container to receive an object dragged by the cursor. When the cursor drops an object on the non-input element, the container receives and stores the dropped object. The system then removes the container and provides the stored object to input field associated with the non-input element.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09075517&OS=09075517&RS=09075517
owner: Google Inc.
number: 09075517
owner_city: Mountain View
owner_country: US
publication_date: 20120221
---
The disclosure generally relates to the field of receiving and formatting input for online content in particular to receiving and formatting input for web objects through drag and drop actions.

Drag and drop is a data input method that can be used to provide data objects to input elements equipped to received data through drag and drop behavior. For example input elements like text boxes in a web page are configured to receive textual data through drag and drop behavior in addition to the user typing text in the text box. Accordingly a user may select text in a document in one window and drag and drop it into a text box in a web page in a separate window. Drag and drop works in this instance because the text box is natively configured to accept the dropped text as a valid textual input.

On the other hand various non input elements like images lists and text in a web page are not configured to receive input through drag and drop behavior. Accordingly a user cannot drag and drop data objects on such elements and the user is limited to providing input related to such web objects through an associated input text box if there is one available. For example if a user intends to input a location name to be displayed on a map image the user must type the location in a text box associated with the map image. The map image itself is not configured to accept an input and a user may not drag and drop text such as a location name on the map.

One way of adding drag and drop behavior to the non input elements is through browser extensions. The browser extensions use the browser s application programming interfaces APIs to provide additional functionality for the browser. Accordingly a browser extension may use one of the browser s API to detect and receive an object dropped on the browser and implement an action in response to detecting the drop.

However these extensions provide the added functionality only if the extension is supported by the browser and the user installs the extension. Accordingly the added functionality is available for a limited set of browsers and available to a limited set of users aware of the available extension and the procedure for installing the extension.

Embodiments of the invention add drag and drop behavior to non input elements in a web page. A client application is configured to detect a cursor performing a drag and drop operation being positioned over a non input element on a web page and create a container to receive an object dragged by the cursor. When the cursor drops an object on the non input element the container receives and stores the dropped object. The client application then removes the container and provides the stored object to web page for handling. The received object may or may not be in a format that the web page can process. For example the dragged text may be an HTML object and the web page may receive a textual input. In this case the client application provides the stored object to a conversion server. The conversion server converts the received object into a format compatible with the web page and provides the converted object back to the client application. The client application then populates an input field associated with the non input element. Where the object is in a format that the web page can process the client application provides the object received from the container to the page without first providing the received object to the conversion server.

The features and advantages described in the specification are not all inclusive and in particular many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings specification and claims. Moreover it should be noted that the language used in the specification has been principally selected for readability and instructional purposes and may not have been selected to delineate or circumscribe the disclosed subject matter.

The computing environment described herein enables drag and drop behavior for non input elements. The figures and the following description describe certain embodiments by way of illustration only. One skilled in the art will readily recognize from the following description that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles described herein. Reference will now be made in detail to several embodiments examples of which are illustrated in the accompanying figures. It is noted that wherever practicable similar or like reference numbers may be used in the figures and may indicate similar or like functionality.

Referring to the computing environment for enabling the drag and drop behavior on arbitrary web pages comprises a content server a client with a browser and optionally a conversion server . The client is a computing device including a processor and a memory capable of running applications like browser . Examples of client include a desktop a laptop and a handheld computing device. While only a single client is shown it is understood that in practice there will be large numbers of such clients.

The browser is an application for retrieving presenting and traversing online data available on various entities like content server . Additionally the browser is capable of executing various software applications and interfaces received from content server or other servers. For example when a user accesses a website with an embedded client side code like drag and drop module the browser receives and implements the drag and drop module and displays the accessed website. In one embodiment the browser receives and implements the drag and drop module without any input from the user. Accordingly the user need not actively search or install the drag and drop module . The browser instead installs the drag and drop module when a user visits a web site that supports the drag and drop module .

The drag and drop module includes client side code that provides the drag and drop behavior for non input elements. In one embodiment the drag and drop module is embedded JavaScript in the HTML page received by the browser for the website accessed by the user. Regardless of the form of the drag and drop module the module provides inter alia drag and drop functionality for non input elements. illustrates steps implemented by the drag and drop module for providing this drag and drop functionality. Referring to the drag and drop module detects a cursor positioned over a non input element and creates a container. To detect that the cursor is over the non input element in one embodiment the drag and drop module attaches a callback function with a hover event like onmouseover associated with the non input element. The drag and drop module may attach the callback function with the hover event through a call like addEventListener. Regardless of how the callback function is attached the hover event is fired in response to the cursor hovering over the non input element and responsive to the hover event the attached callback function is called.

The callback function creates the container to receive the object dragged by the cursor over the non input element. In one embodiment the container is visibly or imperceptibly displayed and configured to follow the cursor over the non input element. In another embodiment the container is not configured to follow the cursor but the container attaches a callback function with a drop event like mouseup event. If the cursor drags and drops a data object over the non input element the callback functions associated with the hover and drop events are called and the container receives the dropped object from the callback functions. The drag and drop module then in one embodiment receives the object from the container removes the container and converts the received object into appropriate format. In one embodiment the drag and drop module converts the received object by providing the received object to a conversion server and receiving the converted object from the conversion server . In another embodiment the received object is not converted into another format and the drag and drop module does not provide the received object for conversion to the conversion server .

Regardless of whether the received object is converted the drag and drop module populates an input field associated with the non input element based on the received object. In one embodiment the associated input field is a text box or another web object capable of receiving an input displayed in proximity of the non input element. In this embodiment the drag and drop module populates the associated text box or web object with the received object. In another embodiment the associated input field is an API or a function call that processes the received object or provides the received object to the appropriate module for processing and the drag and drop module calls the API with the received object as a parameter.

In this manner the drag and drop module beneficially provides drag and drop functionality for non input elements regardless of the browser APIs or non input element s incapability of receiving dropped objects. Additionally the beneficial integration of drag and drop module with the browser does not require the use of extensions. Moreover unlike the extensions the drag and drop module is not limited to a particular browser.

The content server is a computing device including a processor and a memory that stores and or generates online content like web pages audio or video streams embedded web applications and embedded web interfaces like drag and drop module . The content server receives a request from browser for a web page and its associated interfaces and the server provides the requested content over a network .

The conversion server is a computing device including a processor and a memory that receives an object from the drag and drop module converts the object into a requested format and provides the converted object back to the drag and drop module . In one embodiment of the system illustrated in the object received by drag and drop module is not converted to another format and the conversion server is not included in the system . In another embodiment the conversion server converts the received object to a format compatible with the input field associated with the non input element. For example the conversion server receives an HTML object including a location name converts the received object into a textual string including a location name and provides the converted textual string to the drag and drop module . In another example the conversion server receives a location name performs a look up of the location name in a table with geographical coordinates for various locations retrieves the geographical coordinates indicating the location s latitude and longitude for the received location name and provides the coordinates to the drag and drop module .

As another example the conversion server receives an image determines geographical coordinates associated with the image and provides the determined coordinates to the drag and drop module . Many cameras today include a geotagging feature that adds geographical information for an image as metadata for the image. Additionally software applications and web applications prompt users for geographical information that may be added as metadata for the image. This metadata may be stored and provided as part of an image. The conversion server may determine a location associated with an image based on metadata associated with the received image. Alternatively the conversion server may analyze the received image using image detection mechanisms that determine the location of the image based on one or more of the image s feature. For example the conversion server may compare the received image with stored images associated with known locations and determine the received image s location based on the comparison.

The network represents the multiple different communication pathways between the client the content server and the conversion server . The network includes networks such as the Internet as well as dedicated or private communications links that are not necessarily part of the Internet and wired and or wireless networks including cellular networks and POTS.

The data detection module determines when data is dragged over a non input element. In one embodiment the non input element has various associated events like hover events that are fired in response to a cursor hovering over the non input element. The data detection module attaches callback functions with these events. When a cursor hovers over the non input elements the hover events are fired the attached callback functions are called and the data detection module detects the cursor over the non input element. Upon detecting the cursor over the non input element the data detection module provides a request to the container module to create a container to receive the dragged object.

The container module creates and controls a container like an iFrame to receive the dragged object. In one embodiment the container module creates a small e.g. five by five pixels imperceptible container that follows the dragged object over the non input element. To create such a container in one embodiment the container module repeatedly determines the location of the cursor and repeatedly configures the location of the container to the cursor s location. The imperceptible container beneficially creates the illusion that the object is being dragged over the non input element but the object is actually being dragged over the container because the container is placed between the non input element and the dragged object. Accordingly when a cursor drops an object over the non input element the object is actually dropped on the container. The container receives the dropped object and provides the dragged object to the container module .

After receiving the dragged object the container module stores the received object in the object model for the web page and removes the container so that it no longer tracks the cursor. The removal of the container beneficially ensures that the container module does not interfere with subsequent cursor actions. For example after dropping the object if a user clicks on the non input element the web object is selected instead of the container because the container has been removed. If the container was still following the cursor the click would lead to selection of the container not the web object and therefore confuse the user. Accordingly the container module beneficially removes the container to avoid such confusion or other undesired side effects.

The conversion module communicates with the conversion server to facilitate the conversion of the dropped object to a format compatible with an input field associated with the non input element. Again in some embodiments the conversion of the dropped object is not necessary and the conversion server is not required in the system . Because the conversion server is not required in those embodiments a conversion module is also not required to communicate with the conversion server . In embodiments with the conversion server the conversion module provides for conversion to the conversion server the received object stored by the container module . In one embodiment the conversion module is pre configured to store the compatible format for the received object and the conversion module provides to the conversion server the compatible format with the stored object. The received compatible format is used by the conversion server to convert the received object to the received compatible format. In another embodiment the conversion server is pre configured to convert the received object to a particular format and does not need to receive the compatible format from the conversion module . Accordingly the conversion module in this embodiment does not provide the compatible format to the conversion server . Regardless of whether the compatible format is provided the object is converted by the conversion server and provided to the conversion module . The conversion module receives and stores the converted objected.

The object interface module populates the input field associated with the non input element based on the stored object. In one embodiment the associated input field or an API for interfacing with the input field is publically available e.g. through a publication and the object interface module is pre configured to provide the stored object to the published input field or the API. In another embodiment the object interface module analyzes the source code of the web page to determine the input field associated with the non input element web object. For example the object interface module uses an HTML parser to determine a list of form fields and their associated controls in a web page. The object interface module presents the determined form fields to a user. The user based on factors like names of the form fields infers from the form fields list the input field associated with the non input element. The object interface module receives the user inferred form field and stores the received form field as the associated input field. The object interface module populates the form field based on the stored object through an associated control that sets the value of the form field to the stored object. Regardless of how the object interface module determines the associated input field the object interface module populates the input field based on the stored object.

Referring to website is a map web site that does not support the drag and drop feature for non input elements. The website includes an image which is a non input element and an associated input box . Because the image is a non input element the image does not support the drag and drop feature. Accordingly when a user tries to drag an object a textual object in this instance the browser displays a sign indicating that the user cannot drop the object on image . The user therefore is limited to inputting the text in the associated input box .

Next the drag and drop module determines whether the received object is in a format acceptable to the input field . In this illustrated scenario the received object is in text format and the input field accepts textual input. Accordingly the drag and drop module provides the received object directly to input field .

In some cases the received object may not be in format that can be input to the input field . Accordingly the drag and drop module provides the received object to the conversion server . The conversion server then extracts the text from the received object and provides the extracted text back to the drag and drop module . In one embodiment the input box or another input associated with the map image receives the input as latitude and longitude coordinates of a location. Accordingly the drag and drop module provides the received object including Mountain View Calif. text to the conversion server and the conversion server determines the latitude and longitude corresponding to Mountain View Calif. The conversion server provides the determined coordinates to the drag and drop module and the drag and drop module provides the received converted object to an input box or another interface of website . The maps application associated with the website then determines the location corresponding to the received input and displays the location on the map image .

The foregoing description of the embodiments of the invention has been presented for the purpose of illustration it is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Persons skilled in the relevant art can appreciate that many modifications and variations are possible in light of the above disclosure.

Some portions of this description describe the embodiments of the invention in terms of algorithms and symbolic representations of operations on information. These algorithmic descriptions and representations are commonly used by those skilled in the data processing arts to convey the substance of their work effectively to others skilled in the art. These operations while described functionally computationally or logically are understood to be implemented by computer programs or equivalent electrical circuits microcode or the like. Furthermore it has also proven convenient at times to refer to these arrangements of operations as modules without loss of generality. The described operations and their associated modules may be embodied in software firmware hardware or any combinations thereof.

Any of the steps operations or processes described herein may be performed or implemented with one or more hardware or software modules alone or in combination with other devices. In one embodiment a software module is implemented with a computer program product comprising a computer readable medium containing computer program code which can be executed by a computer processor for performing any or all of the steps operations or processes described.

Embodiments of the invention may also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes and or it may comprise a general purpose computing device selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a non transitory tangible computer readable storage medium or any type of media suitable for storing electronic instructions which may be coupled to a computer system bus. Furthermore any computing systems referred to in the specification may include a single processor or may be architectures employing multiple processor designs for increased computing capability.

Embodiments of the invention may also relate to a product that is produced by a computing process described herein. Such a product may comprise information resulting from a computing process where the information is stored on a non transitory tangible computer readable storage medium and may include any embodiment of a computer program product or other data combination described herein.

Finally the language used in the specification has been principally selected for readability and instructional purposes and it may not have been selected to delineate or circumscribe the inventive subject matter. It is therefore intended that the scope of the invention be limited not by this detailed description but rather by any claims that issue on an application based hereon. Accordingly the disclosure of the embodiments of the invention is intended to be illustrative but not limiting of the scope of the invention which is set forth in the following claims.

