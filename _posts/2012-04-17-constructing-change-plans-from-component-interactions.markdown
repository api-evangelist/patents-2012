---

title: Constructing change plans from component interactions
abstract: Techniques for constructing change plans from one or more component interactions are provided. For example, a computer-implemented technique includes observing at least one interaction between two or more components of at least one distributed computing system, consolidating the at least one interaction into at least one interaction pattern, and using the at least one interaction pattern to construct at least one change plan useable for managing the at least one distributed computing system. In another computer-implemented technique, a partial order of two or more changes is determined from at least one component interaction and is automatically transformed into at least one ordered task, wherein the at least one ordered task is linked by at least one temporal ordering constraint, and is used to generate at least one change plan useable for managing the distributed computing system, wherein the change plan is based on at least one requested change.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08515799&OS=08515799&RS=08515799
owner: International Business Machines Corporation
number: 08515799
owner_city: Armonk
owner_country: US
publication_date: 20120417
---
This application is a divisional of U.S. patent application Ser. No. 11 560 525 filed on Nov. 16 2006 the disclosure of which is incorporated by reference.

The present invention relates to distributed computing systems and more particularly to systems and methods for constructing change plans from one or more component interactions.

Implementing changes for hardware software network and storage systems in large scale electronic business e Business environments remains burdensome to customers. Rolling out changes such as installing and uninstalling upgrading or configuring systems can take weeks partly because the complex interdependencies between applications and their supporting services are not made explicit. Therefore human involvement and expertise is required.

Solving this change management problem automatically is advantageous in addressing the increasing complexity of computing systems. The number of relationships of a single computing resource for example a software component a network component and a storage system range from 10 to 100. The number of computing resource instance relationships in large scale enterprise systems is often between 1 000 000 and 1 000 000 000. Given that a change to one or more computing resources may entail additional changes on a multitude of other computing resources it is evident that minimizing the need for human involvement in the change management process would be advantageous.

Change management is a process that offers many automation challenges. The organizational frameworks behind existing change management processes tend to be ill defined and highly variable in detail and formality. This makes it difficult to identify tasks for automation or to reuse standardized automation across environments within or between information technology IT organizations for example this is a particular problem for corporate mergers . Additionally effective change management requires a great deal of accurate information on technical constraints such as dependencies between IT services the components that implement them and the infrastructure supporting them. This information is rarely documented formally or kept up to date therefore hindering change assessment and change impact prediction.

Existing approaches involving service providers and enterprise IT departments require setting up staging areas where changes are repeatedly tested to expose their potential impacts and adjusted accordingly before they can be safely deployed into production environments. Building staging environments is done manually in a step by step fashion and is documented in textual documents termed build sheets or run books that are written in a natural language. Build sheets and run books are used to construct the production system which is typically significantly larger than the staging system. This textual human readable representation however restricts the usage and execution of build sheets and run books to humans only. In particular neither build sheets nor run books can be executed by an automated software deployment and provisioning system.

Existing approaches in the area of dependency management fall into three categories. The first category of approaches requires user input that is the manual entry of dependencies. An existing approach in this category is U.S. patent application Ser. No. 09 835 528 entitled Method and Apparatus for Identifying Software Components Using Object Relationships and Object Usages in Use Cases filed Apr. 17 2001. This approach includes obtaining object dependency and object usages information from a user. Another existing approach in this first category is U.S. patent application Ser. No. 09 750 305 entitled System and Method for Managing Dependencies in a Component Based System filed Dec. 29 2000. This approach includes defining a resource that is part of an entity recording a resource specifier for the resource and recording resource dependency relationship definitions for the resource.

The second category of dependency management approaches requires access to the source code of the particular application in order to derive dependencies. An existing approach in this category is U.S. patent application Ser. No. 09 865 300 entitled System and Method for the Manipulation of Software filed May 24 2001. This approach includes analyzing a body of source code and deriving a set of components from the software architecture inherent in the body of source code. Another existing approach in this second category is U.S. patent application Ser. No. 09 839 644 entitled Methods and Systems for Identifying Dependencies Between Object Oriented Elements filed Apr. 20 2001. This approach includes allowing a developer to simultaneously view a graphical and a textual display of source code.

The third category of dependency management approaches requires the presence of appropriate management instrumentation that surfaces dependency information. An existing approach in this category is U.S. patent application Ser. No. 10 055 426 entitled Method and Apparatus for Distributed Systems Management filed Jan. 23 2002. This approach includes providing a first agent monitoring a first managed device. Another existing approach in this third category is U.S. patent application Ser. No. 10 021 535 entitled Methods and Apparatus for Managing Components in an IT System filed Dec. 21 2001. This approach includes discovery of components carried out using fingerprints of components which can include key elements of the component that exist in a full model of all of the elements of the component.

Existing approaches in the area of software development include U.S. Pat. No. 4 751 635 which includes a host computer extracting information from each of the support system databases to obtain data indicative of development activity for various phases of the life cycle of the software system. Another existing approach in this area is U.S. Pat. No. 5 960 196 which includes a metric collector that provides a list of available metrics related to software development tests and loads building for the user s selection.

Existing approaches in the area of maintenance include U.S. Pat. No. 5 493 682 which includes assembling executable systems from defined component parts such as source code files and object code files.

Existing approaches in the area of software packaging include U.S. Pat. No. 5 835 777 which includes combining listed files the needed resources and any related installation materials.

Existing approaches in the area of electronic software distribution of whole program packages include U.S. Pat. No. 6 009 525 which includes software products being wrapped by their publishers in a straightforward secure manner but in such a way as to allow for the addition of information by downstream distribution channel partners for example distributors and merchants resellers . Another existing approach in this area is U.S. Pat. No. 5 721 824 which includes installation of each dominant or primary package and installation of the dependent or secondary packages dependent on that dominant package.

Existing approaches in the area of updates and or corrections and or fixes and or patches include U.S. Pat. No. 5 999 740 which includes accessing a remote file server to obtain a release file containing a list of software applications available from the remote server and comparing the release file with the registration file to determine which of the installed applications have upgrades available. Another existing approach in this area is U.S. Pat. No. 5 805 891 which includes determining whether the software maintenance module requires test and submitting the module to test if required.

Existing approaches in the area of determining conflicts in existing software and or hardware configurations include U.S. Pat. No. 5 867 714 which includes communications circuitry that from time to time automatically transmits at least part of the current hardware and software configuration data of the computer system to a remote data source capable of identifying inherent conflicts in the hardware and software configuration.

The existing change management approaches rely on detailed static or design information source code or management instrumentation.

It would thus be desirable to overcome these and other limitations in existing change management approaches.

Principles of the present invention provide techniques for constructing change plans from one or more component interactions.

For example in one aspect of the invention a computer implemented technique for constructing at least one change plan includes the following steps. At least one interaction between two or more components of at least one distributed computing system is observed. The at least one interaction is consolidated into at least one interaction pattern. The at least one interaction pattern is used to construct at least one change plan wherein the at least one change plan is useable for managing the at least one distributed computing system.

In another aspect of the invention a computer implemented technique includes the following steps. A partial order of two or more changes is determined from at least one component interaction in at least one distributed computing system. The partial order of two or more changes is automatically transformed into at least one ordered task wherein the at least one ordered task is linked by at least one temporal ordering constraint. The at least one ordered task is used to generate at least one change plan useable for managing the at least one distributed computing system wherein the at least one change plan is based on at least one requested change.

In contrast to the above mentioned limitations in existing approaches principles of the invention overcome such shortcomings by for example being able to generate change plans even if no reliable dependency information is present.

One or more embodiments of the invention may provide one or more beneficial technical effects such as for example eliminating the requirement that the distributed system provide management instrumentation. Furthermore one or more embodiments of the invention may provide one or more beneficial technical effects such as for example eliminating the need for available source code.

These and other objects features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof which is to be read in connection with the accompanying drawings.

Change plans are partially ordered sets of tasks where the order in which changes are carried out will transition a computing system from a workable state into another workable state.

The identification and tracking of relationships between the components of distributed computing systems is advantageous for automated change management. For example software components rely on a variety of supporting components. Consequently applying a change to one component affects other components that is components have dependencies on other components. Dependencies exist between components on a single system and also between the components on multiple systems and organizational domains.

As used herein dependents refer to components that depend on others and antecedents refer to components on which other components depend.

A component often plays the role of both dependent and antecedent for example a component providing a name service is required by many applications and services but is depending itself on the proper functioning of other components such as the operating system and the network protocols and infrastructure thus leading to a dependency hierarchy that can be modeled as a directed graph.

Furthermore dependency relationships are transitive that is the dependent of a given component requires in addition to the component itself the component s antecedent or antecedents as well. Dependencies exist between various components of a distributed system such as for example end user services system services applications networking infrastructure components and their logical and physical components.

One or more embodiments of the present invention generate dependency relationship information by observing one or more interactions among the components of a distributed system at run time. Therefore one or more embodiments of the present invention are able to generate change plans even if no reliable dependency information is present. Consequently the distributed system need not provide management instrumentation nor is there a need for the availability of source code. These features distinguish one or more embodiments of the present invention from the existing approaches in the area of change management.

In contrast to the existing approaches one or more embodiments of the present invention generate change plans from observing and capturing the interactions occurring in a running system and subsequently condensing the interactions into interaction patterns. Furthermore one or more embodiments of the present invention transform the captured component interactions into task sequences that are linked by temporal ordering constraints. Examples of such constraints are Task X must finish before task Y can begin Task X cannot start until task Y does Task X cannot finish before task Y does and Task X cannot finish until task Y starts. Constraints apply to various types of change tasks such as for example install uninstall configure start and stop.

One or more embodiments of the invention include a system that automatically captures component interactions and their subsequent automated processing into change workflows. It is to be appreciated that a workflow is the movement of tasks through a work process. Also one or more embodiments of the invention determine the order in which changes need to be carried out to transition one or more computing systems from a workable state into another workable state. The output of one or more embodiments of the invention can be consumed and modified by for example planning tools schedulers workflow editors workflow management engines and automated provisioning systems for data centers or by enterprise software distribution and configuration tools. Furthermore one or more embodiments of the present invention are able to store computed change workflows for subsequent reuse.

One having skill in the relevant art will recognize that modifications in the way dependencies are obtained as well as the representation of dependencies may be made without departing from the spirit and scope of the present invention. By way of example and not limitation additional sources of dependency information may be available. With additional sources of information containing actual dependencies between components of a distributed system the change plan generator is able to determine the steps of a change as well as the order in which they have to be carried out. As used herein change plan refers to a representation of such information that is the steps of a change as well as the order in which they have to be carried out .

Information stored within a change plan is specific to a given combination of components and may be decoupled from the computing systems and their characteristics for example computer processing unit CPU speed random access memory RAM free and or available disk space .

The purpose of the change plan generator disclosed herein is to construct reusable change plans for various change management operations from component interactions. As noted above change plans describe the partial order in which tasks need to be carried out in order to transition a computing system from a workable state into another workable state. Therefore a change plan may contain for example information about the change management operation that needs to be carried out for example install update configure or uninstall . Also a change plan may contain for example information about the roles and names of the components that are subject to a change as well as the temporal and location constraints that may exist between tasks based on component dependency information.

In one or more embodiments of the present invention a change plan may contain in addition to the aforementioned exemplary data information that relates to the specific hardware characteristics of a computing system such as CPU speed RAM or total and or available disk space or names and internet protocol IP addresses of computing systems. However one having skill in the relevant art will recognize that modifications in the types of data contained within change plans as well as their representation may be made without departing from the spirit and scope of the present invention.

One or more embodiments of the present invention add architectural elements to a change management system that enable such a system to initiate a change trigger the acquisition of dependency relationship information along with temporal constraints identify interaction patterns and automatically process the patterns into change plans. By way of example one or more embodiments of the invention use component interactions to determine whether change tasks must be carried out sequentially or whether some or all of the change tasks can be carried out in parallel. It should be noted that the applicability of one or more embodiments of the invention is not confined to the problem area of software provisioning and maintenance. One or more embodiments of the invention also can be used for other changes as they occur either during the configuration or reconfiguration of computing and software systems in general purpose project management or changes in already packaged software products.

Given the above realizations made in accordance with one or more embodiments of the present invention and general features associated therewith the remainder of the detailed description will provide an illustrative explanation of techniques for implementing such realizations and features in the context of .

In a preferred embodiment the system for generating change plans including at least an interaction observer as illustrated in an interaction pattern detector as illustrated in and a change plan generator as illustrated in is implemented as a background server process also referred to as a daemon that is listening for incoming requests. If a request for constructing a change plan in step is received from for example an administrator the change plan generator is invoked in step .

Input parameters are extracted in step from the request. Examples of such parameters may include but are not limited to whether a change plan for the entire distributed computing system is requested or whether the request applies only to parts of the overall system. Additional examples of input parameters may include the name of the component or components to which the change applies the system names and the change management operation.

The component interactions of the staging system are recorded by way of invoking the interaction observer which monitors observes and captures in step all transactions that the staging system is executing. The recorded component interactions are submitted to the interaction pattern detector which extracts one or more patterns from the data stream thereby significantly reducing the volume of data and identifying the characteristic data flow structure in step throughout the observed system. The identified interaction patterns are sent in step to the change plan generator a purpose of which may be for example to transform the interaction pattern or patterns into a dependency model in step and determine task relationships and relationship constraints for example finish to finish FF finish to start FS start to finish SF and start to start SS in step . Also the change plan generator may perform task consolidation to construct the change plan in a machine readable format such as a general purpose workflow language.

Additionally the change plan may be stored in step in a change plan library as illustrated in for subsequent reuse. Once the change plan for a given request has been generated and stored the system may in one or more embodiments of the invention proceed back to step to await further requests. A preferred embodiment of the invention allows the construction of change plans for both install type scenarios for example change management operations such as install deploy start and update and uninstall type scenarios for example change management operations such as uninstall undeploy stop and undo from the same set of interaction patterns. Also in a preferred embodiment of the invention the techniques may be invoked concurrently in order to service multiple requests at once.

An exemplary element may include an interaction observer . An interaction observer is contained in the same hosting environments for example operating system servlet Enterprise JavaBeans EJB container as the distributed components and it tracks the invocation of operations on other components over time. In two invocations and at different points in time visualized by the solid and dashed arrows of component A lead to an invocation of component B which results in further interactions with component C component D which leads to an interaction with component E .

Another exemplary element may include an interaction pattern detector . An interaction pattern detector inputs the tracking data generated by the interaction observer . In the two invocations of component A and solid and dashed arrows lead to further invocations with components B C D and E . However since the invocation pattern is identical the interaction pattern detector consolidates these interactions into a single interaction pattern.

Yet another exemplary element may include a change plan generator . A change plan generator inputs the data of the interaction pattern detector and constructs a change plan which may for example have the structure of a directed graph. The structure of an exemplary graph may follow the invocation order of the components. In a preferred embodiment the notation in which a change plan is described is a workflow language such as for example the Web Services Business Process Execution Language WS BPEL . Also the change plan generator takes into account the different change management operations by constructing a change plan either for every single change management operation and or change management pattern. Consequently newly constructed nodes in the graph representing the activities include the name of the component and are tagged with the type of change management operation .

For purposes of completeness one or more embodiments of the present invention may also include an administrator .

Also another exemplary element may include a change plan library . A change plan library is a repository for storing newly constructed change plans for subsequent reuse and processing.

In a preferred embodiment a pattern extraction algorithm identifies interactions that have a causal relationship. There are many methods in the existing approaches to detect a causal relationship. In a preferred embodiment we consider two interactions related by causality if the first interaction causes an event on a system in the same thread as a second interaction on the same system. There are other methods to establish causality such as for example the propagation of an explicit correlation identifier.

As used herein transaction refers to a set of all interactions related by causality. As used herein the term transaction is used in a different way than what is sometimes defined in the context of databases or atomic actions. By way of example a transaction may include a sequence of messages and invocations initiated by an action such as for example booting up a machine. A transaction typically passes through one or more components and may branch off. Therefore the structure of a transaction may be a tree. One or more embodiments of the invention process a set of transactions as trees and categorize them into groups or subsets.

One skilled in the relevant art will appreciate that it is possible to use similar algorithms to extract patterns from a large amount of interactions recorded by the interaction observer . An exemplary result of a pattern extraction is illustrated on the right side of .

By way of example depicts that computing system X plays the role of a web application server and hosts a number of components described below. The electronic enterprise e enterprise application which may for example be implemented by a total of 14 servlets. Servlets may include for example BuyRequest buyreq AdministratorConfiguration admcnf AdministratorRequest admreq BestSellers bestsell BuyConfirmation buyconf CustomerRegistration custreg home NewProducts newprod ProductDetails proddet SearchResults srchres ShoppingCart shopcart SearchRequest srchreq OrderInquiry ordering and OrderDisplay ordrdisp . As illustrated in the example of each servlet corresponds to a possible transaction on a website. For example the specific example website used in is a bookseller s web storefront but one or more embodiments of the present invention could be used with any other web application. By way of example some of the servlets may encapsulate the business logic of the application.

The servlet container may be implemented for example by IBM WebSphere Application Server WAS servlet container. The operating system OS may be for example Linux version 7.2.

Computing system Y plays the role of a database server and can host a variety of components as described below. In one embodiment of the present invention the components may include 10 database tables. Database tables may include for example credit card transaction table cc xacts ShoppingCartLineItem shop cart L ShoppingCart shop cart author item customer country address OrderLineItem order line and orders . Database tables may for example hold the data accessed by the servlets.

In one or more embodiments of the present invention the database tables reside within a database implemented for example by IBM DB2 Universal Database UDB version 8.1 and also within an operating system OS such as for example IBM Advanced Interactive Executive AIX version 5.1.

A request may be submitted for example by an administrator to the change plan generator specifying that two servlets BestSellers bestsell and OrderDisplay ordrdisp need to be installed on host system X . This is one example of building a change plan for a partial system as only a subset of the overall distributed system considered for the construction of the change plan.

In one or more embodiments of the invention it may be assumed that the operating system is already present on host system X . In addition it may be assumed that operating system is already present on host system Y . Also in one or more embodiments of the invention it is assumed that the change management system is subject to an operational policy stating that a servlet container must be installed on a different system than a database.

The invocation of the change plan generator for a request yields one or more dependencies. By way of example various dependencies are depicted in by dashed lines. For example as illustrated in the bestsell servlet depends only on the servlet container on host system X . This dependency is illustrated by the arrow labeled . The ordrdisp servlet in contrast depends on both the servlet container on host system X as well as on the credit card transaction table CC XACTS on host system Y . The former dependency is illustrated by the arrow labeled and the latter dependency is illustrated by the arrow labeled . Consequently in the exemplary depiction of it would be advantageous to determine the allowable partial order in which the following components can be installed on two or more systems bestsell servlet ordrdisp servlet servlet container CC XACTS table and database .

We now turn to which is a diagram illustrating task relationships and relationship constraints according to an embodiment of the present invention. In one or more embodiments of the invention a dependency model is needed in a granularity that specifies the one or more components required by each individual component. As such information is often not directly available the change plan generator generates this information as described below. The change plan generator invokes the interaction observer as well as the interaction pattern detector . The change plan generator also transforms the obtained interaction pattern into a dependency graph to determine whether tasks implied by a change must be carried out sequentially or whether some of the tasks can be carried out concurrently.

Different change management operations require different traversals through the dependency model. By way of example and not limitation a request for a new installation of a component leads the change plan generator to determine which components must already be present before a new component can be installed. On the other hand for example a request for an update or a request for an uninstall of a component will result in determining the components that will either be impacted by the change or which need to be removed first to preserve the integrity of the system.

By way of another example if an installation change management operation needs to be carried out the consideration of the results of the relationship traversal carried out by the change plan generator yields that the tasks described below are subject to relationship constraints.

With this information the change plan generator can proceed with consolidating the tasks in order to construct the change plan.

By following the above rules a change plan generator in one or more embodiments of the invention is able to consolidate the task relationships depicted in into an exemplary change plan as described below including two sequences that are grouped on a per host basis and aggregated into a process.

We now turn to which is a flow diagram illustrating steps for determining the partial order of changes and task durations according to an embodiment of the present invention. In one or more embodiments of the invention the algorithm begins at step and includes additional steps as described below. Upon receipt of a new request the change plan generator extracts the relevant parameters from the request in step . Examples of a parameter may include whether the construction of a change plan for the entire distributed computing system is requested or whether the request applies only to parts of the overall system. Additional exemplary parameters may include the name of the component or components that need to be changed the computing system names and the change management operation.

The interaction pattern is obtained in step from the interaction pattern detector and transformed in step into a dependency model. Different procedures are applied according to the type of change management operation specified in the request submitted by the administrator. For example a request may specify an install change management operation in step an uninstall change management operation in step or a configure change management operation in step . One skilled in the relevant art will recognize that modifications and extensions of the change management operations may be made without departing from the spirit and scope of the invention.

In the example of a request specifying an install change management operation in step the change plan generator would perform a recursive drill down operation in step on the dependency model. A list of components to be installed would be returned as well.

In the example of a request may specify an uninstall change management operation in step the change plan generator would perform a recursive drill up operation in step on the dependency model to retrieve a list of components that would be impacted by the update change management operation.

In the example of a request may specify a configure change management operation in step the change plan generator would perform a recursive drill up operation in step on the dependency model to retrieve a list of components that would be impacted by the configure change management operation.

In the examples described above the change plan generator would also create the task relationships as well as the relationship constraints in step from the data contained in the dependency model. The change plan generator also performs the task consolidation step to generate a change plan in step . The change plan is stored in the change plan library in step and returned to the administrator for further processing.

Also the change plan generator may verify whether one or more new requests for change RFCs have arrived for which the procedure needs to be repeated in step . If a new request has arrived one or more embodiments of the invention will retrieve a new request in step and transition in step to step . If a new request has not arrived one or more embodiments of the present invention will end at step .

In one or more embodiments of the present invention the dependency model contains a list of component tuples. The overall list of tuples is referred to herein as a candidate list. In one or more embodiments of the invention it is assumed that every tuple contains first the antecedent and then the dependent component each prefixed with the name of the change management operation the administrator has specified in the request. Every element of a tuple can then be referred to as a task. In one or more embodiments of the present invention the first element of a tuple is the predecessor task and the second element is the successor. An example of a task is Install servlet container on host X .

Also every tuple stores a precedence constraint such as for example FS SS SF and or FF that annotates the dependency link. One skilled in the relevant art will recognize that modifications and extensions to the way the dependency graph is represented may be made without departing from the spirit and scope of the invention.

As illustrated in one or more embodiments of the invention determine if the list of candidates is empty that is no tuples are present in step . If the list of candidates contains one or more tuples a tuple is selected from the candidate list in step . No assumptions are being made with respect to the order of the tuples in the candidate list. Also the tuple selection can happen in any order since the candidate list is essentially an unordered set of tuples. Once a tuple is selected the precedence constraint is read in step and stored for further processing.

One or more embodiments of the present invention also determine if the tuple is empty that is no tasks are present in step . If the tuple is not empty a task is selected from the tuple. Here the order in which the tasks are chosen matters because the first element of a tuple is the predecessor while the latter task within the tuple is the successor. Once a task has been selected in step the hostname is extracted in step from the task by applying a simple read operation to the task suffix. Additionally one or more embodiments of the present invention may determine if a sequence for example a container that stores tasks in a partial order for the chosen host already exists in step . If a sequence for the host does not exist a host sequence is created in step and subsequently the currently selected task is inserted into the host sequence in step . If a sequence for the host does exist a determination is made as to whether the task already exists in the host sequence in step . This is needed to prevent duplicate tasks in a host sequence. If the task is not already part of the host sequence it is inserted into the host sequence in step . Otherwise one or more embodiments of the present invention proceed to remove the task from the tuple in step .

The task is removed from the tuple in step because it has already been processed. One or more embodiments of the present invention verify again if the tuple is empty in step and proceed to insert the outgoing link reference into the task in step if there is still a task in the tuple. A remaining task is by definition the successor task as the predecessor has already been removed from the tuple in step and placed into the host sequence. Consequently step inserts an outgoing link reference that is a pointer to a successor task referring to the successor by its name in the task of the host sequence. One or more embodiments of the present invention proceed then to step and apply the task procedure steps through to the remaining successor task and remove this task from the tuple afterwards in step . This is advantageous because the successor task may refer to a different host for which a host sequence may either already exist or not.

Also a check for task duplicates in step may be carried out for the successor task as well. After the removal of the successor task the tuple is then empty and the check in step yields a positive result. One or more embodiments of the present invention may proceed to step where the precedence constraint that is embedded in the link reference of the incoming link reference of the successor task being contained in the host sequence potentially from a previous iteration of the algorithm is compared to the precedence constraint that is kept in memory for the current tuple instance. This is advantageous to ensure that the precedence constraint specified in the most recently inserted tuple is consistent with a precedence constraint between the same tasks that may have been inserted into the host sequence previously.

If it is determined in step that the newly inserted precedence constraint is different from the precedence constraint that is already stored one or more embodiments of the present invention exit with an error condition in step and subsequently end in step . This check is preferably carried out only once for the incoming link reference of the successor task because its precedence constraint is by definition identical to the precedence constraint stored in the outgoing link of the predecessor task.

If the newly inserted precedence constraint is identical to the precedence constraint that is already stored one or more embodiments of the present invention proceed to step and insert an incoming link reference into the successor task before continuing at step with the removal of the already processed tuple from the candidate list. One or more embodiments of the present invention may additionally proceed to step and determine if the techniques need to be repeated for one or more additional tuples contained in the candidate list. If however no more tuples remain for processing that is the list of candidates is empty the completed change plan is stored in the change plan library in step and the algorithm ends in step .

The following table depicts examples of the change plan generator application programming interfaces APIs . The table includes base APIs that can generate send and request receipt of partial orders of change management tasks for a given service and host name. Those skilled in the art will appreciate that the APIs can use one or more parameters either shown not shown or in any combination thereof to identify characteristics as for example specified in the Functional Description column used by the APIs.

Specifically the constructChangePlanForInstall parameters API builds the change plan for the install change management operation based on a recursive Drill Down carried out by the dependency service. The constructChangePlanForUpdate parameters API builds the change plan for the update change management operation by invoking a recursive Drill Up on the dependency service. It retrieves all the dependents of a given component that is the components in the dependency hierarchy that are likely to be affected by an update change management operation. The constructChangePlanForUninstall parameters API builds the change plan for the uninstall change management operation. The constructChangePlanForRollback parameters API builds the change plan for the rollback change management operation which is the opposite operation of update and restores the previously updated version of a component. The constructChangePlanForInitialConfigure parameters API builds the change plan for the initial configure change management operation which applies basic configuration settings to a component which are needed to install it in the first place. The constructChangePlanForConfigure parameters API builds the change plan for the configure change management operation which applies advanced configuration settings to a component so that it can be customized.

In one or more embodiments of the present invention the step of constructing at least one change plan includes constructing at least one change plan in a machine readable format by taking into account at least one change management operation and at least one change management pattern. The step of constructing at least one change plan may also include reverse engineering a blueprint of at least one staging system at run time. Also the step of constructing at least one change plan may include identifying at least one algorithm step and or procedure applicable to changing a distributed computing system. For example the at least one algorithm step and or procedure may be applicable in the constructing step or in the removal and or update functions or in other operations included in the techniques.

In one or more embodiments of the present invention the techniques may include facilitating an administrator to identify the at least one algorithm for the at least one distributed computing system as a whole or for selected parts of the distributed computing system. Also one or more embodiments of the invention may include expressing at least one identified algorithm in a machine readable format such as a workflow and or a computer program. The workflow and or computer program may be persistently stored or subsequent reuse. Also one or more embodiments of the present invention may include facilitating retrieval of the workflow and or computer program to build a production system automatically. Building the production system may include loading the workflow and or computer program into an automated deployment and provision system and executing the workflow and or computer program.

In one or more embodiments of the invention techniques for constructing at least one change plan may further include the step of storing the at least one change plan for subsequent reuse and processing in a change plan library.

Economies of scale are accomplished because the knowledge gleaned from a smaller scale staging system can be reused for the construction of a production system that is typically at least a magnitude larger than the staging system. In addition persistently storing the constructed change plans in a change plan library allows their reuse whenever similar computing systems need to be built in the future.

In one or more embodiments of the present invention the techniques for automatically determining at least one change plan include a change plan generator an interaction observer and an interaction pattern detector.

The step of generating at least one change plan may include computing allowable sequences of changes by observing one or more interactions between computing systems. Also in one or more embodiments of the invention generating at least one change plan includes minimizing total change time by exploiting parallelism between two or more components. The step of generating at least one change plan may also include an administrator accepting the at least one requested change and explicitly identifying the at least one computing system. In one or more embodiments of the present invention the administrator identifies the computing system or systems to reverse engineer by observing the transactions it handles.

A variety of techniques utilizing dedicated hardware general purpose processors firmware software or a combination of the foregoing may be employed to implement one or more embodiments of the present invention. One or more embodiments of the invention can be implemented in the form of a computer product including a computer useable medium with computer useable program code for performing the method steps indicated. Furthermore one or more embodiments of the invention can be implemented in the form of an apparatus including a memory and at least one processor that is coupled to the memory and operative to perform exemplary method steps.

One implementation of the present invention makes substantial use of software running on a general purpose computer or workstation. With reference to such an implementation might employ for example a processor a memory and an input and or output interface formed for example by a display and a keyboard . The term processor as used herein is intended to include any processing device such as for example one that includes a CPU central processing unit and or other forms of processing circuitry. Further the term processor may refer to more than one individual processor. The term memory is intended to include memory associated with a processor or CPU such as for example RAM random access memory ROM read only memory a fixed memory device for example hard drive a removable memory device for example diskette a flash memory and the like. In addition the phrase input and or output interface as used herein is intended to include for example one or more mechanisms for inputting data to the processing unit for example mouse and one or more mechanisms for providing results associated with the processing unit for example printer . The processor memory and input and or output interface such as display and keyboard can be interconnected for example via bus as part of a data processing unit . Suitable interconnections for example via bus can also be provided to a network interface such as a network card which can be provided to interface with a computer network and to a media interface such as a diskette or CD ROM drive which can be provided to interface with media .

Accordingly computer software including instructions or code for performing the methodologies of the invention as described herein may be stored in one or more of the associated memory devices for example ROM fixed or removable memory and when ready to be utilized loaded in part or in whole for example into RAM and executed by a CPU. Such software could include but is not limited to firmware resident software microcode and the like.

Furthermore the invention can take the form of a computer program product accessible from a computer useable or computer readable medium for example media providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer useable or computer readable medium can be any apparatus for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory for example memory magnetic tape a removable computer diskette for example media a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read and or write CD R W and DVD.

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus . The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code is retrieved from bulk storage during execution.

Input and or output or I O devices including but not limited to keyboards displays pointing devices and the like can be coupled to the system either directly such as via bus or through intervening I O controllers omitted for clarity .

Network adapters such as network interface may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters.

In any case it should be understood that the components illustrated herein may be implemented in various forms of hardware software or combinations thereof for example application specific integrated circuit s ASICS functional circuitry one or more appropriately programmed general purpose digital computers with associated memory and the like. Given the teachings of the invention provided herein one of ordinary skill in the related art will be able to contemplate other implementations of the components of the invention.

Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings it is to be understood that the invention is not limited to those precise embodiments and that various other changes and modifications may be made by one skilled in the art without departing from the scope or spirit of the invention.

