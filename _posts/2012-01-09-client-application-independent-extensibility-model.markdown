---

title: Client application independent extensibility model
abstract: Information describing a type registration regarding which an action is being requested by the client application is received as one or more parameters of an application programming interface method invoked by the client application. Based on the one or more parameters, one of multiple type extensions to which the action being requested corresponds is determined. At least part of the information describing the type registration is sent to the one of the multiple type extensions, and the one of the multiple type extensions performs the action being requested.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667514&OS=08667514&RS=08667514
owner: Microsoft Corporation
number: 08667514
owner_city: Redmond
owner_country: US
publication_date: 20120109
---
This application is a continuation of U.S. patent application Ser. No. 12 465 812 now U.S. Pat. No. 8 117 622 filed May 14 2009 entitled Client Application Independent Extensibility Model to Aditya Rastogi et al. which is hereby incorporated by reference herein.

Many computer operating systems are extensible allowing additional applications to be installed to extend the functionality provided by the computer through the operating system. While such extensibility can make additional functionality available to users it is not without its problems. Different applications can install and uninstall extensions on computers in different ways resulting in the additions and removals of extensions that are performed in inconsistent manners. Furthermore when applications are uninstalled the different ways in which extensions can be removed can result in the computer operating system being left in inconsistent states. These different manners in which extensions can be added and removed can thus result in inconsistent computer operating system states and provide inconsistent user experiences which degrade the user experience with the computer.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

In accordance with one or more aspects information describing a type registration regarding which an action is being requested by a client application is received as one or more parameters of an application programming interface method invoked by the client application. Based on the one or more parameters one of multiple type extensions to which the action being requested corresponds is determined At least part of the information describing the type registration is sent to the one of the multiple type extensions for the one of the multiple type extensions to perform the action being requested.

In accordance with one or more aspects a type extension receives from a type extension interface a registration payload identifying a type registration for an action being requested by a client application. The type extension interface obtained the registration payload via the client application invoking an application programming interface method of the type extension interface. The type extension performs the requested action based at least in part on a store associated with the type extension.

A client application independent extensibility model is discussed herein. A type extension interface operates as an interface between a client application and one or more type extensions. During operation the client application can perform various actions on type registrations for a registration store corresponding to a type extension including additions and removals of type registrations. The client application requests an action be performed on a type registration by invoking an application programming interface API method of the type extension interface. The type extension interface in turn communicates with the appropriate type extension to carry out the requested action. The client application can also provide a callback object to allow communication between the client application and the type extension via the type extension interface regarding the requested action.

Computing device includes a type extension interface and multiple m type extensions . . . m . Although multiple type extensions are illustrated in it is to be appreciated that computing device can alternatively implement a single type extension . Type extension interface and type extensions are typically implemented as a module or component of an operating system of computing device although alternatively interface and or one or more extensions can be implemented separately from operating system .

Each type extension is a module or component that provides a point of extensibility for computing device typically providing a point of extensibility for operating system . Each type extension can extend the functionality of operating system in a variety of different manners performing various requested actions on registrations in a corresponding store. For example a type extension can extend file associations allowing a particular file extension e.g. a file ending in .mp3 .jpg .txt and so forth to be associated with a different default application so that the default application is run when a user requests to access a file having that particular file extension. By way of another example a type extension can extend a Class ID CLSID to be associated with different Program IDs ProgIDs . The functionality of operating system can also be extended in a variety of other manners using type extensions such as establishing firewall rules establishing error tracking and or reporting rules and so forth.

Each type extension has an associated or corresponding store in which type registrations are stored. Each type extension can have a dedicated store that is used by only that type extension or alternatively a single store can be used by multiple type extensions and or other programs or modules. For example one or more type extensions may use a registry or registration store of operating system as its associated store . Each store can be implemented using a variety of different storage media such as random access memory RAM Flash memory a magnetic disk an optical disc and so forth.

Each type registration maintained in a store describes a particular extension of the functionality of operating system . The specific nature of each extension included in a type registration can vary based on the associated type extension . For example a particular type registration can identify a file association can identify a firewall rule can identify an error tracking and or reporting rule and so forth.

Type extension interface includes a control module a client interface and an extension interface . A client application running on computing device can communicate requests indirectly to type extensions via type extension interface . Client application is typically an installer application configured to install one or more applications not shown on computing device and or uninstall one or more other applications not shown on computing device . Alternatively client application can be other types of applications.

Client interface exposes an application programming interface API having one or more methods that can be invoked by client application to request one or more actions be taken regarding a type registration. Control module analyzes requests received from client application determines the appropriate type extension to which the request is to be sent and sends the request to the appropriate type extension via extension interface . Client application can also provide callback object to client interface . Type extensions and client application can communicate information to one another via type extension interface and callback object .

Client interface exposes an API with one or more methods that can be invoked by client application . One API method exposed by client interface allows client application to pass to type extension interface one or more parameters requesting that an action be taken regarding a type registration. In one or more embodiments these one or more parameters include a type extension identity parameter an action parameter and a registration payload parameter. Alternatively one or more of the type extension identity parameter action parameter and registration payload parameter can be combined into one parameter or alternatively separated into multiple parameters.

The type extension identity parameter is a value that is an identifier of a type extension . The type extension identifier allows client application to specify a particular one of type extensions to which the request corresponds. The type extension identifier allows the different type extensions to be distinguished from one another by client application as well as type extension interface . The type extension identifier can be a Globally Unique ID GUID or alternatively another identifier that allows the different type extensions to be distinguished from one another.

The action parameter is a value that is an identifier of a type of action being requested by client application with the request. Various different actions can be supported by type extension interface such as one or more of an install action an uninstall action a patch action a query version action and a query registration action. It is to be appreciated that these different actions are examples and that alternatively other actions can be supported by type extension interface and or one or more of these actions may not be supported by type extension interface . The registration payload parameter includes the data for the request. The data for the request can vary based on the desires of client application and the particular action being requested as discussed in more detail below. In one or more embodiments the data for the request is in an eXtensible Markup Language XML format although other formats can alternatively be used.

The install action indicates that a new type registration is to be added to a store . New type registrations are typically added when client application is installing an application on computing device although new type registrations can alternatively be added at other times. The registration payload for an install action identifies the particular registration that is to be added to a store . For example if the new type registration were to be a new file association then the registration payload would include the new file association being registered.

When client interface receives a request that includes an install action control module identifies the type extension to which the request corresponds based on the type extension identifier in the request. Control module then passes the request including an indication of the install action and the registration payload to the corresponding type extension . In one or more embodiments each type extension implements an API that is similar to that implemented by client interface . Alternatively the interface exposed by each type extension can be exposed in different manners and can be implemented differently than the API that is implemented by client interface .

The type extension corresponding to the request receives the install action and the registration payload from type extension interface . In response to the request type extension generates a rollback payload that identifies a state of at least part of the store corresponding to the type extension before the requested action is performed. This state is typically the state of at least part of the store at the time the request is received by the type extension . The rollback payload can be the state of the entire store or alternatively only a portion of the store . Whether the entire store or only a portion of the store is included in the rollback payload can be determined in different manners such as being pre programmed into type extension being a configuration setting of type extension being based on the received registration payload and so forth. Additionally it is to be appreciated that valid states of the store can be captured for the rollback payload but any non valid states need not be captured.

In one or more embodiments for the rollback payload type extension determines the current state of a type registration when a request to install a new type registration is received. This current state refers to the type registration and settings or values stored as part of that type registration in the store corresponding to the type extension . For example if a request to install a new file association is received type extension determines the current state if any of the file association e.g. the default application for handling files with the file extension identified in the registration payload and stores that current state in the rollback payload. By way of another example if a request to install a new firewall rule is received type extension determines the current state if any of that firewall rule and stores that current state in the rollback payload.

Type extension returns the rollback payload to extension interface . The rollback payload or an identifier of the rollback payload can be returned to interface as a response value in response to an API method that was invoked to pass the action and registration payload to type extension . Alternatively the rollback payload or an identifier of the rollback payload can be returned to interface by invoking an API method exposed by extension interface or alternatively in other manners.

Control module then returns the rollback payload to client application via client interface . The rollback payload or an identifier of the rollback payload can be returned to client application as a response value in response to the API method that was invoked by client application to pass the request to type extension interface . Alternatively the rollback payload or an identifier of the rollback payload can be returned to client application by invoking an API method exposed by client application via callback object or alternatively in other manners.

The rollback payload provides client application with the state of the type registration and optionally additional portions of the store in which the type registration is stored as discussed above before the requested type registration is added to the store. Accordingly if client application terminates the process of installing an application client application can rollback or undo the portions of the installation process that were already performed. This rolling back includes requesting that type extension interface uninstall type registrations that were installed by client application via install requests.

In addition to generating the rollback payload type extension performs the requested installation of the type registration in the registration payload by adding the type registration to the store corresponding to the type extension. The specific manner in which the type registration is added to the store can vary based on various criteria such as the manner in which type extension is implemented the manner in which the store corresponding to the type extension is implemented and so forth. For example the registration can be performed by type extension writing one or more values to an operating system registry by type extension invoking a method of an API of a registration store and so forth.

In one or more embodiments type extension also performs additional actions to record information about the new type registration being added to the store and or the previous state of the type registration in the store . It is to be appreciated that some type extensions can record this additional information but that other type extensions do not record this additional information. When recorded this additional information can be recorded in the corresponding store in a different store in an additional local or remote store not shown and so forth. This additional recorded information can include a variety of different information such as an identifier of client application or the application being installed by client application e.g. as part of the registration payload a date and or time of the new type registration e.g. when the installation request was received from client application when the type was stored in store etc. and so forth.

This additional recorded information is maintained for each new type registration even though new type registrations may be added to store to replace previous type registrations. For example a first type registration associating a particular file extension with a first default application to be run when a user requests access to a file having that particular file extension can be stored in store . The first type registration as well as an indication of a date and time when the first type registration was added to store is maintained in the additional recorded information. A second type registration can then be stored in store replacing the first type registration with the second type registration that associates that particular file extension with a second default application. The second type registration as well as an indication of a date and time when the second type registration was added to store is maintained in the additional recorded information. A third type registration can then be stored in store replacing the second type registration with a third type registration that associates that particular file extension with a third default application. The third type registration as well as an indication of a date and time when the third file type registration was added to store is maintained in the additional recorded information.

This additional recorded information allows type extensions to operate in a more consistent and predictable manner in situations where an application is uninstalled. Following the previous example assume that the third application were to be uninstalled. The type extension can access this additional recorded information and readily identify that prior to the third type registration the second type registration was the most recent type registration for that particular file extension. Type extension can then add the second type registration to store . Type extension can also communicate with another component or module of operating system to determine if the second application identified by the second type registration has already been uninstalled. If the second application has already been uninstalled then type extension can readily identify that prior to the second type registration the first type registration was the most recent type registration for that particular file extension. Type extension can then add the first type registration to store .

An additional action that can be requested by client application is an uninstall action. The uninstall action indicates that a type registration is to be removed from a store . Type registrations are typically removed when client application is uninstalling an application from computing device although type registrations can alternatively be removed at other times. The registration payload for an uninstall action identifies the particular type registration that is to be removed from a store . For example if the type registration were to be a file association then the registration payload would include the file association that is to be removed. Alternatively rather than including the actual type registration an identifier of the type registration such as hash value generated by applying a hashing algorithm to the type registration can be included in the registration payload.

Type extension interface and the type extension corresponding to a request that includes an uninstall action operate similarly to the discussion above regarding a request that includes an install action. The request is received from client application the corresponding type extension is identified and the request is sent to the corresponding type extension . Additionally a rollback payload is generated and returned to client application allowing client application to request that the store be returned to its previous state if the uninstallation process is terminated. However for an uninstall action the type extension corresponding to the request removes the type registration identified in the registration payload from the store rather than adding the type registration identified in the registration payload to the store.

Furthermore as discussed above additional information regarding the new type registration added to the store and or the previous state of the type registration in the store can be maintained in response to an install action. When such additional information is maintained and a request that includes an uninstall action is received the type extension determines based on the recorded additional information a previous state for the type registration being removed from the store . Type extension then stores this previous state in store .

In one or more embodiments in identifying the previous state for the type registration type extension verifies that the previous state is still a valid state for the type registration. The determination of what is a valid state can vary based on the type extension and the particular type registration. For example if the type registration is a registration associating a particular file extension with a default application then type extension can communicate with one or more other components or modules of operating system to verify that the default application is still installed on computing device . By way of another example if the type registration is a registration associating a particular Class ID with a particular Program ID then type extension can communicate with one or more other components or modules of operating system to verify that the application with that particular Program ID is still installed on computing device .

An additional action that can be requested by client application is a patch action. The patch action allows a new type registration to be stored that replaces a previous type registration. Accordingly the patch action can be viewed as being similar to both an install action because the new type registration is added to a store and an uninstall action because the previous type registration is removed from a store. For a patch action client application is configured with or otherwise obtains both the new type registration that is to be added to a store and a corresponding previous type registration that is to be replaced by the new type registration.

The registration payload corresponding to a patch action includes both the new type registration and the previous type registration. Alternatively rather than including the actual previous type registration an identifier of the previous type registration can be included in the registration payload. A variety of different identifiers could be used that allow the previous type registration to be identified such as a service name for a service registration a hash value generated by applying a hashing algorithm to the type registration and so forth. This registration payload is received by type extension interface and forwarded to the appropriate type extension in the same manner as discussed above with reference to the install action. A rollback payload is also returned to client application in the same manner as discussed above with reference to the install action.

In addition for a patch action type extension also obtains a current state of the previous type registration from store . Situations can arise where the previous type registration was changed since being added to store and such changes are not reflected in the previous type registration received from client application . For example a system administrator or user may have set a configuration value associated with the previous type registration may have enabled or disabled the previous type registration and so forth. Any such changes that were made are reflected in store even though client application may not be aware of such changes.

It is to be appreciated that even though the previous type registration in store may have been changed the changed previous type registration from store can still be identified as being the type registration as the previous type registration received from client application . For example one or more parts of the previous type registration may have changed but other identifying information remains unchanged e.g. a name or identifier of the type registration other parameters or data of the type registration and so forth .

Type extension compares the previous type registration received from client application to the current state of the previous type registration obtained from store and identifies differences between the two. These differences reflect changes that were made to the previous type registration in store . To the extent that such changes correspond to a part of the new type registration e.g. a configuration value in the new type registration an enabled disabled setting of the new type registration etc. the new type registration is modified to include such changes. The modified new type registration is then stored in the store corresponding to the type extension .

Additionally in one or more embodiments the registration payload can identify whether particular parts of the new type registration are changeable. For example the registration payload can specify whether a particular configuration value in the new type registration is changeable whether an enabled disabled setting of the new type registration is changeable and so forth. In such embodiments type extension modifies the new registration type to include changes that were made to the previous type registration in store only if the registration payload indicates such changes are permitted e.g. those parts of the new registration type are changeable .

For example assume that the previous type registration is a firewall rule with a default setting of enabled and that after the firewall rule was added to the store a user changed the setting of the firewall rule to disabled. Further assume that client application desires to change that firewall rule to a new version of the firewall rule which is the new type registration. Client application submits a request with a patch action that identifies both the previous type registration the firewall rule set to enabled and the new type registration the new version of the firewall rule set to enabled . Type extension obtains the current state of the previous type registration which is the firewall rule set to disabled and changes the setting of the new version of the firewall rule to disabled thereby preserving the user s changes. Optionally type extension changes the setting of the new version of the firewall rule to disabled only if the registration payload or optionally other part of the request indicates that the disabled enabled setting of the new type registration is changeable.

The new type registration as modified by type extension is saved to store . Additional information regarding the new type registration added to the store and or the previous state of the type registration in the store is can also be maintained in an additional record as discussed above with reference to the install action.

It is to be appreciated that both the install action and the uninstall action can be viewed as particular cases of the patch action and accordingly both the install action and the uninstall action can be implemented using the patch action. The install action is a particular case of the patch action where the previous type registration is a null type registration the previous type registration can be absent or a null identifier can be used for the previous type registration . Accordingly a patch action from a null type registration e.g. from no type registration to a new type registration stores the same new type registration as an install action for the new type registration. As there is no previous type registration the current state of the previous type registration in the store would be the null state e.g. no state so type extension would not modify the new type registration based on the current state of the previous type registration.

Similarly the uninstall action is a particular case of the patch action where the new type registration is a null type registration the new type registration can be absent or a null identifier can be used for the previous type registration . Accordingly a patch action from a previous type registration to a null type registration e.g. to no type registration results in the previous type registration being removed from store . The current state of the previous type registration in the store would not result in any modification of the new type registration because there is no new type registration.

An additional action that can be requested by client application is a query version action. The query version action allows a client application to retrieve a version of a type extension . A type extension can be updated and replaced over time allowing different versions of the type extension to be available at different times on computing device . Each type extension is aware of its own version typically represented as a version number. A request with a query version action is received by type extension interface and sent to the appropriate type extension analogous to the discussions above. In response to the query version action type extension returns an indication of a version of type extension to control module via extension interface which in turn returns the indication to client application via client interface .

An additional action that can be requested by client application is a query registration action. The query registration action allows a client application to retrieve a type registration from store . As discussed above one or more settings of the type registration may have been changed after the type registration was added to store and the query registration action allows client application to retrieve the type registration and identify any such changes. A request with a query registration action is received by type extension interface and sent to the appropriate type extension analogous to the discussions above. The registration payload corresponding to a query registration action includes an identifier of a particular type registration. Type extension retrieves from store the identified type registration and returns the identified type registration to control module via extension interface which in turn returns the identified type registration to client application via client interface .

Although various actions are described it should be noted that not all actions need be supported by type extension interface . In one or more embodiments a single action e.g. the patch action is supported. It is to be appreciated that when a single action is supported an action parameter need not be provided to client interface . Rather the action is inherent in the API method.

Additionally client interface is described above as including an action parameter. Alternatively client interface can implement a different API method for each different action resulting in the action being inherently identified by the API method invoked. For example the API could expose a doInstall method a doUninstall method and so forth. Similarly the interfaces exposed by type extensions can implement different API methods for each different action resulting in the action being inherently identified by the API method invoked.

As discussed above situations can arise where client application desires to rollback a process or operation it is performing. For example client application could desire to undo or rollback a process of installing another application on device undo or rollback a process of uninstalling another application on device and so forth. In one or more embodiments when performing such a rollback or undoing client application informs type extensions via type extension interface that it is performing a rollback or undoing of a process. In one or more embodiments a rollback or uninstall flag hint or other identifier is included in a request to client interface which can be passed on by type extension interface to the appropriate type extension . Alternatively other techniques can be used such as separate API methods for rollback or uninstall processes. For example a doAction method can be invoked when client application is not performing a rollback or uninstall process and a doActionRollback method can be invoked when client application is performing a rollback or uninstall process.

As discussed above in response to a request client application receives a rollback payload identifying a current state of a type registration. Accordingly client application is aware of the requests it sent to client interface as well as a rollback payload for each of those requests and thus can readily determine the requests to send to client interface to undo or rollback the process that application was performing.

Type extensions receive an indication from type extension interface of the requests that are associated with a rollback or undo process. Type extensions can then take appropriate measures or steps such as creating additional backup copies of the state of store removing previously stored information regarding registrations from an additional record of information and so forth. The particular measures or steps taken by type extensions can vary based on the desires of the designers developers users and or administrators of type extensions .

In one or more embodiments client interface exposes a doAction method exposed by a COM Component Object Model object for type extension interface . The doAction method is 

In one or more embodiments during operation client application also provides a callback object to type extension interface . Callback object allows information regarding the process being performed by client application e.g. an install process an uninstall process etc. as well as the registration being performed by type extensions to be communicated between client application and type extensions . Client application provides callback object to client interface . Client application typically provides one callback object when client application begins sending requests to client interface such as including callback object as part of the first request sent to client interface . Alternatively multiple such callback objects can be provided and or callback objects can be provided at different times.

Extension interface also communicates a reference to callback object to a type extension when a request regarding a type registration is sent to type extension . The type extension can then invoke a method exposed by extension interface requesting particular information from client application or providing particular information to client application and identifying callback object . The particular information desired and or provided by type extension can vary based on the designers developers users and or administrators of type extension . Control module in turn invokes the appropriate method of callback object to obtain or provide the desired information. Callback object communicates with the appropriate components objects and or modules of client application to obtain or provide the desired information and returns obtained information to control module via client interface . Control module in turn returns the obtained information to the type extension via extension interface .

In one or more embodiments extension interface exposes a report progress method a log message method and an is canceled method to type extensions . Analogous methods are exposed by callback object to client interface . Accordingly type extension can invoke one or more of these methods to obtain the information desired by the type extension .

The report progress method allows a type extension to report the progress of a request it has received. In one or more embodiments type extension identifies an estimated completion percentage for the request by specifying two numbers in an x out of y format. For example if there are seven steps that type extension performs in response to a particular request and two of those seven have been completed type extension can invoke the report progress method with parameters of 2 and 7 to indicate that the request is estimated at 2 7 completed.

The log message method allows a type extension to report various messages to client application regarding the request it has received. A variety of different messages can be reported based on the desires of the designers developers users and or administrators of type extension . Such messages can be informational messages error messages and so forth. For example if a request with an uninstall action is received and includes a type registration in the registration payload that is not present in the store a message indicating such can be reported by type extension by invoking the log message method. The log message method has as a parameter the message being reported by type extension .

The is canceled method allows a type extension to check whether the process being performed by client application has been canceled. In response to the is canceled method being invoked client application returns an indication to type extension indicating whether the process being performed by client application has been canceled. Type extension can check whether the process has been canceled at various times such as prior to performing certain activities prior to deleting or removing particular data or information and so forth. This check allows type extension to verify that the process started by client application has not been canceled and thus that type extension is to proceed with its operation. However if the process started by client application has been canceled then type extension can halt its operation and wait for rollback and or undo requests from client application .

Thus it can be seen that type extension interface abstracts the particular type extensions from client application and similarly abstracts the client application from type extensions . Type extension interface and type extensions provide a model for extensibility of operating system that is independent of the client application that is installing uninstalling or otherwise modifying the extensibility of operating system via type registrations. Client application interacts with type extensions indirectly via type extension interface allowing various changes to be made to type extensions and corresponding stores without adversely affecting client application . This extensibility model thus allows changes and improvements to be made to type extensions and or stores while allowing the operation of client application to remain unchanged.

In process a request regarding a type registration is passed to a type extension interface by invoking an API method on the type extension interface act . This request includes a type extension identifier an action a registration payload and optionally a callback object as discussed above. A variety of different actions can be requested and the action can be inherent in the API method invoked as discussed above.

In response to the request a rollback payload corresponding to the request is received act . As discussed above this rollback payload identifies a state of at least part of a store corresponding to the identified type extension before the requested action is performed and can optionally include only valid state of the store.

A check is made as to whether the application process being implemented by the client application is canceled act . The application process can be canceled in response to a variety of different situations such as a user request to cancel the application process an error being detected in the application process and so forth.

If the application process is canceled then the application process is rolled back act . This rollback is accomplished by sending a request to the type extension interface to undo each previous request sent in act . For example for each request with an install action that was sent in act a request to undo that install action is sent in act . By way of another example for each request with a patch action that was sent in act a request to undo that patch action is sent in act .

However if the application process is not canceled then a check is made as to whether there is another request regarding an additional type registration ready to be made act . If the application process being implemented by the client application has a request regarding an additional type registration ready to be made then the request is passed to the type extension interface act .

However if the application process being implemented by the client application does not have a request regarding an additional type registration ready to be made then a check is made as to whether the application process is completed act . If the application process is completed then the process ends act . However if the application process is not completed checks are repeatedly made as to whether the application process is canceled act and whether there is another request regarding an additional type registration ready to be made act .

In process the type extension interface waits for a communication act . Different communications can be received such as a request from a client application regarding a type registration act a rollback payload from a type extension act a request for information received from a type extension act or return information received from a type extension act .

If a request from a client application regarding a type registration is received act then a determination of the type extension corresponding to the request is made act . This determination can be made for example by obtaining the type extension identifier from the request.

The action and the registration payload corresponding to the request is sent to the corresponding type extension as identified in act act . A variety of different actions and registration payloads can be included in the request as discussed above. Additionally the action can be inherent in the API method invoked to make the request as discussed above. Process then returns to wait for an additional communication act .

If a rollback payload from a type extension is received act then the received rollback payload is forwarded to the client application act . This rollback payload can be forwarded to the client application in different manners such as the response to the request regarding the type registration previously received from the client application as discussed above. Process then returns to wait for an additional communication act .

If a request for information is received from a type extension act then the information requested is obtained from a callback object provided by the client application act . The information obtained from the callback object is provided to the requesting type extension act . Process then returns to wait for an additional communication act .

If return information from a type registration is received act then the return information is provided to the callback object provided by the client application act . This return information can be for example information reporting the progress of a request a log message regarding a request and so forth as discussed above. Process then returns to wait for an additional communication act .

In process an action and a registration payload are received from a type extension interface act . The registration payload was received via the client application invoking an application programming method of the type extension interface as discussed above. The action is also received from the type extension interface in act whether being explicitly identified or being inherent in the method of the type extension that is invoked for receipt of the registration payload in act .

A rollback payload is generated act . As discussed above this rollback payload identifies a state of at least part of a store corresponding to the type extension prior at the time of receipt of the request in act or at least prior to any changes made to the store in response to the request received in act . Also as discussed above this rollback payload can optionally include only valid states of at least part of the store. The determination of what is a valid state can be determined by the type extension carrying out process and can vary based on the type extension and the particular type registration as discussed above.

Additional information regarding the type registration from the registration payload is optionally stored act . This additional information can be stored in a variety of different stores as discussed above. This additional information can take a variety of different forms such as an identifier of a client application an identifier of an application being installed by the client application a date and or time of receipt or of adding to the store of a new type registration and so forth and can be used in a variety of different manners as discussed above.

The requested action received in act is also performed act . The action is performed based at least in part on the store associated with the type extension such as adding a new type registration removing a type registration and so forth as discussed above.

It should be noted that in one or more embodiments as part of performing the requested action in act previously stored additional information regarding previous type registrations can be used as discussed above. For example if the requested action is an uninstall action then the additional information can be accessed in act to determine a previous type registration that is to be added to the store to take the place of the type registration being removed from the store.

A check is then made as to whether a callback object is to be accessed act . A callback object can be accessed as discussed above to provide information to and or receive information from the client application from which the type extension interface received the request. A determination can be made that a callback object is to be accessed if new information is available to be communicated to the client application if a check is to be made whether the process being performed by the client application has been canceled and so forth.

If the callback object is not to be accessed then process continues to perform the requested action until finished act and continues to check whether the callback object is to be accessed act . However if the callback object is to be accessed then the desired information is communicated to and or obtained from the callback object via the type extension interface act and returns to act to continue to perform the action.

Process continues to perform the requested action until finished act also allowing the callback object to be accessed again act . When the requested action is finished the result of the request is returned to the type extension interface act . The rollback payload generated in act is also returned along with the result in act . Alternatively the rollback payload can be returned prior to or subsequent to the result of the request being returned. The result and the rollback payload can subsequently be returned to the client application by the type extension interface.

Computing device includes one or more processors or processing units one or more computer readable media which can include one or more memory and or storage components one or more input output I O devices and a bus that allows the various components and devices to communicate with one another. Computer readable media and or one or more I O devices can be included as part of or alternatively may be coupled to computing device . Bus represents one or more of several types of bus structures including a memory bus or memory controller a peripheral bus an accelerated graphics port a processor or local bus and so forth using a variety of different bus architectures. Bus can include wired and or wireless buses.

Memory storage component represents one or more computer storage media. Component can include volatile media such as random access memory RAM and or nonvolatile media such as read only memory ROM Flash memory optical disks magnetic disks and so forth . Component can include fixed media e.g. RAM ROM a fixed hard drive etc. as well as removable media e.g. a Flash memory drive a removable hard drive an optical disk and so forth .

The techniques discussed herein can be implemented in software with instructions being executed by one or more processing units . It is to be appreciated that different instructions can be stored in different components of computing device such as in a processing unit in various cache memories of a processing unit in other cache memories of device not shown on other computer readable media and so forth. Additionally it is to be appreciated that the location where instructions are stored in computing device can change over time.

One or more input output devices allow a user to enter commands and information to computing device and also allows information to be presented to the user and or other components or devices. Examples of input devices include a keyboard a cursor control device e.g. a mouse a microphone a scanner and so forth. Examples of output devices include a display device e.g. a monitor or projector speakers a printer a network card and so forth.

Various techniques may be described herein in the general context of software or program modules. Generally software includes routines programs objects components data structures and so forth that perform particular tasks or implement particular abstract data types. An implementation of these modules and techniques may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available medium or media that can be accessed by a computing device. By way of example and not limitation computer readable media may comprise computer storage media and communications media. 

 Computer storage media include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media include but are not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by a computer.

 Communication media typically embody computer readable instructions data structures program modules or other data in a modulated data signal such as carrier wave or other transport mechanism. Communication media also include any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.

Generally any of the functions or techniques described herein can be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms module and component as used herein generally represent software firmware hardware or combinations thereof. In the case of a software implementation the module or component represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices further description of which may be found with reference to . The features of the client application independent extensibility model techniques described herein are platform independent meaning that the techniques can be implemented on a variety of commercial computing platforms having a variety of processors.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

