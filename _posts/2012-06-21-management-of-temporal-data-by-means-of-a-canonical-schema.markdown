---

title: Management of temporal data by means of a canonical schema
abstract: Computer programs embodied in computer-readable media that can use canonical schemas to persist data from non-temporal tables, effective-time tables, assertion-time tables, and bitemporal tables, and that can enforce temporal integrity constraints on those tables, are provided. In one embodiment, the canonical schemas are used by database tables. In another embodiment, they are used by the physical files which persist data from those tables. Temporal metadata is used to express temporal requirements. Thus, uni-temporal, bitemporal, and temporally-enabled non-temporal tables can be generated without altering existing data models or designing temporal features into new data models. Support is also provided for managing temporal data that exists in future assertion time, and for using episodes to enforce temporal referential integrity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08713073&OS=08713073&RS=08713073
owner: Asserted Versioning, LLC
number: 08713073
owner_city: Atlanta
owner_country: US
publication_date: 20120621
---
This application is a continuation in part of U.S. patent application Ser. No. 12 803 600 filed Jun. 29 2010 the entirety of which is hereby incorporated by reference herein.

Temporal data is data that keeps track of changes over time. It is data more precisely that keeps track of changes along either one or two temporal dimensions.

One of these temporal dimensions is called valid time by computer scientists. In valid time modifications to data in a database reflect changes happening in the world around us and that we wish to keep track of. The second of these two temporal dimensions is called transaction time by computer scientists. Transaction time keeps track of when data is initially entered into a database. In addition transaction time keeps track of modifications to data in a database that do not reflect anything that is happening in the world around us. Instead these modifications are made to adjust the data in some way independent of what is happening to what the data represents. For the most part these adjustments are made to correct mistakes found in the data.

Attempts to manage temporal data that varies in valid time may be found in many business applications. Research into temporal data that varies in both valid time and transaction time has been ongoing in the computer science community for several decades. Although there is still no de jure SQL standard for managing temporal data DBMS vendors have begun to add support for temporal data to their DBMSs and related products.

Before proceeding we will introduce some needed terminology. We prefix most of our definitions of terms with def .

 def temporal dimension a semantic interpretation given to points in time and periods of time. Points in time and periods of time that belong to different temporal dimensions cannot be compared they are incommensurable. Points in time and periods of time in the same temporal dimension can be compared as to their relative positions along the timeline which that temporal dimension interprets. For example one time period may end before another time period begins or may overlap that other time period or may be contained within that other time period or may end at the same time as that other time period and so on.

 def non temporal table conventional table a non temporal table which we will also call a conventional table is a table whose rows stand for statements about what we currently assert the things those rows represent are currently like. Each row describes what the object it represents is currently like in other words it describes the current state of that object. Also by its presence in the table each row represents the assertion that the statement made by that row is true. If we believed that the statement were not true we would remove the row from the table.

In a conventional table anything that is represented by a row in that table is represented by only one row. A conventional table contains no history about the things which its rows represent. It does not contain any history about erroneous data that was later corrected. It also contains no data about the future i.e. about what the things its rows represent may be like at some future point in time.

 def object anything that can be distinguished from other instances of its type and that can change over time. So for example specific customers products employees and invoices are all objects. A relationship represented by a row in an associative table such as a table relating customers to salespersons is also an object. An event is not an object because once an event has taken place it is over and cannot change.

 def type of object the kind of thing something is. A type of object is represented in a database by a table. Each instance of that type is represented in a conventional database by a row in that table.

 def statement a description of something. In a natural language a statement is made by writing or uttering a declarative sentence in a normal context i.e. a context in which it is understood that by writing or uttering that sentence one is also willing to affirm that what it says is true.

Each row in a table makes a statement about the object it represents. For example consider a row in a non temporal table of customers where the columns of the table consist of a customer number primary key a customer last name and a customer status code and the row consists of the values respectively C123 Jones and VIP . This row makes the statement There exists a customer with customer number C123 last name Jones and status code VIP . The presence of this row in its non temporal table is the assertion that this statement is true.

 def valid time effective time the temporal dimension that computer scientists call valid time we will call effective time . As stated above in valid time modifications to data in a database reflect changes happening in the world around us and that we wish to keep track of.

 def uni temporal version data uni temporal version table uni temporal data that tracks changes in effective time we will call uni temporal version data and we will call temporal tables that contain such data uni temporal version tables .

 def version a row in a uni temporal version table is a version of the object it represents. Sometimes we will use the word versioned instead of version in these expressions.

 def transaction time assertion time the temporal dimension that computer scientists call transaction time is semantically a proper subset of the temporal dimension that we will call assertion time . As stated above in transaction time modifications to data in a database do not reflect anything that is happening in the world around us. Instead these modifications are made to adjust the data in some way usually in order to correct mistakes found in the data. We allow data to be associated with future periods of assertion time and it is this association which extends the semantics of assertion time beyond the semantics of transaction time. But except in this context we do not allow data to be associated with future periods of assertion time. When we do not assertion time and transaction time are equivalent terms all instances of the one are instances of the other. See also the later section entitled Fundamental Concepts Transaction Time and Assertion Time.

 def uni temporal assertion data uni temporal assertion tables uni temporal data that tracks changes in assertion time we will call uni temporal assertion data and we will call temporal tables that contain such data uni temporal assertion tables .

 def assertion a claim that a statement is true. A row in a uni temporal assertion table is an assertion of the statement made by that row about the object it represents.

In the phrases uni temporal version and uni temporal assertion uni temporal may be unnecessary and so we may sometimes drop it.

 def bi temporal data bi temporal table data that tracks changes in both temporal dimensions. We will call tables that contain bi temporal data bi temporal tables . Rows in bi temporal tables are both versions and assertions.

bitemporal bi temporal we note that in the prior art the term bitemporal is sometimes used instead of the term bi temporal .

This book written by the leading researcher in the field of temporal data management explains how to support temporal data management using Database Management Systems DBMSs and SQL current at the time of publication of the book. It describes an implementation of the basic concepts of temporal data management an implementation which includes three kinds of temporal table. The first kind is called a valid time state table and is the way that the invention described in this book manages temporal data which keeps track of changes in valid time. The second kind is called a transaction time state table and is the way that the invention described in this book manages temporal data which keeps track of changes in transaction time. The third kind is called a bitemporal table and is the way that the invention described in this book manages temporal data which keeps track of changes in both valid time and in transaction time.

This book is an invaluable source of SQL code fragments that illustrate the complexity of managing bi temporal data and in particular that illustrate the complexity of writing entity integrity and referential integrity constraints against temporal data. It constitutes a reduction to then current practice of the underlying concepts of temporal data management.

We will refer to these temporal concepts and the reduction to practice as described in this book as the baseline model of temporal data management or for short the baseline temporal model . It constitutes the invention on which our own invention is claimed to be an improvement.

Our invention is an improvement on the baseline temporal model in several ways. First our invention uses a single canonical schema to express all temporal data. This schema is a bi temporal schema and so all temporal tables in our invention are bi temporal tables. In our invention therefore temporal data which changes only in valid time or temporal data which changes only in transaction time are not kept track of by means of tables with different schemas tables which use only one of the two temporal dimensions. With our invention either kind of uni temporal data can be maintained as bi temporal data for which one of the time periods is not specified on maintenance transactions and instead takes on a default value. With our invention either kind of uni temporal table can be manifested as a queryable object by defining a uni temporal view on the underlying bi temporal table.

Our invention in contrast to the baseline temporal model also enforces entity integrity and referential integrity constraints on temporal data at the time that data is being maintained. It does so by means of insert update and delete transactions. Consequently in contrast to the baseline temporal model a temporal database maintained by our invention will never contain temporal data that violates these constraints.

Our invention in contrast to the baseline temporal model also provides a surrogate valued unique identifier of the objects represented by rows in tables. This provides a common syntax for uniquely identifying those objects which is the same in all temporal tables in the database. With this common syntax which in our preferred embodiment is a single surrogate valued column the primary keys of all temporal tables will be syntactically identical. This syntactic identity of the primary keys of all temporal tables simplifies the program code required to manage all forms of temporal data.

Our invention in contrast to the baseline temporal model also expresses all temporal data requirements as metadata. It thereby avoids the need to express those requirements in relational logical data models or in entity relationship logical data models or in physical data models. It replaces a design specification in data models with a declarative specification in metadata.

Our invention in contrast to the baseline temporal model also extends the concept of transaction time to cover data which exists in future transaction time. We call maintenance transactions that specify future transaction time deferred transactions and we call the rows that result from applying them to a temporal database deferred assertions . With deferred assertions we eliminate the need to maintain separate datasets of transactions which are not yet ready to be applied to their target tables.

While the main focus of our patent application and also of the baseline temporal model is row level management of bi temporal data the main focus of Date Darwen and Lorentzos book is row and column level management of uni temporal data. While the main focus of our patent application and of the baseline temporal model is on implementing temporal data management with current DBMSs and current SQL the main focus of this book is on describing language extensions that contain new operators for manipulating versioned data. On both these counts then this book is essentially orthogonal to this patent application. We include it here because of the prominence of its authors.

Oracle 10 g extended the flashback queries of Oracle 9i to retrieve all the versions of a row between two transaction times and allowed tables and databases to be rolled back to a previous transaction time discarding all changes after that time.

However Oracle s 10 g flashback queries like Oracle s earlier 9i flashback queries are queries based on restoring data as of a past point in time and then rolling forward to a designated later point in time. Like 9i flashback queries 10 g flashback queries do not address the problems involved in creating and maintaining temporal data.

With 10 g Workspace Manager Oracle began to address the issues involved in creating and maintaining temporal data. The Oracle 10 g Workspace Manager includes valid time support transaction time support support for bi temporal tables and support for referential integrity relationships between temporal tables.

Our invention in contrast to this work manages all temporal data with only one kind of temporal table that being a bi temporal table and it provides a method of managing all temporal data in a single table for each type of object represented e.g. of managing all temporal data about customers in one customer table. When this is not done as it is not done in any of Oracle s products or patents or patent applications of which we are aware then in order to respond to a query about specific objects as data located in one or two temporal time periods describes those objects it may be necessary to assemble or re constitute to use Oracle s own terminology the requested data out of a repository of raw material . This process is conceptually the same as the decades old process of re constituting desired data by restoring a database backup and then using a transaction log to roll forward to a desired point in time.

Our invention in contrast to this work also eliminates the need to manage datasets which are collections of transactions not yet ready to be applied to production database tables. Oracle s workspaces are precisely such collections of transactions and they are managed as datasets which are distinct from the production tables to which those transactions are intended to later be applied.

This prior art describes techniques for history enabling a table in a database system so that past versions of rows of the history enabled table are available for temporal querying. The table is history enabled by adding a start time column to the table and creating a separate history table for the historical data. The start time field s value in a row of the history enabled table indicates when the contents of the row last changed. The rows of the history table are copies of rows of the history enabled table that have been deleted or updated. The rows include end time fields whose values indicate when the row was updated or deleted.

This prior art describes the management of data by associating it with only one time period. But first of all if this time period were clearly valid time or clearly transaction time then it would describe only a method of managing uni temporal data whereas our invention is a method of managing bi temporal data which fully subsumes the management of uni temporal data.

Secondly however this prior art does not distinguish changes to data which were made to reflect changes to the objects represented by rows in a table from changes to data made to correct errors in that data. It thus fails to distinguish valid time from transaction time simply using transaction time as its single temporal dimension. It does not support either temporal dimension because it indiscriminately supports both.

Also even if this prior art did describe a method for managing a uni temporal history of changes to a table it does not describe any method for managing data which exists in future effective time or data which exists in future assertion time.

This database designed and implemented by one of the authors of this patent application Weis supports the management and querying of bi temporal tables. However to carry out any modification to those bi temporal tables each of the physical transactions required to complete the modification must be hand written . Thus a single modification e.g. a request to extend the effective start date of an insurance policy back to the beginning of the calendar year might easily require half a dozen or more physical transactions submitted to the DBMS in a specific sequence and constituting an atomic unit of work. Errors in writing sets of these transactions have occurred frequently even though only experienced DBAs and SQL coders are used to write these transactions.

Our invention in contrast to this work permits modifications to temporal data to be expressed as single insert update or delete statements which we call temporal transactions . Our Asserted Versioning Framework or for short AVF shown as in accepts these temporal transactions and translates them into the multiple physical insert update and delete statements which carry out the modification. This eliminates the frequent errors which appear when temporal modifications must be hand written as sets of physical transactions.

This is a bi monthly series of articles written by the authors of this patent application Johnston and Weis . The series began in the May 2007 issue of now and ran continuously in now up to the time of our preliminary patent application which was filed on Jun. 24 2009.

One of the implementations in this patent application introduces the concept of an episode as a managed object i.e. as an abstract data type defined and manipulated by our invention. Episodes are first discussed in this prior art in Part 4 published in June 2007. But this and later discussions of episodes in this series of articles describe episodes in the context of a single temporal dimension not in the context of bi temporality.

In particular in Part 19 February 2008 we do provide a clear statement that episodes are the parent managed objects in temporal referential integrity relationships. We say that temporal referential integrity prevents a child row from being effective before or after the continuous time range of an episode of the parent object. This is a true statement about what the temporal referential constraint is but nowhere in this series do we describe a process for implementing the constraint checking.

For these two reasons we conclude that the use of episodes in a bi temporal context to enforce temporal referential integrity is both novel and unobvious with reference to this prior art.

This is a presentation made on June 3to the ERwin User s Group in Manhattan. It contains no material not presented in the Time and Time Again prior art described above.

The Oracle 11 g Workspace Manager is Oracle s current implementation of support for the management of temporal data that is not yet ready to apply to a database. It is a way of supporting what we call pending transactions .

 def pending transactions collections of transactions that have been written but not yet submitted to the DBMS to be applied to a database.

Oracle s workspaces are hierarchical collections of pending transactions which can be modified by means of insert update and delete transactions without modifying the table from which they may have been originally extracted and to which they will eventually be applied if they are not discarded.

However this method of managing pending transactions creates many problems of its own. In particular by distributing temporal data across different kinds and instances of physical and logical datasets it separates this category of temporal data from other uni temporal or bi temporal data which exists in database tables. Thus once a workspace is approved as containing data that the business wishes to include in those tables IT technical personnel must begin by manipulating those datasets and must note and resolve any inconsistencies that may have been introduced into the data.

Only after this work has been done will those technical personnel be able to move the designated data into the appropriate database tables. The latency incurred between the approval of designated workspace data and its availability to the business user as rows in production tables may thus be a matter of hours or even days.

In our invention all temporal data is contained in one place that being the temporal database tables managed by this invention. This includes the results of immediately applying all database transactions instead of managing some transactions in separate datasets. Those results are stored as rows in those tables but the rows which correspond to pending transactions are not accessible to normal queries until the future point in assertion time associated with them becomes current. In some cases these pending transactions create and modify data that will not become current for perhaps decades or centuries. This data will never become current by accident i.e. by the mere passage of time. Instead it will not become current unless and until it is explicitly approved to become current. Once approved it is moved up from that decades or centuries from now period of assertion time to a point in assertion time that may be only a few seconds from the present moment. This move up of this approved data is a matter of changing a date or timestamp on one or more rows already in the database table they belong to. Thus once approved the latency involved in changing the status of those rows to current data accessible to normal queries is a matter of seconds or milliseconds. Moreover even prior to that approval our invention makes it possible to retrieve that pending data alone or in combination with other temporal data in the same production tables using SQL queries that a business user can write.

Oracle s version tables are one kind of uni temporal table. They are what we call uni temporal assertion tables. Their valid time tables are another kind of uni temporal table the kind we call uni temporal version tables. Together with bi temporal tables this means that there are three categories of temporal table in Oracle databases that must be managed even if we do not count workspaces of pending transactions. In our invention all temporal data is managed in bi temporal tables and those bi temporal tables share a common canonical schema thereby simplifying the maintenance and querying of that data and those tables.

This patent application describes a method for managing changes in both data values and in database schemas. The basic approach is to store a history of changes in a transaction log in which each transaction is associated with points in time in several temporal dimensions including valid time and transaction time. Then whenever a query is submitted to the DBMS the DBMS re constitutes both the schemas which interpret the data values and the data values themselves from the transaction log. By specifying different points in time or periods of time in these queries the DBMS is able to support bi temporal data.

Our invention does not address the problem known as schema evolution and so does not attempt to manage changes to database schemas.

The method described in this patent application of storing data values as transactions and then producing result sets for queries by processing an appropriate subset of transactions in response to each query is not used in our invention.

Instead our invention stores the results of transactions in the tables they update and therefore our invention does not have to dynamically re constitute the data requested by a query. It stores the results of transactions whose data describes the past present or future states of the objects represented by the data in those tables. In this way it supports valid time. It also stores corrections to data already entered but keeps a record of the corrected data also. In this way it supports transaction time.

In one of our implementations our invention also accepts transactions which would otherwise have to be stored and managed in what are usually called batch files batch tables or other collections of transactions which the business has written but is not yet ready to apply. By accepting these transactions as soon as they are written and storing their results in the tables which are their targets our invention eliminates the substantial costs of managing such collections of transactions. By associating the results of those transactions with a future period of time in the temporal dimension we call assertion time and which is a semantic extension of the temporal dimension which computer scientists call transaction time those results remain effectively invisible to normal queries but will automatically become visible when enough time has passed that their transaction times become current.

Our invention which we call the Asserted Versioning Framework or for short the AVF is an improvement on the baseline model of temporal data management. The improvement consists in using a schema i.e. a DBMS catalog entry which defines a table in a database which is identical for all temporal tables except for the business data in those tables. We call this schema a canonical schema for managing temporal data.

 def canonical schema the bi temporal schema of this invention which is used for all temporal tables.

This schema is a bi temporal schema so the AVF does not have any physical uni temporal tables to manage thus simplifying its codebase. These tables replace conventional tables they are not in addition to conventional tables further simplifying the codebase of the AVF. Temporal transactions can specify only an effective time period so they appear to be doing only uni temporal work. However all rows already present in the target table when a temporal transaction is processed and that are affected by that transaction are copied and transformed into rows which appear to be entries in an internal semantic logfile even though they continue to reside in that same table. In this way a bi temporal history of modifications to the table is preserved even though the temporal transactions appear to be specifying only uni temporal modifications. Temporal transactions do not have to specify any time periods at all in which case they appear to be modifying conventional non temporal tables.

From the point of view of queries a uni temporal table is a view on a bi temporal table one which includes only one of the two kinds of time periods present in the underlying table. From the point of view of queries a conventional non temporal table is a view on a bi temporal table from which all columns specific to the canonical schema have been dropped and which always presents only rows which are current in both temporal dimensions.

In one implementation we define an extension to what computer scientists call transaction time and what we call assertion time . This extension supports future time periods in this second temporal dimension. With this extension our invention also eliminates the need to store in either batch transaction datasets or in workspaces or in other named repositories of maintenance transactions those transactions which their authors are not yet ready to apply to the database. Instead with our invention all transactions are immediately applied to the database. If we are not yet willing to claim that the rows of temporal data resulting from any of these transactions make a true statement about the objects they represent we specify a future assertion time period on the transaction and the row or rows that are created by the transaction are assigned that future time period and will not be interpreted as making true statements or statements otherwise good enough to be used for their intended purposes about the objects they represent unless or until that future time period becomes a current time period.

In another implementation our invention also eliminates the need to express requirements for temporal data in a data model. Instead those requirements are expressed in metadata and it is from a combination of a non temporal data model and that metadata that a temporal database is generated.

In a referential integrity relationship among temporal tables while the child object is a single row the parent object is a set of possibly many rows. In another implementation our invention defines this set of possibly many rows as an abstract data type and enforces temporal referential integrity by means of this new data type.

It is well known that an important way to improve the performance of a search in an index is to begin the search as far down the tree structure of the index as possible. It is also well known that one way to do this is to use match predicates as extensively as possible since the node in the index tree at which direct matching stops and sequential searching begins will be the node located by the first range predicate used after all match predicates have been applied. In another implementation this invention provides a mean for improving the search for data which is current in effective time or which is current in assertion time by utilizing match predicates that eliminates most data which is not current in those temporal dimensions.

From the point of view of the incremental amount of work required by technical personnel to manage temporal data perhaps the most important distinction between this invention and the prior art is that this invention supports the full semantics of bi temporal data even extending that semantics as Dr. Richard Snodgrass acknowledges with a single type of table schema and without requiring the deployment of any additional datasets either within production databases or outside them. If a database contains one non temporal table of customer data then with this invention full bi temporal support is extended to customer data by modifying that one table to include customer data from the past or the future in either or both of two temporal dimensions. With no additional tables or other datasets to manage this method of supporting temporal data requires much less additional work on the part of technical personnel than does the prior art.

We begin by providing prima facie evidence that our various embodiments are useful novel and unobvious. A book we have written and which is soon to be published Morgan Kaufmann 2010 describes an invention which is the amalgamation of various embodiments in this patent application and is incorporated by reference herein in its entirety. An endorsement from Dr. Richard Snodgrass the author of the TSQL proposals to the SQL standards committee and a leading researcher in the field of managing temporal data appears on the outside back cover of our book. This endorsement states that The authors present an original and comprehensive conceptual approach called Asserted Versioning which includes support for bi temporality and is a significant advance in the theory and practice of managing time varying data. 

We have already introduced and defined several important concepts including the concepts of temporal data temporal tables temporal databases temporal dimensions uni temporal data uni temporal tables uni temporal assertion tables uni temporal version tables bi temporal data bi temporal tables non temporal conventional data and non temporal conventional tables. We will now define several additional concepts required by the following discussion of the invention and also clarify the conventions we use to represent time periods. Then we describe the architectural context of this invention. We define what we call the baseline model of temporal data management or for short the baseline temporal model . After those discussions the remainder of this detailed description will be organized as a discussion of various embodiments.

 def production table a production table is where we keep data that we the enterprise that creates and maintains that data are willing to say is our best and most accurate data about the things the data represents. In production tables as we will explain below each row makes a statement that we are willing to assert is a true statement or if a statement about the future state of an object and as such a statement which we cannot yet assert as being either true or false is nonetheless a statement on the basis of which business decisions may be made.

Unless otherwise indicated all references to tables including uni temporal bi temporal and non temporal tables are first and foremost to production tables and all references to databases including to conventional and to temporal databases are first and foremost to production databases. While this invention manages non production tables as well as production tables its principal business value lies in its management of production tables and production databases.

Types and instances are one of the most basic ways we organize knowledge. There are different types of things and there are instances of each type. We will use the term object to refer to an instance of a type.

Tables in databases represent the types of things we are interested in types such as clients policies employees organizational structures and so on. Rows in conventional tables represent instances of these types. These instances are the individual objects we are interested in objects such as specific clients specific policies and so on.

Columns in these tables represent types of properties of objects or types of relationships those objects have to other objects. In each row each of its column instances represents the specific instance of that property type or of that relationship type which the object represented by that row has. For example one health insurance policy may have a policy type of PPO while another may have a policy type of HMO. One health insurance policy may have an owned by relationship to client C123 while another may be owned by client C and so on.

In the three canonical schema used by this invention the canonical schema the extended canonical schema and the deferred assertion canonical schema FIG. an object is uniquely identified by means of an object identifier OID .

In a relational database a referential integrity relationship between two non temporal tables is implemented by means of a foreign key. A temporal referential integrity relationship between two temporal tables as explained further in the section Fundamental Concepts Temporal Referential Integrity below is implemented by means of a temporal foreign key . We will sometimes use the acronym TRI to stand for temporal referential integrity and will sometimes use the acronym TFK to stand for temporal foreign key .

Statements are made by declarative sentences. In databases each row in a table stands for what logicians call an existentially quantified statement. These are statements which can be expressed in English in the form There exists an X such that . . . . For example There exists a customer such that the last name of that customer is Jones . As represented in a conventional customer table this statement is true if and only if there is a row in the customer table with the value Jones in its last name column.

A version of an object may be thought of as a timeslice of the life history of an object. The timeslice is uniquely identified by designating an object and a period of time. For example the statement During the month of August 2010 there existed a customer such that the customer s last name was Jones is an existentially quantified statement about a version of an object.

Ignoring self contradictory or otherwise nonsensical statements all statements must be capable of having a truth value. Many statements actually do have truth values that is many statements are in fact true or false. But some statements according to widely accepted interpretations in logic lack a truth value. On these interpretations for example the statement The Atlanta Braves will win the 2028 World Series as made now and as made any time prior to the 2028 World Series lacks a truth value.

This introduces the distinction between a statement and its assertion. With this distinction we can say that an assertion is a claim that a statement is true.

In a conventional table it is tacitly understood that by putting a row into a production table in a database we are asserting that that row makes a true statement. For as long as that row remains in that table we continue to assert as true the statement made by that row.

This is also true of rows which represent versions. Consider the row which represents the statement During the month of August 2008 there existed a customer such that the customer s last name at that time was Jones . For as long as that row remains currently asserted in a temporal table we will assert that it makes a true statement i.e. the statement that throughout the month of August 2008 that customer s last name was Jones .

But sometimes we discover after the fact that we were mistaken and that certain rows do not make true statements. If we wish to retain the information that our tables did contain such mistakes how will we indicate that One way is to associate another time period with the rows in our tables. This time period will represent when we asserted assert or will assert that a row makes a true statement. If that row is a row in a versioned table then that row will have two time periods associated with it. The first time period will designate a period of time in the life history of the object represented by the row. The second time period will designate a period of time during which we once asserted presently do assert or may in the future come to assert that the row makes a true statement.

 def state the state of an object is what the object is like at a point in time or during a period of time. In a conventional table the state of an object is described by the business data on the one row representing that object. The point in time is understood to be the present moment. The period of time is understood to be an open time period and so the row is understood to represent the current state of the object which will continue to be the state of the object unless or until the row is deleted or updated. In a table which supports valid time effective time rows representing different states of the same object may concurrently exist in the table provided the table never contains more than one row which is currently asserted to describe the state of an object at any point in valid time effective time .

Valid time keeps track of changes to data which are made in order to keep up with changes to the objects represented by that data. Transaction time keeps track of when data was first placed in a table. But it also keeps track of changes to data which do not reflect changes to the objects represented by that data. It does so by associating a later period of transaction time to a row which represents the same object during all or part of the same period of valid time. In a series of such rows the row with the latest transaction time is understood to contain correct data and the other rows are understood to contain mistaken data.

This description of valid time and transaction time also applies to effective time and assertion time. We permit rows to be associated with future periods of assertion time the difference between transaction time and assertion time is only one of interpretation. Transaction time is a physical description of this temporal dimension. Assertion time is a semantic description.

One can establish the correlation between the physical and the semantic description by realizing that every row in a table makes a statement which describes the state of some object during some period of time. In a conventional table that state of the object is its current state what it is like currently. The presence of a row in a conventional table is the assertion that the row makes a true statement. When the first temporal dimension is added to an otherwise conventional table it remains true that the presence of a row in the table is the assertion that the row makes a true statement. In this case the true statements are statements about the past present or future states of objects not just the state they are in at the current moment in time.

When the second temporal dimension is added it is no longer true that each row in the table is asserted or understood to make a true statement. In a series of rows about the same object and the same first period of time as described above only the row whose second time period is a current time period is asserted or understood to make a true statement. The other rows are mistakes and are understood to be mistakes and so we are no longer willing to assert that they make true statements. Their second time period ends on the same clock tick that the row containing the corrected data begins.

This second time period changes what it means for a row to be present in a table. Without it the presence of a row is the assertion that the row makes a true statement. With it rows may remain in tables even though they no longer have the status of representing assertions of the truth of the statements they make.

Thus until we consider the implementation that extends assertion time to include future assertion time periods transaction time and assertion time are equivalent and will always be managed in the same way. The difference at this point lies solely in interpretation. As for valid time and effective time the difference between them is purely terminological.

 def clock tick a clock tick is the smallest unit of time that can be used for the begin date or end date of a time period. For example if a date datatype is used for the begin dates and end dates and the level of granularity chosen for time periods is that of one day then two clock ticks are adjacent and have no gaps between them if and only if they represent successive days.

A clock tick designates a known position along a timeline. A time period always consists of at least one clock tick.

We use the closed open convention for representing time periods with delimiting points in time. In this convention the beginning point in time which we call a begin date is included in the time period it delimits but the ending point in time which we call an end date is the next point in time after the last point in time included in the time period it delimits.

Thus for example using a calendar month level of granularity an effective begin date of March 2010 and an effective end date of April 2010 represent a time period consisting of a single clock tick. To take another example an effective begin date of March 2010 and an effective end date of August 2010 represent a closed time period lasting five months those months being March April May June and July of 2010. An effective begin date of March 2010 and an effective end date of 9999 9999 representing the highest temporal value which a specific DBMS can recognize represent an open time period of unknown duration.

In all the figures used in this patent application we use a calendar month as our chosen level of granularity. Thus the temporal columns which are part of our canonical schema show as sample data dates in the format xxx99 where xxx stands for Jan Feb . . . Dec and indicates a month of the year and 99 stands for a year in the current century. Thus May12 stands for the month of May 2012 and is the clock tick that comes immediately after the clock tick of Apr12 and immediately before the clock tick of Jun12 . We use this form of abbreviation in order to fit sample rows of data across one line of a printed page. It is an artifact of this convention that dates in the last century or in prior or later centuries cannot be represented. This restriction is only an artifact and is not part of this invention. More commonly time periods in temporal databases would be defined at the timestamp level of granularity or at least at the level of calendar days.

Temporal entity integrity is similar to the relational constraint of entity integrity. We will sometimes use the acronym TEI to stand for the phrase temporal entity integrity .

However while entity integrity is defined over non temporal tables we define TEI over temporal tables. Entity integrity is the constraint that no two rows concurrently present in a non temporal table may represent the same object. It is usually enforced by associating each object with a unique identifier which is used as the primary key of the table and then by enforcing a unique index over that primary key.

 def TEI is the constraint that requires that a temporal database is always in a state in which no two rows in the same temporal table have the same unique object identifier in both shared assertion time and shared effective time. This unique object identifier is called an OID and is defined below in the section Canonical Schema of the Invention.

 def shared time defined as follows. The assertion time that is shared among assertion time periods AT1 AT2 . . . ATn is the assertion time period consisting of all the clock ticks that are in AT1 and AT2 . . . and ATn. The effective time that is shared among effective time periods ET1 ET2 . . . ETn is the effective time period consisting of all the clock ticks that are in ET1 and ET2 . . . and ETn.

Semantically a database in which there are no TEI violations is a database in which there is no point in time on which the database makes two or more assertions about the same object as that object was is or will be during the same point in effective time.

The means by which TEI is enforced is explained in the sections in which we discuss temporal insert temporal update and temporal delete transactions.

A preliminary concept for temporal referential integrity must first be defined. It is the concept of existence dependency.

 def existence dependency an object X is existence dependent on an object Y if and only if X cannot exist unless Y also exists. For example a water molecule cannot exist without both hydrogen and oxygen atoms. An invoice cannot exist without a customer.

Both referential integrity and temporal referential integrity are relationships between pairs of tables. In both types of relationship we will call the table referred to the parent table and the table referring to it the child table . We will sometimes use the acronym TRI to stand for the phrase temporal referential integrity .

TRI is similar to referential integrity. However while referential integrity is defined over non temporal tables we define TRI over temporal tables. Referential integrity is the constraint that if a database contains a table representing the type of object of which X is an instance and also contains a table representing the type of object of which Y is an instance the types and the tables not necessarily distinct then whenever the database contains a row representing X it must also contain a row representing Y. The row representing X is called the child row in the relationship and the row representing Y is called the parent row .

 def TRI is the constraint that requires that a temporal database is always in a state in which the value in every TFK matches the OID of every row in a set of one or more rows such that the assertion time period of each row in the set is identical to or fully contains the assertion time period of the row containing the TFK and the logical union of the effective time periods of each row in the set contains no gaps in effective time and is identical to or fully contains the effective time period of the row containing the TFK.

We also point out that while the child in a TRI relationship is a row the parent is not a row. It is a set of one or more rows as just defined.

Semantically this results in a database in which for any two objects between which there is an existence dependency and for which there is a table representing the types to which the objects belong the database will never assert the existence of the dependent object in a given period of effective time unless it also at the same time asserts the existence of the object it is dependent on in an effective time period that is identical to or fully contains the effective time period of the dependent object.

The means by which TRI is enforced is explained in the sections in which we discuss temporal insert temporal update and temporal delete transactions.

For every prior art valid time table transaction time table or bi temporal table it is possible to define a corresponding otherwise identical non temporal table. The correspondence is intuitively clear. The temporal table corresponds to the non temporal table but with the addition of one or two time periods.

In this invention for every temporal table it is also possible to define a corresponding otherwise identical non temporal table. But unlike the prior art the temporal tables managed by this invention are all bi temporal and all conform to a common canonical schema. In addition the temporal tables in this invention replace the primary key of the otherwise identical non temporal table with a surrogate valued object identifier and retain the primary key column or columns of the otherwise identical non temporal table as non key columns. In addition the temporal tables in this invention replace foreign keys in otherwise identical non temporal tables with surrogate valued temporal foreign keys. Consequently the correspondence of a temporal table managed by this invention and an otherwise identical non temporal table is less intuitively clear than it is in the prior art.

This correspondence may be demonstrated by describing how a temporal table managed by this invention can be mapped into its otherwise identical non temporal table. We begin with the schema level mapping.

Then by means of metadata we identify the column client oid as a temporal foreign key which references the Client table. This means that in the corresponding non temporal table there must be a foreign key which references the non temporal Client table. By means of metadata we know that the column name for that foreign key is client nbr.

Finally because the columns policy type and copay amt are not mentioned in any of the metadata we identify them as non key columns of the corresponding non temporal table. All columns in the temporal table have been accounted for and the schema level mapping for this table is complete.

But the equivalence of a temporal table and an otherwise identical non temporal table must be an equivalence in content and not just in schemas. In terms of content only some of the rows in a temporal table have a corresponding row in their otherwise identical non temporal table. Those are the rows whose assertion time periods and effective time periods are both current. Therefore for all those rows an otherwise identical non temporal table or view can be populated by means of the following steps.

For each of those currently asserted and currently effective rows in the temporal table the column or columns which metadata designates as the business key is used to populate the primary key column or columns of the non temporal table. Next for each temporal foreign key if any the row whose object identifier matches the value in the temporal foreign key and whose assertion time periods and effective time periods are both current is retrieved and the column or columns making up the business key of that row are used to populate the column or columns making up the foreign key in the non temporal table. Finally for all other columns in the temporal table their values are moved to the row in the non temporal table.

 def temporal insert transaction temporal update transaction temporal delete transaction insert update or delete transactions as written by their authors and whose targets are temporal tables.

Reference character designates the Asserted Versioning Framework which we also refer to as the AVF . It is the computer program code which is part of our invention and which translates each temporal insert update or delete transaction into one or more physical transactions which it then submits to a DBMS which immediately applies those transactions to their target canonical schema temporal table .

 def physical transaction by a physical transaction we mean a SQL insert update or delete transaction which the AVF submits to a DBMS.

The AVF manages each set of physical transactions corresponding to a single temporal transaction as an atomic and isolated unit of work. As these transactions update the database that contains the production tables the AVF also enforces the semantic constraints specific to temporal data those being the constraints of TEI and TRI.

Reference characters and represent the six categories of bi temporal data recognized in the baseline temporal model. Using our terminology of assertion time and effective time instead of the standard computer science terminology of respectively transaction time and valid time each of the categories and are named by a pair of terms separated by a slash in which the first term designates a time period in assertion time and the second term designates a time period in effective time. Thus for example the category named past future represents the category of bi temporal data whose rows represent statements which we no longer assert to be true statements and which are so designated by having assertion time periods that have already ended. The statements represented by these rows are statements about future versions of the objects they each represent i.e. statements about what the objects they each represent would be like at a specified future period of effective time.

Here and elsewhere a period of time is designated as past present or future relative to the current moment in real time i.e. relative to right now.

In an alternative embodiment the AVF is incorporated into a DBMS. In that embodiment the temporal transactions and would be submitted directly to the DBMS .

The various embodiments in this patent application are for improvements over what we call the baseline model of temporal data management. We define this baseline model as consisting of the concepts and the reduction to practice expressed in Snodgrass 2000 .

Our first embodiment is for a canonical schema used by all temporal tables in a temporal database managed by the AVF and for a means by which requests to modify the data stored in these temporal tables can be satisfied.

Our first embodiment references a schema common to all the temporal tables . This schema is the set of columns used by this invention to record and to manage all temporal data. In each table there will be additional columns which represent the data specific to the kind of object represented by the table data which we have called and will call business data and which are shown in as the two columns . Thus a customer table will have columns describing customers a product table will have columns describing products and so on. But if both tables are temporal tables then both tables will use an identical set of columns to represent the temporal features of that data.

 def OID a unique identifier for an object. In our preferred embodiment it is a single surrogate valued column. In another embodiment the object identifier might consist of more than one column.

Whenever the AVF concludes that a temporal insert transaction contains data that describes an object that is not already represented by a row in the target table for that transaction the AVF creates a new OID and attaches it to the transaction. Whenever the AVF concludes that a temporal insert transaction contains data that describes an object that is already represented by a row in the target table for that transaction the AVF attaches the OID from that row in the target table to the transaction. In this way to the extent permitted by the quality of the data on the transactions and in the database the AVF insures that across all assertion time and all effective time all rows representing the same object will have the same OID.

The temporal table shown in is a table of health insurance policies. The sample row shown in represents an insurance policy whose OID is 2117.

Effective time periods and assertion time periods are each represented in our preferred embodiment by a begin date and an end date. However these dates might also be timestamps or any other time valued column of data. The dates used in all examples in this patent application are calendar months. In our notation May10 stands for the calendar month May 2010 . The month Jun10 therefore comes right after the month May10 there is no temporal gap between them. In another embodiment a single column with a PERIOD datatype might be used instead to represent each time period. But because there is no consistent implementation of a PERIOD datatype across all the major commercial DBMSs available today we use begin and end dates as our preferred embodiment of time periods.

Columns and are respectively the effective begin dates and effective end dates for this sample table. Columns and are respectively the assertion begin dates and assertion end dates for this sample table.

The sample row shown in has an effective time period of Mar10 9999 . In this notation which is also used for assertion time periods the first date within the brackets is a begin date and the second date is an end date. The statement made by this row describes what the object it represents is like beginning on March 2010 and what it will continue to be like unless or until the row is withdrawn. This follows from the fact that 9999 stands for the highest date the DBMS managing the database can recognize. Because it is the highest date any date on or after March 2010 will be included in that period and on any of those dates this row will be current in effective time or for short current in effect or currently effective .

 def withdraw to withdraw a row in a temporal table is to alter it so that it appears to reside in a semantic logfile which physically exists within the temporal table itself.

 def semantic logfile rows in a semantic logfile are all and only those rows no longer asserted to make true statements and they are so designated by changing their assertion end dates to the date on which the assertion ceases to be made. Thus a semantic logfile is not a physical structure within a temporal table. It is just the set of rows whose assertion end dates are in the past. It is the set of rows which in comprise all and only those rows in the categories and .

The sample row shown in has an assertion time period of Mar10 May10 . This means that in the months of March and April 2010 the statement made by this row was asserted to be a true statement describing what the object it represents was like and was assumed to remain like unless or until other modifications are made to the database during its effective time period of Mar10 9999 . It also means that beginning in May 2010 the row was no longer asserted to make a true statement and never again will be used to make a true statement. Beginning in May 2010 the row became part of that table s semantic logfile.

In a temporal table the primary key of a row in that table consists of semantically a unique object identifier an assertion time period and an effective time period. No two rows in a temporal table may have the same OID identical or overlapping assertion time periods and identical or overlapping effective time periods. Given this semantics of time periods as components of primary keys and given our representation of time periods as pairs of dates we represent time periods in the primary keys of temporal tables in this embodiment by using their begin dates only. Therefore the primary key of the canonical schema is the combination of columns and .

By managing these pairs of dates as time periods the AVF guarantees that we can represent a time period in a primary key by using just one of the dates that delimit the time period. For example as far as the DBMS is concerned the table shown in could contain a second row which is identical to the row shown except that its effective begin date is Aug10. The values in the primary key columns of those two rows would be different and so the DBMS would consider the primary key uniqueness constraint to be satisfied. However the AVF would prevent that second row from being added to the table because the AVF would recognize that the two time periods Mar10 9999 and Aug10 9999 overlap. This overlap is a TEI violation.

 def business key the non key columns in a temporal table which correspond to the primary key columns of the precursor table corresponding to this temporal table. Column is the business key of an object represented by a row in a temporal table. If the temporal table previously existed as a non temporal table it is also the primary key of that otherwise identical non temporal table. The one or more columns making up the business key of a temporal table are identified by metadata as shown in .

Column of is a TFK. As explained later in this description by means of temporal foreign key metadata shown as item in the AVF knows which temporal table is referenced by each TFK. The row of sample data in which shows a Policy table indicates that the insurance policy is related to i.e. is owned by a client whose OID is 8094. The Client table referenced by this TFK is not shown. 

 def business data data which describes a property or a relationship of an object. In the table shown also contains two columns of business data indicates as items . The business data in the sample row in says that the indicated insurance policy has a policy type of HMO and a copay amount of 15.

 def atemporal data data in a canonical schema other than the object identifier and the two time periods.

In our preferred embodiment all temporal transactions are managed with Instead Of triggers. In this embodiment any temporal update or temporal delete transaction may provide any selection criteria in a WHERE clause and the AVF will update or delete rows for as many objects as satisfy those selection criteria. The deferred assertion Asserted Versioning Framework AVF D described in another implementation will do so also. In the following descriptions of how temporal transactions are processed however we will describe them as though only one object was specified on each transaction. Processing multiple objects in one transaction is simply a matter of the AVF or the AVF D AVF looping through all objects until all have been processed.

In an alternative embodiment all temporal transactions are submitted to the AVF or AVF D by means of a proprietary Application Programming Interface API . In this alternative embodiment a temporal transaction will insert update or delete data for only one object at a time.

All references below to transactions unless explicitly indicated otherwise refer to temporal insert transactions until the section A Temporal Update Transaction is reached.

As submitted a temporal insert transaction must specify i a target temporal table ii a business key iii any required TFKs and optionally iv an OID v additional TFKs and vi any other business data that may be required. As shown in the AVF begins processing temporal transactions by insuring that all required data is present and is syntactically correct. Temporal foreign key metadata is associated with every table. If this metadata indicates that there are one or more TFKs on the table which are required indicated by a value of Yes in the req fig column of then the AVF will reject the transaction unless it includes values for those required TFKs. Temporal foreign key metadata may also be associated with every table. It specifies the columns which make up the business key for the table. If an effective time period is supplied on the transaction the AVF checks that the end date on the time period is greater than the begin date.

As shown in the AVF next supplies any default data required by the transaction. The AVF will supply a default assertion time period for the transaction which is always Now 9999 . A basic temporal insert does not specify any time periods. In that case the AVF will supply a default effective time period of Now 9999 .

 def Now this notation is used to indicate the current moment in time at which a transaction is being applied to the database.

An assertion time period may never be specified on a temporal transaction submitted to the AVF and will always default to Now 9999 .

A temporal insert which is not a basic temporal insert may also be submitted to the AVF. On a non basic temporal insert all or part of an effective time period is explicitly supplied with the transaction. If only an effective begin date is supplied the AVF uses 9999 for the effective end date. If only an effective end date is supplied the AVF uses the value of Now for the effective begin date. This effective time period may be any past present or future time period. A present or future time period may be open in which case it has a 9999 end date. A present or future time period may also be closed in which case it has a non 9999 end date. Past time periods are always closed.

As shown in the AVF defines a bi temporal target space based on the effective time period and assertion time period of the transaction.

 def target space a range of assertion time together with a range of effective time specified by a temporal transaction.

If each temporal dimension is represented as one axis on a Cartesian graph then a transaction s target space may be represented as a rectangle on that graph and the bi temporal extent of any row in a temporal table may also be represented as a rectangle on that graph.

 def target point a target space is made up of target points. Because this is a two dimensional space each point is uniquely identified by a pair of coordinates. One coordinate is a clock tick in assertion time. The other coordinate is a clock tick in effective time.

Each row in a temporal table exists in a space defined by its pair of time periods. Each row occupies all of the points in that space.

 def occupied space occupied points we will call the space associated with each row its occupied space and the points in its occupied space occupied points .

Note that a point in either target space or occupied space corresponds to a pair of points in time one of which is a point in assertion time and the other of which is a point in effective time.

As shown in the AVF attempts to match the transaction to rows already in the target table. It searches for rows which match the business key specified on the transaction. If it finds such rows the AVF checks among them to see if even one of them has even a single occupied point that matches a target point for the transaction.

If an OID is supplied on the transaction the AVF will attempt to find a row already in the target table with the same OID and the same business key. If it does not find one it rejects the transaction.

If the AVF finds such a row it will reject the transaction. For example if the transaction specifies a target space of effective time Jan12 9999 and assertion time Jul11 9999 then a row for the same object whose effective time period is Mar11 Feb12 and whose assertion time period is Mar11 9999 will cause the transaction to be rejected.

If the AVF does not find any such matching rows it may still find a match to a row representing the same object but a row whose occupied space is entirely outside the transaction s target space. If such a match is found the AVF assigns the OID from the matching row in the target table to the transaction and otherwise assigns a new OID.

At this point the AVF has confirmed that applying the transaction to the database will not violate TEI because no row already in the target table and representing the same object occupies any points within the transaction s target space.

Before a temporal table can be generated metadata is created for it. If a temporal table contains a TFK that fact is specified as metadata in along with a designation of the table referenced by the TFK and also an indicator stating whether the TFK is optional or required. If no TFK is specified on the transaction and there is no TFK defined as required for the target table then the transaction is passed to the DBMS which creates a new row in the temporal table for that transaction. Otherwise the value provided for each TFK on the temporal insert transaction must pass the TRI check.

In one embodiment the TRI check works as follows. Every TFK contains an OID value. For every TFK value supplied on the transaction the AVF identifies a set of rows in the parent table which each have an OID which matches the OID value in the TFK and which each have at least one occupied point which matches at least one point in the target space for the transaction.

 def parent occupied space parent occupied points we call the space occupied by the set of these parent table rows the parent occupied space corresponding to the transaction and the points in that space parent occupied points .

 def points matching points we say that a point in one space matches a point in another space if and only if the two points have the same temporal coordinates i.e. occur at the same point in assertion time and the same point in effective time.

If for every point in the transaction s target space there is a matching point in the parent occupied space then the transaction passes the TRI check and otherwise does not. If the transaction passes all TRI checks then the transaction is applied to the target table.

In another embodiment the AVF matches rows in the parent table to transactions by assembling sets of effective time periods from rows in the parent table that i entirely include the assertion time period of the transaction and ii that include at least one effective time clock tick specified on the transaction. It then sequences the effective time periods it has assembled and looks for a contiguous set of time periods that have no gaps between them and that together include the entire effective time period specified on the transaction.

All three rows contain a TFK of 8094. Because these three rows have passed TRI checks the AVF knows that there is a set of rows in the Client table which have i an OID of 8094 ii an assertion time period which began on or before January 2008 and which has an assertion end date of 9999 and iii an effective time period which began on or before January 2008 and has an effective end date of 9999. Of course since there is a fourteen month gap during which policy P was not in effect the set of rows in the Client table may also include that gap or any smaller gap inside the same fourteen month period of time.

The steps shown in do not necessarily represent the sequence of steps taken by the program code in this invention. They are intended to illustrate one way in which program code could be written to manage temporal insert transactions. Other embodiments of the transformations described by these steps are possible and based on the description of these steps one skilled in the art could design and build other such embodiments.

All references below to transactions unless explicitly indicated otherwise refer to temporal update transactions until the section A Temporal Delete Transaction is reached.

As submitted a temporal update transaction must specify i a target temporal table ii selection criteria and whatever business data is to be updated. The selection criteria may include a business key an OID or both. If it does only data representing the one object thus selected will be updated. Otherwise the temporal update transaction may update data representing several objects.

As shown in steps and in the AVF edits the transaction supplies temporal defaults and defines the target space for the transaction just as it does for a temporal insert transaction discussed above with reference to .

A temporal update may or may not be a basic transaction. If it is then no effective time period is supplied with the transaction and the AVF uses the default effective time period Now 9999 .

Then as shown in in step the AVF attempts to match the transaction to rows already in the target table which all represent one object and which have met the selection criteria from the transaction. As explained earlier if rows representing multiple objects meet the selection criteria then the processing done by the AVF is equivalent to looping through those objects and processing them one at a time.

If the AVF does not find such a row it will reject the transaction. For example if the transaction specifies a target space of effective time Jan12 9999 and assertion time Jul11 9999 then a row for the same object whose effective time period is Mar11 Feb12 and whose assertion time period is Mar11 9999 will cause the transaction to be accepted. Also to take another example a row whose occupied space is wholly contained within the transaction s target space will cause the transaction to be accepted.

If a transaction was not supplied with an OID then the AVF will assign the OID from a matching row in the target table to the transaction.

If one or more TFK values are supplied on the temporal update transaction then the AVF carries out a TRI check on each of them.

If the temporal update transaction is not rejected then the AVF continues to process it. All work done from this point forward until the transaction is complete is done as an isolated and atomic unit of work.

As shown in the AVF begins by withdrawing target rows which partially overlap the target space. These are rows i whose assertion time periods end in 9999 and thus include the assertion time period of the transaction and whose effective time periods ii share at least one clock tick with the effective time period of the transaction and also iii include at least one effective time clock tick that is not included within the effective time period of the transaction.

To withdraw a row is to change its assertion end date to the assertion begin date specified on the transaction. That point in time is always the point in time at which the transaction is being processed. Semantically this means that from Now on the withdrawn row will no longer be asserted as making a true statement about the object it represents.

 def cut to cut a withdrawn row is to create a set of rows which are identical to the withdrawn row except that i each row in the set is given the assertion time period specified on the transaction ii either one or two rows in the set has an effective time period identical to the part of the withdrawn row s effective time period that lies outside the transaction s target space and iii one row in the set has an effective time period identical to the part of the withdrawn row s effective time period that lies inside the target space. In this invention the assertion time period specified on the transaction is always Now 9999 .

The AVF then physically inserts the one or two rows in the set of rows whose effective time period lies outside the target space into the target table. These rows are said to replace the part or parts of the withdrawn row that were outside the target space of the transaction. These rows are given the assertion time period specified on the transaction.

Next the AVF applies the business data and any temporal foreign keys from the transaction to the remaining row in the set of rows. It then physically inserts this updated row into the target table assigning it the assertion time period from the transaction. This updated row is then said to supercede the part of the withdrawn row that was inside the target space of the transaction. For example if the temporal transaction specified an insurance policy type of PPO then the policy type in the superceding row is overwritten with that value.

Next the AVF withdraws all rows which do not exist in past assertion time but which have the same OID as the OID on the transaction and whose effective time periods are fully contained within the effective time period of the transaction.

Next the AVF makes a copy of those withdrawn rows assigns them the assertion time period specified on the transaction and updates all data other than the two time periods on those rows with the corresponding data from the transaction. If any temporal foreign keys were specified on the transaction the AVF also updates the temporal foreign keys on those rows with the values from the transaction. It then physically inserts those new rows which are rows which supercede their corresponding withdrawn rows.

As already noted all the physical updates and physical inserts required to complete a temporal update transaction are managed by the AVF as an atomic and isolated unit of work. If any of those physical transactions fails the AVF will direct the DBMS to undo any earlier physical transactions that are part of that unit of work.

We may assume that the only business data supplied on the transaction was a new copay amount because that is the only business data that the transaction changed. Therefore there were no TRI checks to be performed by step for this transaction.

Next the AVF withdrew the one matching row it found that being the third row in the target table shown in . It withdrew the row by physically overwriting its assertion end date of 9999 with the clock tick on which the transaction was being processed that being September 2010. This was done in step .

Next the AVF completed step . The result was to physically insert into the table the fourth and fifth rows shown in . In step the AVF used the fourth row to replace the part of the withdrawn row that was outside the target space of the transaction. In step the AVF updated the fifth row with the business data from the transaction and thus superceded the part of the withdrawn row that was inside the target space of the transaction.

No other rows in the target table were wholly or partially within the target space of the transaction and so the transaction was complete at that point in time. The atomic and isolated unit of work was complete and all locks used in the process were released.

The steps shown in do not represent the sequence of steps taken by the program code in this invention. They are intended to illustrate one way in which program code could be written to manage temporal update transactions. Other embodiments of the transformations described by these steps are possible and based on the description of these steps one skilled in the art could design and build other such embodiments.

All references below to transactions unless explicitly indicated otherwise refer to temporal delete transactions until the section Support for Uni Temporal and Non Temporal Data as Abstractions is reached.

As submitted a temporal delete transaction must specify i a target temporal table and ii selection criteria. The selection criteria may include a business key an OID or both. If it does only data representing the one object thus selected will be deleted. Otherwise the temporal delete transaction may delete data representing several objects.

As shown in steps and in the AVF edits the transaction supplies temporal defaults and defines the target space for the transaction just as it does for a temporal insert transaction.

A temporal delete specifies that for the object it represents no rows may remain asserted in the target table anywhere within the assertion time period and the effective time period specified on the transaction. A basic temporal delete has no effective time period supplied with the transaction and so the AVF associates the default effective time period Now 9999 with the transaction. The result will be to withdraw any rows in current assertion time which have even a single effective time clock tick within that period of time. A non basic temporal delete will have an effective time period supplied with the transaction or else it will supply a begin date only or an end date only. In the former case the AVF uses 9999 for the end date in the latter case it uses the value of Now for the begin date. For example a non basic temporal delete might specify an effective time period of Apr09 Dec15 . The result of that delete will be that no currently asserted rows will remain in the target table that represent the indicated object and whose effective time periods fall anywhere within that range of time.

A temporal delete requires that for any row whose occupied space lies partially within the transaction s target space and partially outside that target space the AVF withdraw that row and replace the part of the row which lies outside that target space. We note that if the row s effective time period begins before the effective time period on the transaction and also ends after the effective time period on the transaction ends that the AVF will insert two replacement rows for the withdrawn row one on either side of the transaction s specified effective time period.

The AVF then withdraws all rows which within in the assertion time specified on the transaction have effective time periods which lie completely within the effective time period specified on the transaction. The result is that from the assertion begin date specified on the transaction on into the future until and unless later temporal insert transactions re populate all or part of those withdrawn representations of the object the target table will not assert any representation of the object within that period of effective time.

If a conventional transaction deletes a row in a table which is the parent table in a referential integrity relationship the DBMS must insure that the result of the transaction does not leave any dangling references to that row from the child table. In other words it must not leave any rows in the child table which have foreign keys pointing to the row in the parent table that were deleted.

As is well known to those skilled in the art a relational DBMS has three ways to prevent dangling references being created by a delete transaction. One way is to restrict the delete transaction as long as there are any child rows that would be left with dangling references. A second is to remove the dangling references in the child rows by setting the foreign keys in those rows to null. The third is to cascade the delete of the parent row or rows deleting all the child rows that point to it.

The third option of course is recursive because if a child row is deleted and it is also a parent row to some other row then deleting it would leave a dangling reference to it. Once again the DBMS has three options to avoid the dangling references.

To illustrate the multi table effect of a temporal delete transaction we consider an example in which two tables are involved. The parent table is a Client table as shown in . We will assume that a temporal delete transaction is being processed on December 2010 and that it specifies that client C was in fact not a client of our company during the months of July through October of 2010. This is obviously a retroactive transaction correcting a mistake in the database.

As shown in in steps and the AVF edits the delete transaction supplies temporal defaults and defines the target space . It then matches rows in the target table to the target space . As with a temporal update transaction the AVF requires that there is at least one row representing an object selected by the transaction and that occupies at least one point that matches a point in the transaction s target space.

If there is no such row the AVF rejects the transaction. However the one row for client C as shown in meets this criterion and so the AVF accepts the transaction. If no OID was supplied on the temporal delete transaction then in step the AVF attaches the OID from the matching row to the transaction.

Next the AVF checks to see if any child rows to client C also exist within the transaction s target space. It looks at the temporal foreign key metadata shown in . The metadata indicates that the Client table is a parent table in a TRI relationship and that a temporal delete against that table should be cascaded to the Policy table. Since the metadata does not specify that the temporal delete should be restricted and since there are no other tables for which the Client table is a parent table in a TRI relationship the AVF continues to process the transaction.

In our preferred embodiment this metadata is used to create static scripts that perform these operations but in another embodiment this metadata could be evaluated dynamically at run time.

The temporal delete transaction specified an effective time period of Jul10 Nov10 . In this invention the transaction defaulted to an assertion time period of Now 9999 with Now being the clock tick of December 2010. There is only one row for client C and some of its occupied points match points in the target space of the transaction while others do not. Therefore the AVF begins by withdrawing that one client row. As shown in it does this by overwriting the 9999 assertion end date on the row changing the rows assertion time period to Jan08 Dec10 . In other words as soon as this transaction is complete that row will no longer be asserted to make a true statement.

In this example the target space is wholly contained within the occupied space of the one row for client C. Therefore the cut operation step results in three rows. Two are outside the target space and one is inside the target space.

Next the AVF inserts into the target table the two rows resulting from the cut operation which are outside the target space of the transaction. The middle row is discarded and is not added to the target table because it represents the effective time period specified on the delete transaction. The two rows added in this step are shown as the second two rows in

There are no other rows for client C within the target space of the transaction so there is no work for this step to do.

The AVF has already determined that this temporal delete transaction should cascade to any dependent tables and that there is one such table that being the Policy table. Since steps have already been applied to the temporal delete transaction they do not need to be invoked a second time and so the temporal delete transaction as applied to the Policy table begins with step .

By referencing the temporal foreign key metadata the AVF determines that the Policy table is not a parent table in any TRI relationship. If it were a parent table in a TRI relationship and if the metadata said that a temporal delete to that table should be restricted as long as there were any TRI dependents on the data about to be deleted then the AVF would have to direct the DBMS to undo the physical updates that had already been made as part of carrying out this temporal delete transaction.

The temporal delete transaction specified an effective time period of Jul10 Nov10 and defaulted to an assertion time period of Now 9999 with Now being the clock tick of December 2010. There are two rows in the Policy table whose TFKs reference client C by containing the OID value of 8094 and which each have some occupied points which match points in the target space of the transaction and some occupied points which do not. These are the fourth and fifth rows shown in and also . shows these rows before the temporal delete transaction is applied to them. shows these rows after the transaction is applied. These two rows are withdrawn by overwriting their assertion end dates with the current clock tick. As shown in the result is to change the assertion time period on these rows to Sep10 Dec10 . In other words as soon as this transaction is complete those two rows will no longer be asserted to make true statements.

In this example the cut operation cuts the first withdrawn row into two rows and also cuts the second withdrawn row into two rows. The two rows resulting from the cut of the first withdrawn row have effective time periods of Mar10 Jul10 and Jul10 Sep10 . The two rows resulting from the cut of the second withdrawn row have effective time periods of Sep10 Nov10 and Nov10 9999 .

Next the AVF inserts into the target table the two rows resulting from the cut operation which are outside the target space of the transaction. They are i the first row in the first pair of rows and ii the second row in the second pair of rows. These rows are given the assertion time period specified on the transaction which is Now 9999 and appear in as the last two rows in the table.

The other two rows produced by step are discarded because they fall entirely within the target space of the transaction.

The transaction is now complete. Prior to December 2010 currently asserted rows in the database stated that there was a client C in effect during the months of July August September and October of 2010 and also that this client owned a policy P which was in effect during that time and which in July and August had a copay of 15 and in September and October had a copay of 20. Starting on the clock tick of December 2010 there are no currently asserted rows making any of these statements. By a natural extension of the Closed World Assumption to this database we can say that starting in December 2010 the database states that there was no such client and no such policy in effect during those four months of 2010.

Improvements are to add to the functionality of some embodiments the ability to support queries for either kind of uni temporal data and queries for non temporal data without exposing to the authors of those queries the complexities of the canonical schema or the complexities of a table which may contain rows which exist in any of the temporal categories past past past present past future present past present present or present future as shown in .

Some embodiments already makes it possible for the authors of maintenance transactions to write insert update and delete transactions against the canonical schema without being exposed to the complexities of the canonical schema or the complexities of the contents of those tables. When no temporal parameters are expressed on temporal transactions it appears to the authors of those transactions that they are writing transactions against the otherwise identical non temporal table. When effective time is expressed on temporal transactions it appears to the authors of those transactions that they are maintaining simple uni temporal version tables. Yet in both cases the AVF is supporting changes in assertion time as well and by that means is able to present as queryable objects either otherwise identical non temporal data as it physically existed at any point in time or uni temporal version data as that data existed at any point in time.

So together with these encapsulation capabilities for maintenance transactions the encapsulation capabilities of additional embodiments mean that by means of the AVF and its universal canonical schema the complexities of managing and querying bi temporal data as though it were non temporal data are eliminated and the complexities of managing and querying bi temporal data as though it were uni temporal versioned data are also eliminated.

Nowhere in the prior art is it proposed that valid time data transaction time data and non temporal data can be managed and queried as abstractions on temporal data which is physically implemented only in bi temporal tables. But this is one of the features of our invention. We continue our discussion of this implementation using our terminology of effective time and assertion time . As explained earlier effective time is equivalent to valid time and until we begin to discuss deferred assertions assertion time functions exactly as transaction time does.

The invention manages effective time data assertion time data and non temporal data as abstractions on the bi temporal data stored in the tables which conform to its canonical schema.

The AVF does this by means of the temporal transactions it supports and the bi temporal data into which it maps the results of carrying out those transactions. Assertion time periods cannot be specified on the temporal transactions and so the role of assertion time periods in tracking changes to data which do not correspond to changes in the objects represented by that data is transparent to the user of the invention. But every time a temporal transaction changes the data which describes the state of an object during a period of effective time the AVF preserves the before image of that data as a withdrawn assertion. And so when users of the database write temporal transactions even though they do not specify assertion time on those transactions the AVF does manage those transactions so as to keep a complete record of all uni temporal assertion time data in its canonical tables.

Valid time periods can be specified on the temporal transactions. When they are the data on the transaction is interpreted as describing the state of the object designated by the transaction only during that valid time period. In this way data describing past present and future states of objects can be entered into the database at any time and the database always contains the most current description of the state of an object at any point in valid time. When two or more rows of data in a canonical table both contain a description of the state of an object at a given point in valid time the most current description of that state of the object is the one provided by the row which is most recent in transaction time. And so when users of the database write temporal transactions the AVF does manage those transactions so as to keep a complete record of uni temporal valid time data in its canonical tables. And to those users it will seem as though they are maintaining uni temporal valid time tables.

It is not necessary to specify valid time periods on the temporal transactions. If a valid time period is not specified on a temporal transaction we refer to it as a basic temporal transaction. Basic temporal transactions make it appear that it is a conventional non temporal table that is being maintained because of the implicitly understood semantics of conventional tables. Those semantics are that every row in a conventional table at each point in time represents i the assertion that at that point in time that row makes a true statement and ii the assumption that at that point in time that row describes the then current state of the object it represents. The only way to remove that assertion of that description from a conventional table is to delete the row in question.

Every basic temporal insert or update results in a row with these same semantics. Every basic temporal delete results in the same semantics by withdrawing one or more currently asserted rows into past assertion time. Inserts updates and deletes of data describing a specific object as basic temporal transactions will seem to be inserting updating and deleting the one row of data in a conventional table that represents that object. However what in fact is happening is that the AVF is keeping track of the bi temporal history of that object and of the data that describes it.

Some embodiments complement the management of temporal transactions just described by providing views corresponding to each of the two kinds of uni temporal table and also by providing a view over each canonical table which corresponds in both schema and content to an otherwise identical non temporal table.

The section entitled Foundational Concepts an Otherwise Identical Non Temporal Table describes an algorithmic process by which a temporal upward compatibility view could be automatically generated for each temporal table using the canonical schema and the metadata of this invention.

In we show such a view for the Policy table. We assume in this view that Policy is the name of the original non temporal table of policies and that Client AV is the name of the temporal table of clients shown in and elsewhere. In reference character designates the schema of the original non temporal Policy table. It should be apparent to one skilled in the art that the view statement shown in defines the same identical schema.

The view V Policy Non Temp Curr which is shown in restricts the rows from the Policy AV table which will appear in the view to those rows which are current in both valid time and transaction time. Since the Policy view shown in selects its rows from this view shown in and since the Policy view does not filter out any rows it should be apparent to one skilled in the art that the view statement shown in will result in a view which at each moment in time contains all and only those rows from the temporal table that are current in both valid time and transaction time.

 def physical data model we use this term as it is understood by data modelers throughout the Information Technology profession. Paradigm examples are the physical data models produced by the ERwin data modeling tool.

 def non temporal physical data model a physical data model none of whose tables include valid time or transaction time and none of whose tables include effective time or assertion time.

 def preliminary data model a non temporal physical data model from which together with temporal metadata this invention will generate a temporal database.

 def precursor table a table in preliminary data model from which together with temporal metadata this invention will generate a temporal table.

 def temporal table generated by this invention a temporal table generated from a precursor table together with temporal metadata by this invention.

 def Asserted Versioning Framework Script Code program procedure or program code logic that is generated and executed statically or executed dynamically using temporal metadata that enforces temporal constraints and manages the temporal data defined in this invention as temporal transactions are applied to them.

For each precursor table in a preliminary data model this invention generates a temporal table by carrying out the following steps as shown in . We will describe the generation of the Policy canonical schema temporal table shown in from the Policy precursor table shown in .

The invention names and creates a schema which conceptually at this point contains only an OID column. As determined by the metadata the name of that schema is Policy AV. The OID is the column policy oid.

We note that here and elsewhere in this patent application including in some of the Figures column names contain hyphens but in others of the Figures the same column names contain underscores in place of hyphens. As physically implemented of course column names must not contain hyphens.

The two columns of the Policy canonical schema temporal table eff beg dt and eff end dt are next added to the schema. In another embodiment a single column using a PERIOD datatype could be used.

The two columns of the Policy canonical schema temporal table asr beg dt and asr end dt are next added to the schema. In another embodiment a single column using a PERIOD datatype could be used.

In this embodiment the effective time period is represented in the primary key of every temporal table by means of the eff beg dt only and the assertion time period is represented in the primary key of every temporal table by means of the asr beg dt only. In other embodiments the end dates could be used instead or both the begin and end dates. In another embodiment in which each time period is represented by a single column using a PERIOD datatype those two columns would be part of the primary key.

The AVF now reviews the schema of the precursor table in the preliminary data model as shown in . The primary key column has already been represented in the temporal schema by the business key column. The foreign key column has already been replaced by a temporal foreign key column. The remaining columns are policy type and copay amt and the AVF now adds them to the schema for the temporal table.

A temporal table has now been generated from the combination of a precursor table in a preliminary data model and temporal metadata. When this has been done for every precursor table listed in the metadata the generation of all temporal tables in the temporal database is complete.

However we note that the temporal metadata is not only used by the AVF to generate temporal tables from precursor tables. It is also used in the management of those temporal tables as temporal transactions are applied to them.

The metadata allows the AVF to translate temporal transactions which name otherwise identical non temporal tables into physical transactions which name the temporal tables which physically exist in the database.

The metadata is a declarative specification of all temporal foreign keys in the database naming the temporal foreign key column indicating whether each one is optional or required and indicating how each one is to be treated when involved in a temporal delete transaction.

The business key metadata identifies the column or columns in each temporal table which correspond to the primary key column or columns in the corresponding otherwise identical non temporal table. This is important for creating the view which supports temporal upward compatibility for queries against an earlier non temporal form of the table. One reason this metadata is important is that these columns will appear in the view in place of the primary key columns of the temporal table. A second reason this metadata is important is that the values for these columns are in fact the values which will populate the foreign key columns in the view which supports temporal upward compatibility for the temporal tables which reference the temporal tables in which these columns are the business key columns.

The metadata which maps foreign keys to temporal foreign keys is also important for creating the view which supports temporal upward compatibility for queries against an earlier non temporal form of the table because these foreign key columns will appear in the view in place of the temporal foreign key columns of the temporal table. These foreign key columns are the columns that will be populated by the values from the business key columns of the temporal table to which the temporal foreign keys replaced by these foreign keys refer.

This aspect adds to various implementations the ability to express requirements for temporal data as metadata and thus to avoid the need to design specifically temporal tables columns keys etc. in any kind of data model including a relational logical data model an entity relationship data model or a physical data model. It also adds to the various implementations the ability to automatically generate temporal tables from precursor tables and the temporal metadata associated with them.

This invention has several important benefits. First it eliminates the work involved in expressing temporal requirements in data models. The amount of work can be substantial as is shown in Chapter 11 in the book by Dr. Richard Snodgrass Snodgrass 2000 . This chapter takes fifty five pages to explain how to express temporal data requirements in data models.

Second this invention means that existing data models which do not express temporal requirements do not have to be modified whenever one or more non temporal tables in a database are converted to temporal tables. This preserves the business value of existing data models which can remain unchanged as the databases they describe evolve over time to contain an increasing number of temporal tables and a smaller number of non temporal tables.

Third this invention means that there are no differences in how the same temporal requirements are implemented by different project teams designing solutions for different subsets of the tables in one or more databases. The process of generating one or more temporal tables of a database from a preliminary data model together with metadata means that this invention guarantees that all temporal tables will have the same canonical schema and therefore can be maintained with the same codebase and with the set of transactions without regard to ad hoc differences reflecting different approaches by different design teams to solving the same set of requirements and can also be referenced in queries without needing to elaborate those queries to overcome such ad hoc differences.

Fourth this invention eliminates the complex custom code that application programs would otherwise require to properly maintain temporal data. All the complexities of maintaining temporal data are isolated in the AVF. The work of application programs is simply to accept temporal transactions as input and pass them on to the AVF.

This aspect differs from the previously described embodiments by the addition of a user defined managed object which we call an episode and by extending the AVF to use episodes to manage temporal tables.

 def A managed object is the representation in data of a specific object or of a specific type or concept.

A table is a managed object representing a type such as customers or products. A row in a conventional table is a managed object representing an instance of a type such as a specific object or a specific product.

The series of steps by which the AVF E manages temporal transactions and the data in extended canonical schema tables which result from those transactions is the same series of steps by which the AVF manages temporal transactions and the data in canonical schema tables which result from those transactions except that the AVF E manages episode begin dates and uses them in carrying out temporal referential integrity checks. The management and use of episode begin dates replaces the processes that the AVF uses to dynamically create and utilize occupied spaces and points and parent occupied spaces and points.

The managed object we call an episode is a set of rows. It is managed by means of one column added to our canonical schema. That is the column designated by reference character in . With the addition of this column our canonical schema becomes our extended canonical schema .

 def An episode is a set of rows in a temporal table which have i the same OID ii a shared period of assertion time iii effective time periods which do not overlap and which in effective time chronological sequence do not contain any gaps between any adjacent pairs of those rows and iv for which there is no other row which has iv a the same OID iv b an assertion time period which is identical to or which overlaps the shared assertion time period of the rows in the set and iv c an effective time period which is effective time contiguous with the effective time period of either the effective time earliest or latest row in the set.

Within any period of assertion time every episode is uniquely identified by an OID and a point in effective time. That point is the earliest point in effective time of all the rows in the set. It is represented by the episode begin date and in our preferred embodiment the value in that column will be identical to the value in the effective begin date of that earliest row in that set. All the rows which belong to the same episode have the same episode begin date.

We will first describe episodes in terms of how they are managed and then in terms of how they are used.

The shared assertion time of a set of rows is the largest assertion time period included in the assertion time periods of all the rows in the set. In the two rows shown in that shared assertion time is the assertion time period of Jul08 9999 .

Both the AVF and the AVF E which is the extended version of the AVF shown in will guarantee that within shared assertion time no two rows in any set of rows with the same OID will have identical or overlapping effective time periods. This guarantee is provided by enforcing the constraint of temporal entity integrity. It follows that none of the rows in an episode will have identical or overlapping effective time periods.

However within shared assertion time and among rows with the same OID there may be temporal gaps between any two effective time adjacent pairs of those rows. Each such gap defines the end of one episode of the object represented by that OID and also defines the beginning of another episode of the object represented by that OID. This follows from component iv of the definition of an episode provided above.

An episode can be added to a temporal table by a temporal insert transaction. It can also be created by a temporal delete transaction which removes a period of effective time from within the effective time of an existing episode. By doing so the temporal delete transaction creates a gap in effective time and as the previous paragraph explains such a gap defines the boundary between two adjacent episodes. There is no other way to add an episode to a temporal table.

An episode can be removed from a temporal table by a temporal delete transaction or by a temporal insert transaction which merges two episodes into one episode. There is no other way to remove an episode from a temporal table.

 def next to two points in time in the same temporal dimension are next to one another if and only one follows the other without any gap in time between them. It is important to emphasize however that because of the closed open convention used to represent time periods in this embodiment if two time periods are next to one another then the end date of the earlier one will have the same value as the begin date of the later one.

A temporal insert transaction results in a new episode if and only if there is no row for the same object already in the target table whose effective end date in time is next to the new row s effective begin date and also no row for the same object already in the target table whose effective begin date is next to the new row s effective end date. In this case the new row s episode begin date is given the same value as its effective begin date. Here and elsewhere we sometimes leave out the phrase within shared assertion time but that phrase should always be understood to apply. In any comparison of points or periods in effective time the comparison always takes place within shared assertion time. Rows which do not share any assertion time cannot be compared they are incommensurable.

Effective begin dates effective end dates assertion begin dates and assertion end dates are the means by which in this embodiment individual effective time periods and individual assertion time periods are defined. In another embodiment these time periods might be defined by single columns with a PERIOD datatype.

Regardless of the embodiment time periods always have a known begin point in time and always last for at least one clock tick. Closed time periods also have a known end point in time. Open time periods are assigned as an end point in time the latest point in time which the DBMS can represent. In another embodiment open time periods might be designated by using NULL or by using any other special value which will be managed and interpreted as representing the latest possible point in time.

If the effective begin date of a new row created by a temporal insert transaction is next to the effective end date of another row with the same OID then the new row extends the episode that the other row belongs to forwards in effective time. In that case the new row is given the episode begin date of that other row indicating that it has become part of that episode.

If the effective end date of a new row created by a temporal transaction is next to the begin date of another row with the same OID then the new row extends the episode that the other row belongs to backwards in effective time. In that case the new row is given its own effective begin date as its episode begin date. In addition the row it is next to and all other rows in that other row s episode are withdrawn and are replaced with rows whose episode begin date matches the effective begin date of the new row just inserted whose assertion time periods are the same as the assertion time period of the new row and whose effective time periods business keys and other business data are otherwise unchanged. The new row and all these replacement rows then belong to the same episode.

If the new row created by the temporal insert transaction is next to both an earlier row for the same object and a later row for the same object then both of the next to conditions are satisfied and the result is that the new row merges two previously distinct episodes into a single episode. In that case the new row is given the episode begin date of the earlier row it is next to. Next the later row the new row is next to and all the other rows in that later row s episode are withdrawn and replaced as described in the previous paragraph. All the rows in the two episodes and the new row which has merged them are now part of the earlier of the two episodes that have been merged by this transaction.

A temporal delete transaction always specifies an object and has an effective time period. If no time period is supplied with the transaction the default time period of Now 9999 is added to the transaction. Otherwise a past present or future effective time period may be supplied with the transaction.

A temporal delete transaction withdraws rows from a designated period of effective time by ending the assertion time periods of those rows within that period of effective time. It does this by changing the assertion end dates of those rows to the value of Now at the time the transaction takes place. If necessary a temporal delete transaction will withdraw a row which is partially within the designated effective time period of the transaction and replace the part of the row that was outside that effective time period. This is similar to a cut done as part of a temporal update transaction but whereas the cut creates two rows which together correspond to the withdrawn row this process only creates the one row which corresponds to the part of the withdrawn row that is outside the target space of the transaction.

Rows whose effective time periods are entirely outside the effective time range of a delete transaction s target space are unaffected by the delete transaction. It follows that episodes all of whose rows are entirely outside the effective time range of a delete transaction s target space are unaffected by the delete transaction.

Conversely episodes all of whose rows are entirely within the effective time range of a delete transaction s target space are temporally deleted. They are withdrawn by having their assertion end dates set to the value of Now when the transaction is carried out.

If a row in the target table with the same OID has an effective time period which falls partially inside the effective time period of the temporal delete transaction and partially outside that effective time period then the row is withdrawn and a replacement row is created in current assertion time for the part of the withdrawn row that was outside the transaction s effective time period.

If the replacement row is for the effective time later part of the withdrawn row then it is the first row in a new episode and its episode begin date is set to its own effective begin date. In addition every effective time later row that was part of the original episode with that withdrawn row is also withdrawn assigned an assertion time period of Now 9999 and given the episode begin date of that first replacement row.

If the replacement row is for the effective time earlier part of the withdrawn row then it is the last row in the episode it still belongs to and its episode begin date remains the same as it was before the transaction.

If the effective time period on a temporal delete transaction begins after the effective time period of the first row in an episode and ends before the effective time period of the last row in an episode then the temporal delete transaction splits the episode into two episodes. The episode begin date for the later of the two new episodes is set to the effective begin date of the effective time earliest row in that new episode.

In another scenario the effective time period on a temporal delete transaction may align with the effective time periods of currently asserted rows in the target table with the same OID. In this case all the rows within the effective time period of the transaction are withdrawn. If the effective time latest withdrawn row is not the effective time last row in an episode then the remaining rows in that episode constitute a new episode with a new episode begin date. So all those rows are withdrawn and replaced by rows with assertion time periods of Now 9999 episode begin dates equal to the effective begin date of the effective time earliest row in the new episode and are otherwise identical to the withdrawn rows.

Episodes improve the performance of temporal referential integrity checks. This is because episodes are the parent managed objects in a temporal referential integrity relationship. In checking temporal referential integrity the AVF E does not need to retrieve multiple rows in the parent temporal table for the relationship. It only needs to retrieve the one row whose OID matches the temporal foreign key value of the child row for which the integrity check is being carried out and whose effective end date is equal to or greater than the effective end date of that child row. On that one parent row the episode begin date indicates the start of the effective time extent during which the object referenced by the temporal foreign key is without any temporal gaps represented. If the effective begin date of the row for which the check is being carried out is equal to or later than that episode begin date then the row passes the temporal referential integrity check and otherwise does not.

In this way by needing to retrieve only one row from the parent table the AVF E can carry out temporal referential integrity checks more efficiently than the AVF can because the AVF uses the process in which the occupied space of possibly many parent rows must be consulted.

This aspect is for an improvement on previously described embodiments. The improvement is to substitute an approximately accurate match predicate for a range predicate.

We will not provide figures to illustrate the use of the match predicate but it constitutes a modification to the canonical schema . The match predicate is based on a column we call a circa effective flag. The column can take on one of two values for example 0 and 1 .

A match predicate that will substitute in an index for a range predicate on effective time cannot be guaranteed accurate at all times. For example assuming our time periods are accurate to milliseconds a row may have an effective time period which will end in three milliseconds. This means that three milliseconds from now that row will no longer be current. How is a flag to change its value at precisely that split second moment in time 

The key insight is this. The flag doesn t have to be one hundred percent accurate to be useful as a match predicate. We design these flags to distinguish between rows whose time periods are known to be in the past from rows whose time periods are not known to be in the past.

When the AVF creates a new row in a temporal table the effective time period of that row may be in the past present or future. If it is in the past we assign its circa effective flag a value of 0 and otherwise a value of 1.

During some maintenance processes the AVF may create rows with an effective end date of Now . Whenever it does this it will set the circa effective flag on those rows to 0 meaning that these rows are definitely known to not be currently effective rows.

A temporal transaction may create a current version or a future version of an object which has a non 9999 effective end date. Because the version is not in past effective time the AVF will set its circa effective flag to 1. But as time goes by future versions may become current versions simply because of the passage of time. More to the point current versions may become past versions simply because of the passage of time. At the moment a current version slips into the past its circa effective flag is incorrect. That flag will still be set to 1.

Periodically an update statement should scan the database looking for rows with effective time periods in the past but with circa effective flags still set to 1. For each of those rows it will change their circa effective flag to 0. In this way the flag will remain approximately correct as a way to distinguish non current versions from current versions.

This means that queries looking for currently effective data should specify a circa effective flag of 1 as well as a current effective time period. Temporal indexes that use the circa effective flag instead of an effective begin or end date will have substituted a match predicate for a range predicate. The match predicate will perform much better than the range predicate and will start the search in the index at a node that will not have under it more than a small handful of rows whose effective time periods are in the past.

This aspect is for an improvement on previously described embodiments. The improvement is to add to the functionality of the previous embodiments the ability to manage data which exists in future assertion time.

The improvement requires the addition of one column to the canonical schema . As shown in that column is the row create date column and the result is a new canonical schema shown as the deferred assertion canonical schema .

With the baseline temporal model rows inserted into temporal tables begin to be asserted on the date they are physically inserted. This is also true of the AVF . With the AVF assertion dates cannot be specified on temporal transactions and a default assertion time period of Now 9999 is always used instead. However with the deferred assertion Asserted Versioning Framework as shown in and its use of the deferred assertion canonical schema temporal transactions may be submitted with an explicitly supplied future assertion begin date and rows may be stored in deferred assertion canonical schema temporal tables . These rows will fall into one of three new temporal categories as shown in future past future present or future future . This is because deferred assertions exist in future assertion time and may be statements about the effective time past present or future of the objects represented by those assertions.

Because rows may now exist in a temporal table whose assertion begin date is not the same as the date on which those rows were physically created we need the row create date column . This will always be the date on which each row is physically created. With this date we can always recreate exactly what the contents of the table were at any point in time. This ability is the functional equivalent of a physical logfile. A parallel ability is to provide a date and to retrieve only those rows which were currently asserted on that date. This latter ability is the functional equivalent of a semantic logfile a logfile of what the table asserted to be true at any point in time. It is because of deferred assertions that the physical logfile and semantic logfile functionalities are not identical.

The deferred assertion canonical schema temporal table is a temporal table that uses the deferred assertion canonical schema .

 def deferred assertion a row in a deferred assertion canonical schema temporal table with a future assertion begin date.

When the AVF D creates one or more future assertions as a result of a deferred transaction those rows will have future assertion time periods. Those rows will be physically part of the temporal table than contains all other past present and future assertions for the same object. As previously explained rows with past assertion time periods are not currently asserted to make true statements. They are merely records of statements we once asserted were true.

As for these rows with future assertion time periods they too are not currently asserted to make true statements. If enough time passes and these rows are still in their tables and their assertion time periods become current because of the passage of time then at that time they will become currently asserted. But until then they are just a record of what we might eventually come to assert are true statements.

Deferred transactions may specify any assertion begin date. Some transactions may be given an assertion begin date that is close enough to the present moment that the business will let the deferred assertions they create become current assertions simply by the passage of time. These deferred transactions correspond to transactions that would otherwise be collected together and applied at the end of the day or perhaps at the end of the week. We will say that such deferred assertions exist in near future assertion time.

 def near future assertion time assertion time periods that are close enough to the present moment that the authors of the deferred transactions that created them are willing to let those deferred assertions become current simply by means of the passage of time.

Other transactions may be given an assertion begin date that is in the distant future for example a date several decades from now. The reason for doing this is to avoid the possibility that these assertions might become current if they are ignored or forgotten for long enough. Consequently these are assertions that will not become current in any timeframe meaningful to a business unless explicit action is taken to move them closer in assertion time to the present moment. We will say that such deferred assertions exist in far future assertion time.

 def far future assertion time assertion time periods that are far enough away from the present moment that they will not become current assertions unless or until explicit action is taken to change their assertion time periods to time periods in near future assertion time.

One way of looking at rows with future assertion time periods is to consider a temporal database which does not manage such rows. This might be a temporal database of canonical schema temporal tables managed by the AVF . Or it might be a temporal database from the prior art such as one managed by Oracle 11 g and its Workspace Manager.

With such databases as with conventional databases we often write transactions that we do not intend to apply to the database right away. Sometimes we intend to apply these transactions in the near future perhaps at the end of the business day. The collections of these near future transactions are often called batch transaction datasets or batch tables . But until they are submitted to the DBMS and applied to their target tables the rows they contain are statements which are not yet currently asserted in our databases.

With the AVF D and its deferred assertions those transactions can be applied right away and will not become currently asserted until the assertion begin date associated with them becomes current. By this means this invention eliminates the need to manage external datasets which are collections of written but not yet applied transactions. It avoids potential bottlenecks that might otherwise be encountered when a very large number of transactions residing in such external datasets must be added to the database at the same time.

At other times we write transactions that we do not intend to apply to the database until a substantial amount of time has passed for example weeks or months. We keep this data in a collection of tables separate from production databases. Sometimes we call these separate collections of data a sandbox area. When we use this term our intention is usually to play around with the data perhaps to try to develop a new bill of materials for an improved version of a product. If we are successful and our work is approved we will then move the data from the sandbox into the production bill of materials table.

But with the AVF D and its deferred assertions that sandbox bill of materials can exist alongside the real bills of materials in the production bill of materials table. By this means this invention eliminates the need to manage sandboxes of data.

There is another reason we write transactions that we do not intend to apply to the database until a substantial amount of time has passed. It is to accumulate a collection of data from multiple sources. When the first components of the data we need arrive we start to build the transactions that we will eventually apply to the database. But additional components are needed before those transactions are complete. Eventually when all the components have arrived and when all have been combined into complete insert update and delete transactions we can apply those transactions to the production database.

In such cases we do not tend to call the physical datasets in which we accumulate and build our transactions sandboxes or batch transaction tables . More commonly we call them staging areas or pending tables places where we get ready for going to production.

But regardless of what we call them these are all physical objects external to the database tables that they will unless discarded eventually update. In all these cases the AVF D eliminates the need to manage these external physical objects by permitting us to store batched transactions sandbox data and staging area data in the same tables as the production data we currently assert as data which makes true statements about the objects represented in those tables. In eliminating these external datasets this invention eliminates the cost of managing them the latency involved in getting approved data from them into production tables and the bottlenecks that may arise when large volumes of such data are approved all at once.

The series of steps by which the AVF D manages temporal transactions and the data in extended canonical schema tables which result from those transactions is the same series of steps by which the AVF manages temporal transactions and the data in standard canonical schema tables which result from those transactions except that the AVF D manages temporal transactions that may specify future assertion time periods and also manages the future assertions called deferred assertions that result from them.

This step is identical to the step which the AVF carries out when processing a temporal insert transaction except that for the AVF D an assertion date may be specified on the transaction. If it is the AVF D checks that it is a future date.

We again emphasize that although dates are being used to provide examples for this patent application in another embodiment these dates might be timestamps or any other datatype that expresses points in time.

These steps are identical to the steps and which the AVF carries out when processing a temporal insert transaction except that the AVF D will accept a future assertion begin date specified on the transaction. If one is supplied it will assign the transaction the assertion time period with that date as its begin date and 9999 as its end date. Otherwise the AVF D will assign the transaction a Now 9999 assertion time period.

This step is identical to the step which the AVF carries out when processing a temporal insert transaction.

Both the AVF and the AVF D search a two dimensional target space and compare two dimensional occupied spaces to that target space. And for both of them the target space always extends along its assertion time axis to 9999 the latest point in time the DBMS can represent. For the AVF the target space always begins along its assertion time axis at Now i.e. at the moment in time at which the transaction is being processed. But for the AVF D when an assertion begin date is supplied on a transaction the target space will begin along its assertion time axis at some future point in time. However for both the AVF and the AVF D the target space always begins along its assertion time axis at the point in time specified by the assertion begin date of the transaction.

In a temporal database whose temporal tables are canonical schema temporal tables there will be no occupied spaces that begin along their assertion time axis in the future. But in a temporal table whose temporal tables are deferred assertion canonical tables there may be rows whose occupied spaces begin along their assertion time axis in the future.

Nonetheless a target space is a target space and an occupied space is an occupied space. And so the means by which the AVF matches occupied spaces to target spaces is the same means by which the AVF D matches occupied spaces to target spaces.

This step is identical to the step which the AVF carries out when processing a temporal insert transaction.

This step is identical to the step which the AVF carries out when processing a temporal insert transaction.

Note that if these rows were contained in a canonical schema temporal table there would be no row create date and no need for one. Because of the rules by which the AVF processes temporal transactions the assertion begin date of all rows in tables is the date on which those rows are physically created. But as the second row shown in illustrates in tables the AVF D may create rows whose assertion begin dates are later than the dates on which those rows are physically created.

The first row shown in began to assert on June 2008 that from that date up to February 2012 our company had a client C whose name was Jones. The second row shown in asserts nothing at all when it is first created. But if it is not updated or deleted then beginning on March 2012 it will become a current assertion on that date stating that client C whose name is Jones is re instated beginning on September 2012 and will remain in effect until further notice.

The first row shown in began to assert on January 2011 that throughout 2011 policy P is an HMO policy with a thirty dollar copay amount. The temporal referential integrity constraint for this row is satisfied by the first row shown in

The second row shown in asserts nothing at all when it is first created. But if it is not updated or deleted then beginning on July 2012 it will become a current assertion stating that throughout 2013 the policy will be a PPO policy with a fifty dollar copay amount. The temporal referential integrity constraint for this row is satisfied by the second row shown in

These steps are identical to the steps and which the AVF carries out when processing a temporal update transaction except that for the AVF D an assertion begin date may be specified on the transaction. If it is the AVF D checks that it is a future date.

These steps are identical to the steps and which the AVF carries out when processing a temporal update transaction.

This step is identical to the step which the AVF carries out when processing a temporal update transaction. It is interesting to note however that one of the ways in which a TRI check can fail in a temporal database managed by the AVF D and consisting of deferred assertion canonical schema temporal tables is not possible in a temporal database managed by the AVF and consisting of canonical schema temporal tables . For when deferred assertions may exist in temporal tables it is possible that a TRI check will fail because the parent occupied space begins at a later point along the assertion time axis than does the target space of the transaction. In other words in such a situation there may be a set of rows with an OID that matches the TFK on a transaction and whose effective time periods fully include the effective time period on the transaction but a set of rows at least one of which will not have an assertion begin date equal to or earlier than the assertion begin date of the transaction.

This step is identical to the step which the AVF carries out when processing a temporal update transaction. But there is an interesting point of difference in the data that is managed.

Using the AVF to withdraw a row is to change its assertion end date to Now i.e. to the point in time at which the transaction is being processed. Semantically this means that from Now on the withdrawn row will no longer be asserted as making a true statement about the object it represents.

However using the AVF D to withdraw a row is to change its assertion end date to the assertion begin date specified on the transaction. Since if specified that date is a future date this means that until that future date becomes current the withdrawn row will remain currently asserted. It will retain its status as a row which we claim is making a true statement.

But in spite of this difference the AVF and the AVF D use the same process to withdraw a row. In both cases the assertion begin date specified on the temporal transaction is used as the assertion end date for the withdrawal.

A temporal update whether deferred or not will always result in the AVF D changing the assertion end date of the row or rows within the target space of the transaction to the assertion begin date of the transaction. When a temporal update is not a deferred transaction that assertion date is the value of Now . And so as soon as the transaction is complete the row or rows so updated will have been withdrawn into past assertion time.

But when a temporal update is a deferred transaction that assertion date is a future date. And so as soon as the transaction is complete the row or rows so updated will remain in current assertion time but will be in an assertion time period with a definite non 9999 end date.

Just as rows with past assertion time periods cannot be the target of temporal update or temporal delete transactions the AVF D will manage all other rows with closed assertion time periods in the same way. We will say that all rows with closed assertion time periods are locked from transactions with an earlier transaction assertion date.

 def locked a row in a temporal table is locked if and only if it cannot be the target of any temporal transaction.

When the target of a deferred update transaction is a row in current assertion time the result of the transaction is that the target row takes on a locked current assertion time period. But a deferred update transaction may have as a target another deferred assertion. When it does the result of the transaction is that the target row takes on a locked future assertion time period.

It follows as a corollary that temporal update and delete transactions whether or not deferred can only have unlocked rows as their targets.

It is necessary to lock rows with closed current assertion time periods and closed future assertion time periods because this locking is a serialization mechanism. Conventional update or delete transactions are applied to the state of the database current when those transactions are applied. Non deferred temporal update or delete transactions are also applied to the state of the database current when those transactions are applied.

But deferred temporal update or delete transactions leave their target rows in either current or future assertion time. And so if those target rows could by means of later transactions be again temporally updated or be temporally deleted that would alter the state of the database to which those original deferred transactions were applied. But because the semantic validity of update and delete transactions depends on the state of the database to which they are applied that cannot be allowed to happen. The way the AVF D prevents that from happening is by means of the non 9999 assertion end date on all rows temporally updated or temporally deleted by means of deferred transactions which the AVF D interprets as functionally equivalent to a lock on those rows.

These steps are identical to the steps and which the AVF carries out when processing a temporal update transaction keeping in mind that while the assertion begin date on a temporal transaction submitted to the AVF is always Now the assertion begin date on a temporal transaction submitted to the AVF D may be either Now or some future point of time.

As already noted all the physical updates and physical inserts required to complete a temporal update transaction are managed by the AVF D as an atomic and isolated unit of work. If any of those physical transactions fails the AVF D will direct the DBMS to undo any earlier physical transactions that are part of that unit of work.

Until September 2012 the database will continue to assert that the policy will have a copay amount of fifty dollars throughout 2013. And starting on May 2012 the second row shown in is locked and cannot be the target of any other temporal insert or temporal delete transaction.

No other rows in the target table were wholly or partially within the target space of the transaction and so the transaction was complete at that point in time. The atomic and isolated unit of work was complete and all DBMS locks used in the process were released.

In most cases deferred assertions are moved from a far future to a near future period of assertion time. Doing this will reflect a business decision in which rows in far future assertion time have been reviewed and a decision has been made to assert them. By bringing them into near future assertion time a possibly large and inter related group of such rows will then all become currently asserted at the same moment in time.

The physical update does destroy the information that when originally entered these rows were given an assertion begin date of 2093. In this embodiment of the management of deferred assertions our design philosophy is that until deferred assertions become current assertions they do not represent any statements that the business has committed itself to. For that reason we do not believe that it is important to preserve such changes made to never yet made assertions.

If no changes were made to the second row in then in one embodiment that row would remain with an assertion time period of Jul90 Jul93 . In that case some eighty years from now that row would contrary to all intentions and expectations become currently asserted. Also the third and fourth rows having been moved to the Jun12 9999 assertion time period also exist in the Jul90 Jul93 assertion time period. Those two rows are rows for policy P for the 2013 effective time period. But the second row is also a row representing the 2013 effective time period of the same policy and so if no changes were made to that row the result would be a TEI conflict.

For this reason the AVF D must either remove the second row from assertion time so that there is no TEI conflict or else block the move. If the move is blocked then the AVF D will return an error message. In that case before the third and fourth rows could be moved the second row would have to be removed from its earlier assertion time period. If the move is not blocked then the move will cross over the second row thereby introducing the third and fourth rows into the assertion period of the second row creating a TEI conflict. To avoid the conflict whenever such a move does cross over another deferred assertion for the same object in the same or in overlapping effective time periods the row or rows crossed over will have their assertion end dates set to the near future assertion time which is also being used as the assertion begin dates of the rows doing the crossing over . The result is always to place the crossed over rows into negative assertion time.

In this example when the third and fourth rows have been moved by being given a June 2012 assertion begin date the second row is placed into negative assertion time by being given that same date as its assertion end date. That second row then exists in the assertion time period of Jul90 Jun12 i.e. in no assertion time period at all. The TEI conflict has been avoided.

 def negative assertion time period an assertion time period whose end date is earlier than its begin date created in the process of moving later deferred assertions for the same object and effective time period across the assertion time period of the row. This row could be deleted.

In the example just reviewed we chose to currently assert the statements that policy P had a forty dollar copay in the first half of 2013 and a fifty dollar copay in the second half of the year. But the earlier deferred assertion stated that P had a fifty dollar copay throughout all of 2013. If the business had decided to make that assertion represented by the second row current rather than the assertions made by the third and fourth rows how would that have been done 

In one embodiment of the AVF D nothing would have been done. The later deferred assertions would remain unaffected. In another embodiment the same process would be used. In that case the result would be the table shown in . The second row would become currently asserted and the third and fourth rows would be moved into negative assertion time.

Finally we note that throughout the management of these far future deferred assertions TRI constraints have remained satisfied. As shows the client referenced by the TFK of these policy rows was asserted to exist throughout the 2013 effective time period starting on March 2012.

This aspect is for an improvement on previous embodiments. The improvement is to substitute an approximately accurate match predicate for a range predicate.

We will not provide figures to illustrate the use of the match predicate but it constitutes a modification to the deferred assertion canonical schema . The match predicate is based on a column we call a circa assertion flag. The column can take on one of two values e.g. 0 and 1 .

The circa assertion flag works for assertion time exactly like the circa effective flag works for effective time. It is used with the deferred assertion canonical schema because it is only when deferred assertions may exist in a temporal table that we can have assertions in future time which may because of the passage of time become past assertions and assertions in current time which have a non 9999 assertion end date and therefore may become past assertions. This is the precise situation that parallels the process in which a row currently in effect may because of the passage of time become a row in past effective time. In both cases a periodic update process must scan the database and correct the circa flags. In addition the AVF can update the circa flag whenever an assertion end date is set to Now . In both cases specifying the circa flag as well as the time period in a query will allow indexes that use the circa flag instead of the time period to perform a more efficient search of their index trees.

Two foundational elements of the systems and methods described herein are the use of canonical schemas and the use of temporal metadata.

In some embodiments canonical schemas may restrict object identifiers to surrogate valued single columns. But in other embodiments object identifiers in canonical schemas may comprise multiple columns some or all of which do not use surrogate values.

In some embodiments canonical schemas may express time periods by means of one column to indicate the first clock tick in a time period or the first clock tick before the beginning of the time period and a second column to indicate the last clock tick in a time period or the next clock tick after that last clock tick . But in other embodiments time periods may be represented by single columns which use time period datatypes recently made available by some DBMS vendors. Here a clock tick is referenced as a measurement of time but any other suitable measurements of time may also be used.

In some embodiments canonical schemas may use as primary keys the combination of an object identifier an effective time period and an assertion time period. But in other embodiments object identifiers and time periods may be retained as non primary key data and primary keys may be created from one or more other columns that uniquely identify each row.

In some embodiments canonical schemas are used as the schemas for tables. In these embodiments the tables which use canonical schemas are canonical tables. In other embodiments canonical schemas are used as the schemas for the physical files which persist the data in tables. In these embodiments the physical files are canonical files and the tables whose data is persisted in canonical files are canonically supported tables.

One use of temporal metadata is to generate temporal tables from precursor tables. In one embodiment of the systems and methods described herein the precursor tables are restricted to being non temporal tables and the generated temporal tables are restricted to being canonical tables.

In another embodiment described below the precursor tables may also be uni temporal tables or bitemporal tables and the generated tables may also be non canonical tables. If the precursor tables are uni temporal tables they may be either uni temporal assertion time tables or uni temporal effective time tables both defined above. We note that above uni temporal effective time tables are called uni temporal version tables . If the generated tables are non canonical tables they may be uni temporal tables or bitemporal tables.

A second use of temporal metadata is to manage temporal tables. By using canonical tables as these temporal tables all the transactions and queries which appear to update and retrieve data from non temporal tables uni temporal tables or bitemporal tables can be managed with the same set of code thus consolidating and simplifying the codebase used to manage these types of tables whether that codebase be internal to or external to a DBMS.

Specifically by using canonical schemas entity integrity can be supported as a special case of temporal entity integrity referential integrity can be supported as a special case of temporal referential integrity and the otherwise serious impedance mismatch problems of managing referential relationships between different kinds of tables may thus be significantly reduced or eliminated.

A third use of temporal metadata is to control the user interface at which insert update and delete transactions are submitted and at which queries to retrieve data are also submitted. In a preferred embodiment the user interface is controlled for queries by presenting at that interface the tables which in one embodiment constitute otherwise identical non temporal tables or otherwise identical tables. These and tables in many embodiments are created and managed as views defined by means of CREATE VIEW statements or similar DDL Data Definition Language . otherwise identical tables are a proper superset of otherwise identical non temporal tables because otherwise identical tables may or may not be non temporal tables.

In a preferred embodiment the user interface is controlled for maintenance transactions by the use of Instead Of Trigger SQL which allows the user to write transactions against or tables and which then translates that SQL into physical transactions against the canonical tables corresponding to the or tables.

We note that a physical transaction was defined above as a SQL insert update or delete transaction which the AVF submits to a DBMS . Hereinafter we generalize the term physical transaction to mean a SQL insert update or delete transaction which the systems and methods described herein submit to a DBMS .

By controlling the user interface in this manner for both maintenance transactions and for queries the systems and methods described herein provide full temporal upward compatibility for any and all maintenance transactions and queries written against precursor tables.

In another embodiment as explained below temporal tables do not use canonical schemas. Instead their data is persisted in physical structures called canonical files . In this embodiment the user interface is controlled by providing canonical support by means of these canonical files to tables which are schema isomorphic and content isomorphic to the precursor tables from which they are generated.

Two tables either or both of which may be a view are schema isomorphic if and only if they have i the same table view name ii the same identically named and identically defined columns iii the same columns comprising their respective primary keys and iv the same columns comprising their respective foreign keys. Thus and otherwise identical tables are schema isomorphic to the precursor tables of the canonical tables for which they are otherwise identical tables.

Two tables either or both of which may be a view are content isomorphic if and only if at each moment in time they contain i all and only the same rows ii all and only the same columns and iii identical values in corresponding columns of corresponding rows.

In another aspect of this embodiment the generated tables may not be simply isomorphic to but may be actually physically identical to their precursor tables. As will be apparent to one skilled in the art this aspect of this embodiment supports the implementation of full bitemporal functionality on all tables in a database without altering those tables in any way. Temporal upward compatibility in this aspect of this embodiment is automatically provided because at the level of DBMS tables transactions against them and queries against them nothing has changed.

Additional metadata not included in embodiments described herein include i column sequence ii column datatype length scale default values and nullability options iii code page e.g. 437 ASCII 037 EBCIDIC iv metadata for non unique indexes and v other table or column constraints such as the level of temporal granularity at which time periods are defined and domain constraints such as enforce WEEK NBR smallint must be between 1 and 52 .

It will be apparent to one skilled in the art how this additional metadata may be added to the temporal metadata defined in tables and .

The name above each box in is the name of the entity and will unless overridden become the name of the table created from it. Primary key columns are shown inside each box and above the line internal to each box and are underlined. Foreign key columns have an fk tag and are italicized. Names below the line internal to each box each represent a non primary key column of the entity table.

Relationships are shown by arrows from a parent table to a child table. All relationship are one to many relationships in which the relationship is optional for the parent table and required for the child table except in the case of the relationship from the Table Metadata table to the Business Key Column Metadata table from the table to the Temporal Unique Identifier Metadata table and from the Temporal Foreign Key Metadata table to the Temporal Foreign Key Column Metadata table. In these three cases the relationship is also required for the parent table.

A temporal foreign key may be defined as the column or columns in a child bitemporal table which references the object identifier of the one or more rows in a parent bitemporal table each of whose rows has an assertion time period that fully includes the assertion time period of the child row containing the temporal foreign key and the logical union of the effective time periods of whose rows form a continuous period of effective time that fully includes the effective time period of the child row containing the temporal foreign key. We note that these bitemporal tables may or may not be canonical tables.

The interpretation of these metadata tables is as follows Database Metadata this table contains such preliminary data model metadata as the DBMS and release. If the preliminary data model is a logical data model it is the DBMS and release of the physical data model that a data modeling tool such as Erwin will generate from it. If the preliminary data model is a physical data model it is the DBMS and release for which that physical data model is valid. In all cases metadata is applied to a physical data model in order to generate a temporal database.

The columns prelim data model info and target db info are placeholders for metadata information such as the DDL dialects of the precursor tables and the generated tables target tablespace definitions and partitioning definitions.

As an example of additional target database temporal metadata consider that a database can have multiple owners or qualifiers. These are sometimes called database schemas but this disclosure reserves the term schema to refer to a table definition. For example a database DB001 may have owners qualifiers CDB123 and XDB456 for different tables COWN123.Customer and XOWN456.Customer. These tables may be in the same DB001 database.

Another target database issue that would require additional temporal metadata is that databases are often on separate servers. In addition owners qualifiers are usually defined within a database but may also be in different databases.

Table Metadata this table contains metadata for each table to be generated from the combination of a precursor table in a preliminary data model and temporal metadata.

For each precursor table prcrsr tbl nm is the name of the precursor table in the preliminary data model. prcrsr tbl typ indicates the type of the precursor table which is one of the following i non temporal ii bitemporal iii effective time or iv assertion time. Precursor tables are all non canonical tables.

For each generated table gen tbl nm is the name of the generated canonical table in the target database and gen tbl typ indicates the type of the generated table which is one of the following i temporally enabled canonical ii bitemporal canonical iii effective time canonical iv assertion time canonical v bitemporal non canonical vi effective time non canonical and vii assertion time non canonical.

A temporally enabled dependent table is a table or view that appears to contain non temporal data but whose data is in fact persisted in a canonical table. A temporally enabled dependent table is a otherwise identical non temporal table.

A temporally enabled canonical table is a canonical table for which the systems and methods described herein are able to define and manage a otherwise identical non temporal table which is a temporally enabled dependent table.

A bitemporal dependent table is a table or view that appears to contain bitemporal data but whose data is in fact persisted in a canonical table. A bitemporal dependent table is a otherwise identical table.

A bitemporal canonical table is a canonical table for which the systems and methods described herein are able to define and manage a otherwise identical table which is a bitemporal dependent table.

An effective time dependent table is a table or view that appears to contain effective time data but whose data is in fact persisted in a canonical table. An effective time dependent table is a otherwise identical table.

An effective time canonical table is a canonical table for which the systems and methods described herein are able to define and manage a otherwise identical table which is an effective time dependent table.

An assertion time dependent table is a table or view that appears to contain assertion time data but whose data is in fact persisted in a canonical table. An assertion time dependent table is a otherwise identical table.

An assertion time canonical table is a canonical table for which the systems and methods described herein are able to define and manage a otherwise identical table which is an assertion time dependent table.

A bitemporal non canonical table is a bitemporal table which persists its own data and is not a otherwise identical table to a canonical table.

An effective time non canonical table is an effective time table which persists its own data and is not a otherwise identical table to a canonical table.

An assertion time non canonical table is an assertion time table which persists its own data and is not a otherwise identical table to a canonical table.

For each generated table gen tbl oid typ indicates whether its object identifier is i a system generated surrogate valued single column indicated for example by means of the value sk or ii the business key of the generated table indicated for example by means of the value bk .

If the object identifier is a system generated surrogate valued single column it is generated and managed by the systems and methods described herein. If the object identifier is the business key then whether or not it is surrogate valued it takes on values supplied by the transactions that populate the database. In other embodiments object identifiers which are not business keys and which are generated and managed by the systems and methods described herein may consist of more than one column.

For each generated table gen tbl pk typ indicates whether the PK of the table is also the temporal unique identifier of the table. If it is not then in one embodiment values for that PK are supplied on transactions which create and maintain the data in the table and in the embodiment which includes temporal metadata table gen tbl sk pk col nm provides the name of that column. In another embodiment the values for a PK which is not a temporal unique identifier may be supplied by the systems and methods described herein.

A row in the Table Metadata table represents one generated table and also the one precursor table from which it is generated.

Business Key Column Metadata this table contains metadata for each generated table that indicates the column or columns which make up its business key. As described above the business key of a generated table is identical to the primary key of that table s precursor table with temporal foreign keys being substituted for any foreign keys in the primary key of the precursor table.

Business key columns in the generated table may have different column names than the names of the corresponding columns in the precursor table. bk col nm indicates the name of each business key column. The definition of the precursor table in the preliminary data model supplies the information about the corresponding primary key columns including their names and datatypes.

Temporal Foreign Key Metadata this table contains metadata for each temporal foreign key TFK to be generated from the preliminary data model together with the temporal metadata. Minimum and maximum cardinality are determined from the corresponding precursor physical table definitions and are stored in the columns min card and max card respectively for use in managing temporal data. The option on delete transactions to block deletes or cascade deletes or set foreign key occurrences in child tables to null is also determined from the corresponding precursor physical table definitions and is stored in the column del rule.

The primary key of the TFK Metadata table is comprised of two foreign keys to the Table Metadata table together with a sequence number. One of the foreign keys indicates the parent table for the TFK which is the table pointed to by the TFK. The other foreign key indicates the child table for the TFK which is the table that contains the TFK itself. The sequence number tfk seq nbr is used to sequence the TFKs for each child table in the same sequence in which the corresponding FKs are sequenced in the associated precursor table.

Temporal Foreign Key Column Metadata this table contains metadata for each column of each TFK of each generated table. The name of the column is contained in tfk col nm. If multiple columns make up the temporal foreign key tfk col seq nbr determines the sequence of those columns.

The primary key of this table consists of a foreign key to the TFK Metadata table together with tfk col seq nbr which is a sequence number. This sequence number is used to insure that the columns which make up the TFK occur in the same sequence as their occurrence in object identifiers in their parent tables. The column tfk col nm contains the name of each TFK column. The sequence of FKs in precursor tables and of columns within FKs and the names of those columns is part of the information provided by the physical table definition of the precursor table which is part of the preliminary data model.

If a time period is represented in a precursor table by a single column with a time period datatype then the name of that column is indicated by tp one col nm. If a time period is represented in a precursor table by a begin and end point in time then the names of those columns are indicated by respectively tp from col nm and tp to col nm. If a time period is represented in a precursor table by only a begin point in time then the systems and methods described herein use the begin point in time of the chronologically next row for the same object to determine the end point in time of the row and if there is none uses 9999 as that end point in time.

As stated above 9999 represents the latest point in time at the chosen level of granularity that a specific DBMS can recognize and manage. In other embodiments nulls or any other acceptable values may be used instead.

The column tp open closed ind indicates whether or not each point in time is included in the time period. In this disclosure all examples used the closed open convention in which the begin point in time is included in the time period but the end point in time is the next point in time following the last point in time in the time period. 

If the precursor table is an effective time table then it has one row in the Precursor Time Period Metadata table and its tp typ is effective . If the precursor table is a bitemporal table then it has two rows in the Precursor Time Period Metadata table. The tp typ of one of those rows is effective and the tp typ of the other of those rows is assertion . With this information the software is able to generate any of the generated table types gen tbl typ from non canonical temporal tables as well as from non temporal tables.

For example as will be clear to one skilled in the art if so directed by the temporal metadata software utilizing the systems and methods described herein may generate an effective time table from a precursor table and the temporal metadata. In that case based on a gen tbl typ of effective in the Table Metadata table the previously described algorithm or any equivalent algorithm would skip step of that algorithm or its equivalent step.

Furthermore a temporally enabled non temporal table will be generated if all steps of that algorithm are included. This is because a temporally enabled non temporal table is a canonical table which has a dependent dynamic view populated by all and only those rows which are current in effective time and in assertion time. If the precursor table is a non temporal table then this view is identical in name to that table and is column for column and column name for column name identical to it. If the precursor table is a temporal table then the view is identical to it in this manner except that the one or two time periods of the precursor table are included in the otherwise identical dependent table view.

Here the precursor temporal table of a canonical table and the otherwise identical table of that same canonical table are schema isomorphic to one another. Furthermore the precursor non temporal table of a canonical table and the otherwise identical non temporal table of that same canonical table are schema isomorphic to one another.

In embodiments utilizing the systems and methods described herein and provided by DBMS vendors the temporal metadata described herein may be defined by means of extensions to SQL DDL Data Definition Language and may be stored in data structures internal to a DBMS.

A row in the Precursor Time Period Metadata table represents one time period in a precursor table. When a generated table is generated from a uni temporal or bitemporal precursor table this establishes the correspondence of a precursor time period with either an effective time period or an assertion time period in the generated table.

These precursor tables may or may not physically exist. It is their physical table definitions provided for example in a form specific to a data modeling tool or directly in SQL DDL Data Definition Language that is the starting point for the creation of generated tables.

TFKs like FKs exist in child tables and point to parent tables. Because a TFK is an object identifier and not a complete temporal unique identifier there may be several rows in the parent table which have the indicated object identifier. Sometimes a single parent row may have time periods which cause it to satisfy temporal referential integrity dependencies. At other times it may require several parent rows to satisfy the TRI dependency from a single child row.

We have defined a TFK to reference an episode of the object whose object identifier value it matches. We said above that episodes are the parent managed objects in a temporal referential integrity relationship. So a TFK relationship is from a parent episode to zero one or more child rows. If the relationship is optional for the child table then the TFK defined for it is nullable and otherwise not.

With this process the systems and methods described herein create generated tables from precursor tables under the direction of the metadata in the and metadata tables.

Many of the figures in this specification contain sample database tables. The top row of every table contains the column names of the columns of the table. Primary key columns are underlined and usually appear left most. Foreign key columns are italicized. Non key columns are neither underlined nor italicized.

We will sometimes use the phrase temporally enabled table in place of the longer phrase temporally enabled non temporal table .

A temporal primary key may be defined as a primary key comprising an object identifier an effective time period and an assertion time period.

In some embodiments canonical schemas may represent one or more temporal primary keys other than by means of time periods represented by begin and end points in time or by means of single column surrogate valued object identifiers.

In which shows a canonical schema table the temporal primary key includes an object identifier an effective begin date and an assertion begin date . The effective begin date represents an effective time period the assertion begin date represents an assertion time period.

However in some embodiments single column time period datatypes may be used to represent effective time periods and assertion time periods. It follows that for example in the PK shown there is another embodiment of a temporal PK . The PK includes a single column effective time period and a single column assertion time period .

Further embodiments of temporal PKs are also possible because other embodiments of object identifiers are possible. For example as previously stated i n another embodiment the object identifier might consist of more than one column. 

This concept is illustrated in where the object identifier consists of three columns. The first two columns are a temporal foreign key TFK referencing a specific customer in the Customer G table shown in . The third column is a TFK referencing a specific salesperson in the Salesperson G table shown in . The object identifier of the associative table shown in is formed by combining these two TFKs. In this example the object designated by the object identifier is a relationship between customer C123 in the southwest region and salesperson .

Thus temporal PKs of canonical schemas may or may not use single column surrogate valued object identifiers. The temporal PKs of canonical schemas may be multi column may include TFKs and may include time periods represented in different ways.

We distinguished and canonical schemas above. The next sections refer to canonical schemas and describe them. However the following descriptions and concepts also apply to and canonical schemas.

In an alternative embodiment the PKs of canonical or non canonical temporal tables do not have to be temporal PKs. Instead temporal PKs may be replaced as PKs by any other column or columns surrogate valued or not that will be a unique identifier of a row in a temporal table the said column or columns comprising a non temporal PK illustrated in . However this replacement may occur only if i the PK uniquely identifies each row in the table and ii a temporal unique identifier is also present as a non PK column or set of columns in the table.

In some embodiments a temporal unique identifier may exist in a separate table and in a canonical table a pointer to the temporal unique identifier may be used instead of the temporal unique identifier itself. In general and as will be apparent to one skilled in the art any column or set of columns in any table may be moved to another table and replaced by a pointer to that column or set of columns.

A temporal unique identifier tui may be described as a unique identifier for a temporal table which includes i an object identifier ii a designation of an effective time period and iii a designation of an assertion time period. These designations may or may not be the time periods themselves. For example in earlier embodiments the begin date of each time period was used in a temporal unique identifier to designate the entire time period.

As shown in non PK temporal unique identifier may be described as a temporal unique identifier which is not used as a PK.

To be temporally unique i.e. to satisfy TEI a row in a temporal table must be the only row in the table anywhere within the two dimensional temporal extent defined by the assertion time period and the effective time period of that row which has that row s object identifier.

The use of temporal unique identifiers as PKs represents one embodiment of a canonical schema but implementation by means of PKs which are not temporal unique identifiers are also possible. For example shows a canonical schema table that has a non PK temporal unique identifier and that uses the surrogate valued column cust id as its non temporal PK. Metadata for this table is not shown but if it were the gen tbl pk typ column of the Table Metadata table would have a value of non tui indicating that the PK of this table is not the temporal unique identifier of the table.

In one aspect a temporal table must contain a temporal unique identifier but that identifier may or may not be the PK of the table. If the temporal unique identifier is not the PK of the table whatever is used as the PK must uniquely identify each row and a DBMS will then be able to enforce PK uniqueness entity integrity on it. The non PK temporal unique identifier may be used by the systems and methods described herein to enforce TEI and may also be used by those same systems and methods to enforce TRI.

In another embodiment canonical schemas may also be used for non temporal data and thus to present as maintainable and as queryable objects non temporal tables as well as temporal tables.

A non temporal table whose data is persisted in a canonical table is a temporally enabled non temporal dependent table. It is schema isomorphic with the precursor table of the canonical table which persists its data and also with the otherwise identical non temporal table which is dependent on it.

Temporal transactions that do not specify a time period and whose target table is a temporally enabled table are called temporally enabled transactions. 

Regarding the phrase as maintainable and as queryable objects canonical tables are physical tables and each of them is a bitemporal table. By supporting an effective time dependent table for example a canonical table provides temporal upward compatibility for maintenance transactions and for queries against that effective time dependent table. In one embodiment Instead Of Trigger SQL provides temporal upward compatibility for maintenance transactions and SQL views provide temporal upward compatibility for queries.

By managing non temporal tables as temporally enabled dependent tables the problem of temporal referential integrity relationships between non temporal and temporal tables is solved because both the temporally enabled canonical tables and the other canonical tables use the same canonical schema.

Another benefit of this integrated approach to managing temporally enabled and temporal tables is that entity integrity is automatically enforced on temporally enabled dependent tables by enforcing temporal entity integrity on their corresponding canonical tables and that referential integrity is automatically enforced on temporally enabled dependent tables by enforcing temporal referential integrity on their corresponding canonical tables. In this way the same set of code that manages temporal tables and their integrity constraints can be used to manage temporally enabled non temporal tables and their integrity constraints.

Above the notation Now is used to represent the moment in time at which a transaction physically commits. Hereinafter the notation Now represents a variable whose value at any point in time is that current point in time and the notation Now represents a constant whose value is the moment in time at which a transaction physically commits. However in embodiments which support future assertions against canonical or canonically supported tables temporal transactions and temporally enabled transactions may specify a future assertion time period when applied to those tables.

Now is a value assigned to the variable Now at the point in time at which a temporal transaction commits.

In embodiments which do not support future assertions temporal transactions cannot specify an assertion time period and a default assertion time period of Now 9999 is associated with these transactions.

Transactions on effective time dependent tables may include an explicit effective time period. However if they do not include an explicit effective time period the default value Now 9999 is used for the effective time period associated with the transaction.

In the case of non temporal tables implemented as temporally enabled dependent tables the default value Now 9999 is supplied for both the effective time period and the assertion time period. This is because neither effective time periods nor assertion time periods are defined for non temporal tables. Thus neither can appear on a transaction updating a non temporal table.

An effective time transaction may be defined as a transaction that may specify an effective time period. Effective time transactions may have as their targets either effective time dependent tables or bitemporal dependent tables. Effective time transactions may include an explicit assertion time period only in embodiments which support future assertions.

The otherwise identical table which is the target of an effective time transaction may be either an effective time dependent table or a bitemporal dependent table.

An effective time canonical table is a canonical table whose precursor table is an effective time table and therefore whose otherwise identical table is an effective time dependent table which is schema isomorphic to the said precursor table.

A bitemporal canonical table is a canonical table whose precursor table is a bitemporal table and therefore whose otherwise identical table is a bitemporal dependent table which is schema isomorphic to the said precursor table.

As described above by controlling the user interface at which insert update and delete transactions against dependent tables are accepted some embodiments of the software and methods described herein maintain a full bitemporal history of all modifications submitted at the user interface. This is because some embodiments i use otherwise identical dependent tables at the user interface to accept transactions and queries ii use canonical tables or canonically supported tables to persist the data submitted on those transactions and iii use temporal metadata to direct their enforcement of TEI and TRI.

A preferred embodiment of this user interface utilizes Instead Of SQL triggers but other embodiments such as temporal extensions to the SQL language now under development in the ANSI and ISO standards committees are also possible.

In this example temporal metadata defines needed relationships between components of the paired schemas e.g. paired with for both the Client and Policy tables. Here show a Policy table that is a referential integrity not a temporal referential integrity child table of FIG. s Client parent table . also show a Policy table that is a temporal referential integrity child table of FIG. s Client parent table .

The tables shown in these figures may not physically exist. But it will be apparent to one skilled in the art that as temporal entity integrity and temporal referential integrity are enforced on the tables shown in these figures entity integrity and referential integrity are automatically enforced on the corresponding tables.

The tables and are associated by means of temporal metadata. Furthermore the tables are associated by means of the same temporal metadata that enable the systems and methods described herein to create generated tables from precursor tables. The otherwise identical non temporal tables of are in one embodiment dynamic views defined on physically existing canonical tables. They are also schema isomorphic to the precursor tables from which the generated canonical tables are derived by means of the temporal metadata tables and .

Some details of the pairing of otherwise identical non temporal tables with the canonical tables that support them are shown in . shows a Database Metadata table that sets db id 23 for the database in which the Client G and Policy G tables will be generated as shown in .

The temporal metadata of this embodiment may be thought of as the semantic glue by which canonical tables can physically represent all types of temporal tables and also temporally enabled non temporal tables. This metadata glues canonical tables back to the precursor tables from which they are generated and forward to the otherwise identical tables which are dependent on them and in the case of temporally enabled tables to the otherwise identical non temporal tables which are dependent on them .

By means of this glue all temporal and temporally enabled data is persisted in tables which use the same canonical schema and consequently the constraints of TEI and TRI are applied to them and among them by means of code which does not have to distinguish among tables with different temporal schemas. In addition by means of this glue dependent tables are schema isomorphic and content isomorphic with their corresponding precursor tables thus providing temporal upward compatibility for those precursor tables and for the transactions and queries which may have already been written against them.

Returning to this figure shows the results of a temporally enabled insert transaction which on February 2009 specifies the row shown in the otherwise identical non temporal table i.e. insert values P C HMO 15 . Because no time periods are specified on temporally enabled transactions the two default time periods for the transaction i.e. the effective time period and the assertion time period are both Feb09 9999 . Prior to February 2009 the row shown in FIG. s otherwise identical non temporal table would not appear in that table. Specifically a query for a policy whose policy number is P would not return a result i.e. its result set would be empty. However during or after February 2009 a query for policy P would return a result e.g. a query for P s copay amount would return a value of 15.

Still referring to the non temporal update of January 2010 specifies a change to the foreign key column client nbr. By means of the temporal metadata referred to above the systems and methods described herein will know that the corresponding column in the canonical table is client oid. Just as a conventional FK references a PK in a parent non temporal table a TFK references an object identifier in a parent temporal table. Here the client nbr C specified on the update transaction matches obj id in the canonical schema Client table from . That row i.e. the last row shown in the Client table in is a single row episode which satisfies the TRI dependency from the update transaction. Thus the update goes through and now querying the table s client oid column indicates that the policy s ownership has changed.

In other embodiments rows in canonical tables that have assertion time periods with an end point in time already in the past may be physically stored in a separate table. These and all rows with assertion time periods with an end point in time already in the past are rows that correspond to physically deleted rows in an otherwise identical non temporal table. These are rows that correspond to statements that we are no longer willing to assert.

Queries that wish to access these rows may be directed to that separate table. Queries that wish to access these rows and also rows whose assertion time periods are not entirely in the past may access a union of the two tables.

In other embodiments canonical schemas such as the or schemas may be used as schemas for the physical files in which the data in temporal tables is persisted. This embodiment may be referred to as a DBMS internals embodiment because the physical files or canonical files are normally accessible only from within the DBMS itself. What is accessible to DBAs Database Administrators and other users of a database are the tables and their data not those underlying files.

In a DBMS internals embodiment canonical files are used to persist the data in uni temporal tables and in bitemporal tables and may also be used to persist the data in non temporal tables. A canonical file may be for example a sequential file an indexed file a hashed access file a file used in a column oriented data storage scheme a comma delimited file or any other similar file as known in the art.

A canonically supported table can be defined as a table whose data is persisted in one or more canonical files. Thus an effective time table may be a canonically supported effective time table whether or not it is also an effective time table that is dependent on an effective time canonical table. An assertion time table may be a canonically supported assertion time table whether or not it is also an assertion time table that is dependent on an assertion time canonical table. A bitemporal table may be a canonically supported bitemporal table whether or not it is also a bitemporal table that is dependent on a bitemporal canonical table. A temporally enabled non temporal table may be a canonically supported temporally enabled non temporal table whether or not it is also a temporally enabled non temporal table that is dependent on a temporally enabled canonical table.

In another embodiment called a canonically visible embodiment temporal tables and temporally enabled tables are dependent on canonical tables i.e. tables which use canonical schemas. All of the temporal tables and temporally enabled tables shown in the figures of this disclosure are part of a canonically visible embodiment.

Canonical tables may also be canonically supported tables. Thus it follows that some embodiments may be both canonically visible embodiments and DBMS internals embodiments.

For example a database whose tables are not canonical tables may contain canonically supported effective time tables. These tables include an effective time period but not an assertion time period. The same database may contain canonically supported assertion time tables which include an assertion time period but not an effective time period. The same database may contain canonically supported bitemporal tables which include both time periods. However because all these types of tables are canonically supported tables the files which persist the data for each of these tables are canonical files and in all cases these canonical files contain both effective time periods and assertion time periods.

When non canonical canonically supported tables are generated from precursor tables which physically exist in a database the generated tables are both schema isomorphic and content isomorphic with their precursor tables. In one aspect they are in fact not just isomorphic with their precursor tables they are substantially identical to them. They are those same precursor tables with canonical support supplied by persisting their data in canonical files.

The use of canonical files provides an embodiment of the systems and methods described herein in which the generated tables are not required to be canonical tables. If canonically supported tables are not canonical tables then the systems and methods described herein provide a very low cost migration path to a database all of whose tables support the maintenance transactions and queries already described with reference to canonical tables. By supporting the transactions and queries described herein by means of canonical files instead of by means of canonical tables the tables in databases can remain unchanged even though the temporal and bitemporal functionality described herein is provided for some or all of those tables.

The data in canonically supported non temporal tables are persisted by means of canonical files. This means that neither effective time periods nor assertion time periods are columns in these canonically supported tables. Neither effective time periods nor assertion time periods may be specified on insert update or delete transactions against their dependent tables or in an aspect in which these tables are substantially identical to their dependent tables against these tables themselves. Instead the system supplies a default value for both time periods on all transactions against non temporal tables. In a preferred embodiment the default value is Now 9999 .

When a delete transaction is processed for an object the row representing that object may be physically or logically deleted from its canonically supported non temporal table. However that row in whatever form it exists in canonical files is not deleted in the canonical files which persist that data. Instead in those canonical files the deleted row is withdrawn not physically deleted i.e. it is given an assertion time end point of Now . The system also creates a copy of the withdrawn row which differs from it in having an effective time end point of Now and an assertion time period of Now 9999 .

In otherwise identical non temporal tables are shown together with the canonical tables on which they are in one aspect by means of a view definition based. The relationship of canonical files to canonically supported non temporal tables is similar to this relationship. In these figures if the views instead represented physical tables and the tables instead represented canonical files then these figures would illustrate how canonical files support temporal or temporally enabled tables.

Queries may be directly issued against canonically supported non temporal tables. The rows which appear in these tables are at all times all and only those rows current in both effective time and assertion time and so in a canonically supported non temporal table each object is represented by one and only one row. Thus in one embodiment canonically supported non temporal tables are both schema isomorphic and content isomorphic to their otherwise identical non temporal tables. In another embodiment canonically supported non temporal tables may be physically the same tables as their otherwise identical non temporal tables.

Two TFK relationships are illustrated in . TFKs like FKs exist in child tables and point to parent tables. Because a TFK is only an object identifier and not a complete temporal unique identifier there may be several rows in the parent table with the indicated object identifier. Sometimes a single parent row may have time periods which cause it to satisfy temporal referential integrity dependencies. But at other times it may require several parent rows to satisfy the TRI dependency from a single child row.

A TFK parent is an episode of the object whose object identifier value it matches. So a TFK relationship is from a parent episode to zero one or more child rows. If the relationship is optional for the child table then the TFK defined for it is nullable and otherwise not.

In one embodiment a TFK relationship to a dependent child row is always optional for episodes. In another embodiment metadata may be included which would specify whether a TFK relationship is optional or required for the parent episode.

Episode tables are illustrated in . In one aspect an episode table is entirely system maintained and users cannot write transactions against it. In this aspect an episode table may be internalized within a DBMS and not be visible either as a table in the database itself or as a table definition in the database catalog. However in another aspect if the Episode table is visible to users of the database then those users could write queries against it.

For example the first row in the Episode table in identifies an episode of policy P whose effective time period extends from January 2008 up to July 2008. It corresponds to the first row in the Policy table in . The episode is uniquely identified as episode for OID in the table named Policy AV. That episode begins on January 2008 in assertion time.

In this example only episodes where all constituent rows have assertion time periods ending in 9999 are represented. In this example the only rows with non 9999 assertion end dates are rows which are temporally deleted. Consequently those rows can no longer be modified and can no longer enter into TRI relationships. Thus they are semantically equivalent to rows in non temporal tables that have been physically deleted. Since the principal role for episodes is to assist in TRI checking rows which can no longer enter into TRI relationships can be safely ignored because their time is past.

Continuing the discussion of the second row in the Episode table begins in assertion time on July 2008. Its effective time period extends from July 2008 to January 2009 and the episode corresponds to the second row in the Policy table of . However during the assertion time period beginning on July 2008 the effective time period of the second Policy row is effective time contiguous with the effective time period of the first Policy row. The two Policy rows together therefore form a single episode. To represent this single episode in the effective time begin date of the second episode is moved back to the effective time begin date of the first row. This shift results in a second episode which overlaps with the first episode and which beginning on July 2008 covers the effective time period of January 2008 up to January 2009 that is the effective time period of the combination of the first and second episodes. In another embodiment the column epis asr per of the first row in may be set to Jan08 Jul08 as part of the transaction which creates the second row. In this embodiment episodes for the same object do not overlap.

In another embodiment this shift of episode effective time begin dates is not utilized and the episodes in an Episode table will correspond one for one to the episodes implemented by means of episode begin dates.

In embodiments which support future assertions rows may exist with non 9999 assertion end dates that are in the future. Rows with such end dates are not temporally deleted. We note that in discussions of figures prior to the term deferred assertion is used interchangeably with the term future assertion . In discussions of figures beginning with the term future assertion is used preferentially. The two terms are nonetheless synonymous.

An Episode table can also accommodate episodes of rows in future assertion time. This accommodation can occur because the creation of a row in future assertion time has the system lock any and all current assertion time rows for the same object which exist in at least one overlapping effective time clock tick.

A row in a canonical table is locked if and only if its assertion end date is a non 9999 value. Thus rows with assertion time periods entirely in the past are locked but other rows with non 9999 end date values may also be locked. Specifically as explained above locking is done in association with future assertions by setting the assertion end date of rows affected by a future assertion to the same value as the assertion begin date of the future assertion itself. This process of managing and using episodes is described in detail above in reference to and within the discussion of those figures.

The concept of an effective time initial row can be defined as for a given object identifier in a canonical bitemporal table a row whose effective time period is not contiguous with the effective time period of any effective time earlier row with the same object identifier that shares at least one assertion time clock tick with the said row.

A standard bitemporal table can be described as a bitemporal table which is not a canonically enabled table.

If episodes can be used to manage standard bitemporal tables then episodes are canonically agnostic in the sense that it does not matter whether they are defined on canonical or on non canonical bitemporal tables.

Episodes clearly can be used with any tables that utilize canonical schemas. It follows that they can be used in temporally enabled canonical tables uni temporal canonical tables and bitemporal canonical tables.

In embodiments which do not support future assertions assertion time periods cannot be specified on any transactions. In such embodiments transactions against temporally enabled non temporal tables can specify neither effective time periods nor assertion time periods. But in all embodiments both those that support future assertions and those that do not when a time period cannot be specified on a transaction the default value of Now 9999 is used.

Thus in both canonical tables and canonical files the rows created by all temporal and temporally enabled transactions include both time periods and thus support the use of episodes. Episodes work on all and only those rows on which both effective and assertion time periods appear but it does not matter whether the values for those time periods are explicitly specified on transactions or are default values and it does not matter whether those time periods appear on canonical tables or only in the canonical files of canonically supported tables.

In embodiments which support future assertions assertion time periods can be specified on transactions against all types of canonical tables and on transactions against non canonical bitemporal tables. This is because episodes are defined for specific objects on a two dimensional temporal space and effective time periods and assertion time periods together define such a two dimensional space.

It may appear however that episodes cannot be used with non canonical bitemporal tables because it may appear that non canonical bitemporal tables do not have the concept of an object and thus lack an object identifier.

But first of all an object is defined above as anything that can be distinguished from other instances of its type and that can change over time. And an OID is defined above as a unique identifier for an object. 

Next a temporal unique identifier is defined above as consisting of an object identifier an assertion time period and an effective time period. It follows that the component of the temporal unique identifier of a standard bitemporal table which is not either of the time periods is the object identifier for that table. It distinguishes the instance of the type represented by the table from all other instances. For example in a Customer standard bitemporal table the portion of the temporal unique identifier which uniquely identifies a customer and distinguishes that customer from all other customers is an object identifier or OID.

Given this definition of episode it will therefore be apparent to one skilled in the art that episodes may be defined on and managed on standard bitemporal tables canonical bitemporal tables or canonically supported bitemporal tables.

In another embodiment future assertions against standard bitemporal tables can be managed by the systems and methods described herein.

To support future assertions the tables to which they apply must contain both i an effective time period and an assertion time period and ii distinct from both time periods a column or other means of recording the point in time at which each row is physically created. The deferred assertion canonical schema shown in provides an example of a canonical schema which contains a column which is distinct from both time periods and which is used to record the point in time at which each row is physically created.

It therefore follows that any standard bitemporal table which records the point in time at which each row is physically created in a separate column from both time periods is one which may contain future assertions. Future assertions are thus canonically agnostic.

For any uni temporal or bitemporal table a column can be added to the table which will take on one of two values as described above and which may appear as a match predicate in an index defined on the table. So it will be apparent to one skilled in the art that match predicates as defined in this disclosure are canonically agnostic. That is they may be defined on tables which are neither canonical nor canonically supported.

In another embodiment the ability of the systems and methods described herein can be extended i to generate temporal databases from temporal as well as non temporal tables defined in a preliminary data model ii to generate temporal databases whose tables are neither canonical tables nor canonically supported tables and iii to generate temporal tables which are valid for databases managed by specific DBMSs.

As described above the systems and methods described herein can utilize an algorithm to generate a temporal database from a preliminary data model together with temporal metadata. The tables or entities in the preliminary data model are precursor tables. The temporal metadata in one embodiment is contained in the and metadata tables.

A business key in a temporal table was previously defined as consisting of columns that were not part of the PK of that table. However in embodiments where business keys can be object identifiers a business key can be defined less restrictively as the column or columns in a temporal table which correspond to the primary key columns of the precursor table for that temporal table.

As described above the systems and methods described herein can utilize an algorithm to generate a temporal database from a preliminary data model together with temporal metadata. In that embodiment the tables or entities in the preliminary data model are non temporal tables. The temporal metadata in that embodiment is contained in the and metadata tables. The tables generated in that embodiment are canonical tables.

But in another embodiment the metadata tables support the same functionality. This follows from the fact that the temporal metadata of metadata tables contains all the metadata in temporal metadata tables . This establishes that metadata fully supports the functionality described above and is therefore an extension of it.

Specifically the metadata table shown in associates a precursor table with the table generated from it. For example the column tbl nm identifies the precursor table the column temp tbl nm identifies the generated table. The Table Metadata shown in and does this with respectively the column prcrsr tbl nm and the column gen tbl nm.

The metadata table shown in specifies the parent and child tables for a temporal foreign key by means of respectively the column src tbl nm and the column tar tbl nm. The TFK Metadata table shown in and does this by means of the two FKs which are part of the PK of the TFK Metadata table.

The metadata table uses the column req fig to indicate whether or not the TFK is nullable. This is done in the metadata tables by determining the minimum and maximum cardinality from the physical table definition of the precursor table and storing this information in the columns min card and max card respectively of the TFK Metadata table uses the column del rule ind to indicate whether a delete when there is at least one child for the TFK should be i blocked ii continued with all child instances of the TFK set to null or iii cascaded down the chain of child instances. This information may also be determined from the physical table definition of the precursor table. It is stored in the column del rule of the table.

The metadata table shown in uses the column bus key col nm to indicate the column or columns which make up the business key of the temporal table indicated by the column tbl nm. If there are multiple columns in the business key they must occur in the same sequence as they do in the primary key of the precursor table. The Business Key Metadata table uses the column bk col seq nbr to establish the sequence of columns of the business key in the generated table.

The metadata table shown in maps temporal foreign key column names in a generated table tbl nm to the corresponding column names of the corresponding foreign key in the precursor table. The Temporal Foreign Key Metadata table uses the column tfk seq nbr to sequence temporal foreign keys in a generated table in the same sequence in which the corresponding foreign keys occur in the precursor table. The Temporal Foreign Key Column Metadata table uses the column tfk col seq nbr to sequence columns within TFKs.

Another embodiment extends the process of generating a temporal database from non temporal precursor tables in a preliminary data model so that the process also supports generating a temporal database from temporal precursor tables and also supports generating a temporal database whose generated tables include non canonical tables.

The systems and methods described herein in embodiments which use the metadata tables add the ability to generate temporal databases for specific DBMSs and specific current and future releases of those DBMSs. In addition these embodiments include support for precursor tables that are themselves uni temporal tables and for precursor tables that are themselves bitemporal tables. Finally support for generated tables that are non canonical uni temporal or bitemporal tables are also supported in these embodiments.

An example showing the process of generating a bitemporal Supplier G table from an effective time Supplier P table together with associated metadata will be described to illustrate the use of this temporal metadata.

With this process the systems and methods described herein create generated tables from precursor tables with the help of metadata tables. Metadata tables and provide the information needed to generate temporal tables and temporally enabled tables from tables which are themselves temporal or non temporal.

Step 1. For as many rows as there are in Table Metadata start building a CREATE TABLE statement or other DDL statement which defines a table to a DBMS. Begin by plugging in the value from the gen tbl nm column. As shown in the name of the generated table will be Supplier G.

Step 2. For each row in Table Metadata shown in define the object identifier oid type to be used in the generated tables. In this example the Supplier G table will use a surrogate valued single column as its oid. The object identifier type which is either sk surrogate key or bk business key is recorded in s gen tbl oid typ column.

The Supplier G oid column name will be supp sk id as indicated by the TUI Column Metadata table column tui col nm. The one or more columns making up the object identifier are those columns in the table that have both flags set to 0.

The Supplier G business key columns are the set of columns in sequence for db id 7 and tbl id 1 shown in the BK Column Metadata table in . The business key column names are stored in the column bk col nm and are snbr bk and eff tp. The column datatype of the column which does not represent a time period is taken from the physical table definition of the corresponding Supplier P precursor table. The column datatype of the column which represents the effective time period is in one embodiment always a time period datatype regardless of how the time period is represented in the precursor table.

Step 3. In Table Metadata the column gen tbl pk typ indicates whether or not the primary key of the generated table will be the temporal unique identifier tui of that table.

In this example the primary key for the generated table will be the temporal unique identifier. The object identifier of the temporal unique identifier will be a surrogate key with the column name supp sk id. This is the one column in the TUI Column Metadata table in both of whose flags are 0.

The Non Key Metadata table shown in completes the definitions of the remaining columns for the generated table. The column prcrsr col nm in this table is in fact redundant since the column nk seq nbr indicates the sequence of non key columns in the precursor table.

Step 4. The Precursor Time Period Metadata table identifies Supplier P as an effective time table. Supplier P is an effective time table in which a single column represents a time period by means of a begin point in time. That is indicated by a value in the column tp one col nm and by the corresponding nulls in the from and to column names. Finally the column tp open closed cnvntn indicates the convention used for the time period representation in the precursor table. In embodiments supported by this metadata table time periods in generated tables are represented in single columns with a time period datatype. In other embodiments additional metadata could be used to allow time periods to be represented in different ways in generated tables.

The Precursor Time Period Metadata table is used during the initial database conversion. It identifies the column or pair of columns which contain the source data which will be used to populate the effective time period in the generated table.

Step 5. The last step is to provide for temporal upward compatibility. All queries and all insert update and delete statements which work against the precursor table assuming there is a populated precursor table against which such SQL has already been written must work without modification against the generated table.

As for queries software utilizing the systems and methods described herein can be used to define and display a view over the generated table for example by means of a CREATE VIEW statement whose name is identical to the name of the precursor table.

In this view the temporal unique identifier of the generated table must be replaced by the primary key of the precursor table. In this view all temporal foreign keys if any must be replaced by the corresponding foreign keys in the precursor table. It will be apparent to one skilled in the art that the described metadata tables make it possible to do both these things.

Finally columns must be added to the view corresponding to the non key columns of the precursor table. The datatypes of these columns can be derived from the table definitions of the original precursor tables. The column names of these columns come from the prcrsr col nm column in Non Key Metadata .

Additionally in a preferred embodiment Instead Of Trigger SQL is utilized to maintain temporal upward compatibility for insert update and delete statements as previously described.

In another aspect the column target db info in Database Metadata can be used to tell software utilizing the systems and methods described herein what vendor specific and release specific type of database will be the target for the generated tables. With this information the software can modify a DBMS agnostic set of temporal table definitions to conform to the requirements of specific SQL dialects.

Utilizing the systems and methods described herein allow one skilled in the art to generate a temporal database from a precursor database plus temporal metadata. Generally the basic idea is to map precursor data structures onto generated data structures in a DBMS agnostic way and then to translate the DBMS agnostic SQL DDL into DDL appropriate for the specific target database.

In another embodiment the systems and methods described herein may be used as part of a solution to the schema evolution problem.

Schema evolution is a difficult problem and is being actively worked on in the computer science community. However as will be clear to one skilled in the art the systems and methods described herein may be useful in implementing a solution to the schema evolution problem. For example database table definitions such as CREATE TABLE statements or fragments thereof from which complete table definitions might be assembled may be stored as bitemporal data in the canonical schemas of the software and methods described herein. If they are then a bitemporal history of all changes to these table definitions will be available to the software that does implement a schema evolution solution.

By means of the systems and methods described herein the use of canonical schemas whether in database tables or in the physical files which persist the data in database tables simplifies the management of temporal data including the relationships of that temporal data to temporally enabled non temporal data. Systems and software utilizing the methods described herein do this by using a canonical bitemporal schema to store all uni temporal and bitemporal data and also to store temporally enabled non temporal data. Systems and software utilizing the methods described herein incorporate the enforcement of entity integrity and referential integrity which applies only to non temporal data as a special case of the enforcement of temporal entity integrity and temporal referential integrity which applies to both temporal data and temporally enabled non temporal data.

Using the systems and methods described herein when data appears to its users to have only one temporal dimension a default value for the other temporal dimension is added to the transactions which maintain that data before those transactions are applied to their target tables or and a view mechanism or similar mechanism is used to support queries against those tables that are aware of only the explicit temporal dimension of that data. If data appears to its users to have no temporal dimensions i.e. to be conventional current data then a default value for both temporal dimensions is added to transactions before they are applied to their target tables and a view mechanism or similar mechanism is used to support queries against those tables that assume that only current data is available to query.

The systems and methods described herein use temporal metadata to simplify the creation and management of canonical tables including temporally enabled non temporal tables and also the creation and management of non canonical tables. Temporal metadata makes it possible to generate canonical tables from non temporal tables and from non canonical temporal tables. For those enterprises who wish to convert non canonical tables into either uni temporal or bitemporal non canonical tables the temporal metadata of the systems and methods described herein also support that conversion.

By means of canonical schemas conventional tables may continue to be modeled maintained and queried as tables containing only current data. Within their generated canonical tables or their associated canonical files a complete bitemporal record of all changes to that data is preserved.

Temporal metadata also supports the otherwise identical capabilities provided by the systems and methods described herein. With these capabilities a query for what the objects represented by canonical or canonically supported data were like at any past point in time or are like at the current moment in time or are expected to be like at any future point in time can always be satisfied provided of course that the past current or future states of those objects have been recorded in the database.

In addition a query for what the database said at any past point in time that objects represented by its data were like are currently like or are expected to be like can always be satisfied. This data may be found in assertion time canonical tables or it may remain resident in effective time canonical tables or in bitemporal canonical tables.

In embodiments supporting future assertions queries can also be supported that ask what the database is expected to say at any future point in time that objects represented by its data were like are currently like or are expected to be like.

Business intelligence software provides an extensive temporal history of events. The systems and methods described herein provide an equally extensive temporal history of the past present and future states of persistent objects and also of the past present and future states of the data that record those states of those objects. The systems and methods described herein also encapsulate the complexities of the evolutionary path from today s data management and access capabilities to the data management and access capabilities described herein.

