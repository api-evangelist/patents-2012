---

title: Checksum and hashing operations resilient to malicious input data
abstract: A resilient hashing system leverages a fast, non-cryptographic hash/checksum function that has good diffusion properties while remaining reasonably efficient on modern central processing units (CPUs). The hash function uses random secret data so that hash keys for particular data are difficult to predict. Due to its internal structure, well-chosen random secret data is difficult for an attacker to counter without having access to the direct output of the hash function. At every stage of the block function, there are at least two operations that can be performed in parallel, increasing performance on modern superscalar CPUs. Thus, the resilient hashing system provides a hash table and checksum that can be used in Internet-facing or other vulnerable sources of input data to manage performance in the face of malicious attacks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09002812&OS=09002812&RS=09002812
owner: Microsoft Technology Licensing, LLC
number: 09002812
owner_city: Redmond
owner_country: US
publication_date: 20121119
---
The present application claims the benefit of U.S. Provisional Patent Application No. 61 618 839 entitled CHECKSUM AND HASHING OPERATIONS RESILIENT TO MALICIOUS INPUT DATA and filed on Feb. 4 2012 which is hereby incorporated by reference.

A hash table is a data structure in computer science that implements an associative array between particular buckets identified by keys and the values stored there. A hash function is used to determine a key for any particular value. A hash function can be any operation that generates a suitable key for a particular hash table s usage. Hash functions are generally chosen so that the distribution of keys is good over a particular expected set of values. A perfect hash function is used to denominate a hash function that does a good job of distributing values by selecting unique keys and thus does not cause any collisions. A collision occurs when two values map to the same key and thus the same hash bucket. Whether collisions are a problem or not depends on how the hash table is being used but where collisions matter a perfect hash function avoids extra logic for handling collisions.

Hash functions often use a technique referred to as a checksum for determining hash keys from input values. A checksum can be thought of as a summary of data. A long set of bytes of data when run through a checksum function will generally produce a fixed length value e.g. 32 bits or 64 bits referred to as the checksum. This value can then be compared to the checksum of other data or of the same data at a different time to quickly detect changes to the data. The checksum function is generally chosen so that even small changes to the data will result in a different checksum value so that changes can be efficiently detected. The most common checksum function for detecting data changes is a group of algorithms known as cyclic redundancy check CRC . Cryptographic hash algorithms such as MD5 and SHA1 are also commonly used.

Hash tables experience worst case performance when large numbers of input values all have the same key and thus are hashed into the same bucket. This can be caused by either poor hash function choice or maliciously chosen input that takes advantage of the predictable nature of the hashing function. Non cryptographic hash codes such as those used in the hash table data structure can be predictably calculated outside of an application s boundaries. A malicious attacker can use this to force many entries into the same hash table location deliberately creating worst case performance and to cause substantial delays in calculation over otherwise acceptable input data.

One potential solution to the latter is to mix secret data into the predictable hash function that is not known to the attacker. However existing hash functions are built for either speed good distribution of outputs over the input data or high likelihood that related inputs are spread throughout the table evenly. There are few good places to include extra secret data in existing functions that attackers cannot work around. There are several solutions to dealing with malicious inputs to hash tables. One is to use a hash table with good worst case performance. Unfortunately such hash tables are more complicated and sometimes have poorer average performance.

A resilient hashing system is described herein that leverages a fast non cryptographic hash checksum function that has good diffusion properties while remaining reasonably efficient on modern central processing units CPUs . The hash function uses random secret data so that hash keys for particular data are difficult to predict. Due to its internal structure well chosen random secret data is difficult for an attacker to counter without having access to the direct output of the hash function. At every stage of the block function there are at least two operations that can be performed in parallel increasing performance on modern superscalar CPUs. Good diffusion properties mean that small amounts of entropy in the input data greatly affect the output. Non cryptographic simply means that the function does not have the processing overhead typically associated with cryptographic functions where performance would be unacceptable for frequently used data structures because the hash function does not provide the properties of a cryptographic hash function such as collision resistance and second pre image resistance. Non cryptographic hash functions can be significantly faster than cryptographic ones. Thus the resilient hashing system provides a hash table and checksum that can be used in Internet facing or other vulnerable sources of input data to manage performance in the face of malicious attacks.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A resilient hashing system is described herein that leverages a fast non cryptographic hash checksum function that has good diffusion properties while remaining reasonably efficient on modern central processing units CPUs . The hash function uses random secret data so that hash keys for particular data are difficult to predict. Due to its internal structure well chosen random secret data is difficult for an attacker to counter without having access to the direct output of the hash function. In some embodiments the hash function provides for high parallelism. At every stage of the block function there are at least two operations that can be performed in parallel increasing performance on modern superscalar CPUs. In software this hash function can even be faster than CRC. Good diffusion properties mean that small amounts of entropy in the input data greatly affect the output. Non cryptographic simply means that the function does not have the processing overhead typically associated with cryptographic functions where performance would be unacceptable for frequently used data structures because the hash function does not provide the properties of a cryptographic hash function such as collision resistance and second pre image resistance. Non cryptographic hash functions can be significantly faster than cryptographic ones.

The resilient hashing system provides at least three advancements over existing hash tables. First the internal structure of the system uses a hashing function that has low overhead and high parallelizability on modern superscalar CPUs. Second the system uses rotation constants described further herein derived from an exhaustive search to be both resilient against predictable output modification and high in diffusion. Rotation constants refer to how data is modified to calculate a checksum using CPU rotation instructions. Third the system s application to a hash table to provide randomized location of data values and thus to avoid potential denial of service attacks improves upon existing hash tables. Although the industry understands the benefit that randomized hash tables provide today the resilient hashing system improves the security of these implementations with little to no performance degradation. Thus the resilient hashing system provides a hash table and checksum that can be used in Internet facing or other vulnerable sources of input data to manage performance in the face of malicious attacks.

One application of the resilient hashing system is in a web based system. Web frameworks such as MICROSOFT ASP.NET provide an environment in which web application developers can build solutions to a wide variety of problems. Such frameworks often provide a library of well known data structures and algorithms that application developers can use to build their solutions. These solutions are then often deployed to the public Internet or to other areas where attackers and others may attempt to compromise the operation or performance of the application. One type of attack is known as a denial of service DoS and refers to an inability for legitimate users of a system to achieve the results they want because malicious users have compromised the system in some way. Degrading performance of hash tables is one among many such possible DoS attacks. The resilient hashing system provides a hash table and method that can be applied to input data in this type of environment and that can manage and maintain good performance even in the event of malicious activity and attempts to deny good service to legitimate users.

Recent DoS attacks rely on an adversary constructing many hash table keys that hash to the same index and sending them all to a server in a request. The server inserts all the items in a hash table which takes time 0 n if they all have the same hash value. There are several possible mitigations including the use of a hash table with 0 n log n worst case behavior but the simplest solution is to use a randomizable hash function to compute the index into the hash table. As long as the attacker cannot predict when two keys will hash to the same table entry the DoS attack fails. This is the mitigation provided by the resilient hashing system.

The following paragraphs describe one checksum function called Marvin32 which exhibits the properties described above although other functions can be used with the system herein to achieve similar results. The function described builds upon the Helix Phelix algorithms and the Skein hash function. The Skein hash function is one of five finalists that may become the SHA3 algorithm to replace the aging SHA1 and SHA2 specifications. The method described herein improves upon Skein to provide greater performance potential.

Marvin32 takes the following inputs 8 bytes Seed s s . . . s N bytes Data d d . . . d N 0 and produces an 8 byte checksum c c . . . cas output. The Seed is converted to two 32 bit words S S using the least significant byte first convention 2 22

Let K ceil N 5 4 be the number of 32 bit words D . . . D we derive from the data using the least significant byte first convention 2 2 2 for 01

We define the function Block a b that takes two 32 bit words as input and returns two 32 bit words as output. Block A B 

Here xor is the bitwise exclusive OR operation the additions are all modulo 2 32 and the rotate left function rotates its first argument left by a number of bits specified by the second argument.

The final words P Q form the result of the checksum function. They are converted to 8 bytes using the least significant byte first convention 

If no seed is required a default seed can be used that consists of the first 8 bytes of the SHA 256 hash of the 8 byte string Marvin32 byte values b7 93 08 cd ce d9 3c d5 . Use of the all zero seed value is discouraged. The all zero state is a fixed point of the Block function and as long as all inputs are zero the internal state will remain zero. For randomly chosen seed values this happens with low probability 2 64 which is not a problem for a checksum function. We recommend against checking a random seed for the all zero value and then changing it the extra code and risk of errors is not worth the gain. The use of a fixed zero seed raises the concern that some accidental changes e.g. adding 16 zero bytes to the front of the message will not affect the result of the checksum function.

The basic structure design is derived from a class of cryptographic algorithms called ARX for Add Rotate and Xor. Similar designs are used in Helix Phelix Michael and Skein. At every stage of the block function there are at least two operations that can be performed in parallel this increases performance on modern superscalar CPUs.

The default seed value is chosen to be verifiably non malicious. Using SHA 256 is a trivial way to generate 8 bytes with no structure that could relate to the Marvin design. The rotation constants are chosen by computer search. There are 1 048 576 possible sets of rotation constants. We first eliminated those containing rotations by 0 1 or 31 leaving 707 281 sets. Rotation by one is undesirable as it moves a bit to its neighbor which could also be influenced by the carry in the addition. This can lead to undesirable cancellation of a difference. The next test is that the sums of any subset of the rotation constants are different modulo 32. It is possible to find a path through the Block function that uses any subset of the four constants having two paths with the same overall rotation again increases cancellation of differences. This leaves 73 320 sets of rotation constants.

Next we look at an approximate measure of the diffusion. We rewrite the Block function to use OR instead of XOR and ADD. We then apply it to the input 1 0 . In this computation a bit is set if it could be affected through the binary operations and rotates but ignoring the carries in the addition. As the modified Block function is rotation invariant we do not apply it to 2 0 and other input bit positions. We restrict the set of rotations to those that achieve highest Hamming weight after the application of two consecutive modified Block functions to the input 1 0 . The highest Hamming weight is 38 and 1 326 sets of rotations pass this test.

Finally we measure the average forward and backward diffusion of differences in the Block function. Given a random input we flip a random bit in the first word and measure how many bits are flipped in the output. We do this both for the forward and reverse version. The set 20 9 27 19 consistently scored amongst the highest performing sets of rotation constants under this metric though other sets of rotation constants can be similarly derived.

The input receiving component receives input data for which to determine a checksum value. The input data may include any variety of data including text binary image audiovisual or other data. The data may include email messages web form data hypertext markup language HTML software application output media content or any other type of data. The system receives input from a user or from software via an application programming interface API or other interface. The system may provide a graphical or programmatic interface through which users or other software can interact with the system to provide configuration input and to receive output data. The system may be implemented as one or more modules as part of a programming library or in any other suitable form.

The seeding component receives or determines a seed value to use to randomize the checksum values produced by any particular instance of the system. The user of the system e.g. a software application developer may provide the seed which may be determined in whatever manner the user decides or may rely on the system to use a default seed value or choose a random seed value. The seed may be determined once for any particular instance of the system or may be changed periodically. For example some implementations may choose to select a new seed each time the system is run while others may choose to select a new seed after a particular period of time to thwart external attempts to guess or extract the seed value.

The checksum component computes a checksum value derived from the received input data and determined seed value. The checksum is determined in a manner that produces high diffusion of the checksum value even for slight variations in the input data. In addition the checksum is determined in a manner that is difficult to guess for an attacker that has ready access to the data but does not have access to the seed value which is kept protected within the system . In this way the system is resilient to attacks that attempt to fill particular hash buckets of a hash table that selects hash keys using the checksum function described herein. The checksum component may use an implementation of Marvin32 or other suitable checksum functions to achieve this result.

The data output component provides the computed checksum value as output data to other components of the system or external components. In some cases a software application may leverage the system simply to produce a checksum. Because the system computes checksums in a manner that is efficient and that uses modern CPU resources effectively applications may choose the system to produce checksums for a variety of purposes. Those of ordinary skill in the art will recognize numerous software problems that involve the use of a checksum where use the system described herein is well suited. Alternatively or additionally the system may be applied in a hash table implementation to provide less predictable distribution of data within the hash table.

The hash table component manages a hash table that uses the checksum value as a hash key. A hash table built in such a manner is more resilient than common hash tables to malicious attacks that attempt to overfill particular buckets of the hash table with data values. Filling hash buckets beyond an amount that occurs in normal operation can lead to poor hash table performance and thus can be used to carry out a denial of service attack. By distributing data values with the type of checksum described herein the system can ensure that an attacker cannot know or easily guess how data will be distributed within the hash table. Without knowing this information the attacker cannot intentionally degrade the hash table s performance.

The data storage component provides a data store for storing information associated with the system . The data may include the hash table seed value or other information used by the system. The data store may include one or more in memory data structures files file systems hard drives databases cloud based storage services or other facilities for storing data.

The computing device on which the resilient hashing system is implemented may include a central processing unit memory input devices e.g. keyboard and pointing devices output devices e.g. display devices and storage devices e.g. disk drives or other non volatile storage media . The memory and storage devices are computer readable storage media that may be encoded with computer executable instructions e.g. software that implement or enable the system. In addition the data structures and message structures may be stored on computer readable storage media. Any computer readable media claimed herein include only those media falling within statutorily patentable categories. The system may also include one or more communication links over which data can be transmitted. Various communication links may be used such as the Internet a local area network a wide area network a point to point dial up connection a cell phone network and so on.

Embodiments of the system may be implemented in various operating environments that include personal computers server computers handheld or laptop devices multiprocessor systems microprocessor based systems programmable consumer electronics digital cameras network PCs minicomputers mainframe computers distributed computing environments that include any of the above systems or devices set top boxes systems on a chip SOCs and so on. The computer systems may be cell phones personal digital assistants smart phones personal computers programmable consumer electronics digital cameras and so on.

The system may be described in the general context of computer executable instructions such as program modules executed by one or more computers or other devices. Generally program modules include routines programs objects components data structures and so on that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments.

Continuing in block the system receives a word of input data D for which the following steps will determine an output checksum and computes A B P D mod 2 32 Q . The data may be input data to a software application data from a previous iteration of running the checksum process or any other data.

Continuing in block the system performs a logical operation. The logical operation can be a logical XOR operation or other suitable operation such as XOR A and B to produce B. In many cases the operation will be native to the CPU used to execute the instructions of the system such that this step can be processed as a single CPU instruction.

Continuing in block the system rotates the input data using a first rotation constant to produce intermediate data A. The rotation can be a left rotation or other operation that can be implemented by modern CPUs as a single instruction. For example the INTEL x86 architecture provides a rol instruction that rotates data to the left by a specified amount. The first rotation constant and other rotation constants described herein are selected to produce good diffusion of the output checksum value and for other properties described herein. The system may be designed to operate with a fixed set of rotation constants or may receive rotation constants as input or configuration data. This allows the system some flexibility if constants are discovered that work better or work better in a particular use of the system.

Many blocks of the system can process data in parallel. For example the blocks to produce intermediate data A and intermediate data B can be performed in parallel i.e. at the same time using separate processing units on modern superscalar CPUs. This allows the system to produce a checksum faster than many past methods and to more efficiently utilize available hardware resources. Similarly other steps below may be processed in parallel to reach the output checksum value.

Continuing in block the system combines intermediate data A and intermediate data B to produce intermediate data A. The combination may be produced by adding the two intermediate data numbers or by performing another operation that yields similar results. In the case of addition and similar operations these can be performed in a single CPU instruction for efficiency just as the other instructions previously described. The system may also make the addition modulo 2or another value to fit the data into a desired length.

Continuing in block the system rotates intermediate data B using a second rotation constant to produce intermediate data B. As described above the rotation can be a left rotation or other operation that can be implemented by modern CPUs as a single instruction. The second rotation constant and other rotation constants described herein are selected to produce good diffusion of the output checksum value and for other properties described herein.

Continuing in block the system performs a logical operation that combines intermediate data A and intermediate data B to produce intermediate data B. The logical operation can be a logical XOR operation or other suitable operation. In many cases the operation will be native to the CPU used to execute the instructions of the system such that this step can be processed as a single CPU instruction.

Continuing in block the system rotates intermediate data A using a third rotation constant to produce intermediate data A. As described above the rotation can be a left rotation or other operation that can be implemented by modern CPUs as a single instruction. The third rotation constant and other rotation constants described herein are selected to produce good diffusion of the output checksum value and for other properties described herein.

Continuing in block the system combines intermediate data A and intermediate data B to produce intermediate data A. The combination may be produced by adding the two intermediate data numbers or by performing another operation that yields similar results. In the case of addition and similar operations these can be performed in a single CPU instruction for efficiency just as the other instructions previously described.

Continuing in block the system rotates intermediate data B using a fourth rotation constant to produce intermediate data B. As described above the rotation can be a left rotation or other operation that can be implemented by modern CPUs as a single instruction. The fourth rotation constant and other rotation constants described herein are selected to produce good diffusion of the output checksum value and for other properties described herein.

Continuing in block the system provides intermediate data A and intermediate B as the input for the next block or if all blocks are complete as the output checksum value. Depending on the purpose and needs of a particular implementation the system may provide both values A and B or may combine the values e.g. through a logical XOR or other operation or making one value the upper bits of a longer value and the other value the lower bits of the longer value . For example in cases where a 64 bit checksum is desired and the intermediate data A and B are each 32 bits the two values can be combined into one 64 bit value. The output may be fed into another iteration of the previous steps that processes more data or may be output to other parts of a software application that use the output checksum value. After block these steps conclude.

Continuing in block the system provides the selected seed value to a checksum function that determines a checksum given an input seed and input data. The checksum function may be implemented in a module or other software package and may provide an interface such as an application programming interface API that includes a method for providing the seed value.

Continuing in block the system receives data to be inserted into a hash table. The data may include strings binary data or any other type of data that can be stored in a hash table. The system uses the data and seed to determine a key that is difficult for attackers to guess and thus that distributes data in the hash table in a manner that is difficult to predict. This makes it more difficult to perform a denial of service attack that depends on overusing particular buckets of the hash table.

Continuing in block the system breaks the received data into blocks and selects the first block for processing by the checksum function. In subsequent iterations the system selects the next block e.g. word using the output of the previous iteration as input to the next iteration. At the end of the data the system may pad the data to a suitable length and add zero or more additional blocks with a fixed value. In one embodiment the padding consists of a single nonzero byte followed by 4 5 6 or 7 bytes zero chosen such that the total length is a multiple of 4 bytes and thus an integral number of blocks.

Continuing in block the system computes the block checksum from the current checksum state and the data block selected in the previous step see e.g. . Preferably the block checksum function provides good mixing of the data and checksum state and high diffusion.

Continuing in decision block if there are more blocks of data or more blocks of padding then the system loops to block to process the next block of data else the system continues to block . After the system has processed all of the blocks of input data the system has computed an overall checksum value for the input data and uses that value as a hash key for inserting the data into the hash table a similar process can be used to look up or replace data in the hash table . In general the attacker will not have access to the seed and thus even if the attacker is aware of the data and the checksum function being used the attacker will still not have enough information to determine the key under which the data will be stored. In some embodiments the system uses a typical hashing function until a threshold number of collisions are detected and then switches to using the randomized hashing function described herein. This may allow the system to achieve better performance until an attack is more likely and then to thwart the attack by switching to a different hashing method.

Continuing in block the system inserts the received data into the hash table by using the hash key calculated by the checksum function. The location into which the data is inserted is referred to as a hash bucket and performance of the hash table may be determined in part by how many data items are placed in the same hash bucket. Because the system determines hash keys in a manner that has high diffusion and that is difficult to predict without knowing the seed value users of the system can have high assurance that an attacker cannot perform a directed attack to intentionally fill particular hash buckets. After block these steps conclude.

In some embodiments the resilient hashing system applies padding to input data shorter than the native size of the checksum operation e.g. four bytes . For example the system may append 0x80 to the end of the data and add zeroes to bring the size of the data to a four byte or other sized boundary.

In some embodiments the resilient hashing system operates at different bit lengths. As described herein the system can be implemented to operate at 32 bits 64 bits or other data size suitable for a particular implementation. The system can also operate with different rotation constants. As described above one set of constants was selected as an example but additional research may produce additional rotation constants with similar or better results. The output of the system as described produces two 32 bit values that can be combined to reach a 32 bit checksum or can be combined to produce a 64 bit checksum.

In some embodiments the resilient hashing system is applied to a common language library for strings and other data types. For example the MICROSOFT .NET common language runtime CLR provides data types such as String that include a GetHashCode function for getting hash keys. The techniques described herein can be applied to such implementations to generate less guessable hash keys. For example the system can seed the checksum function with a different random value for each .NET application domain so that each running program instance locates data in hash tables differently.

From the foregoing it will be appreciated that specific embodiments of the resilient hashing system have been described herein for purposes of illustration but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly the invention is not limited except as by the appended claims.

