---

title: Computation reduced tessellation
abstract: Systems and methods for a tessellation are described. The tessellation unit is configured to determine a number of points that reside along a first edge of a first ring within a domain, determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain, and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion. The tessellation unit is also configured to stitch points that reside along the first edge of the first ring with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09142060&OS=09142060&RS=09142060
owner: QUALCOMM Incorporated
number: 09142060
owner_city: San Diego
owner_country: US
publication_date: 20120830
---
A graphics processing unit GPU may implement a graphics processing pipeline that includes a tessellation stage. The tessellation stage converts a surface into a plurality of primitives on the GPU resulting in a more detailed surface. For example the GPU can receive information for a coarse surface and generate a high resolution surface rather than receiving information for the high resolution surface. Receiving information for the high resolution surface rather than the coarse surface may be bandwidth inefficient because the amount of information needed to define the high resolution surface may be much greater than the amount of information needed to define the coarse resolution surface.

In general the techniques described in this disclosure are directed to determining coordinates for points along first and second portions of an edge of a ring within a domain used for tessellating. In an example a tessellation unit for graphics processing may determine coordinates for points along the first portion of the edge. The tessellation unit may determine the coordinates for points along the second portion of the edge based on the coordinates for the points along the first portion of the edge.

The points along the edge may form vertices of primitives within the domain. By determining coordinates for the points of the second portion with the coordinates of the points of the first portion the example tessellation unit may exploit symmetry within vertices of the primitives within the domain.

In one example the disclosure describes a tessellation unit for graphics processing. The tessellation unit includes a first unit configured to determine a number of points that reside along a first edge of a first ring within a domain determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion. The tessellation unit also includes a second unit configured to stitch one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch wherein the second ring is inner to the first ring within the domain.

In another example the disclosure describes a method of tessellation including determining a number of points that reside along a first edge of a first ring within a domain determining a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain determining a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion and stitching one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch wherein the second ring is inner to the first ring within the domain.

In another example the disclosure describes a tessellation unit including means for determining a number of points that reside along a first edge of a first ring within a domain means for determining a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and means for determining a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion and means for stitching one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch wherein the second ring is inner to the first ring within the domain.

In another example the disclosure describes a device including a central processing unit CPU a graphics processing unit GPU . The GPU includes a tessellation unit configured to determine a number of points that reside along a first edge of a first ring within a domain determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion and stitch one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch wherein the second ring is inner to the first ring within the domain.

In another example the disclosure describes a non transitory computer readable medium including instructions that when executed in a sink device cause a programmable processor to determine a number of points that reside along a first edge of a first ring within a domain determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion and stitch one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch wherein the second ring is inner to the first ring within the domain.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Modern mobile devices such as laptop computer tablet computers smartphones and digital media players may include a CPU Central Processing Unit a graphics processing unit GPU and system memory. When rendering graphics as part of executing an application the CPU transmits instructions and graphics data to the GPU. In some examples the graphics data may be in the form of vertices which may comprise one or more data structures that describes a point in 2D or 3D space.

The application executing on the CPU may communicate with the GPU in accordance with an application programming interface API . For instance the application may communicate with the GPU in accordance with the DirectX API developed by Microsoft or the OpenGL API developed by the Khronos Group as two examples. For purposes of illustration and to ease with understanding the techniques described in this disclosure are generally described in the context of the DirectX and OpenGL APIs. However aspects of this disclosure should not be considered limited to the DirectX and OpenGL APIs and the techniques described in this disclosure may be extended to other APIs as well.

DirectX and OpenGL each define graphics processing pipelines that are to be implemented by a GPU. These graphics processing pipelines may include a combination of programmable stages as well as fixed function stages. Some recent versions of the APIs such as the Direct3D API and the OpenGL 4.x API include a tessellation process that is to be performed by the GPU.

The tessellation process refers to dividing a portion referred to as a patch of a surface of an object into a plurality of smaller portions and interconnecting the smaller portions together. This results in a more highly detailed surface as compared to the surface prior to tessellation. Tessellation allows the application executing on the CPU to define the surface with low resolution which may require few points and allows the GPU to generate a higher resolution surface.

With tessellation computation efficiency may be realized because the application executing on the CPU may not need to generate the higher resolution surface and may instead offload the generation of the higher resolution surface to the GPU. Furthermore bandwidth efficiency may also be realized because the CPU may need to transmit information for fewer points of the surface because the low resolution surface includes fewer points as compared to the higher resolution surface and the GPU may need to retrieve fewer points of the surface.

As described above the GPU applies the tessellation process to a patch. A patch may be considered as a specialized type of a primitive. A patch is defined by one or more control points that together form a portion of a surface. For example an object such as a sphere may be divided into a plurality of surfaces. In this example the surfaces may be curved surfaces that when combined form the sphere. Each one of the surfaces may be divided into one or more patches where each of the patches is defined by one or more control points.

When dividing an edge into one or more smaller edges each edge may be normalized to a zero to one coordinate system. For example in a quad domain each of four edges may be normalized from 0 to 1. Accordingly a normalized quad domain may include Cartesian coordinates u v of 0 0 1 0 0 1 1 1 . Similarly in an example of triangular domain each of three edges may be normalized from 0 to 1. Accordingly a normalized triangle domain may have Barycentric coordinates u v w of 0 0 1 0 1 0 1 0 0 . Additionally when using normalized Barycentric coordinates in the triangular domain the sum of each coordinate set is always one e.g. for 0 0 1 0 0 1 1 for 0 1 0 0 1 0 1 and for 1 0 0 1 0 0 1. Once an edge has been normalized the tessellation unit may determine the coordinates of each point of the edge based on the tessellation factor.

The control points may be defined by coordinates e.g. x and y coordinates for two dimensional patches or x y and z coordinates for three dimensional patches and the control points may be considered as vertices of the patch. There may be any number of control points in a patch. For instance in some examples the number of control points in a patch may be between one control point up to 32 control points. The number of control points in a patch may be fixed or user defined.

Unlike other primitive types the control points within the patches may be connected to one another in any way. In other words there is no predefined way in which the control points of the patches are connected. For example a standard triangle primitive includes three vertices and the primitive is defined with a specific way in which the three vertices are connected with one another to form the triangle. The control points on the other hand may not need to be connected in any specific way to form a shape. Rather as one example some control points in a patch may be connected with one another to form a triangle other control points in the same patch may be connected with one another to form a rectangle and yet other control points in the same patch may be connected with one another to form an octagon. As another example it may be possible that the control points are connected with another to form the same type of shapes as well e.g. connected to only form a plurality of triangles .

The control points that define a patch of a surface may define a low resolution surface. With the tessellation process additional detail is added to create a higher resolution surface. For example referring back to the example of the sphere. If only the control points were used to form the sphere the sphere would appear jaggy with stair step like points rather than a smooth curved surface. After tessellation additional points are added such that when these points are connected the sphere appears as if it is a smooth sphere.

The tessellation process in accordance with the both the DirectX API and the OpenGL 4.x API includes two shaders and a fixed function unit. A shader is a software application that executes on a programmable shader core of the GPU and provides substantial functional flexibility. The fixed function unit is a hardwired logic unit that performs fixed functions and may not provide functional flexibility. However it may be possible to implement the functions of the fixed function unit using a programmable shader coder to provide additional functional flexibility. Solely for purposes of illustration the functions described in this disclosure for the fixed function unit are described with a fixed function unit that provides limited functional flexibility.

In the DirectX API a graphics processing pipeline that is configured to implement the tessellation process includes a hull shader stage coupled to a tessellation stage which is coupled to a domain shader stage. The hull shader stage and the domain shader stage in the DirectX API may form the two shaders of the tessellation process and the tessellation stage may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline are similar to those in DirectX APIs that do not implement the tessellation process.

In the OpenGL 4.x API a graphics processing pipeline that is configured to implement the tessellation process includes a tessellation control shader coupled to a primitive generator which is coupled to a tessellation evaluation shader. The tessellation control shader and the tessellation evaluation shader in OpenGL 4.x may form the two shaders of the tessellation process and the primitive generator may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline may be similar to those in OpenGL APIs that do not implement the tessellation process.

The techniques described in this disclosure are related generally to the fixed function unit of the tessellation process e.g. the tessellation stage of the DirectX graphics processing pipeline and the primitive generator of the OpenGL 4.x graphics processing pipeline . For purposes of brevity the fixed function unit of the tessellation process is referred to as a tessellation unit. For instance examples of the tessellation unit include the tessellation stage of the DirectX graphics processing pipeline the primitive generator of the OpenGL 4.x graphics processing pipeline or any other analogous unit for other types of graphics processing pipelines.

As described in more detail the shader preceding the tessellation unit e.g. the hull shader stage in DirectX or the tessellation control shader in OpenGL 4.x transmits values to the tessellation unit that indicate how many primitives are to be generated for the patch to increase the resolution i.e. increase the detail of the patch. The shader preceding the tessellation unit also transmits a domain type to the tessellation unit. The tessellation unit divides a domain into the primitives and indicates the manner in which the primitives in the domain are to be connected i.e. the manner in which the primitives in the domain are to be stitched .

The domain is a template shape that the tessellation unit divides into a plurality of primitives. It is these primitives that are then added to the patch to increase the resolution of the patch. For example the additional primitives generated in the domain are then used to form a mesh on the patch thereby adding detail to the patch.

The shader subsequent to the tessellation unit e.g. the domain shader in DirectX or the tessellation evaluation shader in OpenGL 4.x receives the vertices of the primitives generated by the tessellation unit and connectivity information for the vertices from the tessellation unit. The shader subsequent to the tessellation unit then adds the primitives as generated by the tessellation unit to the patch to add more resolution to the surface.

In accordance with techniques described in this disclosure the tessellation unit for graphics processing may be configured to determine coordinates of points along an edge of a ring within the domain based on the other points along the same edge. In this manner computational efficiency may be achieved because there may be fewer points whose coordinates need to be computed.

For example the tessellation unit may determine a number of points that reside along a first edge of a first ring within a domain. The tessellation unit may determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion.

The tessellation unit may also be configured to stitch one or more points that reside along the first edge of the first ring based on the first set of coordinates and the second set of coordinates with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch. In this example the second ring is inner to the first ring within the domain.

In various examples the points that reside along the first portion and the points that reside along the second portion may be symmetrical to one another. For example the second half of the edge is symmetrical with respect to the first half. Accordingly each point in the first portion of the points is symmetric with a corresponding point in the second portion of the points.

The coordinate for the last point on the edge may be equal to fixed point 1 for reasons described in more detail below. Therefore if the coordinates for the first portion are generated and represented by the set X the coordinate for the points on the second portion are equal to the set 1 X.

In an example system the tessellation unit may determine the coordinate for a point of the first portion and store the coordinate in a buffer. At the same time e.g. in parallel the tessellation unit may store the value of one minus the coordinate for the point of the first portion in the buffer or in a different buffer. The value of one minus the coordinate for the point of the first portion may be the coordinate for a point in the second portion. In this example the point in the second portion may be symmetric to the point in the first portion.

In this manner the tessellation unit may use a buffer that stores the 1 X values e.g. the coordinates for the points of the second portion of the edge when generating the points for the first portion of the edge which are represented by the set X. When the set 1 X is needed the values can be read from the buffer in the subsequent clock cycles rather than re calculating the coordinates for the points along the second portion of the edge.

In this case various circuitry within the tessellation unit may be clock gated during this period so that this circuitry does not determine the coordinates for the points along the second portion of the edge. This may result in saving significant power because the circuitry that would have been used to determine the coordinates for the points along the second portion of the edge is essentially turned off due to the clock gating.

Additionally throughput may be increased by using the generated points immediately instead of waiting to the end until all of the coordinates of the edge are determined to double throughput. For example in this case the tessellation unit may determine the coordinates for the points along the first portion and the second portion at the same time. In this example when the tessellation unit completes determining the coordinate for the last point in the first portion the coordinates for the points along the first and second portions of the edge are available for processing. In this manner units further down in the graphics processing pipeline may be able to retrieve the coordinates for all of the points along the edge in half the time as compared to if the tessellation unit determined the coordinates for each of the points in both the first portion and the second portion one at a time.

CPU may execute various types of applications. Examples of the applications include web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. Instructions for execution of the one or more applications may be stored within system memory . CPU may transmit graphics data of the generated viewable objects to GPU for further processing.

For example GPU may be specialized hardware that allows for massive parallel processing which functions well for processing graphics data. In this way CPU offloads graphics processing that is better handled by GPU . CPU may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft and the OpenGL by the Khronos group however aspects of this disclosure are not limited to the DirectX and the OpenGL APIs and may be extended to other types of APIs that have been developed are currently being developed or are to be developed in the future.

In addition to defining the manner in which GPU is to receive graphics data from CPU the APIs may define a particular graphics processing pipeline that GPU is to implement. GPU in illustrates the graphics processing pipeline defined by the Direct3D API. As described in more detail illustrates the graphics processing pipeline of the OpenGL 4.x API.

Examples of CPU and GPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing and may be referred to as a general purpose GPU GPGPU . The techniques described in this disclosure may also be applicable to examples where GPU is a GPGPU.

System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM flash memory or any other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Accordingly system memory may be a computer readable storage medium comprising instructions that cause one or more processors e.g. CPU and GPU to perform various functions.

System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable. As one example system memory may be removed from device and moved to another device. As another example a system memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

The execution of the applications on CPU causes CPU to generate a plurality of primitives that connect together to form the viewable content. Examples of the primitives include points lines triangles squares or any other type of polygon. CPU may define these primitives by their respective vertices. For example CPU may define coordinates and color values for the vertices. The coordinate values may be three dimensional 3D coordinates or 2D coordinates.

In accordance with the techniques described in this disclosure in some cases CPU may also generate a special type of primitive referred to as a patch. Similar to the other primitive types a patch may be defined by a plurality of vertices referred to as control points of a patch. Unlike other primitive types the patch may not be any particular shape. For example CPU may interconnect the control points of the patch in any manner so that the interconnected control points form any desired shape. For other primitive types such as triangles CPU may define the specific manner in which the vertices are interconnected e.g. such that interconnection of the vertices results in a triangle .

Also unlike other primitive types the number of control points in a patch may be variable. For example the application executing on CPU may define a maximum number of control points that are allowed for a patch or the maximum number of control points may be user defined. In some examples the number of control points in a patch may be one to thirty two control points however the techniques described in this disclosure are not so limited.

CPU may utilize the control patch for purposes of tessellation. As described above a tessellation process refers to CPU defining a portion of a surface of a viewable object in low resolution and tessellating the portion to generate a higher resolution version of the surface. For example CPU may define control points of the patch such that when the control points are interconnected the patch forms a portion of a surface of a viewable object. If a surface were to be formed only from the control points of the patch the surface may not appear with high resolution and may appear jaggy. With tessellation additional primitives are added to the patch such that when the primitives are interconnected they add detail to the patch which increases the resolution of the patch and results in higher quality viewable content.

GPU may be configured to implement tessellation. In this way CPU may not need to define the vertices for all the additional primitives needed to create the higher resolution patch which saves on computations performed by CPU . Also CPU may need to transmit fewer vertices e.g. the vertices of the control points and not the vertices of the primitives to be added and GPU may correspondingly need to receive fewer vertices which promotes bandwidth efficiency due to fewer accesses to system memory .

To perform graphics operations GPU may implement a graphics processing pipeline. The graphics processing pipeline includes performing functions as defined by software or firmware executing on GPU and performing functions by fixed function units that are hardwired to perform very specific functions. The software or firmware executing on the GPU may be referred to as shaders and the shaders may execute on one or more shader cores of GPU . Shaders provide users with functional flexibility because a user can design the shaders to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility.

As indicated above the graphics processing pipeline illustrated in is a graphic processing pipeline substantially as defined by Direct3D . In this example GPU may include one or more of input assembler stage vertex shader stage hull shader stage tessellation stage domain shader stage geometry shader stage rasterizer stage pixel shader stage and output merge stage . GPU may include more stages than those illustrated and in some examples GPU may not necessarily include all of the illustrated stages. Also the specific ordering of the stages is provided for purposes of illustration and should not be considered limiting.

In techniques described in this disclosure CPU may output the control points of a patch to system memory . GPU may then retrieve the control points from system memory . In this manner CPU may transmit the control points to GPU . As used in this disclosure CPU transmitting to GPU or GPU receiving from CPU may generally include CPU writing to system memory from which GPU receives. Alternatively it may be possible for CPU to directly transmit to GPU and for GPU to directly receive from CPU .

Input assembler stage may read the control points from system memory as defined by CPU and assemble the control points to form the patch. For instance input assembler stage may read the coordinates color values and other such information of the control points. The coordinates color values and other such information may be commonly referred to as attributes of the control points. Based on the attributes of the control points input assembler stage may determine the general layout of the patch. In this manner input assembler stage may assemble the control points to form the patch. Input assembler stage may be a fixed function unit.

Vertex shader stage may process the vertices e.g. the control points of the patch from input assembler stage . For example vertex shader stage may perform per vertex operations such as transformations skinning morphing and per vertex lighting. Vertex shader stage may be a shader.

Hull shader stage receives the control points of the patch as processed by vertex shader stage process the control points and outputs control points for a processed patch. In other words hull shader stage receives an input patch as processed by vertex shader stage processes the input patch and outputs an output patch. Hull shader stage may perform various functions for processing the input patch. For example hull shader stage may modify the coordinates of the control points to change the locations of the control points or may even add or delete control points.

In addition hull shader stage may determine values that indicate how many primitives are to be added to the patch generated by hull shader stage i.e. the output patch . Hull shader stage may utilize various criteria to determine how many primitives are to be added to the patch. Described below are two example criteria that hull shader stage may utilize to determine how many primitives are to be added to the patch. However aspects of this disclosure are not so limited and hull shader stage may utilize any criteria to determine how many primitives should be added to the patch.

As one example hull shader stage may utilize information indicative of the depth of the patch to determine how many primitives should be added. For instance a patch that is further away from the perspective of the viewer may not need high resolution because objects further in distance appear blurry in real life. However a patch that is closer from the perspective of the viewer may need higher resolution because objects closer in distance appear sharper in real life. In this example hull shader stage may determine that fewer primitives should be added to the patch that is further away and more primitives should be added to the patch that is closer relative to one another.

As another example hull shader stage may determine how many primitives should be added based on the size of the patch. For a smaller sized patch hull shader stage may determine that fewer primitives should be added because the patch encompasses a smaller area. For a larger sized patch hull shader stage may determine that more primitives should be added because the patch encompasses a larger area.

Based on a determination of how many primitives should be added hull shader stage may output a domain type and values that indicate how many primitives are to be added to the patch to tessellation stage . The values that indicate how many primitives are to be added to the patch in the Direct3D API are referred to as tessfactors.

The domain may be a considered as a template shape that tessellation stage uses for tessellation purposes. Examples of the domain type include a line a triangle a quad e.g. a four sided polygon or any other type of polygon. The domain may be a two dimensional 2D shape even if the patches define a three dimensional 3D surface or a 2D surface. When the domain is a line the domain may be a one dimensional 1D shape i.e. a line even if the patches define a 3D surface a 2D surface or a 1D surface. For purposes of illustration the techniques described in this disclosure are described with respect to the domain being a 2D surface. For instance the techniques are described with domain shapes that are the triangle or quad.

In some examples hull shader stage may not explicitly indicate the domain type. Rather tessellation stage may determine the domain type based on the number of transmitted tessfactors. For example the presence of four tessfactors may indicate that the domain type is a triangle domain type and the presence of six tessfactors may indicate that the domain type is a quad domain type.

In some examples a quad domain may be defined by 2D Cartesian coordinates u v . In some examples a triangle domain may be defined by Barycentric coordinates. Barycentric coordinates utilize three coordinates to identify any point within the triangle. For example the vertices of the triangle domain may be defined as u v w as described below in more detail. The location of any point within the triangle is defined by vertex weighting that indicates its proximity to a vertex. For instance the closer a point is to a vertex the higher its vertex weighting and the further away the point is from the vertex the lower its vertex weighting.

As an example assume the vertices of the triangle are defined with Barycentric coordinates u v w as follows 1 0 0 0 1 0 and 0 0 1 . In this example the center point is located at because the center point is equally distant from each of the vertices. Also with the given definition of the vertex coordinates in this example the sum of the u v and w coordinates for any point within the triangle domain should equal one.

The Cartesian and Barycentric coordinates are described for purposes of illustration only and should not be considered limiting. In other examples it may be possible to define the quad domain with Barycentric coordinates or Cartesian coordinates and the triangle domain with Cartesian coordinates or Barycentric coordinates. In general a domain of any type may be defined using any coordinate system.

Tessellation stage may tessellate e.g. divide the domain into a plurality of primitives. It should be understood that in this example tessellation stage is not dividing the patch outputted by hull shader stage into primitives but rather dividing the domain into the primitives. In some examples tessellation stage may not even have access to the patch outputted by hull shader stage . Tessellation stage may be a fixed function unit although aspects of this disclosure need not be so limited.

Tessellation stage may utilize the tessfactors outputted by hull shader stage to tessellate e.g. divide the domain into a plurality of primitives. For example in addition to defining the domain type e.g. triangle or quad the tessfactors may define how many rings are to be included within the domain.

A ring may be a series of concentric shapes within the domain where the concentric shapes are the same shape as the domain shape. For example if the domain shape is a quad the perimeter of the quad may be considered as the outer ring. Hull shader stage may define the number of inner rings which may be series of smaller sized quads that reside within the quad domain. Similarly if the domain shape is a triangle the perimeter of the triangle may be considered as the outer ring and the inner rings may be series of smaller sized triangles that reside within the triangle domain.

In addition to defining the number of rings within a domain the tessfactors define the points that reside along the rings. The points that reside along the rings should not be confused with control points. The control points define the patch. The points that reside along the rings are points generated by tessellation stage based on the tessfactors. These points are generated within the domain and not within the patch.

Also it is these points that tessellation stage connects together to divide the domain into a plurality of primitives. For example assume that the primitives that tessellation stage will divide the domain into are triangles. In this example tessellation stage may connect one point that resides along the outer ring with two points that reside along the inner ring to form a triangle primitive. Alternatively tessellation stage may connect two points that reside along the outer ring with one point that resides along the inner ring to form a triangle primitive. In this way by defining the domain type the number of rings within the domain and the number of points along the outer and inner rings hull shader stage may define the number of primitives into which tessellation stage should divide the domain.

In some examples the number of points that can reside along an edge of ring may be one point to sixty five points. For example if the domain type is a triangle than there may be up to 65 points per edge of the triangle domain. Similarly if the domain type is a quad than there may be up to 65 points per edge of the quad. However the techniques described in this disclosure are not limited to an edge having a maximum of sixty five points.

Furthermore the number of points that reside along a ring may be different for outer and inner rings. For example the number of points that reside along an edge of the outer ring may be more than or less than the number points that reside along an edge of the inner ring. It may also be possible that number of points that reside along the edge of the outer ring and the inner ring are the same number of points.

Moreover the number points along an edge of the same ring may be different. For example for a triangle domain the number of points that reside along one of the edges may be different than the number of points that reside along one other edge or both edges. Similarly for a quad domain the number of points that reside along one of the edges may be different than the number of points that reside along one two or all three other remaining edges. It may also be possible for each of the edges of the rings to have the same number of points.

As described above in some examples tessellation stage may not divide the patch into a plurality of primitives. Accordingly in some examples tessellation stage may not receive any information such as the number of control points the locations of the control points or the size of the patch. Without any information as to the size of the patch and the locations of the control points tessellation stage may not be able to define the size of the domain that is used or the specific coordinates for the vertices of the domain.

To address this tessellation stage may rely upon a normalized coordinate system for defining the vertices of the domain as well as for determining the locations of the interconnected points within the domain. In a quad domain each of four edges may be normalized from 0 to 1. As one example of the normalized coordinates tessellation stage may define the vertices of a quad domain in u v coordinates as 0 0 1 0 0 1 and 1 1 which is a unit square. Similarly in a triangular domain each of three edges may be normalized from 0 to 1. Accordingly tessellation stage may define the vertices of a triangle domain in u v w coordinates as 0 0 1 0 1 0 and 1 0 0 which is an equilateral triangle. Tessellation stage may determine the coordinates for the interconnected vertices of the plurality of primitives in this normalized coordinate system. Additionally when using normalized Barycentric coordinates in the triangular domain the sum of each coordinate set is always one.

Tessellation stage may output the vertices of the plurality of primitives of the domain to domain shader stage in the normalized coordinate system e.g. the u v coordinates or the u v w coordinates as applicable . The function of domain shader stage may be to map the vertex coordinates as received from tessellation stage on to the patch. For example while tessellation stage may not receive information of the patch as defined by hull shader stage domain shader stage may receive such information from hull shader stage .

Domain shader stage may execute for each vertex coordinate outputted by tessellation stage . With the coordinates of the control points of the patch from hull shader stage domain shader stage may determine the location of the vertex as outputted by tessellation stage on the patch. Because tessellation stage outputs vertices of the plurality of primitives generated by tessellation stage and domain shader stage adds these primitives to the patch the combination of hull shader stage tessellation stage and domain shader stage together add additional primitives to the patch. This results in a mesh of primitives that are added to the patch creating a higher resolution more detailed patch as compared to the patch defined by CPU . In this manner hull shader stage tessellation stage and domain shader stage implement a tessellation process.

The tessellation stage may be configured to include a point generator capable of outputting two x y coordinate pairs simultaneously. Point generator may transmit the x y coordinate pairs for both points to a connectivity generator in parallel. In some examples the connectivity generator may be configured to receive two x y coordinate points at a time. In the case where connectivity generator is capable of receiving two x y coordinate pairs simultaneously the tessellation unit may include two 4 deep first in first out FIFO queues that is two FIFOs capable of holding 4 x y coordinate pairs . For example the tessellation unit the local memory of GPU or system memory may include two buffers where each of the two buffers is a 4 deep FIFO queue.

Geometry shader stage receives the vertices of the primitives added to the patch by domain shader stage and may further generate additional vertices for the primitives to add even more resolution. Rasterizer stage receives the primitives from geometry shader stage and converts the primitives into pixels for the display. For example the primitives may be defined as vectors that indicate the interconnection of the primitives and may be defined in a coordinate space that is independent of the display on which the image is to be displayed. Rasterizer stage converts these vectors into the display coordinates and performs any additional functions such as removing points within primitives that are occluded.

Pixel shader stage receives the pixels as outputted by rasterizer stage and performs post processing to assign color values to each of the pixels that are to be displayed. For example pixel shader stage may receive constant values stored in system memory texture data stored in system memory and any other data to generate per pixel outputs such as color values. Pixel shader stage may also output opacity values that indicate the opaqueness of the pixels.

Output merge stage may perform any final pixel processing. For example output merge stage may utilize depth information to further determine whether any of the pixels should be removed from being displayed. Output merge stage may also perform blending operations to generate final pixel values.

Output merge stage may output the final pixel values to a frame buffer generally located within system memory but which may be located within GPU . A display processor not shown may retrieve the pixel values from the frame buffer and cause pixels of a display not shown of device to illuminate accordingly to the pixel values to cause the display to display the image.

As described above tessellation stage interconnects points of the outer and inner rings within the domain to generate a plurality of primitives within the domain. In an example the tessellation stage may be a tessellation unit for graphics processing. The tessellation unit may be configured to determine a number of points that reside along a first edge of a first ring within a domain. Additionally the tessellation unit may also be configured to determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain. The tessellation unit may also be configured to determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion. In an example the tessellation unit may be configured to determine the second set of coordinates for the second portion of the points based on only the first set of coordinates for the first portion of the points.

In an example the tessellation unit may be configured to stitch one or more points that reside along the first edge of the first ring with points that reside along a second edge of a second ring. This may be done to divide the domain into a plurality of primitives that are mapped to a patch to increase a resolution of the patch. This division may be based on the first set of coordinates and the second set of coordinates of the edge. In this example the second ring is inner to the first ring within the domain. For example the points along the edge i.e. the points of the first portion and the points of the second portion may form the vertices of the primitives. The tessellation unit may stitch these points of the edge with points along an edge of an inner ring. The stitching of these points may result in primitives that are mapped to the patch to increase the resolution of the patch.

In accordance with techniques described in this disclosure as described above the first unit may determine coordinates for points along a second portion based on the determined coordinates for points along a first portion and in some examples based only on the points along the first portion. The techniques described this disclosure may allow for such determination of the coordinates of the second portion of the edge due to the symmetry between the points in the first and second portions.

Symmetry as used in this disclosure may refer to the condition that the points along the first portion appear as mirror points to the points along the second portion. In other words for a point in the first portion there is a mirror point in the second portion. This mirror point in the second portion may be considered as being symmetric to the point in the first portion.

For example assume that the first portion and the second portion are each half of the edge. In this example the first portion may be referred to as the first half of the edge and the second portion may be referred to as a second half of the edge. For instance the first half of the edge may start from a first end of the edge and end halfway up the edge. The second half of the edge may start halfway up the edge and end at a second end of the edge.

In this case assume that the length of the edge is one unit and that there is a point in the first half that is a distance D from the first end. In this example due to the symmetry there is a point in the second half that is a distance D from the second end. The point in the first half that is a distance D from the first end is considered to the mirror of the point that is a distance D from the second end. In other words each of these points in the first portion and the second portion are equidistant from the halfway point of the edge.

The tessellation unit may exploit this symmetry for purposes of determining coordinates of the edge. For example the coordinates of the points along the edge may be based on a normalized coordinate system in which the length of the edge is assigned to be one. In this case the first end of the edge may be represented with the coordinate value of 0 and the second end of the edge may be represented with the coordinate value of 1.

Accordingly keeping with the previous example a point that is a distance D away from the first end has a symmetric point that is a distance D away from the second end. If the coordinate of the point that is a distance D away from the first end is defined as D then the coordinate of its symmetric point is 1 D because the ends of the edge are at 0 and 1. This symmetry may allow the tessellation unit to determine the coordinate for one of the points in the first portion and determine the coordinate for its symmetric point in the second portion based on the determined coordinates for the point in the first portion. For example the tessellation unit may determine the coordinate for one point in the first half to be D and determine the coordinate for its symmetric point in the second half to be 1 D.

To expand this concept consider that a first set of coordinates are represented by X where X represents the coordinates for the points in the first portion edge which may be half of the edge. In this example the tessellation unit may determine the coordinates for the points in the second portion as being 1 X where 1 X represents the coordinates for the points in the second portion of the edge.

Due to this symmetric relationship the tessellation unit may be able to determine the coordinates of a point in the first portion and coordinates of a point in the second portion at same time e.g. in parallel . For example upon determining the coordinates of a point in the first portion the tessellation unit may store the coordinates in a buffer. At the same time or shortly thereafter the tessellation unit may also be able to store the coordinates for a point in the second portion by subtracting the coordinates of the point in the first portion from one to determine the coordinates of the point in the second portion. The tessellation unit may store the coordinates for the point in the second portion in the same buffer or a different buffer.

In this manner the tessellation unit may not need to waste computing cycles using complicated arithmetic to determine the coordinates of each of the points along the edge. Rather the tessellation unit may determine a first set of coordinate for points along a first portion of the edge and apply the simple arithmetic of subtraction the first set of coordinates from one to determine a second set of coordinates for points along a second portion of the edge. Also due to this simple arithmetic the tessellation unit may be able to determine the second set of coordinates at a time substantially the same as the time when the tessellation unit determined the first set of coordinates. This may allow the tessellation unit to output the first and second set of coordinates at substantially the same time rather than outputting each of the coordinates of the points along the edge one at a time.

The OpenGL 4.x graphics processing pipeline may function in a substantially similar fashion as the Direct3D graphics processing pipeline. Accordingly for purposes of brevity reference is made to to describe components that are similar to both the Direct3D graphics processing pipeline and the OpenGL 4.x graphics processing pipeline.

As illustrated in the example of GPU includes input assembler vertex shader tessellation control shader primitive generator tessellation evaluation shader geometry shader clipping unit rasterizer fragment shader and post processor . Similar to in the example illustrated in GPU may include more or fewer components than those illustrated in . Also the specific ordering of the unit is provided for purposes of illustration and should not be considered limiting.

In some ways the tessellation process with the OpenGL 4.x graphics processing pipeline may be substantially similar to the tessellation process with the Direct3D graphics processing pipeline. For example OpenGL 4.x tessellation process may rely upon patches and control points in the manner similar to that described above with respect to . For instance input assembler and vertex shader of may function substantially similar as input assembler stage and vertex shader stage of respectively.

For example in primitive generator may be equivalent or comparable to a tessellation unit. The tessellation unit may determine a number of points that reside along a first edge of a first ring within a domain. Additionally the tessellation unit may determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain. The tessellation unit may also determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion. The tessellation unit may also be configured to stitch points that reside along the first edge of the first ring with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch.

As more examples for tessellation tessellation control shader of may function substantially similarly to hull shader stage of . However tessellation control shader outputs tessellation levels which may be analogous to the tessfactors of Direct3D . For example the tessellation levels of OpenGL 4.x may define the domain type the number of rings within the domain and the number of points per ring edge.

Primitive generator may function in a substantially similar manner as tessellation stage . For example primitive generator may utilize the tessellation levels and the domain type to divide the domain into a plurality of primitives.

Tessellation evaluation shader of may function substantially similarly to domain shader stage of . For example tessellation evaluation shader may receive the vertices of the generated primitives from primitive generator and add the primitive to the patch outputted by tessellation control shader . In this manner the graphics processing pipeline of the OpenGL 4.x API may perform tessellation on a patch to increase the resolution of the patch.

Geometry shader may function substantially similar to geometry shader stage . The combination of clipping unit and rasterizer in may function substantially similarly to rasterizer stage in . Fragment shader and post processor in may function substantially similar to pixel shader stage and output merge stage in respectively. Post processor may output the final pixel values to a frame buffer and the display processor may retrieve the pixel values from the frame buffer and cause a display to illuminate according to the pixel values to display the image.

As described above tessellation control shader primitive generator and tessellation evaluation shader of function substantially similar to hull shader stage tessellation stage and domain shader stage of respectively for implementing the tessellation process. Accordingly both the Direct3D and the OpenGL 4.x APIs rely upon two programmable shader units and one fixed function unit to implement the tessellation process.

For purposes of generality the techniques described in this disclosure may be described with a first tessellation shader unit a tessellation unit and a second tessellation shader unit. Examples of the first tessellation shader unit include hull shader stage and tessellation control shader . Examples of the tessellation unit include tessellation stage and primitive generator . Examples of the second tessellation shader unit include domain shader stage and tessellation evaluation shader .

Also Direct3D uses the term tessfactors and OpenGL 4.x uses the term tessellation levels which may be considered analogous terms. For purposes of generality this disclosure uses the term tessellation factor examples of which include tessfactors and tessellation levels. In this way the first shader unit may be considered as outputting tessellation factors to the tessellation unit and the tessellation unit may output vertices to the second shader unit in response to the tessellation factors.

It should be noted that while the Direct3D and OpenGL 4.x utilize two shader units and one fixed function unit the techniques described in this disclosure are not so limited. For example it may be possible in other systems for the first and second shader units to be fixed function units and the tessellation unit to be a shader unit. As another example all may be fixed function units or all may be shader units or any combination thereof.

Therefore in some examples it may be considered that a first unit performs functions similar to the first shader unit but may be a shader unit or a fixed function unit a second unit performs functions similar to the tessellation unit but may be a shader unit or a fixed function unit and a third unit performs functions similar to the second shader unit but may be a shader unit or a fixed function unit. Moreover although the first shader unit the tessellation unit and the second shader unit are illustrated as separate units in aspects of this disclosure are not so limited. These units and possibly any unit of the graphics processing pipelines illustrated in may be combined together into a common unit. Accordingly while the functionality of these units is described separately for ease of description these units may be implemented in shared hardware or as distinct components.

In triangle domain includes outer ring and inner ring . Outer ring includes outer ring edge and inner ring includes inner ring edge . Outer ring edge and inner ring edge are parallel with one another. In aspects described in this disclosure the tessellation unit may use symmetry between the first and the second set of coordinates to potentially decrease calculating resources used to calculate the coordinates. For example the tessellation factors may define the number of points that reside along outer ring edge and the number of points that reside along inner ring edge . As indicated in there is an addition inner ring which is inner to inner ring edge . The tessellation unit may determine the first set of coordinates for a first portion of a particular edge e.g. outer ring edge to be a set of values X. The tessellation unit may determine the second set of coordinates for a second portion of the same edge e.g. outer ring edge to be 1 X based on the symmetry between the first and the second set of coordinates.

In an example using normalized coordinates a tessellation unit such as tessellation stage from or primitive generator from may determine the coordinates for a portion of an edge and use the symmetry to determine the other portion. The coordinates may be normalized. With normalized coordinates the ends are assumed be at 0 and at 1. For example in a normalized quad domain each of four edges may be normalized from 0 to 1 and may include Cartesian coordinates 0 0 1 0 0 1 1 1 and in a normalized triangle domain each of three edges may be normalized from 0 to 1 and may have Barycentric coordinates 0 0 1 0 1 0 1 0 0 . Additionally as discussed above when using normalized Barycentric coordinates in the triangular domain the sum of each coordinate set is always one.

In particular the tessellation unit may utilize the formula 1 to determine the coordinates for the other portion. In this example X n represents one of the coordinates and n is an integer value indicative of the number of points along a portion of an edge.

In one specific example used simply for purposes of illustration it may be assumed that the tessellation factors define that there are 10 points along an edge. It may also be assumed that the first portion and the second portion of the edge each include half of the points. Therefore there are 5 points per portion.

In this example the tessellation unit may determine the coordinates for 5 points i.e. n 1 to 5 for the other remaining points i.e. the remaining 5 points the tessellation unit may reuse the 5 points for the first portion. For instance the tessellation unit may implement the equation 1 X n where n 1 to 5. In this equation 1 X n represent the coordinates for points 6 through 10 on the edge.

The above equations may be generalized to X N n equals 1 X n where N is the total number of points on an edge and n ranges from 1 to the number of points in the first portion. Accordingly in this case X N n represents the coordinates for the points in the second portion and X n represents the coordinates for the points in the first portion. In this way the tessellation unit may be able to determine the second set of coordinates based on the determined first set of coordinates.

This allows the tessellation unit to perform fewer tasks to determine the coordinates of the points. It will be understood however that other numbers of points along the edge may be used e.g. other than 10 points . Generally the more points that are used the greater the detail that may be provided.

In the interconnection of the points that form the triangle may be based on the tessellation factors. For example the tessellation units described above may includes a first unit that determines a number of points that reside along a first edge of a first ring within a domain such as the edges of the triangle domain of and the quad domain divided illustrated in . As illustrated in the domains may be divided i.e. tessellated into a plurality of primitives.

The tessellation units described above may also determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion. As illustrated in different rings may be divided into different numbers of coordinates. Additionally each set of coordinates each point in the first portion of the points may be symmetric with a corresponding set of coordinates point in the second portion of the points.

The tessellation unit may also be configured to stitch points that reside along the first edge of the first ring with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch. In an example the first set of coordinates may include a first coordinate for a first point in the first portion of the points and the second set of coordinates includes a second coordinate for a second point in the second portion of the points. The first point and the second point are equidistant in opposite directions from a halfway location of the first edge.

Tessellation unit may include setup unit point generator and connectivity generator which may be fixed function hardware units of tessellation unit . Setup unit point generator and connectivity generator are illustrated as separate components for ease of description. Setup unit point generator and connectivity generator may be formed as a single unit as separate units or a combination thereof.

Setup unit may receive the tessellation factors as input a first shader unit such as hull shader stage of and tessellation control shader and may determine the domain type from the tessellation factors. For example if there are four tessellation factors setup unit may determine that the domain type is a triangle and if there are six tessellation factors setup unit may determine that the domain type is a quad. Setup unit may perform other setup functions such as correcting rounding problems ceiling and floor functions determining half tessellation factors and reducing and combining tessellation factors. In general setup unit may process the tessellation factors to ensure that the other components of tessellation unit can perform respective functions.

Point generator may determine how many points reside along each edge of each ring of the domain from the tessellation factors and the locations of the points e.g. the u v coordinates or the u v w coordinates of the points . Connectivity generator may connect i.e. stitch the points to form a plurality of primitives in the domain such as those illustrated in .

Accordingly the tessellation unit determines a number of points that reside along a first edge of a first ring within a domain. This may be accomplished using the point generator . Point generator may also determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain and determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion.

For example point generator may determine coordinates of points along an outer ring edge such as outer ring edge and outer ring edge of respectively. In some examples point generator may store the determined coordinates in a buffer such as buffer in point generator of . In an example point generator may store the first set of coordinates for the first portion of outer ring edge or in buffer while storing the second set of coordinates for the second portion of outer ring edge or in another buffer. Point generator may determine the second set of coordinates for the points of the second portion of outer ring edge or outer ring edge based on the determined coordinates for the first set of coordinates. This may be accomplished based on symmetry between the first and the second set of coordinates. In another example point generator may store both the first and the second set of coordinates in buffer .

It will be understood however that buffer is illustrated in point generator for ease of description. Buffer may be located within tessellation unit and may couple to both point generator and connectivity generator . Alternatively buffer may be located within a local memory such as cache memory of GPU . In some examples buffer may be located within system memory .

In accordance with one or more examples similar to those described above when the point generator divides an edge into points each of the points is spaced an equal distance apart from any left or right neighboring points. As an example if the tessellation factor instructs point generator to divide an edge into five points an odd tessellation factor the point generator may divide the edge into points at x coordinates 0 0.25 0.5 0.75 and 1. As an example if the tessellation factor instructs the point generator to divide the edge into four points an even tessellation factor the point generator may divide the edge into points located at x coordinates 0 0.33 0.66 and 1. In both of the previous examples there is symmetry between most of the points. For example one point may be calculated from another point using the formula 1 where i is the index from 0 to the of points 1 of a point n is the of points 1 and x is the function that returns the x coordinate of the point. The equation x Pi 1 x Pn i may be a restatement of the above equation X N n 1 X n and is provided to further assist with understanding. As an example if there are five points each numbered 0 through 4 denoted as P0 . . . P4 the point at position may be calculated as 3 1 4 3 3 1 1 Substituting the value of 1 0.25 3 1 0.25 3 0.75

Thus the x coordinate value of the point at position is 0.75. Based on this symmetry the number of calculations required to determine the x coordinate of each point may be reduced by using the above calculation rather than by determining the x coordinate for each point on an edge individually. For instance in the previous example point generator may determine the coordinate for P1 and from the value of P1 determine the value of P3. In this way the techniques of this disclosure may exploit symmetry among points that reside on a normalized edge to determine the coordinates for such symmetrical points.

For each edge of the outer ring that is parallel with an edge of the inner ring connectivity generator may determine how the points of the outer ring edge should connect with the points of the inner ring edge to form primitives. For instance there may be at least two different ways in which points along the outer ring edge and the points along the inner ring edge can form triangles. As one example connectivity generator may form a triangle using two points from the outer ring edge and one point from the inner ring edge and connect them together to form a triangle. As another example connectivity generator may form a triangle using two points from the inner ring edge and one point from the outer ring edge to form the triangle. Accordingly the connectivity generator may stitch points that reside along the first edge of the first ring with points that reside along a second edge of a second ring to divide the domain into a plurality of primitives that are mapped to a patch.

In an example system a tessellation unit may determine a number of points that reside along a first edge of a first ring within a domain . This may occur for example in point generator of . For example the tessellation unit may receive a tessellation factor for an edge of a ring. The tessellation unit may also receive as input a depth level value which is one example of a tessellation factor.

The tessellation unit may determine a first set of coordinates for a first portion of the points that reside along the first edge of the first ring within the domain . This may also occur for example in point generator of . The coordinates may be generated for a unit quad domain or a unit triangle domain for example. Such domains may be normalized. For example a normalized quad domain may have each of four edges normalized from 0 to 1 and have coordinates 0 0 1 0 0 1 1 1 and a normalized triangle domain may have each of three edges normalized from 0 to 1 and have coordinates 0 0 1 0 1 0 1 0 0 . Additionally as discussed above when using normalized Barycentric coordinates in the triangular domain the sum of each coordinate set is always one e.g. for 0 0 1 0 0 1 1 for 0 1 0 0 1 0 1 and for 1 0 0 1 0 0 1.

For each edge of the ring the point generator may divide the edge into the number of points specified by the tessellation factor for that edge. Based on the tessellation factor point generator may repeat the process of subdividing edges into points once for each level of depth. For each level of depth point generator converges toward the center of the domain and subdivides not the original edge but a concentric edge. Thus for each level of depth a concentric shape that is the same as the domain is subdivided into the number of points specified by the tessellation factor for that edge. If the depth level is even the point generator may create the final depth level as a single point rather than as a concentric version of the patch.

The tessellation unit may determine a second set of coordinates for a second portion of the points that reside along the first edge of the first ring within the domain based on the first set of coordinates for the first portion . This may also occur for example in point generator of . For example the tessellation unit may be designed to determine the coordinates of two symmetrical points of an edge in parallel to increase throughput. In this example the tessellation unit may be configured to include point generator capable of outputting two x y coordinate pairs simultaneously. Point generator may transmit the x y coordinate pairs for both points to the connectivity generator in parallel. In some examples Connectivity generator may be configured to receive two x y coordinate points at a time. In the case where connectivity generator is capable of receiving two x y coordinate pairs simultaneously the tessellation unit may include two 4 deep first in first out FIFO queues that is two FIFOs capable of holding 4 x y coordinate pairs . For example the tessellation unit the local memory of GPU or system memory may include two buffers where each of the two buffers is a 4 deep FIFO queue.

The tessellation unit may stitch one or more points that reside along the first edge of the first ring. This may also occur for example in connectivity generator of . The stitching may be based on the first set of coordinates and the second set of coordinates. Points that reside along a second edge of a second ring may divide the domain into a plurality of primitives that may be mapped to a patch to increase a resolution of the patch. The second ring may be inner to the first ring within the domain.

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

