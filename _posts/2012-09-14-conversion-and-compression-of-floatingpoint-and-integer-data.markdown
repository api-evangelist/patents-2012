---

title: Conversion and compression of floating-point and integer data
abstract: Compression and decompression of numerical data can apply to floating-point or integer samples. Floating-point samples are converted to integer samples and the integer samples are compressed and encoded to produce compressed data for compressed data packets. For decompression, the compressed data retrieved from compressed data packets are decompressed to produce decompressed integer samples. The decompressed integer samples may be converted to reconstruct floating-point samples. Adaptive architectures can be applied for integer compression and decompression using one or two FIFO buffers and one or two configurable adder/subtractors. Various parameters can adapt the operations of adaptive architectures as appropriate for different data characteristics. The parameters can be encoded for the compressed data packet. This abstract does not limit the scope of the invention as described in the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104473&OS=09104473&RS=09104473
owner: Altera Corporation
number: 09104473
owner_city: San Jose
owner_country: US
publication_date: 20120914
---
This application claims benefit of U.S. Provisional Patent Application No. 61 618 509 filed on 30 Mar. 2012 entitled CONVERSION AND COMPRESSION OF FLOATING POINT AND INTEGER DATA.

This application is related to co pending U.S. Patent Application No. 61 618 534 filed on 30 Mar. 2012 entitled DATA COMPRESSION FOR DIRECT MEMORY ACCESS TRANSFERS and is also related to co pending U.S. Patent Application No. 61 618 463 filed on 30 Mar. 2012 entitled PROCESSING SYSTEM AND METHOD INCLUDING DATA COMPRESSION API all of which are incorporated by reference.

The present invention relates to compression of numerical data represented in a floating point format or an integer format for efficient storage and transfer in a computing system. In particular the floating point data are converted to integer or fixed point representations prior to compression processing.

In present high performance computing applications it is often necessary to transfer vast amounts of numerical data among multiple processor cores or between processor cores and memory. The limited data transfer rates of interfaces among processor cores and between cores and memory devices can create bottlenecks for overall data processing speed and performance. In data rich applications storage of numerical data challenges memory and network resources and storage devices. Reducing the demands on data transfer and storage capacity for numerical data can improve the efficiency economy and performance of the computing system. Compression of the numerical data may reduce these demands however at the cost of additional computations. In applications having vast quantities of numerical data it is especially important that the compression be computationally efficient in order to minimize demands on computing resources.

Commonly owned patents and applications describe a variety of compression techniques applicable to fixed point or integer representations of numerical data or signal samples. These include U.S. Pat. No. 5 839 100 the 100 patent entitled Lossless and loss limited Compression of Sampled Data Signals by Wegener issued Nov. 17 1998 and the U.S. patent application Ser. No. 12 605 245 the 245 application entitled Block Floating Point Compression of Signal Data publication number 2011 0099295 published Apr. 28 2011. The commonly owned patent application Ser. No. 12 891 312 the 312 application entitled Enhanced Multi processor Waveform Data Exchange Using Compression and Decompression by Wegener publication number 2011 0078222 published Mar. 31 2011 incorporated herein by reference describes configurable compression and decompression for fixed point or floating point data types in computing systems having multi core processors. In a multi core processing environment input intermediate and output waveform data are often exchanged among cores and between cores and memory devices. The 312 application describes a configurable compressor decompressor at each core that can compress decompress integer or floating point waveform data. The 312 application describes configurable compression decompression at the memory controller to compress decompress integer or floating point waveform data for transfer to from off chip memory in compressed packets. The configurable compressor and decompressor of the 312 application may be configured to apply the compression and decompression described in the present application. The commonly owned non provisional patent application Ser. No. 13 534 330 filed Jun. 27 2012 entitled Computationally Efficient Compression of Floating Point Data describes algorithms for direct compression floating point data by processing the exponent values and the mantissa values of the floating point format.

In order to better meet the requirements of higher speed data transfer reduced memory utilization and minimal computation in many computing applications a need exists for computationally efficient compression and decompression of floating point data and integer data.

Data transfer operations for numerical data among components of a computer system are augmented by compression. Floating point samples are converted to integer samples and the integer samples are compressed and encoded to produce compressed data for compressed data packets. The compressed data packets allow efficient data transfer among computer system components such as transfers between processor cores in a multi core computer architecture transfers between the processor and memory transfers between two memories such as on chip and off chip . For decompression the compressed data retrieved from compressed data packets are decompressed to produce decompressed integer samples. The decompressed integer samples may be converted to reconstruct floating point samples.

The floating point to integer conversion applies a scale factor to a plurality of the floating point samples. The scale factor can be included in the compressed data packet. The integer to floating point conversion applies the scale factor to the corresponding plurality of decompressed integer samples.

An adaptive architecture can be applied for integer compression. A number of previous integer samples can be stored in a first in first out FIFO buffer where one is selected for addition or subtraction operations with a current integer sample to give a first result sample. In one alternative selection of the current integer sample or the first result sample can provide a compressed integer sample. In another alternative a number of previous first result samples can be stored in a second FIFO buffer where one is selected for addition or subtraction with a current first result sample to give a second result sample. In another alternative previous integer samples can be stored in a second FIFO buffer where one is selected for addition or subtraction with the current integer sample to give a second result sample. A selection of the current integer sample the first result sample or the second result sample provides a compressed integer sample. The selection can be based on the alternative that provides more efficient compression. The compressed integer sample is encoded for the compressed data packet. Various parameters can adapt the operations of adaptive compression architecture. The parameters can be encoded for the compressed data packet.

For decompression of the compressed data packet the compressed data are decoded to produce decoded integer samples. Parameters for decompression can also be recovered from the compressed data packet.

An adaptive architecture for integer decompression can be applied to decoded integer samples to produce decompressed integer samples. A number of previous decoded integer samples can be stored in a FIFO buffer where one is selected for addition or subtraction operations with a current decoded integer sample to give a first result sample. In one alternative selection of the current decoded integer sample or the first result sample can provide a decompressed integer sample. In another alternative a number of previous first result samples can be stored in a second FIFO buffer where one is selected for addition or subtraction with a current first result sample to give a second result sample. In another alternative previous decoded integer samples can be stored in a second FIFO buffer where one is selected for addition or subtraction with the current decoded integer sample to give a second result sample. A selection of the current decoded integer sample the first result sample or the second result sample provides a decompressed integer sample. Parameters are provided to the adaptive decompressor to invert the compression operations.

For floating point data the decompressed integer samples are converted back to the floating point format to provide reconstructed floating point samples.

Embodiments of the compression and decompression described herein may encompass a variety of computing architectures that represent digital data numerically using a floating point format referred to herein as floating point data floating point numbers and floating point samples or an integer format. The digital data may be generated by a variety of applications and the computing architectures may be general purpose or specialized for particular applications. The digital data may result from detected data from a physical process a data created by computed simulation or intermediate values of data processing. For example the digital data may arise from analog sensor signals that are converted by an analog to digital converter ADC to a digital signal whose sample values are represented in a floating point format. For another example the digital data may be spatial data points for a simulated computer graphics image having two or more dimensions.

User interface input devices may include a keyboard pointing devices such as a mouse trackball touchpad or graphics tablet a scanner a touch screen incorporated into the display audio input devices such as voice recognition systems microphones and other types of input devices. In general use of the term input device is intended to include all possible types of devices and ways to input information into computer system .

User interface output devices may include a display subsystem a printer a fax machine or non visual displays such as audio output devices. The display subsystem may include a cathode ray tube CRT a flat panel device such as a liquid crystal display LCD a projection device or some other mechanism for creating a visible image. The display subsystem may also provide non visual display such as via audio output devices. In general use of the term output device is intended to include all possible types of devices and ways to output information from computer system to the user or to another machine or computer system.

Storage subsystem stores the basic programming and data constructs that may provide some or all of the functions for the format conversion compression and or decompression described herein. These software modules are generally executed by processor . The processor s may include one or more of a DSP microprocessor microcontroller CPU or GPU or a combination of these devices. The processor s may also include dedicated application specific integrated circuit ASIC or field programmable gate array FPGA logic implementing some or all of the format conversion compression and or decompression functionality.

Memory subsystem typically includes a number of memories including a main random access memory RAM for storage of instructions and data during program execution and a read only memory ROM in which fixed instructions are stored. File storage subsystem provides persistent storage for program and data files and may include a hard disk drive a floppy disk drive along with associated removable media a CD ROM drive an optical drive or removable media cartridges including Universal Serial Bus USB thumb drives with USB interface and flash media storage. The databases and modules implementing the functionality of certain embodiments may be stored by file storage subsystem .

Bus subsystem provides a mechanism for letting the various components and subsystems of computer system communicate with each other as intended. Although bus subsystem is shown schematically as a single bus alternative embodiments of the bus subsystem may use multiple busses.

Computer readable medium can be a medium associated with file storage subsystem and or with communication interface subsystem . The computer readable medium can be a hard disk a floppy disk a CD ROM an optical medium removable media cartridge USB thumb drive flash media storage or electromagnetic wave. The computer readable medium is shown storing a compressed data file . The computer readable medium may also store programs implementing the functions of format conversion compression and or decompression.

Computer system itself can be of varying types including a personal computer a portable computer a workstation a computer terminal a network computer a mainframe a television a smart phone a tablet computer or any other data processing system or user device. Due to the ever changing nature of computers and networks the description of computer system depicted in is intended only as a specific example for purposes of illustrating the preferred embodiments. Many other configurations of computer system are possible having more or fewer components than the computer system depicted in .

Data transfer interfaces in a computer system or network of computer systems may generally include interfaces connecting processing units memories including off chip memory external storage devices and data acquisition devices. The architectures described with respect to give examples of data transfer interfaces in a computer system or network of computer systems. The compression described herein speeds the data rate by reducing the number of bits per sample to be transferred across the data transfer interfaces. Faster data transfer improves the system performance because it reduces the time that processors wait for data. The compression and decompression described below uses simple operations for computational efficiency and low latency.

The floating point compression processing converts the floating point data to integer samples and compressing the integer samples to form the compressed data. For decompression processing the compressed data are decompressed to produce decompressed integer samples that may be converted back to the floating point format. The integer compression processing may be applied to original integer samples or to converted integer samples.

The float to integer format converter may normalize a set of input floating point numbers by using a scale factor to form a set of normalized floating point numbers. Normalization adapts the range of the fixed point integer samples to the range of a particular set of input floating point samples thus preserving more accuracy. Alternatives for determining the scale factor for the set of input floating point numbers include the following 

The first option for the scale factor produces scaled floating point numbers where the maximum magnitude in the set is 1.0 or less so that floating point numbers in the set will have values in the range of 1.0 1.0. The second option reduces the computational latency for the current set. After normalization the float to integer format converter converts the scaled floating point numbers to integer numbers.

In an alternative embodiment the float to integer format converter determines the maximum exponent value of the floating point numbers in the set. For this alternative the float to integer format converter may provide approximate normalization during format conversion without a multiplication by the floating point scale factor F SCALE. This reduces computational complexity by eliminating the floating point multiplier. The approximate normalization provides magnitude values less than 2.0 for the set. Alternatives for determining the maximum exponent value for the set include the following 

The multiplier multiplies the resulting value F SCALE with each floating point number in the set by to form a scaled floating point number. The rounding block includes logic to round each scaled floating point number to provide the output integer number. The integer number is represented in a binary two s complement format having Nbit bits. The two s complement integer format is used for illustrative purposes. The particular integer format does not limit the scope of the invention as the floating point data may be converted to other integer formats.

Alternatively the integer compressor logic may provide other types of compression such as predictive compression as described by Moriya et al. in the U.S. Pat. No. 7 230 551 entitled Floating Point Type Digital Signal Reversible Encoding Method Decoding Method Apparatuses Therefor and Programs Therefor .

For the first group of samples the exponent n exp 0 is directly encoded. For example the exponent n exp 0 can be encoded as follows where S is the original number of bits per sample 

For the igroup the exponent n exp i may be differentially encoded using a prefix code where no codeword is the prefix of another codeword. An example of differential encoding is as follows 

Huffman encoding of the exponent differences assigns tokens of different lengths to the exponent differences based on their frequencies of occurrence. Shorter Huffman tokens may be assigned to the more frequent values of exponent differences. The exponents n exp i may be directly encoded for example by Huffman encoding instead of differentially encoded. Alternatives for encoding the block exponents are described below.

Encoding the mantissas and exponents separately can provide additional compression and mitigate compression error. In one embodiment for exponent encoding two or more exponent difference values are jointly encoded. A statistical analysis of block exponent values for signal data from various applications including ultrasound radar and computed tomography raw data showed that 90 of consecutive exponents have differences in the range of 1 0 1 and that 98 of consecutive exponents have differences in the range 2 1 0 1 and 2. Jointly encoding two or more successive exponent differences can reduce the number of bits per encoded exponent. An encoding scheme that uses four or eight bits for an exponent token is given in . By using a fixed number of exponent bits the complexity of both compression and decompression is reduced when compared to exponent encodings that permit exponent tokens having arbitrary bit lengths. FIG. s table lists exponent token values for three encoding options A jointly encoding two successive exponent differences B encoding one exponent difference and C absolute or linear encoding of one exponent value. The successive exponent differences diff i diff i 1 for the joint encoding option A given in the third column have nine different combinations of difference values in which both the first and the second encoded exponent difference have one of three possible values 1 0 1. These nine of sixteen combinations in the table may be encoded using exponent tokens having 4 bits each. Since one token encodes the exponents for two blocks the joint encoding of exponent differences uses 2 bits per block exponent. Encoding of a single exponent difference in the range 2 1 0 1 2 and the associated exponent tokens are listed for option B . This option uses five of the sixteen combinations in the table. Finally absolute encoding for the exponent value itself n exp i listed for option C uses 8 bits per exponent token. In this embodiment the top three bits are set to 1 s and the bottom five bits encode the exponent. The top three bits set to 1 s indicate that the exponent is absolutely encoded i.e. the exponent itself is sent in the exponent token rather than the difference between the current exponent and the previous exponent. The five lower bits indicate one absolute exponent in the range 0 2 3 . . . 32 where an exponent value of 1 is not allowed. Using an integer number of nibbles 4 bit units simplifies exponent encoding and later decoding. Applying the exponent encoding of to the signal data from the above applications showed the following proportions for the exponent encoding options 

The weighted average of the bits exponent for each of the options indicates that the average number of bits per encoded exponent is about 2.48 bits. Since there are N GROUP individual samples per encoded exponent the exponent encoding scheme provides substantial efficiency when compared to alternative exponent encoding techniques especially those using one exponent per mantissa.

For efficient encoding and decoding of packets the compressed data for all the samples represented by the packet are contained within the packet. Absolute encoding the first block exponent of the packet makes the first exponent token independent of the previous packet. The final block exponent of the packet may be differentially encoded with the next to last block exponent of the packet. The exponent difference corresponding to the last block exponent and the previous block exponent may be jointly encoded with the previous exponent difference within the same packet but may not be jointly encoded with the first exponent difference of the subsequent packet.

The bit packer may pack a single exponent token followed by the corresponding signs and mantissas in the compressed packet. The exponent token may correspond to A joint encoding of two exponent differences B encoding of one exponent difference and C absolute encoding of one exponent value. The number of mantissas following the exponent token depend on the encoding option A B or C . For encoding option A the exponent token is followed by 2 N GROUP mantissas. For encoding options B and C the exponent token is followed by N GROUP mantissas as illustrated in . Alternatively the bit packer may pack two or more exponent tokens followed by the corresponding mantissas and signs. This alternative may be more efficiently implemented in SIMD single input multiple data architectures.

Referring to the compression controller provides compression parameters to one or more of the float to integer format converter integer compressor logic the block floating point encoder and the bit packer . The compression controller may provide a parameter indicating for example whether the data type of the input sample such as single or double precision and a parameter indicating whether F SCALE or EXP SCALE will be used by to the float to integer format converter . The compression parameters used by the integer compressor logic may include an attenuation parameter used by the attenuator . Derivative parameters used by the derivative processor may include the derivative order i.e. first second or no derivative and sample spacing for difference calculations. The compression controller may calculate these parameters to achieve lossless fixed rate or fixed quality of compressed data. The fixed rate or fixed quality modes or compression may be lossy. In lossy compression the decompressed or reconstructed signal samples are similar but not identical to the original samples. The compression controller may support fixed rate compression by receiving information on compressed packet size from the bit packer and adjusting the compression parameters to increase or decrease compression as described in the 533 patent. For the BFP encoder the compression parameters may include the block size parameter N GROUP. The compression controller can respond to user input to select the compression parameters. The user may select compression parameters that provide a fixed bit rate of compressed data or a fixed quality metric or level of distortion of the compressed data.

The bit packer may provide a header section in the compressed data packet. The header section may contain information to be used for decompressing the compressed data reconstructing the floating point data converting the compressed data to another format or other information used for processing the data. For example information for reconstructing the data sequence includes synchronization information number of samples number of bits per sample and data type of the original data. For reconstructing the floating point numbers the parameters EXP SCALE or F SCALE determined by the float to integer format converter may be included in the header. Compression parameters used by the integer compressor logic may include an attenuation parameter used by the attenuator and derivative parameters used by the derivative processor such as the derivative order i.e. first second or no derivative and sample spacing for difference calculations. For the BFP encoder the block size parameter N GROUP may be included in the header. To support decompression the packet header is decoded to generate the parameters for decoding of the compressed data and optionally to re sequence the decompressed samples.

The block includes logic to determine which of alternatives x n x1 n or x2 n for the current packet would produce the least number of bits or most compression for a compressed packet. A selection parameter corresponding to the alternative with the most compression is provided to the fourth selector and stored in the packet header of the next packet. The selector applies the selection parameter to samples for the next packet. Determining the selection for the next packet based on the current packet data reduces the latency of compression processing. Alternatively the selection parameter may be based on the current packet data and stored in the current compressed packet if the latency to determine the minimum bits per packet is tolerable. Alternatively the selection of x n x1 n or x2 n may be made during a training period and fixed for subsequent packets. Alternatively the selector may use a manually set selection parameter received from the compression controller .

When the compression processing uses the block floating point encoder the logic block may determine which of the alternatives x n x1 n and x2 n produces the most compression as follows 

While the above may not explicitly calculate the exact number of bits per compressed packet for each alternative the alternative producing the best compression is indicated by the lowest total. Alternatively the maximum magnitude sample max i in each block N GROUP samples for each alternative can be substituted for n exp i .

The adaptive compressor supports compression of multidimensional data structures or multiplexed data structures. Certain parameter settings for the components in are appropriate for compression for two dimensional 2D data such as image samples. For example let N equal the number of samples representing a row of a 2D data set or an image so that a sequence of the integer samples x n represents row ordered samples of two or more rows of the 2D data set where x 0 to x N 1 is the first row x N to x 2N 1 is the second row etc. When the first selector is set to select x N and the first adder subtractor is configured to subtract the resulting x1 n x n x n N is the difference between corresponding samples in adjacent rows. When the second selector is set to select 1 the third selector is set to select 0 and the second adder subtractor is configured to subtract the resulting x2 n x n x n 1 is the sample difference within the same row. The fourth selector would select the input sample x n the row difference sample x1 n or the sample difference x2 n for block floating point encoding.

For multiplexed data a sequence of samples x n may represent multiple channels of data such as data from multiple sensors multiplexed together to form the sequence. For example N may represent the number of multiplexed channels where x n to x n N 1 represent one sample from each channel at a given time instant and x n N represents two temporally consecutive samples from the same channel. When the first selector is set to select x n N and the first adder subtractor is configured to subtract the resulting x1 n x n x n N is the difference between temporally consecutive samples from the same data channel. When the second selector selects samples from a second channel offset from the first channel and the second adder subtractor is configured to subtract the difference x2 n x n x n p is the difference between two different channels at a given time instant. The difference between channel data may provide compression when the different channels are correlated. The selector would select the input sample x n the intra channel difference x1 n or the inter channel difference x2 n for block floating point encoding.

The adaptive compressor supports compression of data having different center frequencies. As described in the 533 patent the sample separations and the addition or subtraction operations may be selected to optimally compress the samples based on their center frequency. The preprocessor may include a center frequency detector to determine the center frequency. Techniques for center frequency detection are described in the 533 patent. shows a table of parameter settings as a function of the center frequency. The center frequency is indicated as a fraction of the sample rate SR. The sample separation parameter may be used by selectors and . The selection parameter for the third selector is set to 1 for calculating second order derivatives. The add subtract configurations apply to both adder subtractors and . The selection of addition or subtraction is related to the positive or negative correlation of the samples separated by the sample separation parameter corresponding to the center frequency.

The fourth selector makes selections of x n or x1 n to initialize the data for the compressed packet. For initialization the fourth selector may select the sample x n for absolute encoding as the initial sample of the compressed packet. Thus when the first derivatives or differences x1 n are to be encoded for a particular compressed packet at least the initial sample for the packet will be the absolutely encoded x n . When the second derivatives x2 n are to be encoded for a particular compressed packet the fourth selector may select the sample x n for the initial sample and the first derivative x1 n for the second sample of the compressed packet. This initialization may be performed at least once per compressed packet.

The compression controller may provide the parameters for the components of the adaptive compressor architecture including an attenuation factor for the attenuator the sample separation parameter for the selectors and add subtract selection parameter for the adder subtractors and and selection parameter for the third selector . The compression controller may store configuration parameters corresponding to multiple data structures in memory. When a particular data structure is to be compressed the compression controller may retrieve the appropriate parameters and provide them to the corresponding components of the adaptive compressor. Data structure information may include for example multidimensional data parameters or multiplexed data parameters. The compression controller may receive information on center frequency for example from the preprocessor and select the corresponding parameters for the components of the adaptive compressor as described with respect to .

The decoded samples output from the BFP decoder may comprise the decompressed integer samples or alternatively additional decompression operations by the integer decompression logic may be applied as indicated by compression parameters in the compressed data packet header. The compression parameters extracted from the compressed data packet and provided to the decompression controller will indicate further decompression operations corresponding to the compression operations applied to the compressed samples in the packet. The integer decompression logic performs the inverse operation of the integer compressor logic in accordance with the compression parameters received from the decompression controller . For example the integer decompression logic may calculate the first or higher order integrals of the decoded samples received from the BFP decoder in response to a derivative order parameter included with the compression parameters. For another example the integer decompression logic may multiply the integer samples by a gain factor based on a compression parameter.

The adaptive decompressor architecture supports decompression of multidimensional data structures or multiplexed data structures using parameter settings described with respect to the adaptive compressor architecture of . For the 2D data set example where N equals the number of samples representing a row of a 2D data set or an image the first selector is set to select s N and the first adder subtractor is configured to add the resulting s1 n s n s n N sums the decoded samples to reverse the difference operation of adjacent rows performed for compression. When the second selector is set to select 1 the third selector is set to select 0 and the second adder subtractor is configured to add the resulting s1 n s n s n 1 sums decoded samples to reverse the difference operation of samples within the same row performed for compression. For the multiplexed data example described above N represents the number of multiplexed channels. When the first selector is set to select s n N and the first adder subtractor is configured to add the resulting s1 n s n s n N reverses the difference between temporally consecutive samples from the same data channel performed for compression. When the second selector selects samples from the second channel offset from the first channel and the second adder subtractor is configured to add the difference s2 n s n s n p reverses the difference between two different channels performed for compression. The fourth selector selects from s n s1 n or s2 n based on the compression parameter from the compressed packet header.

The adaptive decompressor architecture supports decompression of data having different center frequencies. The selectors and select sample spacing and the addition or subtraction operations to reverse the operations performed by the adaptive compressor the samples based on their center frequency. The selection parameter for the third selector is set to 1 for calculating second order integrals. The configurations of the adder subtractors and reverse the operations of the adder subtractors and .

The fourth selector makes selections of s n or s1 n corresponding to the initialized data of the compressed packet. When the first derivatives or differences x1 n were encoded for a particular compressed packet at least the initial sample for the packet will be absolutely encoded. For the initial decoded sample from the compressed packet the fourth selector may select s n as the initial sample. The fourth selector would select the first integral s1 n for the remaining decoded samples from the compressed packet. When the second derivatives x2 n were encoded for a particular compressed packet the fourth selector may select the sample s n for the initial sample and the first integral s1 n for the second sample and the second integral s2 n for the remaining decoded samples from the compressed packet. This initialization may be performed at least once for decoded samples from a compressed packet depending on the initialization performed during compression.

The decompression controller may provide the decompression parameters for the components of the adaptive decompressor including the gain factor for the multiplier the sample separation parameters for the selectors and add subtract configuration parameters for the adder subtractors and and selection parameters for the selectors and . The decompression controller may determine the decompression parameters based on the compression parameters from the compressed data packet header.

The integer to float format converter may be applied to the decompressed integer samples output from the integer decompression logic or the BFP decoder to reconstruct the floating point data. A first alternative for integer to float format converter corresponds to the float to integer format converter that uses the F SCALE factor described with respect to . This integer to float format conversion implements the following fp samp int samp F 3 where fp samp indicates the reconstructed floating point sample and int samp indicates the decompressed integer sample output from the BFP decoder or the integer decompression logic .

To reconstruct the mantissa the left shifter shifts the selected mantissa based on the left shift value e shift and block clears the hidden bit. For the IEEE 754 standard the reconstructed mantissa would have 23 bits for single precision or 52 bits for double precision. To reconstruct the exponent the adder computes the difference of e shift and EXP SCALE. For the IEEE 754 standard the reconstructed exponent would have 8 bits for single precision or 11 bits for double precision. Alternatively when the original floating point number was scaled by F SCALE the EXP SCALE value and the adder are not used. In this case the e shift provides the exponent value exp and the reconstructed floating number is divided by F SCALE. Preferably the F SCALE or EXP SCALE parameter is retrieved from the packet header of the compressed data packet.

The embodiments of the integer and floating point compression and decompression described herein may be implemented in a variety of computing architectures. For example the above referenced 312 application describes configurable compressors decompressors for integer or floating point data compression in a multi core computing architecture. The compression and decompression technology described herein may be applied by the configurable compressors and decompressors described in the 312 application.

My above referenced patent applications entitled Processing System and Method Including Data Compression API and Data Compression for Direct Memory Access Transfers describe embodiments that can be applied for the integer and floating point compression and decompression described herein. An application programming interface API including a set of operations and parameters for the operations provides for data compression and decompression during or in conjunction with processes for moving data between memory elements of a memory system in a computer system. The set of operations can be configured to use the parameters and perform the operations of the API. One example set of operations of an API for compression and decompression includes functions that support direct memory access DMA operations. A compression channel DMA transfer can compress a specified data set from a first memory element for transfer and storage as a compressed data set in a second memory element. Compression channel descriptors for an API can be associated with a DMA operation using the compression functions. The register set holding the compression function descriptors can be written and controlled by a component or components of a compression decompression library implementing the API. The compression DMA descriptor can include parameters indicating number and length of compressed data packets for the compressed data set and parameters to configure compression operations such as parameters that are manual settings initial settings determined by other functions of the data processing or that are constant for a particular data set to be compressed. For a decompression channel DMA transfer a compressed data set is transferred from the second memory element and decompressed prior to storage in the first memory element. Decompression channel descriptors for an API can be associated with a DMA operation using the decompression functions. A register set holding the decompression function descriptors can be written and controlled by a component or components of a compression decompression library. The decompression DMA descriptor can include parameters indicating number and length of compressed data packets for the compressed data set to be decompressed.

The floating point compression and decompression operations can be implemented in hardware software or a combination of both and incorporated in computing systems such as those described in . The hardware implementations include ASIC FPGA or an intellectual property IP block. The floating point compression and decompression operations can be implemented in software or firmware on a programmable processor such as a digital signal processor DSP microprocessor microcontroller multi core CPU or GPU.

The logic blocks shown in for floating point data conversion and compression and in for decompression and optional conversion back to floating point data as described above can be implemented using FPGA circuits. For implementation using FPGA circuits the technology described here can include a memory storing a machine readable specification of the compression logic and a machine readable specification of the decompression logic in the form of a configuration file for the FPGA block. The logic blocks shown in for compression and for decompression may be described using computer aided design tools and expressed or represented as data and or instructions embodied in various computer readable media in terms of their behavioral register transfer logic component transistor layout geometry and or other characteristics. A machine readable specification of the compression logic and a machine readable specification of the decompression logic can be implemented in the form of such behavioral register transfer logic component transistor layout geometry and or other characteristics. Formats of files and other objects in which such circuit expressions may be implemented include but are not limited to formats supporting behavioral languages such as C Verilog and VHDL formats supporting register level description languages like RTL and formats supporting geometry description languages such as GDSII GDSIII GDSIV CIF MEBES and any other suitable formats and languages. A memory including computer readable media in which such formatted data and or instructions may be embodied include but are not limited to computer storage media in various forms e.g. optical magnetic or semiconductor storage media whether independently distributed in that manner or stored in situ in an operating system .

When received within a computer system via one or more computer readable media such data and or instruction based expressions of the above described circuits may be processed by a processing entity e.g. one or more processors within the computer system in conjunction with execution of one or more other computer programs including without limitation netlist generation programs place and route programs and the like to generate a representation or image of a physical manifestation of such circuits. Such representation or image may thereafter be used in device fabrication for example by enabling generation of one or more masks that are used to form various components of the circuits in a device fabrication process.

While the preferred embodiments of the invention have been illustrated and described it will be clear that the invention is not limited to these embodiments only. Numerous modifications changes variations substitutions and equivalents will be apparent to those skilled in the art without departing from the spirit and scope of the invention as described in the claims.

