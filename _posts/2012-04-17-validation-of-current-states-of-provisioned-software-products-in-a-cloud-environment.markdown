---

title: Validation of current states of provisioned software products in a cloud environment
abstract: In one aspect, a state file is received that describes a desired state of a provisioned software product started in a cloud environment. The state file defines the bundles to be installed and their desired state. The desired states of the bundles are read from the state file. Currently installed bundles, from the provisioned software product, are analyzed together with current states of the currently installed bundles. The specified bundles in the state file are compared to the currently installed bundles. The current states of the currently installed bundles are compared to the desired states from the state file to determine whether a current state of the provisioned software product corresponds to the desired state.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08839223&OS=08839223&RS=08839223
owner: SAP AG
number: 08839223
owner_city: Walldorf
owner_country: DE
publication_date: 20120417
---
Cloud computing is the delivery of computing resource as a service over a network e.g. the Internet . There are a number of types of cloud computing solutions that have been developed. Software as a Service SaaS is a type of a solution where a cloud service provider allows software applications and various hardware and software resources to execute the software application when requested by an end user e.g. customer . In that manner a customer of an on demand application is free from the procurement and maintenance of the hardware and software that is needed for the execution of the applications. On the other hand Platform as a Service PaaS is a category of cloud computing solutions that facilitates the development and deployment of on demand applications and services. PaaS is a growing technology space offering possibilities for optimization of information technology IT spending. It provides facilities required to support the lifecycle of web applications and services available from the Internet. Applications run as a SaaS on the infrastructure that is provided from a PaaS provider. PaaS may give application developers the tools to design develop test deploy and host their software applications as well as use provided application services and infrastructure. Practically different applications require different services and capabilities from the underlying infrastructure. For example it is often difficult to select the proper runtime components needed for an application to operate efficiently on a cloud Virtual Machine VM .

Open Services Gateway initiative OSGi technology is the dynamic module system for Java . The OSGi provides a modular architecture that reduces complexity of today s large scale systems. If an OSGi application is developed then it contains one or more bundles. When such an application is deployed on a given PaaS it is expected to find it provisioned and stared on a VM provided from the PaaS. Depending on the complexity of the solution the provisioning or installation process may involve a series of tedious tasks prone to errors. Typically there is no predictability of whether the provisioning process will be successful or not. For example a failure in the installation at the last stages failure to resolve or start bundles from an application or that the starting operation had not finished.

Embodiments of techniques for validation of current states of provisioned software products are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment applications can be developed based on available platforms or software products to provide new functionality. The platforms or software products can be provided by third parties. For example such a platform can be an on demand runtime platform that allows provisioning of an application in a cloud environment. A PaaS solution can provide an application runtime user interface UI development toolkits and platform services that can be adopted and used in the development of the application. In one embodiment the installation and execution of the application may further require installation of one or more software products which provide specific functionalities for example in the form of infrastructural platform provided components reused by the application. A provisioning process can prepare the application containing components both application components and infrastructural components together with the right configuration in the execution environment. In this manner the total cost of ownership and the resource consumption would be optimized. In one embodiment an infrastructural component can be a platform service such as an identity management and authentication service.

There are different technology solutions that may implement provisioning of applications in a cloud environment together with an existing platform product e.g. an on demand runtime platform. For example the Equinox p2 provisioning platform for OSGi based applications. The p2 platform is part of the Equinox project of Eclipse . The Equinox p2 provisioning platform includes a general purpose provisioning infrastructure that can be used for provisioning a variety of application.

In one embodiment a consumer s request or another event may invoke the execution of a customer application in a cloud environment. The invocation can be a result of an event triggered by a developer of the customer application. According to the characteristics of the cloud environment the invocation of the application may cause its deployment on the cloud its installation and starting together with the necessary runtime platform.

In one embodiment a software application that is based on a PaaS e.g. on demand runtime platform can be deployed installed and started on virtual machines VMs and then can serve users requests through a network. However a provisioned application can be in an undesired state that can cause the application to not be operational. The reasons behind such a situation can be for example failed resolution between the application components and the platform provided components failure of the provisioned software product to start etc. In one embodiment a reliable mechanism can be provided which can determine if a provisioned software product is in a desired state. The ability to determine whether the current state of a provisioned software product is desired or not at a particular time can be used when monitoring the product. Notifications can be sent when the software product is not in the desired state. In addition such mechanism can be used during load balancing when provisioned products are monitored continually. When an application goes into an undesired state the reserved computing resources can be allocated for other usage.

In one embodiment the application may be provided in a repository such as platform repository as a combination of physical artifacts for example stored in one or more Java archives or .jar files and metadata. The metadata describes and configures the functionalities of the components from the application. The platform repository can contain a platform product which represents the functionality and capabilities provided by the on demand runtime platform that is used for the development of the application  . The platform product may include a server that can be used for hosting deployed software applications and their components enterprise services etc. In one embodiment the deployed software product can be an Eclipse based product. An Eclipse based product is a stand alone program e.g. self contained and installable software built using the Eclipse development platform. A product may optionally be packaged and delivered as one or more of so called features. A feature may correspond to a particular functionality of the product or the application and usually groups a number of unitary software components that could be managed together as a single entity. According to the terminology adopted in Eclipse projects such unitary software components are called plugins. The plugins are the basic installable and executable units or software code structures built by the Eclipse developers. The plugins may include one or more bundles in the form of Java ARchive JAR or .jar binary files. In another embodiment the developed and deployed application can be an OSGi application including one or more OSGi bundles. The OSGi hides everything in the bundles unless explicitly exported.

The component  includes bundles . When provisioning a software product based on a platform product such as component  at and the platform product the bundles are installed and in addition to that part of the platform product is also installed. The part of the platform product that is installed when provisioning a component to install a software product on a VM depends on the dependencies between the developed components and the infrastructural components that are provided from the platform product .

In one embodiment the step to start a deployed software product can be triggered from a development environment . Eclipse provides software development kit SDK that can be downloaded and used as Java integrated development environment IDE . By adding various enhancement the Eclipse platform could be used to develop applications in various programming languages such as but not limited to Java Perl C C PHP etc. A domain manager that is part of an orchestrator module is called. In one embodiment the orchestrator can be a module part of the on demand runtime platform used for provisioning the software product. The orchestrator manages the lifecycle of the whole landscape. The domain manager manages a list of running VMs that can be used for hosting a provisioned software product. The domain manager collects information about the VMs by requesting a VM from a cloud controller . The cloud controller has a VM pool where a VM can be acquired. In one embodiment if there is a free VM in the VM pool the VM can be directly taken by the cloud controller. In another embodiment if there are no free VMs the cloud controller can ask the infrastructure layer of the used on demand runtime platform for a new VM. VM is an exemplary VM that the cloud controller can get from the VM pool . In one embodiment VMs can have different types of operating systems working on them and can have a provisioning agent already installed such as a provisioning agent . In one embodiment the provisioning agent can be a provisioning infrastructure on a client machine.

In one embodiment when the VM is chosen from the VM pool the provisioning is started and the provisioning agent from the VM is notified to read the provisioning information and binaries from the platform repository . The provisioning agent executes a script to install a server such as an application server and an administration agent on the VM . The provisioning agent takes from the platform repository the bundles that are part of the provisioned component  and also takes bundles from the platform product that are used from the component  to formulate the software product that is provisioned on the VM . Typically only one component e.g. component  at from the platform repository can be provisioned on a single VM such as the VM . A product  at is the installed provisioned software product on the application server .

In one embodiment during the installation that the provisioning agent triggers on the VM when the provisioned software product product  at is started a state file is created. The state file contains a list with the bundles to be installed on the VM for the product  . The state file presents for each of the bundles what is their desired state. In one embodiment part of the installed bundles should also be activated and another part of the bundles should be in a resolved state when they have dependencies with other bundles. In one embodiment bundles can change their state and the installed state is a temporary state that they have at first. Bundles in the installed state are waiting for their dependencies to be resolved and once they are resolved bundles move to the resolved state. In one embodiment bundles can be in the resolved state when the packages imported by the bundle are exposed by the bundles that are either in the resolved state or that can be moved into the resolved state at the same time as the current bundle. In one embodiment when bundles are activated they are available to function. What a bundle does in the active state depends on the contents of the bundle for instance. On the application server there is a validation module which determines whether the current state of the provisioned software product product  at is in the desired state based on the defined desired state in the state file . Thus the application server can provide information from the validation made in the validation module about the state of the provisioned software product.

If the read bundle at process step is not installed then at process step the record created at step is filled in with information about the read bundle that was checked. If at decision block it is determined that there are no more bundles listed in the state file that are not checked then at process step it is determined whether the created record is empty or not. If the record is empty then at process step the provisioned software product is determined to be in the desired state. This means that there are no bundles in a different state than the desired state that is defined in the state file. If the record is not empty then at process step the record with the bundles that are either not installed or are not in the desired state is saved. The provisioned software product is not in the desired state. This means that there are bundles that are in a different state than the desired state that is defined in the state file. The record is filled in with information about the current states of the bundles that are different that the desired.

In one embodiment a system may comprise one or more computing machine resources for provisioning and execution of a software product e.g. product  a processor and a platform repository having bundles e.g. platform repository and bundles . The computing machine resources can be physical machines virtual machine e.g. VM data storage etc. The system may comprise a platform infrastructure that can receive a descriptor of the provisioned software product and select bundles from the platform repository that are specified in the descriptor. In one embodiment the descriptor includes information describing hardware and software resources to be employed during the provisioning and execution of the software product. In one embodiment the platform infrastructure may select the available computing machine resources from the one or more computing machine resources and install the selected bundles from the platform repository. In one embodiment the installation includes installation of a specified server to be used for the provisioning of the software product on the selected available computing machine resources. In addition the rest of the selected bundles are installed on the server with a desired state. In one embodiment the server can be an application server such as application server . The desired state is defined in a created state file during the installation where a desired state for the selected bundles is specified. For example the state file can be such as state file . The platform infrastructure can include instructions which when executed on the processor installs a validation module such as the validation module .

The comparing module in communication with the checking module and the reading module compares the bundles specified in the state file to the currently installed bundles and the current states of the currently installed bundles with the desired state of the bundles to determine if the current state of the provisioned software product corresponds to the desired state. In one embodiment the determining module in communication with the comparing module defines if the current state of the provisioned software product is desired or undesired. In one embodiment the determining module can determine the current state to be undesired when the specified bundles in the state file differ from the currently installed bundles. In another embodiment the determining module can determine the current state to be undesired when the current states of the currently installed bundles differ from the desired states as defined in the state file . In an embodiment the determining module can determine that the current state of the provisioned software product is desirable. The desirable state is determined when the specified bundles from the state file correspond to the currently installed bundles and the current states of the currently installed bundles correspond to the desired states.

In one embodiment the bundle state identifying module in communication with the determining module identifies those of the currently installed bundles whose current states differ from the desired states when the state of the provisioned product is undesirable. In another embodiment the bundle state identifying module can also determine those of the specified bundles in the state file that are not part of the currently installed bundles. The sending module part of the validation module and the sending module in relation to the bundle state identifying module can send notifications to inform a monitoring system such as the monitoring system . In one embodiment the notifications can include information about the current state of the started provisioned software product. In one embodiment the defined bundles that are not in the desired state can be used for repairing the provisioned software product to be in a desired state by applying necessary actions to the defined bundles.

According to an embodiment the validation module can be associated with hardware software and data resources. In one embodiment the validation module is associated with a central processing unit CPU and a repository to assist during the process of validation of the current state of a provisioned software product. The CPU is used to execute the program code. In one embodiment the repository is used for storing a record of bundles that are not in the desired state. For example the bundles can be bundles that are not installed during the start of a provisioned software product. Another example are bundles that are installed during the start of the provisioned software product but whose current state is not the desired state defined in the state file for the provisioned software product.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

