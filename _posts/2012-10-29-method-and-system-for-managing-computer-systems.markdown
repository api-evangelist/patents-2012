---

title: Method and system for managing computer systems
abstract: A management system for a computer system is disclosed. The computer system operates or includes various products (e.g., software products) that can be managed in a management system or collectively by a group of management systems. Typically, the management system operates on a computer separate from the computer system being managed. The management system can make use of a knowledge base of causing symptoms for previously observed problems at other sites or computer systems. In other words, the knowledge base can built from and shared by different users across different products to leverage knowledge that is otherwise disparate. The knowledge base typically grows over time. The management system can use its ability to request information from the computer system being managed together with the knowledge base to infer a problem root cause in the computer system being managed. The computer system being managed can also request the management system to process its knowledge base for possible problem cause analysis. The management system can also continually identify persisting problem causing symptoms.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09020877&OS=09020877&RS=09020877
owner: IpVenture, Inc.
number: 09020877
owner_city: Los Altos
owner_country: US
publication_date: 20121029
---
This application is a divisional application of U.S. patent application Ser. No. 12 661 244 filed Mar. 12 2010 and entitled METHOD AND SYSTEM FOR MANAGING COMPUTER SYSTEMS now U.S. Pat. No. 8 301 580 which is hereby incorporated by reference which is a divisional application of U.S. patent application Ser. No. 11 585 660 filed Oct. 23 2006 and entitled METHOD AND SYSTEM FOR MANAGING COMPUTER SYSTEMS now U.S. Pat. No. 7 707 133 which is hereby incorporated by reference herein which is a continuation of U.S. patent application Ser. No. 10 412 639 filed Apr. 10 2003 and entitled METHOD AND SYSTEM FOR MANAGING COMPUTER SYSTEMS which is hereby incorporated by reference herein and which in turn claims the priority benefit of i U.S. Provisional Patent Application No. 60 371 659 filed Apr. 10 2002 and entitled METHOD AND SYSTEM FOR MANAGING COMPUTER SYSTEMS which is hereby incorporated by reference herein and ii U.S. Provisional Patent Application No. 60 431 551 filed Dec. 5 2002 and entitled METHOD AND SYSTEM FOR MANAGING COMPUTER SYSTEMS which is hereby incorporated by reference herein.

The present invention relates to computer systems and more particularly to management of computer systems.

Today s computer systems namely enterprise computer systems make use of a wide range of products. The products are often applications such as operating systems application servers database servers JAVA Virtual Machines etc. These computer systems often suffer from network and system related problems. Unfortunately given the complex mixture of products concurrently used by such computer systems there is great difficulty in identifying and isolating of application related problems. Typically when a problem occurs on a computer system it must first be isolated to a particular computer system out of many different computer systems or to the network interconnect among these systems and also to a particular application out of many different applications used by the computer system. However conventionally speaking isolating the problem is difficult time consuming and requires a team of application experts with different domain expertise. These experts are expensive and the resulting down time of computer systems is very expensive to enterprises.

Although management solutions have been developed such solutions are dedicated to particular customers and or specific products. Monitoring systems are able to provide monitoring for events but offer no meaningful management of non catastrophic problems and prevention of catastrophic problems. Hence conventional managing and monitoring solutions are dedicated approaches that are not generally usable across different computer systems using combinations of products.

Thus there is a need for improved management systems that are able to efficiently manage computer systems over a wide range of products.

Broadly speaking the invention relates to a management system for a computer system. The computer system operates or includes various products e.g. software products that can be managed in a management system or collectively by a group of management systems. Typically the management system operates on a computer separate from the computer system being managed. The management system can make use of a knowledge base of causing symptoms for previously observed problems at other sites or computer systems. In other words the knowledge base can built from and shared by different users across different products to leverage knowledge that is otherwise disparate. The knowledge base typically grows over time. The management system can use its ability to request information from the computer system being managed together with the knowledge base to infer a problem root cause in the computer system being managed. The computer system being managed can also request the management system to process its knowledge base for possible problem cause analysis. The management system can also continually identify persisting problem causing symptoms.

The invention can be implemented in numerous ways including as a method system apparatus and computer readable medium. Several embodiments of the invention are discussed below.

As a management system for a computer system one embodiment of the invention can for example include at least a plurality of agents residing within managed nodes of a plurality of different products used within the computer system and a manager for said management system. The manager is operable across the different products.

As a method for isolating a root cause of a software problem in an enterprise computer system supporting a plurality of software products one embodiment of the invention can for example include at least forming a knowledge base from causing symptoms and experienced problems provided by a disparate group of personal contributors and examining the knowledge base with respect to the software problem to isolate the cause of the software problem to one of the software products.

As a method for managing an enterprise computer system one embodiment of the invention can for example include at least the acts of receiving a fact pertaining to a condition of one of a plurality of different products that are operating in the enterprise computer system asserting the fact with respect to an inference engine the inference engine using rules based on facts retrieving updated facts from the inference engine from those of the rules that are dependent on the fact that has been asserted and performing an action in view of the updated facts.

As a computer readable medium including at least computer program code stored therein for isolating a root cause of a problem in an enterprise computer system supporting a plurality of products one embodiment of the invention can for example include at least computer program code for accessing a knowledge base that is formed from causing symptoms and experienced problems provided by a disparate group of personal contributors and computer program code for examining the knowledge base with respect to the problem to isolate the cause of the problem to one of the products.

Other aspects and advantages of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of the invention.

The invention pertains to a management system for a computer system e.g. an enterprise computer system . The computer system operates or includes various products e.g. software products that can be managed in a management system or collectively by a group of management systems. Typically the management system operates on a computer separate from the computer system being managed. The management system can make use of a knowledge base of causing symptoms for previously observed problems at other sites or computer systems. In other words the knowledge base can built from and shared by different users across different products to leverage knowledge that is otherwise disparate. The knowledge base typically grows over time. The management system can use its ability to request information from the computer system being managed together with the knowledge base to infer a problem root cause in the computer system being managed. The computer system being managed can also request the management system to process its knowledge base for possible problem cause analysis. The management system can also continually identify persisting problem causing symptoms.

Embodiments of the invention are discussed below with reference to . However those skilled in the art will readily appreciate that the detailed description given herein with respect to these figures is for explanatory purposes as the invention extends beyond these limited embodiments.

The agents can be controlled to monitor specific information e.g. resources with respect to user configurable specifics e.g. attributes . The information e.g. resources being monitored can have zero or more layers or depths of specifics e.g. attributes . The monitoring of the information can be dynamically on demand or periodically performed. The information being monitored can be focused or limited to certain details as determined by the user configurable specifics e.g. attributes . For example the information being monitored can be focused or limited by certain levels depths.

Optionally the agents can also be capable of performing certain statistical analysis on the data collected at the managed nodes. For example the statistical analysis on the data might pertain to running average standard deviation or historical maximum and minimum.

The management system also includes a management framework . The management framework facilitates communications between the agents for the managed nodes and the manager . For example different agents can utilize different protocols namely management protocols to exchange information with the management framework .

The management system also includes a manager . The manager serves to manage the management system . Consequently the manager can provide cross products cross systems and multi systems management in a centralized manner such as for an enterprise network environment having multiple products or applications which serve different types of requests. In an enterprise network environment the manager has the ability to manage the various systems therein and their products and or applications through a single entity. Geographically these systems and products and or applications can be centrally located or distributed locally or remotely even globally .

The manager includes a Graphical User Interface GUI that allows a user e.g. an administrator to interact with the manager to provide user input. The user input can pertain to rules resources or situations. In addition the user input with the GUI can pertain to administrative or configuration functions for the manager or output information e.g. reports notifications etc. from the manager . The input data is supplied from the GUI to a knowledge manager . The knowledge manager confirms the validity of the rules resources or situations and then converts such rules resources or situations into a format being utilized for storage in a knowledge base . In one implementation the format pertains to meta data represented as JAVA properties. The knowledge base stores the rules resources and situations within the database in a compiled code format.

The manager also includes a knowledge processor . The knowledge processor interacts with the knowledge manager to process appropriate rules within the knowledge base in view of any relevant situations or resources. In processing the rules the knowledge processor often requests data from the agents at the managed nodes. Such requests for data are initiated by the knowledge processor and performed by way of a data acquisition unit and a management framework interface . The returned data from the agents is returned to the knowledge processor via the data acquisition unit and the management framework interface . With such monitored data in hand the knowledge processor can evaluate the relevant rules. When the rules evaluated by the knowledge processor in accordance with the monitored data received from the agents indicate that a problem exists then a variety of different actions can be performed. A corrective action module can be initiated to take corrective action with respect to resources at the particular one or more managed nodes that have been identified as having a problem. Further if debugging is desired a debug module can also be activated to interact with the particular managed nodes to capture system data that can be utilized in debugging the particular system problems.

The knowledge processor can periodically or on a scheduled basis perform certain of the rules stored within the knowledge base . The notification module can also initiate the execution of certain rules when the notification module receives an indication from one of the agents via the management framework interface . Typically the agents would communicate with the notification module using a notification that would specify a management condition that the agent has sent to the manager via the management framework .

In addition the manager also includes a report module that can take the data acquired from the agents as well as the results of the processed rules including debug data as appropriate and generate a report for use by the user or administrator. Typically the report module and its generated reports can be accessed by the user or administrator through the GUI . The manager also includes a log module that can be used to store a log of system conditions. The log of system conditions can be used by the report module to generate reports.

The manager can also include a security module a registry and a registry data store . The security module performs user authentication and authorization. Also to the extent encoding is used the security module also perform encoding or decoding e.g. encryption or decryption of information. The registry and the registry data store serve to serve and store structured information respectively. In one implementation the registry data store serves as the physical storage of certain resource information configuration information and compiled knowledge information from the knowledgebase .

Still further the manager can include a notification system . The notification system can use any of a variety of different notification techniques to notify the user or administrator that certain system conditions exist. For example the communication techniques can include electronic mail a pager message a voice message or a facsimile. Once notified the notified user or administrator can gain access to a report generated by the report module .

The debug module is able to be advantageously initiated when certain conditions exist within the system. Such debugging can be referred to as just in time debugging. This focuses the capture of data for debug purposes to a constrained time period in specific areas of interest such that more relevant data is able to be captured.

The GUI includes a knowledge input GUI a report output GUI and an administrator GUI . The knowledge input GUI provides a graphical user interface that facilitates interaction between a user e.g. administrator and a manager e.g. the manager . Hence using the knowledge input GUI the user or administrator can enter rules resources or situations to be utilized by the manager. The report output GUI is a graphical user interface that allows the user to access reports that have been generated by a report module e.g. the report module . Typically the report output GUI would not only allow initial access to such reports but would also provide a means for the user to acquire additional detailed information about reported conditions. For example the report output GUI could enable a user to view a report on chosen criteria such as case ID or a period of time. The administrator GUI can allow the user to configure or utilize the manager. For example the administrator GUI can allow creation of new or modification to existing users and their access passwords specific information about managed nodes and agents including managed node IP and port agent name agent types electronic mail server and user configuration.

The knowledge manager includes a knowledge code generator . In particular the knowledge code generator receives rules or definitions namely definitions for resources or situations and then generates and outputs knowledge code to a knowledge processor such as the knowledge processor . In one implementation the knowledge code generator can be considered a compiler in that the rules or definitions are converted into a data representation suitable for execution. The knowledge code can be a program code or it can be a meta language. In one implementation the knowledge code is executable by an inference engine such as JESS. Additional information on JESS is available at herzberg.ca.sandia.gov jess as an example.

The knowledge manager also includes a knowledge encoder decoder a knowledge importer exporter and a knowledge update manager . The knowledge encoder decoder can perform encoding when storing knowledge to the knowledge base or decoding when retrieving knowledge from the knowledge base . The knowledge importer exporter can import knowledge from another knowledge base and can export knowledge to another knowledge base. In general the knowledge update manager serves to manually or automatically update the knowledge base with additional sources of knowledge that are available and suitable. In one embodiment the knowledge update manager operates to manage the general coherency of the knowledge base with respect to a central knowledge base. Typically the knowledge base stored and utilized by the knowledge manager is only a relevant portion of the central knowledge base for the environment that the knowledge manager operates.

The directed graph is typically structured to include base resources at the top of the directed graph situations resources in a middle region of the directed graph and actions action resources at the bottom or leaf nodes of the directed graph . In particular node pertains to a base resource or resources and node pertains to situation and or resource. A relationship between the nodes and is determined by the rule being represented by the directional arrow between the nodes and . The situation resource at node in turn relates to another situation resource at node . A relationship relates the nodes and namely the relationship is determined by the rule represented by the directional arrow between the nodes and . The situations resources at nodes and together with the relationship pertain to another rule. The situation resource at node is further related to an action resource at node . A relationship between the situation resource at node and the action resource at node is determined by still another rule namely an action rule.

The knowledge base represented by the directed graph is flexible and extendible given the hierarchical architecture of the directed graph . Hence the knowledge base is able to grow over time to add capabilities without negatively affecting previously existing knowledge within the knowledge base. The knowledge base is also able to be divided or partitioned for different users applications or service plans. In effect as the knowledge base grows the directed graph representation grows to add more nodes such nodes representing situations or resources as well as relationships i.e. rules between nodes.

The knowledge processor includes a controller that couples to a knowledge manager e.g. the knowledge manager . The controller receives the knowledge code from the knowledge manager and directs it to an inference engine to process the knowledge code. In one embodiment the knowledge code is provided in an inference language such that the inference engine is able to execute the knowledge code.

In executing the knowledge code the inference engine will typically inform the controller of the particular data to be retrieved from the managed nodes via the agents and the management framework interface. In this regard the controller will request the data via a management interface to a management framework. The returned data from the managed nodes is then returned to the controller via the management interface . Alternatively in executing the knowledge code exceptions i.e. unexpected events can be generated at the managed nodes and pushed through the management interface to the controller . In either case the controller then forwards the returned data to the inference engine . At this point the inference engine can continue to process the knowledge code e.g. rules . The inference engine may utilize a rule evaluator to assist with evaluating the relationships or rules defined by the knowledge code. The rule evaluator can perform not only the relationship checking for rules but also data parsing. Once the knowledge code has been executed the inference engine can inform the controller to have various operations performed. These operations can include capturing of additional data from the managed nodes initiating debug operations initiating corrective actions initiating logging of information or sending of notifications.

The knowledge processor also can include a scheduler . The scheduler can be utilized by the inference engine or the controller to schedule a future action such as the retrieval of data from the managed nodes.

The management framework interface includes a SNMP adapter and a standard management framework adapter . The SNMP adapter allows the management framework interface to communicate using the SNMP protocol. The standard management framework adapter allows the management framework interface to communicate with any other communication protocols that might be utilized by standard management frameworks such as other product managers and the like. The management framework interface also includes an enterprise manager a domain group manager and an available domain resources module . During startup of the management framework interface which is typically associated with an enterprise the enterprise manager will identify all groups within the enterprise. Then the domain group manager will operate to identify all management nodes within each of the groups. Thereafter the available domain resources module will identify all domains and resources associated with each of the identified domains. Hence the domains and resources for a given enterprise are able to be identified at startup so that the other components of a manager e.g. the manager are able to make use of the available domains and resources within the enterprise. For example a GUI can have knowledge of such resources and domains for improved user interaction with the manager and the knowledge processor can understand which rules within the knowledge base are pertinent to the enterprise.

The management framework interface also includes an incoming notification manager . The incoming notification manager receives notifications from the agents within managed nodes. These notifications can pertain to events that have been monitored by the agents such as a system crash or the presence of a new resource. More generally these notifications can pertain to changes to monitored data at the managed nodes by the agents.

The management framework interface also includes a managed node administrator module . The managed node administrator module allows a user or administrator to interact with the management framework interface to alter nodes or domains within the enterprise such as by adding new nodes or domains updating domains reloading domains etc.

Still further the management framework interface can also include a managed node update module . The managed node update module can discover managed nodes and thus permits a manager to recognize and receive status e.g. active inactive of the managed nodes.

The report module includes a presentation manager a format converter and a report view selector . The presentation manager operates to process the raw report data provided by a log module e.g. log module in order to present an easily understood richly formatted report. Such a report might include associated graphical components that a user can interact with using a GUI e.g. GUI . Examples of graphical components for use with such reports are buttons pull down lists etc. The format converter can convert the raw report data into a format suitable for printing and display. The report view selector allows viewing of partial or complete log data raw report data in different ways as selected using a GUI. These views can for example includes one or more of the following types of reports 1 Report Managed nodes wise show report for the selected managed node process identifier only 2 Report time wise show report for the last xyz hours time desired by the user with the user having the option of choosing the managed node he wants to view 3 Report Rule wise show report for the selected rule that might be applicable for number of JVM instances 4 Report Rule pack wise show report for all the rules fired under a particular rule pack 5 Report Last Fired Rules wise show report for rules fired after last re start of the inference engine 6 Report Rule Fired Frequency wise show report for rules fired as per selected fired frequency e.g. useful to get recurrence pattern of event occurrence 7 Report Domain wise show report pertaining to a particular domain e.g. if a rule is composed of multiple domains in that case this report can show the rules including the selected domain. e.g. JVM 8 Report Resource wise show report for all rules including a particular resource under the domain e.g. jvm Exception 9 Report filter wise show report pertaining to rules having similar filter conditions 10 Report Day wise show report for all events happened in a day 11 Report Refreshed Values wise show next refreshed state of the same report and highlights changed added records 12 Report Case ID wise show the report based on problem case identifier id and 13 Customized Structure reports allow user to select a combination of the above or provide a report filter of their own.

The knowledge base includes one or more knowledge domains and one or more rule packs. In particular the knowledge base illustrated in includes knowledge domain A knowledge domain B and knowledge domain C . Through use of the rule packs these multiple knowledge domains and can be linked together so as to effectively operate to concurrently cooperate with one another. A particular knowledge domain is a software representation of know how pertaining to a specific field or domain . The knowledge domains can be physical domains and or virtual domains. A physical domain often pertains to a particular managed product. A virtual domain can pertain to a defined set of resources defined by a user to achieve effective manageability.

The knowledge base also includes rule packs and . These rule packs or knowledge rule packs are collections of rules i.e. relationships between different kinds of resources situations . The purpose of the rule packs is to collect the rules such that management modification and tracking of knowledge is made easier. By separating knowledge into domains and rule packs each knowledge component can be individually tested as well as tested together with other knowledge components. In other words each domain or rule pack is a logically separate piece of knowledge which can be installed and uninstalled as desired.

When a rule pack is installed the system must keep track of its rules functions inputs and outputs so that a large installed base of rule packs can be managed. Hence an individual rule pack can be added to or removed from the knowledge base without adversely affecting the entire system.

Further two rule packs may operate on the same set of shared facts. The two knowledge rule packs may also generate a set of shared facts. These rule packs can facilitate the tracking of how a fact travels through various rule packs and how a fact may be generated by multiple rule packs. The functions and rules of rule packs can also be more precisely monitored by using the smaller sized rule packs. It is also possible for one rule to exist in two or more rule packs. Hence when such two or more rule packs that share a rule are merged into a knowledge base only one copy of the rule need exist within the knowledge base.

An expert system object manages the knowledge base. For example the expert system object can reset an inference engine load and unload rule packs or domains insert or retract runtime facts etc.

The knowledge representation utilized by the present invention makes use of three major components facts rules and actions. Collectively these components are utilized to perform the tasks of monitoring and managing a computer resource such as a JVM an operating system a network database or applications.

The rules can be represented in JAVA Expert Systems Shell JESS and as a rule engine that drives these rules. JESS offers a CLIPS like language for specifying inference rules facts and functions. The relationship thus facilitates the creation of a data driven knowledge base that is well suited for monitoring and managing computer resources.

The relationship between a domain fact and an inference object is always an arrow pointing from the fact to the inference object thereby denoting that facts are driving the rules inside the inference engine. The relationship between the inference object and the actions are that of an arrow pointing from the inference object toward the action meaning the inference rules drive the actions. Between the two inference objects and are facts and actions that both inference objects and utilize. In effect these inference objects and are cooperative expert systems namely expert systems that cooperate in a group by sharing some of their knowledge with one another.

Facts can be used to represent the state of an expert system in small chunks. For example a fact may appear as MAIN jvm jvm heapused v 3166032 uid 372244480 instance 13219 host unknown The content of the fact indicates that in the current Java Virtual Machine JVM on system unknown with instance or process id 13219 the size of heap used is 3166032 bytes. In this example uid instance and host are some of the attributes of the resource jvm heapused belonging to the domain jvm. The attributes of a resource that are not used for comparison with other resources need not be included in the facts for the resource. Facts as implemented by JESS exist inside the rules engine. To add an additional fact into the rules engine the new fact is injected into the inference engine object. The repository of facts can be represented hierarchically. The knowledge base can for example be sorted and transmitted as needed as a set of XML documents or provided as shared distributed databases using LDAP or as JAVA Properties files.

In the case of a cooperative expert system access to a shared set of facts is needed. The facts can be logically organized into separate domains. In one implementation a user may choose to organize shared knowledge into separate knowledge rule packs or alternatively allow the same fact definition to exist within multiple rule packs. In the later approach the system can manage the consistency of the facts using a verification process at the managed resource node in the form of capability requests and at the knowledge control module in the form of definition verification .

The rules are used to map facts into actions. Rules are preferably domain specific such that separate domains of knowledge are thus provided as modular and independent rule sets. Hence the modification of one domain of rules and its internal facts would not affect other domains. These different rule packs of rules interact with each other only through shared facts.

The default prefix denotes the rule pack the rule belongs to. Since it is possible that memory leak can exist for application or application server utilizing separate name spaces for each rule pack of rules allows separation of these rules into different rule packs. Another advantage of using separate name space for different rule packs is that JESS rules are serializable meaning that text rules can be encoded into binary form. The ability to store rules in binary form serves to protect the intellectual property encoded within the rules.

Actions are procedural statements to be executed. The actions may reside on the right hand side of rules in the form of scripts or can be embedded as methods inside programming objects e.g. JAVA objects . In the case of scripts the scripts are inference engine dependent such that different inference engines would utilize different scripts because of the different languages utilized by the inference engines. In the case of programming objects the actions are functions. For example actions in JAVA can be implemented by registering them as new JESS functions. Alternatively the functions could be packaged inside fact objects for which such rules are relevant. The functions could in turn request relevant resource values from the managed nodes and assert the values obtained as facts into the inference engine. The fact objects e.g. get values represent values obtained from agents e.g. using a scheduler of an agent .

Given that actions can be complicated and not tied to any particular facts it is often more efficient to create a global object for a domain and include the methods or functions for actions therein such that every rule within a rule pack has access to the actions.

Through the use of a modular design the system becomes easier to manage even when thousands of rules and facts exist. By separating rules into rule packs and facts into domains and making it difficult for domains to interfere with one another the expert system is effectively divided into smaller modular pieces. Additionally through use of JESS s built in watch facility the system can track those rules that have fired and the order in which they have fired. This watch facility thus provides a limited tool for debugging a knowledge system. Groups of rules can be isolated for inspection by turning off other rules. Rules can be turned off by deactivating those inference objects from firing which are not desired. If one were to desire to debug a set of rules related to one domain such a set of rules could be manually grouped into a logical group e.g. rule pack and user of the management system can use GUI to control the activation of each group. Using GUI user can additionally control activation of a single or a selected set of rules within a rule pack.

Initialization scripts can be used to set up all the components needed for a rule pack. The setup can operate to create the inference object load the rules create initial facts create action objects and link all the objects together so that they can inter operate.

In the JESS JAVA implementation one inference object may contain rules from one or more rule packs. Outside the inference object are objects that represent facts and objects that encapsulate actions. Each inference object is attached to a set of facts and actions. The rules engine searches the facts for matches that can trigger a rule to fire. Once a rule is fired one or more action objects being linked thereto are invoked. Actions can also be explicitly linked by using an initialization that involves JAVA object creation and passing handles to these objects to appropriate JESS inference objects.

One useful aspect of the rule engine design is the ability of the system to manage different combinations of multiple products on multiple nodes using one set of rule packs and one manager. This simplifies the distribution configuration and manageability of rule packs on per user basis. For example the rules engine can have rule packs for managed products JVM and Oracle loaded but one managed node may not have Oracle as the managed product. In this case naturally there will be no facts corresponding to Oracle resources for the managed node asserted into the inference engine and hence the rules using those Oracle resources will not be active for the managed node without Oracle as a managed product. Note that the information about the managed node is part of the fact representing any Oracle resource.

Another useful aspect of the rules engine design is the implicit chaining of rules by the inference engine. A user of the system defines individual rules representing a problem or diagnostic cases . The system combines these individual rules based on the use of common facts representing resources. For example one rule can be represented in a meta language IF jvm uncaught exception AND filter exception is Oracle connections exhausted THEN get Oracle max connections configured . A second rule can be represented in a meta language IF Oracle max connections configured

The managed node includes a plurality of different managed products . In particular the managed node includes managed products . . . . These managed products are software products that form part of the system being managed by a management system. The managed products can vary widely depending upon implementation. As examples the managed products can pertain to a Solaris operating system an Oracle database or a JAVA application.

The managed node also includes an agent . The agent couples to each of the managed products . The agent also couples to a manager e.g. the manager illustrated in via the management framework . In general the agent can interact with the managed products such that the managed products can be monitored and possibly controlled by the management system via the agent .

Additionally in one embodiment one or more of the managed products can include an application agent . For example as shown in the managed product N includes the application agent . Here the application agent resides within the process space of the managed product N and thus out of the process space of the agent . The application agent can render the managed product N more manageable by the agent . For example the application agent can enable any JAVA application to be managed. The capabilities of the application agent can be further enhanced by the user adding application code to the application agent conforming to the Application Programming Interfaces API provided by the application agent . This methodology provides a convenient means for the user to add his her application specific information such that it becomes available as resources to the rest of the management system.

The agent includes a master agent that couples to a plurality of sub agents . In particular the agent utilizes N sub agents . . . . Each of the sub agents . . . respectively communicates with the managed products . . . shown in . The master agent thus interacts with the various managed products through the appropriate one of the sub agents . The master agent includes the resources that are shared by the sub agents . These shared resources are discussed in additional detail below with respect to . The master agent also provides an Application Programming Interfaces API that can be used by the user to write a sub agent that can interact with a managed product for which a sub agent is not provided by the management product. Using this API the user written sub agent can make available the managed product specific information as resources to the rest of the management product including the master agent and the manager .

The agent also includes a communication module . The communication module allows the agent to communicate with a management framework and thus a manager through a variety of different protocols. In other words the communication module allows the agent to interface with other portions of a management system over different protocol layers. These communication protocols can be standardized general purpose protocols such as SNMP or product specific protocols such as HPOV SPI from Hewlett Packard Company or various other proprietary protocols. Hence the communication module includes one or more protocol communication modules . In particular as illustrated in the communication module can include protocol communication modules . . . . The protocol A communication module interfaces to a communication network that utilizes protocol A. The protocol B communication module interfaces with a communication network that utilizes protocol B. The protocol M communication module interfaces with a communication network that utilizes protocol M.

The master agent includes a request processor that receives a request from the communication module . The request is destined for one of the managed products . Hence the request processor operates to route an incoming request to the appropriate one of the sub agents associated with the appropriate managed product . Besides routing a request to the appropriate sub agent the request processor can also perform additional operations such as routing return responses from the sub agents to the communication module namely the particular protocol communication module that is appropriate for use in returning the response to the balance of the management system i.e. the manager .

The master agent typically includes a registry that stores registry data in a registry data store . The registry manages lists which track the sub agents that are available for use in processing requests for notification to the sub agents or the protocol communication modules . These lists that are maintained by the registry are stored as registry data in the registry data store . Hence the registry is the hub of the master agent for all traffic and interactions for other system components carried out at the agent . The functionality provided by the registry includes 1 a mechanism for sub agent registration initialization and dynamic configuration 2 a communication framework for the sub agent s interaction with the manager node through different communication modules present at the agent 3 a notification mechanism for asynchronous notification delivery from the monitored systems and applications to the communication modules and the manager node and 4 a sub agent naming service so that sub agents can be addressed by using simple human readable identifiers. The registry also acts as an interface between the communication modules so that the communication modules are able to configure registered sub agents and receive asynchronous notifications from the registered sub agents.

The master agent also includes a scheduler and statistical analyzer . The scheduler can be utilized to schedule requests in the future to be processed by the request processor . The statistical analyzer can be utilized to process or at least pre process the response data being returned from the managed product before some or all data is returned to the manager. Hence by having the master agent perform certain statistical analysis at the statistical analyzer the processing load on the manager can be distributed to the master agents.

Each of the sub agents can be a pluggable component enclosing monitoring and control functionality pertinent to a single system or application. The sub agents are known to the managed products through the registry . In other words each of the sub agents is registered and initialized by the registry before it can receive requests and send out information about the managed product it monitors. The principal task of the sub agent is to interact with the managed product e.g. system application it controls or monitors. The sub agent serves to hide much interaction detail from the rest of the agent and provides only a few entry points for request into the information.

The different protocols supported by the communication module allow the communication module to be dynamically extended to support additional protocols. As a particular protocol communication module is initialized the registry within the master agent is informed of the particular protocol communication module so that asynchronous notifications from the managed objects can be received and passed to the manager via the particular protocol communication module .

The communication module receives requests from a manager through the protocol supported by the particular protocol communication module that implements and forwards such requests to the appropriate sub agent corresponding to the appropriate managed node. The registry within the master agent is utilized to forward the request from the protocol communication module and the sub agents .

In addition the protocol communication module also provides a callback for the sub agents such that notifications are able to be received from the managed product and sent back to the manager. If such callbacks are not provided the notifications will be ignored by the sub agents and thus no error will be reported to the manager. Hence each of the protocol communication modules can be configured to handle or not handle notifications as desired by any particular implementation.

The sub agent includes a get resource module a set operation module and an event forwarding module . The get resource module interacts with a managed product to obtain resources being monitored by the managed product. The set operation module interacts with the managed product to set or control its operation. The event forwarding module operates to forward events that have occurred on the managed product to the manager. In addition the sub agent can further include a statistical analyzer . The statistical analyzer can operate to perform statistical processing on raw data provided by a managed product at the sub agent level. Hence although the master agent may include the statistical analyzer the presence of statistical analyzer in each of the sub agents allows further distribution of the processing load for statistical analysis of raw data.

Next a first node group is selected from the list of node groups. For the selected node group a list of nodes within the selected node group is obtained . A decision then determines whether there are more node groups to be processed. When the decision determines that there are more node groups to be processed then the manager startup processing returns to repeat the operations and for a next node group. When the decision determines that there are no more node groups to be processed all the nodes within each of the node groups have thus been obtained.

At this point processing is performed on each of the nodes. A first node from the various nodes that have been obtained is selected . Then a list of domains within the selected node is obtained . A decision then determines whether there are more nodes to be processed. When the decision determines that there are more nodes to be processed then the manager startup processing returns to repeat the operations and for a next node.

On the other hand when the decision determines that there are no more nodes to be processed then processing can be performed for each of the domains. At this point the manager startup processing performs processing on each of the domains that have been obtained. In this regard a first domain is selected . Then a list of supported resources is obtained for the selected domain. A decision then determines whether all of the domains that have been identified have been processed. When the decision determines that there are additional domains to be processed the manager startup processing returns to repeat the operations and for a next domain such that each domain can be similarly processed.

Next processing is performed with respect to each of the nodes. At this point a first node is selected . Then a customized knowledge base is produced for the selected node based on the supported resources for the selected node. In other words the generalized knowledge base that is loaded is customized at operation such that a customized knowledge base is provided for each node that is active or present within the system being managed. A decision then determines whether there are more nodes to be processed. When the decision determines that there are more nodes to be processed then the manager startup processing returns to repeat the operations and for a next node. Alternatively when the decision determines that there are no more nodes to be processed then data acquisition for those base rules within the customized knowledge bases can be scheduled . Once the data acquisition has been scheduled the manager startup processing is complete and ends.

A decision then determines whether there are any node groups to be processed. When the decision determines that there are node groups to be processed then a first node group is selected . Then a list of nodes within the selected node group is obtained .

Next a decision determines whether there are any nodes in the selected node group that are to be processed. When the decision determines that there are nodes within the selected node group to be processed then a first node is selected . Then for the selected node a list of agent types on the selected node is obtained .

A decision then determines whether there are any agent types to be processed. When the decision determines that there are agent types to be processed a first agent type is selected . Then for the selected agent type a decision determines whether there is any third party framework adapter. When the decision determines that there is no third party framework adapter then a list of domains is obtained . On the other hand when the decision determines that there is a third party framework adapter then a list of supported domains is discovered . Here the resulting list of supported domains includes information about product s supported by the third party adapter. The concept of domain in this case is adapter specific. For example for SNMP adapter all resources supported by the SNMP master agent on a managed node can be considered belonging to a domain. Another concept of domain for SNMP adapter can correspond to the resources supported by every SNMP sub agent on the managed node communicating with the SNMP master agent

Following the operations and a decision determines whether there are any domains within the selected agent type. When the decision determines that there are domains then a first domain is selected . Then a list of supported resources and domain version are obtained . Next a decision determines whether there are more domains within the selected agent type. When the decision determines that there are more domains then the manager startup processing returns to repeat the operation and subsequent operations so that a next domain can be similarly processed.

Alternatively when the decision determines that there are no more domains within the selected agent type to be processed as well as directly following the decision when there are no domains to be processed a decision determines whether there are more agent types to be processed. When the decision determines that there are more agent types to be processed then the manager startup processing returns to repeat the operation and subsequent operations so that a next agent type can be similarly processed.

On the other hand when the decision determines that there are no more agent types to be processed or directly following the decision when there are no agent types to be processed a decision determines whether there are more nodes to be processed. When the decision determines that there are more nodes to be processed then the manager startup processing returns to repeat the operation and subsequent operations so that a next node can be similarly processed.

Alternatively when the decision determines that there are no more nodes to be processed or directly following the decision when there are no nodes a decision determines whether there are more node groups to be processed. When the decision determines that there are more node groups to be processed the manager startup processing returns to repeat the operation and subsequent operations so that a next node group can be similarly processed.

On the other hand when the decision determines that there are no more node groups to be processed or directly following the decision when there are no node groups a customized domain and resources list is produced based on available domains and their versions and resources information for rules input. Then a customized knowledge base is produced for the selected nodes based on supported domains and resources.

A reference resource list can be created using the most up to date version of each domain type. The reference resource list is used in rule definitions. For example a JVM domain list of resources obtained from one managed node may be larger in number than the list of resources obtained for the JVM domain from a different managed node. This is possible because of enhancement of agent over time. The reference resource list contains the maximal set of domains and resources from the latest version of all the knowledge domains by name type. This enables user to define rules for the most complete manageability of the user environment e.g. using one GUI .

Next a decision determines whether a knowledge processor has been selected to run. The decision enables user to start the management system for development and testing of rules and also to setup all the managed nodes and select a set rule packs and rules prior to running the knowledge processor. The decision can be facilitated by a GUI. When the decision determines that the knowledge processor is to be run then data acquisition for those base rules within the customized knowledge base can be scheduled . Alternatively when the decision determines that the knowledge processor is not selected to run then the operation can be bypassed. Following the operation or its being bypassed the manager startup processing is complete and ends.

The master agent startup processing initializes any pre configured sub agents for the master agent. Hence any standard sub agents for the master agent are initialized . Then the presence of any other sub agents for the master agent are discovered . These other sub agents can be either in process or out of process. An in process sub agent would operate in the same process as the master agent. On the other hand an out of process sub agent would operate in a separate process from that of the master agent. After the any other sub agents are discovered the discovered sub agents are initialized . A statistical analyzer can then be activated for each of the sub agents. The statistical analyzers provide the statistics collection for the resources being monitored by the respective sub agents. Following the operation the master agent startup processing is complete and ends.

The sub agent startup processing initially establishes a connection with the master agent. The connection is an interface or a communication link between the master agent and the sub agent. Application resources are then discovered . The application resources are those resources that are available from an application monitored by the sub agent. The application resources can also include user defined resources e.g. using an API. Next the master agent is notified of the status of the sub agent. The status for the sub agent can include various types of information. For example the status of the sub agent might include the resources that are available from the sub agent details about the version or operability of the sub agent etc. Next a statistical analyzer can be activated for the sub agent. The statistical analyzer allows the sub agent to perform statistical analysis on resource information available from the sub agent. Following the operation the sub agent startup processing is complete and ends. It should however be recognized that the sub agent s startup processing is performed for each of the sub agents associated with the master agent.

The trigger notification processing begins with a decision that determines whether a new fact has been asserted. When the decision determines that a new fact has not been asserted then a decision determines whether a notification has been received. Here the notifications could arrive from managed nodes. When the decision determines that a notification has not been received then the trigger notification processing returns to repeat the decision . Once the decision determines that a new fact has been asserted or when the decision determines that a notification has been received then a fact is asserted in the inference engine. The inference engine then processes the fact in the manager. For example in the case of the manager illustrated in the inference engine is implemented by the knowledge processor . Next a log entry is made into a log. The log entry indicates at least that the fact was asserted .

Next updated facts are retrieved for one or more rules that are dependent upon the asserted fact. Hence the inference engine receives the asserted fact and determines which of the rules are dependent upon the asserted fact and then for such rules requests updated facts so that the rules can be fully and completely processed using up to date information.

Following the operation a decision determines whether the trigger notification processing should stop. When the decision determines that the trigger notification processing should stop then those facts no longer needed are discarded . Following the operation the trigger notification processing is complete and ends. For example a user might terminate the operation of the manager and thus end the trigger notification processing .

Alternatively when the decision determines that the trigger notification processing should not stop then additional processing is performed depending upon the type of resource. For example the resource or the rule being processed can signal for data acquisition corrective action or debug operations. In particular a decision determines whether data acquisition is requested. When the decision determines that data acquisition has been requested then an updated fact is selected . On the other hand when the decision determines that data acquisition is not being requested then a decision determines whether corrective action is indicated. For example a rule within the knowledge base can request a corrective action be performed. In any case when the decision determines that a corrective action has been requested then the corrective action is performed .

Alternatively when the decision determines that a corrective action is not being requested then a decision determines whether debug data is being requested. When the decision determines that debug data is requested then debug data is obtained .

Alternatively when the decision determines that debug data is not being requested then a decision determines whether a user defined situation has occurred. When the decision determines that a user defined situation has occurred then an action is taken noting the occurrence of the user defined situation.

Following any on the operations or the decision when a user defined situation is not present a log entry is made into the log. The log entry indicates the firing of the rule along with the specifics of the resources including their values on the left hand side or if part of the rule . Following the logging operation the trigger notification processing returns to repeat the operation and subsequent operations so that additional facts can be asserted and similarly processed.

Additionally a user of the management system may interact with a Graphical User Interface GUI to request a report. The report provides information to the user about the management state of the one or more managed products within the enterprise or computer system being monitored.

The GUI report processing can begin with a decision that determines whether a report has been requested. When the decision determines that a report has not yet been requested the GUI report processing awaits such a request. In other words the GUI report processing can be considered to be invoked once a report request has been received. In any case when the decision determines that a report request has been received then log data is retrieved . For example with respect to the manager illustrated in the log data can be retrieved from the log module . After the log data is retrieved a report is generated from the retrieved log data.

The report might indicate the various facts and rules that have been utilized by the management system over a period of time. For example a report might specify those of the rules that were fired and for each such rules when it fired why it fired and action if any taken. Additionally a report might include details on the actions taken and related values. Still further if one of the actions taken is a debug action then the report might also include debug data. A report can also be targeted or selective in its content based on criteria. For example a report can be limited with respect to one or more of a certain time range an event exceptions domains and or rule packs.

Once the report has been generated a report delivery method is determined . Here the report delivery method can be pre configured by an administrator of the management system to deliver reports to certain individuals or locations automatically. For example the report can be delivered in the form of a notification that can be carried out using a pager a voice mail a voice synthesized telephone call a facsimile etc. Once the report delivery method has been determined the report is delivered using the determined report delivery method. It should be understood that the report delivery method can vary depending upon the nature of the report. For example urgent reports can utilize one or more delivery methods that are more likely to reach the recipient immediately such as a page or a mobile telephone call. Hence the report can be delivered in a variety of different ways depending upon the application circumstances and configuration of the management system. Following the delivery of the report the GUI report processing is complete and ends.

To add create a rule a user would access an Add New Rule page such as shown in . Here the user would perform the first step of four steps to follow in order to add a new rule. Namely the user would enter a name and description for the rule and select a rule pack it belongs to. Upon pressing a Submit button the process proceeds to the next step where you define the situation or the left hand side of a rule i.e. the conditions under which the rule will fire. Or in other words a list of situations and events When this happens . . . which lead to the actions specified under the Then define situation or do this . . . header which is referred to as the right hand side of the rule. Predicates of the left hand side are called antecedents and elements of the right hand side are called consequents.

As shown in to build the left hand side of a rule first choose a knowledge domain from a Domains list on the left side of the screen. After a domain is selected from the list the selection box below will be show all resources of that domain. There are two kinds of domains physical and special or virtual . A physical domain represents a collection of resources pertaining to a software component or an entire software product for instance the Java Virtual Machine as opposed to a special or virtual domain. A special domain represents a set of resources which aren t associated with any physical knowledge domain. Instead such resources are used by the manager as building blocks to express conditions of the left hand side or form actions on the right hand side of a rule. In the representative rule being built both a physical domain resource and a virtual domain resource are used. First select the jvm domain from the list of domains and two resources of that domain to the right hand side of the rule see .

Once we have selected all the resources used to define the situation the proceed to next step button is selected. The next step is where relationships between the selected resources and or their thresholds are set to configure the condition for the rule to fire. Now add a condition to the left hand side of the rule. This condition basically states that when the amount of heap memory currently in use is greater than a certain percentage of the maximum heap memory available the rule should fire. In order to add a condition to the left hand side of a rule choose the Filter special domain. As shown in one of the domain resources in the selection box will be Condition. The user just selects Condition and clicks the add button.

Next an Edit Parameter button for the condition is selected and the desired condition expression entered. Here the condition expression shown entered in binds the two JVM resources. The condition is typically defined as an expression. A simple example of a condition expression is a b .

Let us look at detail how we came up with the condition expression in . Please refer to for better illustration. Under the When this happens . . . header note that there are three distinct entries one below the other as follows 

Here r1 r2 and r3 are resource variable names assigned by the system to the resources jvm HeapUsed jvm MaxHeapSize and Condition resources respectively. This is to facilitate the definition of the condition expression using the resource variable names only. A simplified example of a condition expression using resource r1 is r1 1000000 which states that the rule is considered true or gets fired in case jvm HeapUsed exceeds 1000000 bytes or 1 MB. Note that in this expression r1 and 1000000 are operands and is a comparator operator in between the two operands.

In the condition expression r1 r2 060 in the condition states that the rule is considered to be true if JVM heap being currently used jvm HeapUsed r1 is greater than 60 of or 0.60 times the maximum allowed heap size jvm MaxHeapSize r2.

Now as the left hand side of the rule has been built let us specify using the Configure Action s page shown in to indicate what we want the system to do when the condition becomes true. Let s request the system produce a report on the class whose objects occupy most of the JVM heap and request a report on objects of the classes thus identified are allocated on the heap during the following 15 seconds.

In order to test the rule that has been created and also make sure that all components of the products are installed properly and communicate with each other the manager should be set so that it considers the rule when the rule evaluation engine is started. Every rule can be configured in a flexible way. For instance it can be set to be tested every 10 seconds or every minute or every hour. If you want a trial run of the rule as you run the engine select a special option on the list of possible intervals once only can be chosen. The testing interval can be set on the same Rule Editing page as shown in .

The rule shown in is a rule that defines conditions for an abnormal situation. If the defined situation occurs the system is requested to take one or more actions. In this representative example the actions are the two request for jvm TopHeapObjects and jvm AllocTrace on the right hand side of the rule under the Then define situation or do this . . . header. This kind of rule is useful but its capabilities are limited. If instead of taking action right there in the rule a situation is defined then another rule can be built so that it gets triggered when this situation has been encountered. Through this mechanism rules can be chained and hierarchies or trees of rules can be built.

For example for this rule to be turned into a rule that can potentially be chained to other rules a new situation has to be defined see . The situation can then be added to the rule as a consequent see .

Thereafter as desired another rule or a set of rules can be defined with JVMLowMemory as the antecedent and the system will automatically chain these rules i.e. the set of rules defined with JVMLowMemory on the left hand side of the rule will fire when the situation in is declared in the modified rule in .

A previously defined added rule can be edited. To edit an existing rule go to the Rule Management page such as shown in select an existing rule and click on the Edit button.

After a rule or a chain of rules has been created the system is ready to monitor the software on the managed nodes. In order to initiate this process from the Rule Management page start the rule engine by clicking on the Re Start Engine button. If the rules engine has to be stopped press the Stop Engine button in the Rule Management page. If any of the rules were edited or new rules were added and you want these changes to take effect the Re Start Engine button in the Rule Management page has to be pressed. This will cause the engine to stop automatically pick up any changes that have been made and restart.

Note that every time the manager process is started the Rule Engine status can be Ready. The current status of the engine is displayed in the top right hand corner in the Rule Management page. For the rules to be fired according to time and condition set in its definition the Re Start Engine button in the Rule Management page needs to be pressed explicitly. This changes the status of Rule Engine from Ready to Running. You have to do this every time you add or make changes to rules and want the Rule Engine to pick up the additions changes. As the engine gets into the running state it checks resource values of the rules set up for periodic checking. In case all conditions on the left hand side of such rule become valid the engine will proceed with the actions on the on the right hand side of the rule after which the rule will become blocked for as long as the conditions are valid. Then the rule will be marked active again. All activities of the engine in respect to rule firing and subsequent actions are reflected on the Report page. The page can be accessed through the Report button on the Rule Management page such as shown in .

The Report page for our example above with heap usage reduced to 1 and allocation tracing time reduced to 5 seconds is shown in . The Report page has several functional buttons which are self descriptive a Refresh button is used for updates of the page so it reflects the latest report information a Clear button will render the report page empty a Mail button will allow the report to be sent via e mail and the Done button will take you back to the main page the Rule Management page.

The sample report shown in is a result of running of the rule defined and shown in . The report reflects all important events associated with the system having run with the rule being activated for diagnostics. The first line of the report indicates that rule JVMHeap was fired and for what system the conditions of the rule became true and when it happened. Then values of the resources on the left hand side of the rule which led to the rule being triggered are shown. Under the Actions taken header the resources of the right hand side are shown. First the list of the classes whose objects take up most of the space on the JVM heap is requested. Filters excluding all standard classes java. javax. are applied so that only two classes appear on the list. This is because the application run by our JVM is truly simple. The second action is a 15 second allocation trace report for objects of the classes found on the top heap objects list. Under jvm AllocTrace you can see all allocations of objects of the two classes. Each allocation trace shows where in what method of what class it took place. It also shows the line number in the source code for that class if available such would be available when the source code was compiled without disabling the debugging information generation .

The invention can be implemented in software hardware or a combination of hardware and software. The invention can also be embodied as computer readable code on a computer readable medium. The computer readable medium is any data storage device that can store data which can be thereafter be read by a computer system. Examples of the computer readable medium include read only memory random access memory CD ROMs magnetic tape and optical data storage devices. The computer readable medium can also be distributed over a network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

The many features and advantages of the present invention are apparent from the written description and thus it is intended by the appended claims to cover all such features and advantages of the invention. Further since numerous modifications and changes will readily occur to those skilled in the art it is not desired to limit the invention to the exact construction and operation as illustrated and described. Hence all suitable modifications and equivalents may be resorted to as falling within the scope of the invention.

