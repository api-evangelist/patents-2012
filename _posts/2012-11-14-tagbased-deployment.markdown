---

title: Tag-based deployment
abstract: Methods and systems for deploying upgrades are provided. In an example, a release package containing upgrade for software application, operating system, firmware and the like may be tagged with one or more package tags. Each of the package tags may be associated with a tag category comprising one or more tag values which may form a tag hierarchy. In an example, a target host for a upgrade release may be tagged with one or more host tags similar to the package tags. In an embodiment, a release package may be selected from a plurality of release packages to be deployed to a host by matching the package tags associated with the release package to the host tags associated with the host. The package tags, host tags and associated tag categories may be arbitrarily defined and/or extended.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489188&OS=09489188&RS=09489188
owner: Amazon Technologies, Inc.
number: 09489188
owner_city: Reno
owner_country: US
publication_date: 20121114
---
Components installed on computing systems or computing devices such as application software operating systems firmware and the like sometimes need to be upgraded or rebuilt to fix bugs improve existing features and or introducing new features or releases. The determination of which particular upgrade to be deployed to a particular host often depends on various characteristics of the host such as computer architecture operating system geographic region and the like. Traditionally such determination has been performed manually. However for large and complex upgrade deployments involving many upgrades and hosts such manual determination is likely to become cumbersome and error prone.

In the following description various embodiments will be described. For purposes of explanation specific configurations and details are set forth in order to provide a thorough understanding of the embodiments. However it will also be apparent to one skilled in the art that the embodiments may be practiced without the specific details. Furthermore well known features may be omitted or simplified in order not to obscure the embodiment being described.

Techniques described and suggested herein can be used to select and deploy upgrade packages to target hosts by matching package tags associated with the upgrade packages and the host tags associated with the hosts. In various embodiments an upgrade package refers to a collection of executable instructions program code data files such as disk image files firmware image files configuration files and the like that may be distributed to and installed on a computing system or device. An upgrade package is typically utilized to fix bugs or to introduce new and or improved features associated with application software operating systems firmware and the like. As used herein a target host hereinafter host refers to an entity such as a computer system or hardware device where an upgrade package may be installed. Such hosts may include a variety of virtual or physical computational entities such as virtual or physical computer systems data storage devices network devices e.g. network switches mobile devices set top boxes and the like.

In some embodiments upgrade packages may be built and organized according to certain structure or hierarchy. In an embodiment upgrade packages may be built for different entities such as application software product or component operating system firmware or the like. In such an embodiment upgrade packages may be grouped by the name of the entity for which the upgrade packages are built. For example such packages may share the same package name prefix such as kernel openssl office and the like. In an embodiment upgrade packages built for the same entity may be grouped by various versions of the entity including major versions minor versions and the like. In some examples an upgrade package may also be referred to as a package variant to denote a particular combination of build characteristics or dimensions such as distribution architecture region kernel feature release family instance type and the like some of which are discussed below. One or more upgrade packages may be selected to be added to a release. The same upgrade package may be added as a release package to one or more releases. In some embodiments once a release is built e.g. when all resources required by the installation of the release is created the release packages contained in the release may become snapshots of the corresponding upgrade packages unaffected by subsequent changes to the upgrade packages.

In various embodiments an upgrade package may be associated with one or more package tags that correspond to various package or build characteristics such as a processor instruction set or instruction set architecture architecture hereinafter for which a package is built e.g. x86 x86 64 bit extension i386 Advanced RISC Machine ARM Microprocessor without Interlocked Pipeline Stages MIPS etc. a particular distribution or distro of the package e.g. Red Hat Enterprise Linux RHEL a geographical region or language for which the package is built version of the kernel release for the package computing resources required for the installation of the package e.g. input output I O central processing unit CPU power memory etc. and other characteristics. In some embodiments each package tag may be associated with a tag category such as architecture or distribution. Each tag category may be associated with a set of tag values. For example x86 and i386 may be tag values for the tag category of architecture. In some embodiments a package tag may include a single tag value. In other embodiments a package tag may be represented in other formats. For example a package tag may include a name value pair e.g. architecture i386 where the name of the name value pair may correspond to a tag category and the value of the name value pair may correspond to one of a set of possible tag values associated with the tag category.

In some embodiments the set of tag values for a particular tag category may form a tag hierarchy which is a hierarchical structure such as a tree structure where the root node may denote the most generic tag value within the tag category and nodes at lower levels denote progressively more specific tag values. For example the tag hierarchy for the tag category of architecture may include noarch as the root node of the tag hierarchy to denote any architecture. Noarch may have two children nodes i386 and x86 to denote more specifically the i386 based and x86 based computer architectures. Moreover x86 may have children nodes x86 32 x86 64 and x86 128 to denote in further specificity the 32 bit 64 bit and 128 bit extensions of the x86 based architecture. As used herein tag hierarchy may be used to refer generally to any data structure formed by the tag values associated with a tag category where the data structure is not limited to a hierarchy. For example a tag hierarchy may include a list a set or the like.

In some embodiments some of the package tags described above e.g. architecture distribution may be used to select an appropriate package to install for a particular host such as a computer system a hardware device and the like as described in more detail below. In other embodiments package tags may be used for other purposes. For example a reboot package tag associated with a package may be used to indicate that a reboot is required for changes included in the package to take effect. For another example an optional package tag may be used to indicate that the package does not need to be installed on every target host associated with a release for which the package is a part of.

In various embodiments package tags hierarchies discussed above may be provided by default or defined by user and may be modified and or extended in any suitable fashion. For example new tag categories or hierarchies may be added or existing tag hierarchies may be modified to add remove and or modify tag values to control which packages get deployed on which hosts. In various embodiments information about the tags and tag hierarchies may be stored and or managed by a deployment service or some other entity. An interface such as a web and or graphical user interface GUI a web service interface an application programming interface API a command line tool or the like may be provided to enable user modification and management of tags and tag hierarchies.

While the package tags and tag hierarchies described above are typically associated with packages or package variants similar tags or tag hierarchies may also be associated with any aggregation of packages or package variants. For example a set of tags may be associated with a package product group comprising packages for the same software product or component e.g. openssl kernel . As another example a set of tags may be associated with a package version group comprising packages for the same version of a software product. Where multiple layers or levels of aggregations are involved tags associated with one layer of aggregation may be inherited or otherwise shared by tags associated with another layer of aggregation. For example a package variant may inherit tags associated with a package version group which may in turn inherit tags associated with a package product group. In general tags and tag hierarchies similar to those described herein may be associated with any other versioned entities such as releases builds deployments and the like.

In various embodiments tags and tag categories associated with versioned entities such as packages may be stored in any suitable manner. For example tags tags categories and related information may be stored within a physical package file for example as part of the metadata. Such information may also be stored separately from the physical package file for example in a local or remote data store. In some embodiments such information may be provided by a service.

In various embodiments tags may become associated with versioned entities such as packages at any suitable time. In some embodiments the tags become associated with the tags are built typically by an owner of the package. For example tags may become associated with packages when the packages are ingested by a deployment service described below . In other embodiments new tags may become associated with a package or existing tags may be modified after a package is built. In some embodiments once a release is built all package tags associated with release packages contained in the release may become frozen such that subsequent changes to the package tags e.g. addition removal of tags associated with a package may only affect subsequent releases.

In various embodiments an interface such as a web user interface an API a command line tool or the like may be provided for a user to edit tag categories or hierarchies associated and disassociate tags with versioned entities such as packages releases and the like to define policies e.g. who can update tag related information and or when where the tags are stored and to perform other tag related operations.

In some embodiments a package that is ready for deployment may become available to a deployment service. As used herein a deployment service may be configured to distribute and or install upgrade packages to one or more hosts such as computing systems and or devices. In various embodiments built packages may be made available by being pushed to a deployment service e.g. by a build service pulled by a deployment service e.g. from a build service or by a combination of both. An API may be provided for uploading or otherwise making available upgrade packages. In some embodiments a release may be built based on a subset of available upgrade packages and subsequently deployed to a group of hosts e.g. computer systems devices or components thereof . In some embodiments the release may be deployed in multiple deployments each of which may be associated with among other things a subset of the group of hosts associated with the release and or a start time for the deployment. For example a release may be deployed in a first deployment to a set of testing servers for quality assurance purposes before being deployed in a second deployment to a set of production servers.

In some embodiments an interface such as a web service interface a graphical user interface an API a command line tool or the like may be provided to allow a user such as a deployment engineer or system administrator to perform release related operations such as creating configuring e.g. by selecting or deselecting packages to be added to the release and building a release creating configuring and or scheduling one or more deployments associated with the release monitoring deployment status and the like.

In an embodiment various validation checks may be performed when a release is being built for example to ensure that no conflicting upgrades exist and or that each host has at least one applicable upgrade package in a release. Such validation checks may be performed dynamically as the releases and or deployments are being created or built. In some embodiments warnings and or error messages may be provided for failed validation checks.

In some embodiments a host may be associated with one or more host tags that describe software and or hardware characteristics or dimensions associated with the host. In some embodiments host tags are similar to package tags described herein. For example host tags may indicate the instruction set architecture software distribution region kernel release family and other characteristics of a target host as described above. Likewise host tag values may be associated with tag hierarchies similar to those described above in connection with package tags. In other embodiments host tags may include tags not included in package tags. In some embodiments an interface such as a web service interface a GUI an API a command line tool or the like may be provided for performing host tag related operations such as defining and modifying host tags and or tag hierarchies associating dissociating host tags with hosts and the like defining host tag related policies and the like.

In some embodiments host tags associated with a host may be stored with the host and or elsewhere such as in a file registry local or remote data store and the like. In some embodiments host tags may be applied to a host automatically for example based on build axes used to build the host. In such embodiments host tags may tend to be specific e.g. x86 64 rather than x86 because the build axes i.e. parameters or dimensions of a build implemented by a host are generally well defined. In some embodiments build axes may include characteristics similar to tag categories discussed above such as architecture distribution region instance type and the like. In various embodiments a build recipe may be selected based on a set of build axes to build or rebuild a host. A build recipe may include one or more steps or scripts that need to be performed to achieve the given set of build axes.

In some embodiments host tags associated with hosts may be made available to a deployment service. For example in an embodiment such information may be provided by a host by a build service configured to build or rebuild hosts and the like using push or pull technologies or a combination thereof on a periodic basis or upon the occurrence of an event e.g. receipt of a request host startup etc. .

In some embodiments a release may be deployed to a set of hosts in a centralized or distributed fashion. In an embodiment a deployment service may actively push upgrade packages to applicable hosts. In another embodiment a host may poll or query a deployment service e.g. periodically to determine if update is available and if so obtains the applicable upgrade packages to install. In such an embodiment host tag information may be provided to the deployment service as part of the polling or querying process. In yet another embodiment a combination of both push and pull technologies may be used to deploy a release to a set of hosts.

In some embodiments a suitable release package from a release may be selected to deployed at a particular host based at least in part on a match between the package tags associated with the release package and the host tags associated with the host. In an embodiment given the package tags associated with the release packages in a release and the tags hierarchies associated with the package tags a release package hierarchy may be constructed where nodes in the hierarchy correspond to the release packages. In some embodiments such a hierarchy is generated once during release build time and subsequently restored e.g. in memory using stored index information when the hierarchy is needed such as for selecting a suitable release package to deploy for a host. Such index information may indicate for example the relative positions of the nodes in the hierarchy. In some embodiments at least a portion of the release package hierarchy may be traversed to compare the package tags associated with release packages with the host tags associated with a host in order to determine a matching release package for the host. Various pattern matching or recognition algorithms may be used. In some embodiments error or warning messages may be raised for example if the release package hierarchy cannot be constructed or if a match cannot be found during a traversal of the hierarchy. In various embodiments automatic tag based selection of upgrade package as described herein may greatly simplify the task of deploying a large number of packages to a large number of hosts.

In some embodiments a release may be validated based at least in part on the release package hierarchy described above. For example when a user selects upgrade packages to be added to a release for a given set of hosts or during the time a release is being built the release package hierarchy may be constructed to ensure that no conflicting packages are added to the same release. In some embodiments two packages may conflict if a release package hierarchy cannot be constructed based on the packages. In other embodiments two packages may conflict if they both match the same host and it is not clear which is a closer match. In some embodiments the release package hierarchy is used to ensure for example during release build time that a host is matched to at least one release package in a release. Such validation may be needed for example when the release is required for all the target hosts for the release such as indicated by a required or similar tag . In some embodiments tag matching is performed after deployment starts for selecting a suitable release package to install on a host for example when a deployment service receives an update request from the host or before the deployment service pushes the release package to the host.

In various embodiments the package tags and host tags may be defined modified and extended. Various policies may be defined to control the scope and extent of such tag related operations. Such policies may include security and access control policies. For example in an embodiment only authorized entities such as package or package or host owners or builders and system administrators may perform certain operations. As another example package tags associated with a release may become immutable after the release is built to ensure consistency of upgrade deployment over a distributed environment.

In various embodiments the tag based deployment methods described herein may be used to facilitate the allocation or distribution of any versioned entities to target entities. The versioned entities may not be limited to upgrade packages and the target entities may not be limited to computational entities such as hosts.

In some embodiments an entity that builds the upgrade packages may provide the upgrade packages to the deployment service after the packages are built. In other embodiments the deployment service may pull upgrade packages from another entity such as a builder of the packages. In some embodiments the deployment service may build the packages. In various embodiments the deployment service has access to information related to the package tags tag hierarchies and package hierarchies as described above. For example such information may be stored in the packages configuration files and or data stores that are local or remote to the deployment service.

In some embodiments the deployment service may be configured to deploy the upgrade packages to one or more target hosts which may include computer systems and computing devices such as servers desktop computers laptop computers mobile device and other hardware devices such as network switches data storage devices and the like. For example the deployment service may provide software patches or kernel hotfixes to a computer system or firmware to a network switch. In some embodiments some of the target hosts may be operated by a service provider that also provides the deployment service . For example the target hosts may be used to provide services such as data processing data storage and the like. In other embodiments some of the target hosts may be operated by an entity that is different from the provider of the deployment service such as a customer of a software product. In various embodiments the deployment service may be operated by the same or different entity that provides the upgrade. For example a software manufacture may operate its own deployment service to distribute its software updates or use a third party deployment service.

In some embodiments the hosts may each be associated with a set of host tags that correspond to one or more host characteristics. In some embodiments the host tags may overlap with package tags described above. For example the host tags may include the architecture type of a host distribution of software installed on the host geographic region kernel release family of the host and the like. In other embodiments host tags may also include tags that are not available in package tags . Host tags may become associated with hosts when the hosts are built based on build axes used. The host tags may be stored with the hosts or elsewhere e.g. in a remote data store etc. .

In some embodiments a package e.g. a release package in a release may be selected for deployment on a host based at least in part on a match between the host tags associated with the host and the package tags associated with the package . For example in an embodiment a release package hierarchy may be constructed based at least in part on the package tags associated with the packages in a release and tag hierarchies associated with the package tags. Such a release package hierarchy may be traversed to find a release package for which the package tags match the host tags associated with a host.

In some embodiments the deployment service may provide an interface such as web service interface GUI such as on a web site or in an application API command line tool for users to perform various functionalities related to upgrade deployment. In some embodiments deployment service may provide an interface to allow users to build or create a release and add or remove packages to or from the release. The interface may also allow users create and configure deployments of release such as selecting target hosts or setting deployment time for a deployment.

In some embodiments deployment service may provide an interface to allow users to configure and manage package tags host tags tag categories and any tag related information. For example users may be able to add remove or edit package tags associated with upgrade packages and or host tags associated with hosts. For another example user may be able to define and change the tag hierarchies associated with the package and host tags such as adding new tag hierarchies or changing existing hierarchies. In some embodiments deployment service may even allow users to control at least some aspects of the tag matching algorithm as described herein for example by specifying and or editing rules for tag matching such as a mapping between host tags and package tags. In various embodiments users of the interfaces described herein may include any user of the deployment service such as system administrators of the target hosts software manufacturers or distributors third party service providers and the like.

In at least one embodiment one or more aspects of the tag based upgrade deployment illustrated in may incorporate and or be incorporated into a distributed computing environment. For example illustrates an example distributed computing and or datacenter environment in which various embodiments may be implemented. In this example one or more customer devices connect via network to datacenter . The customer devices may include any devices capable of connecting via a public network to the data center such as personal computers smartphones tablet computing devices and the like. In an exemplary embodiment network may include any publicly accessible networks such as the Internet mobile and or wireless networks private network or any other networks. The datacenter includes one or more management components including but not limited to a management system a gateway and or a monitoring entity which are collectively connected via internal networking to a plurality of internal servers . The gateway may filter and route traffic in and out of the datacenter such as to and or from the servers via the internal networking. The management system often referred to as control plane or control plane system may receive requests to manipulate computing resources of the datacenter such as provisioning resources altering routing and the like. In some embodiments the management system may also provide a deployment service such as discussed in connection with . The monitoring entity may receive and report information about the status of computing resources in the data center such as information about the internal servers. The management system and the monitoring entity may connect to the network via gateway or their own gateways. In various embodiments components of a data center such as servers may be located locally or distributed across one or more regions isolation or availability zones and the like.

Each internal server may provide multiple logical machine slots each slot capable of running a computing resource instance such as a virtual machine instance. Any number of the plurality of the customer devices previously described may provision to run any number of computing resource instances in any number of slots up to the limits of the datacenter whether physical logical or externally imposed and the slots may be allocated to the connecting customer devices based on operational and or business related criteria such as geographical proximity level of support and or resources allocated to the user server and or slot health and or readiness and the like. In some embodiments upgrades may be deployed to internal servers using techniques described herein.

As discussed above package and or host tags may be associated with tag categories the tag values for which may form tag hierarchies. illustrates some example tag hierarchies in accordance with at least one embodiment. In an embodiment a root node of a tag hierarchy may include the most generic tag value for the tag hierarchy whereas nodes in lower levels in the hierarchy may include progressively more specific concrete values. For example the architecture tag hierarchy illustrates an example hierarchy of tag values for an architecture tag. As illustrated the architecture tag hierarchy includes noarch as the root node of the tag hierarchy to denote any architecture. Noarch may have children nodes i386 x86 and ARM to denote more specifically the i386 based architecture the x86 based architecture and the ARM architecture. Moreover x86 may have children nodes x86 32 x86 64 and x86 128 to denote in further specificity the 32 bit 64 bit and 128 bit extensions of the x86 based architecture.

For another example the distribution tag hierarchy illustrates an example hierarchy of tag values for a distribution tag that indicates the distribution or distro. As illustrated the distribution tag hierarchy includes generic as the root node of the tag hierarchy to denote any distro. generic may have children nodes food and rhel to denote more specifically a foo distro and a Red Hat Enterprise Linux distribution. The rhel node may have children nodes that represent major versions within the rhel distro such as rhel4 rhel5 and rhel6. In further specificity the rhel5 node may have children nodes rhel5.1 and rhel5.2 to denote distros with minor revisions within the same major version.

Likewise illustrates some more example tag hierarchies in accordance with at least one embodiment. As illustrated a region tag hierarchy may be associated with a region tag that indicates the geographic region of target host s . The region tag hierarchy may include a root node world that indicates any location in the world. Progressively more specific concrete geographic regions such as America US and Boston may be represented by lower level nodes e.g. America US and Boston in the region tag hierarchy as shown in . Also as illustrated an entity tag hierarchy may be associated with an entity tag that indicates the type of entity for target host s . The entity tag hierarchy may include a root node Generic that indicates any type of entity. Progressively more specific concrete entity types may be represented by lower level nodes such as Gov government non gov non government Fed federal agency and State state agency such as shown in .

In some embodiments tag hierarchies described herein may be defined and updated via an API provided by a deployment service such as described here or any other service. For example new tag hierarchies may be added and a new tag can be created and inserted into an existing hierarchy. In some embodiments such updated tag hierarchies may be made available to be associated with upgrade packages and or hosts shortly after the updates occur. As discussed above the tag hierarchies discussed herein may be associated with both package tags and host tags.

Between feature releases patches or hotfixes may be released for example to fix software bugs and or provide additional or improved features. Typically different sets of patches or hotfixes apply to different kernel feature releases. Kernel upgrade path shows an example of such an upgrade path. For example hotfixes A B and C may be applied only on top of kernel feature releases A B and C respectively. In some embodiments a host may be tagged with a kernel release tag that indicates the current kernel feature release family for the kernel running on the host. An upgrade package that contains a hotfix or a patch may be tagged with one or more kernel release tags to indicate the kernel feature release family or families for which the hotfix or patch applies. Thus in an embodiment kernel hotfixes or patches may be matched with the corresponding kernel feature release families by matching the kernel release tag of the package and the kernel release tag of the host. In some embodiments when a new or upgraded kernel is installed on a host e.g. from B to C the host tags associated with the host may be updated to reflect the current kernel release installed on the host. For example a new kernel release tag indicating the current kernel release may be added to the host tags.

In some embodiments upgrade packages may be aggregated based on attributes of the packages. Tags similar to the package tags described herein may be associated with any layer of such aggregation. illustrates an example aggregation of packages in accordance with at least one embodiment. In this example package variants may be aggregated by versions of the package variants e.g. 1.0 2.3 and versions may be aggregated by the product name or type such as openssl office and the like. The layers of aggregation may form a hierarchy such that as shown in .

As discussed above tags similar to the package tags described herein may be associated with any layer and or node of the hierarchy . For example the top layer may be associated with tags such as optional and reboot which may apply to all upgrade packages or variants for the same product or type package name . The optional tag may indicate for example that it is not required that at least one of the upgrade package s must be applied to a target host. The reboot tag may indicate for example that a reboot is required for upgrade to take effect. As illustrated a version layer or node may also be associated with a set of tags that apply to all package variants with the same version. The version specific tags may or may not inherit some or all of tags associated with the name layer e.g. optional and reboot . Finally each variant within a package version may be associated with tags that may include inherited tags e.g. optional and reboot as well as non inherited tags e.g. arch architecture and dist distribution . In various embodiments the hierarchy may include more or less levels of aggregations or abstractions than illustrated here and tags same or different than illustrated here may be associated with some or all levels of the hierarchy .

An interface such as a GUI or API may be provided for performing tasks related to various aspects of deployment process such as illustrated in . For example a web service command line tool or graphical editor may be provided for example by a deployment service to create delete or otherwise manage a release such as adding and removing packages associated with the release adding and removing target hosts associated with the release building the release adding removing and configuring deployments associated with a release and to perform other deployment related tasks. In various embodiments one or more policies related to security access and the like may be configured for the deployment related operations.

In an embodiment process includes creating an upgrade release. In some embodiments a newly created release may be associated with a default set of packages and or target hosts. In other embodiments a newly created release may not be associated with any packages and or target hosts. In such embodiments the release may be deployed to target hosts via one or more deployments discussed in connection with . In some embodiments packages and or target hosts may be added and or removed for example via an API.

In an embodiment process includes adding one or more upgrade packages to the created release. In some embodiments the one or more upgrade packages may be selected from a plurality of upgrade packages that are made available for example to a deployment service. At least some of such upgrade packages may be associated with one or more package tags as described herein. For example the package tags or information about the package tags may have been built into the physical upgrade packages or stored in a data store that is local or remote to a deployment service. As discussed above each of the package tags may be associated with a tag hierarchy. Information about such tag hierarchies may also be made available for example in the upgrade packages a configuration file a data store that is local or remote to a deployment service or the like.

In an embodiment an interface such as a GUI or API may be provided to modify the tag hierarchies and package tags. For example a command line tool or a web user interface may be provided for example by a deployment service to allow an authorized user to create new tag hierarchies and to modify existing tag hierarchies. In addition package tags based on existing tag hierarchies may be associated with or disassociated from upgrade packages for example using a similar interface. In some embodiments tags or tag hierarchies may be generated and or modified by a computer system such as a package building system a user such as a system administrator via a user interface or a combination thereof. In some embodiments such tag modifications may be governed by one or more rules or policies such as access control policies.

In an embodiment process includes performing validation of the release. In some embodiments such validation may be performed based on the package tags and tag hierarchies associated with the upgrade packages that are included in the release. For example in an embodiment the package tags associated with the upgrade packages are checked to ensure that no two conflicting upgrade packages exist. As another example validation may be performed to ensure that a package that is required to be installed on a set of target hosts e.g. as evidenced by a required package tag or the lack of an optional tag can indeed be installed on the set of target hosts for example by ensuring that the package tags associated with the required package matches the host tags associated with the set of target hosts using tag matching techniques described in more detail in connection with .

The release validation described above may be performed at any suitable point in time. For example some or all of the validation checks may be performed after an indication that a release is finalized and or ready to be built e.g. when the user clicks on a Submit button or other similar controls in a user interface for editing releases . As another example some or all of the validation checks may be performed as part of the release building process or after each change to the release such as after the addition of each package. In some embodiments error or warning messages or logs may be provided when validation fails. The correction of an validation error may be required or optional for building the release. In some embodiments the release may not be validated at all.

In an embodiment process includes building the release for example if the validation of the release succeeds. Building the release may involve gathering and or generating information and resources required for the deployment of the packages selected to be included in the release. In some embodiments release packages corresponding selected upgrade packages are generated and built into the release. In some embodiments building the release may be based at least in part on package tags associated with the packages in the release. For example the package tags may indicate the resources that need to be complied or added to the release. In some embodiments various access rules or policies may be associated with the package tags and or tag hierarchies. For example in an embodiment the tags and tag hierarchies are mutable before a user submits the release for building. When a release is being built the tags and or tag hierarchies may become immutable to users but mutable to a system administrator building the release. After a release is finished building the tags and or tag hierarchies may become immutable to both users and system administrators.

In some embodiments the built release may be deployed to a set of hosts in one or more deployments. Each of the deployments may be associated with a scheduled start time a subset of the set of hosts and other deployment related information. In various embodiments the one or more deployments may be configured to start at the same or different times. For example a release may be deployed to a set of target hosts that share one or more common characteristics e.g. geographic region software hardware configuration etc. before being deployed to another set of target hosts. As described above an interface may be provided for example by a deployment service to create configure cancel and or monitor the deployments associated with a release.

In an embodiment process includes identifying a target host for deployment. In some embodiments identifying a target host may involve selecting the target host e.g. randomly or according to a predetermined algorithm or schedule from a set of hosts associated with a deployment. In other embodiments identifying a target host may involve receiving a request from a host to determine whether a release or deployment affecting the host is available such as the case when a start time for a deployment has been reached . In general upgrade contained in a release may be deployed to target hosts using push or pull technologies or a combination thereof.

In an embodiment process includes determining whether one or more packages from the release need to be installed on the identified host. Such determination may be based at least in part on one or more host tags associated with the identified host. In some embodiments a system implementing process such as a deployment service may have access to the host tags associated with the identified host. In some cases the host may provide the host tags to the system on its own e.g. on a periodic basis or in response to a request. In other cases the system may obtain the host tags from some other sources such as a build or rebuild service for the hosts. In some embodiments one or more packages included in the release may be selected based at least in part on a match between the package tags associated with the packages and the host tags associated with the host such as described in connection with .

In an embodiment if it is determined that one or more such matching packages are selected based on the host tags process includes causing the installation of the selected packages on the host. In some embodiments the selected packages may be provided to the host by any suitable communication means e.g. over a network or using a data storage medium such a CD or remote network drive . The installation of the selected package s may involve decompressing decrypting or otherwise decoding the selected package s running an installer copying and or updating data or performing any other installation tasks required to install the selected package s . Otherwise if it is determined that none of the packages match the host tags process may include determining whether more hosts need to be upgraded. In various embodiments upgrades may be deployed to hosts in parallel or sequentially in a centralized or distributed fashion.

In some embodiments the system implementing process may keep track of the deployment status of all target hosts of a release and determines whether more hosts needs to be upgraded based on the status of the hosts. For example such record keeping may be performed by a centralized or distributed deployment service. In some embodiments each host may query a deployment service for example on a periodic basis to determine if upgrades are available. In an embodiment if it is determined that more hosts need to be upgrade process includes looping back to block to identify the next host to deploy the release. Otherwise if it is determined that no more hosts need to be upgraded process may end . In some embodiments process may include causing some of the target hosts to reboot if necessary. In an embodiment a reboot aggregator service may be configured to keep track of the hosts that need to be rebooted and reboot the hosts at appropriate times such as when no critical application is running on the host s .

In some embodiments process includes generating a release package hierarchy based at least in part on the package tags associated with the release packages and the tag hierarchies associated with the package tags. Based on the generated release package hierarchy in an embodiment a parent node index field or some other similar position indicating index field for each release package may be populated so that the release package hierarchy may be restored later based on the index. In general any suitable data structures and or storage medium may be used to record information about the generated release package hierarchy. For example information about the generated release hierarchy may be stored in an Extensible Markup Language XML file one or more database tables and the like. In some embodiments steps and of process may be performed as a part of building a release such as discussed in more detail in connection with .

In some embodiments process includes obtaining host tags associated with a host. For example the host tags may be provided by the host for example as part of a request to a deployment service to determine if upgrade is available for the host. As another example host tags of a host may be provided to a deployment service by another entity such a build service configured to build or rebuild the hosts. As discussed above a release may be associated with a set of hosts. Host tags associated with the set of hosts may be provided for example to a deployment service before the release is deployed to the set of hosts.

In some embodiments process includes determining a matching release package based at least in part on the host tags associated with the host and the release package hierarchy generated above. In some embodiments the index associated with each release package may be used to restore the release package hierarchy in memory and the host tags may be used to determine a matching release package in the release package hierarchy such as discussed in more detail in connection with . In some embodiments step may be optional and determining may include comparing the host tags to the host tags associated with each of the release packages.

In some embodiments the determination a matching release package is performed in order to select the matching release package for deployment on the host. In other embodiments the determination is performed to check validity of the release for example to ensure that for each of the set of hosts corresponding to the release there is at least one matching release package. Such validity check may or may not be necessary depending on whether the release is required to be installed on all the hosts such as indicated by a tag e.g. required or optional associated with the release or the packages.

In an embodiment process includes initializing release packages based on corresponding upgrade packages selected for a release. As discussed before a release package may represent a snapshot of an upgrade package. For example illustrates an example implementation of initialization of release packages in accordance with at least one embodiment. As illustrated by upgrade package 0 package 1 package 2 package 3 and package 4 are selected for release . During initialization release package 0 release package 1 release package 2 release package 3 and release package 4 may be created and initialized based at least in part on the corresponding upgrade packages. In an embodiment an upgrade package such as package may include a package file field that contains a reference to a package file such as file field and metadata e.g. tags field associated with the upgrade package. In the illustrated example each of the upgrade packages is associated with two package tags distribution architecture that indicate the distribution and target architecture of the package respectively. For example the tags rhel5.1 i386 associated with package indicates that the distribution for the package is RHEL version 5.1 and that the package is built for target architecture of i386. The distribution tag may be associated with the distribution tag hierarchy and the architecture tag may be associated with the architecture tag hierarchy as shown in .

In an embodiment a release package e.g. release package may include fields that are initialized based on fields from a corresponding upgrade package e.g. upgrade package . Such fields may include the package file field e.g. file field and tags field e.g. tags field . The release package may also include additional fields such as a release field e.g. release field that identifies the parent release e.g. release package field e.g. package field that identifies the corresponding upgrade package an index field e.g. parentNode index that identifies directly or indirectly the position of the release package in a release package hierarchy to be constructed and other fields. In the illustrated embodiment the index field contains an identifier or a reference a parent node in the release package hierarchy or NULL if the release package does not have a parent node e.g. when the release package is the top most release package in the hierarchy . In some embodiments the index field may be initialized to NULL or some other values and subsequently populated with the index value after the construction of the release package hierarchy discussed below.

Referring back to once the release packages have been initialized the process may include constructing a release package hierarchy based at least in part on the package tags associated with the release packages and tag hierarchies associated with the package tags. In some embodiments the tag hierarchy information may be obtained from a configuration file or a local or remote data store. In an embodiment the tag hierarchies associated with the package tags may be pruned based on the package tags and the pruned tag hierarchies may be merged to derive the final release package hierarchy.

In some embodiments pruning a tag hierarchy includes removing or excluding from consideration nodes that do not correspond to any package tags associated the packages in the release. illustrates an example implementation of pruning a distribution tag hierarchy given the release packages shown in in accordance with at least one embodiment. Starting with a distribution tag hierarchy similar to the distribution tag hierarchy shown in each node of the hierarchy may be traversed and compared with the distribution tag if any of each release package in the release. Nodes that do not correspond to any distribution tags for the release packages may be removed or pruned. In this example only the nodes rhel5.1 associated with release packages 0 and 1 foo associated with release package 2 and generic associated with release packages 3 and 4 have corresponding distribution tags in the release packages. Thus the rest of the nodes in the hierarchy rhel rhel4 rhel6 and rhel5.2 may be removed from the distribution tag hierarchy resulting in a pruned distribution tag hierarchy as shown in .

Similar pruning process may be performed for the other tag hierarchies associated with the package tags in a release. For example illustrates an example pruning process for an architecture tag hierarchy given the release packages shown in in accordance with at least one embodiment. Starting with a architecture tag hierarchy similar to the architecture tag hierarchy shown in each node of the architecture hierarchy may be traversed and compared with the architecture tag if any of each release package in the release. Nodes that do not correspond to any architecture tags for the release packages may be removed or pruned. In this example only the nodes noarch associated with release package 4 i386 associated with release packages 0 1 and 2 x86 64 associated with release package 2 have corresponding architecture tags in the release packages. Thus the rest of the nodes in the hierarchy x86 ARM x86 32 and x86 128 may be removed from the hierarch resulting in a pruned architecture tag hierarchy as shown in . In some embodiments the pruning process such as described in connection with may be performed for each tag hierarchy for which there are corresponding package tags in the release. Such pruning of tag hierarchies may be useful for reducing the resources e.g. space time required to generate the release package hierarchy discussed below. In some embodiments the pruning of tag hierarchies may be optional.

In some embodiments the pruned tag hierarchies may be merged to derive the final release package hierarchy. illustrates an example that shows the merging of two pruned tag hierarchies to derive a release package hierarchy in accordance with at least one embodiment. As illustrated pruned distribution tag hierarchy corresponds to a release package hierarchy where each node in release package hierarchy includes release packages that have the corresponding distribution tag. For example as shown release packages 3 and 4 have generic as their distribution tags package 2 has foo as its distribution tag package 1 has rhel5 as its distribution tag and package 0 has rhel5.1 as its distribution tag. Similarly pruned architecture tag hierarchy corresponds to a release package hierarchy where each node in release package hierarchy includes release packages that have the corresponding architecture tag. For example as shown release package 4 has noarch as its distribution tag packages 0 1 and 2 have i386 as their distribution tags and package 3 has x86 64 as its distribution tag.

In some embodiments nodes of the pruned tag hierarchies may be merged to generate a merged hierarchy such that each node of the merged hierarchy may include tags associated with a distinct release package in the release. The resulting merged hierarchy or release package hierarchy thus incorporates all tag categories associated with all the package tags in the release. For example as shown in the distribution tag hierarchy may be merged with the architecture tag hierarchy to form the merged hierarchy . In various embodiments any suitable hierarchy or tree merge algorithm may be used to merge two or more release package hierarchies such that the merged hierarchy preserves or at least does not conflict with the relative positions of the nodes in the individual hierarchies. For example in an embodiment each node of tag hierarchy A may be merged with every other node of tag hierarchy B to form a new node and nodes that do not correspond to a package tag combination for any release package may be removed.

Referring back to in an embodiment process includes storing information about the release package hierarchy generated above. In some embodiments the release package hierarchy is generated in memory and information about the generated release package hierarchy may to be persistently stored for subsequent restoration of the hierarchy. In some embodiments storage of such information may be optionally since the information is merely an optimization to reduce the computing resource and time required to reconstruct the release package hierarchy. In embodiments where such information is not stored the release package hierarchy may be constructed from scratch. In some embodiments the information may include the relative positions of the nodes in the hierarchy. In an embodiment storing information about the release package hierarchy includes populating the index field of each release package based on its position in the release package hierarchy. illustrates an example population of index fields of release packages based on a release package hierarchy such as the release package hierarchy shown in in accordance with at least one embodiment. In some embodiments the index field of a release package may be populated with an identifier that identifies the parent node of the release package in the release package hierarchy or NULL if the release package is the topmost node in the hierarchy. In the illustrated example the index field of release package 0 may be populated with an identifier that points to release package 1 as the parent node according to the release package hierarchy in . Further release packages 1 2 and 3 have index fields and populated with identifiers that point to release package 4 as their parent node. Finally the index field of release package 4 may be set to NULL to indicate that it is the topmost node in the release package hierarchy in . In general information about the release package hierarchy such as the relative positions of the nodes may be recorded and stored using any suitable methods and or medium such as using a XML file a database table and the like.

In an embodiment process includes constructing a release package hierarchy such as in accordance with process in . In some embodiments the construction of the release package hierarchy may be performed from scratch as discussed in connection with . In some embodiments the construction includes restoring the release package hierarchy e.g. in memory based at least in part on previously stored information about the hierarchy such as an index as discussed in connection with . In various embodiments such information may be stored in a configuration file local or remote data store and the like. In some embodiments construction of a release package hierarchy may be optional.

In an embodiment process includes obtaining one or more host tags associated with a host. In some embodiments such host tags may be provided by the host or by a third party entity such as another host or service. For example a host may provide its host tags to a deployment service when during boot time or on a periodic basis. For another example host tags associated with a host may be stored and or managed by a service which may provide host tag information.

In an embodiment process includes traversing nodes in a release package hierarchy to identify one or more matching nodes based at least in part on the host tags. In some embodiments the release package hierarchy is traversed in order to find the closest match. In other embodiments more than one matching nodes may be identified and or provided. Various matching criteria may be used to determine whether the package tags associated with a node match the host tags associated with the host. For example in an embodiment each host tag is compared with the corresponding package tag i.e. both the host tag and the package tag belong to the same tag category or tag hierarchy if any of the node. If the host tag is same as or descends from the package tag in the tag hierarchy then the package tag and the host tag may be considered to match each other. In some cases if a host tag does not have a corresponding package tag for the node the package tags associated with the node may be considered to match that particular host tag. In an embodiment a node matches a host only when package tags associated with the node respectively match all the host tags associated with the host.

In some embodiments the release package hierarchy is traversed in a recursive fashion from top to bottom e.g. depth first or breadth first . In an embodiment for each node if its host tags match the host tags the nodes in the sub hierarchy rooted at the node may be traversed. On the other hand if the node does not match the host tags or if it is a leaf node i.e. with no children nodes then the search ends. Consider for example searching for a matching release package in a release package hierarchy as shown in given host tags rhel5.2 i386. To start with the host tags may be compared with tags generic noarch associated with the root node of the release package hierarchy in a pairwise fashion assuming that the package tags and host tags are based on the tag hierarchies and shown in . Since rhel5.2 descends from generic in the distribution tag hierarchy of and i386 descends from noarch in the architecture tag hierarchy of the root node corresponding to release package 4 may be considered a match for the host.

Since the root noted is found to match the host the hierarchy based at the root node may be traversed. In the illustrative example release package 3 with tags generic x86 64 does not match the host with tags rhel5.2 i386 because although generic matches rhel5.2 x86 64 does not match i386 since i386 does not descend from x86 64 in the architecture tag hierarchy of . Similarly release package 2 with tags foo i386 does not match the host because rhel5.2 does not descend from foo in the distribution tag hierarchy of . On the other hand release package 1 with tags rhel5 i386 does match the host because rhel5.2 descends from rhel5 in the distribution tag hierarchy of and i386 is identical to i386.

Since a match release package 1 is found the sub hierarchy of the matching node may be traversed. In this case release package 0 with tags rhel5.1 i386 does not match the host tags rhel5.2 i386 because rhel5.2 does not descend from rhel5.1 in the distribution tag hierarchy of . At this point the search may end because all the sub hierarchies associated with matching nodes have been traversed. In this search two matching nodes release packages 1 and 4 have been found where release package 1 matches the host tags more closely than release package 4. Accordingly release package 1 may be selected as the matching release package for the host. In some embodiments both matching nodes may be provided. In some embodiment an error or warning message may be raised if a required release package e.g. with a required tag or without an optional tag is found not to match the host.

As another example consider searching for a matching release package in a release package hierarchy as shown in given host tags foo x86 64 associated with a host. Again root node with tags generic noarch matches the host for reason discussed above. Traversing children nodes for release packages 1 2 and 3 it may be determined that only release package 3 with tags generic x84 64 matches the host for reasons discussed above. The search ends here since the node for release package 3 is a leaf node. Accordingly the more closely matched release package 3 may be returned. In some embodiments both matching release packages 3 and 4 may be returned.

As yet another example consider searching for a matching release package in a release package hierarchy as shown in given host tags rhel6 i386 associated with a host. Again root node with tags generic noarch matches the host for reason discussed above. Traversing children nodes for release packages 1 2 and 3 it may be determined that no match is found for reasons discussed above. The search ends here since no matching node is found in this round. Accordingly the only matching node is the root node release package 4 .

Still referring to process may include determining whether a matching node or matching nodes are found. If so process may include providing the release package s for the matching node s . Otherwise process may include determining whether the release is optional for the host. In some embodiments the release or release packages within the release may be associated with an indication of whether the release or some or all packages within the release are optional for the host. Such indication may include an optional tag the release or with some or all packages within the release. If it is determined that the release is optional process may include providing an indication that no release package is available for the host. Otherwise if it is determined that the release is required process may include providing a warning error message or logging the error. In some embodiments an error message or log may be provided if a release package is required but does not match a host even if a different matching package is found for the host.

In some embodiments aspects of process may be configurable for example by a system administrator deployment engineer or the like. For example in an embodiment a user may be allowed to specify e.g. via a user interface how to treat a no match situation. The user may be presented options to treat it as an error e.g. providing an error message to ignore it or to take some other actions.

In this example each of one or more hosts may be processed to determine whether a given host has reached its goal state. Such processing may be performed sequentially e.g. one host at a time or in parallel e.g. multiple hosts at a time . As used herein a goal state of a host refers to a state of the host where no more upgrade needs to be installed based on the software including operating system and or firmware currently installed on the host. In some embodiments a host may query a deployment server or service with its current state to determine whether it has reached its goal state. In other embodiments a service or server may poll a host to determine whether the host has reached its goal state. In some embodiments determining a goal state may include determining whether a deployment applicable to the host exists e.g. when the scheduled deployment time has been reached . Such determination may be based on the tags associated with the host build axes used to build the host kernel version of the host unique identifier of firm image installed on the host and the like.

If it is determined that a host is at its goal state another host may be processed as described above. In various embodiments the hosts may be process in parallel or sequentially. Otherwise if it is determined that a host is not at its goal state anti entropy actions may be taken to drive the host to its goal state. As used herein anti entropy actions may include any actions or processes performed to minimize the difference between a host s current state and the host s goal state. In some embodiments anti entropy actions may include pulling e.g. by a host and or pushing e.g. by a deployment service release packages to the host based at least in part on the host tags associated with the host similar to the processes and described in connection with respectively. Anti entropy actions may also include installing or causing the installation of the upgrades on the hosts for example by obtaining suitable build or rebuild recipes.

In some embodiments it may be determined that a reboot of a host is necessary for the upgrades to take effect. Such determination may be based on the tags e.g. a reboot tag associated with a release and or release package installed on the host. If a reboot is not necessary the next host may be processed for goal state. Otherwise the host may be rebooted immediately or at a later time. In some embodiments a reboot rebuild aggregation service may be configured to keep track of all hosts that need to rebooted for example by maintaining a reboot list. The reboot rebuild aggregation service may pass the reboot list to a reboot rebuild coordination service which may be configured to drive the to be rebooted hosts into reboot or rebuild state via resource draining service migration providing customer reboot incentives and the like. In some embodiments the reboot rebuild coordination service may provide notifications to a rebuild reboot notification processing service which may be configured to process the notifications and remove the hosts that are rebuilt or rebooted from the rebuild reboot list.

The illustrative environment includes at least one application server and a data store . It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HyperText Markup Language HTML Extensible Markup Language XML or another appropriate structured language in this example. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein.

The data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data store illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing log data which can be used for reporting analysis or other such purposes. It should be understood that there can be many other aspects that may need to be stored in the data store such as for page image information and to access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable storage medium e.g. a hard disk random access memory read only memory etc. storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

The various embodiments further can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as Transmission Control Protocol Internet Protocol TCP IP Open System Interconnection OSI File Transfer Protocol FTP Universal Plug and Play UpnP Network File System NFS Common Internet File System CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including Hypertext Transfer Protocol HTTP servers FTP servers Common Gateway Interface CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disc Read Only Memory CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

Other variations are within the spirit of the present disclosure. Thus while the disclosed techniques are susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific form or forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention as defined in the appended claims.

The use of the terms a and an and the and similar referents in the context of describing the disclosed embodiments especially in the context of the following claims are to be construed to cover both the singular and the plural unless otherwise indicated herein or clearly contradicted by context. The terms comprising having including and containing are to be construed as open ended terms i.e. meaning including but not limited to unless otherwise noted. The term connected is to be construed as partly or wholly contained within attached to or joined together even if there is something intervening.

Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range unless otherwise indicated herein and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples or exemplary language e.g. such as provided herein is intended merely to better illuminate embodiments of the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non claimed element as essential to the practice of the invention.

Preferred embodiments of this disclosure are described herein including the best mode known to the inventors for carrying out the invention. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate and the inventors intend for the invention to be practiced otherwise than as specifically described herein. Accordingly this invention includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover any combination of the above described elements in all possible variations thereof is encompassed by the invention unless otherwise indicated herein or otherwise clearly contradicted by context.

All references including publications patent applications and patents cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein.

