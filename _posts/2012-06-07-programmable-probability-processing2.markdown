---

title: Programmable probability processing
abstract: In an aspect, in general, a programmable computation device performs computations of an inference task specified by a plurality of variables and a plurality of factors, each factor being associated with a subset of the variables. The device includes one or more processing elements. Each processing element includes a first storage for a definition of a factor, a second storage for data associated with the inputs and/or outputs of at least some of the computations, and one or more computation units coupled to the first storage and the second storage for performing a succession of parts of the at least some of the computations that are associated with a factor, the succession of parts defined by data in the storage for the definition of the factor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09563851&OS=09563851&RS=09563851
owner: Analog Devices, Inc.
number: 09563851
owner_city: Norwood
owner_country: US
publication_date: 20120607
---
This application claims the benefit of the right of priority to U.S. Provisional Application No. 61 494 311 titled ACCELERATING INFERENCE COMPUTATION filed Jun. 7 2011. This application also claims the benefit of and for U.S. purposes is a continuation in part of U.S. patent application Ser. No. 13 187 466 filed on Jul. 20 2011. These applications are incorporated herein by reference.

This invention was made with government support under FA8750 07 C 0231 awarded by the Defense Advanced Research Projects Agency DARPA . The government has certain rights in the invention.

One approach to inference based computation e.g. Belief Propagation BP makes use of factor graphs for instance as described in Loeliger Introduction to Factor Graphs IEEE Signal Processing Magazine January 2004. One graph based inference approach is the Sum Products SP approach as described in the referenced paper. Another approach is the Min Sum MS approach also referred to as Max Sum or Max Product which can be regarded as an approximation of the SP approach. A description of such algorithms may be found in H. Wymeersch Iterative Receiver Design Cambridge University Press Cambridge 2007.

Referring to an example of a portion of a factor graph includes factor nodes and variable nodes . Factor node implements a factor e.g. a constraint that depends on the variables A B and C associated with variable nodes respectively. In the SP approach the factor node receives messages from the adjacent variable nodes and uses those messages to compute and emit output messages back to the variable nodes. In the SP approach we use the notation right arrow over or more explicitly right arrow over to represent the message from the variable node associated with variable A to factor node associated with factor F. Similarly the message passing back to the variable node is represented as or more explicitly . For the factor graph shown in the messages for factor node are computed as follows 

The weights w a b c represent the factor for example as a probability distribution with all the values adding up to 1.0 of as another form of distribution or as 0 1 indicator values.

In the Max Product approach the summations are effectively replaced with max operations. The Min Sum approach is effectively a logarithmic version of the Max Product approach. The messages represent logarithmic messages for instance defined as right arrow over l log right arrow over taking the logarithm element wise . Similarly the weights are defined as W a b c log w a b c . For the MS approach the messages are computed as follows min 2a min 2b min 2c 

In the discussion below we use the notation A to represent the number of values that the variable A can take on. In this notation the number of terms in the sum for c is A B . For instance if each variable can take on one of 64 values there are 4096 terms in the sum or min which must be computed for each of the 64 output values for a total of over 0.78 million terms to compute three output messages.

There is a need to accelerate computation of the messages for the purpose of accelerating inference computation for example based on factor graphs.

In an aspect in general a programmable computation device performs computations of an inference task specified by a plurality of variables and a plurality of factors each factor being associated with a subset of the variables. The device includes one or more processing elements. Each processing element includes a first storage for a definition of a factor a second storage for data associated with the inputs and or outputs of at least some of the computations and one or more computation units coupled to the first storage and the second storage for performing a succession of parts of the at least some of the computations that are associated with a factor the succession of parts defined by data in the storage for the definition of the factor.

Each computation unit may include a combination unit for combining values accessed from the second storage. The combination unit may include numeric computation logic and or analog computation circuitry. Each computation unit may include an accumulation unit for accumulating an output of the combination unit into values in the second storage. Each processing element may include multiple the computation units. Each of the computation units may have a separate part of the second storage. The first storage may be shared by the computation units.

The device may include a plurality of processing elements operable in parallel a connectivity system coupled to each of the processing elements a controller having an interface for a host system for accepting a specification of at least part of the inference task and being coupled to the processing elements via the connectivity system. Each of the processing elements may be configurable by the controller to perform a computation associated with one of the factors concurrently with other of the processing elements performing computation associated with different ones of the factors. Each of the plurality of processing elements may be coupled to the connectivity system to exchange messages via the connectivity system the messages providing inputs and or outputs to the computations associated with the factors and providing to the controller a result of performing of the at least part of the inference task.

The specification of the inference task may include a specification of a graph based inference task and each factor may be associated with an element of a graph. The connectivity system may be configurable to provide connectivity between processing elements according to the graph. The connectivity system may provide at least one of a grid a tree and a chain connectivity between the processing elements.

In another aspect in general a method for performing computations of an inference task uses a processing element of a computation device having a plurality of processing elements. The inference task is specified by a plurality of variables and a plurality of factors each factor being associated with a subset of the variables. The method includes storing at a first storage of the processing element a definition of a factor storing at a second storage of the processing element data associated with the inputs and or outputs of at least some of the computations and performing at one or more combination units of the processing element a succession of parts of the at least some of the computations that are associated with a factor the succession of parts defined by data in the first storage. Each of the one or more combination units is coupled to the first storage and the second storage.

Each computation unit may include a combination unit and performing the succession of parts of the at least some of the computations associated with a factor may include combining values accessed from the second storage. The combination unit may include numeric computation logic used in performing the succession of parts of the at least some of the computations. The combination unit may include analog computation circuitry used in performing the succession of parts of the at least some of the computations. Each computation unit may include an accumulation unit and performing the succession of parts of the at least some of the computations associated with a factor may include accumulating an output of the combination unit into values in the second storage. Each processing element may include a plurality of the computation units and performing the succession of parts of the at least some of the computations may include performing the parts concurrently on multiple of the computation units.

The method may also include accepting a specification of the inference task. The specification may include a plurality of variables and a plurality of factors with each factor being associated with a subset of the variables. The method may also include configuring each of the processing elements with data defining one or more of the plurality of factors at each of the processing elements performing computation associated with one of the factors concurrently with other of the processing elements performing computation associated with different ones of the factors and exchanging messages via a connectivity system the messages providing inputs and or outputs to the processing elements for the computations associated with the factors and providing a result of performing of the at least the part of the inference task.

Accepting the specification of the at least part of the inference task may include accepting the specification from a host at a controller of the device and the method may further include passing the result of the performing of the at least part of the inference task via the controller to the host. The specification of the inference task may include specification of a graph based inference task and each factor is associated with an element of a graph. The inference task may include a Belief Propagation task. The messages may represent probability distributions of the variables. Configuring the connectivity system may be to provide connectivity between processing elements according to the graph. Configuring the connectivity system may be according to a result of a computation performed using the device. At least one of a grid a tree and a chain connectivity between the processing elements via the connectivity system may be provided.

Finally it should be understood the programmable computation devices of the type described in this application are not limited for use in computations of an inference task specified by a plurality of variables and a plurality of factors. Acceleration of other similar operations can be implemented with the same or essentially the same structure. For example the sum product computation i.e. a linear domain processing of probability values is effectively a tensor multiplication a tensor times a bunch of vectors . Therefore other applications of tensor multiplication for example with sparse data representations can be addressed as well.

Other features and advantages of the invention are apparent from the following description and from the claims.

Referring to a reconfigurable processing system includes a host system e.g. a conventional digital computer which is connected via a data bus to a programmable probability engine . The programmable probability engine includes a processing unit and a front end e.g. a digital controller implemented on a field programmable gate array FPGA which is coupled to the bus providing a means of communication between the processing unit and the host system .

The probability engine is programmable to implement various types of probability based processing and in particular is programmable to implement inference graphs e.g. factor graphs for instance to solve Bayesian inference problems. In an example of such a use a specification of a factor graph is created on the host system and all or part of the graph specification is passed to the probability engine from the host system . In some examples the graph is specified using an approach described in the co pending application titled DESIGN AND IMPLEMENTATION OF FACTOR GRAPHS U.S. patent application Ser. No. 13 006 060 filed Jan. 1 2011 which is incorporated by reference.

In some examples the probability engine includes an analog processing unit which is configurable to solve the graph while in other embodiments digital numeric processing is used or a combination of analog and numeric processing is used. It should also be understood that the graph is not necessarily implemented and operated on as a whole by the processing unit . Rather depending on the configuration of the processing unit various portions e.g. portion of the graph can be processed at different times and or on different subsets of the processing unit as is described in a later section.

Referring to one embodiment of a reconfigurable processing system includes a processing unit which includes a single probability processor element . In general the probability processor element is a special purpose processor specifically designed to perform computation for the Min Sum or Sum Product algorithm on individual factors in a factor graph. The probability processor element is programmable in that it can perform this computation for an arbitrary factor over discrete variables.

The probability processor element includes a sequencer including an instruction memory a factor table memory N computation units referred to herein as slices and N first in first out FIFO micro instruction queues each corresponding to one of the N slices .

In general the host system analyzes a problem graph as shown in element and determines a sequence of computations which are necessary to compute the problem graph as well as necessary factor table records. The analysis can be accomplished for example by using an application programming interface API and a compiler designed specifically for the programmable probability engine . Based on the determined sequence of computations the host system transfers high level instructions into a RAM along with the necessary factor table records if not already resident e.g. from an earlier computation or from another prior configuration . The front end reads the high level instructions from the RAM using direct memory access DMA and provides them to the processing unit via a host interface . The front end also reads the factor table records from the RAM and provides them to the processing unit via the host interface .

The factor table records accepted from the host interface are provided to the factor table memory . The high level instructions accepted from the host interface are provided to the instruction memory in the sequencer . The sequencer fetches the high level instructions from the instruction memory and parses them into micro instructions which are provided to a local instruction sequencer associated with each of the N slices . In some embodiments the local sequencer also provides memory addresses of records to the factor memory . The records at the provided memory addresses are fetched from the factor memory and provided to the appropriate slice .

Collectively the slices perform belief propagation for one factor of a factor graph by performing message passing algorithms such as the Min Sum Sum Product and Mean Field algorithms. In some examples a single shared instruction sequencer causes the slices perform message passing algorithms while operating in lock step with one another with each slice operating on distinct data. In other examples each slice has its own instruction sequencer along with its own instruction memory . In such a case the slices may operate more independently of each other for example synchronizing with each other for inter slice communications. A detailed description of how a single slice performs a message passing algorithm is presented below. The results produced by the slices are provided to the host interface which in turn provides the results to the host system via the front end .

In some examples the factor table memory maintains a cache of records such that previously used records do not need to be reloaded from the host system . The cache of records can be maintained as long as adequate space exists in the factor table memory .

Referring to one example of an architecture of a single slice is designed to compute the terms of message computations. The slice includes an address generator an input message memory an ALU and an output message memory .

In general the slice receives an instruction from the FIFO micro instruction queue shown in element along with a record from the factor table memory shown in element . The address generator provides a mapping between values in the factor memory and locations in the input and output message memories .

The input and output message memories store the inputs intermediate values and output of the computation of belief propagations messages. Messages stored in the input message memory are passed into the ALU along with messages stored in the output message memory . The ALU applies an algorithm e.g. the Min Sum algorithm to the messages and produces a result which is stored in the output message memory . After performing a number of iterations of the message passing algorithm the results stored in the output message memory are passed back to the host system shown in element through the host interface shown in element .

In some examples the input and output message memories use digital logic. In other examples the memories use store values in analog form.

Referring to pseudocode is presented which implements an iterative message passing algorithm that solves for the factor F shown in . The pseudocode can be implemented by the detailed slice architecture shown in .

Referring to a detailed version of the slice architecture shown in is shown along with the factor table memory . The slice architecture includes input and output message memories and an ALU . An address unit provides a mapping between values in the factor table memory and locations in the message memories . Generally the factor table memory includes a set of records . Each record corresponds to an iteration of the loop over i at lines in the pseudocode. A sequencer or controller not shown in causes successive records to be accessed from the factor table memory . For each record a combination unit of the ALU performs the computations of lines of the pseudocode and an accumulation unit performs the computations of lines of the pseudocode. The address unit maps each index into two corresponding memory locations in the message memory an input message location and an output message location. For example for the factor F shown in the address unit maps an index ato the address addr right arrow over l a for the input message and addr a for the output message where addr is understood to mean the address of the storage location for that message value . Note that the signal paths between the message memory and the combination unit are unidirectional from the memory to the combination unit while the signal paths between the memory and the accumulation unit are bidirectional so that for each record of the factor table memory the current values of the output messages are read in and the minimum of the read value and the newly computed value is written back. By iterating over all the elements a b c of the factor the three output messages are computed.

Referring to an implementation of the ALU includes a summation unit which accepts the input message values and the weight and outputs the sum of its inputs. Each of the weights is subtracted in a corresponding adder so that each of the three outputs of the combination unit effectively excludes a corresponding message input. The accumulation unit makes use of three minimum units each of which accepts the memory value and provides the minimum of the memory value and the corresponding newly computed value.

Referring to in some implementations multiple ALUs are implemented and executed in parallel. For instance ALUs i.e. two or more ALUs each receive a part of i.e. a disjoint exhaustive subset the values a b c for the factor. The input message values are replicated in each copy of the memory so that each ALU can perform a local read of the input message value. After all the elements of the factor are evaluated the output messages are typically not fully computed. For example for a particular entry a separate partial computations of the output message a are present in the message memories . In one implementation further data paths not shown link the accumulation units to the message memory so that in a sequence of iterations e.g. log n where n is the number of ALUs the absolute minimum is computed across the ALUs.

In some embodiments a host system controls the operation of the system including loading the factor memory configuring the sequencer to coordinate operation of the ALUs and the address units and loading an unloading message values from the message memory.

In some examples the factor memory does not necessarily hold an exhaustive set of tuples a b c w . For example a set of tuples a b c for which a fixed known weight e.g. 0.0 is encoded and the sequencer is configured to convert the encoding to the sequence of a b c w tuples. Other forms of compressed representation of the factors may also be used.

In some examples different inputs have different numbers of possible values and therefore different numbers of bits may be needed to represent the indexes. As an example a variable that can take on 16 values only requires at most 4 bits to represent each index but a variable that can take on 1024 values may take 10 bits. Therefore even with a maximum of three variables per record in the factor memory different numbers of bits may be allocated for each index.

In the example above the factor is assumed to have three inputs which corresponds to the hardware architecture of the ALUs which expect three inputs and a weight. For a factor with only two inputs one approach is to configure the combination unit to ignore one of the inputs or alternatively for the message memory to provide an input e.g. 0.0 that does not affect the combination.

However when a factor has more inputs than the number for which the ALU is configured one approach is to use an iterative and pipelined approach. For example consider a factor that has six variables and therefore each element of the factor is defined by a tuple a b . . . f w . Referring to one approach is to encode such an element in a succession of records in the factor memory . Referring to operation of the combination unit can be understood by considering the first cycle in which right arrow over l a right arrow over l b right arrow over l c are read from the message memory. These values are summed with the weight wand stored i.e. added to a zeroed value in a temporary register. The input message values are added to a FIFO. On the second cycle values right arrow over l d right arrow over l e right arrow over l f are read from the message memory. The values are then added to the value in the temporary register to yield the value tilde over l as defined in the single cycle case. The values right arrow over l d right arrow over l e right arrow over l f are pushed into the FIFO . In the second cycle the values right arrow over l a right arrow over l b right arrow over l c are read from the output of the FIFO and subtracted from tilde over l to produce tilde over l tilde over l tilde over l . On the third cycle the values right arrow over l d right arrow over l e right arrow over l f are read from the FIFO and the values tilde over l tilde over l tilde over l are output by the combination unit. Note that in the third cycle values right arrow over l a right arrow over l b right arrow over l c can be processed in a pipelined manner without affecting the outputs tilde over l tilde over l tilde over l .

Operation of the accumulation unit is delayed so that in the second cycle the output messages for a b c are updated and in the third cycle the output messages for d e f are updated.

Note that this same approach can be used for situations in which more than two records per factor element. Generally for M records per element the accumulation unit is delayed by M 1 cycles in a pipelined manner.

In some examples a control graph can be a specification of another inference graph which is used to optimally determine how the inference graph is computed by the processing unit .

Referring to in another embodiment of a reconfigurable processing system the architecture of the processing unit is extended to incorporate multiple probability processor elements with each probability processor element operating in parallel. The probability processor elements are connected via a reconfigurable connectivity fabric over which messages are passed between the data memories of individual probability processor elements . When computing a graphical model the set of probability processor elements operates on a portion of the model at a time assuming a large model . At any given time each probability processor element performs the computation associated with one node in the graph. Each probability processor element can be used to perform the computation for a number of different nodes as different portions of the model are loaded into the programmable probability engine .

The connectivity fabric is configured e.g. by the host system or a controller located on the programmable probability engine to correspond directly to the structure of the graphical model. For example in an image processing application graphical models typically correspond to a two dimensional grid or perhaps a hierarchy of such grids. For this type of processing the connectivity fabric is configured to mimic this structure so that communication between probability processor elements corresponds directly to the communication between nodes in the graphical model required for message passing based inference algorithms. Such a configuration allows for high bandwidth parallel communication between the probability processor elements without bottlenecks.

Note that for a given connectivity structure there may be many distinct inference problems that can be implemented. For example a linear chain structure can be used to perform inference on a great many models in the form of a time sequenced Markov model. Or a hierarchy of two dimensional grids can be used to perform inference for a wide variety of image processing models.

Some common configurations of the connectivity fabric are butterfly network fully connected grids chains trees fat trees etc. In some examples the configurable interconnect plane includes storage for intermediate analog or digital values.

For some types of graphical models the connectivity fabric may change frequently when operating on different portions of the graph. For other types of graphical models such as those representing arrays of image pixels or hidden Markov models the connectivity may not need to change when operating on different portions of the graph.

In some examples the processors associated with nodes for which the connectivity changes must complete their processing task and synchronize their data prior to the reconfiguration of connectivity.

In some examples due to the overhead of reconfiguring the connectivity fabric it may be necessary to allow changes in connectivity to be preloaded while the previous computation is still underway allowing a rapid switch to the new configuration.

In some examples operation of the parallel probability processor elements is a mixture of asynchronous and synchronous operation. Thus reconfiguration of the connectivity fabric needs to be synchronized. In particular all processing elements involved with the portions of the connectivity fabric being modified need to reach an appropriate synchronization point before the reconfiguration can occur.

Generally the processing unit may have different sets of probability processor elements each with different characteristics most suited to different types or topologies of factor graphs. For example one type of probability processor element may be best suited to graphs that are generally grid like while another type of probability processor element may be best suited for tree like graphs. In some examples certain of the probability processor elements may be particularly tailored to specific types of problems. An example of such a specific problem relates to LDPC decoding as described in the co pending application international application number PCT US11 20794 titled Belief Propagation Processor. In some examples the probability processor elements use log based representations and implement factor graph message passing. In some examples certain of the probability processor elements may be implemented using digital logic while others of the probability processor elements may be implemented using analog logic.

As is common in many parallel systems it is desirable to ensure that each of the processing elements is optimally utilized. Controlling execution by scheduling load balancing and pipelining are ways in which such an optimization can be accomplished.

In some examples an overall problem graph may have different parts or regions which are not necessarily addressed concurrently. In some such examples the controller or host system follows a predetermined plan or schedule for example performing computation using a first part of a graph and proceeding to another part of the graph only after an intermediate result is obtained. The sequence of iterations results in a convergence to an overall solution of the problem. For example one part of a graph represent decoding constraints of an LDPC code while another part of the graph may represent another form or constraint for instance based on inter symbol interference not addressed by the code and yet another part of the graph may related to adaptation of a channel model to be used in signal acquisition stage. The plan or schedule is then used to coordinate operation of the parts. In some examples the control is implemented using programmable logic e.g. a software program which may involve numerical computations.

The type of schedule is chosen by the user and defined in the source code that specifies a graphical model or a default schedule is used . Design software e.g. DMPL software and compiler combines the graphical model connectivity with a choice of schedule to indicate the specific order of processing. Since the processing unit allows parallel processing such that many nodes in the graph may be updated at once instead of generating a single ordered sequence the DMPL compiler can define a partially ordered sequence of updates allowing as many updates as possible to be done in parallel. The choice of schedule type under the control of the user affects how much parallelism can be exploited.

For a given schedule each processing operation must be mapped to a given probability processor element at a given time. This mapping is also a function of the DMPL compiler. The compiler incorporates knowledge of the number of probability processor elements the available configurations of the connectivity plane the amount of local and shared storage and other factors to choose the mapping. The mapping determines the sequence of instructions provided to each probability processor element the sequence that these instructions as well as the combo tables are preloaded onto the probability processor elements the necessary connectivity plane configuration changes and the sequence in which data is transferred to and from the probability processor elements . The mapping is explicitly aware of the caching that can be done avoiding unnecessary transfers of data.

In some examples efficiency can be improved by using dynamically updating schedules. For example the host system or the controller may optimally select portions of the graph to assign to different probability processor elements . Intermediate values computed for one portion of a graph can be used as indications of which portions of the graph should be solved next such that optimal progress is made toward the overall solution. In other examples run time decision making related to which parts of a graph to address during the course of execution is accomplished using a further graph based computation which is performed by a controller located on the programmable probability engine . For instance a decision of which part of a graph to address may itself be represented as a Bayesian inference control problem which is assigned to the probability processor elements under the control of the controller .

Another method for optimally utilizing the probability processor elements is balancing the computational load on each probability processor element . For example in an arbitrary factor graph there can be a large disparity in the computational complexity between various nodes. As a result some probability processor elements may be given a number of factors with small computation required while other factors may be given a single factor requiring a large computation. The host system can optimally assign factors to computation elements while taking into account the need to balance the load as much as possible.

Another method for optimizing the utilization of the probability processor elements is to allow the host system to treat the processing as a pipeline where at any given time tasks are being fetched ahead of time fed to the probability processor elements other tasks are being executed and the results of already executed tasks are being read out.

In some examples inference graphs are specified using an application programming interface API referred to as DMPL. DMPL is used to design arbitrary graphical models by specifying variables of the model and the factors that relate the variables.

DMPL allows for the specification of the solver schedule which can be a pre defined schedule e.g. Sum Product Min Sum Gibbs sampling etc. or a custom user defined schedule.

Some pre defined schedules are conditional on the topology of the inference graph. For example a tree sequential schedule examines each graph and sub graph to determine which schedule to use for it. If the graph or sub graph is a tree then a tree schedule is used for that portion of the graph the optimal schedule for a tree otherwise a sequential schedule is used for that portion of the graph.

Once the inference graph is specified DMPL compiles the factor graph such that the programmable probability engine can execute them. The output of the compiler includes control software for the host system and data sequencing instructions for the programmable probability engine .

It should be understood that although a number of embodiments described above make use of the Min Sum approach in which a negative logarithm representation permits effectively compute products as sums effectively the same approach can implement the Sum Product approach in which a linear probability representation is used by implement products rather than sum and sums rather than mins. Furthermore a variety of similar approaches can be addressed with this architecture.

Furthermore a number of features may be optionally added to replace corresponding features in embodiments that otherwise follow the approaches described above. Such features include the following.

In the architectures described above each factor in a factor graph has an associated factor table that drives the computation. As introduced above a variety of encoding formats of the factor table can be used in the factor memory each enabling generation of the appropriate sequence of memory addresses and factor weights needed to compute the entries of the output message. Embodiments of the system may be configured to access different encoding formats or may be configured to operate with a particular format. A number these formats are described below.

For the sake of exposition assume that there are K inputs to the factor such that the index for a factor can be considered to be a K dimensional vector with its jentry having possible values 1 to n. There are therefore N nunique index vectors. Each index vector Xis associated with a weight w.

As introduced above a first format for the factor memory is as a sequence of records each encoding X w . We refer to this format as an explicitly indexed factor table. Note that fewer than N records can be represented in the factor table with missing index values essentially having zero weights in the linear domain . In some examples the encoding of the index vector uses a fixed length format for example allocating logn bits for the jentry of the index vector.

Another format for a factor table includes a weight for all possible index values. We refer to such a table as an exhaustive factor table. With only the weights being represented in the factor table the index values and corresponding addresses are generated by the address generator for example according to a canonical ordering of the weights.

One canonical ordering of the weights starts with X 1 1 1 X 2 1 1 incrementing the entries in order. Note that this order results in transitions of multiple index values at times for example from n 1 1 to 1 2 1 or from n n 1 to 1 1 2 In such transitions multiple read accesses are required to access each of the input and output message memories.

An alternative canonical ordering for the weights is based on a generalization of a Gray Code in which the sequence of index vectors is guaranteed to change only a single entry at a time. For example such a sequence may progress 1 1 1 2 1 1 . . . n 1 1 n 2 1 n 1 2 1 . . . 1 2 1 1 3 1 2 3 1 and so forth. Using such a canonical ordering only one new input and one new output message is referenced for each new weight.

Referring to to implement an alternative canonical ordering of the weights such as a Gray Code a caching mechanism may be added to slice architecture of . Such a caching mechanism serves to store the input and output message values read from the message memories from one slice iteration to the next. In this way if the address of any of the input or output message values repeats from one iteration to the next that value is not unnecessarily re read from the message memory.

To implement the caching mechanism an input message memory cache and an output message memory cache are added to the slice architecture. The input message memory cache is located between the input message memory and the combination unit of the ALU and the output message memory cache is located between the output message memory and the accumulation unit of the ALU .

As is the case in an address unit receives a factor F and a number of edge indices A B and C as inputs. The address unit uses its inputs to generate an input memory address and an output memory address for each edge index. The address unit of also generates an address changed indicator for each edge index each address changed indicator indicating whether the memory address associated with a given edge index has changed since the previous slice iteration. The address changed indicators are provided to the input and output message memory caches .

In general if the address changed indicator for a given edge index is false there is no need to re read the message value from the message memory address associated with the edge index. Thus in it is assumed that no memory read occurs for a given edge index when its corresponding address changed indicator is false.

The input message memory cache includes a number of input message caching elements each corresponding to a single edge index i.e. A B or C .

Referring to a detailed view of one input message caching element the input message memory caching element receives the address changed indicator associated with its corresponding edge index and outputs an input message value . As is noted above if the address changed indicator is true for a given input message caching element the input message caching element also receives a newly read input message value from the input message memory . Otherwise if the address changed indicator is false for a given input message caching element the input message caching element does not receive a newly read input message value from the input message memory .

The input message caching element includes a register and a multiplexer . The multiplexer receives the newly read input message value from the input memory conditional on the value of the address changed indicator an input message value from the register and is controlled by the address changed indicator .

In operation if the address changed indicator is true the input message caching element stores the newly read input message value in the register . The multiplexer is configured by the address changed indicator such that the newly read message value is passed to the combination unit . Otherwise if the address changed indicator is false the multiplexer is configured such that the input message value from the previous slice iteration which is stored in the register is passed to the combination unit . In this way the input message memory cache avoids unnecessary reads to the input message memory .

The output message memory cache includes a number of output message caching elements each corresponding to a single edge index i.e. a b or c .

Referring to the detailed view of one output message caching element the output message memory caching element receives the address changed indicator associated with its corresponding edge index and an accumulation result from the accumulation unit . The output message caching element outputs an output message value to the accumulation unit and an updated output message value to the output message memory . As is noted above if the address changed indicator is true for a given output message caching element the output message caching element also receives a newly read output message value from the output message memory . Otherwise if the address changed indicator is false for a given output message caching element the output message caching element does not receive a newly read input message value from the output message memory .

The output message caching element includes a register and a multiplexer . The multiplexer receives the newly read output message value from the output message memory conditional on the value of the address changed indicator and an output message value from the register and is controlled by the address changed indicator .

In operation if the address changed indicator is true the multiplexer is configured by the address changed indicator such that the newly read output message value is passed to the accumulation unit . Otherwise if the address changed indicator is false the multiplexer is configured such that the accumulation result from the previous slice iteration which is stored in the register is passed to the accumulation unit . In both cases the accumulation unit returns the accumulation result to the output message caching element which in turn stores the accumulation result in the register and writes the accumulation result back to the output message memory . In this way the output memory cache avoids unnecessary reads to the output message memory .

Note that caching can have advantages even in the explicit indexing case and that the order of storage of the weights can affect the utility of the cache. For example a random ordering of the entries of the factor table would generally result in more non cached memory accesses than a careful ordering for example as a subsequence of the generalized Gray Code ordering described above for the exhaustive format case.

Yet other formats for encoding the factor table can be used. For example in an exhaustive format approach in which there are runs of zero weights a run length coded approach can be used by encoding a starting index and length of run of non zero weights which are presented in the canonical order. Alternatively the runlengths can be encoded by repeating zero runlength non zero runlength non zero weights in order. Other forms of run length encoding may be used for example based on a compression of an explicit index approach by run length encoding each entry of a series of index vectors separately. In any of these approaches indices and run lengths may be variable length encoded for instance being entropy coded e.g. Huffman coded to further compress the representation.

Referring to another embodiment of a reconfigurable processing system includes a host RAM and a programmable probability engine all in communication over a bus . The programmable probability engine includes a front end including a host interface which facilitates communication between the bus and a processing unit . The processing unit includes a scratch pad memory a variable accelerator a factor accelerator and a number of DMA controllers . A system bus connects all of the elements in the processing unit to one another and to the host interface .

In general the overall system functions similarly to the system of . However rather than handling both variable node computations and factor node computations in the probability processor element shown in the processing unit performs variable node computations in the variable accelerator . Factor node computations are performed in the factor accelerator which is substantially the same as the probability processor element shown in .

Referring to one example of a variable accelerator reads data from the scratch pad memory element processes the read data and writes the processed read data back to the scratch pad memory . The variable accelerator includes an address generator an instruction sequencer and an ALU . The instruction sequencer includes an instruction command list which includes a list of instructions to be performed by the variable accelerator . The instruction sequencer reads an instruction from the instruction command list and based on the instruction commands the address generator to generate the read and write addresses corresponding to the instruction . The instruction sequencer also provides the instruction to the ALU .

The ALU receives the instruction from the instruction sequencer and input data from the scratch pad memory and corresponding to the instruction . The ALU processes the input data according to the instruction to form write data which is output to the scratch pad memory . In some examples the ALU is configured to perform operations according to an instruction set including the instructions UpdateVariable UpdateVariableEdge VariableBelief Normalize and ApplyDamping.

The UpdateVariable instruction causes the ALU to compute all output messages for a variable of a factor graph. For example if a given variable is connected to N factors the variable receives a set of N input messages i.e. f f from the connected factors. Each message includes a vector with a number of elements equal to the domain length of the variable i.e. the number of values that the variable can possibly take .

Where vis an output message intended for the ifactor connected to the variable and includes a vector of X elements with each element addressed as v x . The equation above updates the variable by performing a vector element by vector element sum of all of the input message vectors f f excluding the iinput message vector.

In when the Update Variable instruction is received by the ALU output messages are computed for all factor nodes connected to the variable node. For the ifactor node of the N connected factor nodes an accumulator receives the input message vectors f ffrom the scratch pad memory and computes a vector element by vector element sum all of the input message vectors. The result of the accumulator v is a vector of X elements which is stored in a sum register .

At approximately the same time an input message pipeline receives the input message associated with the ifactor node f. fand v are passed to a subtractor which performs a vector element by vector element subtraction of ffrom v resulting in the output message for the ifactor node v. vis then passed out of the ALU as write data and written to the scratch pad memory .

The Normalize instruction causes the ALU to apply i.e. to add in the negative logarithm representation or multiply in a linear representation a constant offset value to all elements of a message vector. In some examples such an operation is useful when the values included in the message vector are in the log domain. In particular a normalization operation can keep values included in the message vector within a specific numeric range e.g. a range suitable for representation using a certain number of bits as the computation of a factor graph progresses.

In general the smallest value i.e. the smallest negative logarithm corresponding to the largest linear representation in a message vector represents the most likely configuration of a variable. Thus the message can be normalized by identifying the minimum value in the message vector and adding a value to the entire vector such that the minimum value is at a predefined constant value.

In a min accumulator identifies the minimum value of the input message vector associated with the ifactor node f. If the identified minimum value is less than a previously identified minimum value then the identified minimum value is passed to the subtractor . Otherwise the previously identified minimum value is passed to the subtractor . The subtractor applies the minimum value to normalize its resulting message output.

The UpdateVariableEdge instruction causes the ALU to compute an output message for a single factor connected to the variable. Computation for the single factor is performed in much the same way as is described above for the Update Variable command. However for the UpdateVariableEdge instruction the ALU computes an output message for only one factor and not for all factors.

The VariableBelief instruction causes the ALU to compute the belief for the variable based on all of the input message vectors f f. In some examples this is also referred to as the mean field variable update computation.

Computing the variable belief involves computing the following function for each of the connected factors 

Where vis an output message intended for the ifactor connected to the variable and includes a vector of X elements with each element addressed as v x . The equation above updates the variable by performing a vector element by vector element sum of all of the input message vectors f f .

In when the VariableBelief instruction is received by the ALU output messages are computed for all factor nodes connected to the variable node. For the ifactor node of the N connected factor nodes the accumulator receives the input message vectors f ffrom the scratch pad memory and computes a vector element by vector element sum all of the input message vectors. The result of the accumulator v is a vector of X elements which is stored in a sum register . v is then passed out of the ALU as write data and written to the scratch pad memory .

The ApplyDamping instruction causes the ALU to modify an output message vector using a combination of that message vector with a second message vector representing an earlier value of that message vector. The amount of damping applied can be controlled by a predetermined damping coefficient which in some examples is a value between 0 and 1.

In the ALU described above with reference to negative logarithm representations are used and therefore the sums correspond to products in the linear domain and the min operation corresponds to a max in the linear domain.

In some examples other functions than min can be used for example with hardware circuitry providing efficient implementations of those functions. Note that if two inputs x and y are negative log representations e.g. using base two logarithms of two linear quantities then s being the negative log representation of their sum satisfies 2 2 2or s log 2 2 . In some alternatives the ALU exactly or approximately computes s rather than using min x y . A number of such approximations are referred to generally as min functions which can also be implemented in the logic of the ALU.

Note that when x and y are very different min x y min x y . Where x and y are similar in value the result is smaller than the minimum of the two.

In some examples the min operation is implemented by performing approximate implementations of the exponentiation and log functions in the equation above. One approach is to implement the min using the following identity and using the a table lookup to the second term min min log 1 2 

In another approach computing an approximation min the negative logarithms are treated as having two parts with the high order bits being treated as as an exponent and the low order bits being treated as a mantissa of a floating point representation such that x x xwhere represents bit concatenation and y y Y and the result is represented as min x y s s. In this approximation s min x y . If x d where the overbar denotes bit complement and in some cases there is a further renormalization if there is carry in the sum in a manner similar to that used in floating point addition. Similarly if x y with x y d then s yand the mantissa is essentially computed as 1 1 d 1 . In practice there may be a further renormalization if there is carry in the sum in a manner similar to that used in floating point addition i.e. by reducing sby one and shifting sto the right .

The reconfigurable processing system architectures described above include a number of elements operating and in particular accessing memory asynchronously. For example the DMA controllers variable accelerator and factor accelerator do not necessarily operate synchronously with each other. Thus there is a potential for memory access collisions possibly resulting memory corruption. In some examples a synchronization mechanism uses information embedded in instructions and or residing in synchronization registers to synchronize memory accesses thereby avoiding collisions and memory corruption.

In some examples the synchronization mechanism is included in the instruction sequencers described above i.e. element and element . The instruction sequencers generally run in a continuous loop waiting to read instructions load their corresponding configuration registers and to initiate instruction execution. The instruction sequencers including the synchronization mechanism are configured to detect a hold condition before executing an instruction.

In some examples before beginning execution of a loaded instruction the instruction sequencer determines if a hold condition is met. If not the execution begins immediately. However if the hold condition is met the instruction sequencer waits to begin execution. The instruction sequencer continuously monitors the hold condition and as soon as it is no longer met execution of the instruction commences.

In some examples the hold condition is considered met based on a result of comparing a sequence number included in the instruction to a hold indication register which is maintained by the host. In other examples an instruction includes information related to the execution state of other instruction sequencers in the system. The information can be used to hold processing until the other instructions sequencers are at a certain execution state e.g. causing the instruction sequencers to rendezvous at a given execution state.

In general the hold condition only applies to the execution of an instruction an not to the loading of the configuration registers for an instruction. Regardless of whether or not the hold condition has been met loading of the configuration registers for an instruction proceeds unconditionally.

While the above described reconfigurable processing system architecture utilizes an external host processor to coordinate the programmable probability engine computation and to perform any additional processing beyond the capabilities of the programmable probability engine as currently defined a more general architecture could include one or more general purpose processors dedicated to the programmable probability engine. In addition to simply performing more local coordination of the programmable probability engine s operation and reducing off chip I O local general purpose processors can facilitate support for a broader class of inference algorithms. Some specific algorithms and the means by which a general purpose processor can augment the computation by the probability processor elements are described as follows.

In the examples described above the host system is external to the programmable probability engine. However in some examples one or more CPUs may be integrated into the programmable probability engine acting as an on chip host system. Furthermore in some examples one host system can serve as a host to multiple programmable probability engines.

Particle belief propagation is a form of belief propagation that can be used to support continuous variables or variables with very large domains. In this case instead of passing an entire probability distribution as a message the messages are a series of values that represent the importance weighted message at points randomly sampled from the domain of the variable. The belief propagation updates using these messages are similar to ordinary belief propagation and as such could be performed using the programmable processor elements with little change. But there are additional aspects of what must be computed that could benefit from support by a general purpose processor. Specifically there are two such aspects of the computation. First is the periodic resampling of the randomly chosen sample points for each variable. This computation can involve repeated evaluation of functions that defines factors in the graph for example when resampling using the Metropolis Hastings algorithm . For a user specified factor graph these functions may be user specified and involve arbitrary computation. Second is the regeneration of the factor table after this resampling. One method of doing this is to recalculate the factor table for a given factor by evaluating its factor function at the new sample points. This also may involve arbitrary user specified computation. In both cases a general purpose processor augmenting the probability processor elements can perform these computations. In one approach these processors would perform resampling of variables and recalculation of factor tables and then write the new factor table values into the factor table memory of the appropriate probability processor element as needed. In one approach this calculation is performed while a probability processor element continues to perform processing on portions of the factor graph.

Another class of algorithms that could benefit from general purpose computation are sampling based methods. Common sampling methods are Gibbs sampling and the Metropolis Hastings algorithm. Sampling based algorithms can be used to perform inference on a factor graph. Typically Gibbs sampling is used in this case sometimes in combination with the Metropolis Hastings algorithm . Sampling based algorithms can also be used to perform inference on models specified by a stochastic generative program. In this case the Metropolis Hastings algorithm is used as one aspect of the inference computation. In the case of factor graphs using continuous or large domain variables and in the case of stochastic generative programs inference computation includes performing arbitrary computation based on a user specified program either the factor function in the former case or the stochastic generative program itself in the latter case . In both cases general purpose processors as part of the programmable probability engine can be used to perform these computations. In some cases sampling based methods such as for performing inference on stochastic generative programs can be combined with belief propagation such as performed by the probability processor elements as currently defined. Models that combine both generative programs and undirected graphical models factor graphs are possible and in such cases it would be appropriate to combine the two approaches in which case the programmable probability engine belief propagation computations could operate simultaneously with other computations used for other portions of the model.

Sampling based methods particle belief propagation as well as other forms of non parametric belief propagation particle belief propagation is a form of non parametric belief propagation all involve random sampling for at least a portion of the computation. Random sampling generally requires mechanisms to generate random or pseudo random numbers distributed according to some set of distributions. To efficiently perform these types of computation one form of probability processor engine would have dedicated hardware for generation of random numbers or more generally for generating randomly distributed values according to a probability distribution selected among a set of available distributions. Hardware support for this could be a pseudo random bit sequence generator a random bit sequence generator based on a form of physical randomness or could involve direct generation of values from a distribution. Hardware support for uniform distributions normal distributions or exponential distributions would facilitate efficient implementation of these algorithms.

For the programmable probability engine including multiple analog processor elements an alternative embodiment includes direct support for Gaussian messages parameterized by a mean and variance or equivalent or by a joint mean and covariance matrix or equivalent . It may also support messages based on mixtures of Gaussians messages parameterized by a series of Gaussian messages combined with a mixture weight associated with each . It may also support other parameterized message representations. In the case of Gaussian messages it may support special purpose processing for Gaussian or linear factors and for variable nodes linear factors include sum or difference factors and multiplication by a constant scalar or matrix . For supporting more general factors that are not as easily computed the programmable probability engine can employ stochastic methods for performing the factor computation. Graphs with such factors would make use of mechanisms similar to those described above for sampling based algorithms while Gaussian factors linear factors and variables would make use of special purpose hardware in the probability processor elements.

In the above description some examples of probability processor elements are described as being implemented using analog electronics or a combination of analog and digital logic. However in some examples the probability processor elements can be implemented using digital electronics. In an Analog Logic implementation of programmable probability engine Min Sum or Sum Product computations performed by each probability processor element use Analog Logic computation elements. In a digital implementation this processing uses digital computation elements.

In some examples the programmable probability engine includes a shared memory for storing factor tables which are shared among a large number of the parallel probability processor elements. In many cases many nodes in a graphical model may use the same factor function. If the associated combination table is sufficiently large then it would be inefficient to independently store a copy of the table in the local memory of each probability processor element. In this case it is proposed that a shared memory be available to hold such tables. In operation all of the probability processor elements making use of a given table in shared memory would be configured to operate in synchrony during the time this table is in use. This allows the data from the table to be read over a shared memory bus and used simultaneously by all probability processor elements that require its value.

The specialized programmable probability engine compiler is responsible for determining the criteria by which shared memory is used to store combo tables. It balances the overall storage requirements with any performance tradeoff associated with reading shared memory or synchronizing probability processor elements. For example if multiple tables are stored in shared memory that are to be used at the same time by different subsets of probability processor elements there can be some performance degradation due to contention for the shared memory bus.

In embodiments where at least part of the probability processing engine is implemented using analog electronics data is converted between digital and analog form. In some examples a DMA controller included in the front end incorporates a data conversion unit that can translate data between the analog and digital domains. Specifically the DMA controller can incorporate a bank of DACs for translating data from the digital to the analog domain and a bank of ADCs for translating data from the analog to the digital domain.

In some examples each probability processor element includes local operating memory which is maintained by a memory hierarchy scheme allowing for storage of data at several levels.

The internal representation of messages can be a logarithmic representation of probability either a log likelihood ratio LLR for binary variables or a potential log p for multi valued variables. By default the corresponding representation of this data for external storage is in the same format. A representation conversion step may also be included to allow representation in other formats.

It is to be understood that the foregoing description is intended to illustrate and not to limit the scope of the invention which is defined by the scope of the appended claims. Other embodiments are within the scope of the following claims.

