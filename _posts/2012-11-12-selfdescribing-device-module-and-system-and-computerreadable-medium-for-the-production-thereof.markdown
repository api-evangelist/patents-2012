---

title: Self-describing device module and system and computer-readable medium for the production thereof
abstract: A system, method, and computer-readable medium for generation of a controlled device Module are provided. Various components are provided to a Module designer for selection, and the designer defines the interface APIs specifying the component functionalities. The designer may specify custom commands or events for the Module including Commands, Properties, and Parameters, and custom components corresponding to the custom commands are generated. A self-describing capabilities component is then generated for each component, and a composite capabilities component may then be generated from the capabilities components of each of the components. The completed Module package is then produced by an integrated development environment station.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09134719&OS=09134719&RS=09134719
owner: AMX LLC
number: 09134719
owner_city: Richardson
owner_country: US
publication_date: 20121112
---
This application is a continuation of and claims priority to U.S. patent application Ser. No. 12 344 716 entitled SELF DESCRIBING DEVICE MODULE AND SYSTEM AND COMPUTER READABLE MEDIUM FOR THE PRODUCTION THEREOF filed Dec. 29 2008 now issued U.S. Pat. No. 8 316 343 issued Nov. 20 2012 which in turn claims priority to U.S. provisional patent application Ser. No. 61 017 613 entitled Self Describing Devices filed Dec. 29 2007 by Birze et al. and U.S. provisional patent application Ser. No. 61 017 620 entitled Server Enabled Device Description filed Dec. 29 2007 by Birze et al. the disclosures of which is incorporated herein by reference.

The present invention is generally related to control systems and more particularly to self describing controlled device modules in a control system.

Many systems such as control systems monitoring systems and the like exist that allow discovery at runtime of devices active in the system. These systems may also discover a device s type thereby allowing basic control and monitoring with no external configuration. However these systems depend on standardized application programming interfaces APIs describing Parameters Properties and Control Commands for different device types. Once a device of a known device type is found the system can use a standardized API for the device type to control configure or monitor the device. For example some of the attributes of security system device types include Properties such as a manufacture and model Parameters such as arm able state ability to arm a system and security state such as ARM HOME ARM DISARM and PANIC and Commands such as GetSecurityStatus setSeucrityState and isOKToArm .

Unfortunately many devices have capabilities that do not fit into standardized device type APIs. This particular trend is becoming more prevalent as manufacturers merge multiple capabilities into a single device e.g. placing a DVD and a VCR in the same device housing.

Companies that support standardized device type APIs must frequently update their APIs to keep up with the latest innovations by device manufactures. This causes deployment issues as the control monitoring and integration systems that understand the APIs must be updated to understand devices using the latest APIs.

Many device protocols allow manufactures to add extensions to their device type API to allow the manufacturers to expose their devices unique capabilities. However custom code must then be developed and installed in the control or monitoring system to allow the system to utilize a device s extensions thereby requiring intimate knowledge of the control or monitoring system s internals. Additionally custom code in a control or monitoring system hampers the ability to swap one device of a type for another of the same type. For example custom code written for a receiver with custom capabilities will not perform when the receiver is swapped for one that does not have the custom capabilities.

The present invention provides a controlled device Module and a method and computer readable medium for generation thereof. A development IDE presents various SDK components for selection to a Module designer to include selected SDK components in the Module. The designer is then provided an environment by the development IDE to supply or otherwise define the interface API specifying the SDK component functionality. The designer may be provided an option to specify custom commands or events for the Module. If the designer elects to supply a custom command or event the custom command is supplied to the IDE by the designer for the Module. After specification of the custom command or event and corresponding Commands Properties and or Parameters and associated descriptive text and metadata the IDE generates a custom component corresponding to the custom command. The IDE then generates a self describing capabilities component for each SDK component and custom component. The IDE may then generate capabilities classes for the Module. A composite capabilities component may then be generated from the capabilities components of each of the SDK and custom components. A manifest may then be generated for the Module that specifies a generic router that is adapted to interface with the self describing Module. The completed Module package is then produced by the IDE.

In one embodiment of the disclosure a method of generating a controlled device module is provided. The method comprises providing a plurality of software development kit components for inclusion in the module receiving selection of at least one software development kit component of the plurality of software development kit components receiving a definition of an application programming interface for the at least one software development kit component receiving a custom command for the module generating by an integrated development environment station a custom component corresponding to the custom command and generating a capabilities component from the definition of the application programming interface and the custom component.

In a further embodiment of the disclosure a computer readable medium having computer executable instructions for execution by a processing system the computer executable instructions for generating a controlled device module is provided. The computer readable medium includes instructions that when executed cause the processing system to provide a plurality of software development kit components for inclusion in the module receive selection of at least one software development kit component of the plurality of software development kit components receive a definition of an application programming interface for the at least one software development kit component generate a software development kit component class corresponding to the selected software development kit component generate a device component class corresponding to the selected software development kit component from the definition of the application programming interface receive a custom command for the module generate by an integrated development environment station a custom component corresponding to the custom command and generate a capabilities component from the definition of the application programming interface and the custom component.

In a further embodiment of the disclosure a controlled device module for deployment in a control system that facilitates control and monitoring of a controlled device is provided. The module is implemented as executable instructions tangibly embodied on a computer readable medium comprising a software development kit component class a custom features class defined by one or more custom commands a device component class corresponding to the software development kit component a custom device component class corresponding to the custom features class and a capabilities class configured to query the device component class for capabilities associated therewith and query the custom device component class for capabilities associated therewith wherein the capabilities class is adapted to generate a composite capabilities object based on capabilities associated with the device component class and capabilities associated with the custom device component class.

It is to be understood that the following disclosure provides many different embodiments or examples for implementing different features of various embodiments. Specific examples of components and arrangements are described below to simplify the present disclosure. These are of course merely examples and are not intended to be limiting.

In accordance with disclosed embodiments a self describing controlled device Module allows a device to describe itself both at runtime and before installation thereby allowing discovery of the capabilities of the device to enable control monitoring and integration of a device with no prior knowledge of the device or the device type. Additionally custom extensions to a device s capabilities will also be discovered to allow control monitoring and integration of these custom extensions without the need for custom code. New devices may then be deployed or communicatively coupled with control systems monitoring systems configuration tools or development tools and natively understood with no changes to the systems or tools.

Contemporary products may use application programming interfaces and corresponding device types to provide integration and control of devices in a control system. Exemplary attributes of the Security System device type include Properties such as manufacture and model Parameters and Commands. However many devices have capabilities that do not fit into such standardized APIs and the trend is becoming more prevalent as manufacturers merge multiple capabilities into a single device.

In accordance with disclosed embodiments mechanisms for provisioning a self describing controlled device Module are provided. As referred to herein a device Module comprises a component that allows a device to be deployed in a control or remote monitoring system collectively referred to herein simply as a control system . The device Module may be implemented as computer executable or computer readable instructions tangibly embodied on a computer readable medium. A device such as a camera tuner or any other device that may be monitored controlled or otherwise manipulated via the control system is referred to herein as a controlled device. A controlled device has a corresponding device Module that facilitates deployment and operation of the controlled device within the control system. The control system may include various system entities or nodes that facilitate controlled device configuration and deployment management operation control monitoring or other manipulations of a controlled device. Control system entities are referred to herein as control system devices or simply system devices . Exemplary system devices include for example a master controller a remote monitoring system RMS and any variety of Integrated Development Environment IDE systems or tools used for device integration deployment or configuration.

The self describing device Modules implemented according to disclosed embodiments are able to describe the capabilities of a controlled device both at runtime and before installation. Advantageously the discovery of the capabilities of the device by other system devices with no prior knowledge of the device or its device type is provided. A master controller is able to control the controlled device an RMS is able to monitor the controlled device and an integration IDE is able to integrate the device Module with no changes to other control system devices. Additionally custom extensions to device APIs may be allowed and may also be discoverable to allow control monitoring and integration of these custom extensions without the need for custom code.

An integration IDE allows device dealers to easily integrate multiple Modules and their associated controlled devices into a single control system . An integration tool run at integration IDE may provide a visual mechanism of generating Touchpanel glue code to tie for example touch panel inputs with each device Module s API to control and monitor the associated device.

Modules integrated with integration IDE may be loaded onto a master controller to enable control of the corresponding devices in the control system . NetLinx code generated by integration IDE may also be loaded onto the master controller to link touch panels or other peripheral devices with the control and monitoring APIs exposed by the device Modules generated by development IDE .

A remote monitoring system RMS may feature a resource management suite that provides remote monitoring and control of various controlled devices integrated in control system . The RMS may comprise an RMS server that communicates with RMS agents installed on the system master controller . The RMS enables administrators to gather status of controlled devices and to control the devices participating in the control system that are deployed via the master controller . Various control system devices are communicatively coupled with one another e.g. via a network a direct connection or another suitable interface.

Contemporary API specifications create a control system which provides rigid device development yet does not provide effective runtime enforcement. This introduces ambiguity and creates issues for control system devices or products collaborating to provide control and monitoring for controlled devices deployed in control system .

A control system device software development kit SDK composed of SDK components is used to create Modules for controlled devices. SDK components each expose an API that describes the mechanisms for controlling and monitoring the common device component. For example a Power Supply is a device component used in many device types and thus may have a corresponding Power Supply SDK component at the development IDE .

Typical SDK components are grouped into well know device types which are rigid in their structure. These well known device types cannot easily account for device innovations in the form of new functionality or combinations of different device types. For example a VCR comprises a power supply a television tuner and a tape transport. A device type specified as a VCR may then have a respective SDK component for the power supply television tuner and the tape transport. In a similar manner a DVD player comprises a power supply and a disc transport. A device type specified as a DVD player may have a respective SDK component for the power supply and the disc transport. In this manner well known device types may be accommodated by various automated tools for configuration and deployment in a control system. However consider a manufacturer that has produced a DVD VCR combination. In this instance another device type must be defined for efficient deployment of the DVD VCR combination since neither the SDK components grouped into the VCR device type nor the SDK components of the DVD device type may appropriately address the combination device. Module developers may add custom capabilities as custom events but these are not natively understood by any tools or control system devices or products requiring for example custom Touchpanel code to utilize the unique device capabilities. Thus a device SDK must be disadvantageously updated periodically to accommodate new or modified device types. Consequently controlled device deployment issues are often encountered as the system master controller can support only one version of the device APIs. If an updated API breaks a legacy Module s existing functionality the legacy Module must be reopened to account for the updated APIs in order to function on new control system installations. This ongoing SDK and Module maintenance consumes software engineering and development time aggravates system partners that may not be aware of SDK updates and complicates integration and deployment for product dealers.

Integration IDE may import a Module s generated module.xml file to determine the device type and the Commands Parameters and Properties available for the Module. This data is checked against the expected Commands Parameters and Properties for the device type from the most recent Device SDK API. If there is a mismatch due to an out of date Module the mismatched commands will not appear in the code builder and thus will not be available to the system integrator. Custom commands and events representing extensions to the standard device type are not exposed to integration IDE and cannot be exposed to the system integrator.

In accordance with disclosed embodiments a device Module configuration relaxes the rigidity of development while enforcing runtime access to only defined Commands Parameters and Properties. This shift in perspective eliminates the frustration of Module developers not being able to fit their device capabilities into a pre defined device SDK. Module developers are able to mix and match standard SDK components to accommodate new device combinations while also creating custom commands and events to capture unique device capabilities in accordance with disclosed embodiments. A development IDE captures this information and generates a framework that describes the capabilities of the Module.

Central to the disclosed controlled device Module implementation is the creation of a capabilities component. When queried a Module s capabilities component is able to describe its Module s capabilities both as a capabilities object that can be queried at runtime and in an XML format or other instruction set that can be saved or passed in messages between control system devices such as the master controller and RMS. This same capabilities component will be able to create a runtime capabilities object from consuming the self describing XML file.

A controlled device Module development IDE may be used by controlled device manufactures e.g. manufacturers of controlled and monitored devices or control system device manufacturers to develop self describing Modules for corresponding controlled devices.

An integration IDE allows device dealers to integrate multiple Modules and their associated controlled devices into a single control system. An integration code builder tool run at integration IDE may provide a visual mechanism of generating Touchpanel glue code to tie for example touch panel inputs with each device Module s API to control and monitor the associated controlled device.

Modules integrated with integration IDE may be loaded onto a system master controller to enable control of the controlled devices in the control system .

An RMS provides remote monitoring and control of various controlled devices integrated in control system. The RMS may comprise a resource management suite that communicates with RMS agents installed on the system master controller . RMS enables administrators to gather status of controlled devices and to control the devices participating in the control system deployed via master controller .

Each Module facilitates control and monitoring for a corresponding controlled device in control system. In accordance with an embodiment a Module package is produced by development IDE that includes the device Module and a capabilities component CC that facilitates device deployment and operation within the control system. In accordance with an embodiment a CC is provided for each controlled device type. Thus controlled device may have a CC associated therewith and controlled device may have a CC associated therewith. The RMS may access each CC and of associated controlled devices . The Module package such as Module package and constituent components are associated with a particular controlled device such as controlled device . A corresponding capabilities component includes a self describing XML file or other suitable instruction set that specifies the capabilities of the corresponding controlled device including Properties such as the device manufacturer and model Parameters such as controlled device parameter states and status and commands. As referred to herein Parameters are mutable values describing the state of the controlled device. Parameters can be queried or delivered as asynchronous events. Properties are immutable values describing the controlled device such as a manufacturer and model. Control Commands comprise methods which can be invoked to control the device to change the controlled device configuration or state.

A capabilities component such as CC is configured to be queried by one or more control system devices including configuration integration and deployment tools e.g. integration IDE and RMS and return Module capabilities in response to the query. The Module capabilities may be provided by the capabilities component as the XML file prior to complete operational configuration of the Module and corresponding controlled device . Further the self describing XML file may be conveyed between one or more control system devices or components. When the device Module and corresponding controlled device are operationally deployed within the control system a corresponding capabilities component may generate a capabilities object from the self describing XML file . At this point response to runtime queries issued to the capabilities component may be provided by the capabilities object .

Various control system devices such as the integration IDE RMS and master controller may access a respective capabilities component such as CC . The capabilities component allows for strict enforcement during integration of the corresponding controlled device within the control system and during controlled device runtime.

The controlled device is coupled with the master controller and is thereby provisioned a communication interface with the corresponding Module . When the Module and controlled device are operationally configured within the control system supported control and monitoring commands may be conveyed from the Module to the controlled device . To this end the controlled device Module may communicatively interface with a remote monitoring agent that itself may be communicatively coupled with RMS e.g. via a network connection a direct connection or other suitable communication medium. The remote monitoring agent may include or interface with an instance of the self describing XML file . At runtime the remote monitoring agent may obtain the capabilities component in the form of the capabilities object . When the controlled device is registered with RMS an administrator may issue control and monitoring commands that are received by the remote monitoring agent associated with the controlled device .

The controlled device Module additionally interfaces with a controlled device router that is allocated for and associated with the controlled device . The router is identified and loaded by the master controller to enable communications between Touchpanel code and the code environment e.g. Java in which Module is deployed. To this end Module may include a manifest that specifies the router to be loaded and associated with Module and master controller is configured to examine the Module s manifest for such purposes. When loaded the router will query the associated Module to discover its capabilities via a returned capabilities object illustratively represented as a capabilities component . Only the capabilities described by the Module will be sent to or received from the router . Commands or monitoring requests conveyed to the router that are not included in the Module s capabilities object will be returned with a not implemented error or other suitable fault. Other controlled devices may have corresponding Modules associated RMS agents and routers configured on master controller .

The control system may accommodate controlled devices such as a controlled device that has a legacy controlled device Module a corresponding router and RMS agent . Legacy controlled device Module does not have the ability to provide capabilities of the controlled device both rather may only provide a device type and version e.g. to remote monitoring agent .

A device Module is produced at development IDE step . The controlled device Module created at the development IDE includes a self describing capabilities XML file for use prior to complete configuration of the controlled device and corresponding Module within control system. The Module includes suitable logic for creating and exposing a capabilities object and or a self describing XML file for use at runtime i.e. when the controlled device and Module are operationally configured for use in control system . An integration IDE may then access the controlled device Module to obtain the self describing XML file step . On receipt of the self describing XML file the integration IDE use the XML file to integrate the controlled device s exposed capabilities into the control system. Once the device s capabilities are integrated into the control system such that the controlled device and Module are operationally configured the master controller may retrieve the runtime capabilities object from the Module and thereby control access to the Module and the corresponding controlled device step . The master controller utilizes the runtime capabilities object to allow or prohibit monitoring requests and commands issued for the controlled device according to the capabilities advertised or otherwise provided by the capabilities object . The remote monitoring system may likewise obtain the controlled device Module s capabilities object step and the remote monitoring system may register the controlled device accordingly step . The remote monitoring system uses the capabilities description provided by the capabilities object to advertise the device capabilities to a remote monitoring system administrator. The administrator may then complete a monitoring and control configuration for the device that is constrained by the device capabilities advertised by the controlled device capabilities object. Monitoring and control of the controlled device may then be performed by issuance of suitable commands from the remote monitoring system to the device Module step .

The development IDE used for creation of the device Module according to step may include an SDK that features low level reusable controlled device SDK component building blocks e.g. power supply key pad sensor device or other common SDK components. However the use of SDK components for creation of a Module implemented in accordance with embodiments advantageously does not rely on module indexing e.g. the association of one or more SDKs with a particular controlled device type. Rather SDK components that are available and that may be utilized for Module development are not bound by a particular device type and thus Module developers may freely mix and match SDK components. Further the SDK preferably provides mechanisms for creating custom events and commands for the controlled device that may be accommodated by the corresponding Module. Advantageously development and deployment of controlled devices within control system does not require any rigid notion of a device type and a required SDK components association. Module developers are able to create their own device types or alternatively start with a known device type and remove or add SDK component at will.

Completed controlled device Modules developed at development IDE are packaged for installation on master controllers. Completed Modules employ a capabilities component to allow the Module to provide a description of the services it offers as both a runtime capabilities object and in a self describing XML file .

The Module creation routine is invoked step and the Module designer may be presented with various SDK components for selection to include in the Module for a corresponding device component step . If the designer selects an SDK component the metadata on the API is then specified including valid parameter ranges and values descriptions etc. step . Specification of the interface API may include specifying one or more commands parameters and or properties and may include the specification of metadata including descriptions parameters types and valid ranges. Once the selected SDK component function s interface API has been defined by the designer the designer may choose an additional SDK component according to step .

When no additional SDK components are selected by the Module designer the designer may be provided an option to specify custom commands step . If the designer so chooses the designer may extend a custom component API by the specification of custom commands or events for the Module step . In an embodiment the IDE may provide required fields to facilitate generation of a corresponding custom component. For example the IDE may require the designer to specify one or more Commands Properties and Parameters that are to be associated with the custom command or event and may require the supply of metadata including descriptive text and valid ranges of the one or more Commands Properties or Parameters. After specification of the custom command or event and corresponding Commands Properties and or Parameters and associated descriptive text and metadata the IDE may then generate a self describing capabilities component for the SDK custom component step . The custom component generated by IDE encapsulates the device s custom commands and events.

Thereafter the IDE may then generate a device class skeleton for the SDK and custom component step . A device class implementation is then added to control the specific device step . A composite capabilities component may then be generated from each of the capabilities and custom components step . In an embodiment the composite capabilities component may comprise a self describing XML file from which Module may generate a runtime capabilities object when Module is operationally configured and deployed in control system. A manifest may then be generated for Module step . In an embodiment the manifest generated for the Module may specify a generic router that is adapted to interface with self describing Module . The completed Module package is then produced by IDE step . In an embodiment the Module package includes the generated manifest the chosen SDK components custom components and the composite capabilities component including the generated self describing XML file . The Module creation routine cycle may then end step .

In the illustrative example the Module package class structure depicts an exemplary class diagram of a packaged Module for control of a controlled device comprising a tuner . The module package may include various device SDK component classes including for example a Device Power SDK class a Device Preamp SDK class and a Device Tuner SDK class . Additionally a Device Custom Features class specifies custom commands or events specific to tuner . Corresponding device component classes are generated for each of the SDK classes and the custom class es . For example a Power Device Component class is generated and included in the Module package that corresponds to the Device Power SDK class . Likewise a Preamp Device Component class is included in the Module package that corresponds to the Device Preamp SDK class and a Tuner Device Component class is included in the Module package that corresponds to the Device Tuner SDK class . A Custom Device Component class is generated by the development IDE and provides the API to the custom commands events and listeners specific to the tuner that are provided by the Device Custom Functions class . All Device SDK Component classes inherit from a Device Component base class which provides a consistent interface to the OSGi framework.

Each of the Device SDK classes comprise abstract classes that are selected by the Module developer e.g. at step described with reference to . The Module developer specifies the interface APIs providing the functionality of the abstract SDK classes e.g. at step of thereby providing the requisite logic for the corresponding device component classes to implement specific device access codes for properly interfacing with tuner . The Module developer specifies custom commands or events for defining the Device Custom Features class e.g. at step of . Custom Device Component class is generated by the development IDE e.g. at step of and provides the API to the custom commands events and listeners specific to the tuner that are provided by the Device Custom Functions class . A utility access class e.g. Serial Access Utility class may be provisioned at the development IDE to simplify development of device component classes and corresponding API specifications for utility access via SDK Component classes and custom classes e.g. Device Custom Functions class .

In accordance with an embodiment Module package and control system software entities are implemented in compliance with the OSGi framework although other suitable frameworks may be substituted therefor. An OSGi Device class and Capabilities class are hidden from the Module developer. The OSGi Device class provides interaction with the OSGi framework and is the communication point for all services outside the Module bundle. The Capabilities class is generated by development IDE and determines all the components and custom commands and listener events specified in the Module. In an embodiment the Capabilities class uses Java reflection to match the commands parameters and properties listed in the capabilities Object with the actual methods in the objects that satisfy the capabilities.

At startup each Device Component class will be queried for their runtime capabilities object that includes the commands parameters and properties offered by the Module as well as metadata including descriptions parameters types and valid ranges. Individual capabilities objects of Component classes may be accumulated by the Capabilities class for collection of composite capabilities of all device component classes . When queried the OSGi Device class obtains the composite capabilities from the Capabilities class and returns a composite runtime capabilities object describing the capabilities of device . The OSGi Device class exposes a service interface other services will use to invoke command or request parameter identifiers from the associated Capabilities Object.

As described mechanisms for generation of a controlled device Module are provided. A development IDE presents various SDK components for selection to a Module designer to include selected SDK components in the Module. The designer is then provided an environment by the development IDE to supply or otherwise define the interface API specifying the SDK component functionality. The designer may be provided an option to specify custom commands or events for the Module. If the designer elects to supply a custom command or event the custom command is supplied to the IDE by the designer for the Module. After specification of the custom command or event and corresponding Commands Properties and or Parameters and associated descriptive text and metadata the IDE generates a custom component corresponding to the custom command. The IDE then generates a self describing capabilities component for each SDK component and custom component. The IDE may then generate capabilities classes for the Module. A composite capabilities component may then be generated from the capabilities components of each of the SDK and custom components. A manifest may then be generated for the Module that specifies a generic router that is adapted to interface with the self describing Module. The completed Module package is then produced by the IDE.

The flowchart of depicts process serialization to facilitate an understanding of disclosed embodiments and is not necessarily indicative of the serialization of the operations being performed. In various embodiments the processing steps described in may be performed in varying order and one or more depicted steps may be performed in parallel with other steps. Additionally execution of some processing steps of may be excluded without departing from embodiments disclosed herein.

The illustrative block diagrams depict process steps or blocks that may represent modules segments or portions of code that include one or more executable instructions for implementing specific logical functions or steps in the process. Although the particular examples illustrate specific process steps or procedures many alternative implementations are possible and may be made by simple design choice. Some process steps may be executed in different order from the specific description herein based on for example considerations of function purpose conformance to standard legacy structure user interface design and the like.

Aspects of the present invention may be implemented in software hardware firmware or a combination thereof. The various elements of the system either individually or in combination may be implemented as a computer program product tangibly embodied in a machine readable storage device for execution by a processing unit. Various steps of embodiments of the invention may be performed by a computer processor executing a program tangibly embodied on a computer readable medium to perform functions by operating on input and generating output. The computer readable medium may be for example a memory a transportable medium such as a compact disk a floppy disk or a diskette such that a computer program embodying the aspects of the present invention can be loaded onto a computer. The computer program is not limited to any particular embodiment and may for example be implemented in an operating system application program foreground or background process driver network stack or any combination thereof executing on a single processor or multiple processors. Additionally various steps of embodiments of the invention may provide one or more data structures generated produced received or otherwise implemented on a computer readable medium such as a memory.

Although embodiments of the present invention have been illustrated in the accompanied drawings and described in the foregoing description it will be understood that the invention is not limited to the embodiments disclosed but is capable of numerous rearrangements modifications and substitutions without departing from the spirit of the invention as set forth and defined by the following claims. For example the capabilities of the invention can be performed fully and or partially by one or more of the blocks modules processors or memories. Also these capabilities may be performed in the current manner or in a distributed manner and on or via any device able to provide and or receive information. Further although depicted in a particular manner various modules or blocks may be repositioned without departing from the scope of the current invention. Still further although depicted in a particular manner a greater or lesser number of modules and connections can be utilized with the present invention in order to accomplish the present invention to provide additional known features to the present invention and or to make the present invention more efficient. Also the information sent between various modules can be sent between the modules via at least one of a data network the Internet an Internet Protocol network a wireless source and a wired source and via plurality of protocols.

