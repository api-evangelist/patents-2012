---

title: Symbolic execution and automatic test case generation for JavaScript programs
abstract: A method includes, by one or more computing devices, determining JavaScript statements to be evaluated, parsing the JavaScript statements, translating the JavaScript statements into Java bytecodes and JavaScript-specific instructions, executing the Java bytecodes in a Java execution engine, calling a JavaScript run-time engine from the Java execution engine, handling one or more semantic operations associated with the JavaScript-specific instructions through use of the JavaScript run-time engine, and providing return values to the Java execution engine. The statements are configured for execution on a computing device. The set of Java bytecodes and JavaScript-specific instructions is configured to conduct symbolic execution of one or more portions of the JavaScript statements. The symbolic execution is configured to evaluate the JavaScript statements.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09038032&OS=09038032&RS=09038032
owner: Fujitsu Limited
number: 09038032
owner_city: Kawasaki-shi
owner_country: JP
publication_date: 20120525
---
The present invention generally relates to software verification and more particularly to symbolic execution and automatic test case generation for JavaScript programs.

A software application may include any number of modules e.g. classes functions procedures subroutines or code blocks and each module may be tested or validated individually. A software module may be tested or validated manually or automatically. In the former case a person e.g. a software testing engineer may manually design test cases for the software module based on the design specification of the module execute the module under the test cases and check for module behavior or output that does not agree with the specification of the module in view of the test cases. In the latter case a software testing tool implemented as computer software or hardware may automatically generate test cases for a software module under test execute the module under test while simulating the test cases and check for module behavior or output that does not agree with the specification of the module in view of the test cases. The sheer complexity of modern software often renders manual generation or design of test cases inadequate for completely testing the software.

Java is an object oriented programming language. It may be used to create for example applications and applets. An applet may be downloaded as a separate file in an Internet browser alongside a hypertext markup language HTML document to provide added functionality to a website. The applet may appear to be embedded in an HTML page. However the applet may run in for example a container such as a Java Virtual Machine rather than in the browser or other application running the HTML page. Java may be compiled into machine code.

JavaScript is a scripting language. JavaScript typically resides in HTML documents. JavaScript is not compiled into machine code but is interpreted by an application running for example an HTML file together with a JavaScript interpreter. JavaScript may not create applets or standalone applications. JavaScript is an object based dynamic typing static scope and higher order language.

In one embodiment a method includes by one or more computing devices determining JavaScript statements to be evaluated parsing the JavaScript statements translating the JavaScript statements into Java bytecodes and JavaScript specific instructions executing the Java bytecodes in a Java execution engine calling a JavaScript run time engine from the Java execution engine handling one or more semantic operations associated with the JavaScript specific instructions through use of the JavaScript run time engine and providing return values to the Java execution engine. The statements are configured for execution on a computing device. The set of Java bytecodes and JavaScript specific instructions is configured to conduct symbolic execution of one or more portions of the JavaScript statements. The symbolic execution is configured to evaluate the JavaScript statements.

In another embodiment a system includes a computer readable medium including computer executable instructions and one or more processors coupled to the computer readable medium and operable to read and execute the instructions. The one or more processors are operable when executing the instructions to determine JavaScript statements to be evaluated parse the JavaScript statements translate the JavaScript statements into Java bytecodes and JavaScript specific instructions executing the Java bytecodes in a Java execution engine call a JavaScript run time engine from the Java execution engine handling one or more semantic operations associated with the JavaScript specific instructions through use of the JavaScript run time engine and provide return values to the Java execution engine. The statements are configured for execution on a computing device. The set of Java bytecodes and JavaScript specific instructions is configured to conduct symbolic execution of one or more portions of the JavaScript statements. The symbolic execution is configured to evaluate the JavaScript statements.

In yet another embodiment an article of manufacture includes a computer readable medium and computer executable instructions carried on the computer readable medium. The instructions are readable by a processor. The instructions when read and executed cause the processor to determine JavaScript statements to be evaluated parse the JavaScript statements translate the JavaScript statements into Java bytecodes and JavaScript specific instructions executing the Java bytecodes in a Java execution engine call a JavaScript run time engine from the Java execution engine handling one or more semantic operations associated with the JavaScript specific instructions through use of the JavaScript run time engine and provide return values to the Java execution engine. The statements are configured for execution on a computing device. The set of Java bytecodes and JavaScript specific instructions is configured to conduct symbolic execution of one or more portions of the JavaScript statements. The symbolic execution is configured to evaluate the JavaScript statements.

System may include an electronic device configured to symbolically execute one or more portions of code under test . Further electronic device may be configured to automatically generate test cases resulting from the symbolic execution. In one embodiment electronic device may be configured to evaluate the resulting test cases to validate code under test . Electronic device may be configured to produce results reflecting the results of testing code under test .

Electronic device may be configured to receive code under test in any suitable way such as for example electronically over a network through loading or entering by a user or accessing local or remote storage. Electronic device may be configured to provide results in any suitable way such as for example sending results over a network display to a user or storing to a local or remote storage.

Electronic device may include a test module configured to perform any aspect of testing code under test for electronic device or system such as symbolically executing the one or more portions of code under test automatically generating resulting test cases or evaluating the resulting test cases. Test module may be implemented by any suitable mechanism such as a program software software as service analog or digital circuitry or any combination thereof. Test module may be resident on electronic device . Test module may be implemented as a complete module or as a sub module as part of a larger system. In software form some or all of test module may be implemented by for example logic instructions binaries object code libraries functions programs applications scripts executables or other suitable digital entity.

Electronic device may include any device configurable to interpret and or execute program instructions and or process data including but not limited to a computer desktop server laptop personal data assistant or smartphone. Electronic device may include a processor coupled to a memory . Some or all of test module may be embodied in logic or instructions resident in memory for execution by processor . Processor may include for example a microprocessor microcontroller digital signal processor DSP application specific integrated circuit ASIC or any other digital or analog circuitry configured to interpret and or execute program instructions and or process data. Processor may interpret and or execute program instructions and or process data stored in memory . Memory may comprise any system device or apparatus configured to retain program instructions and or data for a period of time e.g. computer readable media .

Code under test may include for example a hypertext markup language HTML web page or file software software code libraries applications scripts active or passive web content or other logic or instructions for execution upon an electronic device. Code under test may include a complete instance or a portion of such software. In one embodiment code under test may include JavaScript code. In another embodiment code under test may include references to web related components such as objects and application programming interfaces of a web browser or an HTML document object model DOM . Such web related components may be present in JavaScript execution environments.

In one embodiment code under test may not require any modifications in order to be symbolically executed. In another embodiment code under test may require such modifications in order to be symbolically executed by for example test module . The modification may include designations of particular variables parameters or other portions of code under test which test module is to symbolically execute. The designations may be added for example as additional specific instructions in code under test or as rewrites of variable object class or other entity names. The designations may be made using a naming convention such as sym xxx wherein xxx is the original name of the entity. The designations may be made by an application user or other entity preparing code under test for testing with system . Any suitable changes may be made to code under test in order to indicate that some or all of code under test is to be symbolically executed. For the purposes of the use of code under test in and subsequent figures it may be assumed that such designations if necessary have already been made.

Using symbolic execution test module may be configured to validate code under test in any suitable way. For example test module may evaluate whether code under test can be executed in a manner consistent with design constraints and acceptable operating parameters. Test module may symbolically execute code under test to determine for example programming bugs assertion violations functional correctness security violations or other indications of valid operation or errors. The determined status may be stored or reported in results .

Results may be implemented by data files or any other suitable mechanism for portraying storing or otherwise indicating the result of the operation of test module . Results may include for example test cases generated by test module through symbolic execution of code under test or indications of validation or errors in code under test determined by evaluating the test cases.

Despite the similar name many differences exist between JavaScript and Java. JavaScript code and Java code are not equivalent. A piece of software enabled to use Java may not necessarily be enabled to use JavaScript and vice versa. Java may be used to create stand alone applications or applets while JavaScript may not residing instead within an existing HTML document. In some instances JavaScript may be considered a scripting language rather than a programming language.

Further while Java code and JavaScript code may use some similar vocabulary or syntax constructions an engine or other entity requiring Java code cannot run JavaScript code nor can an engine or other entity requiring JavaScript code run Java code. The similar vocabulary or syntax constructions may arise from their common ancestry with the C programming language rather than through common development. The semantics and programming language constructs between the languages may differ. For example Java may have static typing while JavaScript may have dynamic typing. Thus JavaScript variables may hold an object of any type. JavaScript is weakly typed whereas Java is strongly typed. When used Java based applications are loaded from a compiled bytecode created from the original Java code whereas JavaScript is loaded into an application in its original source code form. Java is object oriented while JavaScript is object based Java s objects are class based and use inheritance whereas JavaScript s objects are prototype based without classes or inheritance.

In addition JavaScript may contain any number of commands statements or functional features that are not present in Java. Some of these commands may include interfaces to the interpreter or environment in which the JavaScript code runs. A Java compiler would be unable to compile and execute such commands. The JavaScript commands to the environment may include for example accessing events anywhere in an HTML page such as controlling the back button on the browser. In contrast compiled Java code in an applet may only access events within the applet container.

Java code may require compilation into bytecodes which may be downloaded for execution into an entity such as a Java Virtual Machine. The actual electronic device on which the Java code is to execute may be unknown and thus generating pure machine code may be impractical. However a given electronic device may include such a Java Virtual Machine which may be able to accept Java bytecodes and execute them on the particular electronic device.

In contrast JavaScript code may be interpreted as part of the file such as an HTML file in which it resides. Download of the HTML file may thus inherently download the JavaScript code which is interpreted as the HTML page is loaded and displayed. Thus Java code cannot simply be interchanged with JavaScript code nor can Java bytecodes simply be interchanged with JavaScript code.

As described above JavaScript code in an HTML file may make references to various web related components such as an HTML DOM or objects and application programming interfaces of a web browser. The web related components may normally be present in JavaScript execution environments and JavaScript code may be written assuming that facilities for their use are present. For example a JavaScript reference may be made to the window in which it is executing thus invoking methods or objects without even creating instances of them. Java executing entities might not be able handle such references as no provisions are given for understanding their structure or function.

The incompatibility of JavaScript code and Java code means that many existing programs applications techniques libraries and other tools created for one language may be unavailable for the other. For example software validation solvers may exist for Java code that has been symbolically executed into test cases but these are unavailable to validate JavaScript code. Further a complete translation from one code to the other code may be unfeasible or impossible. Some given commands or structures in one language may have no equivalent in the other. For example environmental commands in JavaScript for controlling the back button of a browser as described above may have no equivalent in Java. The creation typing and morphing of variables may mean that variable use can be entirely different between the languages. In addition JavaScript executing entities may be unable to perform symbolic execution while symbolic execution modules and associated solvers may exist for Java code.

Accordingly in order to symbolically execute code under test test module may be configured to utilize a hybrid of Java and JavaScript processing in order to accept code under test containing JavaScript and references to non Java web related components such as HTML DOMs or browser objects and functions. Any suitable hybrid of Java and JavaScript processing may be used in order to symbolically execute code under test . Various embodiments of such hybrids of Java and JavaScript processing are shown in more detail in for example below.

In operation test module may be executing on electronic device . Test module may be accessible to local or remote users. Code under test may be provided to electronic device and test module . Test module may analyze code under test by any suitable process such as symbolically executing code under test . Test module may generate test cases as a result of the symbolic execution. In one embodiment test module may analyze the test cases to determine whether the test cases indicate code under test contains errors or is valid. Test module may produce results containing for example the generated test cases or the results of analyzing the test cases. Results may be provided to a user stored or otherwise used to evaluate code under test .

Test module may include a JavaScript parser web object module symbolic Java executor such as symbolic Java pathfinder JavaScript run time engine and solver module . JavaScript parser may be communicatively coupled to symbolic Java pathfinder and to web object module . Symbolic Java pathfinder may in turn be communicatively coupled to JavaScript runtime engine and to solver module which may be configured to produce results .

Code under test may contain code that is to be evaluated tested or validated and may be implemented in for example a file record database or any other suitable entity. Code under test may include one or more portions of code including JavaScript code DOM references and browser references . Browser references may include references to web browser objects and functions. Results may be implemented in any suitable manner such as a file record data structure or database and include results from .

JavaScript parser web object module symbolic Java pathfinder JavaScript run time engine and solver module may each be implemented in any suitable manner such as a program software library application script function software as service analog or digital circuitry or any combination thereof. Although each of JavaScript parser web object module symbolic Java pathfinder JavaScript run time engine and solver module are shown as separate components any of these may be combined with another component shown or not shown and still perform the functionality described herein. JavaScript parser web object module symbolic Java pathfinder JavaScript run time engine and solver module may each implement some or all of test module from . JavaScript parser web object module symbolic Java pathfinder JavaScript run time engine and solver module may each be implemented in common or distinct modules and such modules may be implemented as a complete module or as sub modules as part of a larger system. In software form some or all of JavaScript parser web object module symbolic Java pathfinder JavaScript run time engine and solver module may be implemented by for example logic instructions binaries object code libraries functions programs applications scripts executables or other suitable digital entity.

In one embodiment JavaScript parser and JavaScript runtime engine may be adapted changed modified or otherwise repurposed from a traditional JavaScript interpreter. JavaScript parser and JavaScript runtime engine may have been changed to implement the functionality of test module as described herein. In a further embodiment JavaScript parser and JavaScript runtime engine may have been so adapted from the JavaScript interpreter known as Rhino JavaScript parser and JavaScript runtime engine may not form a complete JavaScript interpreter. For example JavaScript parser and JavaScript runtime engine may be configured to work without a concrete interpreter which would fully execute received JavaScript code.

JavaScript parser may be configured to receive code under test or a portion thereof. Further JavaScript parser may be configured to parse code under test to determine portions that may be represented as Java bytecodes and portions that are specific to JavaScript. In one embodiment JavaScript parser may be limited to the parsing as implemented in generally available JavaScript interpreters such as Rhino In another embodiment JavaScript parser may include traditional JavaScript parsing used in JavaScript interpreters but may be modified to enhance the ability of test module to translate some JavaScript specific portions of code under test or instruction stream into instructions that can be handled by a traditional Java execution engine. In yet another embodiment such translation capabilities may be implemented by another portion of test module such as symbolic Java pathfinder . In still yet another embodiment such translation may be implemented on the fly or on demand by another portion of test module such as symbolic Java pathfinder wherein the received Java specific portions are translated as needed.

Test module might not be capable of fully translating JavaScript into Java due to any number of issues such as inherent incompatibilities between the two languages. However test module may be configured through for example JavaScript parser to partially translate JavaScript into instruction stream including Java bytecodes and indications of JavaScript specific instructions or components. As described below instruction stream may be executed by a Java runtime engine or Java virtual machine such as symbolic Java pathfinder configured to execute the Java bytecodes and make special use of a JavaScript runtime engine to access the JavaScript specific instructions or components.

Any suitable or feasible JavaScript specific components may be translated into instructions native to Java or otherwise made readable by a Java execution engine. For example basic data structures and operations in JavaScript may be implemented directly with their equivalent data structures and operations in Java. JavaScript specific data structures and operations thereof if not translatable may be included in instruction stream in their JavaScript specific state. Regardless of whether a given data structure is translated or not an instance of it may be designated for symbolic execution. Various semantics and functions in JavaScript may not be translatable due to differences between JavaScript and Java such as type conversion or higher order functions. Thus these may be included in instruction stream in their JavaScript specific state.

As described above references to various web components such as DOM references or browser references may be made with the assumption that for example a JavaScript execution environment would be available to natively understand the context of such references or that instances of an object are already created and available for operation. Some of such references may be translatable such that they may be used in a Java execution environment.

JavaScript parser may be configured to translate one of DOM references or browser references by accessing web object module . Web object module may be configured to store one or more prototypes data structures object models or other information on DOM or browser objects accessible to JavaScript. In one embodiment JavaScript parser may be configured to create Java code that reflects the accessed object in code under test. JavaScript parser may create such Java code using the reference in code under test such as on of DOM references or browser references in combination with the information received from web object module . In such an embodiment a Java execution engine may simply access and run this Java code. In another embodiment JavaScript parser may be configured to create executable JavaScript code that reflects the accessed object in code under test. JavaScript parser may create such code by combining the reference in code under test such as one of DOM references or browser references with the information received from web object module . In such an embodiment a Java execution engine may make special use of a JavaScript runtime engine to access the JavaScript specific instructions forming the reference.

JavaScript parser may be configured to make the translation of one of DOM references or browser references at any suitable time. In one embodiment JavaScript parser may be configured to make such translations when translating other portions of code under test . In another embodiment JavaScript parser may be configured to delay such translation and subsequent loading. For example JavaScript parser may place markers events or other indications of such references into instruction stream so that a Java engine processing instruction stream may demand translation on the fly. Such an embodiment may be utilized for cases where JavaScript parser has translated an object into JavaScript code rather than into Java code. In another example an attempted access by one of DOM references or browser references may be preserved in instruction stream as JavaScript specific content. When such references are reached during the execution of instruction stream the executor such as symbolic Java pathfinder may be configured to access JavaScript runtime engine and JavaScript parser to build the object in question. As mentioned above the object may be built in for example Java code or JavaScript code as appropriate. The object may then be loaded into the Java executor.

Web object module may be implemented by any suitable mechanism. In one embodiment web object module may be implemented by a parser from the EnvJS simulated browser environment. Such a parser may include an html5 xml parser. Web object module may be configured to provide models for any suitable object including HTML DOM objects such as Document Events Elements Anchor Area Base Body Button Form Frame IFrame or browser objects such as Windows Navigator Screen History or Location.

A later user of instruction stream such as a Java execution engine may determine that a given portion of instruction stream is JavaScript specific and may make use of a JavaScript runtime engine to utilize the JavaScript specific portion. In one embodiment the Java execution engine may be configured to identify the contents as JavaScript specific. In another embodiment an indication or marker of the JavaScript specific nature of any portion of code under test may be made in instruction stream .

As described above instruction stream may include one or more Java bytecodes and one or more indications of JavaScript specific instructions. Instruction stream may be produced all at once or on a rolling basis depending upon the operation of test module to process code under test . JavaScript parser may provide instruction stream to any suitable Java execution engine such as symbolic Java pathfinder for executing instruction stream .

Symbolic Java pathfinder may be configured to execute instruction stream in any suitable manner. In one embodiment symbolic Java pathfinder may be configured to directly execute Java bytecodes in instruction stream and to access a JavaScript engine such as JavaScript runtime engine to facilitate JavaScript specific portions of instruction stream . Symbolic Java pathfinder may be configured to call JavaScript runtime engine using an application programming interface or other suitable mechanism. JavaScript runtime engine may be configured to perform operations as instructed by symbolic Java pathfinder . Symbolic Java pathfinder may be configured to perform some of the translation operations described above in association with JavaScript parser .

JavaScript runtime engine may be configured to conduct JavaScript operations as instructed by symbolic Java pathfinder . JavaScript runtime engine may be configured to return values to symbolic Java pathfinder by for example returning function parameters or writing values to memory. In one embodiment JavaScript runtime engine may itself be written in Java and thus its code for conducting JavaScript specific operations may be executed within symbolic Java pathfinder .

While symbolic Java pathfinder may be configured to delegate JavaScript specific operations to JavaScript runtime engine symbolic Java pathfinder may be configured to maintain corresponding information necessary to perform its functions such as symbolic execution. For example for a given JavaScript variable symbolic Java pathfinder may delegate typing and casting of the object to JavaScript runtime engine . JavaScript runtime engine may establish and maintain the type syntax scope and other information about the variable. Symbolic Java pathfinder may maintain information about the variable relevant to symbolic execution. Thus an access to the variable in instruction stream may first trigger a delegation to JavaScript runtime engine to determine a type or type conversion and then an access by symbolic Java pathfinder to the actual or symbolic value. In another example a JavaScript function call may be delegated to JavaScript runtime engine . JavaScript runtime engine may be configured to pre process the function with respect to its semantics parameters and the scope thereof and subsequent instructions. JavaScript runtime engine may be configured to communicate with symbolic JavaScript pathfinder to hand off processing of the function. In one embodiment symbolic JavaScript pathfinder may then symbolically execute the function in the Java domain.

Any suitable mechanism may be used for symbolic Java pathfinder and JavaScript runtime engine to access each other s functionality. In one embodiment they may include various application programming interface functions accessible by the other. In addition to the interoperation described above functions may be provided for designating that a given variable is to be executed symbolically. In another embodiment portions of symbolic Java pathfinder may be modified or written to incorporate functionality of JavaScript runtime engine . For example the ability to handle common JavaScript objects and associated functions such as JS Boolean JS Number JS String JS Global JS RegExp JS Array JS Date and JS Math may be included in symbolic Java pathfinder .

As symbolic Java pathfinder may be configured to symbolically execute code under test symbolic Java pathfinder may be configured to intercept all attempted JavaScript operations on regular expressions. Provisions for symbolic execution may have been added to code under test in the form of various searches or other operations for regular expressions. Such provisions may have been written in JavaScript and may include naming or other markers. Thus symbolic Java pathfinder may be configured to recognize JavaScript regular expression operations associated with symbolic execution. For these symbolic Java pathfinder may be configured to model the regular expression in question with a Java object and conduct regular expression operations through the object s functions.

Symbolic Java pathfinder may be configured to determine through any suitable mechanism what components of instruction stream are to be symbolically executed. In one embodiment the components of instruction stream may derive from portions of code under test with special names or other markers indicating such symbolic execution. In another embodiment such names or markers may have been added by JavaScript parser . In yet another embodiment symbolic Java pathfinder may be configured to recognize objects and structures used in symbolic execution such as regular expressions and treat them accordingly.

Symbolic Java pathfinder may be configured to conduct symbolic execution on code under test in its form in instruction stream in any suitable manner. The symbolic execution may include a program verification technique that systematically explores the different paths in a program. Included in such systematic exploration may be sequences of particular function calls that form a given path. Symbolic Java pathfinder may be configured to analyze conditional branch points in an instruction sequence. Such conditional branch points may include for example if then else statements or conditional loops. The result of symbolically executing the symbolic test driver may include test cases to be analyzed by solver module . The test cases may include sequences of instructions paralleling code under test with specified input variables. The test case may include sequences of functional calls and input vectors or variable values that form a particular path. Further the test cases may include constraints on the available range of a given variable. The constraints may be determined through for example the design and operating parameters of code under test or through symbolic execution. The constraints may include equations or logical conditions.

Multiple such test cases may be created given a conditional branch point wherein one test case shows the execution given one possible outcome of the conditional branch and another test case shows the execution given a different possible outcome of the conditional branch. Further multiple such test cases may be created using different possible values for the variables. Execution of the test cases may or may not be possible under such constraints.

Solver module may be configured to execute the test cases and evaluate whether the results in view of the constraints validate code under test . If the results of executing the test cases violate the constraints then solver module may be configured to determine that for example a bug error or security violation exists in code under test represented by the test cases. If the results of executing the test cases do not violate the constraints then solver module may be configured to validate code under test represented by the test cases at least given the existing constraints. Solver module may be configured to reexamine test cases representing code under test in view of new constraints as they are determined by for example symbolic Java pathfinder . After evaluating the test cases solver module may be configured to advise symbolic Java pathfinder of whether to stop or to continue symbolically executing code under test . Solver module may be configured to make such a determination through any suitable mechanism such as determining whether a certain amount of test coverage has been performed or a certain limit of resources such as iterations or time have been expended. After determining whether a test or resource boundary has been met solver module may be configured to advise symbolic Java pathfinder of whether to stop or to continue to evaluate code under test . Test engine may be configured to produce results .

In operation code under test possibly containing JavaScript code HTML DOM references and browser references may be provided to test module . JavaScript parser may translate code under test into instruction stream to include Java bytecodes and JavaScript specific components. Some JavaScript specific components may be translated into Java equivalents. JavaScript parser may access web object module to determine how to create objects for HTML DOM references or browser references . Such objects may be created in Java or JavaScript as appropriate. JavaScript parser may send instruction stream to symbolic Java pathfinder .

Symbolic Java pathfinder may execute the contents of instruction stream . Symbolic Java pathfinder may execute native Java bytecodes directly translate certain JavaScript specific components and execute the components directly or call specially adapted functions to execute the JavaScript specific components directly. For other JavaScript specific components symbolic Java pathfinder may access JavaScript runtime engine . JavaScript runtime engine may be accessed by specific function calls or by being embedded within symbolic Java pathfinder . JavaScript runtime engine may handle JavaScript specific operations such as semantics typing or other operations while symbolic Java pathfinder may actually access the underlying objects variables or functions.

Symbolic Java pathfinder may perform such execution in order to symbolically execute code under test . Based on such symbolic execution symbolic Java pathfinder may generate one or more test cases including constraints equations and other information necessary to evaluate code under test . Symbolic Java pathfinder may send the test cases to solver module which may evaluate the test cases in view of constraints. If such test cases can be solved under the constraints code under test may be validated. Otherwise code under test may be determined to contain one or more bugs errors or security violations. Solver module may produce results .

JavaScript parser may be configured to convert this code segment from code under test into instruction stream . The contents of instruction stream in show the results of parsing the above example code. For illustrative purposes Java bytecode sets and JavaScript specific components have been explicitly noted. Java bytecode set and Java bytecode set may be configured to load the specified string and the variable into memory. However the operations to allocate the variable and assign the string to the variable may be JavaScript specific semantic operations and thus shown in JavaScript specific component and JavaScript specific component which may be references to memory locations of the specific functions in JavaScript runtime engine . The logical location and designation of the functions path Script.Runtime.setName and path Script.Runtime.name are provided for the sake of clarity. Following these Java bytecode set may load the string abc into memory and prepare for a comparison operation and JavaScript specific component may invoke the comparison operation itself and return the value. Following the comparison Java bytecode set may provide memory branch operations based on the results of the comparison.

Symbolic Java pathfinder may receive instruction stream and execute and delegate the appropriate portions thereof. For example symbolic Java pathfinder may execute Java bytecode set and then use JavaScript runtime engine to handle JavaScript specific component . JavaScript runtime engine may contain an object such as ScriptRuntime which may contain functions .setName .name or .cmp which may be accessible by symbolic Java pathfinder . Symbolic java pathfinder may reference such functions specifically to appropriately handle a given JavaScript specific component. JavaScript runtime engine may return values to symbolic Java pathfinder or write values into an application space resident in memory. Although application space is shown within JavaScript runtime engine it may be located external to JavaScript runtime engine internal to symbolic Java pathfinder or in a location accessible to either entity. Symbolic Java pathfinder and JavaScript runtime engine may repeat these actions for additional portions of instruction stream such as Java bytecode sets and JavaScript specific components .

JavaScript Parser or another appropriate portion of test module may include any suitable mechanism for creating the object in Java or JavaScript. For example JavaScript Parser may include a web object detector configured to determine the need for such objects and to create them. Web object detector may be implemented by any suitable software function library application script or other suitable mechanism. Web object detector may determine from code under test that one or more HTML DOM or browser objects are contained therein. Further web object detector may determine whether such an object has already been created. If no such object has been created web object detector may access web object module to retrieve an appropriate prototype for the object.

Web object module may contain any suitable number or kind of prototypes of objects for implementation in Java or JavaScript. For example web object module may contain a window prototype . Window prototype may define the type scope functions variables and other information regarding a Window object. The definitions may be provided in JavaScript or Java as appropriate to the object. In the example code given above references are made to a Window object. Consequently web object module may provide window prototype to web object detector .

Web object module may create instructions to instantiate an object of the received prototype and populate the various portions of the prototype with values inferred or discovered from code under test . Web object module may modify code under test to include the newly created instructions to produce modified code under test . The modified code under test may continue to be processed by JavaScript parser using other JavaScript parser components according to the descriptions of test module herein. JavaScript parser may thus produce an instruction stream containing the original and newly created instructions regarding the object.

In the example provided in web object detector may create an instance of the Window object by inserting code into modified code under test corresponding to the instructions in Window prototype . Specific variables may be populated such as defaultStatus set to loaded and title set to Alchemy . Such variable values may have been derived from the contents of code under test wherein the reference is made to example alchemy.html or the references indicate that the window is actually being used. The inserted code reflecting the creation of the web object may be accompanied by one or more of the original additional web references such as print window.title which reflect use of the object once it has been created.

Once modified code under test has been created and translated into instruction stream it may contain resulting Java bytecodes and JavaScript specific elements. As the object may have been created using Java or JavaScript the resulting code under test may be accomplished by native execution in symbolic Java pathfinder alone or by a combination of such native execution and additional calls to JavaScript runtime engine .

In step the code under test may be parsed. Parsing the code under test may be conducted in any suitable manner. In one embodiment parsing the code under test may be conducted with a parser adapted and modified from an existing JavaScript interpreter. In step during the parsing it may be determined whether one or more web objects have been referenced. Such objects may be referenced by JavaScript code that assumes the objects are known within an executor. However such an assumption may be incorrect as method may be conducted on a Java execution environment rather than on a pure JavaScript interpreter. The objects may include for example HTML DOMs or browser objects.

If such web objects are referenced in step an object prototype associated with the reference may be retrieved. The object prototype may include instructions defining and encompassing an instance of the object that was referenced in the code under test. The instructions may be written in for example Java or JavaScript. In step code may be inserted into the code under test creating an instance of the object using the object prototype. Instructions for populating creating or executing various portions of the object prototype instance may be included. Such instructions may be based upon the use of the object in the reference in the code under test. In one embodiment step or step may be executed when the associated code under test is accessed by an execution engine rather than during parsing. Steps may be conducted at least once for each different instance of an object that is referenced in the code under test.

If no such web objects are referenced or upon the completion of step in step the code under test may be translated into a combination of Java bytecodes and Java specific components. Step may be conducted during parsing of code under test and upon execution by a Java execution engine.

In step content to be symbolically executed may be determined. Such content may include variables functions or other portions of the code under test. The determination may be made by discovering markers or other indications in code under test. The content to be symbolically executed may be related to specific constraints under which the code under test is being tested.

In step Java bytecodes may be executed in a Java engine. The bytecodes may be configured for the desired symbolic execution. Further additional JavaScript specific components may be translated into Java bytecodes and subsequently executed. In step a JavaScript run time engine may be called to handle semantics and other JavaScript processing of the JavaScript specific components. Values may be returned from the JavaScript run time engine by for example parameters or writes to shared memory. The JavaScript specific components may be configured for the desired symbolic execution. In step if the desired symbolic execution iteration has not finished steps and may be repeated. If the desired symbolic execution iteration has finished then method may proceed to step .

In step test cases resulting from the symbolic execution in the iteration of steps and may be produced. Such test cases may include constraints on possible values of variables parameters functions or other portions of the code under test.

In step the test cases may be solved. If the test cases can be solved then the code under test in question may be validated in view of the symbolic execution and its constraints. If the test cases cannot be solved then it may be determined that the code under test contains one or more errors bugs or security flaws. The results of solving the test cases may be produced displayed or stored.

In step it may be determined whether a boundary condition for symbolic execution has been reached. Such a condition may include depth of execution number of iterations time or another suitable metric. If the boundary condition has not been reached then method may return to step to determine additional content to be symbolically executed. If the boundary condition has been reached then method may terminate in step .

Although discloses a particular number of steps to be taken with respect to example method method may be executed with more or fewer steps than those depicted in . In addition although discloses a certain order of steps to be taken with respect to method the steps comprising method may be completed in any suitable order. Further various steps of method may be conducted in parallel with each other.

Method may be implemented using the system of or any other system network or device operable to implement method . In certain embodiments method may be implemented partially or fully in software embodied in computer readable media. For the purposes of this disclosure computer readable media may include any instrumentality or aggregation of instrumentalities that may retain data and or instructions for a period of time. Computer readable media may include without limitation storage media such as a direct access storage device e.g. a hard disk drive or floppy disk a sequential access storage device e.g. a tape disk drive compact disk CD ROM DVD random access memory RAM read only memory ROM electrically erasable programmable read only memory EEPROM and or flash memory as well as communications media such as wires optical fibers and other tangible non transitory media and or any combination of the foregoing.

Although the present disclosure has been described in detail it should be understood that various changes substitutions and alterations can be made hereto without departing from the spirit and the scope of the disclosure.

