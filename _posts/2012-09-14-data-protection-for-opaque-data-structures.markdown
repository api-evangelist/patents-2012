---

title: Data protection for opaque data structures
abstract: Methods, media and systems that use an encoded opaque pointer in an API between a client process and a library process. An encoded opaque pointer, in one embodiment, can be received by the library process from the client process, and the library process can decode the opaque pointer to obtain an address in memory containing a data structure pointed to by the opaque pointer. The library process can operate on the data structure to create a revised or processed data structure, stored in the same or different address in heap memory or stack memory, and the library process can encode and return a new opaque pointer, for the processed data structure, to the client process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09424049&OS=09424049&RS=09424049
owner: Apple Inc.
number: 09424049
owner_city: Cupertino
owner_country: US
publication_date: 20120914
---
This application claims the benefit of U.S. Provisional Application No. 61 606 233 filed Mar. 2 2012 which is hereby incorporated by reference.

The present invention relates to the field of methods for protecting data used in a data processing system such as a computer.

In computer programming an opaque pointer is a special case of an opaque data type which is a data type that is declared to be a pointer to a record or data structure of some unspecified type. Opaque pointers are often used in computer programs to hide implementation details. For example a client software process which is communicating with a library might establish a session by calling an API application programming interfaces that will send back an opaque pointer to the client process. The opaque pointer can be used in subsequent calls to identify the client from the standpoint of the library and can be used to refer to or point to the data structure which can be manipulated by the library. Opaque pointers provide a way to hide the implementation details of an interface from a client process so that the implementation can be changed without the need to recompile the modules using the implementation.

APIs using opaque pointers are often targeted by attackers that might attempt to reverse engineer the opaque data structure. Once the opaque data structure is understood attackers can intercept the data modify it or even replay data previously observed. Hence an improved method for using opaque pointers may be desirable.

Methods machine readable non transitory storage media and systems that use an encoded opaque pointer in an API between a client process and a library process are described. In one embodiment an encoded opaque pointer can be received by the library process from the client process and the library process can decode the opaque pointer to obtain an address in memory containing a data structure pointed to by the opaque pointer. The library process can operate on the data structure to create a revised or processed data structure and then the library process can encode and return a new opaque pointer corresponding to the processed data structure to the client process. In one embodiment the data structure can be stored at an address in heap memory or in stack memory of the library process. In one embodiment the encoding of the opaque pointer can include the use of selected portions of text of the executable code in binary opcode form of the library process and this representation of text can be used as a variable in the encoding of the opaque pointer. In this way the opaque pointer is associated with or tied to the particular library code used in the encoding process and it will be difficult for an attacker to reverse engineer the encoding process particularly if the selection of the text of the binary code is random. In one embodiment the text can be from a portion of the library process while in another embodiment the text can be from a portion of the client process or a combination of both the library process and the client process.

The encoding of an opaque pointer can be performed in a layered or repetitive fashion. For example the encoding can be performed by using a series of encoding operations in which an output from a first encoding operation is used as an input to a next encoding operation in order to apply multiple layers of encoding to the opaque pointer.

The encoding of the opaque pointer can also use one or more constants in the executable code of the library process as variables in the encoding of the opaque pointer. Moreover the encoding of the opaque pointer can use a representation of a pointer value which corresponds to one or more addresses of the data structure used by the library process as part of the API. This pointer value can be used as a variable in the encoding of the opaque pointer in one embodiment. Moreover in one embodiment the encoding can also use a representation of the data structure itself as a variable in the encoding process for encoding an opaque pointer.

In one embodiment the encoding of the opaque pointer can be performed by calculating an encryption function with a key and variables. The key can be a fixed cryptographic key or a concatenation of a set of the variables used in the encryption function such as a representation of text of the executable code in the library process and one or more constants in the executable code and a representation of the data structure and a representation of the pointer value which points to the data structure.

The encoding operations effectively scramble in one embodiment the pointer and the data that is pointed to in such a way that running the same client process with the same library in two identical environments will generate two different scramblings or encodings in this fashion the encoding process is non deterministic. Moreover in one embodiment running the same client process with the same library process several times in a row in a single environment can in one embodiment generate different encodings or scramblings each time in other words the encoding can be dynamic. In one embodiment the encoding operation can depend on static information embedded in the library program at compilation time. Moreover the encoding operation can depend upon constant data embedded in the program so that altering those constants will result in a different encoding result.

In one embodiment an attempt to circumvent the protection provided by this encoded opaque pointer can be provided by detecting a modified encoded opaque pointer which has been modified by an attacker. In one embodiment a simple checksum mechanism can be used to detect buffer corruption which indicates that a hacker has modified an opaque pointer. In response to detecting this modification defensive mechanisms can be taken such as crashing the library program or corrupting data or blacklisting the client etc. depending on the context and seriousness of the security breach.

Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.

The above summary does not include an exhaustive list of all aspects of the present invention. It is contemplated that the invention includes all systems and methods that can be practiced from all suitable combinations of the various aspects summarized above and also those disclosed in the Detailed Description below.

Various embodiments and aspects of the inventions will be described with reference to details discussed below and the accompanying drawings will illustrate the various embodiments. The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of various embodiments of the present invention. However in certain instances well known or conventional details we not described in order to provide a concise discussion of embodiments of the present invention.

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in conjunction with the embodiment can be included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification do not necessarily all refer to the same embodiment. The processes depicted in the figures that follow are performed by processing logic that comprises hardware e.g. circuitry dedicated logic etc. software or a combination of both. Although the processes are described below in terms of some sequential operations it should be appreciated that some of the operations described may be performed in a different order. Moreover some operations may be performed in parallel rather than sequentially.

An API and or a library process can be protected through the use of one or more encoded opaque pointers which are exchanged to cross the API between a client process and a library process. The encoding of an opaque pointer can be considered to be a seal applied to the opaque pointer and the seal helps to protect the opaque pointer from attack by hackers or others attempting to reverse engineer the API or the library process.

Library process includes executable binary codes in the form of text which can represent binary opcodes for the software of the library process. This text referred to as code text can be used in one embodiment as part of the encoding process and this is described further below in conjunction with for example . Library process can include software which implements encoding and decoding processes . The encoding and decoding processes are used to encode and decode one or more opaque pointers according to one embodiment of the present invention. Library process can also include constants such as fixed integer or floating point values which are embedded in the library process either when the software for library process is written or at compilation time.

The implementation of an encoding process as shown in can provide a variety of advantages. For example naming the same client process with the same library process in two identical environments can generate two different encoded opaque pointers by virtue of using randomly selected portions of binary opcodes of the library process and randomly selecting constants in the library code etc. Running the same client process with the same client library several times in a row in a single environment can generate different encoded opaque pointers each time. This can also result from the use of random selections of code portions or random selection of constants in the code library or different positions of the pointer or differences in the data structures over time. Hence the encoded opaque pointer can be non deterministic and also dynamic over time. Further encoded opaque pointers applied to two unrelated opaque data structures can be different this can be due to the fact that the encoding depends on static information embedded in the library process at compilation time. Also the encoding can depend upon constant data embedded in the library process so that altering those constants will result in a different encoding being applied. As noted previously the encoding can be applied or removed multiple times in reversible manner and be layered multiple times. The layering may be particularly helpful to ensue that certain paths are indeed executed. For example if you want to ensure both foo and bar are invoked and not just bar then 

The decoding operations which decode the encoded opaque pointers can be simple decryption algorithms that use a symmetric key to reverse the encryption algorithm and thereby reveal the inputs which can include the pointer value.

A display controller and display device can provide a visual user interface for the user this interface may include a graphical user interface which is similar to that shown on a Macintosh computer when running OS X operating system software or iOS software on an iPhone or iPad . The system also can include one or more wireless transceivers to communicate with another data processing system. A wireless transceiver may be a WLAN transceiver e.g. WiFi an infrared transceiver a Bluetooth transceiver and or a wireless cellular telephony transceiver. It will be appreciated that additional components not shown may also be part of the system in certain embodiments. and in certain embodiments fewer components than shown in may also be used in a data processing system. The system further can include one or more communications ports to communicate with another data processing system. The communications port may be a USB port Firewire port Bluetooth interface a docking port etc.

The data processing system also can include one or more input devices which are provided to allow a user to provide input to the system. These input devices may be a keypad or a keyboard or a touch panel or a multi touch panel which is overlaid and integrated with a display device such as display device . The data processing system can also include an optional input output device which may be a connector for a dock. It will be appreciated that one or more buses not shown may be used to interconnect the various components as is well known in the art. The data processing system shown in may be a desktop computer a handheld computer or a personal digital assistant PDA or a cellular telephone with PDA like functionality or a handheld computer which includes a cellular telephone or a media player such as an iPod or a game or entertainment device or devices which combine aspects or functions of these devices such as a media player combined with a PDA and a cellular telephone in one device or an embedded device or other consumer electronic devices. In other embodiments the data processing system may be a network computer or an embedded processing device within another device or other types of data processing systems which have fewer components or perhaps more components than that shown in .

Data processing system can optionally include one or more hardware devices designed to digitize and store human speech received by the microphone in Audio I O .

At least certain embodiments of the inventions may be part of a digital media player such as a portable music and or video media player which may include a media processing system to present the media a storage device to store the media and may further include a radio frequency RF transceiver e.g. an RF transceiver for a cellular telephone coupled with an antenna system and the media processing system. In certain embodiments media stored on a remote storage device may be transmitted to the media player through the RF transceiver. The media may be for example one or more of music or other audio still pictures or motion pictures.

Examples of a portable media player are described in published U.S. Pat. No. 7 345 671 and U.S. published patent application number 2004 0224638 both of which are incorporated herein by reference.

One or more Application Programming Interfaces APIs may be used in some embodiments. An API is an interface implemented by a program code component or hardware component hereinafter API implementing component that allows a different program code component or hardware component hereinafter API calling component to access and use one or more functions methods procedures data structures classes and or other services provided by the API implementing component. An API can define one or more parameters that are passed between the API calling component and the API implementing component.

An API allows a developer of an API calling component which may be a third party developer to leverage specified features provided by an API implementing component. There may be one API calling component or there may be more than one such component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from an application. An operating system OS can have multiple APIs to allow applications running on the OS to call one or more of those APIs and a service such as a program library can have multiple APIs to allow an application that uses the service to call one or more of those APIs. An API can be specified in terms of a programming language that can be interpreted or compiled when an application is built.

In some embodiments the API implementing component may provide more than one API each providing a different view of or with different aspects that access different aspects of the functionality implemented by the API implementing component. For example one API of an API implementing component can provide a first set of functions and can be exposed to third party developers and another API of the API implementing component can be hidden not exposed and provide a subset of the first set of functions and also provide another set of functions such as testing or debugging functions which are not in the first set of functions. In other embodiments the API implementing component may itself call one or more other components via an underlying API and thus be both an API calling component and an API implementing component.

An API defines the language and parameters that API calling components use when accessing and using specified features of the API implementing component. For example an API calling component accesses the specified features of the API implementing component through one or more API calls or invocations embodied for example by function or method calls exposed by the API and passes data and control Information using parameters via the API calls or invocations. The API implementing component may return a value through the API in response to an API call from an API calling component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API may not reveal how the API call accomplishes the function specified by the API call. Various API calls are transferred via the one or more application programming interfaces between the calling API calling component and an API implementing component. Transferring the API calls may include issuing initiating invoking calling receiving returning or responding to the function calls or messages in other words transferring can describe actions by either of the API calling component or the API implementing component. The function calls or other invocations of the API may send or receive one or more parameters through a parameter list or other structure. A parameter can be a constant key data structure object object class variable data type pointer array list or a pointer to a function or method or another way to reference a data or other Item to be passed via the API.

Furthermore data types or classes may be provided by the API and implemented by the API implementing component. Thus the API calling component may declare variables use pointers to use or instantiate constant values of such types or classes by using definitions provided in the API.

Generally an API can be used to access a service or data provided by the API implementing component or to initiate performance of an operation or computation provided by the API implementing component. By way of example the API implementing component and the API calling component may each be any one of an operating system a library a device driver an API an application program or other module it should be understood that the API implementing component and the API calling component may be the same or different type of module from each other . API implementing components may in some cases be embodied at least in part in firmware microcode or other hardware logic. In some embodiments an API may allow a client program to use the services provided by a Software Development Kit SDK library. In other embodiments an application or other client program may use an API provided by an Application Framework. In these embodiments the application or client program may incorporate calls to functions or methods provided by the SDK and provided by the API or use data types or objects defined in the SDK and provided by the API. An Application Framework may in these embodiments provide a main event loop for a program that responds to various events defined by the Framework. The API allows the application to specify the events and the responses to the events using the Application Framework. In some implementations an API call can report to an application the capabilities or state of a hardware device including those related to aspects such as input capabilities and state output capabilities and state processing capability power state storage capacity and state communications capability etc. and the API may be implemented in part by firmware microcode or other low level logic that executes in pet on the hardware component.

The API calling component may be a local component i.e. on the same data processing system as the API implementing component or a remote component i.e. on a different data processing system from the API implementing component that communicates with the API implementing component through the API over a network. It should be understood that an API implementing component may also act as an API calling component i.e. it may make API calls to an API exposed by a different API implementing component and an API calling component may also act as an API implementing component by implementing an API that is exposed to a different API calling component.

The API may allow multiple API calling components written in different programming languages to communicate with the API implementing component thus the API may include features for translating calls and returns between the API implementing component and the API calling component however the API may be implemented in terms of a specific programming language. An API calling component can in one embedment call APIs from different providers such as a set of APIs from an OS provider and another set of APIs from a plug in provider and another set of APIs from another provider e.g. the provider of a software library or creator of the another set of APIs.

It will be appreciated that the API implementing component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling component . It should be understood that the API calling component may be on the same system as the API implementing component or may be located remotely and accesses the API implementing component using the API over a network. While illustrates a single API calling component interacting with the API it should be understood that other API calling components which may be written in different languages or the same language than the API calling component may use the API .

The API implementing component the API and the API calling component may be stored in a machine readable non transitory storage medium which includes any mechanism for storing information in a tangible form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc. and can be a local storage medium or a storage medium on a remote device that is coupled to a client device by one or more networks.

In Software Stack an exemplary embodiment applications can make calls to Services or using several Service APIs and to Operating System OS using several OS APIs. Services and can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

Reference in the specification to one embodiment or an embodiment means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase in one embodiment in various places in the specification are not necessarily all referring to the same embodiment.

In the foregoing specification the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are accordingly to be regarded in an illustrative sense rather than a restrictive sense.

In the foregoing specification the invention has been described with reference to specific embodiments thereof. It will however be evident that various modifications and changes can be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

