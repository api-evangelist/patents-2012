---

title: Hand-held video game platform emulation
abstract: A software emulator for emulating a handheld video game platform such as GAME BOY®, GAME BOY COLOR® and/or GAME BOY ADVANCE® on a low-capability target platform (e.g., a seat-back display for airline or train use, a personal digital assistant, a cell phone) uses a number of features and optimizations to provide high quality graphics and sound that nearly duplicates the game playing experience on the native platform. Some exemplary features include use of bit BLITing, graphics character reformatting, modeling of a native platform liquid crystal display controller using a sequential state machine, and selective skipping of frame display updates if the game play falls behind what would occur on the native platform.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08795090&OS=08795090&RS=08795090
owner: Nintendo Co., Ltd.
number: 08795090
owner_city: Kyoto
owner_country: JP
publication_date: 20120404
---
This application is a Continuation application of U.S. application Ser. No. 10 690 818 filed Oct. 23 2003 which is a divisional application of application Ser. No. 09 723 322 filed Nov. 28 20000 now U.S. Pat. No. 6 672 963. This application is related to commonly assigned application Ser. No. 09 722 410 filed Nov. 28 2000 entitled PORTABLE VIDEO GAME SYSTEM now U.S. Pat. No. 7 445 551 which is a continuation in part of application Ser. No. 09 627 440 filed Jul. 28 2000 now abandoned. This application is also related to commonly assigned application Ser. No. 09 321 201 of Okada et al filed May 27 1999 entitled Portable Color Display Game Machine and Storage Medium for The Same now U.S. Pat. No. 6 315 669. Priority is also claimed from provisional application No. 60 233 622 filed Sep. 18 2000 entitled Method and Apparatus for Emulating a Portable Game Machine. Each of these related applications is incorporated herein by reference.

This invention relates to systems methods techniques data structures and other features for running software applications including but not limited to video games on platforms different from the ones the software is intended or designed to run on.

Nintendo s GAME BOY hand held video game platforms have been extraordinarily successful. Nintendo released the first GAME BOY in the late 1980s. Since then this product and its successors GAME BOY COLOR and GAME BOY ADVANCE have captured the imaginations of millions of video game players throughout the world.

A wide number of different software applications including but not limited to video games have been designed to run on these platforms. People throughout the world enjoy these applications every day. One can see them being used on subways at sports arenas after school and in a number of other contexts. See .

Nintendo s GAME BOY GAME BOY COLOR and GAME BOY ADVANCE are examples of platforms having specialized hardware that is optimized for low cost excellent performance and good graphics. These devices are not really general purpose computers rather they are special purpose devices with specialized capabilities particularly adapted to video game play. These special capabilities provide low cost and exciting video game play action with good graphics and sound.

While GAME BOY platforms are inexpensive and have long battery life there may be situations in which it would be desirable to play or use applications developed for GAME BOY on other platforms. For example an airline train or other vehicle passenger might want to play video games during a long journey. As shown in airlines are installing seat back computer displays into the backs of airline seats. Such seat back displays may provide a low cost personal computer including a processor random access memory liquid crystal display and input device s . Similar displays could be installed in other vehicles e.g. trains ships vans cars etc. or in other contexts e.g. at walk up kiosks within hotel rooms etc. . It would be desirable under certain circumstances to allow users to execute all sorts of different applications including GAME BOY video games and other applications using the general purpose computer capabilities of such seat back or similar display devices.

Personal computers have also proliferated throughout the world and are now available at relatively low cost. A trend has shifted some entertainment from the home television set to the home personal computer where children and adults can view interesting web pages and play downloaded video games and other applications. In some circumstances it may be desirable to allow users to play GAME BOY video games on their home personal computers see .

A wide variety of so called personal digital assistants PDA s have become available in recent years. Such devices now comprise an entire miniature computer within a package small enough to fit into your pocket. Mobile cellular telephones are also becoming increasingly computationally intensive and have better displays so they can access the World Wide Web and perform a variety of downloaded applications. In some circumstances it may be desirable to enable people to play GAME BOY video games and other GAME BOY applications on a personal digital assistant cellular telephone or other such device see .

The special purpose sound and graphics circuitry provided by the GAME BOY platforms is not generally found in the various other platforms shown in C and D. Providing these missing capabilities is one of the challenges to running a GAME BOY video game or other GAME BOY application on these other target platforms.

Another challenge relates to instruction set compatibility. Nintendo s GAME BOY is based on an older relatively inexpensive microprocessor the Zilog Z80 that is no longer being used in most modern general purpose computer systems such as personal computers seat back displays and personal digital assistants. The Z80 instruction set the language in which all GAME BOY games and other GAME BOY applications are written in is not directly understood by the more modern Intel microprocessors e.g. the 8086 80286 80386 Pentium and other processors in the Intel family that are now widely used and found in most personal computers seat back displays personal digital assistants and the like. While it is possible to port certain GAME BOY games or other applications to different microprocessor families e.g. by cross compiling the source code to a different target microprocessor there may be an advantage in certain contexts to being able to play or execute the same binary images stored in GAME BOY cartridges on target platforms other than GAME BOY .

One way to provide a cross platform capability is to provide a GAME BOY software emulator on the target platform. Generally a software emulator is a computer program that executes on a desired target platform e.g. a seat back display device a personal computer or a personal digital assistant shown in and uses software to supply native platform capabilities that are missing from the target platform. For example a software emulator may perform some or all of GAME BOY s specialized graphics functions in software and may interface with whatever graphics resources are available on the target platform to display resulting images. A software emulator may translate or interpret Z80 instructions so the microprocessor of the target platform can perform the functions that GAME BOY would perform if presented with the same instructions. The software emulator may include software code that emulates hardware capabilities within the GAME BOY circuitry e.g. audio and or graphics processing and or translate associated GAME BOY application requests into requests that can be handled by the hardware resources available on the target platform. For example the target platform may include a graphics adapter and associated display that is incompatible with GAME BOY s graphics hardware but which can perform some of the basic graphics functions required to display GAME BOY graphics on a display.

A number of GAME BOY emulators have been written for a variety of different platforms ranging from personal digital assistants to personal computers. However further improvements are possible and desirable.

One area of needed improvement relates to obtaining acceptable speed performance and high quality sound and graphics on a low capability platform. A low capability platform e.g. a seat back display or a personal digital assistant may not have enough processing power to readily provide acceptable speed performance. Unless the software emulator is carefully designed and carefully optimized it will not be able to maintain real time speed performance when running on a slower or less highly capable processor. Slow downs in game performance are generally unacceptable if the average user can notice them since they immediately affect and degrade the fun and excitement of the game playing experience.

Performance problems are exacerbated by the penchant of some video game developers to squeeze the last bit of performance out of the GAME BOY platform. Performance tricks and optimizations within a GAME BOY application may place additional demands on any emulator running the application. Some prior art emulators provide acceptable results when running certain games but unacceptable results or do not work at all for other games. An ideal emulator provides acceptable results across a wide range of different games and other applications such that the emulator can run virtually any game or other application developed for the original platform.

Another challenge to designing a good software emulator relates to maintaining excellent image and sound quality. Ideally the software emulator running on the target platform should be able to produce graphic displays that are at least the same quality as those that would be seen on the native platform. Additionally the color rendition and other aspects of the image should be nearly if not exactly the same. Sounds e.g. music and speech from the emulator should have at least the same quality as would be heard on the original platform. All of these capabilities should be relatively closely matched even on platforms with radically different sound and graphics hardware capabilities.

One prior attempt to develop a video game platform emulator is disclosed in U.S. Pat. No. 6 115 054 to Giles. That patent describes a general purpose computer based video game platform software emulator including an execution skipping feature that evaluates the ability of the general purpose computer to generate video frames fully synchronized with the target platform computer system. If the evaluation determines that the emulator is falling behind the target system the emulator executes only a first subset of the graphics commands while skipping execution of a second subset of graphics commands so as to partially render the frame. For example the patent discloses fully executing certain graphics commands while partially executing others e.g. clipped drawing commands to provide a partial rendering of the frame. One disadvantage to the approach described in the Giles patent is that partial rendering of a frame can lead to uncertain imaging results that will degrade the quality of the image being produced by the emulator.

The present invention solves these and other problems by providing a unique software emulator capable of providing acceptable speed performance and good image and sound quality on even a low capability target platform such as a seat back display for example.

The preferred embodiment software emulator provided by this invention maintains high quality graphics and sound in real time across a wide variety of video games and other applications and nearly duplicates the graphics and sound that would be experienced by a user of the GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE platform running the same game or other application. The preferred embodiment emulator achieves this through a unique combination of features and optimizations including for example 

Emulator which executes on the target platform microprocessor and uses the resources of the target platform receives the binary image of a game or other application file stored on disk or other file system block . Emulator parses and interprets this binary image block . Emulator also receives user inputs from handheld controller via target platform keypad interface block . In response to these inputs emulator generates sound commands for the audio adapter block and generates graphics commands for application to the video graphics adapter block creating sounds on audio transducer and images on display . These sounds and images nearly duplicate what one would hear and see if running file on a native GAME BOY platform.

In the example embodiment the game file binary image can be a video game or any other application that can run on a GAME BOY COLOR GAME BOY or GAME BOY ADVANCE . Binary image includes binary audio commands and binary graphics commands compatible with a GAME BOY native platform but which are not compatible with the application programming interface features of audio interface and VGA adapter . Emulator interprets those graphics commands and sound commands and generates a corresponding sequence of graphics and sound commands that are understandable by and compatible with the audio and sound capabilities of the target platform.

In the example embodiment emulator includes a virtual microprocessor core . Virtual microprocessor core interprets instructions within the binary game file that would be executed by the actual GAME BOY native platform Z80 microprocessor block and provides a corresponding sequence of microprocessor instructions for execution by the target platform microprocessor which in the general case is different from the microprocessor found in GAME BOY and does not understand and is incompatible with the native platform microprocessor instruction set .

Virtual microprocessor core receives inputs from a keypad emulation block block . Block in turn receives interactive inputs from the user via target platform keypad interface . Keypad emulator block emulates the GAME BOY control input circuitry and associated functionality and translates inputs received from the target platform keypad interface which may have a different set of control inputs and configurations from that found in a GAME BOY native platform.

Virtual microprocessor core also communicates with sound emulation block and graphics emulation block . Sound emulation block emulates or simulates the sound generation circuitry within a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE to provide a set of sound commands for application to the target platform sound adapter block . Graphics emulation block emulates or simulates the hardware acceleration and other graphics circuitry found within a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE platform to provide a set of graphics commands for application to a target platform graphics adapter block .

In the example embodiment virtual microprocessor core also includes a virtual liquid crystal display controller used for the purpose of maintaining timing. Events within the GAME BOY GAME BOY COLOR and GAME BOY ADVANCE native platforms are generally driven by activities relating to updating the liquid crystal display every one sixtieth of a second. The example embodiment of emulator emulates the native platform liquid crystal display controller block in order to synchronize events occurring within the emulator with emulated events that would occur within a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE native platform. As will be described below in detail the virtual liquid crystal display controller of the example embodiment does not actually perform any display functions but rather is used to tell emulator what would be going on in terms of display timing on a real GAME BOY GAME BOY COLOR or GAME BOY ADVANCE . A virtual liquid crystal display controller allows emulator to synchronize its pace with what the pace of a real GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE native platform would be running the same application file . Virtual liquid crystal display controller may be viewed as a software implemented model of the event timing sequence of a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE native platform.

Emulator also includes an emulated random access memory an emulated read only memory and an emulated memory bank controller MBC . Emulated random access memory and emulated read only memory provide memory storage locations within the read write random access memory of the target platform. The emulated random access memory emulates or simulates the random access memory of a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE and the emulated read only memory emulates or simulates the read only memory within the game cartridge of a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE block . The emulated memory bank controller emulates or simulates the hardware memory bank controller bank switching circuitry found within certain a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE game cartridges.

The example functional modules shown in provide various functions that can be called by name from other parts of the emulator code. Each of these functional modules may be implemented with a C or C and or assembler function or other routine in one example implementation. In this particular implementation the entire executable file the aggregate of all modules is designed as a DOS protected mode application that runs with a minimum number of drivers to maximize efficiency.

The run game functional module loads the game file into emulated ROM and then calls the emulate functional module block . The run game module may also by itself or in conjunction with an additional function if desired initialize each of the hardware handler modules within the emulator . Emulate functional module is the main emulation loop and is executed until the user quits the game or other application.

In the example embodiment the draw functional modules perform the task of drawing graphics objects generated by emulator by sending graphics commands to the graphics adapter block . For example the draw COB functional module may draw each of 144 color background lines of the COLOR GAME BOY on the screen and may also by itself or in conjunction with another module draw the moving objects after the background has been drawn. The draw DMG functional module performs a similar drawing task for original GAME BOY games and other applications and the draw AGB functional module performs similar drawing tasks for GAME BOY ADVANCE games and other applications. Example emulator is capable of emulating any all of a number of different platforms across the Nintendo GAME BOY product line.

In this example the ROM check ROM REG functional module is used to check and or display registration data within the game file . This functional module is used to ensure for example proper authorization on the part of the user before game play is allowed. In another embodiment the ROM registration module does not do anything regarding user authorization but just reads the ROM registration data in the game file sets emulator variables and optionally displays the registration data on the screen. A game file validation function may be included in the ROM registration module to validate the game file not the user.

The video functional module is used in the example to transfer character graphics data. The functions in the video module perform character bitmap translation for any type of write to the character RAM area whether it is a direct write from the CPU or a DMA transfer. Functions in the video module also handle the RAM bank switching register for character data areas control and status registers for the LCD controller and palette registers for both COB and DMG modes. When a game file instruction calls for a direct memory access data transfer of character information into the GAME BOY character RAM space video functional module performs a character bit map translation into a portion of emulated RAM to prepare graphics characters for display. The video functional module may by itself or in conjunction with another functional module place appropriate function pointers into appropriate input output read write tables for all of the register handling functions that should be performed.

In the example embodiment the VGA functional module is used to set the appropriate video mode of the target platform graphics adapter . In addition this VGA functional module may be responsible for transferring full screens of graphics data to VGA graphics adapter under certain circumstances e.g. if a hardware assisted bit BLIT operation is not available on the target platform .

The buttons functional module is responsible for getting the keypad data from keypad interface and writing this data into a set of input interface registers that emulate actual hardware interface registers within GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE .

The sound functional module in the example embodiment generates and writes appropriate sound information to the target platform sound adapter by translating writes to the virtual sound registers to appropriate sound information for the target platform sound adapter block . The sound functional module by itself or in conjunction with another functional module may also be used to put function pointers into appropriate input output read write tables for all of the register handling functions performed by the sound functional module.

In this example module the no write functional module protects the emulated ROM from being written to thus making sure this memory segment is emulated as a read only memory as opposed to a read write memory during game play . The no write functional module by itself or in conjunction with an additional functional module may place appropriate function pointers into the appropriate input output read write tables for all of the register handling functions in the no write functional module.

The port mode functional module emulates a CPU timer and provides a keypad handler. It has functions that handle the keypad the timers and the CPU speed control e.g. to provide a CPU speed change operation since COLOR GAME BOY operates twice as fast as GAME BOY and GAME BOY ADVANCE operates still faster . The port mode functional module may also set appropriate function pointers or call an additional function module s to perform this task. The main function of the CPU timer is to generate CPU interrupts at specified intervals. Registers to specify this interval are handled in the port mode module. There are a couple of registers that provide real time views of a free running counter. These registers can be emulated by returning a random number. This is only a partial emulation a random number is not a real time value . However the most common use of these registers by games is to generate a random number by looking at a fast clock at an arbitrary point in time. It is therefore possible to completely satisfy such games by providing a random number as opposed to a real time clock indication. A more accurate emulation can be provided if a game requires the real time view of the counter actually provided in the native hardware.

The CGB RAM functional module emulates the COLOR GAME BOY RAM to provide additional emulated RAM . DMA functional module performs direct memory access transfers between the various emulated storage resources within emulator thereby emulating the GAME BOY native platform DMA controller. The MBC functional module emulates the native platform memory bank controller to provide emulated MBC .

The SIO functional module emulates a serial input output port available on a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE platform e.g. to provide a game link operation whereby plural platforms can exchange data over a cable or other communications interface . The ADDPTRS functional module performs the task of registering various handlers for operation in particular it may contain a single function that all hardware support modules call to register their memory function pointers in an I O handler table and accomplishes this by registering pointers for reading and writing to I O addresses . The timer functional module implements the virtual liquid crystal display controller by maintaining an emulated state machine that keeps track of the state and associated timing information of a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE platform. Timer module thus allows the target platform which may operate at a completely different speed from the original platform to maintain a sense of the event timing as those events would occur on the native platform ensuring that emulator provides event timings that are consistent with the native platform. Without such timing information the speed of the application s graphics and or sound might be different on the emulator as compared to on the original platform resulting in an unsatisfying game play experience.

The main RAM array is in one example a generic 64K memory array used for any non paged address space. A CGB buffer is used to emulate the internal RAM banks for COLOR GAME BOY . MBC RAM is used to emulate the random access memory that may be provided within certain game cartridges.

The object enable array may include a flag for each display line indicating that drawing of moving objects was enabled for that line flags may be sent queried as the background is drawn .

Page table may comprise a 64K table of pointers to the base pointers that handle each address and may be used to reestablish the program counter on jumps calls returns etc.

Page table may be used for making pointer adjustments to both the program counter and the stack pointer. In another embodiment a separate stack table comprising for example a 64K table can be used in a similar manner to page table but with a coverage of each base pointer extending one address higher and used to reestablish the base of the stack pointer when it is manually changed.

The ROM pages may be used to emulate the cartridge read only memory arrays in the example embodiment this ROM array is twice as big as the actual ROM pages since the bottom half is always duplicated .

The raw character data array is used to store raw character data and the further character data army is used to store corresponding bit map ized character data. A translator is used to provide precomputed translation data for translating the raw character data into the bit mapped character data . Different sets of pointers are used for each page and addressing mode in this example. The background data buffer is used to store background data in pages 0 and 1.

The off screen buffer which may comprise an entry of 192 160 2 may be used to compose images off screen. This buffer may not be needed when a bit BLIT capability is available within the hardware of the target platform.

Color background palettes comprise two sets of eight palettes one for high priority background pixels and the other for low priority background pixels. Color object palette provides object palette data to emulate the COLOR GAME BOY object color palette one set of eight palettes may be provided . GAME BOY color palettes emulate the monochrome GAME BOY palettes with background palette providing four background palette data entries and object palettes comprising object palette data for object 0 and object 1 four entries per palette . The native COLOR GAME BOY platform has selectable palettes for colorizing monochrome GAME BOY games and this capability may also be emulated by for example changing the color entries within palettes . In another embodiment these palettes may be preassigned to provide certain default colors e.g. red objects on a green background .

Jump table is used to facilitate the parsing and execution of target instructions by emulator as is explained below.

In the example embodiment the lower 16K in each allocated ROM page . . . is duplicated to facilitate page selection and reduce page swapping. A ROM page selection pointer is used to select the current ROM page and a ROM page count register specifies the number of ROM pages loaded for the current game or other application. As mentioned above the no write functional module is used to protect the ROM space so that inadvertent write instructions within the application and or emulator do not succeed in overwriting emulated read only memory .

As mentioned above the run game routine is responsible for loading the game application file into emulated ROM . Part of this loading operation loads particular compatibility information see and registration data see into the emulated ROM . The compatibility information is used to specify whether an application is compatible or incompatible with certain native platforms e.g. compatibility with the COLOR GAME BOY mode of emulator or whether it can run exclusively on the COLOR GAME BOY mode . This compatibility information is present in a normal binary game file to provide instructions to the COLOR GAME BOY platform emulator reads and takes advantage of this information in determining its own emulation mode. The registration data shown in is used in the example embodiment to ensure that game file is authorized and authentic and emulator performs checks similar to those performed by the GAME BOY COLOR GAME BOY and GAME BOY ADVANCE native platforms as well as possibly other security checks such as digital signatures decryption digital certificates etc. to ensure the user has proper authorization.

In the example embodiment emulator uses an internal state machine to keep track of and emulate the states of an actual GAME BOY COLOR GAME BOY or GAME BOY ADVANCE platform during emulation operation. The emulator could execute the instructions within game file without keeping track of corresponding events within the native platform but this would lead to loss of real time synchronization. In video game play the pacing of the audio and video presentation is very important to the game play experience. Playing a game too fast or too slow will tend to destroy the fun oldie game It is therefore desirable to emulate a game playing experience that is close to or nearly the same as the game playing experience one would have when running the application on the original native platform.

Emulator accomplishes this result by maintaining liquid crystal display controller providing a sequential state machine that is synchronized with event states that would occur on the original native platform. Emulator synchronizes its operation to the state transitions within this internal state machine to maintain real time synchronization of game play.

In the example embodiment the sequential progression through all four states comprises a frame that results in the display of a new image on display . In the native platform one frame comprises a vertical blanking state and various repetitions of the hblank OAM search and OAM transfer states dependent on the number of lines e.g. 144 within a frame. Because the native platform hardware is driven by line scanning operation of a liquid crystal display so too is preferred embodiment emulator driven by an emulated state machine that models the same line scanning and other time intervals to ensure proper game timing as the developers of the game intended it and as a user would see and experience a game on the native platform.

Within each line there is an hblank interval and associated state as well as an OAM search state during which a native platform would search its object attribute memory for objects to be displayed on the next line and an OAM transfer state during which a native platform transfers object character information into a line buffer for display . The table of shows example cycle parameters for the virtual state machine.

The preferred embodiment emulator emulates a virtual state machine by maintaining the various registers shown in . The registers shown in generally comprise various registers used to keep track of the virtual state and operation of a liquid crystal display controller that is being emulated. In this example emulator emulates a liquid crystal display controller using the following registers 

The timing registers are used to maintain the various parameters pertaining to the timing parameters associated with the virtual state machine. These registers include 

If the next state is Vertical blanking yes exit to decision block then emulator determines whether it is running behind e.g. by determining the amount of time until the next timer interrupt is going to occur . Preferred embodiment emulator tries to maintain the sixty frames per second screen update rate of the native platform. However in one particular embodiment it is not always possible e.g. depending upon the particular game of other application being executed to maintain a sixty frame per second rate on a slow target platform. In that example embodiment emulator dynamically scales back to a slower thirty frame per second rate by setting the do frame flag yes exit to decision block block which will have the result of entirely skipping the drawing of the next frame. In that example embodiment this frame skipping operation does not skip execution of any instruction from game file . All such instructions are executed by virtual microprocessor core in order to continually maintain and update appropriate state information. Furthermore this frame skipping operation does not have the result in the embodiment of partially rendering the frame being skipped. For example there is no selective execution of certain graphics commands in a command buffer depending on whether or not the emulator is falling behind. In that example embodiment of emulator the only operations that are skipped are internal emulator operations of transferring graphic information to the VGA graphics adapter and updating the display resulting in the frame either being rendered or not being rendered. Since the GAME BOY platforms operate to render an entire new frame each 1 60of a second from scratch there is no need to partially render a frame for use in generating a next frame and such a partial rendering would tend only to degrade speed performance and generate uncertain image results. A maximum of every other frame may be skipped in the example embodiment since using a frame update rate of less than 1 30of a second would noticeably degrade image quality.

In a further embodiment the dynamic scaling feature is omitted from the emulator to allow better emulation of transparency based images. It turns out there are some games that achieve transparency effects by enabling and disabling the visibility of entities on the screen at a 30 fps rate on for one frame off the next . Allowing the emulator to skip as needed between 30 fps and 60 fps causes undesirable flickering in such games. In this alternate configuration the emulator may draw frames at either a fixed 30 fps skip drawing of every other frame or a fixed 45 fps skip drawing of every third frame . Running at 30 fps causes the object to either always be visible or never be visible depending on which phase you hit on. This is less than perfect emulation but actually is the best solution for at least some games. For example the 45 fps rate is currently used in certain games to make characters blink when they are hit by an enemy. Running at 45 fps which provides acceptable game speed in certain games but not many other CGB games allows you to alternate between visible and invisible and provides a good flickering character. If the emulator could draw at 60 fps none of these problems would exist but slow target hardware does not permit this. Luckily 30 fps provides good game play for most games. It is possible to modify a few bytes the game code which the emulator does not use in the ROM registration area of the game file to tell the emulator what frame rate to use. There may be other game specific emulation parameters put into the game file in the future.

In the example embodiment the virtual microprocessor core interprets the binary instruction formats of game file block . As mentioned above the game file binary instruction formats in the example embodiment are compiled for execution by a Z80 microprocessor of the native platform whereas the target platform on which emulator runs may be any microprocessor e.g. an Intel 8086 family microprocessor . In the example embodiment the virtual microprocessor core may include a binary instruction format parser implemented as a jump table e.g. C or C case statement that parses the binary op code portion of the incoming instruction and jumps to appropriate code that performs one or a series of steps that will cause emulator to emulate the operation of that instruction. shows an example jump table flow based on the jump table which may be implemented as inline code if desired .

Those skilled in the art will understand that different native instructions can be emulated in different ways depending upon the particular instruction. shows an example flow diagram for emulation of an example no operation NOP instruction. In this example an op code of 00 parsed by the process results in transferring control to the process for emulating the no operation instruction. On the native platform a no operation instruction results in nothing happening wait for a CPU cycle. Within emulator in contrast certain tasks are performed in response to such a no operation instruction. For example an emulated program counter which is different from the target platform program counter and is used to emulate the program counter of the native platform is incremented block and the cycle counter is decremented see block . As shown in if the cycle counter is not greater than zero a timer function is called to perform the steps of blocks shown in . If the cycle counter is still greater than zero then control returns to the operation to parse the next op code block .

Some games and other applications make extensive use of no operation loops to maintain game timing. Somewhat surprisingly such no operation loops can cause emulator to run very slowly. To avoid this particular issue it is possible for emulator to include a dynamic code analyzer that looks ahead to the next few instructions surrounding a no op instruction to determine whether the game file includes a no op loop. If emulator determines that such a loop is present then the emulator may intelligently use events other than a wait loop setting a timer and waiting for it to expire or relying on the virtual liquid crystal display controller as alternate means for providing the requisite wait loop timing. This optimization can result in increased efficiency by preventing the emulator from becoming bogged down with no operation wait loops. In other embodiments no NOP reduction analysis is implemented and the only such technique implemented is to detect whether a loop was waiting for a transition of the LCD machine and automatically force the transition. The problem is that such a technique may work for some games but could cause some games to malfunction.

Also as shown in and alluded to above the emulated random access memory and the emulated read only memory may include multiple copies of the same information within the target platform random access memory in order to provide more efficient paging and corresponding reduction in processing time.

Different functions can be called for reading from and writing to the same address in this example arrangement and different pointers may be used reading from and writing to the same address. Similarly a read operation with respect to a particular native address may cause a read from an active PTR memory mapped value whereas a write operation to the same address can invoke a handler function or vice versa. The flexibility provided by this arrangement simplifies the architecture of emulator while providing an efficient way to execute instructions from game file .

In the example embodiment the program counter or program pointer may include a current base pointer for the program counter as well as an offset portion. Similarly a stack pointer may include a base pointer for an emulated stack pointer to which may be added an offset e.g. in a target platform register . Virtual microprocessor core may further include a set of emulated native platform flags including 

In the example embodiment emulated flags are not in the same bit positions as the native platform flags but rather they are in positions used by the target platform processor. This allows emulator to pass virtual flags to the target platform processor before performing operations that effect the flags. The target platform flags are retrieved into the virtual flag data structure after the operation is performed.

In the example embodiment the various native platform general purpose registers are defined in three separate data structures as bytes block words block and long words block . The three structures are bundled into a union so that emulator can access a particular register as a byte a word or a long word as needed. In the example embodiment the program pointer is not included because it is maintained as a C character pointer for maximum efficiency. The program counter or pointer can be declared as a local variable in the main emulation function and the compiler preferably implements the program pointer as a register in the target platform CPU as described above.

Some additional optimizations are possible when accessing the emulated registers shown in . For example the HL register within the native platform CPU is often used as an index register. As shows it is possible for virtual microprocessor core to look ahead by determining whether the indexed address is for a special hardware location in response to a write to the FIL register decision block and to access page table immediately in response to such an indexed address so that the corresponding memory pointer and or function are available when a further instruction comes along that uses the HL register contents for an indexed operation block . This optimization can save processing time. Indirect accesses via HL or any other 16 bit register BC or DE are all handled by referring to the I O read write handler tables in the example embodiment. One look ahead technique the preferred embodiment emulator uses is the prefetch queue implemented by always fetching four bytes into a 32 bit target platform register each time. The low order byte is the opcode the emulator is after but many opcodes require one or two subsequent bytes as data or extended opcode. By having four bytes in a register any opcode handlers that need subsequent bytes already have them in a CPU register.

Referring once again to the virtual microprocessor core further includes a set of interrupt vectors and an interrupt master enable flag that are used to emulate the interrupt structure within a GAME BOY GAME BOY COLOR and or GAME BOY ADVANCE native platform. This interrupt vector when enabled by the interrupt master enable flag can be read to determine what portion of emulator caused a particular interrupt e.g. vblank the liquid crystal display controller a timer button depression or serial input output . Emulator provides an emulated interrupt controller that emulates the actual native platform interrupt structure in controller to maintain compatibility and event driven functionality of game file .

As shown in preferred embodiment emulator provides keypad emulation in the example embodiment through the use of certain data registers flags including 

In one example embodiment the buttons direction register and the buttons buttons register encode various button parameters in certain bit positions as shown in . As mentioned above the buttons functional module shown in may be used to retrieve inputs from keypad interface and load them into the data structures for reading by virtual microprocessor core . These data structures and associated functionality emulate the hardware control input controller of the native platform by duplicating the register interface of the native platform in software. Target platform controller device may be any of a variety of different configurations including for example an SNES handheld controller a keypad or any other input device capable of interacting with a user. A parallel port register or indicator may be used to define the type of keypad interface e.g. SNES controller adapter or keyboard that will be used for the controller input on the target platform.

As shown in preferred embodiment emulator may include one or more game specific emulation options that go into effect for particular games or other applications block . As one example an options data structure may specify particular functions and or features that could be activated selectively depending upon the particular application or game being supplied by game file . Such game specific emulation options can improve efficiency by tailoring the operation of emulator for particular applications or games on a dynamic as needed basis. While in some embodiments it would be best to avoid using game specific options in other examples it might be desirable to use such game specific options to increase efficiency and or functionality.

As shown in one game specific option might be using a single CGB RAM memory pointer. Another game specific option is the 30 45 fps frame rate option described previously. Other game specific options are possible.

A rumble pack flag is used in the example embodiment to indicate whether the loaded game file supports the rumble pack feature of certain native platform games.

The TSR interrupt register in the example embodiment specifies the number of the DOS interrupt used for host to emulator communication.

A DMA source register specifies a source address for emulated direct memory access operations and a DMA destination register specifies a destination address for emulated direct memory access operations. A memory base pointer specifies a base pointer for non paged memory .

Referring to a register file including for example various native platform registers emulated in software RAM locations is shown. Such registers include for example sound control registers NR10 NR52 a liquid crystal display controller register having the bit assignments shown and a status register STAT having the bit assignments shown.

In terms of sound emulation certain information written to the sound control registers may be straight forwardly translated and passed on to the target platform sound adapter using the particular API used by that sound adapter. Other sound generation commands are peculiar to the GAME BOY GAME BOY COLOR and GAME BOY ADVANCE native platforms and need to be emulated using sound producing functions. These sound producing functions take advantage as much as possible of the target platform sound generation capabilities but typically need to provide additional state information e.g. implementation of a sound generation state machine in order to ensure sound timing synchronization. Maintaining real time sound timing sound synchronization is especially important with voices which will sound unnatural if played back too fast or too slow. Unfortunately voice reproduction may be difficult to achieve since the strict CPU timing necessary to play back voice takes up too much time in itself and may not be possible to perform on a low resource target platform. Games that rely on voice playback for a satisfactory game play experience may have to be excluded. In the example embodiment the sound module translates writes to the virtual sound registers to appropriate sound information for the target platform sound adapter. If the sound library used does not provide for automatic termination of sounds after specified durations then the emulator may also be provided with the capability to terminate sounds at appropriate times.

As described above a graphics emulation portion of emulator in the example embodiment receives commands from the virtual microprocessor core and performs responsive graphics tasks. This graphics emulation functionality performed by block supplies capabilities normally supplied by the graphics acceleration hardware of the native platform.

One way to provide such graphics emulation would be to nearly exactly implement in software each of the hardware structures of the native platform s graphics circuitry. This is not necessarily the best approach however since it may be more efficient to perform certain graphics related tasks differently in software. shows an example of how the efficiency of preferred embodiment emulator is enhanced by handling character data differently than the way it is handled in the native platform.

In the example a pre computed translation table is used to translate raw character data within an array into a bit mapped ized character data format for storage into buffer . further illustrate this feature. The representation shows a portion of the raw character data buffer storing the character data bit planes as they are typically maintained by the native platform. Pre computed translator translates this raw character data representation into a differently ordered and organized bit mapped character data representation more like the format found in a conventional bit map .bmp file. This character data reorganization is useful in minimizing processing time required to output character graphics data to the video adapter . The bit mapped ized representation is more compatible with VGA and other commonly used video adapter hardware and the pre computation of translator allows this data reorganization to occur in a straight forward manner in advance of the time when the graphics data is sent to the graphics adapter .

The example embodiment emulator uses a hardware assisted bit BLIT operation to copy the contents of the screen size buffer into on screen buffer . Such a bit BLIT hardware assisted operator can increase transfer times without corresponding increases in overhead. If a bit BLIT operation is not available then a conventional direct memory access or other memory transfer can be used instead. In the example embodiment a STPC TARGET register is used to specify whether a bit BLIT engine of the target platform is available and can be used if one is not available then a conventional memory copy function can be used instead .

En the example embodiment the handling of color palettes can lead to efficiency problems. In the example native platforms graphics characters are represented in a color lookup table CLUT format i.e. the graphics characters themselves include a reduced number of bits that are used to look up a color value in a color palette for display . See . The example COLOR GAME BOY native platform can display 56 colors on the screen nominally eight palettes of four colors each for background and eight palettes of four colors each for object characters minus transparency . It would seem therefore that with only 56 simultaneous colors on the screen at any one time it would be possible to use a 320 200 8 bit VGA mode 13H which would provide 256 different colors on the screen at once much more than 56 colors . One possibility would be to simply add an offset into a VGA palette when using 8 bits of color. However certain game developers for the COLOR GAME BOY native platform change color palettes during horizontal blanking periods to achieve greater color variety on the screen. To emulate for these particular games it is necessary to provide more than 256 colors on the screen at a time. A mode such as the VESA standard 320 216 bits provides 65 000 different colors RGB 565 about twice as much as the 32 000 colors the GAME BOY COLOR is capable of displaying. Thus this video adapter mode is adequate for even applications that change their color palettes in the middle of a frame but using this mode doubles the amount of information that must be sent to the video memory per frame and costs processing time. Moreover it also requires emulator in the preferred embodiment to map color information 4 bits into 32 000 colors. The 16 bit color resolution makes it desirable for emulator to write 16 bit color palette information into the video adapter . This in turn necessitates a memory array of 16 bit numbers associated with the various color palettes. The color palettes see can be accessed on a character by character basis using pointers to apply color information to the bit map ized character data before the data is written to the display buffer .

While the invention has been described in connection with what is presently considered to be the most practical and preferred embodiment it is to be understood that the invention is not to be limited to the disclosed embodiment but on the contrary is intended to cover various modifications and equivalent arrangements included within the scope of the appended claims.

