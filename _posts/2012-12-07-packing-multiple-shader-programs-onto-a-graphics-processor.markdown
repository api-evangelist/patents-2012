---

title: Packing multiple shader programs onto a graphics processor
abstract: This disclosure describes techniques for packing multiple shader programs of a common shader program type onto a graphics processing unit (GPU). The techniques may include, for example, causing a plurality of shader programs of a common shader program type to be loaded into an on-chip shader program instruction memory of a graphics processor such that each shader program in the plurality of shader programs resides in the on-chip shader program instruction memory at a common point in time. In addition, various techniques for evicting shader programs from an on-chip shader program instruction memory are described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09530245&OS=09530245&RS=09530245
owner: QUALCOMM Incorporated
number: 09530245
owner_city: San Diego
owner_country: US
publication_date: 20121207
---
This application claims the benefit of U.S. Provisional Application No. 61 581 525 filed Dec. 29 2011 the entire content of which is incorporated herein by reference.

This disclosure relates to graphics processing systems and more particularly to graphics processing systems that utilize programmable shader units.

Computing devices often utilize a graphics processing unit GPU to accelerate the rendering of graphics data for display. Such computing devices may include e.g. computer workstations mobile phones embedded systems personal computers and video game consoles. GPUs typically execute a graphics processing pipeline that includes a plurality of processing stages which operate together to execute graphics processing commands. Traditionally GPUs included a fixed function graphics processing pipeline where each processing stage in the pipeline was implemented with fixed function hardware e.g. hardware that is hard wired to perform a certain set of specialized functions and not capable of executing a user downloadable program . More recently however graphics processing pipelines have shifted to a programmable architecture where one or more processing stages in the pipeline are programmable processing stages and implemented with one or more programmable shader units. Each of the programmable shader units may be configured to execute a shader program. A user application may specify the shader program to be executed by the programmable processing stages in a programmable graphics pipeline thereby providing a high degree of flexibility in the use of modern day GPUs.

This disclosure is directed to techniques for packing multiple shader programs of a common shader program type into a shader program instruction memory of a graphics processing unit GPU . The techniques of this disclosure may be implemented by a processing system that includes a GPU. In some examples the techniques of this disclosure may be implemented as part of a GPU device driver software program that executes on a host central processing unit CPU for the GPU.

In one example this disclosure describes a method that includes causing a plurality of shader programs of a common shader program type to be loaded into an on chip shader program instruction memory of a graphics processor such that each shader program in the plurality of shader programs resides in the on chip shader program instruction memory at a common point in time.

In another example this disclosure describes a device that includes a processor configured to cause a plurality of shader programs of a common shader program type to be loaded into an on chip shader program instruction memory of a graphics processor such that each shader program in the plurality of shader programs resides in the on chip shader program instruction memory at a common point in time.

In another example this disclosure describes an apparatus that includes means for loading a shader program into an on chip shader program instruction memory of a graphics processor. The apparatus further includes means for causing a plurality of shader programs of a common shader program type to be loaded into the on chip shader program instruction memory of the graphics processor such that each shader program in the plurality of shader programs resides in the on chip shader program instruction memory at a common point in time.

In another example this disclosure describes a computer readable storage medium storing instructions that when executed cause one or more processors to cause a plurality of shader programs of a common shader program type to be loaded into an on chip shader program instruction memory of a graphics processor such that each shader program in the plurality of shader programs resides in the on chip shader program instruction memory at a common point in time.

The details of one or more examples of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

This disclosure is directed to techniques for packing multiple shader programs of a common shader program type into a shader program instruction memory of a graphics processing unit GPU . The techniques of this disclosure may be implemented by a central processing unit CPU and or a GPU. In some examples the techniques of this disclosure may be implemented as part of a GPU device driver software program hereinafter referred to as a GPU driver that executes on a host CPU for the GPU.

In a typical graphics processing system when a GPU driver loads a shader program of a particular type e.g. a vertex shader type a pixel shader type etc. into a shader program instruction memory of the GPU the GPU driver overwrites the other shader programs of that same type that have been previously loaded into the memory. Thus in such systems only a single shader program of a particular type can reside in the shader program instruction memory at a given time. If a user application and or driver decides to execute a different shader program of the same type in such systems then the GPU driver loads the new shader program into the shader program instruction memory and overwrites the previously loaded shader program.

In some use cases it is desirable to switch the GPU rendering state and the shader program multiple times when rendering an image. For example certain types of applications may interleave Bit Block Image Transfer BLIT operations with rendering operations to display a graphical user interface GUI . The BLIT operations may use a shader program of a particular type that is different than the shader program used for the rendering operations. Reloading shader programs in such use cases can constitute a non negligible portion of the rendering time. However by loading multiple shader programs of the same type into the shader program instruction memory of the GPU according to the techniques of this disclosure the GPU may seamlessly switch between performing BLIT operations and rendering operations without needing to reload particular shader programs. In this manner the techniques of this disclosure may be used to improve the performance of a graphics processing system.

As illustrated in the example of computing device includes a user input interface a CPU a memory controller a system memory a graphics processing unit GPU a GPU cache a display interface a display and bus . User input interface CPU memory controller GPU and display interface may communicate with each other using bus . Bus may be any of a variety of bus structures such as a third generation bus e.g. a HyperTransport bus or an InfiniBand bus a second generation bus e.g. an Advanced Graphics Port bus a Peripheral Component Interconnect PCI Express bus or an Advanced eXentisible Interface AXI bus or another type of bus or device interconnect. It should be noted that the specific configuration of buses and communication interfaces between the different components shown in is merely exemplary and other configurations of computing devices and or other graphics processing systems with the same or different components may be used to implement the techniques of this disclosure.

CPU may comprise a general purpose or a special purpose processor that controls operation of computing device . A user may provide input to computing device to cause CPU to execute one or more software applications. The software applications that execute on CPU may include an operating system a word processor application an email application a spread sheet application a media player application a video game application a graphical user interface application or another program. The user may provide input to computing device via one or more input devices not shown such as a keyboard a mouse a microphone a touch pad or another input device that is coupled to computing device via user input interface .

The software applications that execute on CPU may include one or more graphics rendering instructions that instruct CPU to cause the rendering of graphics data to display . In some examples the software instructions may conform to a graphics application programming interface API such as e.g. an Open Graphics Library OpenGL API an Open Graphics Library Embedded Systems OpenGL ES API a Direct3D API an X3D API a DirectX API a RenderMan API a WebGL API or any other public or proprietary standard graphics API. In order to process the graphics rendering instructions CPU may issue one or more graphics rendering commands to GPU to cause GPU to perform some or all of the rendering of the graphics data. In some examples the graphics data to be rendered may include a list of graphics primitives e.g. points lines triangles quadralaterals triangle strips etc.

Memory controller facilitates the transfer of data going into and out of system memory . For example memory controller may receive memory read and write commands and service such commands with respect to memory system in order to provide memory services for the components in computing device . Memory controller is communicatively coupled to system memory . Although memory controller is illustrated in the example computing device of as being a processing module that is separate from both CPU and system memory in other examples some or all of the functionality of memory controller may be implemented on one or both of CPU and system memory .

System memory may store program modules and or instructions that are accessible for execution by CPU and or data for use by the programs executing on CPU . For example system memory may store user applications and graphics data associated with the applications. System memory may additionally store information for use by and or generated by other components of computing device . For example system memory may act as a device memory for GPU and may store data to be operated on by GPU as well as data resulting from operations performed by GPU . For example system memory may store any combination of texture buffers depth buffers stencil buffers vertex buffers frame buffers or the like. System memory may include one or more volatile or non volatile memories or storage devices such as for example random access memory RAM static RAM SRAM dynamic RAM DRAM read only memory ROM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

GPU may be configured to perform graphics operations to render one or more graphics primitives to display . Thus when one of the software applications executing on CPU requires graphics processing CPU may provide graphics commands and graphics data to GPU for rendering to display . The graphics data may include e.g. drawing commands state information primitive information texture information etc. GPU may in some instances be built with a highly parallel structure that provides more efficient processing of complex graphic related operations than CPU . For example GPU may include a plurality of processing elements that are configured to operate on multiple vertices or pixels in a parallel manner. The highly parallel nature of GPU may in some instances allow GPU to draw graphics images e.g. GUIs and two dimensional 2D and or three dimensional 3D graphics scenes onto display more quickly than drawing the scenes directly to display using CPU .

GPU may in some instances be integrated into a motherboard of computing device . In other instances GPU may be present on a graphics card that is installed in a port in the motherboard of computing device or may be otherwise incorporated within a peripheral device configured to interoperate with computing device . GPU may include one or more processors such as one or more microprocessors application specific integrated circuits ASICs field programmable gate arrays FPGAs digital signal processors DSPs or other equivalent integrated or discrete logic circuitry.

GPU may be directly coupled to GPU cache . Thus GPU may read data from and write data to GPU cache without necessarily using bus . In other words GPU may process data locally using a local storage instead of off chip memory. This allows GPU to operate in a more efficient manner by eliminating the need of GPU to read and write data via bus which may experience heavy bus traffic. In some instances however GPU may not include a separate cache but instead utilize system memory via bus . GPU cache may include one or more volatile or non volatile memories or storage devices such as e.g. random access memory RAM static RAM SRAM dynamic RAM DRAM erasable programmable ROM EPROM electrically erasable programmable ROM EEPROM Flash memory a magnetic data media or an optical storage media.

CPU and or GPU may store rendered image data in a frame buffer that is allocated within system memory . Display interface may retrieve the data from the frame buffer and configure display to display the image represented by the rendered image data. In some examples display interface may include a digital to analog converter DAC that is configured to convert the digital values retrieved from the frame buffer into an analog signal consumable by display . In other examples display interface may pass the digital values directly to display for processing. Display may include a monitor a television a projection device a liquid crystal display LCD a plasma display panel a light emitting diode LED array a cathode ray tube CRT display electronic paper a surface conduction electron emitted display SED a laser television display a nanocrystal display or another type of display unit. Display may be integrated within computing device . For instance display may be a screen of a mobile telephone handset. Alternatively display may be a stand alone device coupled to computer device via a wired or wireless communications link. For instance display may be a computer monitor or flat panel display connected to a personal computer via a cable or wireless link.

CPU may load shader programs onto GPU according to the shader program packing techniques described in this disclosure. For example CPU may cause a plurality of shader programs of a common shader program type to be loaded into a shader program instruction memory of GPU such that each shader program in the plurality of shader programs resides in the shader program instruction memory at a common point in time. As another example CPU may perform any of the shader program eviction techniques described in further detail later in this disclosure. Although the shader program packing techniques of this disclosure are described herein as being performed by CPU in other examples the shader program packing techniques may be performed by another component in computing device such as e.g. GPU .

Software application may include one or more instructions that cause graphics images to be displayed. In some examples the instructions may include a load shader program instruction that instructs GPU driver to load a shader program onto GPU . The shader program in some examples may be a compiled version of a program written in a high level shading language such as e.g. an OpenGL Shading Language GLSL a High Level Shading Language HLSL a C for Graphics Cg shading language etc. The compiled version of the shader program may be alternatively referred to as a shader binary. The shader program may in some examples be a machine code shader program that is configured to be executed by shader unit without further compilation preparation modification and or assembly.

Software application may issue the instructions to graphics API . Graphics API may be a runtime service that translates the instructions received from software application into a format that is consumable by GPU driver . GPU driver receives instructions from software application via graphics API and controls the operation of GPU to service the instructions. For example in response to receiving a load shader program instruction from software application GPU driver may issue one or more commands to GPU that cause the shader program specified in the instruction to be loaded onto GPU e.g. loaded into shader program instruction memory . Graphics driver may issue the commands to GPU via operating system e.g. via one or more system calls. Although CPU is illustrated in the example system of as executing a software application a graphics API a GPU driver and an operating system in other examples CPU may implement the techniques of this disclosure by executing more or less software modules that are the same or different and are organized in the same or a different configuration.

Shader unit may include one or more processing elements that are configured to execute one or more types of shader programs. The different types of shader programs may include e.g. vertex shader programs pixel shader programs geometry shader programs hull shader programs domain shader programs compute shader programs etc. In some examples shader unit may be configured to execute a single type of shader program. In such examples shader unit may be referred to by the type of shader program which shader unit is configured to execute. For example shader unit may be referred to as a vertex shader unit if shader unit is configured to execute vertex shader programs. Similarly shader unit may be referred to as a pixel shader unit a geometry shader unit a hull shader unit a domain shader unit or a compute shader unit depending upon which type of shader program shader unit is configured to execute.

In further examples shader unit may be a shader subsystem that includes multiple shader units individual ones of which may be configured to execute different types of shader programs. For example shader unit may include a vertex shader unit that is configured to execute vertex shader programs and a pixel shader unit that is configured to execute pixel shader programs. In additional examples shader unit may be a unified shader unit that is configured to execute multiple different types of shader programs e.g. vertex shader programs and pixel shader programs.

Shader program instruction memory may store one or more shader programs that are executable by shader unit . A shader program may include a set of instructions that are configured to control shader unit to perform one or more shader operations. A vertex shader program may control the execution of a vertex shader unit or a unified shader unit and include instructions that specify one or more per vertex operations. A pixel shader program may control the execution of a pixel shader unit or a unified shader unit and include instructions that specify one or more per pixel operations.

In some examples shader program instruction memory may be an on chip memory. For example GPU may be formed on located on and or disposed on a microchip an integrated circuit and or a die and shader program instruction memory may be formed on located on and or disposed on the same microchip integrated circuit and or die. That is in such examples a single microchip integrated circuit and or die may include both GPU and shader program instruction memory .

According to this disclosure CPU e.g. through GPU driver may be configured to load shader programs into shader program instruction memory such that at least two different shader programs of a common shader program type reside in shader program instruction memory at a given point in time. For example GPU driver may load two different vertex shader programs i.e. two shader programs of a vertex shader program type into shader program instruction memory such that both vertex shader programs reside in memory and are capable of being executed by shader unit at a given point in time. In a similar manner GPU driver may load two different pixel shader programs i.e. two shader programs of a pixel shader program type into shader program instruction memory such that both pixel shader programs reside in memory and are capable of being executed by shader unit at a given point in time. Similar techniques may be applied to any other type of shader program e.g. a geometry shader program a hull shader program a domain shader program and or a compute shader program.

The type of shader program may be indicative of the type of data upon which the shader program is configured to operate and or the type of operations performed by the shader program. For example a shader program of a vertex shader type may be configured to perform per vertex operations on vertices and a shader program of a pixel shader type may be configured to perform per pixel operations on pixels and or fragments. Similarly a shader program of a geometry shader program type may be configured to perform per primitive operations on primitives a shader program of a hull shader program type may be configured to perform per patch operations on patch control points a shader program of a domain shader program type may be configured to perform per texture coordinate operations on texture coordinates and control points and a shader program of a compute shader program type may be configured to perform per general purpose data operations on general purpose data.

In some examples shader program instruction memory may be an instruction memory from which shader unit fetches e.g. retrieves and or obtains instructions of a shader program for processing by shader unit during execution of the shader program by shader unit . For example shader unit may include a program counter register that stores a program counter value indicative of a memory location in shader program instruction memory from which to fetch one or more instructions for a shader program executing on shader unit and a control unit configured to fetch one or more instructions from shader program instruction memory during execution of a shader program based on a program counter value stored in the program counter register. The control unit may in some examples be configured to execute the shader program during a plurality of instruction cycles where during each instruction cycle one or more instructions of the shader program are processed by the shader unit. During at least two or more of the plurality of instruction cycles the control unit of shader unit may be configured to fetch one or more instructions from shader program instruction memory . In other words in such examples shader program instruction memory may act as an instruction store and or as an instruction cache for the execution of shader programs on shader unit during the execution of a shader program by shader unit .

As shown in GPU driver has loaded multiple shader programs into shader program instruction memory such that the resulting memory state stores two vertex shader programs A B and two pixel shader programs A B. Vertex shader program A may be different than vertex shader program B. Similarly pixel shader program A may be different than pixel shader program B. A first shader program may be said to be different than a second shader program for example when the first shader program includes a set of instructions that is different than those of the second shader program and or when the first shader program includes a set of instructions that implements a different algorithm than that which is implemented by the set of instructions included in the second shader program. Vertex shader programs A B may represent two shader programs of a common type. Similarly pixel shader programs A B may represent two shader programs of a common type.

Because shader program instruction memory in includes two different vertex shader programs A B and two different pixel shader programs A B GPU may be able to seamlessly switch between the execution of different shader programs of the same type without necessarily needing to reload such shader programs into shader program instruction memory every time a shader program execution switch occurs. By removing the need to reload shader programs between the execution of different shader programs of the same type the techniques of this disclosure may be able to improve the processing efficiency of a graphics processing system.

The operation of an example embodiment of GPU driver will now be described. GPU driver may receive a first load shader program instruction from software application executing on host CPU that instructs GPU driver to load a first shader program of a first shader program type onto GPU . In response to receiving the first load shader program instruction GPU driver may issue one or more commands to GPU e.g. via operating system that causes the first shader program to be loaded into shader program instruction memory . GPU driver may receive a second load shader program instruction from software application that instructs GPU driver to load a second shader program of the first shader program type onto GPU . In response to receiving the second load shader program instruction GPU driver may determine whether there is a sufficient amount of free space available in shader program instruction memory to store the second shader program. Free space may refer to e.g. one or more address ranges within shader program instruction memory that are not currently allocated to store a shader program. If there is a sufficient amount of free space available to store the second shader program then GPU driver may load the second shader program into the free space of shader program instruction memory .

On the other hand if there is not a sufficient amount of free space available then GPU driver may determine whether evicting one or more shader programs would free up enough memory space in memory such that there would be a sufficient amount of free space available to store the second shader program. If evicting one or more shader programs would free up enough memory space then GPU driver may evict one or more shader programs that were previously loaded into shader program instruction memory to generate the additional free space to store the second shader program. Otherwise if evicting one or more shader programs would not free up enough memory space then GPU driver may determine to overwrite all shader programs in memory .

Evicting a shader program from shader program instruction memory may include in some examples overwriting all or a portion of the shader program with a new shader program that is loaded into memory . In additional examples evicting the shader program from shader program instruction memory may involve removing the shader program from memory and or deallocating a portion of memory assigned to the shader program.

When loading shader programs into shader program instruction memory GPU driver may in some examples load the shader program into memory in such a way as to reduce fragmentation. For example GPU driver may determine which region of free space in shader program instruction memory is the smallest region into which the shader program will fit and load the shader program into such a region of memory .

GPU driver may store state information that is indicative of the state of shader program instruction memory in a local memory space e.g. system memory in . Using vertex shader programs as an example GPU driver may keep track of an amount of on chip memory available e.g. memory available in shader program instruction memory for vertex shader programs and which vertex shader programs are stored in the available memory. For example when a vertex shader program is loaded GPU driver may track the memory range used by the vertex shader program. In addition for each vertex shader program stored in shader program instruction memory GPU driver may track the last time that the shader program was accessed or executed and or the frequency in which the shader program was accessed or executed. This state information may be used by GPU driver to determine whether there is a sufficient amount of free space available when loading vertex shader programs and or to determine which vertex shader programs to evict when insufficient free space is available. Similar state information may also be stored for the other shader program types e.g. for pixel shader programs.

GPU driver may select which shader programs to evict from the shader program instruction memory according to various eviction techniques. According to a first eviction technique GPU driver may determine a least frequently used LFU shader program of a particular shader program type and evict the LFU shader program. If evicting the LFU shader program does not free up a sufficient amount of memory space then GPU driver may evict the next LFU shader program from the remaining shader programs and any subsequent LFU shader programs until there is a sufficient amount of free space for the new shader program to be loaded. According to a second eviction technique GPU driver may determine a least recently used LRU shader program of a particular shader program type and evict the LRU shader program. If evicting the LRU shader program does not free up a sufficient amount of memory space then GPU driver may evict the next LRU shader program from the remaining shader programs and any subsequent LRU shader programs until there is a sufficient amount of free space for the new shader program to be loaded.

According to a third eviction technique GPU driver may determine a set of N LFU shader programs for a particular shader program type where N is an integer 1. The set of N LFU shader programs may include shader programs that have frequencies of use that are within a threshold level of each other and are lower than those of the other shader programs not in the set of N LFU shader programs. For example in some examples two or more shader programs that are not frequently used may have frequencies of use that are approximately equal to each other e.g. within a threshold level of tolerance of each other. According to the third eviction technique GPU driver may determine the LRU shader program from the set of N LFU shader programs and evict the LRU shader program. GPU driver may determine if evicting the LRU shader program from the set of N LFU shader programs would free up a sufficient amount of memory space to allow the new shader program to be loaded into the memory. GPU driver may consider free space surrounding the LRU shader program e.g. free space due to fragmentation when determining whether evicting the LRU shader program would free up a sufficient amount of memory. If evicting the LRU shader program from the set of N LFU shader programs would free up a sufficient amount of memory space then GPU driver may evict the LRU shader program from memory and load the new shader program into memory . On the other hand if evicting the LRU shader program from the set of N LFU shader programs would not free up a sufficient amount of memory space then GPU driver may evict the next most LRU shader programs from the set of N LFU shader programs until enough free space has been generated for the new shader program to be loaded into the memory.

CPU of may be similar and or identical to CPU shown in . GPU of may be similar to GPU shown in except that shader unit is illustrated in as including processing elements and instruction cache and that shader program instruction memory is illustrated in as storing shader programs . Accordingly in the interest of brevity and to avoid redundancy the general operation and construction of CPU and GPU will not be described in further detail.

In the example system of system memory is an off chip memory. That is system memory may be formed on located on and or disposed on a microchip an integrated circuit and or a die that is different than the microchip integrated circuit and or die upon which GPU is formed located and or disposed. In contrast to system memory shader program instruction memory is an on chip memory in the example system of . In other words shader program instruction memory may be formed on located on and or disposed on the same microchip integrated circuit and or die as GPU .

Processing elements may be configured to execute one or more shader programs that are stored in shader program instruction memory . During execution of a shader program processing elements may fetch or retrieve one or more instructions of the shader program from shader program instruction memory . In some examples processing elements may use instruction cache to assist in retrieving the instructions from shader program instruction memory . If multiple shader programs of a common shader program type are loaded into shader program instruction memory then processing elements may be configured to switch from executing instructions associated with a first shader program stored in shader program instruction memory to executing instructions associated with a second shader program stored in shader program instruction memory without requiring shader program instruction memory to be reloaded. The first and second shader programs may be the same type of shader program e.g. vertex shader programs pixel shader programs geometry shader programs hull shader programs domain shader programs compute shader programs etc. .

Instruction cache is configured to retrieve one or more instructions of a shader program from shader program instruction memory and to store the one or more instructions in a cache within shader unit for subsequent execution by processing elements . Instruction cache may be configured to retrieve one or more instructions from shader program instruction memory in advance of the instruction cycle in which the one or more instructions are to be executed by shader unit . The retrieval of an instruction in advance of the instruction cycle in which the instruction is to be executed may be referred to herein as pre fetching instructions. The pre fetching of instructions by instruction cache may in some examples ensure that a sufficient number of instructions are ready to be executed by shader unit even if there is a delay in retrieving instructions from shader program instruction memory thereby preventing shader unit from being starved of instructions.

In some examples shader program instruction memory may be implemented as a fully addressable memory. That is in contrast to a cache where each storage slot in the cache may map to multiple different storage slots in an underlying memory each memory storage slot in shader program instruction memory may be uniquely addressable. In other words each memory storage slot in shader program instruction memory may be configured to store data associated with a single memory address.

A fully addressable memory may allow a CPU and or a graphics driver to configure how many shader programs are stored in shader program instruction memory and in what locations such shader programs are stored in shader program instruction memory . For example a fully addressable memory may allow CPU and or GPU driver to cause a plurality of shader programs of a common shader program type to be loaded into shader program instruction memory of GPU such that each shader program in the plurality of shader programs resides in shader program instruction memory at a common point in time in accordance with the techniques of this disclosure. As another example a fully addressable memory may allow CPU and or GPU driver to practice the shader program loading and eviction techniques described in this disclosure.

Shader programs which are stored in system memory may be any combination of source code versions of shader programs or compiled versions of shader programs. In some examples when CPU and or GPU driver loads one or more shader programs into shader program instruction memory CPU and or GPU driver may retrieve one or more shader programs from system memory and load the retrieved shader programs into shader program instruction memory . In other words in such examples system memory may serve as a staging area for shader programs that may be loaded onto GPU as part of one or more graphics processing applications and or computing applications.

Shader programs may be compiled shader programs and or machine code shader programs. The compiled shader programs and or the machine code shader programs may in some examples be configured to be executed by shader unit without further compilation preparation modification and or assembly. In other words in such examples each of shader programs is not merely a snippet or a portion of a shader program that is yet to be built but is instead a fully functional shader program.

In examples where one or more of shader programs are source code CPU and or GPU driver may compile the source code versions of the shader programs into compiled versions of the shader programs prior to loading the shader programs into shader program instruction memory . In examples where one or more of shader programs are compiled code or machine code the shader code for one or more shader programs loaded into shader program instruction memory may in some examples be identical to the shader code for the corresponding shader programs stored in system memory .

In some examples the capacity of shader program instruction memory may be less than the capacity of a region of system memory that is allocated for storing shader programs . For example the capacity of shader program instruction memory may in some examples be equal to the a maximum shader program size defined by a particular graphics application programming interface API e.g. an OpenGL API or a DirectX API for a particular shader program type. In such examples shader program instruction memory may not necessarily be guaranteed to be large enough to store multiple shader programs of the same shader program type if the shader programs are relatively large. However if one or both of the shader programs are relatively small in such examples then the techniques of this disclosure may be able to pack multiple shader programs of the same shader program type into shader program instruction memory even though the memory is only guaranteed in such examples to be large enough to store a single shader program.

Because shader program instruction memory is located on the same chip as GPU shader unit may be able to during execution of a shader program retrieve instructions more efficiently than a shader unit that executes instructions stored in an off chip memory such as e.g. system memory . Moreover because the techniques of this disclosure allow for multiple shader programs of a same shader program type to be stored in shader program instruction memory shader unit may be able to switch between the execution of different on chip shader programs without needing to reload the on chip shader program instruction memory thereby providing further performance improvement in systems that may need to frequently switch between executing different shader programs of a common shader program type.

In some examples CPU may determine one or more ranges of available memory space in shader program instruction memory after the first shader program has been loaded into shader program instruction memory and load the second shader program into the one or more ranges of available memory space. Available memory space may refer to memory space that is not presently allocated for the storage of and or is not presently storing a particular shader program. Available memory space may be alternatively referred to herein as free memory space.

After performing process blocks and two shader programs of a common shader program type may reside in shader program instruction memory at a common point in time. In some examples shader unit may be configured to execute each of the first and second shader programs directly from shader program instruction memory and to seamlessly switch between executing the first shader program and the second shader program without necessarily requiring either of the first and second shader programs to be reloaded into shader program instruction memory . The ability of shader unit to seamlessly switch between the execution of different shader programs may be particularly useful for example in applications that require a GPU to repeatedly switch between different shader programs during the execution of an application e.g. a GUI application that interleaves BLIT operations that use a first shader program with rendering operations that use a second shader program different that the first shader program. In such examples reloading new shader programs into shader program instruction memory every time the shader program to be executed is switched may consume a significant portion of the rendering time in such applications. By loading multiple shader programs of a common program type into shader program instruction memory according to the techniques of this disclosure however the performance overhead due to reloading shader programs may be significantly reduced thereby improving the performance of the overall graphics processing system.

On the other hand in response to determining that shader program instruction memory does not have a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory CPU evicts one or more shader programs from shader program instruction memory to generate enough available memory space in shader program instruction memory to store the shader program to be loaded . CPU loads the shader program into a portion of the available memory space in shader program instruction memory .

CPU may use a variety of techniques to determine which of the shader programs to evict from shader program instruction memory . In some examples CPU may select a least recently used LRU shader program to evict. In further examples CPU may select a least frequently used LFU shader program to evict. In additional examples CPU may determine N LFU shader programs and select the LRU shader program of the N LFU shader programs to evict. Other examples are possible and within the scope of this disclosure.

On the other hand in response to determining that shader program instruction memory does not have a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory CPU determines an LRU shader program from the remaining set of shader programs presently stored in shader program instruction memory and evicts the LRU shader program . CPU continues to evict LRU shader programs from the remaining shader programs until a sufficient amount of memory space is available in shader program instruction memory to store the shader program to be loaded. After determining that shader program instruction memory has a sufficient amount of memory space to store the shader program to be loaded into shader program instruction memory CPU loads the shader program into a portion of the available memory space in shader program instruction memory . The remaining set of shader programs presently stored in shader program instruction memory may include the original set of shader programs stored in shader program instruction memory when the technique in began executing excluding any LRU shader programs that have already been evicted in process box .

On the other hand in response to determining that shader program instruction memory does not have a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory CPU determines an LFU shader program from the remaining set of shader programs presently stored in shader program instruction memory and evicts the LFU shader program . CPU continues to evict LFU shader programs from the remaining shader programs until a sufficient amount of memory space is available in shader program instruction memory to store the shader program to be loaded. After determining that shader program instruction memory has a sufficient amount of memory space to store the shader program to be loaded into shader program instruction memory CPU loads the shader program into a portion of the available memory space in shader program instruction memory . The remaining set of shader programs presently stored in shader program instruction memory may include the original set of shader programs stored in shader program instruction memory when the technique in began executing excluding any LFU shader programs that have already been evicted in process box .

CPU determines a set of N least frequently used LFU shader programs from the set of one or more shader programs presently stored in shader program instruction memory where N is an integer greater than or equal to one . CPU determines a least recently used LRU shader program from the set of one N LFU shader programs . CPU evicts the LRU shader program from shader program instruction memory . CPU determines if shader program instruction memory has a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory . In response to determining that there is a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory CPU loads the shader program into a portion of the available memory space in shader program instruction memory .

On the other hand in response to determining that shader program instruction memory does not have a sufficient amount of available memory space to store the shader program to be loaded into shader program instruction memory CPU determines an LRU shader program from the remaining shader programs in the set of N LFU shader programs and evicts the LRU shader program . CPU continues to evict LRU shader programs from the remaining shader programs in the set of N LFU shader programs until a sufficient amount of memory space is available in shader program instruction memory to store the shader program to be loaded. After determining that shader program instruction memory has a sufficient amount of memory space to store the shader program to be loaded into shader program instruction memory CPU loads the shader program into a portion of the available memory space in shader program instruction memory . The remaining shader programs of the set of N LFU shader programs may include the original set of LFU shader programs determined in process box excluding any LRU shader programs that have already been evicted in process box .

The shader loading and eviction techniques described herein can be applied to any type of shader program and to any type of shader memory configuration. For example the techniques of this disclosure may be applied to a shader program instruction memory that has separate memory pools for each type of shader program as well as a shader program instruction memory that has a combined memory pool e.g. a memory pool that store multiple types of shader programs.

The techniques in this disclosure may be particularly useful in the context of rendering low complexity low pixel count objects because the shader programs that are used in such contexts are typically small enough to allow multiple shader programs to be packed into the same shader memory. In such cases the multiple shader programs can be reused without necessarily having to evict and or reload any of the shader programs.

For common use cases e.g. a user interface UI most shader programs may fit inside of an on chip memory. For semi common use cases e.g. a UI plus a simple application a BLIT operation may use the same shader across the frame but may be interleaved with many other types of rendering operations. By utilizing the techniques of this disclosure in these cases a GPU driver and the GPU may pay a lower cost for executing BLIT operations because the shader programs do not need to be evicted by the normal draw operation and reloaded by the BLIT operation.

The techniques described in this disclosure may be implemented at least in part in hardware software firmware or any combination thereof. For example various aspects of the described techniques may be implemented within one or more processors including one or more microprocessors digital signal processors DSPs application specific integrated circuits ASICs field programmable gate arrays FPGAs or any other equivalent integrated or discrete logic circuitry as well as any combinations of such components. The term processor or processing circuitry may generally refer to any of the foregoing logic circuitry alone or in combination with other logic circuitry or any other equivalent circuitry such as discrete hardware that performs processing.

Such hardware software and firmware may be implemented within the same device or within separate devices to support the various operations and functions described in this disclosure. In addition any of the described units modules or components may be implemented together or separately as discrete but interoperable logic devices. Depiction of different features as modules or units is intended to highlight different functional aspects and does not necessarily imply that such modules or units must be realized by separate hardware or software components. Rather functionality associated with one or more modules or units may be performed by separate hardware firmware and or software components or integrated within common or separate hardware or software components.

The techniques described in this disclosure may also be stored embodied or encoded in a computer readable medium such as a computer readable storage medium that stores instructions. Instructions embedded or encoded in a computer readable medium may cause one or more processors to perform the techniques described herein e.g. when the instructions are executed by the one or more processors. Computer readable storage media may include random access memory RAM read only memory ROM programmable read only memory PROM erasable programmable read only memory EPROM electronically erasable programmable read only memory EEPROM flash memory a hard disk a CD ROM a floppy disk a cassette magnetic media optical media or other computer readable storage media that is tangible.

Computer readable media may include computer readable storage media which corresponds to a tangible storage medium such as those listed above. Computer readable media may also comprise communication media including any medium that facilitates transfer of a computer program from one place to another e.g. according to a communication protocol. In this manner the phrase computer readable media generally may correspond to 1 tangible computer readable storage media which is non transitory and 2 a non tangible computer readable communication medium such as a transitory signal or carrier wave.

Various aspects and examples have been described. However modifications can be made to the structure or techniques of this disclosure without departing from the scope of the following claims.

