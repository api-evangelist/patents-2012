---

title: Analysis system for test artifact generation
abstract: A requirements testing system facilitates the review and analysis of requirement statements for software applications. The requirements testing system generates test artifacts from the requirement statements. The test artifacts characterize the requirements statements to provide valuable analysis information that aids understanding whether the requirement statements are testable, what the intentions of the requirement statements are, and other useful analysis information. Because the system generates the analysis information from the requirement statements, the system provides benefits in terms of early feedback along the software application development timeline.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08935654&OS=08935654&RS=08935654
owner: Accenture Global Services Limited
number: 08935654
owner_city: Dublin
owner_country: IE
publication_date: 20120109
---
This application claims the benefit of priority from Indian provisional patent application no. 1370 CHE 2011 filed Apr. 21 2011 and from Indian provisional patent application no. 1613 CHE 2011 filed May 10 2011 both of which are incorporated by reference.

This disclosure relates to test automation. More specifically this disclosure relates to assisted generation of early test analysis and design artifacts from natural language e.g. English language specification documents.

The network may follow any of a wide variety of network topologies and technologies. As examples the network may include Local Area Networks LANs Wide Area Networks WANs Internet connections Ethernet networks or Fiber Distributed Data Interconnect FDDI packet switched networks that may communicate Transmission Control Protocol Internet Protocol TCP IP packets or any data following any other communication protocol. The network provides a transport mechanism or interconnection of multiple transport mechanisms supporting data exchange between the system and any source of documents to analyze including the requirement documents .

An analysis engine in the system analyzes the requirement statements to determine the test artifacts. A requirement statement may for example be implemented as a single sentence or other sequence of one or more words. The requirement statement may for example be in unconstrained natural language structured formats or model based formats. An example of a requirement statement in a structured format may be a requirement statement limited to subject action and object denoted by SAO in Link Grammar notation . Such a restriction may exclude requirement statements with multiple objects or requirement statements with nouns which are neither subjects nor objects. Other examples are possible.

In some instances the requirement statements may include data that is not intended for processing. Such data may be marked e.g. the data not intended for processing may be enclosed in brackets. The requirement statements may first be processed by the preprocessor as described in more detail below. Among other things the preprocessor may remove data enclosed in brackets as well as the brackets themselves. The analysis engine may generate e.g. on the display an analysis report . The analysis report may specify the test artifacts or any other analysis details that the system determines.

An artifact may be a tangible by product produced during the development of software e.g. a use case or a class diagram . Artifacts of a software project may be or resemble deliverables of the software project though the software itself i.e. the released end product may not be an artifact. A test artifact may be a tangible by product produced during software testing. Test artifacts may relate to a characteristic of a requirement statement. Examples of test artifacts may include an indication of one or more of the following requirement testability requirement intent requirement category requirement data and requirement ambiguity. Testability artifacts intent artifacts category artifacts and data artifacts may be examples of test artifacts as well as or alternatively an ambiguous phrase identified in a requirement statement. For example the test artifacts may include Testability specifying for example whether the requirement statement is testable Intent specifying for example the intent or purpose of the requirement statement Category specifying for example what type of requirement the requirement statement establishes Data specifying for example the data that the requirement statement operates on and Ambiguity specifying whether all or parts of a requirement statement are ambiguous with regard to its testability. The system may determine additional fewer or different artifacts including grammatical correctness of the requirement statement in whole or in part.

 1 Modal verbs connect to the subject and object as in the requirement statement The system should display the numbers in ascending order. 2 Modal verbs connect to the subject and a preposition or participle as in the requirement statement The numbers displayed should be in ascending order. 3 The modal verb connects to the subject through a participle and in turn connects to an object preposition participle as in the requirement statement The numbers are required to be displayed in ascending order. 

Not all requirement statements are testable. For example Project staffing report is defined as a report containing information about the project name project description total employee count staffing status. The system determines that this statement is not testable because none of the testability rules fire. One reason is that this requirement statement gives the definition of the report but does not tell how the report can be generated. As such the requirement statement fits better into the assumptions section of the requirement document. Another example is Resource allocation request is associated with only one role. This requirement statement is not clearly a requirement to be coded or a logical association made by the requirement writer. If it is to be encoded it is better phrased included a modal verb such as The resource allocation request should be associated with only one role. 

A compound sentence or statement may be a sentence or statement that has multiple subjects. A simple sentence or statement may be a sentence or statement that has a single subject. A subject may be a word phrase or formal expression about which something is predicated. The subject may be for example a noun noun phrase or noun substitute.

An intent may for example be a logical step that must be executed in order to perform a test. The intent may be the most atomic unit that conveys enough information for a test to be made. In some cases the intent may be a set of words along a path of links bounded by noun phrases. The intents of a requirement statement may be represented by an intent artifact. The links of the requirement statement identified by a grammatical parser may be traversed in order to identify the intents. A grammatical parser may for example be implemented as a syntactic parser or a dependency parser such as a dependency parser with an extensible dictionary. Static text may be added to each intent through an intent template i.e. action discussed in more detail below in order to maintain the meaning of the intent. Identifying test intents may increase the comprehensibility of the requirement statement by breaking the requirement statement into individual testable components such as test steps corresponding to the requirement statement. Intents may be useful when analyzing long requirement statements and or may be used to remove syntactic ambiguity such as ambiguity arising from the structure of the requirement statement . Intents may also act as a proxy to estimate the amount of testing effort needed to test a requirement statement. Other uses may be possible.

In the first requirement statement the system determines that two applicable categories are Input and Security. The Input category is applicable due to the noun verb construct user enters while the Security category is applicable due to the presence of the word password. In the requirement statement the system determines that the applicable category is Non Functional Requirement NFR due to the presence of the non functional requirement within 3 seconds. A NFR may define characteristics such as performance availability or other non functional aspects as opposed to functional or behavioral aspects.

In some systems it may be useful or necessary to determine whether the requirement statement can be categorized as NFR Input Output or Intermodule. Syntactic patterns and semantic rules may be used to determine whether the requirement statement is in the Input Output or Intermodule category. For example a requirement statement in one of these two categories may be characterized by two noun phrases connected by either a verb or an adverb. According to a more specific example if both the noun phrases are system nouns the category may be Intermodule . If one of the nouns is a person noun the requirement statement may be categorized as Input Output . Semantic rules may be used with a category glossary to determine what constitutes system nouns and person nouns .

In some systems and methods a requirement statement may be categorized as Security if any phrase from a security glossary is present in the requirement statement. Other examples are possible.

The system may also include a set of pattern matching rules which identify link structure patterns referred to as primary structures that determine test artifacts including the initial intents of the requirement statement. In addition a set of extended rules identify extensions to the initial intents to provide secondary intents. The extended rules may analyze noun verb modifiers gerunds and other modifiers as examples. A set of entity mapping rules maps noun phrases and verb phrases to a keyword list or glossary to categorize requirements into test categories. The system may also include a set of quantifier constraints and other modifiers that identify test data and logic to generate a test data range. Example implementations of the rulesets are provided in the tables below. The system may implement additional fewer or different rulesets to analyze requirements statements for additional fewer or different test artifacts.

In some systems and methods the rules in a ruleset may specify a contiguous set of links that must be present in a requirement statement. For example the testability ruleset may specify a contiguous set of links that must be present in a requirement statement in order for the requirement statement to be classified as testable. Other examples are possible.

The system may include a processor and a memory with logic for execution by the processor that implement the analysis engine . The system receives from either local or remote sources and stores in the memory a requirement statement for analysis. Preprocessor logic may first filter each requirement statement .

The preprocessor logic includes preprocessing rulesets e.g. the preprocessing rulesets and . The preprocessing rulesets cause the preprocessing logic to perform analysis modification or other actions on requirement statements. Table 1 and Table 2 give examples of the preprocessing rulesets.

In some instances when the preprocessor logic converts the words in the sentence to lower case the words e.g. when they are acronyms may not be recognized as valid entries in the parser logic dictionary. To address this situation the system may modify the parser logic dictionary to treat all unknown words as a noun and associate with the unknown words with the links given to recognized nouns. The system may also handle verbs used as nouns as with the word update in the example The system should disable the update button. In one implementation the system identifies as dual use words those words that may be used both as a verb and as a noun updates the parser logic dictionary to indicate that the dual use words may be used as both a verb and a noun and associates the links given to verbs and nouns with the dual use words. Words may be identified as dual use words in many ways such as by scanning a dictionary or other grammatical database such as the Word Net database wordnet.princeton.edu . Identifying dual use words in the parser logic dictionary may be advantageous in some instances such as where a requirement statement might not otherwise be properly parsed like where a noun may be incorrectly identified as a verb.

The pre processed requirement statement is passed onto the parser logic . If no linkages are found by the parser logic null count 0 the system highlights the requirement statement as grammatically incorrect. If the parser logic has found a complete linkage then the parser output including grammatical links between words and phrases the constituent tree and the classification of words into the parts of speech which may be based on the suffix put after the input words are saved in memory . The constituent tree may classify the words in the requirement statement into parts of speech and arranges words into phrases. The parser output may be evaluated by the analysis logic including for example by submission of the parser output and requirement statement as input data to one or more analysis rulesets . The rules within the analysis rulesets that fire on the input data indicate the test artifacts for the requirement statements.

Furthermore the analysis logic may reference one or more glossaries such as for example the ambiguity glossary conformance glossary usability glossary entity glossary and category glossary as noted in the rules below to facilitate processing the requirement statement . The glossaries may be leveraged from the document commenting and analysis applications DARAs identified below and incorporated by reference.

The example analysis rulesets given below show the condition to be checked on the parser outputs of the parser logic the corresponding action to be taken and whether a specific test artifact is determined. The examples referred to by number in the tables are found in the drawings. For instance Examples 5.1 5.1.1 and 5.1.2 are found in .

The system may recognize a testable requirement statement based on whether the testable requirement statement includes a modal verb represented with links I rule IDs T.1 and T.4 and Ix rule IDs T.2 and T.3 in Table 3. For example the requirement statement may be determined to be testable based on the presence of contiguous links e.g. S I O rule ID T.1 . The linkage S I O denotes that a subject link S should connect to a modal verb link I which in turn should connect to an object link O . In some configurations the requirement statement may be determined to be testable based on the presence of a combination of 8 links as shown in Table 3 i.e. links S I Ix P O OF Pv TO as specified in LG nomenclature in Table 3 . Other examples are possible.

When a particular rule fires for a parsed sentence the system generates a corresponding intent template e.g Verify was . The system fills the template with appropriate words from the constituent tree of the sentence. The system may implement a set of rules developed over any set of example sentences created for setting up the system . With regard to notation the notation denotes the phrase encapsulated within the tag T in the constituent tree. Any word of the phrase should have a link L . The link L may specify e.g. using the or flag whether the system should analyze the start or the end of the link.

With regard to categorization the system may implement categorization by identifying the occurrence of phrases and their relation to an action. The system may also as described below leverage the categorization processing described in the document commenting analysis and reporting applications DARAs including U.S. Pat. Publication Nos. 2011 0022902 2010 0005386 and 2009 0138793 which are incorporated by reference in this document in their entireties.

The system may employ the entity glossary and the category keyword glossary from the DARAs or may employ customized glossaries including additional different or fewer glossary entries. In particular the entity glossary may be implemented as the agent glossary in the DARAs. An example NFR dictionary including a logging and security section is given below in Table 12.

For the security category the system may compare the requirement statement to the indicator phrases in the DARAs NFR glossary marked as security. For error handling the system may compare the requirement statement to the indicator phrases in the DARAs NFR glossary marked as logging disaster recovery DisasterRecoveryRequirements Recovery Time or any other phrases that indicate error handling.

As noted above the non functional requirement NFR statement specifies how a system should behave. What the behavior should be is captured in the functional requirement. The system may compare the requirement statement to the indicator phrases in the DARAs NFR glossary except those marked for security or error handling as noted above .

Then the system may confirm that both the nouns are not actors and not persons. An example inter module test statement is shown in for the requirement statement The system should send the report to the xyz module. 

The system may classify verbs as input output. For example the system may regard send and click as outputs and receive as an input. The system may then determine whether a person noun phrase occurs to the left of the verb or to the right of the verb. If the person noun phrase is to the left the system may categorize the requirement statement as an Input domain else as an Output domain. An example Input domain statement is present in . An example output domain statement is also present in .

The system may determine that a requirement statement is of the category Condition Dependency when the parser logic locates condition C structures in the requirement statement. An example Condition Dependency statement is shown in .

The system may determine that a requirement statement is of the category Usability Conformance when the parser logic locates any of the keywords in the usability glossary or in the conformance glossary respectively in the requirement statement. An example Usability Conformance statement is shown in .

With regard to data test artifacts the system may proceed under the assumption that the preprocessor logic has executed whatever rulesets have been implemented e.g. the preprocessor rulesets shown in Tables 1 and 2 . For example the system may assume that the preprocessor logic has made the following replacements and optionally other or different replacements defined in the preprocessor rulesets noted above by the time that the system analyzes the requirement statement for data test artifacts 

If the parser logic output has Nlf Nit and either between or from then the system may loop through the results until Nlr or threshold. Accordingly the system may ensure that it handles a range keyword such as between and from in the correct manner. The system may when the parser logic generates multiple linkages select the linkage that facilitates further processing of the requirement statement e.g. the linkage that facilitates a rule firing .

Different kinds of test data may be present in a requirement statement. As examples time data date data numeric data and Boolean data may be present. The system may recognize test data associated with a numeral a unit a condition such as a relational symbol like a variable that takes values. Furthermore the system may recognize that a requirement statement includes multiple instances of test data linked by conjunctions or a range as examples. The system may identify units of data by pulling out the immediate post nominal link from the identified data. Particular links may be analyzed for time and date. Similarly the system finds units when the data is in a range e.g. The password should be between 8 and 10 characters . The system may further identify the condition such as a relational symbol like etc . To that end the system may identify the pronominal modifier to the data e.g. The password should be less than 10 characters .

With regard to numerals the system may recognize natural numbers fractions and decimals time e.g. 5 35 date e.g. first 1st . The parser logic may link numbers with a . symbol. The system may then identify numbers by searching the parser logic output for data tagged with a . . shows an absolute number example a fraction example a time example and a date example . The parser logic may include a dictionary that lists the various numerals and other parts of speech that may occur in an English sentence e.g. 1 first 2011 and so on . The system may employ a modified dictionary for the parser logic to supply a suffix of . to each occurrence of such a numeral similar to the way in which the parser logical may apply of suffix of .v to verbs .a to adjectives .ti to time or date.

The parser logic may output tags for time units that include a suffix of .ti for am pm a.m. p.m. o clock o clock with the numeral connected with an ND link. The system may pick up the numeral from the . and look at the word reached from it through the ND link to find the numeral. If the word also includes a .ti suffix the system may conclude that the data is time data. In summary Unit ND word Data type time.

Date information may vary from concepts such as the last day of the month to Midnight noon quarterly weekly monthly fortnightly daily half yearly yearly annually p.a. p.m. to equal installments or intervals or other phrases. The system may identify the day by the TM or TM link and may identify the year by the TY link.

The system may determine that if the . has a TM or a TM link the . word is the day. The system may then conclude that the word pointed by the complimentary of the TM is the month. Similarly if the . has a TY link it is the year. The TY link corresponding to this is the month. The month from the day year should be the same. If they are different the system may log this condition as an error choose the month from for example the TY structure. The system may conclude that if . is connected with a TM or TY the data type is date.

The system may identify units with a range of data or multiple possible data values. shows a range example and a range example . For the range example the system may determine that if the . does not have an ND link but has Nlf or Nit ND the unit is the ND link. The system may recognize as ambiguous a requirement statement with multiple dates with the month before the date as shown in the ambiguous example .

Regarding Boolean data the system may recognize as examples ON OFF TRUE FALSE. These may be associated with the variable in the following examples 

The system may make each of these terms behave like a number and therefore act like an object. The parser logic may give them a suffix of . b. The system may increase the weight of Pa and Paf for True False. This is because when these occur they would most likely be used in the Boolean context.

The system need not modify weights for on since on will largely be used in two contexts switch on on the table. In both these cases on cannot act like a number. Similarly off can be used in switched off mainly and again cannot act like a number here. In general the parser logic may assign grammatical links in a manner that minimizes the number of links. However in the context of requirements testing certain links between words do not fit e.g. the switch should be in ON mode. . Here ON is to be used as a Boolean as opposed to a conjunction. The system recognizes this by increasing the weight of the conjunction link of ON thus making the Boolean use of ON occur before the former.

Note that the time date can have the prepositions at on for by before after from to and phrases like no later than no sooner than. For the system to identify a condition the system may search for the PP or SBAR from the constituent tree before the NP of the data element.

In case of numeric data the prepositions that occur are equal to less than more than greater than lesser than higher than lower than fewer than further than as many as as much as up to at least at most be at all but none but within in 

 Less than is generating the EN link as the next option. The system may look for the next however the system may replace these terms using the pre processor logic 

The system finds ranges through the Nlr structure as shown for example in the range example shown in .

Words that can have ranges will have an Nlr link between from and the system may handle the Nlr structure as follows Nit as shown in the range example . The range example shows how a statement with and or may be parsed and recognized by the system .

The system may analyze specific words in the requirement statement with reference to one or more glossaries. For example the ambiguity glossary may store selected words as noted for example in Table 9 that when found by the system in the requirement statement imply non ambiguity for the phrase in which the words exist. As described in more detail below e.g. and with respect to the system may perform the ambiguity tests after establishing the testability of the requirement statement and in parallel or in sequence with the application of other rulesets including the intent data and categorization rulesets.

The system submits the pre processed requirement statement to the parser logic . When the parser logic determines that the requirement statement is syntactically invalid then the system may report that the requirement statement is invalid and continue analyzing additional requirement statements.

Otherwise the parser logic outputs such as the grammatical links constituent tree and the classification of words into the parts of speech are saved in the memory . The analysis logic may then perform any desired analyses on the requirement statement by applying analysis rulesets to the requirement statement with reference to the parser logic outputs. For example the analysis logic may apply a testability ruleset to determine whether any of the testability rules fire and the requirement statement is testable . If the requirement statement is not testable then the system may report that the requirement statement is not testable continue on to other requirement statements for analysis.

The analysis logic may then invoke statement simplifier rules . Examples of such rules include analysis and delimiting of compound sentences and processing of conditional statements. The statement simplifier rules are explained in more detail above in the Compound Sentences ruleset with respect to the C CC B VJ and MJ rules. Given a resulting simplified sentence the analysis logic may apply any other desired rulesets such as the ambiguity ruleset the intent ruleset the category ruleset or the data ruleset to determine any desired test artifacts for the requirement statement. Each resulting simplified sentence may include the modal verb of the compound sentence from which it is derived. Simplifying a compound sentence and applying the rulesets to simple sentences derived from the compound sentence may resolve ambiguity in the compound sentence and improve the accuracy and utility of test artifacts. The analysis logic may store the determined test artifacts in memory . A reporting module running in the system may then read the test artifact results and generate and display an analysis report .

The constituent tree shows how the requirement statement is composed by individual grammatical units. The graphical representation of the constituent tree also shows how the requirement statement flows through its component noun phrases NP e.g. the noun phrase the user and verb phrases VP e.g. the verb phrase overwrite . The constituent tree also identifies the subject in this case The user . The numbers next to each node give a unique identifier for each node.

A specific example of the test artifacts that the system generates is now given for the sentence The PRTS system should send 3 bits of functional information containing the WAKE code. shows the resulting parse by the parser logic into links and a constituent tree . For this sentence the following rules fire and the system outputs the following test artifacts shown in Table 13 

The system provides a framework for identification and analysis for early testing artifacts from natural language requirements. For any software project and in particular for large sized software implementation projects it is critical to identify and analyze if the functional requirement specifications written in natural language e.g. the English language are testable in terms of business and user acceptance criteria. For example a business analyst test architect or other personnel may benefit from knowing whether a functional requirement is un ambiguously testable what would be the intents of such tests e.g. what functional non functional needs would those requirements be tested for what category of test would the requirement belong to and if there are any test data embedded in the requirement. These are significant test artifacts to identify and understand because in absence of such an exercise early in the test analysis and design phase many ambiguous requirements may propagate downstream.

This gives rise to improper ambiguous or un defined test specifications. Test case generation and test coverage may suffer as well. Also from such imprecise test specifications one cannot prepare a valid testing plan and estimate the testing effort required and determine whether the functional coverage will be adequately achieved through testing. Although test cases can be generated automatically from properly specified and elaborate requirements and models the activity of testability checking and generation of early testing artifacts from high level functional requirements has been in the past mainly manual subjective and error prone. In contrast the system provides a novel automated framework for identification and analysis for early testing artifacts from functional requirement sentences. The framework leverages natural language processing techniques to obtain structural dependencies in the sentence e.g. a requirement statement and parts of speech phrase tagging. The system employs a set of pattern matching rules to identify syntactic structure s of possible test intents and a set of entity keyword mapping rules to identify and tag test category and data from the phrases and mark ambiguity if any.

Requirements testing systems and methods may be used for testing a requirement statement. Requirements testing systems may gather and analyze sentences to determine if the sentence is testable invoke sentence simplifier rules to simplify the sentence and extract test artifacts about the sentence. For example in gathering and analyzing sentences to determine testability some systems may execute pre processing rulesets on the gathered sentences. The pre processed sentences may be submitted to a parser logic which may be used to determine if the sentence is valid. Where the sentence is valid the outputs from the parser logic may be stored and a testability ruleset may be applied to the sentence. Where the sentence is testable the simplifier rules such as compound sentence rules and conditional statement rules may be applied to the sentence to simplify the sentence. Then the various test artifact rules such as ambiguity rules test data rules intent rules and or category rules may be applied to the sentence. The test artifacts obtained from the application of these rules may be stored. Such test artifacts may be used in reports or other analysis or processing as discussed.

In some requirements testing systems and methods a requirement statement is obtained and stored in a memory. The requirement statement is submitted to a grammatical parser executed by a processor to obtain parser outputs characterizing the requirement statement. A test artifact ruleset is applied with the processor to the parser outputs to determine a test artifact applicable to the requirement statement.

These and other requirements testing systems and methods allow for developers to check for testability and various features of statements and documents. Another benefit of the requirements testing system is that it facilitates creation of test artifacts from requirement statements. The test artifacts reduce testing cycle time effort and expense and improve test quality. As a result the resulting software application is more reliable less expensive and is more timely delivered. This allows developers to implement complex statements and documents in less time and with fewer mistakes or ambiguities increasing efficiency and effectiveness of the requirements statements. Requirements testing systems also result in various other advantages and effects.

The methods systems and logic described above may be implemented in many different ways in many different combinations of hardware software or both hardware and software. For example the logic executed by the system may be circuitry in a controller a microprocessor or an application specific integrated circuit ASIC or may be implemented with discrete logic or a combination of other types of circuitry. The logic may be encoded or stored in a machine readable or computer readable medium such as a compact disc read only memory CDROM magnetic or optical disk flash memory random access memory RAM or read only memory ROM erasable programmable read only memory EPROM or other machine readable medium as for example instructions for execution by a processor controller or other processing device. Similarly the memory in the system may be volatile memory such as Dynamic Random Access Memory DRAM or Static Random Access Memory SRAM or non volatile memory such as NAND Flash or other types of non volatile memory or may be combinations of different types of volatile and non volatile memory. When instructions implement the logic the instructions may be part of a single program separate programs implemented in an application programming interface API in libraries such as Dynamic Link Libraries DLLs or distributed across multiple memories and processors. The system may test input sentences other than requirement statements.

While various embodiments have been described it will be apparent to those of ordinary skill in the art that many more embodiments and implementations are possible. For example a method for testing a requirement statement may be provided. The method may include obtaining a requirement statement and storing the requirement statement in a memory. The method may further include submitting the requirement statement to a grammatical parser executed by a processor to obtain parser outputs characterizing the requirement statement. The method may further include applying a test artifact ruleset with the processor to the parser outputs to determine a test artifact applicable to the requirement statement.

In some cases applying the test artifact ruleset includes applying a testability ruleset with the processor to the parser outputs to determine a test artifact that indicates whether the requirement statement is testable. Additionally or alternatively it may be that applying the test artifact ruleset includes applying an ambiguity ruleset with the processor to the parser outputs to determine a test artifact that indicates whether the requirement statement is ambiguous with respect to testability. Additionally or alternatively applying the test artifact ruleset may include applying an intent ruleset with the processor to the parser outputs to determine a test artifact that indicates an intent characteristic of the requirement statement. Additionally or alternatively applying the test artifact ruleset may include applying a category ruleset with the processor to the parser outputs to determine a test artifact that indicates a category characteristic of the requirement statement. Additionally or alternatively applying the test artifact ruleset may include applying a data ruleset with the processor to the parser outputs to determine a test artifact that indicates a data characteristic of the requirement statement. Additionally or alternatively the method may further include executing a pre processor on the requirement statement prior to submitting the requirement statement to the grammatical parser.

According to another aspect a computer program product including computer readable instructions may be provided. The instructions when loaded and executed on a computer system may cause the computer system to perform operations according to the steps aspect and or embodiments discussed above.

According to yet another aspect a requirement statement analysis system may be provided. The system may include a processor and a memory in communication with the processor. The memory may include a requirement statement and grammatical parser logic. The memory may further include analysis logic operable to when executed by the processor obtain the requirement statement and store the requirement statement in the memory. When executed the analysis logic may be further operable to submit the requirement statement to the grammatical parser logic and obtain parser outputs characterizing the requirement statement. The analysis logic may be further operable to apply a test artifact ruleset to the parser outputs to determine a test artifact applicable to the requirement statement.

In some cases the test artifact ruleset may include a testability ruleset configured to determine as the test artifact whether the requirement statement is testable. Additionally or alternatively the test artifact ruleset may include an ambiguity ruleset configured to determine as the test artifact whether the requirement statement is ambiguous with regard to testability. Additionally or alternatively the test artifact ruleset may include an intent ruleset configured to determine as the test artifact an intent characteristic of the requirement statement. Additionally or alternatively the test artifact ruleset may include a category ruleset configured to determine as the test artifact a category characteristic of the requirement statement. Additionally or alternatively the test artifact ruleset may include a data ruleset with the processor to the parser outputs to determine a test artifact that indicates a data characteristic of the requirement statement. Also the analysis logic may be further operable to execute a pre processor on the requirement statement prior to submitting the requirement statement to the grammatical parser.

It should be understood that various modifications to the disclosed examples and embodiments may be made. In particular elements of one example may be combined and used in other examples to form new examples. Accordingly the implementations are not to be restricted except in light of the attached claims and their equivalents.

