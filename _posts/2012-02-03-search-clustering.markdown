---

title: Search clustering
abstract: In one example embodiment, a method is illustrated as including retrieving item data from a plurality of listings, the item data filtered from noise data, constructing at least one base cluster having at least one document with common item data stored in a suffix ordering, compacting the at least one base cluster to create a compacted cluster representation having a reduced duplicate suffix ordering amongst the clusters, and merging the compacted cluster representation to generate a merged cluster, the merging based upon a first overlap value applied to the at least one document with common item data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08589398&OS=08589398&RS=08589398
owner: eBay Inc.
number: 08589398
owner_city: San Jose
owner_country: US
publication_date: 20120203
---
This application is a continuation of U.S. patent application Ser. No. 11 771 464 filed Jun. 29 2007 entitled SEARCH CLUSTERING which application is related to and claims the priority benefit of U.S. Provisional Patent Application No. 60 866 598 entitled A MULTI FACTOR CLUSTERING SYSTEM FOR A MARKETPLACE SEARCH INTERFACE that was filed on Nov. 20 2006 and U.S. Provisional Patent Application No. 60 904 295 filed on Feb. 28 2007 entitled MULTI FACTOR CLUSTERING FOR A SEARCH INTERFACE all of which are incorporated by reference in their entirety.

The present application relates generally to the technical field of search algorithms and in one specific example the generation of a searchable data structure.

In many cases the success of a search algorithm is tied to the data structure that is being searched and more specifically the organization of this data structure. Certain ways of organizing a data structure and the data contained therein may result in large savings in terms of time needed to search and produce search results. Further certain data structures may result in more accurate search results being produced for a given query.

Example methods and systems to facilitate video mail in a peer to peer network are illustrated. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of example embodiments. It will be evident however to one skilled in the art that the present invention may be practiced without these specific details.

In some embodiments a system and method is disclosed for building a searchable data structure wherein each node in the data structure contains clusters of data. These clusters are generated based upon a variety of factors including for example relevancy weighting seller factors price factors category factors image factors and other suitable factors. In one embodiment this data structure e.g. a merged cluster map is generated from a trie or some other data structure that has constant time O 1 search performance or near constant time search performance e.g. amortized O 1 . These other data structures may include hash tables binary search trees red black trees heaps or other suitable data structure. In one embodiment a Suffix Tree Clustering STC algorithm is implemented.

Example embodiments may include an implementation of an STC algorithm building a suffix trie using the terms in documents that are to be divided into groups of clusters based upon the commonality of phrases in the documents. In some embodiments there are 3 steps to implementing STC 1. Document preparation 2. Identifying base clusters and 3. Merging clusters. During the merging of clusters various relevance weighing factors e.g. multi factor clustering may be utilized to merge the clusters in more or less desirable ways depending upon the selected factors.

In some embodiments the query may be sent to more than one web server . Further this web server may be connected to more than just the application server and may in fact be connected to a plurality of application servers. Additionally this application server may be connected to a plurality of item listing databases in addition to item listing database . Further though not depicted this application server and or a plurality of application servers may be operatively coupled to any one of a number of database servers that may serve as an intermediary between the application server and databases such as the item listing database .

In some embodiments for a given query e.g. a search query the system may obtain search result for that particular query. This may be achieved through an API call made to a search back end. Subsequently a HTTP based method call is made to obtain relevance weighting for that particular query from a Relevance Weighting System. In some embodiments different queries return relevance weightings specific to that query. Next the search results obtained are then clustered on the fly using the standard STC algorithm with influencing factors like the relevance weighting factor pre defined merge threshold and pre defined base cluster score. The clustered results are then sent to the labeling algorithm. The labeling algorithm uses some statistical measure to provide descriptive tags that represent the clusters on the whole such that the clusters have meaning for the person performing the search.

In some embodiments text in the form of strings are processed wherein these strings are capable of reversible mapping to other strings. These strings may appear in documents such as web pages or other types of electronically generated documents. Strings in the form of advertisements appearing on web pages advertising the sale of goods or services may be one example of a document. These advertisements may contain titles seller information and other descriptive string based information.

Example embodiments may include the populating of an item listing database for the purpose of providing data upon which to conduct a search. In some embodiments a rule set e.g. an eXtensible Markup Language XML based file is provided to an parsing operation wherein the rule set outlines a grammar based upon which parsing may occur. This parsing operation may in some embodiments remove e.g. filter noise words from an electronic document in the form of for example an advertisement. These noise words may be duplicate words in the electronic document or words that otherwise do not add meaning to the electronic document. After the completion of the parsing operation the remaining words are stored into a data structure residing on for example the item listing database . These remaining words e.g. item listings may be organized by price of the item to which they refer date and time the advertisement was created or organized based upon other properties to be used in the selecting of item listing for the purpose of satisfying a query such as query .

In some embodiments a mapping in the form of for example a bayesian network decision tree or other suitable data structure is generated wherein all the words in a document e.g. both noise words and the keywords are placed into a data structure as nodes with weighted links connecting the nodes. These weighted links may represent probability values for determining whether a word or combination of words appearing in a item listing are noise or key words.

Some embodiments may include the populating of an item listing database for the purpose of providing data upon which to conduct a search. In some embodiments demand data and attribute data are used to determine which words are noise and which are not during the course of populating an item listing database . Titles as entered by users have high degree of variability. For example for any single phrase item we can have a large number of variations in occurrence location in the title along with the combination of noise words like adjectives and prepositions. Example embodiments may include the use of demand data and attribute data to find the important relevant words in the item listings. This demand data may be data relating to how often a word has been used by all users or a portion of users conducting a search. Attribute data may be data that defines some other piece of data such that the attribute is dependant upon this other piece of data. In one embodiment a set of relevant words for a query q is built through the following steps 

In some embodiments item listing data may be retrieved via the execution of the operation from the item listing database for the purpose of identifying and building a trie of possible search results based upon a particular search query such as query . Further this query may be classified through the execution of an operation prior to the building of the trie. This trie may be a suffix trie or even a prefix trie. Further as discussed above other types of data structures may be used in lieu of a trie for the purpose of organizing item listing data for searching. Once built the trie may be compacted so as to generate clusters of electronic documents e.g. base clusters wherein the clustering is based upon strings and similarities or even differences in strings. This clustering may be performed using various types of logical operations such as intersection so as to eliminate duplicate strings contained in two or more clustered electronic documents. Other operations may include joins e.g. inter join outer join difference and other operations common to query languages such as a Structured Query Language SQL and the Multidimensional Expressions MDX language.

Some embodiments may include the various databases e.g. being relational databases or in some cases On Line Analytical Processing OLAP based databases. In the case of relational databases various tables of data e.g. item data or data that is related to or part of the electronic document are created and data is inserted into and or selected from these tables using an SQL or some other database query language known in the art. In the case of OLAP databases one or more multi dimensional cubes or hyper cubes containing multidimensional data from which data is selected from or inserted into using an MDX may be implemented. In the case of a database using tables and SQL a database application such as for example MYSQL MICROSOFT SQL SERVER ORACLE 8I 10G or some other suitable database application may be used to manage the data. In this the case of a database using cubes and MDX a database using Multidimensional On Line Analytic Processing MOLAP Relational On Line Analytic Processing ROLAP Hybrid Online Analytic Processing HOLAP or some other suitable database application may be used to manage the data. The tables or cubes made up of tables in the case of for example ROLAP are organized into an RDS or Object Relational Data Schema ORDS as is known in the art. These schemas may be normalized using certain normalization algorithms so as to avoid abnormalities such as non additive joins and other problems. Additionally these normalization algorithms may include Boyce Codd Normal Form or some other normalization or optimization algorithm known in the art.

In some embodiments once the item data is retrieved by the operation and the classification of the query is determined an uncompacted trie is built. Consider for example the following five item titles retrieved in response to the search query Pepsi Cola Pepsi Cola Bottle Cap Pepsi Cola Bottle Opener Old Pepsi Cola Lighter Pepsi Cola Coin Bank Vintage Pepsi Cola Bottle Opener. Using these five retrieved titles an uncompacted trie may be built.

In addition to the subtree further subtrees are illustrated in this uncompacted tree . For example a subtree contains a variety of nodes . More to the point a node referenced as is connected to a node referenced as via an edge labeled Bottle. Further the node labeled as is connected to a node labeled as via an edge labeled Cap. Moreover this node labeled as is connected additionally to a node labeled as via an edge labeled Opener. Further the node labeled as is connected to a node labeled as by an edge labeled Lighter. This node labeled as is also connected to a node labeled as via an edge labeled Coin. The node labeled as is further connected to a node labeled as via an edge labeled as Bank. This subtree is in turn connected to a further node by an edge labeled Cola. This node is in turn connected to another root node by an edge labeled Pepsi. Traversing through the subtree and utilizing the node and root node the following substrings may be generated. For example the substring Pepsi Cola Bottle Cap may be generated wherein the leaf node at the end of this path e.g. node labeled as denotes that document 0 contains this substring. Again traversing through this subtree and the connected node and root node the further substring of Pepsi Cola Lighter may be generated wherein this substring is contained in documents 2 and 1 as referenced by node e.g. . A further substring may be generated in the form of Pepsi Cola Bottle Opener wherein this substring is contained in documents 0 1 and 4 see e.g. node referenced herein as . An additional substring contains the terms Pepsi Cola Coin Bank wherein this substring is contained in documents 0 and 3 see e.g. node referenced herein as .

In some embodiments once a trie is built compaction occurs and base clusters are generated. A base cluster may be a set of electronic documents e.g. online transactions that share common phrases in their item titles or other type of common string based data. A suffix trie is then constructed for the purpose of organizing these electronic documents so as to allow for the retrieval of relevant search results. For example a suffix trie of a string S of words may be a compact trie containing all the suffixes of S. Specifically 

In some embodiments not only may a plurality of nodes make up a subtree but also a singular node may make up a subtree. For example node referenced as is connected to the root node via an edge labeled Cap such that documents 0 and 3 contain the substring Cap. Further the node referenced as is a leaf node that references documents 0 and 4 such that documents 0 and 4 contain the substring Vintage Pepsi Cola Bottle Opener. As will be more fully illustrated below the various subtrees within this compacted subtree may again be reduced using certain principles of overlap and other types of factors as will be more fully discussed below.

The table depicted below shows for each intermediate node the base cluster under that node and the phrases e.g. strings and the documents that belong to the base cluster identified by these nodes.

In some embodiments each base cluster is assigned a score that is a function of the number of documents it contains and the words that make up its title. This function can be illustrated as follows 

Some embodiments may include sorting the compacted trie so as to order the nodes within the trie. For example if key phrases can be extracted from the title of an item then the nodes can be ordered based upon these extracted terms. This order may be ascending or decending. Further once ordering occurs then further compaction may take place for certain nodes and their new position may be duplicative of other nodes.

Some embodiments may include strings that are common to more than one document. There might be significant overlap in the document sets between clusters. In some cases similar clusters are identified and those that are similar are merged. The idea is that clusters that have document sets that significantly overlap are probably related to the same theme and hence need to be merged. For example given two clusters qand qwith sizes qi and qj respectively we can say bi and bj are similar if qi qj bi and qi qj qj where is a predefined threshold. Similarity between clusters can be defined as a function qi qj 1 if qi qj qi and qi qj qj and 0 otherwise.

In some embodiments bidirectional edges are used to connect the various nodes that make up this merged cluster map. In one case the use of bidirectional edges denotes that the substrings or a combination of substrings may be searched or understood bi directionally such that the substring Old Pepsi Cola Lighter may be held as an equivalent to Lighter Cola Pepsi Old for the purposes of searching and retrieving search results such as search result . Moreover in certain cases an overlap value may be based upon some percentile value wherein for example where there is a 50 overlap in documents containing strings or substrings then the nodes that reference these strings or substrings may be merged with other nodes containing similar e.g. at least 50 similar similarity. In addition to a bare overlap value additional factors such as a relevancy weighting factor a seller factor a price factor a category factor an image factor or some other suitable factor may be used as a basis for merging clusters. Further these clusters are built purely based on the title text and not based on any additional information available in the transaction. For example we could use price information as an additional parameter into the clustering system such that clusters that are closer to each other in the price range might contribute as additional factor for merging criteria.

In some embodiments the various clusters illustrated in can be shown as various numerical scores. For example the clusters in may be merged into five clusters as given below 

In some cases the clustering search results with the standard STC algorithm do not take into account other factors that may influence the quality of clusters. Using the STC algorithm the title text may be the only parameter for the clustering system. In some cases however the title information alone may not suffice for retrieving. Additional factors may need to be taken into consideration during the clustering process. For instance one factor to be used could be the demand factor which in one embodiment is the relationship of items and categories to the query terms. Other factors may include the price of the items the sellers feedback the categories into which the items belong and other suitable categories. These factors may be applied at any one of the stages of filtering out noise building an uncompacted trie e.g. data structure building a compacted trie e.g. data structure building the merged cluster map or even after these stages.

In some embodiments the demand factor indicates what buyers search for and click on based upon the search query. This factor may for example be applied during the filtering of noise data. The demand factor may be computed based upon the relationships of items and categories to query terms generated via for example a user s actions e.g. their selection by a user using a mouse or other input device Further the demand factor can play a role in improving the quality of clusters. Consider the following item listings 

Taken within the context of a search query demand data could be explained in the following manner. Given a query q we could classify the demand data relevant to q in two ways. For example if the query q is johnny depp the demand data could be gathered by examining contained and related queries. Contained queries may be all the demand data queries entered by users which have the query q contained in the queries. For example for a query johnny depp the contained queries can be johnny depp dvd johnny depp purse johnny depp doll johnny depp shirt and johnny depp photo.s By contrast related queries of query Q may be those queries entered by those users who searched for Q. Example related queries for johnny depp include Edward scissorhands and pirates of Caribbean signed poster. 

The below table shows the impact of the demand factor and its ability to help improve the quality of clusters.

In the above table the column on the left displays the clusters when the demand data is not taken into account while the column on the right displays the clusters when demand data is taken into account. Clusters like free ship ship fee size and super are all eliminated when the demand data is taken into account.

In some embodiments the demand factor and the relationship of items and categories to the query terms may be represented using one or more Artificial Intelligence AI based structures and algorithms. For example the relationship between an item and or category and a query term may be represented via a decision tree or bayesian network wherein the item and or category and query terms form nodes in this network that are connected with various weighted edges or links wherein the weights are probability values relating to the probability of a relationship between the item and or category and query terms. The nodes of the network may then be traversed based upon the weighted values expressed in the edges. Decision trees or bayesian networks are not the only type of AI based structure that may be employed for other types of AI structures and algorithms may be utilized to understand the relationship between the item and or category and query terms.

AI structures and the algorithms that underlie them used to ascertain a relationship between an item and or category and query terms fall into one of two categories deterministic or stochastic. Some example deterministic algorithms include case based reasoning the aforementioned bayesian networks including hidden markov models neural networks or fuzzy systems. The bayesian networks may include machine learning algorithms including supervised learning unsupervised learning semi supervised learning reinforcement learning transduction learning to learn algorithms or some other suitable bayesian network. The neural networks may include kohonen self organizing network recurrent networks simple recurrent networks Hopfield networks stochastic neural networks boltzmann machines modular neural networks committee of machines Associative Neural Network ASNN holographic associative memory instantaneously trained networks spiking neural networks dynamic neural networks cascading neural networks neuro fuzzy networks or some other suitable neural network. Example stochastic algorithms include genetic algorithms ant algorithms tabu search algorithms or monte carlo algorithms e.g. simulated annealing . Common to these algorithms is the use of randomness e.g. randomly generated numbers to avoid the problem of being unduly wedded to a local minima or maxima.

Some embodiments may include the use of a relevance weighting factor to generate a purely statistical measure to produce a list of keywords e.g. corresponding to a particular query that may appear in search results. This factor may for example be applied just before the generation of the merged cluster map. These keywords may be words that are extremely relevant or even totally irrelevant to a particular query. The resulting statistical measure or score is achieved by looking at among other things the historical information of the query terms typed by the user the set of results returned and the set of results that the user actually clicked through.

For example suppose that for the query term dell laptop the results returned included dell laptop bags dell laptop batteries dell laptop cases and dell laptop d410. If most users clicked on dell laptop d410 then d410 would be more relevant and the terms bags batteries and cases would be less relevant. And again if for example we were to search for Persian rugs a table could be generated containing a list of words with assigned weighting 

Additionally from the above table various conclusions can be drawn. First it can be inferred that the seller uses terms like Oriental and Italian to attract buyers but the buyer behavior states that these are less relevant to the term Persian Rugs. Moreover words with weights closer to 2 are words that are most relevant to the query and words with weighting lower than 1 are words that are irrelevant to the query. Here for the purpose of simplicity the relevance weights have been normalized to range from 0 to 2. Based on the above table we can say that words like antique knotted and rugs are indeed relevant to the query Persian Rugs. In some embodiments this form of weighting may be primarily used to filter out good search results from a pool of random results.

In some embodiments a factor that takes into account the overlap of sellers between clusters may enforce the sanctity or legitimacy of the merge. The use of seller information to influence the clustering process is based upon the assumption that sellers who sell similar items tend to appear in related clusters. For instance assume there are two base clusters in the merging phase e.g. when base clusters are identified with the tags ipod nano 4 gb and ipod nano 2 gb. Using the standard merge threshold e.g. 0.5 these two clusters may never have been merged if it didn t satisfy the basic merge criterion. Hence a second measure that takes into account the overlap of sellers between clusters may be needed to enforce this necessary underlying relationship. When the overlap of sellers between the two base clusters mentioned above is high e.g. 0.5 and the two base clusters have a reasonable merge score below the threshold we can then allow this merge which otherwise would have been declined but for the use of the seller factor.

Some embodiments may also use price to measure the effectiveness of a cluster. This factor may for example be applied just before the generation of the merged cluster map. For example in certain cases a fixed price exists for an item offered for sale e.g. a buy it now price . One purpose of this fixed price is to be able to purchase an item immediately without having to go through for example an auctioning process. Assuming an efficient market the buy it now price may be a reasonable price for that item. Applied to the clustering context assume we have a cluster that is solely related to ipod nano 4 gb black. If we take all the new items within this cluster intuitively the buy it now prices within this cluster should not vary beyond a certain point. Therefore by using a function of simple statistical measures like the mean mode and variance it may be possible to measure the cohesiveness of clusters. If in applying one of these measures the prices vary a little too much this is may be an indication of a bad cluster and the cluster may be dropped or discarded. Likewise if the function of the mean mode and variance indicate that the prices within the cluster are indeed consistent then this would be a signal of a tight cluster.

Example embodiments may also include a category factor wherein the association between items in a category in a database is taken into account when generating clusters. This factor may for example be applied just before the generation of the merged cluster map. For example while a seller mostly lists items under the correct category the complexity of the category structure and the seller s own motive might preclude items from going into the correct categories. Correctness here may be understood as based upon certain norms related to the categorization of items for sale. Here a category factor could be used to mean that items belong to the same category and to indicate that the items in the cluster are homogeneous.

In some embodiments items have images attached to them. Image similarity can be used as a factor for clustering. This factor may for example be applied just before the generation of the merged cluster map assuming for example that comparing similar items visually could also be a useful factor. Specifically the strength of a cluster e.g. the extent to which it is homogenous may be based upon a correspondence between the image of a query e.g. query and the images of the query results as existing in clusters.

In some embodiments an additional approach to multifactor clustering is implemented that supplements or in some cases replaces the multi factoring approach outlined above. This approach may be applied after for example a merged cluster map is built.

Some embodiments may include demand data that is utilized in an additional approach to improve the relevancy of clusters extracted and prune the irrelevant clusters or phrases for the given query Q e.g. query . In some cases there could be some phrases in the search results that occur frequently but might not be very relevant to the current input query from the user. These may need to be removed or pruned for such phrases may not be relevant to the current input query. One may for example compute a relevancy score for each cluster and keep those clusters that are appropriate for the current input query.

This concept of pruning may be illustrated in the following manner. For a phrase P several demand attributes may be used for demand factor analysis. These demand attributes are collected by aggregating activity of several users who searched for a keyword P. These activities may include 

Once the demand attribute data is collected a relevancy score may be computed. The relevancy score of a cluster may be computed to determine how relevant the cluster is with respect to a given input query. Several factors may be utilized to compute the relevancy score of a cluster including demand attributes and category histogram match score. The relevance score of cluster may be weighted over several such factors. In some embodiments the weights are normalized to a sum of one over all the factors involved e.g. 1 factors involved . New attributes can be added into the computation of relevancy score and the weights can be tuned so that appropriate relevancy can be achieved. For example the below equation illustrates how a relevancy score might be generated where C is the relevancy score CHMis a category match histogram score NBids is the number of bids VItemCounts is the number of views and w w and wrepresent a number of weighting factors together expressed as CHMBids ItemCounts such that 1 With regard to the CHM this score is may be computed to measure how closely the demand category histogram of the cluster C matches the supply category histogram of the original query Q. Several histogram distance measures may be used including Euclidean and intersection measures are analyzed and can be used to compute the category histogram match score.

In some embodiments a relevancy score may be computed for an example cluster such as is illustrated below 

In some embodiments the STC algorithm takes into account the order of the phrases when base clusters are formed. For example for a base cluster ipod nano only those items that have the exact phrase ipod nano in the same order are included in the clustering. However some sellers might enter the words ipod and nano in their listings but in different order and possibly separated by other words. Penalizing these items for not in the right order would affect the recall of the algorithm. On the other hand if we ignore the order of the words when the data is input to the algorithm a large number of low quality clusters would be output. Some embodiments may include taking into account the order of the words illustrating an item when the initial clusters are formed. Then however we explore the remaining unclustered documents and check if each of them can be added to the clusters formed by not taking the order of the words into account.

In some embodiments cluster labels are used to depict compact information about the type of documents present in the cluster. The labels may act as navigation criteria for the user . In one embodiment the cluster label acts as the label of the base cluster that contains the highest number of documents. In another embodiment the labeling of the cluster is performed using the most frequent phrases in the cluster.

In some embodiments the actual labeling is implemented using the Cluster Tags Extraction CLE approach or the Best Document Extraction CLE approach. In the CLEapproach an important multiple tags concepts within the cluster is applied while in the CLEapproach the best document e.g. a centroid or average that best represents the majority of the documents within the cluster is selected. As will be more fully illustrated below the terms frequency score density score and document score address how to compute different term statistics used to extract cluster labels. In contrast CLEand CLEaddress how to extract labels using these statistics.

Some embodiments may include defining the Cluster Term Frequency CTF of phrase p with respect to cluster C as the number of documents or titles that contain the phrase p. In some embodiments we would ignore common stop words and also duplicate occurrences of the same word or phrase in any document or title. Further a phrase p could be defined as strongly present in a cluster Cif the CTFof p is above a threshold F. The property of being strongly present is boolean e.g. a phrase is strongly present or not . Next we define the Term Density TD score of a phrase p as the number of clusters in which phrase p is strongly present.

Example embodiments may include defining a document score. Let us assume the document dof Cluster Chas a collection of m phrases P P . . . Pwhich are strongly present. A Cluster Document Score CDS of document dm with respect to cluster Ccould be defined as CDS w1 m w2 CTF P k 1 . . . m where w1 and w2 are pre chosen weights.

In some embodiments a CLEapproach is implemented wherein tags or phrases are extracted that represent important concepts within a cluster. Tags extracted this way may be used to navigate across the items within the cluster based on the chosen tags. Specifically for each cluster we extract all the strongly present phrases in the cluster in which a TD score is less than a threshold term density score Th . Thmay be defined as the NumOfClusters 4 e.g. we pick all the strongly present phrases in the cluster Cwhich are not present in more than Thof the clusters globally . In this way tags are identified that most represent a cluster in a way that it is reasonably distinguished from others.

A CLEapproach may be implemented in some embodiments where one would like to have the single best concept within the cluster rather than multiple tags that could occur within the cluster. The single best concept could be extracted by selecting the best document that best represents the majority of the other documents within the cluster. This may be accomplished in the following manner one could rank all the documents in the Cluster Cbased on document score e.g. creating a CDS value and picking the best document that has the highest document score. Next the cluster label of Cis picked as a sequence of all the strongly present phrases in the selected best document.

In some embodiments a mechanism is provided to measure and validate the clustering system. One measure that may be provided for evaluating the clustering system is to determine coverage and precision for the clustering system. For example one goal of the clustering system is to cluster as many of the results into clusters as possible coverage could be measured using the ratio of all those result items that belong to at least one cluster of size 1 to the total number of items in the result set. Further in an extreme situation one could define a single cluster with all the result documents in it to achieve coverage of 1.

Precision may be determined in some embodiments through approximations like cluster overlap or cluster independence. While the STC algorithm allows for overlapping clusters its also may facilitate the creation of clusters that are fairly unique in their theme. We can say that the cluster independence measure is high when we can separate out clusters through their distinction from others. One way to achieve high cluster independence is by putting each item in a separate cluster or by creating random buckets of clusters each of which has independent sets of items. Since our algorithm is designed with the sincere goal of achieving clustering based upon commonality of terms and other factors we can define a measure based upon how much clusters overlap.

For example given clusters C C . . . C where C 1 for all i i 1 . . . n we can say that we have good cluster separation if for any C Cwhere i j 1 n if C C . Since we have n clusters each pair C Cmakes a contribution into the overall measure. The contribution made by the pair is proportional to the size of the way we define cluster separation measure 1 C C CUC . Since there are combinations of pairs of the form C C we give each certain weight of contribution to the overall measure. This weight would be w CUC UC . Thus the overall cluster separation measure is given by w. JJ

In some embodiments cluster quality is an important measure. Cluster quality may be defined as follows. For each cluster we have defined cluster tags. Cluster tags aggregated define the theme of that cluster. If the cluster tags are fairly independent of each other that indicate that the cluster quality is good. If clusters are to be fairly separate in nature the tags defining the clusters should be fairly distinct. The overall cluster quality may be defined as 1 Ti Tj TiUTj for all i j. If there is no overlap in tags then cluster quality is 1. If cluster themes overlap then the tags are shared.

Some embodiments may include cluster quality as defined in terms of the category distribution of the items in a cluster. In some cases items in a cluster may be defined in a hierarchical category structure such that every item belongs to a leaf level category in this hierarchy. The actual category is chosen by the seller of the item. The categories themselves however may be pre defined. A seller may try his her best to put an item in the right leaf category. However items sometimes are wrongly listed either because the seller could not identify the right category or the seller deliberately incorrectly lists mislabels an item. Ignoring this factor e.g. incorrect lists mislabels if one were to look at the distribution of items within a cluster across categories it will give one an understanding of how well the items are clustered. To do this we would do the following. We would define the category entropy CE of cluster Cas CElog where wrepresents the weight of the category k w d Ndis the number of documents present in cluster Cthat belong to category k and Nis the total number of documents in the cluster C. One could define CE across all the clusters as the weighted entropy of the individual cluster category entropies CE CE A Three Tier Architecture

In some embodiments a method is illustrated as implemented in a distributed or non distributed software application designed under a three tier architecture paradigm whereby the various components of computer code that implement this method may be categorized as belonging to one or more of these three tiers. Some embodiments may include a first tier as an interface e.g. an interface tier that is relatively free of application processing. Further a second tier may be a logic tier that performs application processing in the form of logical mathematical manipulations of data inputted through the interface level and communicates the results of these logical mathematical manipulations to the interface tier and or to a backend or storage tier. These logical mathematical manipulations may relate to certain business rules or processes that govern the software application as a whole. A third storage tier may be a persistent storage medium or non persistent storage medium. In some cases one or more of these tiers may be collapsed into another resulting in a two tier architecture or even a one tier architecture. For example the interface and logic tiers may be consolidated or the logic and storage tiers may be consolidated as in the case of a software application with an embedded database. This three tier architecture may be implemented using one technology or as will be discussed below a variety of technologies. This three tier architecture and the technologies through which it is implemented may be executed on two or more computer systems organized in a server client peer to peer or so some other suitable configuration. Further these three tiers may be distributed between more than one computer system as various software components.

Some example embodiments may include the above illustrated tiers and their processes or operations as being written as one or more software components. Common to many of these components is the ability to generate use and manipulate data. These components and the functionality associated with each may be used by client server or peer computer systems. These various components may be implemented by a computer system on an as needed basis. These components may be written in an object oriented computer language such that a component oriented or object oriented programming technique can be implemented using a Visual Component Library VCL Component Library for Cross Platform CLX Java Beans JB Java Enterprise Beans EJB Component Object Model COM Distributed Component Object Model DCOM or other suitable technique. These components may be linked to other components via various APIs and then compiled into one complete server client and or peer software application. Further these APIs may be able to communicate through various distributed programming protocols as distributed computing components.

Some example embodiments may include remote procedure calls being used to implement one or more of the above illustrated components across a distributed programming environment as distributed computing components. For example an interface component e.g. an interface tier may reside on a first computer system that is remotely located from a second computer system containing a logic component e.g. a logic tier . These first and second computer systems may be configured in a server client peer to peer or some other suitable configuration. These various components may be written using the above illustrated object oriented programming techniques and can be written in the same programming language or different programming languages. Various protocols may be implemented to enable these various components to communicate regardless of the programming language used to write these components. For example an component written in C may be able to communicate with another component written in the Java programming language through utilizing a distributed computing protocol such as a Common Object Request Broker Architecture CORBA a Simple Object Access Protocol SOAP or some other suitable protocol. Some embodiments may include the use of one or more of these protocols with the various protocols outlined in the Open Systems Interconnection OSI model or Transmission Control Protocol Internet Protocol TCP IP protocol stack model for defining the protocols used by a network to transmit data.

Some embodiments may utilize the Open Systems Interconnection OSI model or the Transmission Control Protocol Internet Protocol TCP IP protocol stack model for defining the protocols used by a network to transmit data. In applying these models a system of data transmission between a server and client or between peer computer systems is illustrated as a series of roughly five layers comprising an application layer a transport layer a network layer a data link layer and a physical layer. In the case of software having a three tier architecture the various tiers e.g. the interface logic and storage tiers reside on the application layer of the TCP IP protocol stack. In an example implementation using the TCP IP protocol stack model data from an application residing at the application layer is loaded into the data load field of a TCP segment residing at the transport layer. This TCP segment also contains port information for a recipient software application residing remotely. This TCP segment is loaded into the data load field of an IP datagram residing at the network layer. Next this IP datagram is loaded into a frame residing at the data link layer. This frame is then encoded at the physical layer and the data transmitted over a network such as an internet LAN WAN or some other suitable network. In some cases internet refers to a network of networks. These networks may use a variety of protocols for the exchange of data including the aforementioned TCP IP and additionally ATM SNA SDI or some other suitable protocol. These networks may be organized within a variety of topologies e.g. a star topology or structures.

The example computer system includes a processor e.g. a Central Processing Unit CPU a Graphics Processing Unit GPU or both a main memory and a static memory which communicate with each other via a bus . The computer system may further include a video display unit e.g. a Liquid Crystal Display LCD or a Cathode Ray Tube CRT . The computer system also includes an alphanumeric input device e.g. a keyboard a User Interface UI cursor controller e.g. a mouse a disc drive unit a signal generation device e.g. a speaker and a network interface device e.g. a transmitter .

The disc drive unit includes a machine readable medium on which is stored one or more sets of instructions and data structures e.g. software embodying or utilized by any one or more of the methodologies or functions illustrated herein. The software may also reside completely or at least partially within the main memory and or within the processor during execution thereof by the computer system the main memory and the processor also constituting machine readable media.

The instructions may further be transmitted or received over a network via the network interface device utilizing any one of a number of well known transfer protocols e.g. HTTP SIP .

The term machine readable medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine readable medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any of the one or more of the methodologies illustrated herein. The term machine readable medium shall accordingly be taken to include but not be limited to solid state memories optical and magnetic medium and carrier wave signals.

A commercial website may have thousands if not millions of item descriptions e.g. item data . These descriptions may include title information advertisement information and other information generated to illustrate and categorize an item for sale on a website. One challenge that the owners of the website may face is to develop a way to allow for all these descriptions and associated information to be effectively searched. While increased computing power may be one solution another solution is to generate a more effective sorting and search algorithm. When determining what is an effective sorting and search algorithm one place to begin is with the data structure and the ability of that data structure to process a set of data. For the faster that the item data can be sorted and successfully searched the faster search results are returned. The faster search results are returned the more efficient and effective a website is viewed by users and customers.

In some embodiments efficient data structures are leveraged to generate aggregations of searchable item data using a suffix ordering. Once these data structures are generated then a user is free to conduct a string search looking for item data the matches their search query. Through using data structures having constant time O 1 or near constant time e.g. amortized O 1 performance search performance in conjunction with methods used to reduce item data redundancies a user may be provided with search results in a quick and efficient manner.

The Abstract of the Disclosure is provided to comply with 37 C.F.R. 1.72 b requiring an abstract that will allow the reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition in the foregoing Detailed Description it can be seen that various features are grouped together in a single embodiment for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separate embodiment.

