---

title: Methods and systems for parsing data objects
abstract: Methods and apparatuses for use in applying an update to a communication protocol in a software application that is executed by a computing device are described herein. The computing device receives a protocol definition corresponding to a communication protocol and indicating positions of data elements within data objects corresponding to the communication protocol. When the computing device determines that the received protocol definition differs from a previous protocol definition corresponding to the communication protocol, the computing device creates a machine-executable object parser based on the received protocol definition. The machine-executable object parser is accessible to a software application executed by the computing device. The software application receives a data object corresponding to the communication protocol, and the computing device executes the machine-executable object parser to parse at least a portion of the data elements in the data object received by the software application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09608893&OS=09608893&RS=09608893
owner: The Boeing Company
number: 09608893
owner_city: Chicago
owner_country: US
publication_date: 20120227
---
The field of the disclosure relates generally to parsing data objects and more specifically to automatic generation and execution of machine executable object parsers based on protocol definitions.

At least some known network protocol analysis tools allow a user to define protocols in a file e.g. text XML or binary or in a database. A message corresponding to a protocol may be parsed by interpreting the contents of the protocol definition file database. For example the protocol definition may define the offsets and sizes in bytes of fields in the data that make up a network protocol message. Each time a message is to be processed e.g. displayed the message and the protocol definition are parsed offsets are computed and data are extracted.

Another practice is to compile protocol parsing source code into pre compiled plug ins which eliminate the step of parsing the protocol definition each time a message is received but may be too inflexible for some uses. For example an end user may be unable to add a custom message or make any other change to the protocol definition. Rather to accommodate the desired change a software developer must create a new protocol parsing plug in by modifying the protocol parsing source code and compiling the modified source code into a plug in and distributing the plug in to the end user.

In one aspect a method for applying an update to a communication protocol in a software application executed by a computing device is provided. The method includes receiving by the computing device a protocol definition that corresponds to a communication protocol and indicates positions of data elements within data objects corresponding to the communication protocol. The computing device determines that the received protocol definition differs from a previous protocol definition corresponding to the communication protocol and based on the determined difference between the received protocol definition and the previous protocol definition creates a machine executable object parser based on the received protocol definition. The machine executable object parser is accessible to a software application executed by the computing device. The software application receives a data object corresponding to the communication protocol and the computing device executes the machine executable object parser to parse at least a portion of the data elements in the data object received by the software application.

In another aspect a system for applying an update to a communication protocol in a software application is provided. The system includes a memory for storing a first protocol definition corresponding to a communication protocol and a communications unit configured to receive a second protocol definition corresponding to the communication protocol. The second protocol definition indicates positions of data elements within data objects corresponding to the communication protocol. The system further includes a processor unit that is coupled to the memory and the communication interface. The processor is programmed to determine that the second protocol definition differs from the first protocol definition and based on the determined difference between the received protocol definition and the previous protocol definition create a machine executable object parser based on the second protocol definition. The machine executable object parser is accessible to a software application executed by the processor unit. The processor is also programmed to receive by the software application a data object corresponding to the communication protocol and to execute the machine executable object parser to parse at least a portion of the data elements in the data object received by the software application.

In yet another aspect a storage device having computer executable instructions embodied thereon is provided. When executed by a processor unit the computer executable instructions cause the processor unit to receive by the processor unit a protocol definition corresponding to a communication protocol. The received protocol definition indicates positions of data elements within data objects corresponding to the communication protocol. The computer executable instructions also cause the processor unit to determine by the processor unit that the received protocol definition differs from a previous protocol definition corresponding to the communication protocol and based on the determined difference between the received protocol definition and the previous protocol definition to create by the processor unit a machine executable object parser based on the received protocol definition. The machine executable object parser is accessible to a software application executed by the processor unit. The computer executable instructions also cause the processor unit to receive by the software application a data object corresponding to the communication protocol and to execute by the computing device the machine executable object parser to parse at least a portion of the data elements in the data object received by the software application.

The features functions and advantages that have been discussed can be achieved independently in various embodiments or may be combined in yet other embodiments further details of which can be seen with reference to the following description and drawings.

Methods and systems described herein enable communication protocol updates to be applied to a software application without requiring updates to the software application itself and without requiring a software developer to write custom source code. Instead a computing device may automatically create an object parser based on a protocol definition corresponding to a communication protocol and this object parser may be used to parse data elements within data objects corresponding to the communication protocol. Further when the protocol definition is modified a new version of the object parser may be automatically created providing support for the new protocol definition to the software application.

Exemplary embodiments are implemented using computing devices. is a block diagram of an exemplary computing device . In the exemplary embodiment computing device includes communications fabric that provides communications between a processor unit a memory persistent storage a communications unit an input output I O unit and a presentation interface such as a display . In addition or in the alternative the presentation interface may include an audio device not shown and or any device capable of conveying information to a user.

Processor unit executes instructions for software that may be loaded into a storage device e.g. memory . Processor unit may be a set of one or more processors or may include multiple processor cores depending on the particular implementation. Further processor unit may be implemented using one or more heterogeneous processor systems in which a main processor is present with secondary processors on a single chip. In another embodiment processor unit may be a homogeneous processor system containing multiple processors of the same type.

Memory and persistent storage are examples of storage devices. As used herein a storage device is any tangible piece of hardware that is capable of storing information either on a temporary basis and or a permanent basis. Memory may be for example without limitation a random access memory and or any other suitable volatile or non volatile storage device. Persistent storage may take various forms depending on the particular implementation and persistent storage may contain one or more components or devices. For example persistent storage may be a hard drive a flash memory a rewritable optical disk a rewritable magnetic tape and or some combination of the above. The media used by persistent storage also may be removable. For example without limitation a removable hard drive may be used for persistent storage .

A storage device such as memory and or persistent storage may be configured to store data for use with the processes described herein. For example a storage device may store e.g. have embodied thereon source code computer executable instructions software applications protocol definitions machine executable object parsers and or any other information suitable for use with the methods described herein. When executed by a processor e.g. processor unit computer executable instructions and or components cause the processor to perform one or more of the operations described herein.

Communications unit in these examples provides for communications with other computing devices or systems. In the exemplary embodiment communications unit is a network interface card. Communications unit may provide communications through the use of either or both physical and wireless communication links.

Input output unit enables input and output of data with other devices that may be connected to computing device . For example without limitation input output unit may provide a connection for user input through a user input device such as a keyboard and or a mouse. Further input output unit may send output to a printer. Display provides a mechanism to display information such as any information described herein to a user. For example a presentation interface such as display may display a graphical user interface such as those described herein.

Instructions for the operating system and applications or programs are located on persistent storage . These instructions may be loaded into memory for execution by processor unit . The processes of the different embodiments may be performed by processor unit using computer implemented instructions and or computer executable instructions which may be located in a memory such as memory . These instructions are referred to herein as program code e.g. object code and or source code that may be read and executed by a processor in processor unit . The program code in the different embodiments may be embodied on different physical or tangible computer readable media such as memory or persistent storage .

Program code is located in a functional form on non transitory computer readable media that is selectively removable and may be loaded onto or transferred to computing device for execution by processor unit . Program code and computer readable media form computer program product in these examples. In one example computer readable media may be in a tangible form such as for example an optical or magnetic disc that is inserted or placed into a drive or other device that is part of persistent storage for transfer onto a storage device such as a hard drive that is part of persistent storage . In a tangible form computer readable media also may take the form of a persistent storage such as a hard drive a thumb drive or a flash memory that is connected to computing device . The tangible form of computer readable media is also referred to as computer recordable storage media. In some instances computer readable media may not be removable.

Alternatively program code may be transferred to computing device from computer readable media through a communications link to communications unit and or through a connection to input output unit . The communications link and or the connection may be physical or wireless in the illustrative examples. The computer readable media also may take the form of non tangible media such as communications links or wireless transmissions containing the program code.

In some illustrative embodiments program code may be downloaded over a network to persistent storage from another computing device or computer system for use within computing device . For instance program code stored in a computer readable storage medium in a server computing device may be downloaded over a network from the server to computing device . The computing device providing program code may be a server computer a workstation a client computer or some other device capable of storing and transmitting program code .

Program code may be organized into computer executable components that are functionally related. For example program code may include one or more part agents ordering manager agents supplier agents and or any component suitable for practicing the methods described herein. Each component may include computer executable instructions that when executed by processor unit cause processor unit to perform one or more of the operations described herein.

The different components illustrated herein for computing device are not meant to provide architectural limitations to the manner in which different embodiments may be implemented. The different illustrative embodiments may be implemented in a computer system including components in addition to or in place of those illustrated for computing device . For example other components shown in can be varied from the illustrative examples shown.

As one example a storage device in computing device is any hardware apparatus that may store data. Memory persistent storage and computer readable media are examples of storage devices in a tangible form.

In another example a bus system may be used to implement communications fabric and may include one or more buses such as a system bus or an input output bus. Of course the bus system may be implemented using any suitable type of architecture that provides for a transfer of data between different components or devices attached to the bus system. Additionally a communications unit may include one or more devices used to transmit and receive data such as a modem or a network adapter. Further a memory may be for example without limitation memory or a cache such as that found in an interface and memory controller hub that may be present in communications fabric .

Computing device starts a software application such as by executing computer executable instructions associated with the software application. For example the software application may include a network analysis tool that parses and displays data objects transmitted over a network to which computing device is connected e.g. via communications unit .

Computing device examines the received protocol definition. In exemplary embodiments examining the protocol definition may include validating the protocol definition to ensure that the protocol definition is well formed complete and or parseable. If the validation fails an error may be reported. Otherwise method continues as described below. In other exemplary embodiments examining the protocol definition may also include determining that the received protocol definition corresponds to a protocol definition format and parsing the received protocol definition based on the protocol definition format.

Computing device determines whether a machine executable object parser corresponding to the communication protocol exists. For example computing device may determine whether an executable library such as a dynamic link library DLL or a dynamic shared object DSO corresponding to the communication protocol exists. If no such machine executable object parser exists computing device creates e.g. compiles a machine executable object parser based on the received protocol definition as described in more detail below with reference to . Machine executable object parser is accessible to one or more software applications executed by computing device . For example machine executable object parser may include one or more functions that a software application can invoke to parse a data object corresponding to the communication protocol.

If a machine executable object parser corresponding to the communication protocol already exists e.g. stored in memory and or persistent storage computing device determines whether the received protocol definition differs from e.g. is newer than the existing machine executable object parser and or newer than the protocol definition that corresponds to the existing machine executable object parser. In some embodiments computing device determines whether the received protocol definition is newer based on a write timestamp. For example computing device may determine that the received protocol definition is newer when the write timestamp associated with the received protocol definition is newer than the write timestamp associated with the existing machine executable object parser and or the protocol definition that corresponds to the existing machine executable object parser. In other embodiments computing device determines that the received protocol definition is newer when the content of the received protocol definition differs from the content of the previous protocol definition.

If the received protocol definition is newer the existing machine executable object parser and the protocol definition corresponding thereto are considered a previous and or superseded machine executable object parser and protocol definition respectively and computing device creates e.g. compiles a machine executable object parser based on the received protocol definition.

Computing device dynamically loads machine executable object parser into memory e.g. memory and analyzes or reflects on machine executable object parser to extract data structures and functions e.g. protocol types and data structure factories included in machine executable object parser . In exemplary embodiments machine executable object parser is created in the form of a dynamic linked library DLL and is loaded dynamically through the use of a standard operating system call such as Assembly.LoadFrom in the Microsoft Windows operating system. This is in contrast to DLLs that are loaded statically at application startup. Statically loaded DLLs are DLLs that were known at the time of the original compilation of the network analysis application compilation. Dynamically loaded DLLs are DLLs that the application and therefore its developers has no prior knowledge of prior to deployment. Accordingly new machine executable object parsers may be created and loaded for use with a software application without requiring any change to re compilation of or re linking of the software application itself.

Notably method creates machine executable object parser only when there is no existing machine executable object parser or the received protocol definition differs from the protocol definition corresponding to the existing machine executable object parser . The created machine executable object parser is thus stored and executed by the computing device in the manner more fully described herein with reference to until an updated protocol definition different from that stored on the computing device is received by the computing device . Method therefore avoids unnecessary processing e.g. re compiling the same machine executable object parser potentially decreasing the amount of time required to execute the software application.

In one exemplary embodiment some or all of Steps are repeated each time the application is started to determine whether there is no existing machine executable object parser or the received protocol definition differs from the protocol definition corresponding to the existing machine executable object parser .

Machine executable object parser may be created in a variety of manners. In some embodiments computing device converts the protocol definition directly to an intermediate language such as the Microsoft Intermediate Language which is common to the .NET development platform. This may be accomplished using the .NET Emit application programming interface API see http msdn.microsoft.com en us library 3y322t50.aspx . Converting the protocol definition into an intermediate language may allow the created code to be optimized because the most efficient intermediate language instructions can be selected during conversion . The intermediate language is written to the compiled protocol definition DLL just as if compiled using a standard software development environment like the Microsoft Visual Studio compiler.

Another option for creating the compiled protocol definition DLL is to first generate human readable source code based on the protocol definition in a language such as C and then provide the generated source code to a compiler e.g. the .NET compiler at runtime e.g. during execution of method shown in . An example of source code that computing device may generate based on the protocol definition in Listing 1 is shown in Listing 2 below.

In exemplary embodiments generated source code may be provided for compilation using the .NET CSharpCodeProvider see http msdn.microsoft.com en us library microsoft.csharp.csharpcodeprovider.aspx .

Notably the machine executable object parser may be created by the computing device without prompting a user of the computing device to approve the creation of the machine executable object parser.

Computing device executes machine executable object parser shown in to parse at least a portion of the data elements in the received data object. In exemplary embodiments machine executable object parser includes protocol message definitions and a data structure factory which computing device retrieves and executes using data structure factory to convert the raw binary data being read in from the network into protocol specific data structures.

Data structure factory includes machine executable code that determines the type of data contained in the received binary data. In an exemplary embodiment data structure factory processes the Distributed Interactive Simulation DIS IEEE 1278 protocol. In the DIS protocol the third byte of each protocol message identifies what the protocol message is. In this example the DIS data structure factory may implement a switch statement that would branch based on the protocol message type. For example a value of 1 could represent an Entity State message while a value of 2 could represent a Fire message and so on. If the raw binary data contained a value of 1 in byte position 3 then the DIS data structure factory would locate the class or type in protocol definitions that implements the Entity State DIS message instantiate an Entity State data structure in memory and then pass the raw binary data to the newly instantiated Entity State data structure for parsing and interpretation.

After the protocol specific data structure was instantiated and the raw binary data was processed in step the resulting data structure would be passed to the software application e.g. a network protocol analysis application . For example the software application may display the data structure to the user.

Using data structure factory and protocol definitions to create protocol specific data structures allows data received from the network to be parsed quickly and efficiently at runtime without the aid of lookup tables. Instead of computing offsets into an array of data the message data is converted to structured data in memory with all of the type safety that a modern computing language like C offers.

Referring again to the application reflects on the protocol specific data structures created in Step to determine the structure of the data or to retrieve discrete values from the data. This ability of the application to reflect relies on the underlying development environment to support reflection. Languages like C VB.NET and Java all support reflection. Reflection involves emitting type information about classes and objects to the executable files i.e. DLLs and making that information available at runtime for the purpose of querying data structures attributes and capabilities.

In exemplary embodiments when the protocol specific data structures created in Step are passed to the application for display the application can reflect on the data to determine the structure of the data or to retrieve discrete values from the data. For example commercial off the shelf COTS component libraries commonly use reflection to retrieve data for display. Embodiments of these component libraries include DevExpress Infragistics and ComponentOne. When these COTS component libraries display data in grid or graph form they commonly use reflection to retrieve the value of fields in a data structure. This is done to make the COTS components very flexible and allows these COTS components to work with data types which they know relatively nothing about. But by using reflection these COTS components can query a data structure that resides in memory and determine what properties or fields can be displayed whether the data is modifiable or not whether the data is nested or not the names and types of the data to be displayed and conversion routines for displaying data in textual form.

By carefully constructing the emitted intermediate language in Step or the source code in Step type metadata can be applied to help these COTS tools display the information contained in the custom data structures generated by protocol message definitions and data structure factory .

This means that an essential step to the support of graphing grouping sorting searching and filtering the data is in the form the intermediate or source language takes on. Thus the actual graphing grouping sorting searching and filtering is performed by the COTS components but this capability would not be possible without structuring the protocol data structures for use with these COTS components.

In one embodiment protocol loader is responsible for loading data into memory and making executable code available to the network analysis tool application. In this embodiment protocol loader employs a runtime linking methodology in which the module to be loaded is unknown at the time of the original compilation of the network analysis tool . This is accomplished by having the compiled protocol definition file built in conformance with a standard API that protocol loader supports. Thus a multitude of protocols that were completely unknown at the time of the original compilation of network analysis tool can be defined and loaded into network analysis tool via protocol loader .

In one embodiment network traffic parser is responsible for converting raw network traffic into protocol specific message types that break the raw data down into fundamental components i.e. integers floats strings flags and enumerations . Network traffic parser requests the parser from protocol loader and uses the requested parser to convert the raw network traffic into in memory protocol specific message types. All knowledge rules and instructions regarding how to convert the raw network data into an in memory format is handled by the parser which is ultimately defined in the compiled protocol definition file. Thus network traffic parser may simply pass the proper raw network traffic to the proper parser and collect the resulting in memory protocol specific data structures. In one embodiment user interface takes the in memory representation of the parsed network traffic and presents it to the user using standard rendering APIs provided by the operating system. In this embodiment the in memory representation of the parsed network traffic is handed off to either a display or analysis module for further processing of the parsed data.

In one embodiment protocol definition file loader is responsible for reading the contents of the input protocol definition file. The information in the input protocol definition files is read into memory and converted to a single in memory representation of a protocol definition. Protocol compiler converts the standard in memory representation of a protocol definition into executable form. In this embodiment protocol compiler is responsible for creating the output compiled protocol definition file. In this embodiment because protocol definition file loader converts the information in the input protocol definition files to a single in memory representation of a protocol definition the process of converting the standard in memory representation of a protocol definition into executable form is simplified as the executable code created by protocol compiler need only be written to read a single format.

This written description uses examples to disclose various embodiments which include the best mode to enable any person skilled in the art to practice those embodiments including making and using any devices or systems and performing any incorporated methods. The patentable scope is defined by the claims and may include other examples that occur to those skilled in the art. Such other examples are intended to be within the scope of the claims if they have structural elements that do not differ from the literal language of the claims or if they include equivalent structural elements with insubstantial differences from the literal languages of the claims.

