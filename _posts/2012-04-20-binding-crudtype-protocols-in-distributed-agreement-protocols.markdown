---

title: Binding crud-type protocols in distributed agreement protocols
abstract: Various embodiments enable redundant or replica services, such as “cloud” services, to be run at geographically distributed locations. Each replica is capable of performing operations that are generally, identically performed across all replicas. In the event of an interruption at one location, services in other locations can quickly and automatically take over operations. In one or more embodiments, a Distributed Agreement Protocol is utilized to bind a CRUD-type protocol as a state machine. Binding takes place through the use of a reverse proxy that is located at each of the locations at which the service is distributed. In at least some embodiments, the Distributed Agreement Protocol is implemented as the Paxos protocol or a variant thereof, and/or the CRUD-type protocol comprises the HTTP protocol.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09313252&OS=09313252&RS=09313252
owner: Microsoft Technology Licensing, LLC
number: 09313252
owner_city: Redmond
owner_country: US
publication_date: 20120420
---
Services that are offered over the Internet such as so called cloud services can suffer from interruptions which can degrade the user experience. In addition to degrading the user experience such interruptions can have a large organizational impact in terms of business cost such as actual money lost as well as loss of goodwill.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter.

Various embodiments enable redundant or replica services such as cloud services to be run at geographically distributed locations. Each replica is capable of performing operations that are generally identically performed across all replicas. In the event of an interruption at one location services in other locations can quickly and automatically take over operations.

In one or more embodiments a Distributed Agreement Protocol is utilized to bind a CRUD type protocol as a state machine. Binding takes place through the use of a reverse proxy that is located at each of the locations at which the service is distributed. In at least some embodiments the Distributed Agreement Protocol is implemented as the Paxos protocol or a variant thereof and or the CRUD type protocol comprises Hypertext Transport Protocol HTTP .

Various embodiments enable redundant or replica services such as cloud services to be run at geographically distributed locations. Each replica is capable of performing operations that are generally identically performed across all replicas. In the event of an interruption at one location services in other locations can quickly and automatically take over operations.

In one or more embodiments a Distributed Agreement Protocol is utilized to bind a CRUD type protocol as a state machine. Binding takes place through the use of a reverse proxy that is located at each of the locations at which the service is distributed. In at least some embodiments the Distributed Agreement Protocol is implemented as the Paxos protocol or a variant thereof and or the CRUD type protocol comprises Hypertext Transport Protocol HTTP . It is to be appreciated and understood however that the techniques described in this document can be employed in connection with any suitable stateless REST Representational State Transfer protocols. As will be appreciated by the skilled artisan REST defines a set of architectural principles by which web services can be designed to focus on a system s resources including how resource states are addressed and transferred over HTTP by a wide range of clients written in different languages. As will be appreciated by the skilled artisan REST type architectures are utilized in connection with clients and servers. Clients typically initiate requests to servers which then process the request and return appropriate responses. Requests and responses are built around the transfer of representations of resources. A resource can include any coherent and meaningful concept that may be addressed. A representation of a resource is typically a document that captures the current or intended state of a resource. The client initiates a communication by sending a request when it is ready to make a transition to a new state. While one or more requests are outstanding the client is considered to be in transition. The representation of each state can contain links that may be used next time the client chooses to initiate a new state transition.

In the following discussion an example environment is first described that may employ the techniques described herein. Example procedures are then described which may be performed in the example environment as well as other environments. Consequently performance of the example procedures is not limited to the example environment and the example environment is not limited to performance of the example procedures.

Computing device can be embodied as any suitable computing device such as by way of example and not limitation a desktop computer a portable computer a handheld computer such as a personal digital assistant PDA mobile phone television tablet computer and the like. One of a variety of different examples of a computing device is shown and described below in .

Applications can include any suitable type of applications. The web browser is configured to navigate via the network . Although the network is illustrated as the Internet the network may assume a wide variety of configurations. For example the network may include a wide area network WAN a local area network LAN a wireless network a public telephone network an intranet and so on. Further although a single network is shown the network may be configured to include multiple networks.

The browser may be configured to navigate via the network to interact with content available from one or more servers such as web servers as well as communicate data to the one or more servers e.g. perform downloads and uploads. The servers may be configured to provide one or more services such as web services also referred to as cloud services that are accessible via the network and can be consumed by computing device . Examples of such services include map services email web pages photo sharing sites social networks content sharing services media streaming services data retrieval and or displaying services and so on.

One or more of the applications may also be configured to access the network e.g. directly themselves and or through the browser. For example one or more of the applications may be configured to communicate messages such as email instant messages and so on. In additional examples an application for instance may be configured to access a social network obtain weather updates interact with a bookstore service implemented by one or more of the web servers support word processing provide spreadsheet functionality support creation and output of presentations and so on.

Thus applications may also be configured for a variety of functionality that may involve direct or indirect network access. For instance the applications may include configuration settings and other data that may be leveraged locally by the application as well as synchronized with applications that are executed on another computing device. In this way these settings may be shared by the devices. A variety of other instances are also contemplated. Thus the computing device may interact with content in a variety of ways from a variety of different sources.

In the illustrated and described embodiments servers can each support a web service which is a redundant web service. That is each redundant web service is a copy or replica of the other. These web services can be and typically are run or executed at geographically distributed locations. Each replica service is capable of performing operations that are generally identically performed across all replicas. In the event of an interruption at one location services in other locations can quickly and automatically take over operations.

In one or more embodiments a Distributed Agreement Protocol is utilized to bind a CRUD type protocol as a state machine. Binding takes place through the use of a reverse proxy that is located at each of the locations at which the service is distributed. In at least some embodiments the Distributed Agreement Protocol is implemented as the Paxos protocol or a variant thereof and or the CRUD type protocol comprises the HTTP protocol as will become apparent below.

Generally any of the functions described herein can be implemented using software firmware hardware e.g. fixed logic circuitry or a combination of these implementations. The terms module functionality and logic as used herein generally represent software firmware hardware or a combination thereof. In the case of a software implementation the module functionality or logic represents program code that performs specified tasks when executed on a processor e.g. CPU or CPUs . The program code can be stored in one or more computer readable memory devices. The features of the techniques described below are platform independent meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.

For example the computing device may also include an entity e.g. software that causes hardware or virtual machines of the computing device to perform operations e.g. processors functional blocks and so on. For example the computing device may include a computer readable medium that may be configured to maintain instructions that cause the computing device and more particularly the operating system and associated hardware of the computing device to perform operations. Thus the instructions function to configure the operating system and associated hardware to perform the operations and in this way result in transformation of the operating system and associated hardware to perform functions. The instructions may be provided by the computer readable medium to the computing device through a variety of different configurations.

One such configuration of a computer readable medium is signal bearing medium and thus is configured to transmit the instructions e.g. as a carrier wave to the computing device such as via a network. The computer readable medium may also be configured as a computer readable storage medium and thus is not a signal bearing medium. Examples of a computer readable storage medium include a random access memory RAM read only memory ROM an optical disc flash memory hard disk memory and other memory devices that may use magnetic optical and other techniques to store instructions and other data.

Having described an example environment consider now a discussion of Distributed Agreement Protocols DAPs and how such DAPs can be utilized with the CRUD type protocols such as the HTTP protocol to bind the CRUD type protocol as a state machine.

As information systems are more increasingly being shifted to distributed architectures because of the benefits like scalability autonomy and fault tolerance implied from the essence of the distributed systems the challenge of maintaining organization and synchronization within such distributed systems becomes more challenging. One goal of the distributed system is to have each processor or node that serves as a peer to efficiently and flexibly make an agreement on one common value which satisfies a particular agreement condition.

Distributed Agreement Protocols can be utilized in order to enable nodes within the distributed system to agree upon such common values in an efficient manner. One such Distributed Agreement Protocol is the Paxos protocol which is described just below. The Paxos protocol can be utilized in the various embodiments described in this document. It is to be appreciated and understood however that other Distributed Agreement Protocols can be utilized without departing from the spirit and scope of the claimed subject matter. For example one such Distributed Agreement Protocol is the Query Update Q U protocol as will be appreciated by the skilled artisan.

The following discussion describes the Paxos protocol in general as but one example of a Distributed Agreement Protocol that can be utilized to bind a CRUD type protocol e.g. HTTP as a state machine within the Paxos protocol.

The Paxos protocol is used to implement a fault tolerant distributed system. The discussion that follows explains the Paxos algorithm or protocol which is obtained by the application of consensus to the state machine approach for building a distributed system. Consider first the consensus algorithm in the context of a problem. Assume a collection of processes that can propose values. A consensus algorithm ensures that a single one among the proposed values is chosen. If no value is proposed then no value should be chosen. If a value has been chosen then processes should be able to learn the chosen value. The safety considerations for consensus are that 1 only a value that has been proposed may be chosen 2 only a single value is chosen and 3 a process never learns that a value has been chosen unless it actually has been. The goal is to ensure that some proposed value is eventually chosen and if a value has been chosen then a process can eventually learn the value.

Three roles in the consensus algorithm are performed by three classes of agents proposers acceptors and learners. In an implementation a single process may act as more than one agent. Assume also that agents can communicate with one another by sending messages. In the context of this discussion the customary asynchronous non Byzantine model is utilized in which 1 agents operate at arbitrary speed may fail by stopping and may restart since all agents may fail after a value is chosen and then restart a solution is impossible unless some information can be remembered by an agent that has failed and restarted and 2 messages can take arbitrarily long to be delivered can be duplicated and can be lost but they are not corrupted.

Consider now the notion of choosing a value. The easiest way to choose a value is to have a single acceptor agent. A proposer sends a proposal to the acceptor who chooses the first proposed value that it receives. Although simple this solution is unsatisfactory because the failure of the acceptor makes any further progress impossible. Instead of a single acceptor one can use multiple acceptor agents. A proposer sends a proposed value to a set of acceptors. An acceptor may accept the proposed value. The value is chosen when a large enough set of acceptors have accepted it. How large is large enough To ensure that only a single value is chosen one can let a large enough set consist of any majority of the agents. Because any two majorities have at least one acceptor in common this works if an acceptor can accept at most one value. In the absence of failure or message loss we want a value to be chosen even if only one value is proposed by a single proposer. This suggests the requirement 

However this requirement raises a problem. Several values could be proposed by different proposers at about the same time leading to a situation in which every acceptor has accepted a value but no single value is accepted by a majority of them. Even with just two proposed values if each is accepted by about half the acceptors failure of a single acceptor could make it impossible to learn which of the values was chosen.

P1 and the requirement that a value is chosen only when it is accepted by a majority of acceptors imply that an acceptor must be allowed to accept more than one proposal. To allow this we keep track of the different proposals that an acceptor may accept by assigning a natural number to each proposal so a proposal consists of a proposal number and a value. To prevent confusion we require that different proposals have different numbers. How this is achieved depends on the implementation so for discussion purposes now we just assume it. A value is chosen when a single proposal with that value has been accepted by a majority of the acceptors. In that case we say that the proposal as well as its value has been chosen.

We can allow multiple proposals to be chosen but we must guarantee that all chosen proposals have the same value. By induction on the proposal number it suffices to guarantee 

P2. If a proposal with value v is chosen then every higher numbered proposal that is chosen has value v.

Since numbers are totally ordered condition P2 guarantees the safety property that only a single value is chosen.

To be chosen a proposal must be accepted by at least one acceptor. So we can satisfy P2 by satisfying 

P2. If a proposal with value v is chosen then every higher numbered proposal accepted by any acceptor has value v.

We still maintain P1 to ensure that some proposal is chosen. Because communication is asynchronous a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer wakes up and issues a higher numbered proposal with a different value. P1 requires c to accept this proposal violating P2. Maintaining both P1 and P2requires strengthening P2to 

P2. If a proposal with value v is chosen then every higher numbered proposal issued by any proposer has value v.

Since a proposal must be issued by a proposer before it can be accepted by an acceptor P2b implies P2a which in turn implies P2.

To discover how to satisfy P2b let s consider how we would prove that it holds. We would assume that some proposal with number m and value v is chosen and show that any proposal issued with number n m also has value v. We would make the proof easier by using induction on n so we can prove that proposal number n has value v under the additional assumption that every proposal issued with a number in m . . . n 1 has value v where i . . . j denotes the set of numbers from i through j. For the proposal numbered m to be chosen there must be some set C consisting of a majority of acceptors such that every acceptor in C accepted it. Combining this with the induction assumption the hypothesis that m is chosen implies 

Since any set S consisting of a majority of acceptors contains at least one member of C we can conclude that a proposal numbered n has value v by ensuring that the following invariant is maintained 

P2. For any v and n if a proposal with value v and number n is issued then there is a set S consisting of a majority of acceptors such that either a no acceptor in S has accepted any proposal numbered less than n or b v is the value of the highest numbered proposal among all proposals numbered less than n accepted by the acceptors in S.

To maintain the invariance of P2 a proposer that wants to issue a proposal numbered n must learn the highest numbered proposal with number less than n if any that has been or will be accepted by each acceptor in some majority of acceptors. Learning about proposals already accepted is easy enough predicting future acceptances is hard. Instead of trying to predict the future the proposer controls it by extracting a promise that there will not be any such acceptances. In other words the proposer requests that the acceptors not accept any more proposals numbered less than n. This leads to the following algorithm for issuing proposals.

A proposer issues a proposal by sending to some set of acceptors a request that the proposal be accepted. This need not be the same set of acceptors that responded to the initial requests. This will be referred to as an accept request.

An acceptor can receive two kinds of requests from proposers prepare requests and accept requests. An acceptor can ignore any request without compromising safety. So we need to say only when it is allowed to respond to a request. It can always respond to a prepare request. It can respond to an accept request accepting the proposal if and only if it has not promised not to. In other words 

P1. An acceptor can accept a proposal numbered n iff it has not responded to a prepare request having a number greater than n.

Observe that P1subsumes P1. We now have a complete algorithm for choosing a value that satisfies the required safety properties assuming unique proposal numbers. The final algorithm is obtained by making one small optimization. Suppose an acceptor receives a prepare request numbered n but it has already responded to a prepare request numbered greater than n thereby promising not to accept any new proposal numbered n. There is then no reason for the acceptor to respond to the new prepare request since it will not accept the proposal numbered n that the proposer wants to issue. So we have the acceptor ignore such a prepare request. We also have it ignore a prepare request for a proposal it has already accepted.

With this optimization an acceptor needs to remember only the highest numbered proposal that it has ever accepted and the number of the highest numbered prepare request to which it has responded. Because P2must be kept invariant regardless of failures an acceptor must remember this information even if it fails and then restarts. Note that the proposer can always abandon a proposal and forget all about it as long as it never tries to issue another proposal with the same number.

Putting the actions of the proposer and acceptor together we see that the algorithm operates in the following two phases.

A proposer can make multiple proposals so long as it follows the algorithm for each one. It can abandon a proposal in the middle of the protocol at any time. Correctness is maintained even though requests and or responses for the proposal may arrive at their destinations long after the proposal was abandoned. It is probably a good idea to abandon a proposal if some proposer has begun trying to issue a higher numbered one. Therefore if an acceptor ignores a prepare or accept request because it has already received a prepare request with a higher number then it should probably inform the proposer who should then abandon its proposal. This is a performance optimization that does not affect correctness.

Consider now the notion of learning a chosen value. To learn that a value has been chosen a learner finds out that a proposal has been accepted by a majority of acceptors. One way to do so is to have each acceptor whenever it accepts a proposal respond to all learners sending them the proposal. This allows learners to find out about a chosen value as soon as possible but it requires each acceptor to respond to each learner a number of responses equal to the product of the number of acceptors and the number of learners.

The assumption of non Byzantine failures makes it easy for one learner to find out from another learner that a value has been accepted. We can have the acceptors respond with their acceptances to a distinguished learner which in turn informs the other learners when a value has been chosen. This approach requires an extra round for all the learners to discover the chosen value. It is also less reliable since the distinguished learner could fail. But it requires a number of responses equal only to the sum of the number of acceptors and the number of learners.

More generally the acceptors could respond with their acceptances to some set of distinguished learners each of which can then inform all the learners when a value has been chosen. Using a larger set of distinguished learners provides greater reliability at the cost of greater communication complexity.

Because of message loss a value could be chosen with no learner ever finding out. The learner could ask the acceptors what proposals they have accepted but failure of an acceptor could make it impossible to know whether or not a majority had accepted a particular proposal. In that case learners will find out what value is chosen only when a new proposal is chosen. If a learner needs to know whether a value has been chosen it can have a proposer issue a proposal using the algorithm described above.

Consider now the issue of progress and how to guarantee that progression of the algorithm proceeds in a productive way. Consider a scenario in which two proposers each keep issuing a sequence of proposals with increasing numbers none of which are ever chosen. Proposer p completes phase 1 for a proposal number n. Another proposer q then completes phase 1 for a proposal number n n. Proposer p s phase 2 accept requests for a proposal numbered nare ignored because the acceptors have all promised not to accept any new proposal numbered less than n. So proposer p then begins and completes phase 1 for a new proposal number n n causing the second phase 2 accept requests of proposer q to be ignored and so on.

To guarantee progress a distinguished proposer is selected as the only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors and if it uses a proposal with number greater than any already used then it will succeed in issuing a proposal that is accepted. By abandoning a proposal and trying again if it learns about some request with a higher proposal number the distinguished proposer will eventually choose a high enough proposal number.

If enough of the system proposer acceptors and communication network is working properly liveness can therefore be achieved by electing a single distinguished proposer. A reliable algorithm for electing a proposer can use either randomness or real time for example by using timeouts. However safety is ensured regardless of the success or failure of the election.

Consider now some implementation issues. The Paxos algorithm assumes a network of processes. In its consensus algorithm each process plays the role of proposer acceptor and learner. The algorithm chooses a leader which plays the roles of the distinguished proposer and the distinguished learner. The Paxos consensus algorithm is the one described above where requests and responses are sent as ordinary messages. Response messages are tagged with the corresponding proposal number to prevent confusion. Stable storage preserved during failures is used to maintain the information that the acceptor is to remember. An acceptor records its intended response in stable storage before actually sending the response.

All that remains is to describe the mechanism for guaranteeing that no two proposals are ever issued with the same number. Different proposers choose their numbers from disjoint sets of numbers so two different proposers never issue a proposal with the same number. Each proposer remembers in stable storage the highest numbered proposal it has tried to issue and begins phase 1 with a higher proposal number than any it has already used.

One way to implement a distributed system is as a collection of clients that issue commands to a central server. The server can be described as a deterministic state machine that performs client commands in some sequence. The state machine has a current state it performs a step by taking as input a command and producing an output and a new state. For example the clients of a distributed banking system might be tellers and the state machine state might consist of the account balances of all users. A withdrawal would be performed by executing a state machine command that decreases an account s balance if and only if the balance is greater than the amount withdrawn producing as output the old and new balances. An implementation that uses a single central server fails if that server fails. We therefore instead use a collection of servers each one independently implementing the state machine. Because the state machine is deterministic all the servers will produce the same sequences of states and outputs if they all execute the same sequence of commands. A client issuing a command can then use the output generated for it by any server.

To guarantee that all servers execute the same sequence of state machine commands we implement a sequence of separate instances of the Paxos consensus algorithm the value chosen by the iinstance being the istate machine command in the sequence. Each server plays all the roles proposer acceptor and learner in each instance of the algorithm. For purposes of this example assume that the set of servers is fixed so all instances of the consensus algorithm use the same sets of agents.

In normal operation a single server is elected to be the leader which acts as the distinguished proposer i.e. the only one that tries to issue proposals in all instances of the consensus algorithm. Clients send commands to the leader who decides where in the sequence each command should appear. If the leader decides that a certain client command should be the 135command it tries to have that command chosen as the value of the 135instance of the consensus algorithm. It will usually succeed. It might fail because of failures or because another server also believes itself to be the leader and has a different idea of what the 135command should be. But the consensus algorithm ensures that at most one command can be chosen as the 135one.

The efficiency of this approach is enhanced in the Paxos consensus algorithm because the value to be proposed is not chosen until phase 2. Recall that after completing phase 1 of the proposer s algorithm either the value to be proposed is determined or else the proposer is free to propose any value.

Consider now how the Paxos state machine implementation works during normal operation. Consider what happens when the previous leader has just failed and a new leader has been selected. The new leader being a learner in all instances of the consensus algorithm should know most of the commands that have already been chosen. Suppose it knows commands 1 134 138 and 139 that is the values chosen in instances 1 134 138 and 139 of the consensus algorithm. It then executes phase 1 of instances 135 137 and of all instances greater than 139. Suppose that the outcome of these executions determine the value to be proposed in instances 135 and 140 but leaves the proposed value unconstrained in all other instances. The leader then executes phase 2 for instances 135 and 140 thereby choosing commands 135 and 140.

The leader as well as any other server that learns all the commands the leader knows can now execute commands 1 135. However it cannot execute commands 138 140 which it also knows because commands 136 and 137 have yet to be chosen. The leader could take the next two commands requested by clients to be commands 136 and 137. Instead we let it fill the gap immediately by proposing as commands 136 and 137 a special noop command that leaves the state unchanged. It does this by executing phase 2 of instances 136 and 137 of the consensus algorithm. Once these noop commands have been chosen commands 138 140 can be executed.

Commands 1 140 have now been chosen. The leader has also completed phase 1 for all instances greater than 140 of the consensus algorithm and it is free to propose any value in phase 2 of those instances. It assigns command number 141 to the next command requested by a client proposing it as the value in phase 2 of instance 141 of the consensus algorithm. It proposes the next client command it receives as command 142 and so on.

The leader can propose command 142 before it learns that its proposed command 141 has been chosen. It is possible for all the messages it sent in proposing command 141 to be lost and for command 142 to be chosen before any other server has learned what the leader proposed as command 141. When the leader fails to receive the expected response to its phase 2 messages in instance 141 it will retransmit those messages. If all goes well its proposed command will be chosen. However it could fail first leaving a gap in the sequence of chosen commands. In general suppose a leader can get a commands ahead that is it can propose commands i 1 through i after commands 1 through i are chosen. A gap of up to 1 commands could then arise.

A newly chosen leader executes phase 1 for infinitely many instances of the consensus algorithm in the scenario above for instances 135 137 and all instances greater than 139. Using the same proposal number for all instances it can do this by sending a single reasonably short message to the other servers. In phase 1 an acceptor responds with more than a simple OK only if it has already received a phase 2 message from some proposer. In the scenario this was the case only for instances 135 and 140. Thus a server acting as acceptor can respond for all instances with a single reasonably short message. Executing these infinitely many instances of phase 1 therefore poses no problem.

Since failure of the leader and election of a new one should be rare events the effective cost of executing a state machine command that is of achieving consensus on the command value is the cost of executing only phase 2 of the consensus algorithm. It can be shown that phase 2 of the Paxos consensus algorithm has the minimum possible cost of any algorithm for reaching agreement in the presence of faults. Hence the Paxos algorithm is essentially optimal.

This discussion of the normal operation of the system assumes that there is always a single leader except for a brief period between the failure of the current leader and the election of a new one. In abnormal circumstances the leader election might fail. If no server is acting as leader then no new commands will be proposed. If multiple servers think they are leaders then they can all propose values in the same instance of the consensus algorithm which could prevent any value from being chosen. However safety is preserved two different servers will never disagree on the value chosen as the istate machine command. Election of a single leader is needed only to ensure progress.

If the set of servers can change then there must be some way of determining what servers implement what instances of the consensus algorithm. The easiest way to do this is through the state machine itself. The current set of servers can be made part of the state and can be changed with ordinary state machine commands. We can allow a leader to get commands ahead by letting the set of servers that execute instance i of the consensus algorithm be specified by the state after execution of the istate machine command. This permits a simple implementation of an arbitrarily sophisticated reconfiguration algorithm.

The above discussion constitutes a description of how the Paxos algorithm can be utilized to implement a fault tolerant distributed system. The Paxos protocol includes other family members or variants that can be utilized in connection with the embodiments described herein. These other family members include by way of example and not limitation so called Multi Paxos Cheap Paxos Fast Paxos and Byzantine Paxos. These other family members can be utilized in the various embodiments described below.

Having discussed Distributed Agreement Protocols and given an example of a specific protocol i.e. the Paxos Protocol and its related family members consider now a brief discussion of CRUD Create Read Update Delete protocols and in particular the Hypertext Transport Protocol HTTP .

CRUD Create Read Update Delete protocols refer to a family of protocols that allow for the creation reading updating and deletion of resources. One type of a CRUD protocol is the Hypertext Transfer Protocol HTTP . The Hypertext Transfer Protocol HTTP is an application protocol for distributed collaborative hypermedia information systems and is the foundation of data communication for the World WideWeb.

HTTP functions as a request response protocol in the client server computing model. In HTTP a web browser for example acts as a client while an application running on a computer hosting a web site functions as a server. The client submits an HTTP request message to the server. The server which stores content or provides resources such as HTML files or performs on behalf of the client returns a response message to the client. A response contains completion status information about the request and may contain any content requested by the client in its message body.

A web browser or client is often referred to as a user agent UA . Other user agents can include the indexing software used by search providers known as web crawlers or variations of the web browser such as voice browsers which present an interactive voice user interface.

HTTP is an Application Layer protocol designed within the framework of the Internet Protocol Suite. The protocol definitions presume a reliable Transport Layer protocol for host to host data transfer. The Transmission Control Protocol TCP is the dominant protocol in use for this purpose. However HTTP can be used with other protocols such as the User Datagram Protocol UDP and methods such as the Simple Service Discovery Protocol SSDP .

HTTP Resources are identified and located on the network by Uniform Resource Identifiers URIs or more specifically Uniform Resource Locators URLs using the http or https URI schemes. URIs and the Hypertext Markup Language HTML form a system of inter linked resources called hypertext documents on the Internet.

An HTTP session is a sequence of network request response transactions. An HTTP client initiates a request by establishing a Transmission Control Protocol TCP connection to a particular port on a server. An HTTP server listening on that port waits for a client s request message. Upon receiving the request the server sends back a status line such as an HTTP 200 OK and a message of its own. The body of this message is typically the requested resource although an error message or other information may also be returned.

HTTP defines nine methods sometimes referred to as verbs indicating the desired action to be performed on the identified resource. What this resource represents whether pre existing data or data that is generated dynamically depends on the implementation of the server. Often the resource corresponds to a file or the output of an executable residing on the server.

Having discussed various aspects of the HTTP protocol consider now how CRUD type protocols can be bound as a state machine utilizing a Distributed Agreement Protocol.

In this example computing device communicates via network with one or more servers . Any suitable protocol can be utilized to enable computing device to communicate with servers . In the illustrated and described embodiment communication can take place utilizing a CRUD type protocol. In a specific implementation the CRUD type protocol comprises HTTP.

Each server in this particular example includes a reverse proxy . The reverse proxy implements an instance of a Distributed Agreement Protocol DAP which resides in the form of DAP module . In addition each server implements one or more web services here represented by service such as a web or cloud service. Each service implemented by the individual servers constitutes a replica or redundant service.

In operation each server constitutes a node in a distributed system in which service is offered. Typically although not always the servers are geographically distributed at different physical locations. For example the individual servers might comprise servers that are located in data centers across a particular country or distributed throughout the world. Alternately the servers might constitute individual blade servers in a single rack. Each server through its DAP module runs in instance of a Distributed Agreement Protocol. In at least some embodiments the Distributed Agreement Protocol comprises the Paxos protocol.

Using a CRUD type protocol such as HTTP the computing device issues operations using for example verbs associated with a particular protocol. In the context of HTTP such verbs can include GET PUT POST PATCH DELETE and the like. The client computing device can communicate with any node i.e. server in the distributed system. As the server receives the operations from the computing device it captures the operations and utilizing the DAP module chooses an ordering for them. Specifically using the Distributed Agreement Protocol communication takes place between the reverse proxies on each server. Through the communication between the servers the Distributed Agreement Protocol is utilized to come to a consensus as to the ordering of operations that are to be performed.

Once the order of operations has been agreed upon utilizing for example the Paxos protocol described above each node i.e. server can execute the operations in the agreed upon order in the context of service . In this manner the CRUD type protocol which in this instance is HTTP is bound as a state machine using the Distributed Agreement Protocol.

In essence then the Distributed Agreement Protocol enables receipt of operations from various clients that can be widely distributed. The operations can arrive in any arbitrary order and can be associated with any service i.e. cloud service . Using the Distributed Agreement Protocol a server can construct a sequential ordering of operations as between multiple different servers that ensures that the same sequential ordering across all of the servers or nodes is the same. As a result each node will be in the same state with respect operations that are to be or have been performed.

Utilizing the Distributed Agreement Protocol in connection with web services that are implemented using a CRUD type protocol can facilitate operation when for example individual nodes or servers within a distributed system may become inoperative.

As an example of a web service that can be implemented using the techniques described above consider a web service that maintains a contact list for individual users. In this particular contact list service a user can insert a new contact view contacts update contacts and delete contacts. Assume also that the contact list service is implemented in a distributed fashion using servers such as those servers described above. Assume also that the user can interact with the contact list service using multiple different types of client devices. For example for example a user may want interact with the contact list service to the personal computer their phone a web browser or any type of client.

In order to interact with their particular contact list the client device issues operations in the form of HTTP verbs. For example if a user wishes to view all of their contacts through a suitably configured user interface the user would cause an HTTP GET operation to be issued. Similarly to update a contact an HTTP MERGE operation would be issued. Deleting a contact would occur through an HTTP DELETE operation and inserting a new contact would occur through issuance of a POST operation.

Because the contact list service is implemented in a distributed fashion on multiple different servers when operations are issued by a client device the Distributed Agreement Protocol executed by each server or more accurately by the reverse proxy on each server ensures that an agreed upon order of operations occurs on each server. In this manner a user s contact list can remain synchronized across nodes i.e. servers in the distributed system.

Having considered how a CRUD type protocol can be bound as a state machine using a Distributed Agreement Protocol consider now an example method in accordance with one or more embodiments.

Step issues an operation associated with a web service. Any suitable operation can be issued in connection with any suitable web service. In at least some embodiments the operation is associated with a CRUD type operation. In a specific implementation the operation is associated with an HTTP operation such as those described above. Step communicates the operation to a RESTful Web server i.e. one that conforms to or utilizes a RESTful protocol such as a CRUD type protocol. In the illustrated and described embodiment the web server implements the web service and comprises part of a distributed system in which one or more other Web servers implement a redundant or replica of the web service.

Step intercepts or receives the communication to the RESTful Web server. As noted above this step can be performed by a suitably configured reverse proxy. In the illustrated and described embodiment the reverse proxy supports or is otherwise configured to utilize a Distributed Agreement Protocol such as those mentioned above. In a specific implementation the Distributed Agreement Protocol comprises the Paxos protocol. Step initiates the Distributed Agreement Protocol with one or more nodes. This step can be performed in any suitable way. In the illustrated and described embodiment each node corresponds to another RESTful Web server that implements the redundant web service mentioned above. Step utilizes the Distributed Agreement Protocol to arrive at a consensus relative to the operation. Utilization of the Distributed Agreement Protocol can take place through intra communication between the various servers that support or expose redundant web service. Examples of such intra communication are provided above. Having arrived at a consensus using the Distributed Agreement Protocol step performs or enables performance of an associated operation. Performance of the operation occurs in the order as ascertained through the consensus between the RESTful Web servers or more accurately the reverse proxies utilized by each Web server. Having performed the operation step returns a suitable response to the client device. Any suitable response can be returned. In at least some embodiments the response that is returned resides in the form of an HTTP response.

Utilizing the above described methodology state can be maintained between multiple different servers that implement a redundant web service. Through the use of the Distributed Agreement Protocol in conjunction with the RESTful type protocol e.g. the CRUD type protocol RESTful Web servers can be operated in lock step so as to preserve state and remain synchronized with respect to operations that are performed across the Web servers.

Having considered various embodiments consider now an example system and device that can be utilized to implement the embodiments described above.

In the example system multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network the Internet or other data communication link. In one embodiment this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features types of usage or other common characteristics of the devices.

In various implementations the computing device may assume a variety of different configurations such as for computer mobile and television uses. Each of these configurations includes devices that may have generally different constructs and capabilities and thus the computing device may be configured according to one or more of the different device classes. For instance the computing device may be implemented as the computer class of a device that includes a personal computer desktop computer a multi screen computer laptop computer netbook and so on. Each of these different configurations may employ the techniques described herein as illustrated through inclusion of the application s Web browser and operating system .

The computing device may also be implemented as the mobile class of device that includes mobile devices such as a mobile phone portable music player portable gaming device a tablet computer a multi screen computer and so on. The computing device may also be implemented as the television class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions set top boxes gaming consoles and so on. The techniques described herein may be supported by these various configurations of the computing device and are not limited to the specific examples the techniques described herein.

The cloud includes and or is representative of a platform for content services . The platform abstracts underlying functionality of hardware e.g. servers and software resources of the cloud . The content services may include applications and or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Content services e.g. cloud services or web services can be provided as a service over the Internet and or through a subscriber network such as a cellular or Wi Fi network.

The platform may abstract resources and functions to connect the computing device with other computing devices. The platform may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the content services that are implemented via the platform . Accordingly in an interconnected device embodiment implementation of functionality described herein may be distributed throughout the system . For example the functionality may be implemented in part on the computing device as well as via the platform that abstracts the functionality of the cloud .

Device also includes communication interfaces that can be implemented as any one or more of a serial and or parallel interface a wireless interface any type of network interface a modem and as any other type of communication interface. The communication interfaces provide a connection and or communication links between device and a communication network by which other electronic computing and communication devices communicate data with device .

Device includes one or more processors e.g. any of microprocessors controllers and the like which process various computer executable instructions to control the operation of device and to implement embodiments of the techniques described herein. Alternatively or in addition device can be implemented with any one or combination of hardware firmware or fixed logic circuitry that is implemented in connection with processing and control circuits which are generally identified at . Although not shown device can include a system bus or data transfer system that couples the various components within the device. A system bus can include any one or combination of different bus structures such as a memory bus or memory controller a peripheral bus a universal serial bus and or a processor or local bus that utilizes any of a variety of bus architectures.

Device also includes computer readable media such as one or more memory components examples of which include random access memory RAM non volatile memory e.g. any one or more of a read only memory ROM flash memory EPROM EEPROM etc. and a disk storage device. A disk storage device may be implemented as any type of magnetic or optical storage device such as a hard disk drive a recordable and or rewriteable compact disc CD any type of a digital versatile disc DVD and the like. Device can also include a mass storage media device .

Computer readable media provides data storage mechanisms to store the device data as well as various device applications and any other types of information and or data related to operational aspects of device . For example an operating system can be maintained as a computer application with the computer readable media and executed on processors . The device applications can include a device manager e.g. a control application software application signal processing and control module code that is native to a particular device a hardware abstraction layer for a particular device etc. . The device applications also include any system components or modules to implement embodiments of the techniques described herein. In this example the device applications include an interface application and an input output module that are shown as software modules and or computer applications. The input output module is representative of software that is used to provide an interface with a device configured to capture inputs such as a touchscreen track pad camera microphone and so on. Alternatively or in addition the interface application and the input output module can be implemented as hardware software firmware or any combination thereof. Additionally the input output module may be configured to support multiple input devices such as separate devices to capture visual and audio inputs respectively.

Device also includes an audio and or video input output system that provides audio data to an audio system and or provides video data to a display system . The audio system and or the display system can include any devices that process display and or otherwise render audio video and image data. Video signals and audio signals can be communicated from device to an audio device and or to a display device via an RF radio frequency link S video link composite video link component video link DVI digital video interface analog audio connection or other similar communication link. In an embodiment the audio system and or the display system are implemented as external components to device . Alternatively the audio system and or the display system are implemented as integrated components of example device .

Various embodiments enable redundant or replica services such as cloud services to be run at geographically distributed locations. Each replica is capable of performing operations that are generally identically performed across all replicas. In the event of an interruption at one location services in other locations can quickly and automatically take over operations.

In one or more embodiments a Distributed Agreement Protocol is utilized to bind a CRUD type protocol as a state machine. Binding takes place through the use of a reverse proxy that is located at each of the locations at which the service is distributed. In at least some embodiments the Distributed Agreement Protocol is implemented as the Paxos protocol or a variant thereof and or the CRUD type protocol comprises the HTTP protocol.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

