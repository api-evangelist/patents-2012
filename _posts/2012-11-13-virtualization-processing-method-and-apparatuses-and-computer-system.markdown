---

title: Virtualization processing method and apparatuses, and computer system
abstract: A virtualization processing method and apparatuses, and a computer system are provided. Where a computing node includes: a hardware layer, a Host running on the hardware layer, and at least one virtual machine (VM) running on the Host, the hardware layer includes an I/O device, several corresponding virtual function (VF) devices are virtualized from the I/O device, the Host has several VF software instances, the several VF software instances and the several VF devices are in one-to-one correspondence; the Host further has a back-end instance (BE) of an I/O virtual device having the same type with the I/O device, the VM has a front-end instance (FE) of the I/O virtual device; the BE in the Host is bound with an idle VF software instance. The solutions of the embodiments of the present invention are beneficial to optimization of the performance and compatibility of a virtualization system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08635616&OS=08635616&RS=08635616
owner: Hauwei Technologies Co., Ltd.
number: 08635616
owner_city: Shenzhen
owner_country: CN
publication_date: 20121113
---
This application is a continuation of International Patent Application No. PCT CN2012 075846 filed on May 22 2012 which claims priority to Chinese Patent Application No. 201110458345.8 filed on Dec. 31 2011 both of which are hereby incorporated by reference in their entireties.

The present invention relates to the field of computer technologies and in particular to a virtualization processing method and apparatuses and a computer system.

Virtualization technology is a decoupling technology for separating a bottom hardware device from an upper operating system and application programs and referring to a virtual machine monitor VMM Virtual Machine Monitor layer is introduced to directly manage bottom hardware resources create a virtual machine VM Virtual Machine irrelevant to the bottom hardware for being used by the upper operating system and application programs.

The virtualization technology as one of the important supporting technologies of the currently popular cloud computing Cloud Computing platform can greatly improve the resource utilization efficiency of a physical device. Compared with a conventional physical server the virtual machine has better isolation and encapsulation and information of the whole virtual machine can be saved in a virtual disk image VDI Virtual Disk Image so as to conveniently perform operations such as snapshot backup cloning and delivering for the virtual machine.

With the evolution of the x86 processor the virtualization technology of a central processing unit CPU Central Processing Unit and a memory is increasingly perfected with ever decreasing overhead. Based on the latest processor the overhead of virtualization of CPU and memory for most applications has been less than 10 . In an input output I O Input Output virtualization field the virtualization I O solution having high performance and low delay is still a key technical challenge in the virtualization field. The conventional I O virtualization solution includes two types namely a software solution and a hardware solution. However the conventional software solution and hardware solution both have their outstanding advantages and disadvantages. For example the conventional software solution is advantageous in compatibility but has great performance loss the hardware solution can bring about desired performance but has problems such as feature compatibility and guest operating system Guest OS compatibility.

Embodiments of the present invention provide a virtualization processing method and apparatuses and a computer system so as to optimize performance and compatibility of a virtualization system.

In order to solve the foregoing technical problems the embodiments of the present invention provide the following technical solutions.

In one aspect an embodiment of the present invention provides a virtualization processing method which is applied to a computing node and the computing node includes 

a hardware layer a Host running on the hardware layer and at least one virtual machine VM running on the Host where the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device the BE in the Host is bound with an idle VF software instance 

acquiring by the VF software instance bound with the BE an address corresponding to the cache for DMA through an exporting application programming interface of the BE writing the acquired address corresponding to the cache for DMA into a first storage unit of a VF device corresponding to the VF software instance selecting by the VF device an address corresponding to the cache for DMA from the first storage unit when there is data to be received and initiating a DMA write request by using the selected address corresponding to the cache for DMA as a target address notifying by the VF device the VF software instance which is corresponding to the VF device and is in the Host after the DMA write request is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the address.

In another aspect an embodiment of the present invention further provides a virtualization processing method including 

after an I O virtual function of an input output I O device is enabled generating several VF software instances in a Host where several corresponding virtual function VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence 

where a back end instance BE of the I O virtual device is created in the Host a front end instance FE of the I O virtual device is created in the initiated virtual machine VM and

In another aspect an embodiment of the present invention further provides a computing node including a hardware layer a Host running on the hardware layer and at least one virtual machine VM running on the Host where the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device the BE in the Host is bound with an idle VF software instance 

the VF software instance bond with the BE is configured to acquire an address corresponding to the cache for DMA through an exporting application programming interface of the BE write the acquired address corresponding to the cache for DMA into a first storage unit in a VF device corresponding to the VF software instance 

the VF device is configured to select the address corresponding to the cache for DMA from the first storage unit when there is data to be received and initiate a DMA write request by using the selected address corresponding to the cache for DMA as a target address and notify the VF software instance which is corresponding to the VF device and is in the Host after the DMA write request is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the address.

a first creating module configured to after an I O virtual function of an input output I O device is enabled generate several VF software instances in the Host where several corresponding virtual function VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence 

a second creating module configured to create an I O virtual device having the same type with the I O device 

where a back end instance BE of the I O virtual device is created in the Host a front end instance FE of the I O virtual device is created in the initiated virtual machine VM and

a binding module configured to bind the BE created by the second creating module with an idle VF software instance created by the first creating module.

It can be seen that the computing node in the embodiments of the present invention may include a hardware layer a Host running on the hardware layer and at least one VM running on the Host the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device where the BE in the Host is bound with an idle VF software instance. In this way application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficiency device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any extra CPU overhead is hardly caused. Moreover a front end drive that is the FE of the I O virtual device is in the VM so the FE transfers data through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

Embodiments of the present invention provide a virtualization processing method and apparatuses and a computer system so as to optimize the performance and compatibility of a virtualization system.

In order to make the solutions of the present invention more comprehensible for persons skilled in the art the technical solutions in the embodiments of the present invention are clearly and completely described below with reference to the accompanying drawings in the embodiments of the present invention. It is obvious that the embodiments to be described are only a part rather than all of the embodiments of the present invention. All other embodiments derived by persons of ordinary skill in the art based on the embodiments of the present invention without creative efforts shall fall within the protection scope of the present invention.

In order to conveniently understand embodiments of the present invention several elements that will be introduced in the description of the embodiments of the present invention are illustrated herein first.

One or more virtual computers can be simulated on a physical computer through virtual machine software and those virtual machines work as real computers a virtual machine can have an operating system and application programs installed and the virtual machine can still access network resources. For an application program running in the virtual machine the virtual machine works just like in a real computer.

A hardware platform running in a virtualization environment. The hardware layer may include multiple types of hardware for example a hardware layer of a computing node may include a CPU and a memory and may include high speed low speed input output I O Input Output devices such as a network card and a storage and other devices having specific processing functions such as an input output memory management unit IOMMU Input Output Memory Management Unit where the IOMMU may be configured to translate a virtual machine physical address and a Host physical address.

A corresponding physical function PF Physical Function device and several virtual function VF Virtual Function devices can be virtualized from the I O device having an I O virtual function after the I O virtual function is enabled where the PF device virtualized from the I O device is mainly responsible for a management function and a VF device is mainly responsible for a processing function.

The host as a management layer is configured to complete management and allocation for hardware resources present a virtual hardware platform for a virtual machine and implement scheduling and isolation of the virtual machine. The Host may be a virtual machine monitor VMM and moreover sometimes a VMM may combine with one prerogative virtual machine to form a Host. The virtual hardware platform provides various hardware resources for virtual machines running on the platform for example provides a virtual CPU a memory a virtual disk a virtual network card and so on. The virtual disk may be corresponding to one file or one logic block device of the Host. The virtual machine is running on the virtual hardware platform prepared by the Host and the Host may have one or more virtual machines running on the host.

Referring to FIG. and FIG. FIG. and FIG. are schematic architectural diagrams of software and hardware systems of two virtualization solutions provided in embodiments of the present invention. System architecture mainly includes three layers a hardware layer a Host and a virtual machine VM . The hardware layer shown in FIG. or FIG. includes an I O device and the hardware layer shown in FIG. further includes an IOMMU. The Host is running on the hardware layer and at least one virtual machine VM is running on the Host where several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE Back End of an I O virtual device having the same type with the I O device the VM has a front end instance FE Front End of the I O virtual device the BE in the Host is bound with an idle VF software instance. In the technical solution of an embodiment of the present invention the BE in the VM may be considered as a front end driver of the I O virtual device the FE in the Host may be considered as a back end driver of the I O virtual device and the I O virtual device is composed of the BE and the FE.

A virtualization processing method according to an embodiment of the present invention can be applied to a computing node where the computing node comprises a hardware layer a Host running on the hardware layer and at least one VM running on the Host the hardware layer includes an input output I O device the virtualization processing method may include after an I O virtual function of the input output I O device is enabled generating several virtual function VF Virtual Function software instances in the Host several corresponding virtual function VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence creating by the Host an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host a front end instance FE of the I O virtual device is created in the initiated VM and binding the BE with an idle VF software instance.

Referring to a virtualization processing method provided in an embodiment of the present invention may include 

where several corresponding VF devices can be virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence. For example the Host may enable the I O virtual function of the I O device when being initiated or at a certain moment after being initiated so as to enable the I O virtual function of the I O device. Alternatively the I O device may enable its I O virtual function automatically after the device is powered on and in this case it is unnecessary for the Host to enable the I O virtual function of the I O device.

It should be noted that the I O device mentioned in the embodiment of the present invention may be for example a peripheral component interconnect express PCIe Peripheral Component Interconnect Express device or a device of another type such as a network card.

If the Host creates several I O virtual devices having the same type with the I O device a back end instance BE of each I O virtual device is bound with an idle VF software instance and an inter access interface between the BE and the VF software instance that are in binding relatinship exists for example the BE can access a VF device corresponding to the VF software instance through an access interface provided by the VF software instance bound with the BF. In this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and a front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use so it is beneficial for the VM to acquire the performance similar to that of a physical machine. Based on the application architecture constructed by the Host the VM can send data receive data or perform data processing in other forms.

For example in FIG. and FIG. several corresponding VF devices can be virtualized from the I O device such as a PCIe device with the I O virtual function enabled and a corresponding physical function PF Physical Function device can further be virtualized from the I O device with the I O virtual function enabled back end instances BEs of several I O virtual devices that have the same type with the I O device and are created by the Host are located in the Host and a front end instance FE of each I O virtual device is located in a different VM. A shared memory may further be configured between the Host and the VM and the back end instance BE and the front end instance FE of the I O virtual device may for example transfer data through the shared memory.

It can be seen that in this embodiment after the I O virtual function of the input output I O device is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance. In this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

Referring to another virtualization processing method provided in an embodiment of the present invention is applied to a computing node the computing node includes a hardware layer a Host running on the hardware layer and at least one VM running on the Host where the hardware layer includes an input output I O device the method may include 

For example the Host may enable the I O virtual function of the I O device when being initiated or at a certain moment after being initiated so as to enable the I O virtual function of the I O device. Several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled. Alternatively the I O device may enable its I O virtual function automatically after the device is powered on and in this case it is unnecessary for the Host to enable the I O virtual function of the I O device.

If the Host creates several I O virtual devices having the same type with the I O device a back end instance BE of each I O virtual device is bound with an idle VF software instance and an inter access interface between the BE and the VF software instance that are in binding relationship exists for example the BE can access the VF device corresponding to the VF software instance through an access interface provided by the VF software instance bound with the BE. In this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in the VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use so it is beneficial for the VM to acquire the performance similar to that of a physical machine. Based on the application architecture constructed by the Host the VM can send data receive data or perform data processing in other forms.

For example in FIG. and FIG. several corresponding VF devices can be virtualized from the I O device such as a PCIe device with the I O virtual function enabled and a corresponding physical function PF device can further be virtualized from the I O device with the I O virtual function enabled the Host may further generate a PF software instance corresponding to the PF device back end instances BEs of several I O virtual devices that have the same type with the I O device and are created by the Host are located in the Host and a front end instance FE of each I O virtual device is located in a different VM. A shared memory may further be configured between the Host and the VM and the back end instance BE and the front end instance FE of the I O virtual device can for example transfer data through the shared memory.

For ease of understanding an optional interaction manner of application architecture constructed based on the foregoing mechanism is illustrated below by taking a procedure of receiving data as an example.

In an application scenario after the Host binds the BE and the idle VF software instance the FE may pre allocate a cache for direct memory access DMA Direct Memory Access the FE may write a guest physical address GPA Guest Physical Address corresponding to the pre allocated cache for DMA into the shared memory between the Host and the VM through an exporting application programming interface of the BE the VF software instance bound with the BE may acquire the GPA corresponding to the cache for DMA the VF software instance may write the acquired GPA corresponding to the cache for DMA into a receiving queue of a VF device corresponding to the VF software instance when there is data to be received the VF device may select the GPA corresponding to the cache for DMA from the receiving queue of the VF device and may initiate a DMA write request the DMA write request is used to write data into the cache by using the selected GPA as a target address an input output memory management unit IOMMU modifies the target address GPA of the DMA write request into a corresponding Host physical address HPA where an address translation page table for example is set in the IOMMU the address translation page table records mapping between the HPA and the GPA when the DMA write request passes the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA write request by looking up the address translation page table and modify the target address GPA of the DMA write request to the acquired HPA after the DMA write request whose target address is modified to the HPA is executed the VF device may notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers a corresponding FE to receive data written into a cache corresponding to the HPA.

In another application scenario after the Host binds the BE and the idle VF software instance the FE may pre allocate a cache for DMA the FE may write a GPA corresponding to the pre allocated cache for DMA into the shared memory between the Host and the VM the Host for example the BE or another module in the Host may modify the GPA corresponding to the cache for DMA to a corresponding HPA for example an address translation page table is set in the Host the address translation page table records mapping between the HPA and the GPA by looking up the address translation page table the Host for example the BE or another module in the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache for DMA and modify the GPA corresponding to the cache for DMA to the acquired HPA the VF software instance bound with the BE in the Host acquires through the exporting application programming interface of the BE the HPA corresponding to the cache for DMA the acquired HPA corresponding to the cache for DMA is written into a receiving queue of a VF device corresponding to the VF software instance when there is data to be received the VF device selects the HPA corresponding to the cache for DMA from the receiving queue of the VF device and initiates a DMA write request the DMA write request is used to write data in the cache by using the selected HPA as a target address after the DMA write request is executed the VF device may further notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers a corresponding FE to receive data written into a cache corresponding to the HPA.

For ease of understanding an optional interaction manner of application architecture constructed based on the foregoing mechanism is illustrated below by taking a procedure of sending data as an example.

In an application scenario after the Host binds the BE and the idle VF software instance the FE may write a GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM a corresponding BE may invoke a program sending interface of the VF software instance bound with the BE and write the GPA corresponding to the cache where data to be sent locates into a sending queue of a VF device corresponding to the VF software instance after finding that there is data to be sent the VF device initiates a DMA read request the DMA write request is used to read data from the cache by using the GPA recorded in the sending queue of the VF device as a target address and the IOMMU modifies the target address GPA of the DMA read request into a corresponding HPA where an address translation page table for example is set in the IOMMU the address translation page table records mapping between the HPA and the GPA when the DMA read request passes the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA read request by looking up the address translation page table and modify the target address GPA of the DMA read request to the acquired HPA . Further after the DMA read request is executed the VF device may notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers a corresponding FE to release the corresponding cache.

In another application scenario after the Host binds the BE and the idle VF software instance the FE may write the GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM the Host for example the BE or another module in the Host may modify the GPA corresponding to the cache to a corresponding HPA for example an address translation page table is set in the Host the address translation page table records mapping between the HPA and the GPA by looking up the address translation page table the Host for example the BE or another module in the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache and modify the GPA corresponding to the cache to the acquired HPA the corresponding BE may invoke a program sending interface of the VF software instance bound with the BE and write the HPA corresponding to the cache where the data to be sent locates into the sending queue of a VF device corresponding to the VF software instance when finding that there is data to be sent the VF device initiates a DMA read request by using the HPA recorded in the sending queue of the VF device as a target address. Further after the DMA read request is executed the VF device may notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers a corresponding FE to release the corresponding cache.

The optional interaction manner of the application architecture constructed based on the foregoing mechanism is illustrated below by taking procedures of sending data and receiving data as examples and interaction manners in other application scenarios can be deduced through analog.

It can be seen that in this embodiment after the I O virtual function of the input output I O device is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in an initiated VM the BE is bound with the idle VF software instance. In this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

An embodiment of the present invention further provides a virtualization processing method which is applied to a computing node the computing node may include a hardware layer a Host running on the hardware layer and at least one VM running on the Host where the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device the BE in the Host is bound with an idle VF software instance the method includes pre allocating by the FE a cache for direct memory access DMA acquiring by the VF software instance bound with the BE an address corresponding to the cache for DMA through an exporting application programming interface of the BE writing the acquired address corresponding to the cache for DMA into a first storage unit of a VF device corresponding to the VF software instance selecting by the VF device the address corresponding to the cache for DMA from the first storage unit when there is data to be received and initiating a DMA write request by using the selected address corresponding to the cache for DMA as a target address notifying by the VF device the VF software instance which is corresponding to the VF device and is in the Host after the DMA write request is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the address.

Referring to another virtualization processing method in an embodiment of the present invention may include the following steps 

It can be seen that in this embodiment the computing node may include a hardware layer a Host running on the hardware layer and at least one VM running on the Host where the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device the BE in the Host is bound with an idle VF software instance. In this way the application architecture in which each VM can independently use one VF device is established and a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the I O virtual device is in the VM so the FE transfers data through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

In an embodiment of the present invention after the FE pre allocates the cache for DMA the FE may write the GPA corresponding to the pre allocated cache for DMA into the shared memory between the Host and the VM the VF software instance bound with the BE may acquire the GPA corresponding to the cache for DMA from the shared memory through the exporting application programming interface of the BE definitely the FE may also notify the GPA corresponding to the pre allocated cache for DMA to the corresponding BE and the VF software instance bound with the BE may acquire the GPA corresponding to the cache for DMA through the exporting application programming interface of the BE write the acquired GPA corresponding to the cache for DMA into the first storage unit of the VF device corresponding to the VF software instance and when there is data to be received the VF device may select the GPA corresponding to the cache for DMA from the first storage unit and initiate the DMA write request by using the GPA corresponding to the cache for DMA as the target address the IOMMU may modify the target address GPA of the DMA write request into the corresponding HPA for example an address translation page table for example is set in the IOMMU the address translation page table records mapping between the HPA and the GPA the IOMMU acquires an HPA corresponding to the target address GPA of the DMA write request by looking up the address translation page table and modifies the target address GPA of the DMA write request to the acquired HPA after the DMA write request whose target address GPA is modified to the HPA is executed the VF device notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers the FE to receive data written into the cache corresponding to the HPA.

In another application scenario after the FE pre allocates the cache for DMA the FE may write a GPA corresponding to the pre allocated cache for DMA into the shared memory between the Host and the VM the Host may modify the GPA corresponding to the cache for DMA in the shared memory to a corresponding HPA for example an address translation page table is set in the Host the address translation page table records mapping between the HPA and the GPA by looking up the address translation page table the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache for DMA in the shared memory and modify the GPA corresponding to the cache for DMA in the shared memory to the acquired HPA. Definitely the FE may also notify the GPA corresponding to the pre allocated cache for DMA to the corresponding BE and the Host may modify the GPA corresponding to the cache for DMA to the corresponding HPA the VF software instance bound with the BE acquires through the exporting application programming interface of the BE the HPA corresponding to the cache for DMA the acquired HPA corresponding to the cache for DMA is written into a first storage unit of the VF device corresponding to the VF software instance when there is data to be received the VF device selects the HPA corresponding to the cache for DMA from the first storage unit and initiates a DMA write request by using the selected HPA as a target address.

In an embodiment of the present invention when the FE has data to be sent the FE may write the GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM the BE may acquire the GPA corresponding to the cache where data to be sent locates from the shared memory definitely the FE may also notify the GPA corresponding to the cache where data to be sent locates to the corresponding BE and the BE acquires according to the notification the GPA corresponding to the cache where data to be sent locates the BE invokes a program sending interface of the VF software instance bound with the BE and writes the GPA corresponding to the cache where data to be sent locates into a second storage unit of the VF device corresponding to the VF software instance where the second storage unit is for example a sending queue or a sending list of the VF device or another data storage structure capable of recording an address when finding that there is data to be sent the VF device initiates a DMA read request by using the GPA recorded in the second storage unit as the target address the IOMMU may modify the target address GPA of the DMA read request to a corresponding HPA for example an address translation page table is set in the IOMMU the address translation page table records mapping between the HPA and the GPA the IOMMU acquires an HPA corresponding to the target address GPA of the DMA read request by looking up the address translation page table and modifies the target address GPA of the DMA read request to the acquired HPA . Further after the DMA read request is executed the VF device may notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers the FE to release the corresponding cache.

In another embodiment of the present invention when the FE has data to be sent the FE may write the GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM the Host modifies the GPA corresponding to the cache where data to be sent locates in the shared memory to the corresponding HPA for example an address translation page table is set in the Host the address translation page table records mapping between the HPA and the GPA by looking up the address translation page table the Host acquires the HPA corresponding to the GPA that is corresponding to the cache where data to be sent locates in the shared memory and modifies the GPA corresponding to the cache where data to be sent locates in the shared memory to the corresponding HPA. Definitely the FE may also notify the GPA corresponding to the cache where data to be sent locates to the Host and the Host modifies the GPA corresponding to the cache where data to be sent locates to the corresponding HPA the BE acquires the HPA corresponding to the cache where the data to be sent locates invokes a program sending interface of the VF software instance bound with the BE and writes the HPA corresponding to the cache where the data to be sent locates into the second storage unit of the VF device corresponding to the VF software instance where the second storage unit is for example a sending queue or a sending list of the VF device or another data storage structure capable of recording an address when finding that there is data to be sent the VF device initiates a DMA read request by using the HPA recorded in the second storage unit as a target address. Further after the DMA read request is executed the VF device may notify the VF software instance which is corresponding to the VF device and is in the Host so that the VF software instance triggers the FE to release the corresponding cache.

For better understand and implement the foregoing solutions in the embodiments of the present invention further illustration is made by taking several specific application scenarios of data receiving and data sending as examples.

Referring to FIG. another virtualization processing method provided in an embodiment of the present invention may include 

where the Host may enable the IOMMU when being initiated or at a certain moment after being initiated definitely the IOMMU may also enable the corresponding function automatically when the device is powered on and in this case it is unnecessary for the Host to enable the IOMMU and definitely another module may also be used to enable the IOMMU.

where for example the Host may enable the I O virtual function of the I O device E when being initiated or at a certain moment after being initiated. A corresponding physical function PF device and several virtual function VF devices can be virtualized from the I O device E with the I O virtual function enabled definitely another module may be used to enable the I O device E and definitely the I O device E may also automatically enable its I O virtual function when the device is powered on and in this case it is unnecessary for the Host or another module to enable the I O virtual function of the I O device E . The PF device virtualized from the I O device E is mainly responsible for a management function and the VF device is mainly responsible for a processing function.

where a back end instance BE for example referred to as BE of the I O virtual device vE is created in the Host and a front end instance FE for example referred to as FE of the I O virtual device vE is created in an initiated VM for example referred to as VM . For example the Host may trigger the creation of a front end instance FE corresponding to the I O virtual device vE in the initiated VM . It may be considered that the FE created in the VM and the BE created in the Host commonly construct a driver of the I O virtual device vE .

where the VF software instance Vfe for example is corresponding to the VF device for example referred to as VF virtualized from the I O device E . The so called idle VF software instance is a VF software instance that is not bound with another back end instance BE.

So far a channel between the VF device VF virtualized from the I O device E and the front end instance FE in the VM is got through in this way the FE can access the VF device VF through the BE in the Host. The VF device VF is separately allocated to the VM for use the VF device VF is virtualized from the I O device E and can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing.

For example the cache that is used for DMA and is pre allocated by the FE may be GPA Len . . . GPAn Lenn that is multiple sections of cache for DMA may be pre allocated where GPA represents a start address of the GPA of the cache Len represents a length of the cache and so on.

where for example an address translation page table is set in the IOMMU the address translation page table records mapping between the GPA and the HPA for example as shown in FIG. . When the DMA write request passes the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA write request by looking up the address translation page table and modify the target address GPA of the DMA write request to the acquired HPA.

When being triggered by the VF software instance Vfe the front end instance FE in the VM may read the data written in the cache corresponding to the HPA.

It can be seen that in this embodiment after the I O virtual function of the I O device enabled by the Host is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance in this way the application architecture in which each VM can independently use one VF device is established and a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

In addition during the procedure of executing the DMA write request the hardware module IOMMU implements the translation between the GPA and the HPA thereby reducing CPU overhead and further improving performance.

Referring to FIG. another virtualization processing method provided in an embodiment of the present invention may include 

where for example the Host may enable the I O virtual function of the I O device E when being initiated or at a certain moment after being initiated. The corresponding physical function PF device and several virtual function VF devices can be virtualized from the I O device E with the I O virtual function enabled by the Host definitely another module may be used to enable the I O device E and definitely the I O device E may also automatically enable its I O virtual function when the device is powered on and in this case it is unnecessary for the Host or another module to enable the I O virtual function of the I O device E . The PF device virtualized from the I O device E is mainly responsible for a management function and the VF device is mainly responsible for a processing function.

where a back end instance BE for example referred to as BE of the I O virtual device vE is created in the Host and a front end instance FE for example referred to as FE of the I O virtual device vE is created in the initiated VM for example referred to as VM . For example the Host may trigger the creation of the front end instance FE corresponding to the I O virtual device vE in the initiated VM . It may be considered that the FE created in the VM and the BE created in the Host commonly construct a driver of the I O virtual device vE .

where the VF software instance Vfe for example is corresponding to the VF device for example referred to as VF virtualized from the I O device E . The so called idle VF software instance is a VF software instance that is not bound with another back end instance BE.

So far a channel between the VF device VF virtualized from the I O device E and the front end instance FE in the VM is got through in this way the FE can access the VF device VF through the BE in the Host. The VF device VF is separately allocated to the VM for use the VF device VF is virtualized from the I O device E and can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing.

For example the cache that is used for DMA and is pre allocated by the FE may be GPA Len . . . GPAn Lenn that is multiple sections of cache for DMA may be pre allocated where GPA represents a start address of the GPA of the cache Len represents a cache length and so on.

where for example an address translation page table is set in the Host the address translation page table records mapping between the GPA and the HPA for example as shown in FIG. . By looking up the address translation page table the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache for DMA and modify the GPA corresponding to the cache for DMA to the acquired HPA.

When being triggered by the VF software instance Vfe the front end instance FE in the VM may read the data written in the cache corresponding to the HPA.

It can be seen that in this embodiment after the I O virtual function of the input output I O device enabled by the Host is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance in this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

In addition during the procedure of executing the DMA write request the Host implements the translation between the GPA and the HPA thereby reducing hardware resource configuration and simplifying the processing flow.

Referring to FIG. another virtualization processing method provided in an embodiment of the present invention may include 

where the Host may enable the IOMMU when being initiated or at a certain moment after being initiated definitely the IOMMU may also enable the corresponding function automatically when the device is powered on and in this case it is unnecessary for the Host to enable the IOMMU and definitely another module may also be used to enable the IOMMU.

where for example the Host may enable the I O virtual function of the I O device E when being initiated or at a certain moment after being initiated. The corresponding physical function PF device and several virtual function VF devices can be virtualized from the I O device E with the I O virtual function enabled definitely another module may be used to enable the I O device E and definitely the I O device E may also automatically enable its I O virtual function when the device is powered on and in this case it is unnecessary for the Host or another module to enable the I O virtual function of the I O device E . The PF device virtualized from the I O device E is mainly responsible for a management function and the VF device is mainly responsible for a processing function.

where a back end instance BE for example referred to as BE of the I O virtual device vE is created in the Host and a front end instance FE for example referred to as FE of the I O virtual device vE is created in the initiated VM for example referred to as VM . For example the Host may trigger the creation of a front end instance FE corresponding to the I O virtual device vE in the initiated VM . It may be considered that the FE created in the VM and the BE created in the Host commonly construct a driver of the I O virtual device vE .

where the VF software instance Vfe for example is corresponding to the VF device for example referred to as VF virtualized from the I O device E . The so called idle VF software instance is a VF software instance that is not bound with another back end instance BE.

So far a channel between the VF device VF virtualized from the I O device E and the front end instance FE in the VM is got through in this way the FE can access the VF device VF through the BE in the Host. The VF device VF is separately allocated to the VM for use the VF device VF is virtualized from the I O device E and can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing.

For example the GPA corresponding to the cache where data to be sent locates is GPA Len . . . GPAn Lenn that is multiple sections of cache for DMA may be pre allocated where GPA represents a start address of the GPA of the cache Len represents a cache length and so on.

where the VF device VF for example may detect the sending queue of the VF device periodically or non periodically and when finding that a GPA is newly written into the sending queue consider that there is data to be sent or the VF software instance Vfe may notify the VF device VF after a GPA is newly written into the sending queue 

where for example an address translation page table is set in the IOMMU the address translation page table records mapping between the GPA and the HPA for example as shown in FIG. . When the DMA read request passes the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA read request by looking up the address translation page table and modify the target address GPA of the DMA read request to the acquired HPA.

When being triggered by the VF software instance Vfe the front end instance FE in the VM may release the cache corresponding to the HPA so as to cache new data.

It can be seen that in this embodiment after the I O virtual function of the input output I O device enabled by the Host is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance in this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the FE transfers data through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

In addition during the procedure of executing the DMA read request the hardware module IOMMU implements the translation between the GPA and the HPA thereby reducing CPU overhead and further improving performance.

Referring to FIG. another virtualization processing method provided in an embodiment of the present invention may include 

where for example the Host may enable the I O virtual function of the I O device E when being initiated or at a certain moment after being initiated. The corresponding physical function PF device and several virtual function VF devices can be virtualized from the I O device E with the I O virtual function enabled definitely another module may be used to enable the I O device E and definitely the I O device E may also automatically enable its I O virtual function when the device is powered on and in this case it is unnecessary for the Host or another module to enable the I O virtual function of the I O device E . The PF device virtualized from the I O device E is mainly responsible for a management function and the VF device is mainly responsible for a processing function.

where a back end instance BE for example referred to as BE of the I O virtual device vE is created in the Host and a front end instance FE for example referred to as FE of the I O virtual device vE is created in the initiated VM for example referred to as VM . For example the Host may trigger the creation of the front end instance FE corresponding to the I O virtual device vE in the initiated VM . It may be considered that the FE created in the VM and the BE created in the Host commonly construct a driver of the I O virtual device vE .

where the VF software instance Vfe for example is corresponding to the VF device for example referred to as VF virtualized from the I O device E . The so called idle VF software instance is a VF software instance that is not bound with another back end instance BE.

So far a channel between the VF device VF virtualized from the I O device E and the front end instance FE in the VM is got through in this way the FE can access the VF device VF through the BE in the Host. The VF device VF is separately allocated to the VM for use the VF device VF is virtualized from the I O device E and can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing.

where for example an address translation page table is set in the Host the address translation page table records mapping between the GPA and the HPA for example as shown in FIG. . By looking up the address translation page table the Host may for example acquire an HPA corresponding to the GPA that is corresponding to the cache where data to be sent locates and modify the GPA corresponding to the cache where data to be sent locates to the acquired HPA.

where the VF device VF may for example detect the sending queue of the VF device periodically or non periodically and when finding that an HPA is newly written into the sending queue consider that there is data to be sent or the VF software instance Vfe may notify the VF device VF after an HPA is newly written into the sending queue.

When being triggered by the VF software instance Vfe the front end instance FE in the VM may release the cache corresponding to the HPA so as to cache new data.

It can be seen that in this embodiment after the I O virtual function of the I O device enabled by the Host is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance in this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so the data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

In addition during the procedure of executing the DMA read request the Host implements the translation between the GPA and the HPA thereby reducing hardware resource configuration and simplifying the processing flow.

For better understanding and implementation of the foregoing methods in the embodiments of the present invention apparatuses and a computer system configured to implement the foregoing methods are further provided.

the first creating module is configured to after an I O virtual function of an input output I O device is enabled generate several VF software instances in the Host where several corresponding virtual function VF devices are virtualized from the I O device with the I O virtual function enabled and the several VF software instances generated in the Host and the several VF devices are in one to one correspondence 

the second creating module is configured to create an I O virtual device having the same type with the I O device 

where a back end instance BE of the I O virtual device is created in the Host a front end instance FE of the I O virtual device is created in an initiated virtual machine VM and

the binding module is configured to bind the BE created by the second creating module with an idle VF software instance created by the first creating module .

It can be understood that the host in this embodiment may be the Host in each of the foregoing method embodiments functions of each function module may be specifically implemented according to the method in each of the foregoing method embodiments. For the specific implementation procedure reference can be made to relevant description of the foregoing method embodiments and details are not repeated herein.

It can be seen that in this embodiment after the I O virtual function of the I O device is enabled several VF software instances are generated in the Host several corresponding VF devices are virtualized from the I O device with the I O virtual function enabled the several VF software instances generated in the Host and the several VF devices are in one to one correspondence the Host creates an I O virtual device having the same type with the I O device where a back end instance BE of the I O virtual device is created in the Host and a front end instance FE of the I O virtual device is created in the initiated VM the BE is bound with the idle VF software instance in this way the application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficient device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any additional CPU overhead is hardly caused. Moreover a front end drive that is the FE of the virtual device is in the VM so data is transferred through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

a hardware layer a Host running on the hardware layer and at least one virtual machine VM running on the Host .

The hardware layer includes an I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device the VM has a front end instance FE of the I O virtual device the BE in the Host is bound with an idle VF software instance .

In an application scenario the FE is configured to pre allocate a cache for direct memory access DMA.

The VF software instance bound with the BE is configured to acquire an address corresponding to the cache for DMA through an exporting application programming interface of the BE and write the acquired address corresponding to the cache for DMA into a first storage unit of the VF device corresponding to the VF software instance .

The VF device is configured to select the address corresponding to the cache for DMA from the first storage unit when there is data to be received and initiate a DMA write request by using the address corresponding to the cache for DMA as a target address notify the corresponding VF software instance in the Host after the DMA write request is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the address.

Referring to FIG. in an application scenario the FE is further configured to write a guest physical address GPA corresponding to the pre allocated cache for DMA into a shared memory between the Host and the VM .

The VF software instance bound with the BE may be specifically configured to acquire the GPA corresponding to the cache for DMA from the shared memory through the exporting application programming interface of the BE and write the acquired GPA corresponding to the cache for DMA into the first storage unit of the VF device corresponding to the VF software instance .

Moreover the FE may also notify the GPA corresponding to the pre allocated cache for DMA to the corresponding BE and the VF software instance bound with the BE may acquire the GPA corresponding to the cache for DMA through the exporting application programming interface of the BE .

The VF device may be specifically configured to select a GPA corresponding to the cache for DMA from the first storage unit when there is data to be received initiate a DMA write request by using the selected GPA corresponding to the cache for DMA as a target address notify the corresponding VF software instance in the Host after the DMA write request whose target address GPA is modified to a corresponding HPA is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the HPA.

an input output memory management unit IOMMU configured to modify the target address GPA of the DMA write request initiated by the VF device to a corresponding Host physical address HPA.

For example an address translation page table is set in the IOMMU where the address translation page table records mapping between the GPA and the HPA the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA write request by looking up the address translation page table and modify the target address GPA of the DMA write request to the acquired HPA.

Referring to FIG. in another application scenario the FE may further be configured to write the GPA corresponding to the pre allocated cache for DMA into the shared memory between the Host and the VM .

The Host may be configured to modify the GPA corresponding to the cache for DMA in the shared memory to a corresponding HPA.

For example an address translation page table is set in the Host where the address translation page table records mapping between the GPA and the HPA by looking up the address translation page table the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache for DMA in the shared memory and modify the GPA corresponding to the cache for DMA in the shared memory to the acquired HPA. Definitely the FE may also notify the GPA corresponding to the pre allocated cache for DMA to the corresponding BE and the Host may modify the GPA corresponding to the cache for DMA to the corresponding HPA.

The VF software instance bound with the BE may be specifically configured to acquire the HPA corresponding to the cache for DMA through the exporting application programming interface of the BE and write the acquired HPA corresponding to the cache for DMA into a first storage unit of the VF device corresponding to the VF software instance .

The VF device may be specifically configured to select the HPA corresponding to the cache for DMA from the first storage unit when there is data to be received initiate a DMA write request by using the selected HPA as a target address and notify the corresponding VF software instance in the Host after the DMA write request is executed so that the VF software instance triggers the FE to receive data written into the cache corresponding to the HPA.

Further in an application scenario the FE is further configured to write the GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM .

The BE may further be configured to acquire the GPA corresponding to the cache where data to be sent locates from the shared memory invoke a program sending interface of the VF software instance bound with the BE and write the GPA corresponding to the cache where data to be sent locates into a second storage unit of the VF device corresponding to the VF software instance .

Moreover the FE may also notify the GPA corresponding to the cache where data to be sent locates to the corresponding BE and the BE acquires according to the notification the GPA corresponding to the cache where data to be sent locates.

The VF device is further configured to initiate a DMA read request by using the GPA recorded in the second storage unit as a target address when finding that there is data to be sent moreover the VF device may further be configured to after the DMA read request is executed notify the corresponding VF software instance in the Host so that the VF software instance triggers the FE to release the corresponding cache.

an input output memory management unit IOMMU configured to modify the target address GPA of the DMA read request initiated by the VF device to a corresponding HPA.

For example an address translation page table is set in the IOMMU where the address translation page table records mapping between the GPA and the HPA the IOMMU may acquire an HPA corresponding to the target address GPA of the DMA read request by looking up the address translation page table and modify the target address GPA of the DMA read request to the acquired HPA.

In another application scenario the FE may further be configured to write the GPA corresponding to the cache where data to be sent locates into the shared memory between the Host and the VM .

The Host may be configured to modify the GPA corresponding to the cache where data to be sent locates in the shared memory to a corresponding HPA.

For example an address translation page table is set in the Host where the address translation page table records mapping between the GPA and the HPA by looking up the address translation page table the Host may acquire an HPA corresponding to the GPA that is corresponding to the cache where data to be sent locates in the shared memory and modify the GPA corresponding to the cache where data to be sent locates in the shared memory into the corresponding HPA. Definitely the FE may also notify the GPA corresponding to the cache where data to be sent locates to the Host and the Host may modify the GPA corresponding to the cache where data to be sent locates to the corresponding HPA.

The BE is further configured to acquire the HPA corresponding to the cache where data to be sent locates invoke a program sending interface of the VF software instance bound with the BE and write the HPA corresponding to the cache where data to be sent locates into a second storage unit of the VF device corresponding to the VF software instance .

The VF device may further be configured to initiate a DMA read request by using the HPA recorded in the second storage unit as a target address when finding that there is data to be sent. In addition the VF device may further be configured to after the DMA read request is executed notify the corresponding VF software instance in the Host so that the VF software instance triggers the FE to release the corresponding cache.

The first storage unit for example is a receiving queue or receiving list of the VF device or another data storage structure capable of recording an address. The second storage unit for example is a sending queue or sending list of the VF device or another data storage structure capable of recording an address.

It can be understood that the Host in this embodiment can be the Host in each of the foregoing method embodiments the working mechanism of a virtualization system on which the computing node runs in the embodiment may be as that described in the foregoing method embodiments functions of each function module may be specifically implemented according to the method in each of the foregoing method embodiments. For the specific implementation procedure reference can be made to relevant description of the foregoing method embodiments and details are not repeated herein.

It can be seen that the computing node in the embodiment of the present invention includes a hardware layer a Host running on the hardware layer and at least one VM running on the Host where the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances and the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device and the VM has a front end instance FE of the I O virtual device where the BE in the Host is bound with an idle VF software instance. In this way application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficiency device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any extra CPU overhead is hardly caused. Moreover a front end drive that is the FE of the I O virtual device is in the VM so the FE transfers data through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system.

Referring to an embodiment of the present invention further provides a computer system which may include 

It should be noted that as for each of the foregoing method embodiments for simple description the method is described as a series of action combination but persons of ordinary skill in the art should learn that the present invention is not limited by the described action sequence because according to the present invention some steps may be performed in other sequences or performed simultaneously. Furthermore persons skilled in the art should learn that all the embodiments described in the specification are exemplary embodiments and the operations and modules involved may not be necessary for the present invention.

In the above embodiments the description of each embodiment has its emphasis and for the part that is not detailed in an embodiment reference may be made to the relevant description of other embodiments.

In view of the above the computing node in the embodiment of the present invention may include a hardware layer a Host running on the hardware layer and at least one VM running on the Host the hardware layer includes an input output I O device several corresponding virtual function VF devices are virtualized from the I O device the Host has several VF software instances and the several VF software instances and the several VF devices are in one to one correspondence the Host further has a back end instance BE of an I O virtual device having the same type with the I O device and the VM has a front end instance FE of the I O virtual device where the BE in the Host is bound with an idle VF software instance. In this way application architecture in which each VM can independently use one VF device is established a channel between one VF device virtualized from the I O device and the front end instance FE in one VM is got through so that the FE can access the VF device through the BE in the Host. The VF device virtualized from the I O device is separately allocated to the VM for use and the VF device can provide a high efficiency device interface so it is beneficial for the VM to acquire the performance similar to that of a physical machine the delay is low and any extra CPU overhead is hardly caused. Moreover a front end drive that is the FE of the I O virtual device is in the VM so the FE transfers data through a back end drive that is the BE in the Host and the VM does not perceive a real physical device of the Host which is convenient for transition and implementation of device sharing thereby implementing the optimization of compatibility of a virtualization system. Moreover it is unnecessary that the OS in the VM has the latest hardware technology support the computing node is applicable to various mainstream OSs without depending on VM drives provided by hardware providers IHV the isolation and decoupling between a virtual machine and a physical platform are saved completely and the virtual machine is easy to be transited the Host can still monitor data receiving and sending in the VM and advanced features such as data filtering and memory multiplexing can still be used the FE part of front end of the PV can be multiplexed and upgrading is performed conveniently.

Moreover during the procedure of executing the DMA read write request the hardware module IOMMU implements the translation between the GPA and the HPA thereby reducing hardware resource configuration and simplifying the processing flow. Alternatively during the procedure of executing the DMA read request the Host implements the translation between the GPA and the HPA thereby reducing hardware resource configuration and simplifying the processing flow.

Persons of ordinary skill in the art should understand that all or a part of the steps of the method according to the embodiments of the present invention may be implemented by a program instructing relevant hardware. The program may be stored in a computer readable storage medium such as a read only memory a random access memory a magnetic disk or an optical disk.

The virtualization processing method and apparatuses and a computer system provided in embodiments of the present invention are described in detail. The principle and implementation of the present invention are described herein through specific examples. The description about the embodiments of the present invention is merely provided for easy understanding of the method and core ideas of the present invention. Persons of ordinary skill in the art can make variations and modifications to the present invention in terms of the specific implementation and application scopes according to the ideas of the present invention. Therefore the specification shall not be construed as a limit to the present invention.

