---

title: Data pre-processing and indexing for efficient retrieval and enhanced presentation
abstract: A system, a method and a computer readable storage medium for pre-processing data collected from one or more data sources more accurately summarize data. During the pre-processing, multiple raw data are summarized into a pre-processed datum. By using the pre-processed data entries, more accurate trend data may be generated. Alternatively, data entries are indexed and selectively retrieved based on indices. Decimation of data points are performed based on the indices without retrieving all the data sets from the database, reducing the data access time for returning a query result. Additional data sets may also be retrieved efficiently from the database using the indices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954377&OS=08954377&RS=08954377
owner: Moog Inc.
number: 08954377
owner_city: East Aurora
owner_country: US
publication_date: 20120525
---
This application is a divisional application of and claims priority under 35 U.S.C. 121 to co pending U.S. patent application Ser. No. 12 412 260 entitled Data Pre Processing and Indexing for Efficient Retrieval and Enhanced Presentation filed on Mar. 26 2009 which is incorporated by reference herein in its entirety.

This invention relates to pre processing data or indexing data for efficient retrieval and accurate characterization of data trend.

Certain applications by their nature require vast amounts of data. For example Wireless Sensor Networks WSN as described in U.S. Pat. No. 7 369 047 to Alan S. Broad et al. may collect vast amounts of data representing various physical properties e.g. temperature or humidity at different times. Multiple modules in the WSN sense the physical properties and relay sensor data wirelessly to a base station. The data collected at the base station may then be funneled into a database for storage. As the number of modules or the frequency of data collection increases the amount of data collected by the WSN increases proportionally. Sometimes the data may be collected over an extended period of time ranging from months to years resulting in considerable amounts of data for storage and processing.

When a query request is received from a user a search may be performed on the database to retrieve pertinent data sets. The query often requires binary searches across data entries stored in the database. Although it is preferable to return query results to the user instantaneously the data access time increases as the amount of data stored in the database increases. The increased data access time makes it difficult to satisfy users demand for real time response. Especially if the data requests are received simultaneously from multiple users the database may be burdened with numerous requests and fail to return the results in real time.

The retrieved data sets may be processed and presented to the user using visual tools such as graphs or charts to help users identify any trends or correlation between parameters. If the number of retrieved data sets is large the graphs or charts may become overpopulated with data. Further if the retrieved data set exceeds the number of pixels allocated to the graphs or charts only a subset of retrieved data sets may be displayed on the screen. To select the subset of retrieved data to be displayed the retrieved data must be decimation or summarized to a smaller number appropriate for display. As more data sets are retrieved more time is required to decimate or summarize the retrieved data sets. The accumulated retrieval time and processing time may result in a significant delay in presenting the graphs or charts to the user.

Embodiments relate to a method a system and a computer readable storage medium for pre processing two or more data into a summarized datum. The summarized datum is a representative datum for a time period covered by the two or more data. Summarized data covering different time periods may be generated from other data. The pre processing may be performed offline to store and generate summarized data for multiple data sets before receiving a query request. When a request is received the summarized data covering the queried time period are returned. By pre processing the summarized data the need for further processing to decimate the data may be obviated or reduced.

In one embodiment the pre processing includes at least one of averaging the two or more data selecting a minimum or maximum value of the two or more data obtaining a value based on polynomial fitting of the two or more data or selecting a median value of the two or more data.

Embodiments also relate to a method a system and a computer readable storage medium for determining data entries to be retrieved based on indices assigned to the data entries. Each data is associated with a timestamp based on which an index is assigned to each of the data. After receiving a request for a subset of the data associated the timestamps within a time range the data within the time range is determined based on the indices. Instead of retrieving data entries from a database and then reducing the number of data entries indices of the data entries for retrieval are computed. Then the data entries corresponding to the computed indices are retrieved. By determining the data entries for retrieval based on indices and retrieving the data entries corresponding to the indices fewer queries are made on the database.

In one embodiment the number of data entries having the timestamp within the time range is determined by searching for a starting datum having a timestamp after a starting time of the time range and a last datum having a time stamp before an ending time of the time range. Indices of the starting datum and the last datum are then determined. The number of data entries within the time range is determined by computing a difference between the indices of the starting datum and the ending datum.

In one embodiment the indices are computed by determining an increment value for indices based on a limit and the difference between the first index and the second index. The limit represents the maximum number of data entries to be returned to the client device. Then an array of indices for retrieval of the first data by adding multiples of the increment value to the index of the starting datum.

Embodiments of the invention relate to a system a method and a computer readable storage medium for pre processing data collected from one or more data sources to generate summarized data. By using the summarized data more accurate characterization of data trend may be generated in an efficient manner. Embodiments of the invention also relate to a system a method and a computer readable storage medium for assigning indices to data and storing the data in a database keyed with the indices. When a query request is received indices are first computed and data corresponding to the indices are then retrieved. Decimation of data for retrieval is performed based on indices without having to retrieve the data from the database which reduces the data access time associated with returning the results of the query.

In one embodiment the sensor modules sense physical properties of their environment and send raw sensor data to the data server via known communication channels implemented by various wireless or wired communication protocols. The physical properties to be sensed include among other properties temperature humidity light pressure acceleration location e.g. latitude and longitude speed altitude orientation heading of a vehicle battery level the number of GPS satellite visible the number of cell towers in range the radio strength of signals from the cell towers and ambient audio level. The sensor modules sense and send data to the data server periodically e.g. every 10 minutes . Alternatively the sensor module sense and send data to the data server when certain events are detected e.g. temperature rises above a threshold .

After receiving the raw sensor data the data server performs all or some of the following processes i storing the raw sensor data ii pre processing the raw sensor data into pre processed data iii indexing the raw sensor data and iv returning results of queries to the client device responsive to receiving the queries. The data server may be any computing device that is capable of storing data and processing the data. The data server may include among other components a communication module primary memory secondary memory a processor a sensor interface and a bus coupling these components. The communication module is a hardware component or a combination of software and hardware components that allow communication with the client device . In one embodiment the communication module communicates with the client device via TCP IP Transmission Control Protocol Internet Protocol or other known communication protocols.

The primary memory stores one or more code modules for storing and processing data received from the sensor modules as described below in detail with reference to . The primary memory may be embodied as a computer readable storage medium including among others RAM Random Access Memory . The processor executes instructions as included in the code modules of the primary module to perform various operations.

The secondary memory stores data received from the data sources e.g. the sensor modules . In one embodiment the secondary memory has a larger storing capacity compared to the primary memory but has slower access speed. The secondary memory may be embodied as a computer readable storage medium including among other types a flash memory and a hard disk.

The processor reads instructions and data stored in the primary memory and the secondary memory via the bus to perform various operations. The processor may comprise various computing architectures such as a complex instruction set computer CISC architecture a reduced instruction set computer RISC architecture or an architecture implementing a combination of instruction sets. Although only a single processor is shown in multiple processors may be included in the data server . The processor may comprise an arithmetic logic unit a microprocessor a general purpose computer or some other information appliance equipped to transmit receive and process data from the primary memory and the secondary memory .

The sensor interface is coupled to the sensor modules to receive raw sensor data from the sensor modules . The sensor interface may be embodied as a wired communication interface including for example RS 232 Recommended Standard 232 V.24 RS 42 and RS 433. Alternatively the sensor interface may be embodied as a wireless communication interface including for example Bluetooth and Wi Fi.

In one embodiment the data server communicates with the client device to send results of queries in response to receiving the queries from the client device . The client device may be any computing device that is co located with or remotely located from the data server . The client device may include an application program such as a web browser to access and present data received from the data server . The client device may include among other types a screen to display the data received from the data server .

In one embodiment the data server includes a screen not shown to present processed data directly to the user without using the client device . The data server may also include input devices e.g. keyboards to interact with a user.

In one embodiment the sensor modules and the data server form a Wireless Sensor Network WSN as described for example in U.S. Pat. No. 7 369 047 to Alan S. Broad et al. which is incorporated by reference herein in its entirety. The data server corresponds to a base station that collects sensor data from the sensor modules .

In one embodiment the data server sends summarized data sets to the client device in response to receiving a query from the client device . The original raw data sets may be too large or impracticable for display or visualization on the client device . For example a limited space in a screen may be allocated to display a graph or a chart covering a period with too many data points for display. In such case the number of data points may exceed the number of available pixels on the screen of the client device . Therefore when a large number of data points are retrieved the data points must be summarized or decimated for display on the screen . Even when the number of data entries does not exceed the number of pixels it may be desirable to display only representative data points on the screen to simplify the graph or chart and or to reduce bandwidth for transmitting data between the data server and the client device .

One way of reducing the data points for display is to randomly choose data entries for display. The randomized selection of data points however may result in loss of underlying trend characterization. For example assume that data representing temperature are collected every 10 minute intervals. When displaying a temperature trend over the span of a year using only 365 pixels 52 560 data points must be decimated to 365 data points where each data entry represents an entire day. A randomly chosen data point however may not adequately represent the entire day. That is a data point may be selected during a day time to represent a day while another data point may be selected during a night time to represent another day. Therefore a consistent and systemic method must be adopted to summarize or select data to represent the entire day.

The pre processing engine is coupled to the raw data storage to receive stored raw data . The pre processing engine performs pre processing on the received raw data and stores pre processed data in the pre processed data storage . The pre processed data storage may be embodied as a database. In one embodiment the raw data storage and the pre processed data storage are embodied as a single database. The data processing engine is coupled to the pre processed data storage . The data processing engine receives queries from the client device retrieves appropriate pre processed data from the pre processed data storage and returns the query results to the client device .

In one embodiment the raw data storage stores data in the form of a table including a timestamp field a sensor ID field and one or more sensor data fields. The timestamp field indicates the time when the sensor data was generated by the sensor modules or when the sensor data were collected by the data server . The sensor ID field includes unique id indicating which of the sensor modules generated the sensor data. Each sensor data field stores the sensed values of physical properties e.g. temperature or humidity .

In the example of the raw data entries covering 24 hours are summarized into a summarized data entry in the pre processed data table . For this purpose the pre processing engine retrieves all entries of a data source A B or C within a time interval i.e. 24 hours pre processes the retrieved entries and stores the pre processed data entry in the pre processed data table . In one embodiment the pre processing engine generates separate entries for each data source.

In one embodiment separate tables are created during the pre processing to cover different time intervals e.g. day month and year . When a query request is received from the client device the data processing engine determines an appropriate pre processed data table based on the requested range and the number of data entries. The data processing engine then retrieves data entries from the selected pre processed data table and processes further before returning the results to the client device .

In one embodiment the pre processing is performed offline before receiving queries from the client device . In this way the data processing engine can promptly retrieve pre processed data entries from the pre processed data storage process the retrieved data if needed and forward the results of the queries to the client device without a delay associated with summarizing the data entries.

When a query for data entries is received at a data server a binary search is performed by the database management system to return all the data entries that satisfy query conditions. If the number of returned data points is excessively large the data points are decimated and then sent to the client device . Assuming that the size of entire data entries in the database is N the size of the queried result data entries is M and the size of decimated result data points is m the overall time required for returning the data sets to the client device is as follows Overall Time log 1 

In some cases the size of queried result data entries may be quite large i.e. large M . If the number M of returned data entries is in the order of N the efficiency of process associated with querying and decimating the results is dominated by the size of M. That is the above equation 1 is reduced to Overall Time 0 2 

If a large number of queried data is decimated after being retrieved time consumed in searching and retrieving matching data entries is largely wasted. For example if the client device is generating a graph with only five data points but the query on the database resulted in millions of hits only five data points are needed. Therefore the rest of data points are discarded resulting in a huge waste of resources in searching and returning millions of data points. Such process is inefficient in that an excessive amount of time is spent on querying for data points that are eventually unused. The data points are generally stored in and retrieved from secondary memory into primary memory before returning the data to the client device . The second memory has slower data access speed and therefore the increased amount of data retrieval from the secondary memory delays the overall process. Further a large amount of primary memory is required to store and process e.g. decimate data or select data large amounts of data entries retrieved from the database.

In one embodiment the data received from data sources are selected and or decimated by count based indices. The data entries are stored in a database keyed with the count based indices. The count based indices represent tallies of data points received sequentially from a data source. For example a count based index of 5 indicates that the corresponding data entry is a fifth data point received from the data source. After querying starting and ending data entries in a database the count based indices are used to select and decimate data points between the starting and ending data points. That is the data entries to be retrieved are determined based on the indices. Data entries for only the computed indices are then retrieved from a database. By simplifying the search performed on the database and reducing the number of data entries retrieved the process of returning the results of the query to the client device may be expedited.

The data selector receives queries from the client device . The data selector determines the data entries to be retrieved based on unique id and count as described below in detail with reference to . The retrieved results are then sent to the client device . In one embodiment the data entries are grouped by unique id and stored in separate data silos.

Assuming that the data entries in the database file is ordered by time result time the database file is also queried for a last reading of data entry in the time range using for example the following query language SELECT FROM table WHERE unique id uid AND result time

After retrieving the query results for the first reading and the last reading of the data entries the entries to be retrieved are determined based on the index of the first reading and the index of the last reading. In one embodiment the increment of index for entries to be retrieved are computed using the pseudo code provided in following Table 1 where limit represents the maximum number of data entries to be sent to the client device .

Based on the increment determined according to pseudo code of Table 1 an array of indices for retrieval is computed using the following command indices range count start count end increment 5 The data entries corresponding to the array of indices are then retrieved from the database file . The overall time for retrieving the data entries is O m where m is the number of data retrieved rather than the number of the entire data entries within the start time and the end time.

The overall time for the count based decimation is the sum of two indexed searches one for finding the start data entry and the other for the end data entry and the retrieving of decimated result data set from the database file . Assuming that the size of the entire data entries in the database file is N the size of the queried results set is M and the size of decimated result set is m the overall time for the count based decimation can be expressed in the following equation Overall Time 2 log 6 Compare this with equation 1 where the overall time is O log N M m . In many applications M is larger than log N . Therefore in most cases the indexed based decimation is more efficient than retrieving all matching data entries and then decimating the result.

The process of determining the array of indices is performed advantageously by the data selector embodied on the primary memory without retrieving the data entries from the database file stored in the secondary memory . The secondary memory has a slower data access speed compared to the primary memory . Therefore the process of determining the data entries to be retrieved is faster compared to retrieving all the matching data entries from the secondary memory and then decimating the matching entries. Further only data entries to be returned to the client device are retrieved from the database file . This reduces the data access time and thereby decreases the time for returning the data entries to the client device .

Another binary search is then performed on the table for the last reading having timestamp before 2008 11 01 11 13 00 ending data entry . The query results in a data entry represented by count 20 and a timestamp of 2008 11 01 11 12 54. There are a total of 12 entries from count 9 to count 20. Assuming that the maximum number of data to be returned is 5 that is limit 5 an increment of 3 is computed by the pseudo code in Table 1. Therefore data entries having the following indices are computed for retrieval 12 9 3 15 12 3 and 18 15 3 . The data entries corresponding to the indices of 12 15 and 18 are retrieved from the table . The retrieved data entries may then be sent to the client device as the result of the query.

The indices may also be used to retrieve additional data entries for more detailed presentation of data on the screen of the client device . After the results of a query are returned additional data points within the same time range as the previous time range or a subset of previous time range may be requested. Because the data entries in the database file is keyed by count based indices additional data points may also be computed efficiently using these indices.

Similarly indices for the second set of additional data entries are obtained by adding an integer of two 2 to the indices of previous results . That is indices of 11 9 2 14 12 2 and 17 15 2 are obtained for the second set of additional data entries. A data entry having the count of 20 18 2 is not retrieved because this data entry was returned in the previous result . A data entry having the count of 22 20 2 is excluded because it is beyond the final reading index of 20 .

The additional sets of data points to be retrieved are determined by adding integers to the previously retrieved data entries. In this way indices for evenly distributed data points may be obtained. The additional data sets to be retrieved are also determined efficiently because the additional queries on the database need not be performed. The data entries to be retrieved are determined promptly by computing corresponding indices obtained in the previous query and therefore data entries to be retrieved are determined efficiently.

In one embodiment an initial set of data e.g. data set is first sent to the client device and then additional sets of data e.g. data sets and are transmitted to the client device . In this way the client device may present a coarse graph or a chart based on the initial set of data and then present a more refined graph or chart as subsequent sets of data are received despite limited network bandwidth or other restrictions.

The count base decimation is advantageous among other reasons because i the process is efficient because only required data entries are retrieved instead of all data entries in selected time range ii the data server returns the exact number or less of data entries as requested by the client device iii the data points selected or decimated are not random and remain the same under the same querying conditions iv the distribution of data retrieved are evenly distributed and better shows the trend or characteristics of data points v additional data entries are efficiently retrieved using indices and vi additional data entries retrieved are unique and disjoint from any previous data entries retrieved.

The user interfaces of include map views A B data entry views A B and graph views A B. The map views A B indicate the location of the wireless tracking module for different data points. The data entry views A B indicate the unique identities of data points and their timestamps. The graph views A B depict the changes in temperature at different locations of the wireless tracking module across different data points.

When the application e.g. Internet browser associated with the wireless tracking module is launched on the client device a subset of available data points are selected as described above with reference to and received from the data server to display images as illustrated in . As indicated in the id field of the data entry view A one out of five data points except for first two data entries are displayed in the map view A and the graph view A of .

Subsequently as additional data points are received at the client device more detailed information is presented on the user interface. illustrates the results after additional data points are received. As indicated in the id field of the data entry view B all the data points are being displayed on the map view B and the graph view B. The additional data points may be selected and retrieved using the process as described above with reference to .

In one embodiment the data source is a device other than the sensor module. For example the data may be provided by databases manual inputs by users or other computing devices. After the data are received at the data server the data may be pre processed or indexed in the same manner as data from the sensor modules.

In one embodiment the data server includes hardware or software components for transmitting data to the client device using HTTP Hypertext Transfer Protocol or Ajax Asynchronous JavaScript and XML .

As noted above embodiments may be configured as software elements or modules. The software may include processes that are written or coded as instructions using a programming language. Examples of programming languages may include C C BASIC Perl Matlab Pascal Visual BASIC JAVA ActiveX assembly language machine code and so forth. The instructions may include any suitable type of code such as source code object code compiled code interpreted code executable code static code dynamic code and the like. The software may be stored using any type of computer readable media or machine readable media. Furthermore the software may be stored on the media as source code or object code. The software may also be stored on the media as compressed and or encrypted data. Examples of software may include any software components programs applications computer programs application programs system programs machine programs operating system software middleware firmware software modules routines subroutines functions methods procedures software interfaces application programming interfaces API instruction sets computing code computer code code segments computer code segments words values symbols or any combination thereof. The embodiments are not limited in this context.

