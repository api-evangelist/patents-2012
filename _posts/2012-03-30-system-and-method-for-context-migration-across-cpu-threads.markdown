---

title: System and method for context migration across CPU threads
abstract: One embodiment of the present invention sets forth a technique for associating arbitrary parallel processing unit (PPU) contexts with a given central processing unit (CPU) thread. The technique introduces two operators used to manage the PPU contexts. The first operator is a PPU context push, which causes a PPU driver to store the current PPU context of a calling thread on a PPU context stack and to associate a named PPU context with the calling thread. The second operator is a PPU context pop, which causes the PPU driver to restore the PPU context of a calling function to the PPU context at the top of the PPU context stack. By performing a PPU context push at the beginning of a function and a PPU context pop prior to returning from the function, the function may execute within a single CPU thread, but operate on a two distinct PPU contexts.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09513923&OS=09513923&RS=09513923
owner: NVIDIA Corporation
number: 09513923
owner_city: Santa Clara
owner_country: US
publication_date: 20120330
---
This application is a continuation of U.S. patent application Ser. No. 12 176 287 filed Jul. 18 2008 which is hereby incorporated herein by reference.

Embodiments of the present invention relate generally to parallel processing and more specifically to a system and method for context migration across CPU threads.

Typical parallel processing subsystems include at least one parallel processing unit PPU that may be configured to beneficially provide a high volume of computational throughput that is impractical to achieve with a single processing unit. The PPU may be configured to incorporate a plurality of processing cores each capable of executing one or more instance of a parallel program on a plurality of processing engines. Each executing instance of the parallel program called a PPU thread or simply thread typically computes a portion of the required overall results.

In conventional application execution models a user application may employ PPU threads to perform a portion of the computations required by the user application. A user application commonly includes one or more central processing unit CPU threads executing on the CPU where each CPU thread that employs a PPU to perform computations must include an associated PPU context that is specifically coupled to the CPU thread. The PPU context may remain associated with the related CPU thread for the lifetime of the CPU thread and may not coexist with a second PPU context associated with the same CPU thread. In other words a one to one coupling is created model has certain benefits. One benefit is that CPU threads may efficiently refer to and access data in a related PPU context through the simple one to one CPU thread to PPU context association. In some well known operating systems the PPU context may reside in thread local storage providing an efficient well understood access methodology. An additional benefit arises because only one CPU thread may access a given PPU context at a time thereby eliminating a synchronization step and improving overall performance.

However the conventional execution model also creates certain important inefficiencies. One important inefficiency in the conventional execution model is that an application that may benefit from incorporating multiple PPU contexts is required to incorporate and execute an additional CPU thread per additional PPU context. Each additional thread requires additional memory and execution overhead and introduces additional programming complexity. Furthermore under the conventional execution model libraries that call the PPU to perform computations on behalf of user applications are required to create a worker thread per additional PPU context and delegate any PPU computation from the user application to the worker thread for processing. This delegation process increases application complexity. In both cases overall performance suffers due to the additional execution overhead.

As the foregoing illustrates what is needed in the art is a technique for efficiently managing PPU contexts within multi threaded parallel processing systems.

One embodiment of the present invention sets forth a method for preserving a processing unit context associated with a processing unit thread. The method includes the steps of receiving from a first calling function a request to store a first processing unit context associated with the processing unit thread storing the first processing unit context associating a second processing unit context with the processing unit thread and returning execution to the first calling function.

One advantage of the disclosed method is that it enables a PPU context push at the beginning of a function and a PPU context pop prior to returning from the function. Thus the function may execute within a single CPU thread but advantageously operate on a two distinct PPU contexts.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the present invention.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

As shown in detail for PPU each PPU includes a host interface that communicates with the rest of system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . In one embodiment communication path is a PCI E link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. Host interface generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path and directs them to appropriate components of PPU . For example commands related to processing tasks may be directed to a front end unit while commands related to memory operations e.g. reading from or writing to PP memory may be directed to a memory interface . Host interface front end unit and memory interface may be of generally conventional design and a detailed description is omitted as not being critical to the present invention.

Each PPU advantageously implements a highly parallel processor. As shown in detail for PPU a PPU includes a number C of cores where C 1. Each processing core is capable of executing a large number e.g. tens or hundreds of threads concurrently where each thread is an instance of a program one embodiment of a multithreaded processing core is described below. Cores receive processing tasks to be executed via a work distribution unit which receives commands defining processing tasks from a front end unit . Work distribution unit can implement a variety of algorithms for distributing work. For instance in one embodiment work distribution unit receives a ready signal from each core indicating whether that core has sufficient resources to accept a new processing task. When a new processing task arrives work distribution unit assigns the task to a core that is asserting the ready signal if no core is asserting the ready signal work distribution unit holds the new processing task until a ready signal is asserted by a core . Those skilled in the art will recognize that other algorithms may also be used and that the particular manner in which work distribution unit distributes incoming processing tasks is not critical to the present invention.

Cores communicate with memory interface to read from or write to various external memory devices. In one embodiment memory interface includes an interface adapted to communicate with local PP memory as well as a connection to host interface thereby enabling the cores to communicate with system memory or other memory that is not local to PPU . Memory interface can be of generally conventional design and a detailed description is omitted.

Cores can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local PP memories into internal on chip memory process the data and write result data back to system memory and or local PP memories where such data can be accessed by other system components including e.g. CPU or another parallel processing subsystem .

Referring again to in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various tasks related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and bus interacting with local PP memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments PP subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have its own dedicated PP memory device s or no dedicated PP memory device s .

In operation CPU is the master processor of system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a pushbuffer not explicitly shown in which may be located in system memory PP memory or another storage location accessible to both CPU and PPU . PPU reads the command stream from the pushbuffer and executes commands asynchronously with operation of CPU .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

The connection of PPU to the rest of system may also be varied. In some embodiments PP system is implemented as an add in card that can be inserted into an expansion slot of system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

A PPU may be provided with any amount of local PP memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment in such embodiments little or no dedicated graphics PP memory is provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI E connecting the PPU to system memory e.g. via a bridge chip.

As noted above any number of PPUs can be included in a parallel processing subsystem. For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of the PPUs could be integrated into a bridge chip. The PPUs in a multi PPU system may be identical to or different from each other for instance different PPUs might have different numbers of cores different amounts of local PP memory and so on. Where multiple PPUs are present they may be operated in parallel to process data at higher throughput than is possible with a single PPU.

Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and so on.

In a way similar to a SIMD machine a SIMT parallel processing core executes instances of a single parallel program on different data across a plurality of parallel processing engines included in the core . Thus for example the core may be configured to execute a series of common instructions on the parallel processing engines within the core . The series of instructions to a single parallel processing engine constitutes a thread as defined previously and the collection of a certain number of concurrently executing threads among the parallel processing engines within a core is referred to herein as a warp or thread group. Additionally a plurality of related thread groups may be active in different phases of execution at the same time on a core . This collection of thread groups is referred to herein as a cooperative thread array CIA .

The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines in a core and m is the number of thread groups simultaneously active on the core . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

In one embodiment each core includes an array of P e.g. 8 16 etc. parallel processing engines configured to receive SIMT instructions from a single instruction unit . Each processing engine advantageously includes an identical set of functional units e.g. arithmetic logic units etc. . The functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional units may be provided.

In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

Each processing engine uses space in a local register file LRF for storing its local input data intermediate results and the like. In one embodiment local register file is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each processing engine and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMT execution. In some embodiments each processing engine can only access LRF entries in the lane assigned to it. The total number of entries in local register file is advantageously large enough to support multiple concurrent threads per processing engine .

Each processing engine also has access to an on chip shared memory that is shared among all of the processing engines in core . Shared memory may be as large as desired and in some embodiments any processing engine can read to or write from any location in shared memory with equally low latency e.g. comparable to accessing local register file . In some embodiments shared memory is implemented as a shared register file in other embodiments shared memory can be implemented using shared cache memory.

In addition to shared memory some embodiments also provide additional on chip parameter memory and or cache s which may be implemented e.g. as a conventional RAM or cache. Parameter memory cache can be used e.g. to hold state parameters and or other data e.g. various constants that may be needed by multiple threads. Processing engines also have access via memory interface to off chip global memory which can include e.g. PP memory and or system memory with system memory being accessible by memory interface via host interface as described above. It is to be understood that any memory external to PPU may be used as global memory . Processing engines can be coupled to memory interface via an interconnect not explicitly shown that allows any processing engine to access global memory .

In one embodiment each processing engine is multithreaded and can execute up to some number G e.g. 24 of threads concurrently e.g. by maintaining current state information associated with each thread in a different portion of its assigned lane in local register file . Processing engines are advantageously designed to switch rapidly from one thread to another so that instructions from different threads can be issued in any sequence without loss of efficiency.

Instruction unit is configured such that for any given processing cycle the same instruction INSTR may be issued to all P processing engines . Thus at the level of a single clock cycle core implements a microarchitecture substantially representing a P way SIMT or SIMD design. Since each processing engine is also multithreaded supporting up to G threads concurrently core in this embodiment can have up to P G threads executing concurrently. For instance if P 16 and G 24 then core supports up to 384 concurrent threads.

Because instruction unit may issue the same instruction to all P processing engines in parallel core is advantageously used to process threads in SIMT thread groups. As used herein a SIMT thread group or warp refers to a group of up to P threads of execution of the same program on different input data with one thread of the group being assigned to each processing engine . A SIMT thread group may include fewer than P threads in which case some of processing engines will be idle during cycles when that SIMT thread group is being processed. A SIMT thread group may also include more than P threads in which case processing will take place over consecutive clock cycles. Since each processing engine can support up to G threads concurrently it follows that up to G SIMT thread groups can be executing in core at any given time.

On each clock cycle one instruction is issued to all P threads making up a selected one of the G SIMT thread groups. To indicate which thread group is currently active a warp identifier for the associated warp or thread group may be included with the instruction. Processing engine uses the warp identifier as a context identifier e.g. to determine which portion of its assigned lane in local register file should be used when executing the instruction. Thus in a given cycle all processing engines in core are nominally executing the same instruction for different threads in the same SIMT thread group. In some instances some threads in a SIMT thread group may be temporarily idle e.g. due to conditional or predicated instructions divergence at branches in the program or the like.

The core also includes a vote unit which is configured to receive and execute instructions from the instruction unit to compute vote results. The vote unit computes a given vote result by processing data residing in certain registers within the local register file that may be specified by an associated instruction. The vote unit stores a given vote result in a plurality of registers within the local register file such that related threads executing processing engines may access to the vote result.

Operation of core is advantageously controlled via a core interface . In some embodiments core interface receives data to be processed e.g. primitive data vertex data and or pixel data as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed from work distribution unit . Core interface can load data to be processed into shared memory and parameters into parameter memory . Core interface also initializes each new thread or SIMT thread group in instruction unit then signals instruction unit to begin executing the threads. When execution of a thread or SIMT thread group is completed core advantageously notifies core interface . Core interface can then initiate other processes e.g. to retrieve output data from shared memory and or to prepare core for execution of additional threads or SIMT thread groups.

It will be appreciated that the core architecture described in is illustrative and that variations and modifications of this architecture fall within the scope of the present invention. For example any number of processing engines may be included in each core . In some embodiments each processing engine has its own local register file and the allocation of local register file entries per thread can be fixed or configurable as desired. Further while only one core is shown a PPU may include any number of cores which are advantageously of identical design to each other so that execution behavior does not depend on which core receives a particular processing task. Each core advantageously operates independently of other cores and has its own processing engines shared memory and so on.

Persons skilled in the art will understand that the architecture described in in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more GPUs one or more multi core GPUs or the like without departing the scope of the present invention.

In some embodiments multithreaded processing core of can execute general purpose computations using thread blocks or thread arrays. A thread array consists of a number n of threads that concurrently execute the same program on an input data set to produce an output data set. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during its execution. The thread ID controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

In some embodiments the thread arrays are arranged as cooperative thread arrays or CTAs. Each CTA is a group of threads that concurrently execute the same program referred to herein as a CTA program on an input data set to produce an output data set. In a CTA the threads can cooperate by sharing data with each other in a manner that depends on thread ID. For instance in a CTA data can be produced by one thread and consumed by another. In some embodiments synchronization instructions can be inserted into the CTA program code at points where data is to be shared to ensure that the data has actually been produced by the producing thread before the consuming thread attempts to access it. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program.

In some embodiments threads in a CTA share input data and or intermediate results with other threads in the same CTA using shared memory of . For example a CTA program might include an instruction to compute an address in shared memory to which particular data is to be written with the address being a function of thread ID. Each thread computes the function using its own thread ID and writes to the corresponding location. The address function is advantageously defined such that different threads write to different locations as long as the function is deterministic the location written to by any thread is predictable. The CTA program can also include an instruction to compute an address in shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA.

CTAs or other types of thread arrays are advantageously employed to perform computations that lend themselves to a data parallel decomposition. As used herein a data parallel decomposition includes any situation in which a computational problem is solved by executing the same algorithm multiple times in parallel on input data to generate output data for instance one common instance of data parallel decomposition involves applying the same processing algorithm to different portions of an input data set in order to generate different portions an output data set. Examples of problems amenable to data parallel decomposition include matrix algebra linear and or nonlinear transforms in any number of dimensions e.g. Fast Fourier Transforms and various filtering algorithms including convolution filters in any number of dimensions separable filters in multiple dimensions and so on. The processing algorithm to be applied to each portion of the input data set is specified in the CTA program and each thread in a CTA executes the same CTA program on one portion of the input data set or produces one portion of the output data set. A CTA program can implement algorithms using a wide range of mathematical and logical operations and the program can include conditional or branching execution paths and direct and or indirect memory access.

For example as is known in the art an array of data values e.g. pixels can be filtered using a 2 D kernel based filter algorithm in which the filtered value of each pixel is determined based on the pixel and its neighbors. In some instances the filter is separable and can be implemented by computing a first pass along the rows of the array to produce an intermediate array then computing a second pass along the columns of the intermediate array. In one CTA implementation of a separable 2 D filter the threads of the CTA load the input data set or a portion thereof into shared memory then synchronize. Each thread performs the row filter for one point of the data set and writes the intermediate result to shared memory . After all threads have written their row filter results to shared memory and have synchronized at that point each thread performs the column filter for one point of the data set. In the course of performing the column filter each thread reads the appropriate row filter results from shared memory and a thread may read row filter results that were written by any thread of the CTA. The threads write their column filter results to shared memory . The resulting data array can be stored to global memory or retained in shared memory for further processing. Where shared memory can be accessed with lower latency and or greater bandwidth than global memory storing intermediate results in shared memory advantageously improves processor throughput. In one embodiment a driver program executing on CPU of writes commands defining the CTA to a pushbuffer not explicitly shown in memory e.g. system memory from which the commands are read by a PPU . The commands advantageously are associated with state parameters such as the number of threads in the CTA the location in global memory of an input data set to be processed using the CTA the location in global memory of the CTA program to be executed and the location in global memory where output data is to be written. The state parameters may be written to the pushbuffer together with the commands. In response to the commands core interface loads the state parameters into core e.g. into parameter memory then begins launching threads until the number of threads specified in the CTA parameters have been launched. In one embodiment core interface assigns thread IDs sequentially to threads as they are launched. More generally since all threads in a CTA execute the same program in the same core any thread can be assigned any thread ID as long as each valid thread ID is assigned to only one thread. Any unique identifier including but not limited to numeric identifiers can be used as a thread ID. In one embodiment if a CTA includes some number n of threads thread IDs are simply sequential one dimensional index values from 0 to n 1. In other embodiments multidimensional indexing schemes can be used. It should be noted that as long as data sharing is controlled by reference to thread IDs the particular assignment of threads to processing engines will not affect the result of the CTA execution. Thus a CTA program can be independent of the particular hardware on which it is to be executed.

In some embodiments warps consisting of more threads than processing engines may execute on the processing engines through a regime of time interleaving. For example a warp consisting of 32 threads may execute on eight processing engines over the course of four instruction cycles. Persons skilled in the art will recognize that core may include a different number of processing engines and registers within the local register file to accommodate data storage for the threads without departing from the scope of the invention.

Each CPU thread within the user application may perform independent tasks for the user application where each task requires a different PPU context. Alternatively certain CPU threads may perform tasks that require the same PPU context. In both cases the library may require a yet different PPU context to properly perform tasks assigned by the user application . In existing art PPU context and PPU context must be associated with two independent CPU threads thereby incurring inefficiencies that diminish the performance of user application when the two. However with the addition of a PPU context push operation and a PPU context pop operation one CPU thread may use two or more persistent PPU contexts. Additionally each PPU context may be used by any arbitrary PPU thread. The PPU context push and PPU context pop operations are invoked via the PPU API.

When the PPU driver receives a PPU context push request the PPU driver pushes the current PPU context associated with the calling CPU thread onto a PPU context stack and associates a new PPU context with the calling CPU thread. A reference to the new PPU context may be passed to the PPU driver via the PPU context push request. Alternatively the PPU driver may create the new PPU context if no PPU context is named in the PPU context push request.

Any number of PPU contexts may exist at any one time where one or more PPU context may not be associated with a PPU thread. Any PPU context that is not associated to a CPU thread is referred to as floating. 

When CPU thread of user application calls a library function within library the library should request a PPU context push prior to performing the requested library function. In this scenario library names PPU context as the new PPU context to be associated with the calling CPU thread . CPU thread may then execute library functions within library while using PPU context which is owned by library .

Prior to returning from a function call library performs a PPU context pop which restores PPU context as the current PPU context of CPU thread . In this way CPU thread may execute arbitrary functions within library each of which may use an arbitrary PPU context. Importantly CPU thread need not be aware of any PPU context manipulation conducted by library . In fact the function call interface may appear to be identical to any standard function call interface.

In this scenario the function calling sequence illustrated in is expanded to include an additional calling level to a second library function within library . Library may be distinct from library and may require a separate PPU context. Using the PPU context push and PPU context pop operations discussed in library is able to execute an arbitrary library function using PPU context which is owned by library .

CPU thread calls a first function within library . The first function performs a PPU context push making PPU context the current PPU context for CPU thread . The first function calls a second function within library . The second function performs a PPU context push thereby making PPU context the current PPU context for CPU thread . Prior to returning the second function performs a PPU context pop restoring PPU context as the current PPU context for CPU thread . Prior to returning the first function performs a PPU context pop restoring PPU context as the current PPU context for CPU thread .

The method begins in step where a parallel processing unit PPU driver receives a request from a central processing unit CPU thread to push a PPU context. In step the PPU driver pushes a current PPU context onto a PPU context stack. In step the PPU driver associates a named PPU context with the CPU thread. In step the PPU driver returns execution to the calling function. At this point the CPU thread is associated with the named PPU context. The method terminates in step .

The method begins in step where the PPU driver receives a request from the central processing unit thread to pop a PPU context. In step the PPU driver pops the PPU context from the top element of the PPU context stack. In step the PPU driver associates a popped PPU context if any with the CPU thread. Persons skilled in the art will appreciate that under certain circumstances the PPU context stack may be empty and the PPU driver does not need to associate a popped null context with the CPU thread. In step the PPU driver returns execution to the calling function. At this point the PPU context associated with the calling CPU thread is restored to the previous PPU context from the top of the PPU context stack. The method terminates in step .

In sum a technique for enabling CPU threads to use one or more existing PPU contexts is disclosed. The technique allows a first function with a first PPU context to directly call a second function with a second PPU context where the first function need not be aware of any PPU context management on the part of the second function. The technique introduces two operators used manage the PPU contexts. The first operator is the PPU context push which causes the PPU driver to store the current PPU context of a calling thread on a PPU context stack and to associate a named PPU context with the calling thread. The second operator is a PPU context pop which causes the PPU driver to restore the PPU context of a calling function to the PPU context at the top of the PPU context stack. By performing a PPU context push at the beginning of a function and a PPU context pop prior to returning from the function the function may execute within a single CPU thread but advantageously operate on a two distinct PPU contexts.

While the forgoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the present invention. Therefore the scope of the present invention is determined by the claims that follow.

