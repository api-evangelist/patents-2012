---

title: Identifying function calls and object method calls
abstract: A device receives program code, generated via a technical computing environment (TCE) and including code that requires further processing to execute, and identifies one or more function calls or one or more object method calls in the program code. The device creates a control flow graph, for the program code, based on the one or more function calls or the one or more object method calls. The device transforms the control flow graph into a data flow graph. The data flow graph includes a representation for each of the one or more function calls or the one or more object method calls. The device generates hardware code based on the data flow graph, the hardware code including code that does not require further processing to execute.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09032380&OS=09032380&RS=09032380
owner: The MathWorks, Inc.
number: 09032380
owner_city: Natick
owner_country: US
publication_date: 20121204
---
This application claims priority under 35 U.S.C. 119 based on U.S. Provisional Patent Application No. 61 566 910 filed Dec. 5 2011 the disclosure of which is incorporated by reference herein in its entirety.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate one or more implementations and together with the description explain these implementations. In the drawings 

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements.

A technical computing environment TCE may provide a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal etc. In one example a TCE may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations.

Code generated by the TCE may include function calls and or object method calls. A function call may include a function name followed by one or more arguments. One or more output values may be assigned as an output of the function call. A method may define behavior of an object. An object method may be called using function syntax that passes the object as a first i.e. left most argument. However it is difficult to identify function calls and object method calls in TCE designs targeted for hardware code generation.

Systems and or methods described herein may identify function calls and or object method calls in TCE designs targeted for hardware code generation. In one example the systems and or methods may receive code generated by a TCE and may identify function call s and or object method call s in the code. The systems and or methods may create a control flow graph for the code based on the identified function call s and or object method call s . The control flow graph may preserve the hierarchy of the identified function call s and or object method call s . The systems and or methods may transform the control flow graph into a data flow graph and may generate hardware code based on the data flow graph. The data flow graph may be analyzed to determine opportunities for numeric and latency optimization in the code. Such opportunities may be implemented in the hardware code.

In one example the code may be optimized so that performance associated with the code is improved along some parameter e.g. power area latency etc. . The optimized code may not necessarily mean that an optimum e.g. no further improvements are possible is attained.

As further shown in the code identifier component may receive code generated by the TCE. The TCE code may include text based code that may require further processing to execute binary code that may be executed text files that may be executed in conjunction with other executables etc. In one example the TCE code may include the following syntax 

The code identifier component may identify one or more function calls and or object method calls in the TCE code. In one example the code identifier component may use data types sizes complexity etc. information associated with the TCE code to infer or identify a hierarchy of function calls and or object method calls in the TCE code. The code identifier component may create a control flow graph for the code based on the identified function calls and or object method calls. The control flow graph may preserve the hierarchy of the identified function call s and or object method call s . The code identifier component may transform the control flow graph into a data flow graph. The data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of the function calls and or object method calls that are to be executed by one or more hardware devices e.g. a central processing unit CPU a graphical processing unit GPU etc. of an architecture model. The signals may include representations of connections e.g. communication interfaces and or channels provided between the function calls and or object method calls. The code identifier component may provide the data flow graph to the hardware code generator component.

The hardware code generator component may receive the data flow graph and may receive target hardware information. The target hardware information may include information associated with hardware devices e.g. of the architecture model upon which the TCE code is to be executed. The hardware code generator component may generate optimized hardware code based on the data flow graph and the target hardware information. In one example the hardware code may be optimized by enabling the function calls and or the object method calls to be executed in parallel and or to share the hardware devices during execution. The optimized hardware code may be executed by the hardware devices associated with the target hardware information.

The terms code and program code as used herein are to be used interchangeably and are to be broadly interpreted to include text based code that may require further processing to execute binary code that may be executed e.g. executable files that may directly be executed by an operating system bitstream files that can be used to configure a field programmable gate array FPGA Java byte code object files combined together with linker directives source code makefiles etc. text files that may be executed in conjunction with other executables e.g. Python text files a collection of dynamic link library DLL files with text based combining configuration information that connects pre compiled modules an extensible markup language XML file describing module linkage etc. etc. In one example code may include different combinations of the above identified classes e.g. text based code binary code text files etc. . Alternatively or additionally code may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations. Alternatively or additionally code may be of any type such as function script object etc. and a portion of code may include one or more characters lines etc. of the code. The code may be untimed in addition to being array based and dynamically types.

The term hardware code as used herein is to be broadly interpreted to include text based code that may not require further processing to execute such as for example C code Hardware Description Language HDL code very high speed integrated circuits VHSIC HDL VHDL code Verilog Java and or other types of hardware or software based code that may be compiled and or synthesized.

Client device may include one or more devices that are capable of communicating with server device via network . For example client device may include a laptop computer a personal computer a tablet computer a desktop computer a workstation computer a smart phone a personal digital assistant PDA and or other computation and communication devices.

Server device may include one or more server devices or other types of computation and communication devices that gather process and or provide information in a manner described herein. Server device may include a device that is capable of communicating with client device e.g. via network . In one example server device may include one or more laptop computers personal computers workstation computers servers central processing units CPUs graphical processing units GPUs application specific integrated circuits ASICs field programmable gate arrays FPGAs etc. and or software e.g. a simulator executing on the aforementioned devices. In one example server device may include TCE and may perform some or all of the functionality described herein for client device . Alternatively server device may be omitted and client device may perform all of the functionality described herein for client device .

Network may include a network such as a local area network LAN a wide area network WAN a metropolitan area network MAN a telephone network such as the Public Switched Telephone Network PSTN an intranet the Internet or a combination of networks.

TCE may be provided within a computer readable medium of client device . Alternatively or additionally TCE may be provided in another device e.g. server device that is accessible by client device . TCE may include hardware or a combination of hardware and software that provides a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal etc. In one implementation TCE may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations.

For example TCE may use an array as a basic element where the array may not require dimensioning. These arrays may be used to support array based programming where an operation may apply to an entire set of values included in the arrays. Array based programming may allow array based operations to be treated as high level programming that may allow for example operations to be performed on entire aggregations of data without having to resort to explicit loops of individual non array operations. In addition TCE may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development etc. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design etc.

TCE may further provide mathematical functions and or graphical tools e.g. for creating plots surfaces images volumetric representations etc. . In one implementation TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . Alternatively or additionally TCE may provide these functions as block sets or in another way such as via a library etc.

TCE may be implemented as a text based environment e.g. MATLAB software Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence Modelica or Dymola from Dynasim etc. a graphically based environment e.g. Simulink software Stateflow software SimEvents software Simscape software etc. by The MathWorks Inc. VisSim by Visual Solutions LabView by National Instruments Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhopsody or Tau from Telelogic Ptolemy from the University of California at Berkeley aspects of a Unified Modeling Language UML or SysML environment etc. or another type of environment such as a hybrid environment that includes one or more of the above referenced text based environments and one or more of the above referenced graphically based environments.

TCE may include a programming language e.g. the MATLAB language that may be used to express problems and or solutions in mathematical notations. The programming language may be dynamically typed and or array based. In a dynamically typed array based computing language data may be contained in arrays and data types of the data may be determined e.g. assigned at program execution time.

For example suppose a program written in a dynamically typed array based computing language includes the following statements 

Now suppose the program is executed for example in a TCE such as TCE . During execution or run time when the statement A hello is executed the data type of variable A may be a string data type. Later when the statement A int32 1 2 is executed the data type of variable A may be a 1 by 2 array containing elements whose data type are 32 bit integers. Later when the statement A 1.1 2.2 3.3 is executed since the language is dynamically typed the data type of variable A may be changed from the above 1 by 2 array to a 1 by 3 array containing elements whose data types are floating point. As can be seen by this example data in a program written in a dynamically typed array based computing language may be contained in an array. Moreover the data type of the data may be determined during execution of the program. Thus in a dynamically type array based computing language data may be represented by arrays and data types of data may be determined at run time.

TCE may provide mathematical routines and a high level programming language suitable for non professional programmers and may provide graphical tools that may be used for creating plots surfaces images volumetric representations or other representations. TCE may provide these routines and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . TCE may also provide these routines in other ways such as for example via a library local or remote database e.g. a database operating in a computing cloud remote procedure calls RPCs and or an application programming interface API . TCE may be configured to improve runtime performance when performing computing operations. For example TCE may include a just in time JIT compiler.

Although shows example components of environment in other implementations environment may include fewer components different components differently arranged components and or additional components than those depicted in . Alternatively or additionally one or more components of environment may perform one or more other tasks described as being performed by one or more other components of environment .

Processing unit may include one or more processors microprocessors or other types of processing units that may interpret and execute instructions. Main memory may include one or more random access memories RAMs or other types of dynamic storage devices that may store information and or instructions for execution by processing unit . ROM may include one or more ROM devices or other types of static storage devices that may store static information and or instructions for use by processing unit . Storage device may include a magnetic and or optical recording medium and its corresponding drive.

Input device may include a mechanism that permits a user to input information to device such as a keyboard a camera an accelerometer a gyroscope a mouse a pen a microphone voice recognition and or biometric mechanisms a remote control a touch screen a neural interface etc. Output device may include a mechanism that outputs information to the user including a display a printer a speaker etc. Communication interface may include any transceiver like mechanism that enables device to communicate with other devices networks and or systems. For example communication interface may include mechanisms for communicating with another device or system via a network.

As described herein device may perform certain operations in response to processing unit executing software instructions contained in a computer readable medium such as main memory . A computer readable medium may be defined as a non transitory memory device. A memory device may include space within a single physical memory device or spread across multiple physical memory devices. The software instructions may be read into main memory from another computer readable medium such as storage device or from another device via communication interface . The software instructions contained in main memory may cause processing unit to perform processes described herein. Alternatively hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus implementations described herein are not limited to any specific combination of hardware circuitry and software.

Although shows example components of device in other implementations device may include fewer components different components differently arranged components and or additional components than depicted in . Alternatively or additionally one or more components of device may perform one or more other tasks described as being performed by one or more other components of device .

Block diagram editor may include hardware or a combination of hardware and software that may be used to graphically specify models of dynamic systems. In one implementation block diagram editor may permit a user to perform actions such as construct edit display annotate save and or print a graphical model e.g. a block diagram that visually and or pictorially represents a dynamic system . In another implementation block diagram editor may permit a user to create and or store data relating to graphical entities .

A textual interface may be provided to permit interaction with block diagram editor . A user may write scripts that perform automatic editing operations on a model using the textual interface. For example the textual interface may provide a set of windows that may act as a canvas for the model and may permit user interaction with the model. A model may include one or more windows depending on whether the model is partitioned into multiple hierarchical levels.

Graphical entities may include hardware or a combination of hardware and software that may provide entities e.g. signal lines buses etc. that represent how data may be communicated between functional and or non functional units and blocks of a model. Blocks may include fundamental mathematical elements of a block diagram model.

Execution engine may include hardware or a combination of hardware and software that may process a graphical model to produce simulation results may convert the graphical model into executable code and or may perform other analyses and or related tasks. In one implementation for a block diagram graphical model execution engine may translate the block diagram into executable entities e.g. units of execution following the layout of the block diagram. The executable entities may be compiled and or executed on a device e.g. client device to implement the functionality specified by the model.

Graphical models may include entities with relationships between the entities and the relationships and or the entities may have attributes associated with them. The entities my include model elements such as blocks and ports. The relationships may include model elements such as lines e.g. connector lines and references. The attributes may include model elements such as value information and meta information for the model element associated with the attributes. Graphical models may be associated with configuration information. The configuration information may include information for the graphical model such as model execution information e.g. numerical integration schemes fundamental execution period etc. model diagnostic information e.g. whether an algebraic loop should be considered an error or result in a warning model optimization information e.g. whether model elements should share memory during execution model processing information e.g. whether common functionality should be shared in code that is generated for a model etc.

Additionally or alternatively a graphical model may have executable semantics and or may be executable. An executable graphical model may be a time based block diagram. A time based block diagram may consist for example of blocks e.g. blocks connected by lines e.g. connector lines . The blocks may consist of elemental dynamic systems such as a differential equation system e.g. to specify continuous time behavior a difference equation system e.g. to specify discrete time behavior an algebraic equation system e.g. to specify constraints a state transition system e.g. to specify finite state machine behavior an event based system e.g. to specify discrete event behavior etc. The lines may represent signals e.g. to specify input output relations between blocks or to specify execution dependencies between blocks variables e.g. to specify information shared between blocks physical connections e.g. to specify electrical wires pipes with volume flow rigid mechanical connections etc. etc. The attributes may consist of meta information such as sample times dimensions complexity whether there is an imaginary component to a value data type etc. associated with the model elements.

In a time based block diagram ports may be associated with blocks e.g. blocks . A relationship between two ports may be created by connecting a line e.g. a connector line between the two ports. Lines may also or alternatively be connected to other lines for example by creating branch points. For instance three or more ports can be connected by connecting a line to each of the ports and by connecting each of the lines to a common branch point for all of the lines. A common branch point for the lines that represent physical connections may be a dynamic system e.g. by summing all variables of a certain type to 0 or by equating all variables of a certain type . A port may be an input port an output port an enable port a trigger port a function call port a publish port a subscribe port an exception port an error port a physics port an entity flow port a data flow port a control flow port etc.

Relationships between blocks e.g. blocks may be causal and or non causal. For example a model may include a block that represents a continuous time integration block that may be causally related to a data logging block by using a line e.g. a connector line to connect an output port of the continuous time integration block to an input port of the data logging block. Further during execution of the model the value stored by the continuous time integrator may change as the current time of the execution progresses. The value of the state of the continuous time integrator may be available on the output port and the connection with the input port of the data logging block may make this value available to the data logging block.

A sample time may be associated with the elements of a graphical model. For example a graphical model may include a block e.g. block with a continuous sample time such as a continuous time integration block that may integrate an input value as time of execution progresses. This integration may be specified by a differential equation. During execution the continuous time behavior may be approximated by a numerical integration scheme that is part of a numerical solver. The numerical solver may take discrete steps to advance the execution time and these discrete steps may be constant during an execution e.g. fixed step integration or may be variable during an execution e.g. variable step integration .

Alternatively or additionally a graphical model may include a block e.g. block with a discrete sample time such as a unit delay block that may output values of a corresponding input after a specific delay. This delay may be a time interval and this interval may determine a sample time of the block. During execution the unit delay block may be evaluated each time the execution time has reached a point in time where an output of the unit delay block may change. These points in time may be statically determined based on a scheduling analysis of the graphical model before starting execution.

Alternatively or additionally a graphical model may include a block e.g. block with an asynchronous sample time such as a function call generator block that may schedule a connected block to be evaluated at a non periodic time. During execution a function call generator block may evaluate an input and when the input attains a specific value when the execution time has reached a point in time the function call generator block may schedule a connected block to be evaluated at this point in time and before advancing execution time.

Further the values of attributes of a graphical model may be inferred from other elements of the graphical model or attributes of the graphical model. For example the graphical model may include a block e.g. block such as a unit delay block that may have an attribute that specifies a sample time of the block. When a graphical model has an execution attribute that specifies a fundamental execution period the sample time of the unit delay block may be inferred from this fundamental execution period.

As another example the graphical model may include two unit delay blocks e.g. blocks where the output of the first of the two unit delay blocks is connected to the input of the second of the two unit delay block. The sample time of the first unit delay block may be inferred from the sample time of the second unit delay block. This inference may be performed by propagation of model element attributes such that after evaluating the sample time attribute of the second unit delay block a graph search proceeds by evaluating the sample time attribute of the first unit delay block since it is directly connected to the second unit delay block.

The values of attributes of a graphical model may be set to characteristics settings such as one or more inherited settings one or more default settings etc. For example the data type of a variable that is associated with a block e.g. block may be set to a default such as a double. Because of the default setting an alternate data type e.g. a single an integer a fixed point etc. may be inferred based on attributes of elements that the graphical model comprises e.g. the data type of a variable associated with a connected block and or attributes of the graphical model. As another example the sample time of a block may be set to be inherited. In case of an inherited sample time a specific sample time may be inferred based on attributes of elements that the graphical model comprises and or attributes of the graphical model e.g. a fundamental execution period .

Although shows example functional components of TCE in other implementations TCE may include fewer functional components different functional components differently arranged functional components and or additional functional components than depicted in . Alternatively or additionally one or more functional components of TCE may perform one or more other tasks described as being performed by one or more other functional components of TCE .

Code identifier component may receive code generated by TCE . TCE code may include text based code that may require further processing to execute binary code that may be executed text files that may be executed in conjunction with other executables etc. In one example TCE code may include the following syntax 

Code identifier component may identify one or more function calls and or object method calls in TCE code as indicated by reference number . In the example TCE code code identifier component may identify t1 leftchannel processing u and t2 rightchannel processing u as function calls in TCE code . In one example code identifier component may use data types sizes complexity etc. information associated with TCE code to infer or identify a hierarchy of function calls object method calls in TCE code . Code identifier component may identify function calls object method calls in TCE code when TCE code is being compiled or before or after TCE code is compiled.

Code identifier component may create a control flow graph for TCE code based on the identified function calls and or object method calls . The control flow graph may preserve the hierarchy of the identified function calls and or object method calls . The control flow graph may not change function call hierarchy in TCE code but may contain functions of TCE code and or calls to those functions. Nodes of a data structure of the control flow graph may be traversed to identify function and or method calls. Code identifier component may take TCE code and create a control flow graph intermediate representation. Code identifier component may process the control flow graph in multiple analysis translation and or optimization stages e.g. for efficiency and scalability to create an internal representation suitable for detecting function calls and or system object method calls in TCE code . In one example code identifier component may identify system object method calls and or function calls in procedural and untimed TCE code .

Code identifier component may convert the identified system object method calls and or function calls into a data flow and may extract parallelism from the data flow. For example code identifier component may convert procedural languages e.g. Fortran C MATLAB etc. in the control flow graph into data driven execution e.g. Simulink in a data flow graph . Alternatively or additionally code identifier component may convert sequential machines e.g. assembly or C language on processors in the control flow graph into parallel machines e.g. HDL on hardware C on GPUs Simulink etc. in data flow graph .

Such operations may transform the control flow graph into data flow graph . Data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of function calls object method calls that are to be executed by one or more hardware devices e.g. a CPU a GPU one or more cores of a CPU or GPU etc. of an architecture model. The signals may include representations of connections e.g. communication interfaces and or channels provided between function calls object method calls . Edges of data flow graph may have timing inferred automatically. The transformation to data flow graph may ensure that latency changes are introduced without affecting any numerical differences in TCE code . Code identifier component may infer timing by analysis of the control flow graph and by converting the control flow graph to data flow graph in the presence of function calls and or system object calls.

In one example a function e.g. biquad filter may be called a number e.g. numSections of times in the following TCE code 

Function call hierarchy of TCE code may be independent of data typing. The control flow graph may be created with data types inferred from TCE code . The data types may not affect function call hierarchy in the control flow graph. Depending on the kinds of data types used in calling functions the control flow graph may have multiple function call statements with different kinds of inputs. Code identifier component may transform the multiple function call statements into data flow graph as described above.

As further shown in code identifier component may provide data flow graph to hardware code generator component . Hardware code generator component may receive data flow graph and may receive target hardware information e.g. from a user of TCE . Target hardware information may include information associated with a hardware device s e.g. of the architecture model upon which TCE code is to be executed. Hardware code generator component may generate optimized hardware code based on data flow graph and target hardware information . In one implementation hardware code may be optimized by enabling function calls object method calls to be executed in parallel and or to share the hardware device s during execution. Optimized hardware code may be executed by the hardware device s associated with target hardware information .

In one example hardware code generator component may determine that TCE code includes function calls object method calls that may be executed in parallel. Hardware code generator component may configure hardware code to execute such function calls object method calls in parallel which may conserve execution time of hardware code . Alternatively or additionally hardware code generator component may determine that the function calls e.g. t1 leftchannel processing u and t2 rightchannel processing u in TCE code are identical and require the same hardware devices. Hardware code generator component may configure hardware code to utilize the same hardware device e.g. rather than two separate hardware devices for the function calls which may conserve hardware resources.

Alternatively or additionally hardware code generator component may output e.g. provide for display and or store hardware code . Hardware code generator component may provide in a graphical view traceability between TCE and the identified function calls object method calls in addition to the generated hardware code .

Although shows example operations capable of being performed by TCE in other implementations TCE may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

TCE e.g. code identifier component may identify one or more function calls in TCE code . In the example TCE code TCE e.g. code identifier component may identify t1 leftchannel processing u and t2 rightchannel processing u as function calls . In one implementation TCE may use data types sizes complexity etc. information associated with TCE code to infer or identify a hierarchy of function calls in TCE code . TCE may utilize the identified function calls as indicated by reference number to create a data flow graph .

Data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of function calls that are to be executed by one or more hardware devices e.g. a CPU a GPU one or more cores of a CPU or GPU etc. of an architecture model. In one example data flow graph may include a first representation e.g. a node labeled LCP for a first function call e.g. t1 leftchannel processing u and a second representation e.g. a node labeled RCP for a second function call e.g. t2 rightchannel processing u . The signals may include representations of connections e.g. communication interfaces and or channels provided between function calls .

TCE e.g. hardware code generator component not shown may determine optimization information for data flow graph . Optimization information may include target hardware information information identifying that hardware code generated from data flow graph may be optimized by enabling function calls to be executed in parallel and or to share the hardware devices during execution etc. TCE e.g. hardware code generator component may generate optimized hardware code based on data flow graph and or optimization information .

In one example TCE e.g. hardware code generator component may determine that function calls e.g. t1 leftchannel processing u and t2 rightchannel processing u are identical and require the same hardware devices. TCE e.g. hardware code generator component may configure hardware code to utilize a single hardware device e.g. rather than two separate hardware devices for function calls . As shown in the two representations e.g. the LCP node and the RCP node for function calls may be merged into a single representation e.g. a node labeled LCP RCP that may be executed on single hardware device .

Although shows example function call operations capable of being performed by TCE in other implementations TCE may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

TCE e.g. code identifier component may identify one or more object definitions and or one or more object definitions method calls in TCE code . In the example TCE code TCE e.g. code identifier component may identify hL channel speakerpos left and hR channel speakerpos right as object definitions and may identify as t1 step hL u and t2 step hR u as object method calls. In one implementation TCE may use data types sizes complexity etc. information associated with TCE code to infer or identify a hierarchy of object definitions method calls in TCE code . TCE may utilize the identified object definitions method calls as indicated by reference number to create a data flow graph .

Data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of object definitions method calls that are to be executed by one or more hardware devices e.g. a CPU a GPU one or more cores of a CPU or GPU etc. of an architecture model. In one example data flow graph may include a first representation e.g. a node labeled LCP for a first object method call e.g. t1 step hL u and a second representation e.g. a node labeled RCP for a second object method call e.g. t2 step hR u . The signals may include representations of connections e.g. communication interfaces and or channels provided between object definitions method calls .

TCE e.g. hardware code generator component not shown may determine optimization information for data flow graph . Optimization information may include target hardware information information identifying that hardware code generated from data flow graph may be optimized by enabling object definitions method calls to be executed in parallel and or to share the hardware devices during execution etc. TCE e.g. hardware code generator component may generate optimized hardware code based on data flow graph and or optimization information .

In one example TCE e.g. hardware code generator component may determine that object definitions method calls e.g. hL channel speakerpos left and hR channel speakerpos right are identical and require the same hardware devices. TCE e.g. hardware code generator component may configure hardware code to utilize a single hardware device e.g. rather than two separate hardware devices for object definitions method calls . As shown in the two representations e.g. the LCP node and the RCP node for object definitions method calls may be merged into a single representation e.g. a node labeled LCP RCP that may be executed on single hardware device .

Although shows example object method call operations capable of being performed by TCE in other implementations TCE may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

Code identifier component may identify code within identified one or more function object method calls in TCE code . In the example TCE code code identifier component may identify a i b i c i as code within an identified function object method call. In one implementation code identifier component may use data types sizes complexity etc. information associated with TCE code to infer or identify a hierarchy of code within identified function object method calls in TCE code . Code identifier component may utilize code within identified function object method calls as indicated by reference number to create a data flow graph .

Data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of code within identified function object method calls that are to be executed by one or more hardware devices of an architecture model. The signals may include representations of connections provided between code within identified function object method calls. In one example data flow graph may include inputs e.g. b through b and c through c multipliers and outputs e.g. a through a . Inputs may include input variables to a multiplication function. Multipliers may include representations e.g. nodes of a function that multiplies inputs . For example a first multiplier may multiply inputs e.g. b and c a second multiplier may multiply inputs e.g. b and c etc. Outputs may include output variables of the multiplication function.

Code identifier component may determine optimization information from data flow graph . Optimization information may include target hardware information information identifying that hardware code generated from data flow graph may be optimized by enabling code within identified function object method calls to be executed in parallel. Hardware code generator component not shown may generate optimized hardware code based on data flow graph and or optimization information . If optimization information indicates that hardware code cannot be executed in parallel hardware code generator component not shown may generate optimized hardware code that serially executes code within identified function object method calls.

Although shows example operations capable of being performed by code identifier component in other implementations code identifier component may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

Inputs may include input variables to a multiplication function. Multipliers may include representations e.g. nodes of a function that multiplies inputs . For example a first multiplier may multiply inputs e.g. u and u and a second multiplier may multiply inputs e.g. u and u . Outputs may include output variables of the multiplication function.

Hardware code generator component may determine optimization information for data flow graph . Optimization information may include target hardware information information identifying that hardware code generated from data flow graph may be optimized by enabling multipliers to share the same hardware device during execution etc. Hardware code generator component may generate optimized hardware code based on data flow graph and or optimization information .

In one example hardware code generator component may determine that multipliers are identical e.g. perform the same function and require the same hardware devices. Hardware code generator component may configure hardware code to utilize a single hardware device e.g. rather than two separate hardware devices for a single multiplier . As shown in the two multipliers may be merged into a single multiplier that may be executed on a single hardware device. Optimized hardware code may include input processing logic that provides the correct inputs to the single multiplier . As further shown optimized hardware code may include output processing logic that provides the correct outputs from the single multiplier . In such an arrangement the single multiplier may provide a faster rate of processing.

Although shows example operations capable of being performed by hardware code generator component in other implementations hardware code generator component may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

As shown in process may include receiving code generated via a technical computing environment TCE block and identifying function call s and or object method call s in the code block . For example in an implementation described above in connection with code identifier component of TCE may receive code generated by TCE . TCE code may include text based code that may require further processing to execute binary code that may be executed text files that may be executed in conjunction with other executables etc. Code identifier component may identify one or more function calls and or object method calls in TCE code as indicated by reference number . In one example code identifier component may use data types sizes complexity etc. information associated with TCE code to infer or identify a hierarchy of function calls object method calls in TCE code .

As further shown in process may include generating a control flow graph for the code based on the identified function call s and or object method call s block . For example in an implementation described above in connection with code identifier component may create a control flow graph for TCE code based on the identified function calls and or object method calls . The control flow graph may preserve the hierarchy of the identified function calls and or object method calls .

Returning to process may include transforming the control flow graph into a data flow graph block and generating hardware code based on the data flow graph block . For example in an implementation described above in connection with code identifier component may transform the control flow graph into a data flow graph . Data flow graph may include nodes and or signals provided between the nodes. The nodes may include representations of function calls object method calls that are to be executed by one or more hardware devices of an architecture model. The signals may include representations of connections provided between function calls object method calls . Code identifier component may provide data flow graph to hardware code generator component of TCE . Hardware code generator component may receive data flow graph and may receive target hardware information . Hardware code generator component may generate optimized hardware code based on data flow graph and target hardware information .

Process block may include the process blocks depicted in . As shown in process block may include creating representations of the identified function call s and or object method call s block determining whether the representations can share target hardware block and modifying the data flow graph based on the representations that can share target hardware and or explore area speed and or power tradeoffs for the target hardware block . For example in an implementation described above in connection with data flow graph may include representations of function calls that are to be executed by one or more hardware devices of an architecture model. In one example data flow graph may include a first representation e.g. a node labeled LCP for a first function call e.g. t1 leftchannel processing u and a second representation e.g. a node labeled RCP for a second function call e.g. t2 rightchannel processing u . In one example TCE may determine that function calls e.g. t1 leftchannel processing u and t2 rightchannel processing u are identical and require the same hardware devices. TCE may configure hardware code to utilize single hardware device e.g. rather than two separate hardware devices for function calls . The two representations e.g. the LCP node and the RCP node for function calls may be merged into a single representation e.g. a node labeled LCP RCP that may be executed on single hardware device .

Process block may include the process blocks depicted in . As shown in process block may include receiving information associated with target hardware block and determining whether portion s of the data flow graph can execute in parallel on the target hardware block . For example in an implementation described above in connection with hardware code generator component may receive data flow graph and may receive target hardware information e.g. from a user of TCE . Target hardware information may include information associated with hardware devices e.g. of the architecture model upon which TCE code is to be executed.

As further shown in if portion s of the data flow graph can execute in parallel block PARALLEL process block may include generating hardware code that executes in parallel on the target hardware block . If portion s of the data flow graph cannot execute in parallel block NOT PARALLEL process block may include generating hardware code that executes serially on the target hardware block . For example in an implementation described above in connection with hardware code generator component may generate optimized hardware code based on data flow graph and target hardware information . In one example hardware code generator component may determine that TCE code includes function calls object method calls that may be executed in parallel. Hardware code generator component may configure hardware code to execute such function calls object method calls in parallel which may conserve execution time of hardware code . Alternatively if TCE code includes function calls object method calls that may not be executed in parallel hardware code generator component may configure hardware code to serially execute such function calls object method calls .

Systems and or methods described herein may identify function calls and or object method calls in TCE designs targeted for hardware code generation. In one example the systems and or methods may receive code generated by a TCE and may identify function call s and or object method call s in the code. The systems and or methods may create a control flow graph for the code based on the identified function call s and or object method call s . The control flow graph may preserve the hierarchy of the identified function call s and or object method call s . The systems and or methods may transform the control flow graph into a data flow graph and may generate hardware code based on the data flow graph. The data flow graph may be analyzed to determine opportunities for numeric and latency optimization in the code. Such opportunities may be implemented in the hardware code.

The foregoing description of implementations provides illustration and description but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the implementations.

For example while series of blocks have been described with regard to the order of the blocks may be modified in other implementations. Further non dependent blocks may be performed in parallel.

It will be apparent that example aspects as described above may be implemented in many different forms of software firmware and hardware in the implementations illustrated in the figures. The actual software code or specialized control hardware used to implement these aspects should not be construed as limiting. Thus the operation and behavior of the aspects were described without reference to the specific software code it being understood that software and control hardware could be designed to implement the aspects based on the description herein.

Further certain portions of the implementations may be implemented as a component that performs one or more functions. This component may include hardware such as a processor an application specific integrated circuit ASIC or a field programmable gate array FPGA or a combination of hardware and software.

Even though particular combinations of features are recited in the claims and or disclosed in the specification these combinations are not intended to limit the disclosure of the specification. In fact many of these features may be combined in ways not specifically recited in the claims and or disclosed in the specification. Although each dependent claim listed below may directly depend on only one other claim the disclosure of the specification includes each dependent claim in combination with every other claim in the claim set.

No element act or instruction used in the present application should be construed as critical or essential unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

