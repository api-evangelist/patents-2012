---

title: System, method, and computer program product implementing an image processing pipeline for high-dynamic range images
abstract: A system, method, and computer program product for generating high-dynamic range image data is disclosed. The method includes the steps of receiving image sensor data from an interleaved image sensor. The interleaved the image sensor includes a first portion of pixels exposed for a first exposure time and a second portion of pixels exposed for a second exposure time that is shorter than the first exposure time. The method further includes the steps of identifying a first subset of pixels in the second portion having an intensity value above a first threshold value, identifying a second subset of pixels in the first portion having an intensity value below a second threshold value, and generating high-dynamic range (HDR) data based on the first subset and the second subset.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09071765&OS=09071765&RS=09071765
owner: NVIDIA Corporation
number: 09071765
owner_city: Santa Clara
owner_country: US
publication_date: 20121228
---
The present invention relates to image processing and more particular any to an image processing pipeline coupled to an image sensor.

Digital photographs may be captured today using a variety of image sensors e.g. CMOS complementary metal oxide semiconductor image sensors and CCD charge coupled device image sensors. Camera functionality is commonly included in today s mobile devices. For example many cellular telephones such as the Apple iPhone and the Motorola Droid include an integrated image sensor that a user may use to capture digital images for transmission or storing on the mobile device. Design of these compact camera system is complicated by the fact that some scenes may exhibit a large degree of contrast i.e. difference in the degree of intensity between pixels . In other words within a single scene some areas of the scene may be well lit while other areas of the scene are masked in shadow. For example when a user takes a picture outdoors the scene may contain some objects in direct sunlight and other objects that are shielded from the sun.

CMOS image sensors used in mobile devices have a limited dynamic range. Each pixel site in the CMOS image sensor functions like a capacitor capturing photons focused on the image sensor by a lens during an exposure and building up a charge. The amount of charge developed at a particular pixel site is dependent on the well capacity of the pixel sensor. For example CMOS pixels approximately 1.4 m in size have a well capacity of approximately 5000 electrons. Once the pixel site has built up a charge equivalent to 5000 electrons the pixel site is incapable of capturing any further information about the brightness of the scene. The upper limit of the dynamic range is governed by the well capacity and the discrete nature of light. Shot noise limits the highest signal to noise ratio SNR of the sensor to the square root of the maximum signal or about 36 dB in our 5000 electron example. The lower limit of the dynamic range is governed by read noise and quantization. Even in the absence of read noise the charge on the pixel is sampled to a discrete digital value e.g. a 10 bit value. The charge for a pixel may be digitized using a 10 bit ADC analog to digital converter to generate a value between 0 and 1023.

As described above the image sensor is only capable of measuring a limited dynamic range of light. Thus the information captured by the image sensor is dependent on the exposure time. Using a fast exposure time may prevent bright areas of the scene from saturating the corresponding pixel sites. However detailed information in darker areas of the scene may be lost because the signal in these areas is weak. Conversely by extending the exposure time details in the darker areas of the scene may become visible but the brighter areas of the scene may become overexposed.

One technique for generating images with high dynamic range HDR is to capture two images of the same scene using different exposure times. Conventionally a first image is captured with one exposure time and then a second image is captured with a second exposure time. Once the images are captured an image processing pipeline combines the two images to generate a scene with a dynamic range that is larger than the image sensor is capable of capturing during a single exposure. Recently interleaved image sensors have been developed that capture two images with different exposure times substantially simultaneously. In effect the interleaved image sensor captures one image of the scene using two different but simultaneous exposure times interleaved throughout the image sensor.

Some image processing algorithms for generating images using interleaved image sensors sacrifice spatial resolution to generate HDR images. For example a first image may be generated using half the pixels and a second image may be generated using the other half of the pixels. The first image and the second image are then blended to generate an HDR image at half the vertical resolution. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method circuit design and computer program product for generating high dynamic range image data is disclosed. The method includes the steps of receiving image sensor data from an interleaved image sensor. The interleaved the image sensor includes a first portion of pixels exposed for a first exposure time and a second portion of pixels exposed for a second exposure time that is shorter than the first exposure time. The method may further include the steps of identifying a first subset of pixels in the second portion having an intensity value above a first threshold value identifying a second subset of pixels in the first portion having an intensity value below a second threshold value and generating high dynamic range HDR data based on the first subset and the second subset.

An image processing pipeline for use with an interleaved image sensor is described more fully below. The image processing pipeline includes a pre processing engine that transforms the image sensor data received from the interleaved image sensor into HDR data that is companded compressed expanded and then transmitted to a conventional image signal processor ISP for further processing. The conventional ISP implements various functions such as noise reduction lens shading correction demosaicing color space conversion gamma correction chroma sub sampling encoding and so forth. The image processing pipeline may be implemented in software hardware or combinations thereof. In one embodiment the image processing pipeline may be implemented as a hardware engine included in a system on chip SoC such as an NVIDIA Tegra application processor. In another embodiment the image processing pipeline may be implemented in software executed by a processing unit such as a central processing unit CPU . In yet another embodiment the image processing pipeline may be implemented in software executed by a highly parallel processing architecture such as a graphics processing unit GPU .

Unlike a conventional CMOS image sensor image sensor is an interleaved image sensor. With a conventional CMOS image sensor the rows of the image sensor are reset in sequential order. The image sensor is exposed to light for an exposure time thereby building up a charge at each of the pixel sites. The charge built up at each pixel site is approximately proportional to the intensity of light striking the pixel site relative to each of the other pixel sites. Once the exposure time has elapsed the rows of the image sensor are sampled in sequential order to generate an array of values that represent the intensity of light for each pixel in a digital image. In contrast the interleaved image sensor samples the pixels based on multiple exposure times. In one embodiment the odd quad rows i.e. etc. of the image sensor are reset in sequential order at a first reset time. Similarly the even quad rows i.e. etc. of the image sensor are reset in sequential order at a second reset time. The odd quad rows and even quad rows of the image sensor are read at a sampling time. The difference between the sampling time and the first reset time is equal to a first exposure time and the difference between the sampling time and the second reset time is equal to a second exposure time that is less than the first exposure time. Consequently the pixels included in the odd quad rows comprise a first portion of the pixels included in the image sensor which correspond to a long exposure time and the pixels included in the even quad rows comprise a second portion of the pixels included in the image sensor which correspond to a short exposure time. The pixels in the first portion capture more detailed information about the darker areas of the scene and the pixels in the second portion contain more detailed information about the brighter areas of the scene. It will be appreciated that in other embodiments all of the pixels may be reset at a reset time the pixels in the even quad rows may be read after a second exposure time has elapsed since the reset time and the pixels in the odd quad rows may be read after a first exposure time has elapsed since the reset time where the first exposure time is longer than the second exposure time.

The pre processing engine intelligently samples and filters values from the raw image sensor data in order to generate the HDR data which is a combination of values from the first portion scaled values from the second portion filtered values based on one or more sample values in the first portion and filtered values based on one or more sample values in the second portion . For each pixel in the HDR data the pre processing engine generates an intensity value for the pixel based on an intensity value of a corresponding pixel in the image sensor data . If the corresponding pixel is included in the first portion then the intensity value of the pixel in the HDR data is set equal to the intensity value of the corresponding pixel. If the corresponding pixel is included in the second portion then the intensity value of the pixel in the HDR data is set equal to a scaled version of the intensity value of the corresponding pixel. In one embodiment the intensity value of the corresponding pixel in the second portion is scaled by the exposure ratio i.e. the ratio of the first exposure time to the second exposure time . It will be appreciated that scaling by the exposure ratio may require additional bits in the HDR data . For example for an exposure ratio of 8 an additional 3 bits are needed to scale the intensity values of the second portion by 8.

In another embodiment instead of scaling the intensity value of corresponding pixels in the second portion by the exposure ratio the pre processing engine scales intensity values of corresponding pixels in the first portion by the inverse of the exposure ratio. In such an embodiment the HDR data has the same bit depth as the image sensor data . While some information may be lost by scaling the values down rather than scaling values up an additional step of reducing the bit depth of the HDR data e.g. via companding is not required in order to process the HDR data by a conventional ISP.

The HDR data may include some invalid values. For example a pixel in the HDR data has an index associated with a corresponding pixel in the image sensor data . The pre processing engine may determine whether the value for corresponding pixel in the first portion is valid based on a neighboring pixel in the second portion . If the intensity level of a neighboring pixel in the second portion is above a threshold level t which indicates that pixel may be invalid as overexposed then the pre processing engine may determine a new value for the pixel based on one or more neighboring pixels within the second portion. In one embodiment the threshold tis set equal to a maximum threshold tmultiplied by the inverse of the exposure ratio i.e. t t r 1023 8 128 . It will be appreciated that an intensity value for a pixel in the second portion which represent values based on a short exposure time may be located near neighboring pixels in the first portion that have intensity values that are approximately equal to the intensity level for the pixel in the second portion multiplied by the exposure ratio. Because tmultiplied by the exposure ratio is equal to the maximum intensity level of the image sensor neighboring pixels in the first portion captured using a longer exposure time may have saturated the image sensor . Similarly neighboring pixels in the second portion captured using a shorter exposure time may be underexposed when pixels in the first portion are below a different threshold value such as a minimum threshold tmultiplied by the exposure ratio .

To correct for overexposed pixels in the first portion the pre processing engine identifies neighboring pixels in the second portion that have intensity values above a first threshold value. To correct for underexposed pixels in the second portion the pre processing engine identifies neighboring pixels in the first portion that have intensity values below a second threshold value. Then for each pixel in the HDR data the pre processing engine determines whether a neighboring pixel of the corresponding pixel in the image sensor data is above the first threshold value or below the second threshold value. In other words the pre processing engine determines whether a neighboring pixel of the corresponding pixel is included in the first subset or the second subset. If the neighboring pixel is included in the first subset then a new value for the pixel in the HDR data is generated by filtering one or more values from neighboring pixels in the second portion and scaling the filtered value by the exposure ratio. If the neighboring pixel is included in the second subset then a new value for the pixel in the HDR data is generated by filtering one or more values from neighboring pixels in the first portion .

It will be appreciated that the resulting HDR data comprises areas of the scene at low resolution meshed with areas of the scene at high resolution. Low resolution areas are those areas comprising filtered results because at least some of the pixels in the area were underexposed or overexposed in one of the exposures. High resolution areas are those areas comprising results calculated from pixels that were neither under exposed nor overexposed during both exposures. It will be appreciated that the pixels in the image sensor data can be classified as part of three distinct groups a first group that includes pixels that have neighboring pixels in the first subset which indicates that a pixel of the HDR data is generated by filtering one or more values from the second portion a second group that includes pixels that have neighboring pixels in the second subset which indicates that a pixel of the HDR data is generated by filtering one or more values from the first portion and a third group that includes pixels that have neighboring pixels that aren t in the first subset or the second subset which indicates that a pixel of the HDR data is generated by either scaling a pixel in the second portion or selecting a value from the first portion .

In another embodiment the pre processing engine may identify a third subset of pixels in the second portion that is above a third threshold value but below the first threshold value. The third subset indicates neighboring pixels in the second portion that may be near pixels that are close to overexposed. The pre processing engine may also identify a fourth subset of pixels in the first portion that is below a fourth threshold value but above the second threshold value. The fourth subset indicates neighboring pixels in the first portion that may be near pixels that are close to underexposed. The pre processing engine determines whether a neighboring pixel of the corresponding pixel is included in the third subset or the fourth subset. If the neighboring pixel is included in the third subset then a new value for the pixel in the HDR data is generated by filtering one or more values from neighboring pixels in the second portion and scaling the filtered value by the exposure ratio to generate a first intermediate result. The pre processing engine then blends the first intermediate result with the intensity value of the corresponding pixel in the first portion . In one embodiment the blending comprises a linear interpolation between the first intermediate result and the intensity value of the corresponding pixel based on the intensity value of the neighboring pixel. Similarly if the neighboring pixel is included in the fourth subset then a new value for the pixel in the HDR data is generated by filtering one or more values from neighboring pixels in the first portion to generate a first intermediate result. The pre processing engine then blends the first intermediate result with a scaled version of the intensity value of the corresponding pixel in the second portion .

It will be appreciated that the pixels in the image sensor data for such an embodiment can be classified as part of five distinct groups a first group that includes pixels that have neighboring pixels in the first subset which indicates that a pixel of the HDR data is generated by filtering one or more values from the second portion a second group that includes pixels that have neighboring pixels in the second subset which indicates that a pixel of the HDR data is generated by filtering one or more values from the first portion a third group that includes pixels that have neighboring pixels in the third subset which indicates that a pixel of the HDR data is generated by blending a scaled and filtered value from the second portion and a value from the first portion a fourth group that includes pixels that have neighboring pixels in the fourth subset which indicates that a pixel of the HDR data is generated by blending a filtered value from the first portion and a scaled value from the second portion and a fifth group that includes pixels that have neighboring pixels that aren t in the first subset second subset third subset or fourth subset which indicates that a pixel of the HDR data is generated by either scaling a pixel in the second portion or selecting a value from the first portion .

As shown in the scatterplot illustrates an exposure ratio r of approximately 8 i.e. the first exposure time is approximately 8 times longer than the second exposure time . The relationship between the intensity level of neighboring pixels is approximately linear i.e. y ax b . For example as shown in the scatterplot of the slope of a line fit to the sample points in the scatterplot is approximately equal to the exposure ratio. In scatterplot the minimum intensity level is approximately 45 and the maximum intensity level is approximately 1023. Furthermore an intensity value above approximately 167 i.e. 45 1023 45 r in an even quad row i.e. the second portion indicates that there is likely an overexposed pixel in an adjacent odd quad row i.e. the first portion and an intensity value below approximately 360 i.e. 45 r in an odd quad row i.e. the first portion indicates that there is likely an underexposed pixel in an adjacent even quad row i.e. the second portion for a similar object.

In one embodiment the relationship between intensity values for pixels in odd quad rows and neighboring pixels in even quad rows as plotted in scatterplot may be used to define an exposure ratio for the interleaved image sensor . The image sensor may be calibrated during manufacture by capturing images of scenes with standard lighting. For example a digital camera with the image sensor may be placed in a light box and exposed to an evenly lit surface having different colors thereon. The image sensor is exposed using two different exposure times for the odd quad rows and the even quad rows. Then the values of various sample pixels are input to a linear regression algorithm to find an exposure ratio for the image sensor .

In one embodiment the image processing pipeline includes a companding engine . The companding engine reduces the amount of bits used per intensity value in the HDR data in a non linear manner such that a conventional ISP may be implemented downstream to process the HDR data . In other words more bits are used to distinguish between lower levels of the signal than bits that are used to distinguish between higher levels of the signal. Conceptually the companding engine is implemented so that a conventional ISP may be used in the image processing pipeline . In other words if the companding engine were not implemented then an ISP configured to process e.g. 10 bit data could not operate on the HDR data with the expanded e.g. 13 bit dynamic range. Rather than scaling the HDR data back to the 10 bit dynamic range which would cause a loss of information the companding engine is implemented to compress the HDR data in a non linear manner that avoids unnecessary loss of information. The companding engine may scale the HDR data down to the original LDR dynamic range for further processing by a conventional ISP . In another embodiment the companding engine is not included in the image processing pipeline and ISP is configured to process the HDR data at the higher bitwidth.

The ISP may implement a number of functions typically implemented in a conventional ISP. For example the ISP may implement functions for performing noise reduction color conversion gamma correction and the like. Because the image processing pipeline operates on data that has been compressed in a non linear fashion via the companding engine the image processing pipeline may include a tone correction engine that compensates for the non linearity of the compression.

The image processing pipeline also includes an image scaling engine which may be connected to a viewfinder . The image scaling engine can be configured to generate scaled versions of the HDR data at resolutions that are different than the full resolution of the image sensor . The viewfinder may display the HDR image in real time. The image scaling engine is also coupled an encoding engine which is configured to encode the uncompressed image data for storage in a memory. The encoding engine may implement any number of codecs for image compression known in the art including the JPEG Joint Picture Experts Group codec.

Similarly as shown in when pre processing engine determines that a corresponding pixel in the image sensor data is included in the second portion the pre processing engine checks a neighboring pixel to determine whether the neighboring pixel is included in the second subset i.e. has an intensity value below a threshold value . If the neighboring pixel is included in the second subset then the pre processing engine generates an intensity value for the pixel in the HDR data by filtering one or more values in the first portion . In one embodiment the pre processing engine implements a filter by interpolating between two sample values for neighboring pixels in quad rows directly above and below the corresponding pixel . For example for a pixel in the HDR data corresponding with pixel pre processing engine would check to determine whether neighboring pixel is below a threshold value. If the intensity value for pixel is below the threshold value then the pre processing engine generates an intensity value for the pixel based on an interpolation between pixel and pixel .

Again the image processing pipeline described above and specifically the pre processing engine may be implemented in software hardware or combinations thereof. In one embodiment portions of the image processing pipeline may be implemented as a shader program configured to execute on a parallel processing unit such as a GPU. An exemplary parallel processing unit is set forth below. In one embodiment the GPU is a general purpose graphics processing unit GPGPU that is configured to perform calculations traditionally performed by a CPU. Although the parallel processing unit of is described along with a number of features such features are set forth for illustrative purposes only and should not be construed as limiting in any manner.

In one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data set by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. 32 threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the PPU comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the PPU . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PHI comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader shader geometry shader pixel shader etc. For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti abasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit GPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

