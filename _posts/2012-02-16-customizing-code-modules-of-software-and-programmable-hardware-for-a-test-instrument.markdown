---

title: Customizing code modules of software and programmable hardware for a test instrument
abstract: Customizing a test instrument. A plurality of pairs of code modules may be provided. Each pair of code modules may include a first code module having program instructions for execution by a processor of the test instrument and a second code module for implementation on a programmable hardware element of the test instrument. For each pair of code modules, the first code module and the second code module may collectively implement a function in the test instrument. User input may be received specifying modification of a second code module of at least one of the plurality of pairs of code modules. Accordingly, a hardware description may be generated for the programmable hardware element of the test instrument based on the modified second code module.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788882&OS=08788882&RS=08788882
owner: National Instruments Corporation
number: 08788882
owner_city: Austin
owner_country: US
publication_date: 20120216
---
The present invention relates to test instruments and more particularly to a system and method for customizing software and programmable hardware of test instruments.

Test instruments are generally used to for performing testing of devices under test DUTs or systems under test SUTs . Test instruments generally include one or more inputs and outputs for connecting to SUTs. The inputs and outputs may be analog digital radio frequency etc. e.g. at various voltage levels and frequencies. Test instruments are generally able to perform one or more tests or features. For example test instruments may be configured to capture waveforms calculate measured power generate a tone at a programmed frequency etc. Test instruments are also typically calibrated in order to achieve a specified level of accuracy on its I O. For example when the device is requested to generate a sinewave at 1V peak peak it may do so with 10 mV of accuracy. Finally test instruments usually include a user interface in order to specify how the test instrument should behave.

Currently test instruments may be used or configured in a variety of manners. For example users may purchase test instruments which have fixed software and firmware e.g. implemented on a programmable hardware element . The software and firmware may interact with underlying physical hardware of the test instrument such as analog to digital converters ADCs digital to analog converters DACs etc. This model is shown in

As another example some test instruments may be configured to be programmed in a completely custom manner where a user may provide custom code for a processor and for a programmable hardware element of the test instrument. This custom code may interact with similar underlying physical hardware as in the previous example. This model is shown in .

In the first case the user is not able to customize any of the functionality of the test instrument. Further the user may be forced to purchase features that are never used e.g. buying a test instrument with a large set of features in order to use only a few of them. Accordingly these users are forced to adapt their testing to the provided fixed functionality and may not need other features provided by the test instrument. In the second case the user is forced to completely specify the functionality of the test instrument which may require a tremendous amount of coding and test instrumentation knowledge. Additionally the requirement of providing all of this code may be extremely cost inefficient.

Thus both examples of test instruments result in a poor user experience. Accordingly improvements in test instruments especially in customization are desired.

Various embodiments of a system and method for customizing software and hardware of test instruments are presented below.

A plurality of pairs of code modules may be provided e.g. within a development environment for configuring or programming the test instrument. Each pair of code modules may include a processor side code module having program instructions for execution by a processor of the test instrument and a programmable hardware element PHE side code module for implementation on a programmable hardware element of the test instrument. In one embodiment in each pair the processor side code module and the PHE side code module may collectively implement a function in the test instrument. For example the processor side code module may be executable by the processor to perform a first portion of a function and the PHE side code module may be configured to be implemented on the programmable hardware element to perform a corresponding second portion of the function.

The pairs of code may provide various features e.g. those typically associated with a test instrument including functionality associated with hardware configuration digital signal processing acquisition generation or synchronization among other possibilities. Additionally the programmable hardware element may interact with underlying hardware of the test instrument such as analog to digital converters ADCs digital to analog converters DACs digital input and output center frequency e.g. clocking hardware and or local oscillators power level e.g. analog gain and or attenuation hardware among other possibilities.

In one embodiment the code modules may be provided within a graphical programming development environment. For example the code modules may be included in one or more graphical programs having a plurality of nodes connected by wires. The interconnected nodes may visually represent functionality of the one or more graphical program portions.

User input may be received which specifies modification of code of one or more code module pairs. For example the user input may modify the processor side code module and or the PHE side code module of one or a plurality of code module pairs. In some embodiments a portion of the PHE side code modules may be fixed i.e. they may not be changed by the user e.g. during customization. Where the code modules include graphical program code the user input may specify customization of the graphical program code e.g. the user may modify the nodes and or connections between the nodes to customize the behavior of the test instrument. Further an application programming interface API may be provided for interacting with the plurality of pairs of code modules. In some embodiments this API may remain unchanged and usable after said receiving user input.

The customization or modification of the code modules may include a variety of actions. For example the user may remove portions or all of one or more of the code modules. Additionally or alternatively the user may add additional functionality to one or more code modules as desired. The user may also add functionality outside of the code modules e.g. which is coupled to the code modules In one particular embodiment the customization may specify adaptive behavior for the test instrument e.g. such that it may dynamically adjust operation of the test instrument in response to signals from the test system e.g. based on a characteristic of received signals content of received signals etc. .

Finally the test instrument may be configured with the code modules. This configuration may include generating a hardware description for the programmable hardware element of the test instrument based on the second code modules e.g. including any modifications specified by the user input . Similarly the configuration may include storing the first code modules on one or more memory mediums of the test instrument e.g. for execution by processor s of the test instrument including any modification specified by the user input.

While the invention is susceptible to various modifications and alternative forms specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood however that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.

The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein 

U.S. Pat. No. 4 914 568 titled Graphical System for Modeling a Process and Associated Method issued on Apr. 3 1990.

U.S. Pat. No. 5 481 741 titled Method and Apparatus for Providing Attribute Nodes in a Graphical Data Flow Environment .

U.S. Pat. No. 6 219 628 titled System and Method for Configuring an Instrument to Perform Measurement Functions Utilizing Conversion of Graphical Programs into Hardware Implementations filed Aug. 18 1997.

U.S. Pat. No. 7 210 117 titled System and Method for Programmatically Generating a Graphical Program in Response to Program Information filed Dec. 20 2000.

Memory Medium Any of various types of memory devices or storage devices. The term memory medium is intended to include an installation medium e.g. a CD ROM floppy disks or tape device a computer system memory or random access memory such as DRAM DDR RAM SRAM EDO RAM Rambus RAM etc. a non volatile memory such as a Flash magnetic media e.g. a hard drive or optical storage registers or other similar types of memory elements etc. The memory medium may comprise other types of memory as well or combinations thereof. In addition the memory medium may be located in a first computer in which the programs are executed or may be located in a second different computer which connects to the first computer over a network such as the Internet. In the latter instance the second computer may provide program instructions to the first computer for execution. The term memory medium may include two or more memory mediums which may reside in different locations e.g. in different computers that are connected over a network.

Carrier Medium a memory medium as described above as well as a physical transmission medium such as a bus network and or other physical transmission medium that conveys signals such as electrical electromagnetic or digital signals.

Programmable Hardware Element includes various hardware devices comprising multiple programmable function blocks connected via a programmable interconnect. Examples include FPGAs Field Programmable Gate Arrays PLDs Programmable Logic Devices FPOAs Field Programmable Object Arrays and CPLDs Complex PLDs . The programmable function blocks may range from fine grained combinatorial logic or look up tables to coarse grained arithmetic logic units or processor cores . A programmable hardware element may also be referred to as reconfigurable logic .

Software Program the term software program is intended to have the full breadth of its ordinary meaning and includes any type of program instructions code script and or data or combinations thereof that may be stored in a memory medium and executed by a processor. Exemplary software programs include programs written in text based programming languages such as C C PASCAL FORTRAN COBOL JAVA assembly language etc. graphical programs programs written in graphical programming languages assembly language programs programs that have been compiled to machine language scripts and other types of executable software. A software program may comprise two or more software programs that interoperate in some manner. Note that various embodiments described herein may be implemented by a computer or software program. A software program may be stored as program instructions on a memory medium.

Hardware Configuration Program a program e.g. a netlist or bit file that can be used to program or configure a programmable hardware element.

Program the term program is intended to have the full breadth of its ordinary meaning. The term program includes 1 a software program which may be stored in a memory and is executable by a processor or 2 a hardware configuration program useable for configuring a programmable hardware element.

Graphical Program A program comprising a plurality of interconnected nodes or icons wherein the plurality of interconnected nodes or icons visually indicate functionality of the program. The interconnected nodes or icons are graphical source code for the program. Graphical function nodes may also be referred to as blocks.

The following provides examples of various aspects of graphical programs. The following examples and discussion are not intended to limit the above definition of graphical program but rather provide examples of what the term graphical program encompasses 

The nodes in a graphical program may be connected in one or more of a data flow control flow and or execution flow format. The nodes may also be connected in a signal flow format which is a subset of data flow.

Exemplary graphical program development environments which may be used to create graphical programs include LabVIEW DasyLab DiaDem and Matrixx SystemBuild from National Instruments Simulink from the MathWorks VEE from Agilent WiT from Coreco Vision Program Manager from PPT Vision SoftWIRE from Measurement Computing Sanscript from Northwoods Software Khoros from Khoral Research SnapMaster from HEM Data VisSim from Visual Solutions ObjectBench by SES Scientific and Engineering Software and VisiDAQ from Advantech among others.

The term graphical program includes models or block diagrams created in graphical modeling environments wherein the model or block diagram comprises interconnected blocks i.e. nodes or icons that visually indicate operation of the model or block diagram exemplary graphical modeling environments include Simulink SystemBuild VisSim Hypersignal Block Diagram etc.

A graphical program may be represented in the memory of the computer system as data structures and or program instructions. The graphical program e.g. these data structures and or program instructions may be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the graphical program.

Input data to a graphical program may be received from any of various sources such as from a device unit under test a process being measured or controlled another computer program a database or from a file. Also a user may input data to a graphical program or virtual instrument using a graphical user interface e.g. a front panel.

A graphical program may optionally have a GUI associated with the graphical program. In this case the plurality of interconnected blocks or nodes are often referred to as the block diagram portion of the graphical program.

Node In the context of a graphical program an element that may be included in a graphical program. The graphical program nodes or simply nodes in a graphical program may also be referred to as blocks. A node may have an associated icon that represents the node in the graphical program as well as underlying code and or data that implements functionality of the node. Exemplary nodes or blocks include function nodes sub program nodes terminal nodes structure nodes etc. Nodes may be connected together in a graphical program by connection icons or wires.

Data Flow Program A Software Program in which the program architecture is that of a directed graph specifying the flow of data through the program and thus functions execute whenever the necessary input data are available. Data flow programs can be contrasted with procedural programs which specify an execution flow of computations to be performed. As used herein data flow or data flow programs refer to dynamically scheduled data flow and or statically defined data flow .

Graphical Data Flow Program or Graphical Data Flow Diagram A Graphical Program which is also a Data Flow Program. A Graphical Data Flow Program comprises a plurality of interconnected nodes blocks wherein at least a subset of the connections among the nodes visually indicate that data produced by one node is used by another node. A LabVIEW VI is one example of a graphical data flow program. A Simulink block diagram is another example of a graphical data flow program.

Graphical User Interface this term is intended to have the full breadth of its ordinary meaning The term Graphical User Interface is often abbreviated to GUI . A GUI may comprise only one or more input GUI elements only one or more output GUI elements or both input and output GUI elements.

The following provides examples of various aspects of GUIs. The following examples and discussion are not intended to limit the ordinary meaning of GUI but rather provide examples of what the term graphical user interface encompasses 

A GUI may comprise a single window having one or more GUI Elements or may comprise a plurality of individual GUI Elements or individual windows each having one or more GUI Elements wherein the individual GUI Elements or windows may optionally be tiled together.

A GUI may be associated with a graphical program. In this instance various mechanisms may be used to connect GUI Elements in the GUI with nodes in the graphical program. For example when Input Controls and Output Indicators are created in the GUI corresponding nodes e.g. terminals may be automatically created in the graphical program or block diagram. Alternatively the user can place terminal nodes in the block diagram which may cause the display of corresponding GUI Elements front panel objects in the GUI either at edit time or later at run time. As another example the GUI may comprise GUI Elements embedded in the block diagram portion of the graphical program.

Front Panel A Graphical User Interface that includes input controls and output indicators and which enables a user to interactively control or manipulate the input being provided to a program and view output of the program while the program is executing.

A front panel is a type of GUI. A front panel may be associated with a graphical program as described above.

In an instrumentation application the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI Man Machine Interface of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators.

Graphical User Interface Element an element of a graphical user interface such as for providing input or displaying output. Exemplary graphical user interface elements comprise input controls and output indicators.

Input Control a graphical user interface element for providing user input to a program. An input control displays the value input by the user and is capable of being manipulated at the discretion of the user. Exemplary input controls comprise dials knobs sliders input text boxes etc.

Output Indicator a graphical user interface element for displaying output from a program. Exemplary output indicators include charts graphs gauges output text boxes numeric displays etc. An output indicator is sometimes referred to as an output control .

Computer System any of various types of computing or processing systems including a personal computer system PC mainframe computer system workstation network appliance Internet appliance personal digital assistant PDA television system grid computing system or other device or combinations of devices. In general the term computer system can be broadly defined to encompass any device or combination of devices having at least one processor that executes instructions from a memory medium.

Measurement Device includes instruments data acquisition devices smart sensors and any of various types of devices that are configured to acquire and or store data. A measurement device may also optionally be further configured to analyze or process the acquired or stored data. Examples of a measurement device include an instrument such as a traditional stand alone box instrument a computer based instrument instrument on a card or external instrument a data acquisition card a device external to a computer that operates similarly to a data acquisition card a smart sensor one or more DAQ or measurement cards or modules in a chassis an image acquisition device such as an image acquisition or machine vision card also called a video capture board or smart camera a motion control device a robot having machine vision and other similar types of devices. Exemplary stand alone instruments include oscilloscopes multimeters signal analyzers arbitrary waveform generators spectroscopes and similar measurement test or automation instruments.

A measurement device may be further configured to perform control functions e.g. in response to analysis of the acquired or stored data. For example the measurement device may send a control signal to an external system such as a motion control system or to a sensor in response to particular data. A measurement device may also be configured to perform automation functions i.e. may receive and analyze data and issue automation control signals in response.

Automatically refers to an action or operation performed by a computer system e.g. software executed by the computer system or device e.g. circuitry programmable hardware elements ASICs etc. without user input directly specifying or performing the action or operation. Thus the term automatically is in contrast to an operation being manually performed or specified by the user where the user provides input to directly perform the operation. An automatic procedure may be initiated by input provided by the user but the subsequent actions that are performed automatically are not specified by the user i.e. are not performed manually where the user specifies each action to perform. For example a user filling out an electronic form by selecting each field and providing input specifying information e.g. by typing information selecting check boxes radio selections etc. is filling out the form manually even though the computer system must update the form in response to the user actions. The form may be automatically filled out by the computer system where the computer system e.g. software executing on the computer system analyzes the fields of the form and fills in the form without any user input specifying the answers to the fields. As indicated above the user may invoke the automatic filling of the form but is not involved in the actual filling of the form e.g. the user is not manually specifying answers to fields but rather they are being automatically completed . The present specification provides various examples of operations being automatically performed in response to actions the user has taken.

The test instrument may include one or more inputs and outputs for connecting to the SUT . The inputs and outputs may be analog digital radio frequency etc. e.g. at various voltage levels and frequencies. The test instrument may be configured to perform one or more tests or may implement various features for performing testing of the SUT . For example the test instrument may be configured to capture waveforms calculate measured power generate a tone at a programmed frequency etc. The test instrument may be calibrated in order to achieve a specified level of accuracy on its input output I O . For example the test instrument may be configured to generate a sine wave at 1V peak peak within 10 mV of accuracy. The test instrument may be configured and or may operate in the manner described herein.

The SUT may be any of various devices or systems which may be desired to be tested such as a various radio frequency RF devices semiconductor integrated circuits consumer electronics wireless communication devices such as cell phones computers automobile electronics energy devices measurement devices etc. In one embodiment the test instrument may be configured to perform various testing of the SUT e.g. on signals acquired from the SUT . In one embodiment the chassis may acquire measurements of the SUT such as current voltage etc. e.g. using analog sensors and or digital signals using digital I O.

As shown the host device e.g. the chipset of the host device may provide communication e.g. PCIe communication PXI communication or other bus communication to a first peripheral device and a second peripheral device over bus . The first peripheral device and second peripheral device may be configured to change configurations based on information provided by the host device as described herein.

The devices may be any of various devices e.g. PCIe devices such as measurement devices e.g. DAQ devices processing devices I O devices network devices etc. Additionally similar to above the devices may include one or more programmable hardware elements or processors and memory to implement their respective functionality. In some embodiments the devices and may be configured to acquire signals from the SUT to perform testing. For example the device may be configured to measure and perform analog to digital conversion for voltage of the SUT . Similarly the device may be configured to measure and perform analog to digital conversion for current of the SUT . Further devices may be included in the chassis such as devices for performing GPS measurements e.g. acquiring time using GPS circuitry for synchronization purposes among other possibilities.

In some embodiments multiple SUTs may be measured concurrently. For example one or more devices in the test instrument may be used for performing concurrent measurement such as for RF testing among other possibilities. Further the test instrument and or devices included therein may be configured to perform measurements over a network such as a wireless network e.g. 802.11 WiMax etc. .

In various embodiments the host device may be coupled to a second computer system or device via a network or a computer bus . The computer systems may each be any of various types as desired. The network can also be any of various types including a LAN local area network WAN wide area network the Internet or an Intranet among others. Similarly the host device may be coupled to the test instrument via various mechanisms.

As also shown above this level is the FPGA firmware which may communicates with the physical hardware and the driver level host software and may implement the hardware features of the device. The driver level host software may execute on the computer or controller and may have an API that allows the user to access the features of the device. At the highest level is the application software which may call into or otherwise utilize the driver level API.

The various embodiments provided herein may be particularly applicable to the configuration model shown in . More specifically a user may be able to customize or configure both the configuration and code of the host software as well as the configuration and code of the firmware implemented on a programmable hardware element. In one embodiment the customizations described below may particularly apply to the customization of the driver level software and programmable hardware element firmware portion of the system.

As shown the code module pairs include configuration DSP acquisition generation and synchronization although more or less pairs are also envisioned. The configuration code module pair may be used for programming the physical hardware to a given state e.g. power level frequency data rate etc and or calibrating the test instrument. The DSP code module pair may be used for changing the sample rate of the data filtering the data to improve the frequency response of the test instrument digitally changing the gain of the data or other processing. The acquisition code module pair may be used for acquiring data from the inputs and for provision to the host. The generation code module pair may be used for sending data from the host out the outputs. The synchronization code module pair may be used for aligning I O between multiple modules or cards within the test instrument and or between multiple test instruments as desired.

These code modules may be provided to the user in a number of ways. For example the code modules may be provided within a configuration tool or development environment which may be used to configure the test instrument. For example the user may install software on a computer system e.g. the computer system of and may use the software to configure the test instrument. In one specific embodiment the code module pairs may be installed within or along with a development environment e.g. a graphical programming development environment such as LabVIEW provided by National Instruments.

In one embodiment the code modules may be included in one or more graphical programs having a plurality of nodes connected by wires. For example there may be a first graphical program corresponding to software of the host of the test instrument and a second graphical program corresponding to the PHE of the test instrument. Alternatively the functionality of the test instrument may be fully specified in a single graphical program. The interconnected nodes of the graphical program s may visually represent functionality of the one or more graphical programs. However the code modules may be provided in a number of different development environments and are not limited to graphical programming embodiments.

In one embodiment the code modules may be provided in one or more templates within the development environment. For example a user may be able to open a template project which includes the code modules and which may be ready for configuration to a test instrument e.g. may be operable without modification . Accordingly the user may be able to simply modify the already present code modules in order to configure to the test instrument to implement the desired behavior. The code modules may appear as individual modular blocks e.g. which are interconnected on the display of the computer system. In one embodiment a user may be able to expand each block to modify its functionality e.g. where it may be represented by a node such as a sub VI which expands into a graphical program in graphical programming embodiments . Alternatively or additionally the code modules may simply be included in a program with sections corresponding to each of the modular blocks. For example the template may include a first set of code for the host and a second set of code for the programmable hardware element. Each of these sets of codes may have sections corresponding to each of the modular blocks e.g. where each section is labeled such as by a color which indicates which modular block the section or individual nodes correspond to .

In some embodiments the code modules and or pairs of code modules may be provided within a palette or library. For example a user may select which code modules or pairs of code modules he would like included in the program. The user may include these modules by selecting the desired code modules and manually including them in the desired program e.g. by dragging and dropping them into a graphical program possibly from a palette following graphical programming embodiments . Alternatively or additionally the user may simply select the desired code modules and they may be automatically assembled or integrated into a new or existing program. For example a test instrument wizard e.g. a series of GUIs may be displayed on the display where a user may select the desired functionality of the test instrument e.g. by selecting the desired functionality. In response a program or configuration may be automatically created or assembled which implements the desired functionality e.g. by automatically including the appropriate code modules. Thus the code modules may be specified or provided in a number of ways.

As discussed below these code modules may be customized by the user. More specifically the user may be able to choose which of the code modules to keep which to change and which to eliminate without affecting the functionality or behavior of the other code modules. Because the code modules may be provided e.g. within a development environment or configuration tool of the test instrument a user may be able to fully customize the functionality of the test instrument e.g. without having to write much code.

Additionally an application programming interface API may be provided for interacting with the plurality of pairs of code modules. For example this API may be used by the high level application software of to interact with the driver level host software and PHE firmware e.g. corresponding to the pairs of code modules of . In some embodiments this API may remain unchanged and usable even after modification or customization.

In a plurality of pairs of code modules may be provided e.g. within a development environment for configuring or programming the test instrument. As discussed above regarding these code modules may be provided in a number of different manners. As also discussed each pair of code modules may include a processor side code module having program instructions for execution by a processor of the test instrument and a PHE side code module for implementation on a programmable hardware element of the test instrument. Thus in each pair the processor side code module and the PHE side code module may collectively implement a function in the test instrument. For example the processor side code module may be executable by the processor to perform a first portion of a function and the PHE side code module may be configured to be implemented on the programmable hardware element to perform a corresponding second portion of the function.

As discussed above the pairs of code may provide functionality associated with hardware configuration digital signal processing acquisition generation or synchronization among other possibilities. Additionally the programmable hardware element may interact with underlying hardware of the test instrument such as ADCs DACs digital I O center frequency e.g. clocking hardware and or local oscillators power level e.g. analog gain and or attenuation hardware etc.

The plurality of pairs of code modules in may refer to those included for specifying functionality of a test instrument. Thus there may be more pairs of code modules than the plurality of that are not included for configuring the test instrument. In one embodiment the user may have selected the plurality of code module pairs from a larger set of code module pairs. Thus the pairs of code modules in may be a subset of a total number of available code modules e.g. and may be used for configuring a particular test instrument.

In user input may be received which specifies modification of code of one or more code module pairs. For example the user input may modify the processor side code module and or the PHE side code module of one or a plurality of the code module pairs provided in and or included in the current configuration of the test instrument.

The customization or modification of the code modules may include a variety of actions. For example the user may remove portions or all of one or more of the code modules. Additionally or alternatively the user may add additional functionality to one or more code modules as desired. Even further the user may add functionality outside of any of the code modules e.g. to provide functionality that is different from that provided by the currently selected code modules. Thus a user may modify the PHE and or software portions of one or more of the code module pairs remove some or all of the PHE and or software portions of one or more of the code module pairs and or add new PHE and or software code in addition to the existing code provided by the plurality of code module pairs as desired. However in some embodiments a portion of the code modules e.g. the PHE side code modules may be fixed i.e. they may not be changed by the user e.g. during customization.

The user may specify the modification in a variety of manners. For example where the code modules are specified via graphical program code the user input may specify customization of the graphical program code e.g. the user may modify the nodes and or connections between the nodes to customize the behavior of the test instrument. Alternatively the user input may be specified in a different development environment e.g. modifying textual code of the code modules via a test instrument configuration tool e.g. using a configuration wizard or other GUI etc.

In one particular embodiment the customization may specify adaptive behavior for the test instrument e.g. such that it may dynamically adjust operation of the test instrument in response to signals from the test system e.g. based on a characteristic of received signals content of received signals etc. . Further details regarding this adaptive behavior are provided below with respect to .

In program instructions and hardware description s corresponding to specified code module pairs including the one or more modified code module pairs may be generated. For example the software of the processor side code modules may be compiled for execution by processor s of the test instrument. For example the type of processor s of the test instrument may be detected and the program instructions may be generated to correspond to the instruction set of the detected type of processor s . There may be processors in various different locations within the test instrument e.g. within a host which may be collocated with the PHE s and underlying hardware or not e.g. within the chassis or coupled to the chassis as shown in the embodiments of and C . Additionally there may be processors within individual cards or devices of the test device e.g. devices and or of . Thus the software may be executed by one or a plurality of processors located in various different areas of the test device.

Additionally the PHE side code modules may be converted to hardware description level HDL code such as Verilog for implementation on the PHE s of the test instrument. Similar to above the PHE code may be in various locations e.g. within individual devices of the test device e.g. devices and or of or in other locations e.g. the backplane of the chassis . In one embodiment a netlist may be generated e.g. from the HDL code for programming gates of the PHE s . In graphical programming embodiments the generation of HDL code or netlists may be performed in the manner described in U.S. Pat. No. 6 219 628 which was incorporated by reference in its entirety above.

Finally in the test instrument may be configured with the program instructions and according to the hardware description s . More specifically the PHE s of the test instrument may be programmed according to the generated HDL code or netlist s and the program instructions may be stored on one or more memory mediums of the test instrument e.g. for execution by processor s of the test instrument. Note that the program instructions may be stored in a host portion of the test instrument which may be included within the same enclosure as the PHE of the test instrument e.g. and underlying hardware or may be separate from the enclosure of the PHE of the test instrument e.g. of an external computer system coupled to a chassis containing the PHE and underlying hardware . In either case the test instrument may include both the host and PHE portions even if the host portion is implemented via a separate computer system.

The test instrument may then be configured and may be ready to operate as configured e.g. to test an SUT.

In processor side code may be provided. The processor side code may be intended for execution by a processor of a test instrument. Additionally in PHE side code may be provided. The PHE side code may be intended for implementation by a programmable hardware element of a test instrument. For example the processor side code and PHE side code may be provided as pairs of code modules as discussed above regarding . However the code may be provided in any form as desired. For example the code may be provided as uniform code without indications of modules or sections in the code. For example the processor side code may be monolithic and the PHE side code may also be monolithic. Regardless the provided code may specify functionality of a test instrument.

In user input may be received customizing or otherwise modifying the processor side and or PHE side code to provide adaptive behavior for the test instrument. More specifically the user input may specify functionality or behavior which may allow the test instrument to dynamically or automatically adjust its operation based on information received from a SUT e.g. during testing of the SUT. The modification to operation of the test instrument may include modification of processing of signals received from the SUT modification of signals sent to the SUT configuration of the test instrument configuration of the SUT and or any desired modification.

For example the customization may specify that the test instrument automatically adjust methods of receiving or modifying signals received by the SUT based on characteristics of the signals. As a specific example the test instrument may automatically adjust the gain of signals received by the SUT to an appropriate level e.g. increasing gain when the level is too low or decreasing gain when the level is too high .

As another example the customization may specify that the test instrument should modify its behavior based on information provided by the SUT e.g. based on content encoded within the signals sent by the SUT . For example a user may desire to let the SUT control changeover of tests e.g. where the SUT may trigger changeover from a first test mode to a second test mode by providing a particular stimulus signal. Additionally the SUT may be able to respond to or initiate frequency hopping e.g. during RF testing. Other types of adaptive behavior are also envisioned.

Another example may include when the SUT and test instrument are communicating to each other using a defined protocol. In that case there may be Request and Acknowledge signals passing back and forth between the two systems along with data. This may allow the SUT to request responses or operation changes and implement intelligent tests. For example an SUT that is a semiconductor IC for wireless communication may be able to test perform internally e.g. internal hardware or software if it receives the correct stimulus from the test instrument. For example the SUT may request a signal at X frequency and Z power which it may utilize to perform self checks. Then the SUT may continue by requesting a signal at Y frequency and W power and so on.

Another example may include when testing an SUT and the SUT is checking its bit error rate BER . The test may start at a low data rate and if the SUT detects that its BER is very good it may request a higher data rate from the test instrument. This sequence may continue until the SUT detects a bad BER at which point it may request the test instrument to lower the data rate. This process may be used as part of the process of binning an SUT to determine it s maximum operating speed.

This customization may be performed in the manner described above in however other customizations are also envisioned. For example as discussed above the code may not be provided in code modules or pairs of code modules but may be instead be provided in other manners such as monolithic code. Accordingly the user may simply customize the code by modifying the monolithic code. Similar to embodiments above a user may also perform customizations using a series of GUIs e.g. a wizard which may then automatically modify the code according to the user s input. Other customizations are envisioned.

In program instructions and hardware description s corresponding to processor side code and the PHE side code may be generated including the customization of . This step may be performed in a similar manner to .

In during testing information may be received from the SUT. The information may correspond to the customization specified in above. For example the information may correspond to characteristics of signal s provided by the SUT information encoded in the signals provided by the SUT such as data or any other information specified by the customization.

In in response to the information operation of the test instrument may be automatically modified based on the information according to the adaptive behavior specified in .

Note that while includes the step of customizing the processor side code and or the PHE side code to implement the adaptive behavior it is possible that the adaptive behavior may have been previously specified in the code. Accordingly customization may not be required for the test instrument to behave in the adaptive manner described herein. Further while two sets of code are described a single set e.g. the processor and or the PHE may be used instead.

For example the user may use the configuration host software API to specify a particular power level and center frequency at the host software level. This value may then be sent to the firmware and lastly down to the physical hardware. For acquisition the data comes into the ADCs and then gets captured by the Acquisition Engine in the PHE via the DSP firmware FW and then can be read out through the acquisition host software API. On the generation side the API may be used to generate data at the software level which may be passed to the generation FW in the PHE then to the DSP FW and finally to the SUT via the DACs.

One example is an automatic gain control circuit AGC . The user could store a plurality of different configurations e.g. for 100 different power levels. Then the custom FW could look at the power of the signal received by the ADC and pick a different configuration at run time to maximize the dynamic range of the ADC.

Another example would be frequency hopping. The user could store 16 different configurations e.g. for 16 different center frequencies. Then the SUT could request a new center frequency either through the data path by decoding the ADC data or through the digital I O port. Accordingly the operation of the test instrument may be automatically changed e.g. during testing.

More specifically corresponds to session initialization and the opening of the communication port to hardware. corresponds to configuration e.g. for setting up the power level and center frequency. corresponds to generation e.g. for downloading the desired waveforms to the hardware setting up how the hardware should generate in response to a trigger etc. corresponds to synchronization e.g. for setting up the synchronization circuitry routing the synchronization trigger etc. corresponds to DSP e.g. for setting up the DSP frequency shift digital gain rate change etc. . corresponds to acquisition e.g. for acquiring a waveform and returning it back to the user. Finally corresponds to closing the session and resetting the instrument.

In this example corresponding to generation and F corresponding to acquisition have been replaced with custom code for setting up the custom PHE firmware shown in . More specifically this code may be used for setting up the direction of the DIO signals clearing the FIFO s for the DIO port and starting the transfer of data in out the DIO port.

While the above embodiments have been described with respect to test instruments and testing SUTs they may be extended to configuration or customization of any devices or instruments. Thus the above described embodiments are not limited to the particular environments and examples discussed above and may be applied to any appropriate systems as desired.

Although the embodiments above have been described in considerable detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

