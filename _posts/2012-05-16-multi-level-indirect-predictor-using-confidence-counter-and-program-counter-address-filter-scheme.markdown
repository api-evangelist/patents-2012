---

title: Multi level indirect predictor using confidence counter and program counter address filter scheme
abstract: The disclosure relates to predicting simple and polymorphic branch instructions. An embodiment of the disclosure detects that a program instruction is a branch instruction, determines whether a program counter for the branch instruction is stored in a program counter filter, and, if the program counter is stored in the program counter filter, prevents the program counter from being stored in a first level predictor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09477478&OS=09477478&RS=09477478
owner: QUALCOMM Incorporated
number: 09477478
owner_city: San Diego
owner_country: US
publication_date: 20120516
---
Embodiments of the disclosure relate to predicting simple and polymorphic branch instructions and more particularly to distinguishing between simple and polymorphic branch instructions.

During program instruction execution at the microprocessor level an indirect branch instruction may cause execution to jump to a non sequential instruction somewhere else in the program rather than the next sequential instruction. Predicting to which instruction the execution will branch is an important optimization. There are two types of predictable indirect branches simple indirect branches and polymorphic indirect branches. Simple indirect branches are branches that keep jumping to the same target instruction. Polymorphic indirect branches are branches that jump to different target instructions in a specific pattern that is usually predictable.

A global indirect branch predictor stores a history of the correct target for all conditional branches. Simple indirect branches do not need a global branch history for accurate prediction but polymorphic indirect branches do. While building a large monolithic indirect predictor that uses global branch history may solve the problem it is not feasible to build such an array from an area and timing perspective of a processor. Multiple clock cycles would be needed to lookup such a large predictor and that may have a negative impact on the performance of the application.

Further in many cases using global branch history can harm simple branches in a two fold way. First it may provide a bad prediction of simple branches while the global branch history is being populated. Second the same branch may now be stored in multiple entries of the indirect predictor array creating a capacity problem even though it would have been perfectly acceptable to allocate the simple branch in only one entry because it always jumps to the same target.

What is needed is a way to predict both simple and polymorphic indirect branches accurately without negatively impacting the timing or the performance of the processor.

The disclosure relates to predicting simple and polymorphic branch instructions. An embodiment of the disclosure detects that a program instruction is a branch instruction determines whether a program counter for the branch instruction is stored in a program counter filter and if the program counter is stored in the program counter filter prevents the program counter from being stored in a first level predictor.

Aspects of the invention are disclosed in the following description and related drawings directed to specific embodiments of the invention. Alternate embodiments may be devised without departing from the scope of the invention. Additionally well known elements of the invention will not be described in detail or will be omitted so as not to obscure the relevant details of the invention.

The word exemplary is used herein to mean serving as an example instance or illustration. Any embodiment described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments. Likewise the term embodiments of the invention does not require that all embodiments of the invention include the discussed feature advantage or mode of operation.

The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of embodiments of the invention. As used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises comprising includes and or including when used herein specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

Further many embodiments are described in terms of sequences of actions to be performed by for example elements of a computing device. It will be recognized that various actions described herein can be performed by specific circuits e.g. application specific integrated circuits ASICs by program instructions being executed by one or more processors or by a combination of both. Additionally these sequence of actions described herein can be considered to be embodied entirely within any form of computer readable storage medium having stored therein a corresponding set of computer instructions that upon execution would cause an associated processor to perform the functionality described herein. Thus the various aspects of the invention may be embodied in a number of different forms all of which have been contemplated to be within the scope of the claimed subject matter. In addition for each of the embodiments described herein the corresponding form of any such embodiments may be described herein as for example logic configured to perform the described action.

It will be appreciated that configured logic or logic configured to are not limited to specific logic gates or elements but generally refer to the ability to perform the functionality described herein either via hardware or a combination of hardware and software . Thus the configured logics or logic configured to are not necessarily implemented as logic gates or logic elements despite sharing the word logic. Other interactions or cooperation between the logic in the various blocks will become clear to one of ordinary skill in the art from a review of the embodiments described below in more detail.

Referring to a user equipment UE here a wireless device such as a cellular telephone has a platform that can receive and execute software applications data and or commands transmitted from a radio access network RAN that may ultimately come from the core network the Internet and or other remote servers and networks. The platform can include a transceiver operably coupled to an ASIC or other processor microprocessor logic circuit or other data processing device. The ASIC or other processor executes the application programming interface API layer that interfaces with any resident programs in the memory of the wireless device. The memory can be comprised of read only or random access memory RAM and ROM EEPROM flash cards or any memory common to computer platforms. The platform also can include a local database that can hold applications not actively used in memory . The local database is typically a flash memory cell but can be any secondary storage device as known in the art such as magnetic media EEPROM optical media tape soft or hard disk or the like. The internal platform components can also be operably coupled to external devices such as antenna display push to talk button and keypad among other components as is known in the art.

Accordingly an embodiment of the invention can include a UE including the ability to perform the functions described herein. As will be appreciated by those skilled in the art the various logic elements can be embodied in discrete elements software modules executed on a processor or any combination of software and hardware to achieve the functionality disclosed herein. For example ASIC memory API and local database may all be used cooperatively to load store and execute the various functions disclosed herein and thus the logic to perform these functions may be distributed over various elements. Alternatively the functionality could be incorporated into one discrete component. Therefore the features of the UE in are to be considered merely illustrative and the invention is not limited to the illustrated features or arrangement.

The wireless communication between the UE and the RAN can be based on different technologies such as code division multiple access CDMA W CDMA time division multiple access TDMA frequency division multiple access FDMA Orthogonal Frequency Division Multiplexing OFDM the Global System for Mobile Communications GSM 3GPP Long Term Evolution LTE or other protocols that may be used in a wireless communications network or a data communications network. Accordingly the illustrations provided herein are not intended to limit the embodiments of the invention and are merely to aid in the description of aspects of embodiments of the invention.

The processor which executes instructions from at least two instruction sets in different instruction set operating modes additionally includes a debug circuit operative to compare upon the execution of each instruction at least a predetermined target instruction set operating mode to the current instruction set operating mode and to provide an indication of a match between the two.

The pipeline fetches instructions from an instruction cache I cache with memory address translation and permissions managed by an Instruction side Translation Lookaside Buffer ITLB . Data is accessed from a data cache D cache with memory address translation and permissions managed by a main Translation Lookaside Buffer TLB . In various embodiments the ITLB may comprise a copy of part of the TLB . Alternatively the ITLB and TLB may be integrated. Similarly in various embodiments of the processor the I cache and D cache may be integrated or unified. Further I cache and D cache may be L1 caches. Misses in the I cache and or the D cache cause an access to main off chip memory by a memory interface . The memory interface may be a master input to a bus interconnect implementing a shared bus to one or more memory devices . Additional master devices not shown may additionally connect to the bus interconnect .

The processor may include an Input Output I O interface which may be a master device on a peripheral bus across which the I O interface may access various peripheral devices . Those of skill in the art will recognize that numerous variations of the processor are possible. For example the processor may include a second level L2 cache for either or both the I and D caches . In addition one or more of the functional blocks depicted in the processor may be omitted from a particular embodiment. Other functional blocks that may reside in the processor such as a JTAG controller instruction predecoder global branch history cache and the like are omitted for clarity.

Embodiments of the invention distinguish between simple and polymorphic indirect branches. Simple indirect branches are placed in a first level predictor which is a small fast array that uses no global branch history while polymorphic indirect branches are placed in a second level predictor which is a larger array indexed using the PC combined with the global branch history. A PC filter stores the PCs of branch instructions that have been determined to be polymorphic branches.

A confidence counter such as confidence counter is allocated for each entry of first level predictor to help determine the difference between simple and polymorphic branches. The confidence counter is an X bit saturating counter where X is usually 2 or 3 that counts up or down based on the prediction accuracy of first level predictor . The lower saturation value of the counter is 0 and the upper saturation value is 2 1. For example a 2 bit counter can have a value from 0 to 3.

As an example given a 2 bit confidence counter with an initial value of Y 2 when first level predictor predicts the branch correctly the counter is incremented and saturates to the high value mark i.e. 3 . A correct prediction means that the target address stored in first level predictor for the PC was the correct target address. Similarly when first level predictor predicts the branch incorrectly the counter is decremented i.e. to 1 . An incorrect prediction means that the target address stored in first level predictor for the PC was not the correct target address.

When the counter reaches a value of Z e.g. Z 0 it means there is no confidence in the ability of first level predictor to predict that particular branch correctly. This means that the branch is not a simple indirect branch but is rather a polymorphic indirect branch. The PC and corresponding target address are therefore removed from first level predictor and the PC such as PC is allocated in PC filter . PC filter can have R entries where R may be for example 1 to 4.

When the branch is encountered again the PC for the branch will miss in first level predictor . Conventionally when there is a miss for a PC in a first level cache here first level predictor a second level cache here second level predictor is checked. If present in the second level cache the PC and target would be allocated from the second level cache to the first level cache. However since the branch has been determined to be a polymorphic branch and therefore allocated in PC filter and since global branch history is not used for first level predictor because simple branches always have the same target that branch would be mispredicted again if moved back to first level predictor . The PC filter prevents this from happening. If a PC lookup such as PC lookup misses in first level predictor and hits in PC filter the corresponding branch instruction is not filled in to first level predictor from second level predictor because the branch is known to not be a simple branch which is why the PC for that branch was stored in PC filter in the first place . Instead second level predictor will be used to predict the branch instruction.

Second level predictor stores a tag such as tag comprising the PC of the branch instruction XOR ed with the global branch history for that branch and the corresponding target address such as target address . Thus if a PC lookup such as PC lookup misses in first level predictor and hits in PC filter second level predictor is used to determine the target of the branch by XOR ing the PC and global history.

If the PC misses in both first level predictor and PC filter it means the branch hasn t been encountered before and the PC is therefore allocated to first level predictor . If the PC hits in PC filter and misses in second level predictor it means there is no prediction for the target instruction. This may be for example because the branch is unpredictable or because the number of possible jumps is too large to be stored in either the global branch predictor or second level predictor . It would be possible to design more levels for an indirect predictor e.g. by using a larger global history for successive levels of an indirect predictor for more difficult to predict polymorphic branches.

If the instruction is an indirect branch however then at processor checks first level predictor and PC filter for the PC of the branch. If at the PC hits in first level predictor and misses in PC filter then at the corresponding target address allocated in first level predictor is retrieved. If there is a miss in both PC filter and first level predictor there is no prediction for the branch and the PC and the target address will be allocated in first level predictor .

If at however the PC hits in PC filter then at processor ignores any hit in first level predictor because the hit in PC filter indicates that the branch is a polymorphic indirect branch. At the PC is XOR ed with the global branch history and looked up in second level predictor . At the branch instruction carries a bit indicating the PC filter hit with itself down the instruction pipeline. Setting the hit bit indicates that the branch should not be allocated in first level predictor at retirement time as discussed below with reference to . This keeps branches that should be predicted using second level predictor in only second level predictor .

At processor determines whether the confidence counter is less than or equal to the no confidence threshold e.g. 0 . If it is then at the branch is removed from first level predictor and at the PC is allocated in PC filter . If the confidence counter is still greater than zero however no further action is taken and the retirement processing ends.

If the first level predictor lookup at misses then at the branch instruction is checked to determine whether the PC filter hit bit is set. In an alternate embodiment the PC is looked up in PC filter . If the hit bit is set then at the branch is allocated in second level predictor if not already allocated because it is polymorphic. The hit bit prevents the branch from being allocated in first level predictor . If however the hit bit is not set then at the branch is allocated in first level predictor .

Those of skill in the art will appreciate that information and signals may be represented using any of a variety of different technologies and techniques. For example data instructions commands information signals bits symbols and chips that may be referenced throughout the above description may be represented by voltages currents electromagnetic waves magnetic fields or particles optical fields or particles or any combination thereof.

Further those of skill in the art will appreciate that the various illustrative logical blocks modules circuits and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

The methods sequences and or algorithms described in connection with the embodiments disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor.

Accordingly an embodiment of the invention can include a computer readable media embodying a method for predicting simple and polymorphic branch instructions. Accordingly the invention is not limited to illustrated examples and any means for performing the functionality described herein are included in embodiments of the invention.

While the foregoing disclosure shows illustrative embodiments of the invention it should be noted that various changes and modifications could be made herein without departing from the scope of the invention as defined by the appended claims. The functions steps and or actions of the method claims in accordance with the embodiments of the invention described herein need not be performed in any particular order. Furthermore although elements of the invention may be described or claimed in the singular the plural is contemplated unless limitation to the singular is explicitly stated.

