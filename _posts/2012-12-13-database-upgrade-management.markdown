---

title: Database upgrade management
abstract: A system can include an upgrade system manager. The upgrade system manager can be configured to communicate with an upgrade database that employs a given schema. The system can also include a legacy system manager configured to communicate with a legacy database that employs a different schema, wherein the legacy database contains a subset of the data stored at the upgrade database. The legacy database can be configured to provide a forward migration trigger to the upgrade system manager in response to detecting an update to the legacy database. The upgrade system manager can further be configured to determine whether data received from an application configured to produce data for the upgrade database is to be provided to the legacy database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09122716&OS=09122716&RS=09122716
owner: SHORETEL, INC.
number: 09122716
owner_city: Sunnyvale
owner_country: US
publication_date: 20121213
---
A database is an organized collection of data in digital form. The data in a database can be organized to model relevant aspects of reality in a way that supports processes that require this information. A database can have a model that describes a theoretical foundation of the database and fundamentally determines in which manner data can be stored organized and manipulated in a database system.

A database can be implemented with a particular schema and binaries. The schema describes the organization and format of the database e.g. the tables used to identify and describe the data stored in the database and the relationships between the tables . The binaries represent the actual data which is typically stored in the format specified by the schema.

One example relates to a system for managing an upgrade database and a legacy database. The system can comprise an upgrade system manager stored in a memory. The upgrade system manager can be configured to communicate with the upgrade database that employs a given schema. The system can also comprise a legacy system manager stored in the memory. The legacy system manager can be configured to communicate with the legacy database that employs another schema wherein the legacy database contains a subset of the data stored at the upgrade database. The legacy database can be configured to provide a forward migration trigger to the upgrade system manager in response to detecting an update to the legacy database. The upgrade system manager can be further configured to determine whether data received from an application configured to produce data for the upgrade database is to be provided to the legacy database.

Another example relates to a method for managing an upgrade database and a legacy database. The method can include receiving data from an application. The method can also include determining whether to provide the data to a legacy database the determination being based on a type of the data. The method can further comprise updating an upgrade database that employs a given schema based on the data received from the application. The upgrade database can contain a superset of data stored at the legacy database that employs another schema.

Yet another example is related to a system for upgrading a database. The system can comprise a memory configured to store machine readable instructions. The system can also include a processing unit to access the memory and execute the machine readable instructions. The machine readable instructions can comprise an upgrade adapter configured to detect data being provided from an application for a legacy database that employs a given schema. The upgrade adapter can also provide an update command in response to the data provided from the application to an upgrade database that employs another schema. The upgrade database includes a complete set of data stored on the legacy database.

This disclosure relates to managing an upgrade for a database. As an example an upgrade database is provided. The upgrade database can be generated from a legacy database. The upgrade database and the legacy database can employ different schemas. In particular the upgrade database can employ schema V while the legacy database can employ schema V n. As used herein schema V is an upgraded version of a prior schema V n where n is a positive integer denoting a previous non upgraded version . In some examples both databases can run concurrently wherein at least some of the data updated at the upgrade database is provided to the legacy database while each update to the legacy database is forward migrated to the upgrade database. In other examples only the upgrade database that employs an adapter is running e.g. live . The examples disclosed herein thus can allow for incremental upgrading of individual databases in a distributed database system.

The legacy server and the upgrade server can be implemented for example as a computer. The legacy server can include a memory for storing machine readable instructions. In a similar fashion the upgrade server can also include a memory . The memories and could be implemented for example as volatile memory e.g. random access memory nonvolatile memory a hard disk drive a solid state drive flash memory or the like or a combination thereof. The legacy server can also include a processing unit to access the memory and execute the machine readable instructions. Similarly the upgrade server can also include a processing unit to access the memory and execute the machine readable instructions. The processing units and can be implemented for example as including a processor core. It is to be understood that while in the present example the legacy server and the upgrade server are illustrated as being separate computer systems in other examples the legacy server and the upgrade server could be collocated on the same server. Moreover in other examples the legacy server and the upgrade server could be implemented as virtualized components e.g. resources of a computing cloud .

The memory can include a legacy system manager that can be programmed to read and write data e.g. manage data to and from a legacy database e.g. a repository . The legacy database can be stored in the memory of the legacy server . In some examples the legacy database can be integrated with a legacy system. In other examples the legacy database could be stored externally to the legacy server and or be distributed in the legacy system.

The upgrade server can include an upgrade database stored in the memory . The upgrade database can employ a different schema than the legacy database . As disclosed herein it is presumed that the upgrade database is a newer version version V of the legacy database version V n . This does not necessarily imply that the upgrade database was derived directly from legacy database but instead that it is intended to replace each legacy database version V n as part of an upgrade process. In a distributed system there can be more than one different version of legacy databases to be replaced. Moreover as explained herein data written to the legacy database can be migrated to the upgrade database . Additionally some but not necessarily all data written to the upgrade database can be migrated to the legacy database . In the present examples it is presumed that the upgrade database initially is synchronized with the legacy database . This can be implemented in an offline process prior to or concurrently with the upgrade database being activated. Thus it can be presumed that upgrade database contains every data record stored in the legacy database that is required to complete the upgrade process.

To facilitate continued synchronization between the legacy database and the upgrade database an upgrade system manager can be programmed to read and write data to the upgrade database . For instance in some examples the upgrade system manager can include a data application programming interface API and or a database updater that can generate database update commands e.g. write schema in the schema employed by the upgrade database e.g. the V schema . As used herein the term update command can be implemented for example as an insert command an update command a delete command or a combination thereof.

The legacy system manager can include for example a system director that can control a flow of data from a framework to the legacy database . In some examples the legacy system manager can also include a data API and or a database updater that can generate update commands e.g. write schema for the legacy database in the schema employed by the legacy database e.g. the V n schema . Further the legacy system manager of the legacy server can communicate with a legacy application . In some examples the legacy application can be integrated with the legacy server . In other examples the legacy application can be executed on a legacy device such that the communication between the legacy application and the legacy server occurs over the network . The legacy device could be for example a server a switch an end user telecommunication device e.g. a smart phone a desk phone or a video conferencing terminal or the like. The legacy application can be implemented for example as a data producing and receiving component that is configured to generate data for the legacy database . For example in the context of a telecommunication system the legacy application can include a switch control communication device control an interface voicemail service telecommunication management service a conference bridge service an instant messaging service or the like.

The legacy application can include logic e.g. intelligence that can be employed to identify a system e.g. the legacy system manager or the update system manager that can provide access to needed data stored in the legacy database. For example the logic can be a generic routing layer that is collocated with the legacy application or it may be external to the legacy application. Accordingly in one example the legacy application can provide a data request e.g. a read request to the legacy system manager . In response the legacy system manager can query the legacy database to retrieve data identified in the data request. Moreover the legacy system manager can return the data identified in the data request to the legacy application .

Additionally the legacy application can provide data to be written and or updated at the legacy database to the legacy system manager . In response the legacy system manager can generate an update command in a schema employed by the legacy database e.g. the V n schema that writes the data to the legacy database . In response to the update command the legacy database can store the data provided by the legacy application in a given record of the legacy database . Moreover a notification table of the legacy database can detect that the given record of the legacy database has been updated and provide a forward migration trigger to a trigger migrator of the upgrade server . The forward migration trigger can include the data characterizing the update to the legacy database . For instance the migration trigger can include and or be associated with data characterizing a nature of the update to the legacy database e.g. insert update and or delete and data for a change row and or other indicia that characterizes a high level summary of the update to the legacy database . As an example in a telecommunication system the update to the legacy database could indicate that a user has moved from a given switch to another switch and the forward migration trigger can include sufficient data that characterizes the details of the moving of the user. As used herein the term forward migration means to move a copy of data that is updated or is to be updated at or otherwise written to the legacy database to the upgrade database .

The trigger migrator can include logic to translate the forward migration trigger provided by the legacy database e.g. a V n trigger into a translated forward migration trigger e.g. a V trigger that is in a format that is ready for processing. Such logic can include for example database table and or field mappings. In other examples the trigger migrator can act as a pass through between the legacy database and the upgrade system manager . This can occur for instance where no translation of the forward migration trigger is needed. However for purposes of simplification of explanation it is considered that the trigger migrator provides a translated forward migration trigger in response to a forward migration trigger whether or not a translation of the forward migration trigger is needed.

In some examples the trigger migrator can provide the translated forward migration trigger to the upgrade adapter . The upgrade adapter can convert the information included in the translated forward migration trigger into a schema employed by the upgrade database e.g. the V schema which converted information can be referred to as a forward migration update. The conversion by the upgrade adapter may be needed for examples in situations where data included with the forward migration trigger is beyond a scope of the trigger migrator . To facilitate the generation of the forward migration update the upgrade adapter can access metadata that describes the upgrade database . The forward migration update can be provided to the upgrade system manager . The upgrade system manager can in response update the upgrade database based on the forward migration update. In this manner updates to the legacy database are forward migrated to the upgrade database with the appropriate schema.

In other examples the trigger migrator can provide the translated forward migration trigger to the upgrade system manager . The upgrade system manager can convert the translated forward migration trigger into a schema employed by the upgrade database e.g. the V schema which converted command can also be referred to an update command. It is noted that the updated command can be a delete command an update command and or an insert command. Moreover the upgrade system manager can update the upgrade database based on the update command. In this manner updates to the legacy database are forward migrated to the upgrade database .

Additionally the upgrade system manager can communicate with an upgraded application . The upgraded application can be implemented in a manner similar to the legacy application . For instance the upgraded application can be implemented on a device e.g. computer a switch an end user telecommunication device or the like . As a result of the upgraded application now being configured to read and write to the upgrade database the device can likewise be considered upgraded. Moreover the upgraded application can be implemented for example as a data producing and receiving component that is configured to generate and receive data for the upgrade database . For example in the context of a telecommunication system the upgraded application can include a switch control program or a communication application an interface voicemail service telecommunication management service a conference bridge service an instant messaging service or the like. In some examples the upgraded application could be employed to communicate with the legacy system manager in a manner similar to the communication between the legacy system manager and the legacy application while in other examples the upgraded application can employ functions that are incompatible with the legacy database due to changes made during the creation of the upgrade database .

The upgraded application can include logic e.g. intelligence that can identify a system e.g. the upgrade system manager that can provide access to data that can be employed by the upgraded application . The upgraded application can provide a data request to the upgrade system manager . In response the upgrade system manager can generate a query for the upgrade database in a schema that is employed by the upgrade database e.g. the V schema . In response to the query the upgrade database can provide data requested in the query to the upgrade system manager . The upgrade system manager can return the data requested in the data request to the upgraded application .

Additionally in some examples the upgraded application can provide data to be written and or updated at the upgrade database to the upgrade adapter . In response the upgrade adapter can generate an update command in a schema employed by the upgrade database e.g. the V schema that writes updates the data to the upgrade database . The update command can be provided to the upgrade system manager and in response to the update command the upgrade database can store the data provided by the upgraded application in a given record of the upgrade database . In this example the upgrade adapter can generate a reverse migration update for the legacy database based on the data provided by the upgraded application and based on stored metadata that describes the schema of the legacy database . As used herein the term reverse migration means to move a copy of data that is updated or is to be updated at the upgrade database e.g. in response to a write request from an upgraded application to the legacy database . Forward migrated data will not be reverse migrated back to the legacy database . Moreover the upgrade adapter can provide the reverse migration update to the legacy database such that the legacy database can be updated based on the reverse migration update. In this manner the upgrade database and the legacy database can be synchronized. It is noted that in some instances due to the changes in the schema between the upgrade database and the legacy database the adapter may be unable to generate the reverse migration update. In these instances the update to the upgrade database is not reverse migrated to the legacy database .

In other examples the upgrade system manager can receive the data to be written and or updated in the upgrade database . The upgrade system manager can examine the type of the data and determine whether to provide the update of the upgrade database to the legacy database through an exception path. In some examples some updates to the upgrade database may not be provided to the legacy database . For instance in a telecommunication system the upgrade system manager can be programmed to differentiate between personal updates e.g. personal options that relate to updates personal to an end user or end user device and non personal updates such as system or administrator level updates. For example updates to the upgrade database relating to personal options are not provided to the legacy database while updates related to non personal options can be provided to the legacy database via the exception path without first writing such data to the upgrade database. As an example if the upgraded application is implemented on an end user device such as a telephone or a smart phone the personal options can be related to call handling modes privacy settings personal directories ring tones voicemail notification handling or the like. Conversely non personal options can include nearly any other type of update to the upgrade database . As some examples if the upgraded application is implemented on a switch the non personal options could include but are not limited to a list of telephone extensions connected to the switch an IP address associated with the switch huntgroup schedules telephone number assignments related to the switch or the like.

If it is determined that the update to the upgrade database is not being provided to the legacy database e.g. it is a personal option the upgrade system manager can generate an update command for the upgrade database based on the data received from the upgraded application . If it is determined that the update to the upgrade database is to be provided to the legacy database e.g. a non personal option the upgrade system manager can generate the exception path to the legacy system manager that includes exception data characterizing the data provided by the upgraded application . The upgrade system manager can provide the exception data to the legacy system via the exception path without first storing the data in the upgrade database . In some examples the data provided by the upgraded application can be implemented as a primary key for a database. In such a situation exception data that includes the data provided by the upgraded application can be provided by the upgrade system manager of the upgrade server to the legacy system manager of the legacy server via a legacy API for the legacy database. The exception data thus can be received by the legacy system manager of the legacy server via the API and the legacy system manager can generate and execute an update command for the legacy database based on the exception data. In response the legacy database can generate a forward migration trigger based on the update to the legacy database that can be provided to the upgrade system manager and processed in a manner described herein. Thus in these examples the legacy database can contain a proper subset of the data stored in the upgrade database .

The system can be designed such that the upgraded application and or the legacy application can be configured to be agnostic as to the schema employed by an associated database. Stated differently the upgraded application and or the legacy application can be programmed such that the source and or destination e.g. the legacy database or the upgrade database of data consumed or provided is immaterial to the configuration of the upgraded application and or the legacy application. Such a configuration can ensure that the upgraded application and or the legacy application can move between domains e.g. between databases employing the V schema and the V n schema with relative simplicity e.g. no changes or minimal changes .

At some point in time it can be desirable and or necessary to retire the legacy database . Alternatively it may be desirable and or necessary to upgrade the legacy database to the schema employed in the upgrade database . In such a situation applications such as the system director implemented on the legacy system manager can be migrated to the upgrade server . Moreover upon such a migration of the applications the legacy database can be retired and or migrated to the schema employed by the upgrade database e.g. the V schema immediately since the data stored in the upgrade database will reflect the most recent updates to the legacy database . In other examples the upgrade database and an appropriate management framework can be migrated into the legacy server such as in conjunction with upgrading the director system. By employment of the system in an example where multiple databases are employed each database can be upgraded individually e.g. an incremental rolling upgrade while minimizing an impact on the overall system .

By employment of the system the schema employed by the upgrade database e.g. the V schema does not have to be compatible with the schema employed by the legacy database e.g. the V n schema . Moreover since the schemas do not need to be compatible the complexity of the applications that utilize the legacy database or the upgrade can be reduced since each application would only need to include logic to interface with one type of database. Further since the schemas do not need to be compatible the upgrade database could be implemented as a completely different type of database than the legacy database . For instance the legacy database could employ the MySQL schema or some derivative thereof while the upgrade database could employ the PostgreSQL schema or some derivative thereof which schema are incompatible.

Furthermore in some examples the architecture of the system can achieve a high degree of reliability since the upgrade database and the legacy database can be implemented on separate and independent systems. Moreover the architecture of the system can provide significant flexibility in scheduling and performing upgrades including in the order in which system components are upgraded to the schema employed by the upgrade database the V schema since each of the legacy databases and other components of the system can be upgraded incrementally and independently. There also will continue to be at least one functioning database e.g. the upgrade database and or the legacy database during a version upgrade process phase. This allows administrators to focus efforts on upgrading one or more legacy databases and further affords an extended opportunity to work out any infrastructure e.g. compatibility issues and even rollback to the legacy database if needed. Additionally during such a migration phase the system can allow moves adds and changes MACS .

Further still in some examples the system can achieve near real time data consistency between the legacy database and the upgrade database . That is since updates to the legacy database and the upgrade database happen at nearly the same time the upgrade database and the legacy database are nearly always synchronized with each other and the system can offer a consistent system wide view.

Further in examples where many databases are employed in a distributed system each database can be upgraded from the schema employed by the legacy database e.g. the V n schema to the upgrade database individually such that the system can continue to operate and function properly during a version migration phase. Further in the event that errors e.g. bugs in the schema are discovered in the upgrade database the upgrade database can be rolled back to the schema employed by the legacy database e.g. the V n schema since the upgrade database contains a superset of the data stored in the legacy database . Further in some examples primary key collisions can be avoided.

Each of the N number of legacy servers can be implemented in a manner similar to the legacy server illustrated in . The N number of legacy servers can each include a corresponding legacy database . Each of the N number of legacy databases can collectively form a distributed legacy database. Similarly each of the M number of upgrade servers can be implemented in a manner similar to the upgrade server illustrated in . Each of the upgrade servers can include an upgrade database that can collectively form a distributed upgrade database.

Each of the 1 through N number of legacy servers can be incrementally migrated to a corresponding one of the M number of upgrade servers . For instance in one example to migrate legacy server upgrade server can be brought online. In such a situation legacy database can employ the V n schema while the upgrade database can employ the V schema. Both of the legacy server and the upgrade server can operate concurrently during a migration phase such as in any of the manners described with respect to . Moreover at some point in time the legacy server may be retired e.g. shut down as explained with respect to . In such a situation each of the remaining 2 N legacy servers can continue to function properly before during and after the migration of the legacy server . Moreover each of the remaining 2 N legacy servers can be incrementally migrated in a manner similar to the legacy server . Accordingly each of the N number of legacy servers can be migrated to the corresponding M number of upgrade servers individually thereby avoiding the need to perform a big bang migration that includes upgrading each of the 1 N legacy servers at or near the same time. Instead the approach disclosed herein facilitates an incremental or rolling upgrade across the distributed legacy servers in a manner that can be controlled independently of each other e.g. by an administrator .

In each of the examples illustrated in a system can include a legacy server e.g. the legacy server illustrated in . The legacy server can include a legacy database LDB and a legacy system manager LEGACY SYS MGR . The legacy system manager can include for example a legacy application L APP that can be a consumer and a producer of data for in the legacy database . The legacy system manager can also include a data API D API and a database updater DB U that can each be employed to generate an update command e.g. write schema for the legacy database . In the examples of for purposes of simplification of explanation only one update command is provided in response to data being provided from the data API or the database updater however it is to be understood that the either the data API or the database updater could provide the update command according to where the update request was issued. Further the legacy system manager can include a director that can communicate data e.g. read and write to the legacy database via a framework such as a full stack web application framework. In the director and the framework are collectively illustrated as D2 FM . The legacy server can communicate with a legacy application EXT L APP that is external to the legacy server . The legacy application external to the legacy server can be implemented in a manner similar to the legacy application integrated with the legacy system manager .

The legacy server can communicate with an upgrade server e.g. the upgrade server illustrated in that can include an upgrade database UPDB . The upgrade database can employ a different schema e.g. the V schema than the schema the V n Schema employed in the legacy database . The upgrade server can include an upgrade system manager that can be employed to implement a data API D API and a database updater DB U that can each be employed to read and write data to the updated database. As mentioned above for purposes of simplification of explanation only one update command is provided in response to data being provided from the data API or the database updater but it is to be understood that the either the data API or the database updater could provide the update command depending on which one received the update request. The upgrade server can be configured to communicate with an upgraded application U APP . The upgraded application can consume and provide data to from the upgrade database . The upgrade server can also include a trigger migrator to receive and provide translated forward migration triggers. The trigger migrator can include logic to translate update requests in the V n schema into the V schema. For instance in some examples the trigger migrator can include logic to translate the forward migration trigger provided by the legacy database e.g. a V n trigger into a translated forward migration trigger e.g. a V trigger that is in a format that is ready for processing. Additionally in some examples e.g. an adapter can be employed to convert data into update commands e.g. write schema for the upgrade database and the legacy database .

It is noted that in the examples illustrated in although only legacy database and one upgrade database are shown and described in other examples the system could be implemented with a distributed legacy database and or a distributed upgraded database in manner shown and described with respect to . In such a situation updates to one upgrade database of a distributed upgrade database can be synchronized with some or all other upgrade databases of the distributed upgrade database. Similarly updates to one legacy database of a distributed legacy database can be synchronized with some or all other legacy databases of the distributed legacy database.

In the example illustrated in data DATA can be generated from the legacy application external to the legacy server or the legacy application integrated in the legacy server . Moreover the data can be provided to the data API of the legacy system manager and or the database updater of the legacy system manager . In response the database updater can generate an update command UPDATE CMD V n in a schema employed by the legacy database e.g. the V n schema . As noted the update command could be for example an insert update a delete command or a combination thereof. While in the example of only one update command is illustrated in response to multiple data signals in other examples a different update command can be provided for each different instance of data being provided to the data API and or the database updater . Additionally or alternatively the director can provide an update command to the legacy database via the framework.

In response to the update command from the framework or the database updater the legacy database can provide a forward migration trigger FMT to the trigger migrator of the upgrade server . The forward migration trigger can include data characterizing the update to the legacy database . For instance the forward migration trigger can include data characterizing a nature of the update to the legacy database e.g. insert update and or delete and data for a change row and or other indicia that characterizes a high level summary of the update to the legacy database . For instance in a telecommunication system the update to the legacy database could indicate that a user has moved from a given switch to another switch and the forward migration trigger can include sufficient data that characterizes the details of the moving of the user. The trigger migrator of the upgrade server can translate the forward migration trigger into a translated forward migration trigger TFMT that can be provided to the adapter .

The adapter can convert the information included in the forward migration trigger into a schema employed by the upgrade database e.g. the V schema which converted command can be referred to as a forward migration update FMU . To facilitate the generation of the forward migration update the adapter can access metadata that describes the upgrade database . The adapter can provide the forward migration update to the database updater . In response the database updater can generate and execute an update command e.g. a write schema on the updated database thereby synchronizing the update to the legacy database with the upgrade database .

In data DATA can be provided from an upgraded application to the adapter . In response the adapter can forward the data to the database updater . The database updater can execute an update command e.g. a write request on the updated database based on data forwarded by the adapter . Additionally the adapter can generate a reverse migration update RMU that includes an update command e.g. a write schema for the legacy database that is also based on the data provided from the upgraded application . To generate the reverse migration update the adapter can employ metadata that characterizes the schema employed by the legacy database e.g. the V n schema . In response to the reverse migration update the legacy database can be updated. In some examples the adapter may not provide the reverse migration update if it is determined that the data provided from the upgraded application is not compatible with the legacy database . For instance the adapter may not provide the reverse migration update if an update command for the data provided by the application cannot be properly characterized by the schema employed by the legacy database e.g. the V n schema .

By employment of the method illustrated in the database schema employed by the upgrade database e.g. the V schema does not need to be compatible with the schema employed by the legacy database e.g. the V n schema . Moreover since the schemas do not need to be compatible complexity of the applications that utilize the legacy database or the upgrade can be reduced since each application would only need to include logic to interface with one type of database. Further since the schemas do not need to be compatible the upgrade database could be implemented as a completely different type of database than the legacy database .

Furthermore in some examples the architecture of the system can achieve a high degree of reliability since the upgrade database and the legacy database are implemented on separate systems and can operate independently. As a result the architecture can provide significant flexibility in scheduling and performing upgrades to the schema employed by the upgrade database the V schema since the databases and components of the system can be upgraded incrementally since there will continue to be at least one functioning database e.g. the upgrade database and or the legacy database during a version migration phase. The flexibility also extends to the order in which system components are upgraded. Additionally during such a migration phase the system can allow move adds and changes MACS with little to no modifications to account for the migration phase.

Further still in some examples the system can achieve near real time data consistency between the legacy database and the upgrade database . That is since updates to the legacy database and the upgrade database happen at nearly the same time the upgrade database and the legacy database are nearly always synchronized with each other and the system can offer a consistent system wide view.

Moreover since applications have both the upgrade database and the legacy database available database read commands do not all have to be in the schema employed by the legacy database e.g. the V n schema . Further in the event that a rollback of the upgrade database is needed the rollback would be relatively simple since the legacy database would contain at least all of the data contained in the upgrade database .

In response to an update command e.g. a write schema the legacy database can be updated. Moreover the legacy database provide a forward migration trigger FMT to the trigger migrator of the upgrade server wherein the forward migration trigger can include data characterizing the update to the legacy database . For instance the data in the forward migration trigger can characterize a nature of the update to the legacy database and data for a changed row or some other high level summary of the change e.g. a user moving from a given switch to another switch . The trigger migrator can translate the forward migration trigger into a translated forward migration trigger TFMT . The translated forward migration trigger can be provided to the database updater of the upgrade system manager . In response to the translated forward migration trigger the database updater can generate an update command e.g. UPDATE CMD V in a schema employed by the upgrade database e.g. the V schema . As noted the update command can be implemented as an insert command an update command a delete command or a combination thereof.

In the upgraded application can provide data DATA to be stored in the upgrade database to the data API and or the database updater of the upgrade system manager . In response the database updater can examine the data provided by the application and determine whether the data should be provided to the legacy database . In the example of if the nature of the update is related to a given type of update the data would not be provided to the legacy database while if the nature of the data is related to a different type of update the data is provided to the legacy database via an exception path. For instance in a telecommunication system if the data provided from the upgraded is related to non personal options e.g. phone settings hunt group schedules telephone switch assignments or the like the database updater can determine that the data provided from the upgrade database should be provided to the legacy database . In such a situation the database updater can generate exception data that includes the data provided from the upgraded application . The exception data can be provided to the data API of the legacy system manager via the exception path. In response the data API can generate and execute an update command UPDATE CMD V n with the schema employed by the legacy database e.g. the V n schema . As noted the update command can be implemented as an insert command an update command a delete command or a combination thereof.

Upon updating the legacy database the legacy database can generate a forward migration trigger FMT that can be provided to the trigger migrator of the upgrade server . The trigger migrator can translate the forward migration trigger into a translated forward migration trigger TFMT which can be in a format for further processing. The trigger migrator can provide the translated forward migration trigger to the database updater of the upgrade system manager . In response the database updater can generate and execute an update command UPDATE CMD V on the upgrade database in the schema employed by the upgrade database e.g. the V schema . As noted the update command can be implemented as an insert command an update command a delete command or a combination thereof. The exception path can provide a mechanism for routing an update from the upgrade server to the legacy server via the legacy API for updating the legacy database which updates are then forward migrated back to the upgrade database where the update process originated as disclosed herein. In this manner updates to data related to the different type can be synchronized between the upgrade database and the legacy database .

In data can be provided from the upgraded application DATA to the data API and or the database updater of the upgrade system manager that can be related to the given type. In some examples such as telecommunications system the given type of data can be personal options user change mode updates user mailbox settings call handling or the like for a telephone e.g. a smart phone a desk phone or the like . In such a situation the database updater can determine that the data provided from the upgraded application is not to be provided to the legacy database . Thus the database updater can generate and execute an update command UPDATE CMD V on the upgrade database . As noted the update command can be implemented as an insert command an update command a delete command or a combination thereof. In this example the data provided by the upgraded application is provided to the legacy database . Thus the upgrade database can have a proper superset of data in the legacy database .

By employment of the system illustrated in the database schema of the upgrade database does not have to be compatible with the database schema employed by the legacy database e.g. the V n schema since applications have both the upgrade database and the legacy database available. Moreover since the schemas do not need to be compatible complexity of the applications that utilize the legacy database or the upgrade can be reduced since each application would only need to include logic to interface with one type of database. Further since the schemas do not need to be compatible the upgrade database could be implemented as a completely different type of database than the legacy database .

Furthermore in some examples the architecture of the system can achieve a high degree of reliability since the upgrade database and the legacy database are implemented on separate systems. Moreover the architecture can provide significant flexibility in scheduling and performing upgrades to the schema employed by the upgrade database the V schema since components of the system can be upgraded incrementally since there will continue to be at least one functioning database e.g. the upgrade database and or the legacy database during a version migration phase. The flexibly afforded by this architecture further extends to the order in which system components are upgraded. Additionally during such a migration phase the system can allow move adds and changes MACS with little to no changes to account for the migration phase.

Further still in some examples the system can achieve near real time data consistency between the legacy database and the upgrade database . That is since updates to the legacy database and the upgrade database happen at nearly the same time the upgrade database and the legacy database are nearly always synchronized with each other the system can offer a consistent system wide view.

Moreover since both database versions are employed and the upgrade database and the legacy database are synchronized for all data except the given data type rollback is relatively simple. Further in contrast to the example illustrated in no reverse migration path is needed thereby further reducing complexity. Moreover in the chances of primary key collisions are reduced and or eliminated since the legacy database is updated before the upgrade database in examples where the legacy database is updated.

The memory can include an upgrade database that can employ a schema e.g. the V schema . The upgrade database can be implemented for example as a legacy database that has been generated based on or converted from a legacy database that employed a different schema e.g. the V n schema . The upgrade server can communicate with a legacy application that was configured to previously communicate with the legacy database and the upgraded application that is configured to communicate with the upgrade database .

The upgraded application in the legacy application can be implemented for example as data consumer and producing objects. For instance in a telecommunication system the upgraded application or the legacy application could be implemented on a switch a computer e.g. a server or personal computer or an end user device e.g. a smart phone or a desk phone .

The legacy application can provide data requests to the upgrade database to read data. The data requests can be sent in the schema employed by the legacy database e.g. the V n schema . The upgrade database can be configured to provide the legacy application with the data that is requested in the data request. In a similar manner the upgraded application can provide a data request to the upgrade database to read data wherein the data request from the upgraded application can be provided in the schema employed by the upgrade database e.g. the V schema . Moreover the upgrade database can be configured to respond to the data request provided from the upgraded application with the data identified in the data request. In this manner the upgraded application and the legacy application can request that data be read from the upgrade database without a change to the data request.

In some examples the upgraded application or the legacy application can provide data that is to be written to the upgrade database . In the example where the legacy application provides data to be written to the upgrade database an upgrade adapter stored in memory can detect the data provided from the legacy application and generate an update command e.g. a write schema in the schema employed by the upgrade database e.g. the V schema . To generate the update command the upgrade adapter can include update logic for the schema employed by the legacy database e.g. the V n schema and migration logic for the schema employed by the upgrade server e.g. the V schema . The update command can be executed on the upgrade database . In a similar manner the upgraded application can provide data to be written to the upgrade database . In response to detecting the data provided by the upgraded application the upgrade adapter can generate another update command that employs the schema employed by the upgrade database e.g. the V schema . The example system can allow for incremental upgrading in a distributed database system. Moreover the upgrade adapter can include reverse migration scripts to downgrade the upgrade database to the schema employed by the legacy database e.g. the V n schema .

At the upgrade system manager can provide exception data to a legacy system manager e.g. the legacy system manager of of the legacy server. At the legacy system manager can update the legacy database based on the exception data. To update the legacy database the legacy system manager can generate and execute an update command in a schema employed by the legacy database e.g. the V n schema . At the legacy database can provide a forward migration trigger to the upgrade system manager via a trigger migrator e.g. the trigger migrator of of the upgrade server. At the upgrade system manager can update the upgrade database based on the forward migration trigger by generating and executing an update command in the schema employed by the upgrade database e.g. the V schema .

At a director or other management interface executing on the legacy server e.g. the director illustrated in can be migrated to the upgrade server from the legacy server. In some examples additional components such as a framework to facilitate execution of the framework can also be migrated. At the legacy database can be retired since the upgrade database can contain a superset of the data stored at the legacy database.

What have been described above are examples. It is of course not possible to describe every conceivable combination of components or methodologies but one of ordinary skill in the art will recognize that many further combinations and permutations are possible. Accordingly the disclosure is intended to embrace all such alterations modifications and variations that fall within the scope of this application including the appended claims. As used herein the term includes means includes but not limited to the term including means including but not limited to. The term based on means based at least in part on. Additionally where the disclosure or claims recite a an a first or another element or the equivalent thereof it should be interpreted to include one or more than one such element neither requiring nor excluding two or more such elements.

