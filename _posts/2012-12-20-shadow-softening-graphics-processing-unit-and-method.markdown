---

title: Shadow softening graphics processing unit and method
abstract: A shadow softening GPU and method. One embodiment of the GPU is configured to render a shadow cast by a surface occluding a light source and includes: (1) a fetching circuit operable to retrieve a depth value from a texture associated with the surface and a depth comparison result in a single fetch operation, and (2) a shadow softening circuit configured to respectively employ the depth comparison result and the depth value to identify the surface as a blocker and attenuate the light source for a pixel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08872827&OS=08872827&RS=08872827
owner: Nvidia
number: 08872827
owner_city: Santa Clara
owner_country: US
publication_date: 20121220
---
This application is directed in general to computer graphics rendering and more specifically to the rendering of shadows.

Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional 3D scene from a given viewpoint. This process called rendering generates a two dimensional 2D image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene.

As the demand for computer graphics and in particular for real time computer graphics has increased computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems the rendering process is divided between a computer s general purpose central processing unit CPU and the graphics processing subsystem architecturally centered about a graphics processing unit GPU . Typically the CPU performs high level operations such as determining the position motion and collision of objects in a given scene. From these high level operations the CPU generates a set of rendering commands and data defining the desired rendered image or images. For example rendering commands and data can define scene geometry lighting shading texturing motion and or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering commands and data.

Scene geometry is typically represented by geometric primitives such as points lines polygons for example triangles and quadrilaterals and curved surfaces defined by one or more two or three dimensional vertices. Each vertex may have additional scalar or vector attributes used to determine qualities such as the color transparency lighting shading and animation of the vertex and its associated geometric primitives. Scene geometry may also be approximated by a depth texture representing view space Z coordinates of opaque objects covering each pixel.

Many graphics processing subsystems are highly programmable through an application programming interface API enabling complicated lighting and shading algorithms among other things to be implemented. To exploit this programmability applications can include one or more graphics processing subsystem programs which are executed by the graphics processing subsystem in parallel with a main program executed by the CPU. Although not confined merely to implementing shading and lighting algorithms these graphics processing subsystem programs are often referred to as shading programs programmable shaders or simply shaders. 

Shadows are often rendered with respect to a single light source and then merged together with shadows rendered for each other light source. In computer graphics scenes generally contain complex geometries and numerous light sources. Shadow rendering or shading per light source can become a critically long process in the graphics pipeline and is often afforded a great deal of attention to speed the processing.

Also of great importance is how realistic the rendered shadows turn out. Shadows experience a phenomenon known as contact hardening. Contact hardening occurs as a shadow casting surface or blocker nears the surface being shaded or the receiver. Shadows nearest the intersection are sharp or hard and then soften or blur as the shadow extends away creating a penumbra effect. Contact hardening soft shadows are important for realistic rendering because the human visual system uses the variations of penumbra size as a cue for evaluating distances between shadow casting and shadow receiving objects.

One aspect provides a GPU configured to render a shadow cast by a surface occluding a light source including 1 a fetching circuit operable to retrieve a depth value from a texture associated with the surface and a depth comparison result in a single fetch operation and 2 a shadow softening circuit configured to respectively employ the depth comparison result and the depth value to identify the surface as a blocker and attenuate the light source for a pixel.

Another aspect provides a method of shadow softening a pixel in a scene with respect to a light source including 1 rendering a light space depth map for the scene with respect to the light source 2 comparing a sample depth from the light space depth map to a screen space depth of the pixel transformed into light space 3 fetching the sample depth from a texture held in a memory and a result of the comparing in a single fetch operation and 4 employing the result and the sample depth in attenuating the light source with respect to the pixel.

Yet another aspect provides a graphics processing subsystem configured to shade a pixel including 1 a memory configured to store a shadow map texture containing texels characterizing potentially occluding surfaces with respect to a light source the texels configured to contain a light space depth value and 2 a GPU configured to take sample texels of the shadow map texture about the pixel and having 2a a fetching circuit operable to retrieve the light space depth value from one of the sample texels and a depth comparison result in a single fetch operation and 2b a shadow softening circuit configured to respectively employ the depth comparison result and the light space depth value of each of the sample texels to identify the potentially occluding surfaces as blockers and attenuate the light source for the pixel.

Before describing various embodiments of the shadow softening GPU or method introduced herein shadow softening will be generally described.

Several shadow softening techniques are frequently implemented in graphics processing systems. One such technique is known as percentage closer filtering PCF . In PCF the degree of softening is proportional to the percent of samples between a pixel and a light source. Another technique is percentage closer soft shadows PCSS which is an extension of PCF that provides contact hardening. These and many others can be described in two stages shadow mapping and shadow rendering.

Shadow mapping is a process by which a scene is rendered with respect to a single light source. This frame of reference is known as light space. In light space the geometry of the scene is rasterized at some resolution into a depth map capturing the surfaces in the scene receiving direct light from the light source. In other words the depth map represents what surfaces the light source sees. The depth map sometimes called a shadow map is stored in a texture data structure. Each point in the rasterization is a texel.

Outside of this shadow mapping process is normal scene geometry rendering rasterizing the scene into screen space. Screen space is the frame of reference for the eye of the viewer. A screen space scene is similarly stored as a depth map in the depth buffer or Z buffer. The screen space depth map represents the surfaces in the scene the eye can see. Each rasterized pixel in screen space is the subject of shadow rendering specifically shadow softening.

Shadow rendering operates pixel by pixel by sampling nearby surfaces and determining whether or not those surfaces occlude light that would otherwise be incident on the pixel being rendered. This determination may be made by a light space depth comparison of the pixel and each of the sampled nearby surfaces. To make the comparison the screen space depth of the pixel being rendered is first transformed from screen space into light space. The light space depth map is then sampled about the pixel now transformed into light space. The light space depth of each sample is compared to the light space depth or reference depth of the pixel being rendered. If the sample depth is between the light source and the reference depth i.e. depth

It is realized herein that many implementations of shadow rendering require the use of the depth value and the result of a comparison of the depth value to a reference depth the depth value being stored in a texel and the comparison being made on retrieval. It is further realized herein that existing architectures provide these two pieces of data independently and consequently existing architectures place a processing burden on the GPU to fetch the depth value from a texel stored in memory and to carry out the comparison. It is realized herein that an architecture configured to fetch both the depth value from the texel stored in memory and the result of the comparison value in a single fetch operation allows for more efficient use of graphics processing hardware.

Having described various novel realizations a computing system within which the shadow softening GPU and method introduced herein may be embodied or carried out will be described.

As shown the system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM employed to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions transmitted by the CPU and processes the instructions to render and display graphics images on the display devices .

As also shown the system memory includes an application program an application programming interface API and a graphics processing unit GPU driver . The application program generates calls to the API to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits zero or more high level shading programs to the API for processing within the GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shading engines within the graphics processing subsystem . The API functionality is typically implemented within the GPU driver . The GPU driver is configured to translate the high level shading programs into machine code shading programs that are typically optimized for a specific type of shading engine e.g. vertex geometry or fragment .

The graphics processing subsystem includes a graphics processing unit GPU an on chip GPU memory an on chip GPU data bus a GPU local memory and a GPU data bus . The GPU is configured to communicate with the on chip GPU memory via the on chip GPU data bus and with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as a shading engine that includes one or more programmable shaders each executing a machine code shading program i.e. a thread to perform image rendering operations. The GPU may be provided with any amount of on chip GPU memory and GPU local memory including none and may employ on chip GPU memory GPU local memory and system memory in any combination for memory operations.

The on chip GPU memory is configured to include GPU programming code and on chip buffers . The GPU programming may be transmitted from the GPU driver to the on chip GPU memory via the system data bus . The GPU programming may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The on chip buffers are typically employed to store shading data that requires fast access to reduce the latency of the shading engines in the graphics pipeline. Since the on chip GPU memory takes up valuable die area it is relatively expensive.

The GPU local memory typically includes less expensive off chip dynamic random access memory DRAM and is also employed to store data and programming employed by the GPU . As shown the GPU local memory includes a frame buffer . The frame buffer stores data for at least one two dimensional surface that may be employed to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is employed to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

Having generally described a computing system within which the shadow softening GPU or method may be embodied or carried out various embodiments of the shadow softening GPU and method introduced herein will be described.

Continuing the embodiment of fetching circuit is configured to retrieve or fetch texel data from memory over data bus . Shadow softening circuit uses the fetched texel data to render a soft shadow.

Depth value is a light space depth or Z buffer value for the surface characterized by texel . A pixel being rendered is first rasterized into a screen space depth buffer. From there it can be transformed or rotated into light space where it can be compared to depth value . The result of this comparison is a depth comparison result. Alternate embodiments may include additional pieces of data in the texel data structure such as coloring or material properties. Some embodiments may even store the depth comparison result in the texel data structure.

The depth comparison result may be employed as an indicator of whether or not the surface characterized by texel is a potential occluding surface of the light source with respect to the pixel being rendered. The comparison amounts to an evaluation of whether depth value is less than the light space depth of the pixel being rendered or the reference depth. If the depth comparison result is true the surface characterized by texel is between the pixel and the light source and is then considered by the shadow softening process. The shadow softening process employs depth value to attenuate the light source for the pixel. In certain embodiments multiple sample texels are considered for rendering the pixel. The depth value and depth comparison result of each sample texel are fetched and employed in the same or similar manner described above. Certain embodiments may employ percentage closer filtering PCF to soften shadows. Other embodiments may employ a percentage closer soft shadows PCSS technique.

To shade pixel with respect to light source a shadow map may be formed with respect to light source . A reference frame known as light space is created at light source and a depth map is rendered in that reference frame. It is apparent in that surfaces and are between pixel and light source . If a screen space depth of pixel is transformed into light space a comparison may be made of the depth of pixel to the depths of surfaces and . This comparison would identify both surfaces and as blockers with respect to pixel and light source .

Continuing the embodiment of at a step a sample depth from the depth map is compared to a reference depth. The reference depth is the light space depth of the pixel being shaded. The reference depth is transformed into light space from a screen space depth buffer or Z buffer. In a single fetch operation the comparison result and the sample depth value are fetched from the texel data structure at step . Once fetched the comparison result is a binary indicator as to whether the surface characterized by the texel is potentially occluding the light source with respect to the pixel. In other words the comparison tests whether the surface is between the light source and the pixel in light space. If so at step the light source is attenuated to some degree for that pixel. If not no attenuation of the light source is attributed to that surface. The method ends in an end step .

In certain embodiments the attenuation is achieved by a PCF method. Multiple samples are taken about the pixel and multiple texels fetched. The depth values and depth comparison results of each sample texel are fetched for the PCF processing. Alternate embodiments may employ a PCSS method also requiring multiple samples.

Those skilled in the art to which this application relates will appreciate that other and further additions deletions substitutions and modifications may be made to the described embodiments.

