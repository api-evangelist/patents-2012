---

title: Deferred shading graphics processing unit, geometry data structure and method of performing anti-aliasing in deferred shading
abstract: A deferred shading GPU, geometry data structure and method. One embodiment of the geometry data structure is found in a graphics processing subsystem operable to render a scene having a pixel represented by samples. The graphics processing subsystem includes: (1) a memory configured to store a geometry data structure associated with the pixel containing surface fragment coverage masks associated with the samples, and (2) a GPU configured to employ the surface fragment coverage masks to carry out deferred shading on the pixel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09390540&OS=09390540&RS=09390540
owner: Nvidia Corporation
number: 09390540
owner_city: Santa Clara
owner_country: US
publication_date: 20121221
---
This application is directed in general to computer graphics and more specifically to deferred shading systems and methods.

Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional 3D scene from a given viewpoint. This process called rendering generates a two dimensional 2D image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene.

As the demand for computer graphics and in particular for real time computer graphics has increased computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems the rendering process is often described as a graphics pipeline and is divided between a computer s general purpose central processing unit CPU and the graphics processing subsystem architecturally centered about a graphics processing unit GPU . Typically the CPU performs high level operations such as determining the position motion and collision of objects in a given scene. From these high level operations the CPU generates a set of rendering commands and data defining the desired rendered image or images. For example rendering commands and data can define scene geometry lighting shading texturing motion and or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering commands and data.

Scene geometry is typically represented by geometric primitives such as points lines polygons for example triangles and quadrilaterals and curved surfaces defined by one or more two or three dimensional vertices. Each vertex may have additional scalar or vector attributes used to determine qualities such as the color transparency lighting shading and animation of the vertex and its associated geometric primitives. Scene geometry may also be approximated by a depth texture representing view space Z coordinates of opaque objects covering each pixel.

Many graphics processing subsystems are highly programmable through an application programming interface API enabling complicated lighting and shading algorithms among other things to be implemented. To exploit this programmability applications can include one or more graphics processing subsystem programs which are executed by the graphics processing subsystem in parallel with a main program executed by the CPU. Although not confined merely to implementing shading and lighting algorithms these graphics processing subsystem programs are often referred to as shading programs programmable shaders or simply shaders. 

Pixel shaders are one example of shading programs. Pixel shaders are used in a technique known as deferred shading in which various lighting and shading processes are decoupled from and carried out after geometry rendering in a later stage of the graphics pipeline known as screen space. Screen space rendering occurs just before displaying a scene and screen space rendering processes are carried out pixel by pixel. Deferred shading is a technique employed by many modern rendering engines that allows rendering of numerous complex geometries and light sources while simplifying the graphics pipeline and maintaining a proportional relationship between quality and performance.

One limitation of screen space techniques such as deferred shading is the lack of data available at later stages of the graphics pipeline. Screen space rendering processes rely on data available in a geometry buffer or G buffer. The G buffer is generated during geometry rendering and rasterizing. The G buffer stores material properties of all visible geometry per pixel. A specific limitation of deferred shading is the inability to resolve shading ambiguities in screen space. This is otherwise referred to as an incompatibility with anti aliasing or AA. 

Aliasing in computer graphics occurs when a high resolution or high frequency image feature is reproduced at a low resolution. High resolution features most occur at boundaries between two or more surfaces in an image. The rendering process is unable to distinguish the boundaries causing them to become distorted. Shading ambiguities may be resolved during rendering by traditional multisampling AA techniques. However once the surface boundaries are rasterized to a pixel ambiguities may remain with respect to how the pixel is to be shaded. This is due to the fact that in screen space the G buffer lacks sufficient geometric pixel coverage data to perform AA.

Shading during geometry rendering provides other benefits over deferred shading. For example deferred shading is largely incapable of handling transparency in surfaces. Deferred shading also requires a larger G buffer so complex compositions of materials in a scene may be shaded appropriately. These disadvantages together with the incompatibility of AA sometimes lead graphics developers to avoid deferred shading all together.

One aspect provides a graphics processing subsystem operable to render a scene having a pixel represented by samples. The graphics processing subsystem includes 1 a memory configured to store a geometry data structure associated with the pixel containing surface fragment coverage masks associated with the samples and 2 a GPU configured to employ the surface fragment coverage masks to carry out deferred shading on the pixel.

Another aspect provides a method of shading a pixel represented by samples in a previously rendered scene including 1 employing surface fragment coverage masks associated with the samples in determining a number of unique surface fragments covering the pixel 2 employing the surface fragment coverage masks in generating a mapping of the unique surface fragments to the samples and 3 shading the pixel according to the number of unique surface fragments and the mapping.

Yet another aspect provides a graphics processing GPU operable to render a scene containing a pixel including 1 a rasterizer configured to generate surface attributes associated with visible geometry within the pixel and surface fragment coverage masks associated with samples of the pixel 2 a memory configured to store a geometry data structure associated with the pixel containing 2a the surface attributes and 2b the surface fragment coverage masks and 3 a shader configured to employ the geometry data structure in shading the pixel.

Before describing various embodiments of the deferred shading GPU geometry data structure or method introduced herein deferred shading and anti aliasing will be generally described.

Deferred shading is a common technique for decoupling the shading of pixels from the computing of complex geometry and lighting conditions in a scene. The decoupling occurs because deferred shading processes operate on data in the G buffer and are carried out after complete geometry data have been discarded from the graphics pipeline. Unfortunately this very fact underlies the limitation mentioned above namely its incompatibility with anti aliasing techniques.

Boundaries among surfaces in a scene may be under sampled and therefore exhibit aliasing. The surfaces each retain their own material characteristics among other surface attributes. As the surfaces are rasterized ambiguities arise where a single pixel spans two or more surface fragments. A deferred shading program must resolve the ambiguity to perform its shading else suffer the aliasing. Traditional per pixel multi sampling would be sufficient but must be performed while geometry is rendered. Per pixel multi sampling relies on detailed surface fragment coverage information that is lacking in the G buffer. This is in essence the incompatibility.

Several conventional approaches exist to address the incompatibility between anti aliasing and deferred shading. One such approach involves supersampling the entire scene to support shading downstream. However a massive amount of work needs to be performed during the deferred shading stage making this approach impractical in today s systems. Another approach is to perform selective supersampling by supersampling only pixels recognized as having high frequency content. However this approach still performs excessive amount of computation to process those high frequency pixels. Yet another approach is to perform anti aliasing after deferred shading as a post process. However this anti aliasing is particularly ineffective since most of the needed sub pixel data is unavailable.

It is fundamentally realized herein that surface fragment coverage information may be recovered in screen space by storing surface fragment coverage masks in the G buffer. It is realized herein that for multi sampled pixels the surface fragment coverage masks are generated by the rasterizer per sample. It is further realized herein that a deferred shader can reconstruct surface fragment coverage by compiling the per sample surface fragment coverage masks into a coverage matrix. It is realized herein that the coverage matrix may be manipulated to determine a number of unique surface fragments in a pixel and to map the unique surface fragments to the samples in the pixel.

It is realized herein that the raster coverage matrix may contain ambiguities that can lead to incorrect reconstruction of surface coverage. It is also realized herein that these ambiguities may be resolved by a rectifying process. It is realized herein that an unambiguous coverage matrix is symmetric. It is further realized herein that the raster coverage matrix may be made symmetric by carrying out a bit wise AND operation between the raster coverage matrix and its transpose.

It is also realized herein that some future GPUs may produce a post Z coverage mask lacking the ambiguities of the raster coverage mask. The raster coverage mask may indicate a sample is covered but it may not be visible. It is realized herein that the post Z coverage mask represents coverage by visible fragments by considering depth data Z buffer in forming the mask. It is further realized herein that storing the post Z coverage matrix in the G buffer for use in deferred shading relieves the need for the raster coverage matrix and additional processing to make it symmetric.

Having described various novel realizations a computing system within which the deferred shading GPU geometry data structure and method may be embodied or carried out will be described.

As shown the system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM employed to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions transmitted by the CPU and processes the instructions to render and display graphics images on the display devices .

As also shown the system memory includes an application program an application programming interface API and a graphics processing unit GPU driver . The application program generates calls to the API to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits zero or more high level shading programs to the API for processing within the GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shading engines within the graphics processing subsystem . The API functionality is typically implemented within the GPU driver . The GPU driver is configured to translate the high level shading programs into machine code shading programs that are typically optimized for a specific type of shading engine e.g. vertex geometry or fragment .

The graphics processing subsystem includes a graphics processing unit GPU an on chip GPU memory an on chip GPU data bus a GPU local memory and a GPU data bus . The GPU is configured to communicate with the on chip GPU memory via the on chip GPU data bus and with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as a shading engine that includes one or more programmable shaders each executing a machine code shading program i.e. a thread to perform image rendering operations. The GPU may be provided with any amount of on chip GPU memory and GPU local memory including none and may employ on chip GPU memory GPU local memory and system memory in any combination for memory operations.

The on chip GPU memory is configured to include cached portions of the GPU programming code and on chip buffers . The GPU driver may cache the GPU programming code to the on chip GPU memory via the system data bus . The GPU programming may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The on chip buffers are typically employed to store shading data that requires fast access to reduce the latency of the shading engines in the graphics pipeline. Since the on chip GPU memory takes up valuable die area it is relatively expensive.

The GPU local memory typically includes less expensive off chip dynamic random access memory DRAM and is also employed to store data and programming employed by the GPU . As shown the GPU local memory includes a frame buffer . The frame buffer stores data for at least one two dimensional surface that may be employed to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is employed to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

Having generally described deferred shading anti aliasing and a computing system within which the deferred shading GPU geometry data structure and method may be embodied or carried out various embodiments of the deferred shading GPU geometry data structure and method will be described.

During geometry rendering geometry renderer rasterizes surfaces in the frame into N pixels to be displayed. Information is abstracted from the surfaces and stored in memory specifically in G buffer . Information stored in G buffer is merely a subset of the information available to geometry renderer . Once rasterized the complete set of information is discarded from the graphics pipeline and the frame moves into a stage of the pipeline known as screen space. Deferred shader operates on each of pixels through N in screen space. In certain embodiments deferred shader performs a color shading function. In other embodiments it may perform an ambient occlusion function or possibly direct occlusion. A variety of deferred shading programs exist including bump mapping shadows specular highlights and translucency and each employs certain pieces of per pixel data from the G buffer.

In the embodiment of pixel is multi sampled allowing it to be partially shaded according to surface attributes for surface fragment and partially shaded according to surface attributes for surface fragment . Generally sample C would be shaded as surface fragment and samples A B and D would be shaded as surface fragment .

A surface fragment coverage mask for sample A would be 1 0 1 1 . The same mask serves as surface fragment coverage masks for samples B and D. A surface fragment coverage mask for sample C would be 0 1 0 0 . If these four masks were combined into a coverage matrix it would appear as follows 

With the addition of surface fragment an ambiguity exists as to sample B. Both surface fragment and surface fragment cover sample B. This ambiguity may be resolved during geometry rendering but sufficient data is lacking in screen space. Consequently a deferred shading program would not be able to resolve the ambiguity with the information available in the G buffer. The ambiguity may however be resolved given the data available in the asymmetric coverage matrix above. The asymmetries in the matrix represent the ambiguity therefore rectifying the asymmetries resolves the ambiguities. The coverage matrix above may be made symmetric by a logical AND operation on the matrix and its transpose.

In alternate embodiments the surface fragment coverage information for pixel may be represented by a post Z coverage matrix that would lack the ambiguities seen in the coverage matrix above the raster coverage matrix . The post Z coverage matrix of certain embodiments would appear as follows 

Those skilled in the art to which this application relates will appreciate that other and further additions deletions substitutions and modifications may be made to the described embodiments.

