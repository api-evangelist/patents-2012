---

title: Scalar optimizations for shaders
abstract: Described herein are optimizations of thread loop intermediate representation (IR) code. One embodiment involves an algorithm that, based on data-flow analysis, computes sets of temporary variables that are loaded at the beginning of a thread loop and stored upon exit from a thread loop. Another embodiment involves reducing the size of a thread loop trip for a commonly-found case where a piece of compute shader is executed by a single thread (or a compiler-analyzable range of threads). In yet another embodiment, compute shader thread indices are cached to avoid excessive divisions, further improving execution speed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09430199&OS=09430199&RS=09430199
owner: Microsoft Technology Licensing, LLC
number: 09430199
owner_city: Redmond
owner_country: US
publication_date: 20120216
---
Recent trends indicate significant increase in the use of GPUs graphics processing units for general purpose computing GPGPU . That is GPUs are tending to be used for computing not necessarily related to computer graphics such as physics simulation video transcoding and other data parallel computing. Furthermore the introduction of on chip shared memory in GPUs has led to marked performance improvements for widely used compute intensive algorithms such as all prefix sum scan histogram computation convolution Fast Fourier Transform FFT physics simulations and more. Microsoft Corporation offers the Direct X HLSL High Level Shading Language Compute Shader as a software API application programming interface to access and utilize shared memory capabilities. Note that Direct X the HLSL and Compute Shader will be referred to as examples with the understanding that comments and discussion directed thereto are equally applicable to other shading languages such as CUDA Compute Unified Device Architecture OpenCL Open Compute Language etc. These will be referred to generically as compute shaders .

A complete software platform should provide efficient software rasterization of a compute shader or the like on CPUs to provide a fallback when GPU hardware is not an option or when the software platform is used in a headless VM Virtual Machine scenario without the need to implement both GPU and CPU hardware solutions. That is it is sometimes desirable to execute shader language code on a CPU rather than a GPU. However mapping GPU centric compute shaders onto CPUs efficiently is non trivial primarily due to thread synchronization which is enforced by thread barriers or syncs .

To address this problem techniques have been developed to partition a compute shader into maximal size regions called thread loops thus allowing compute shader code to be mapped efficiently to CPUs despite the presence of thread barriers. For that technique see commonly assigned U.S. patent application Ser. No. 13 398 798 titled RASTERIZATION FOR COMPUTE SHADERS filed Feb. 16 2012 and incorporated by reference herein. While thread loop transformations are helpful thread loops may be subjected to optimizations that improve their efficiency when running on a CPU.

The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter which is set forth by the claims presented at the end.

Described herein are optimizations of thread loop intermediate representation IR code. One embodiment involves an algorithm that based on data flow analysis computes sets of temporary variables that are loaded at the beginning of an iteration of a thread loop and stored upon completion of a thread loop iteration. Another embodiment involves reducing the size of a thread loop trip for a commonly found case where a piece of compute shader is executed by a single thread or a compiler analyzable range of threads . In yet another embodiment compute shader thread indices are cached to avoid excessive divisions further improving execution speed.

Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.

Embodiments discussed below relate to efficiently optimizing transformed scalar code to execute with improved speed including optimizations that are specific for compute shaders. It is assumed that a compute shader has already been partitioned into maximal size regions called thread loops as described in the above referenced patent application such that the transformed program does not contain barriers performs equivalent computations as the original shader will produce same output as original shader given same input and is suitable for efficient execution by a single CPU thread rather than GPU hardware. It also may be assumed herein that a vectorization pass is done after the scalar optimizations performed herein as described in U.S. patent application Ser. No. 13 398 797 filed Feb. 16 2012 titled VECTORIZATION OF SHADERS .

The scalar optimizations to be described include the following. First an algorithm that based on data flow analysis computes sets of variables that need to be loaded at the beginning of a thread loop iteration and stored upon completion of a thread loop iteration i.e. on every iteration of a thread loop . Second a technique of reducing the size of a thread loop trip for a commonly found case where a piece of compute shader is executed by a single thread or a compiler analyzable range of threads . Third a caching technique is used where compute shader thread indices are pre computed and cached to avoid excessive divisions.

The following terms used herein will be defined as follows. A compute shader thread block is an instance of the compute shader program the Direct X 11 Dispatch call for example typically creates multiple thread blocks. Each thread block has several compute shader threads with private register sets. Threads within a thread block can share data using shared memory which is private to the thread block and use thread barriers for synchronization. A thread loop t loop is a region of compute shader induced by the original synchronization that must be executed by all threads of a thread block before execution may proceed further. Each original variable v is privatized with respect to iterations of a t loop i.e. conceptually a scalar v becomes an array v T where thread t accesses only its own copy v t and where T is the number of threads. A variable v is live at some point P in a program if and only if it has been defined along some path from the entry to P and there is an execution path from P to a use of v along which v is not redefined. A variable is upward exposed UE in a basic block B if it is used in B before any definition in B. A resource may be a texture shader resource view SRV read only unordered access view UAV read and write or shared memory.

At step individual thread loops are analyzed and optimized. For each thread loop being optimized the algorithm computes thread loop helper sets that will be referred to as MayReachTLLoopDef and UE as described below. At step the result of steps and are used. For each t loop Load and Store sets are computed according to the equations below. Finally at step the Load and Store sets are used to generate efficient executable code with unnecessary loads and stores removed from thread loops or reduce the number or loads and stores if the IR code is being interpreted. The Load and Store sets are compiler analysis data used for optimization and are not used in the final executed code. In other words when just in time compiling the Load and Store sets specify exactly which variables of the shader program to load and store i.e. which load store instructions to generate in the machine code and the information they formerly contained is embedded into the code by issuing significantly fewer loads and stores.

As mentioned earlier it will be assumed that a compute shader has already been partitioned into thread loops to respect the original source code synchronization. In a compute shader each scalar variable is private to a thread. Thus all variables must be conceptually replicated for correctness. One approach would be to use an array v T for each original variable v. Then a statement 1 is transformed into

However if original scalar accesses are lowered to array pointer accesses too early in the intermediate representation the later compiler analysis becomes an order of magnitude harder. Instead a set of scalar temporary variables are used to execute one iteration of a t loop here scalar means non array because the variables may be vector variables in a vectorized code . The x y 1 example would then be transformed to 

Using scalar temporaries would yield even more effective results when variables are used and defined many times within a t loop since v t access is more expensive than a scalar access and a compiler can use standard scalar optimization techniques. Load and store of a temporary are implementation specific. For example the temporaries may be indexed into a piece of memory that is not managed by the compiler.

For correct execution the values of scalar temporaries should be captured at the end of each iteration of the current t loop such that the memory state is properly carried forward to the following t loops. This is why the helper variables are called temporary they may be redefined on the next iteration of the t loop. However notice that the state of a temporary should be preserved only if it may be used in a different t loop that follows in execution. Otherwise the corresponding store operation is redundant. Similarly an implementation should load only those variables at the beginning of each iteration of a t loop that may be used or defined to properly merge values on exit by computation inside t loop. Following is an example that illustrates the optimization 

To formalize each t loop is annotated with two sets of temporary variables the Load set represents all variables that need to be loaded at the very beginning of a t loop iteration and the Store set represents all variables that need to be stored at the very end of each iteration. For each t loop TL the sets are computed as follows Store LiveOnExit MayDef Load MayReachTLoopDef LiveOnEntry Store .

The LiveOnEntry TL and LiveOnExit TL sets represent all live variables on entry and exit from the t loop respectively. Note that a t loop is represented by a pair of IR operations OpBeginThreadLoop and OpEndThreadLoop and there is no back edge from OpEndThreadLoop to OpBeginThreadLoop because variables are privatized for each thread. These sets can be computed applying standard liveness analysis on the entire program. MayDef TL is the set of all variables that may be defined during execution of the TL either by a statement nested in t loop or via a call chain. UE TL is the set of variables that are upward exposed with respect to TL. The set is computed as a union of UE sets of all basic blocks nested in TL as well as UE sets of subroutines that may be invoked during execution of the t loop. The MayReachTLoopDef TL set is the set of all variables that may be stored in some t loop and may reach the very beginning of TL. These sets can be computed as the meet over all path fixed point solution using iterative data flow analysis with the following equations Initialize MayReachTLoopDef TLoopEndBB Store where TLoopEndBB is the basic block that correspond to the end of TL for any other basic block B MayReachTLoopDef B and MayReachTLoopDef MayReachTLoopDef 

The first part of the Load set equation takes care of upward exposed variable uses whose values may be reached by definitions of the corresponding variables that are in some t loop s Store set. The second part takes care of properly merging a definition of a variable nested in control flow within t loop at the end of the thread loop.

For a typical compute shader the size of Load and Store sets is only a small fraction of all program variables. Therefore the optimization significantly reduces the overhead associated with the thread loops due to reduction in the number of memory accesses. For real compute shaders orders of magnitude performance improvements have been observed over a na ve implementation.

Alternatively it is possible to compute the Load and Store sets using a single static assignment SSA form however construction of an SSA could increase the time for just in time compiling.

A frequently found pattern in high performance compute shaders is to perform a piece of work which would produce the same result for all threads by a single thread store the results into shared memory synchronize and read the values from shared memory by all threads. This may save a lot of computation especially if the operations executed by a single thread are expensive e.g. divisions or global memory accesses. Here is the pseudo code 

An efficient optimization is to reduce the trip count number of loop iterations of the first t loop to one because all threads but t 0 do nothing. That would eliminate t loop and replace it with linear code representing computation of thread 0. The optimization also reduces t loop load and store overhead for private temporaries for all but the first iterations. Similarly the t loop trip count can be limited to a range assuming the range expressions are analyzable by the compiler.

A compute shader index within a thread block may have up to 3 dimensions tx ty tz let the bounds be Tx Ty Tz . To properly enumerate thread loop iterations it is possible to use a triply nested loop on tz ty and tx but such code is unlikely to be fast due to more complex compiler analysis that would be required. Furthermore the code is likely to be vectorized and if ti W 0 W is vector width there are partially filled vectors which reduce efficiency of computation. The approach to be used is to linearize the thread index t tz Tx Ty ty Tx tx and run a t loop with t 0 T T Tx Ty Tz. This is acceptable for the case when Tz Ty 1 because then tx t. Otherwise the thread index tx ty tz needs to be reconstructed from t 1 1 1

Thread index retrieval is a common operation in compute shaders and having two divisions will likely not be acceptable. To reduce the cost of thread index computation pre compute three arrays atx T aty T and atz T and keep them as part of the shader state. The arrays are used to reconstruct the thread index atx t aty t atz t via array accesses which is less costly. Furthermore the same arrays are used by all thread blocks that execute the shader resulting in a good performance gain.

Embodiments and features discussed above can be realized in the form of information stored in volatile or non volatile computer or device readable storage media. This is deemed to include at least physical storage media such as optical storage e.g. compact disk read only memory CD ROM magnetic media flash read only memory ROM or any means of physically storing digital information excluding carrier waves signals per se and the like . The stored information can be in the form of machine executable instructions e.g. compiled executable binary code source code bytecode or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as random access memory RAM and or virtual memory storing information such as central processing unit CPU instructions during execution of a program carrying out an embodiment as well as non volatile media storing information that allows a program or executable to be loaded and executed. The term media as used herein refers to physical devices and material and does not refer to signals per se carrier waves or any other transient forms of energy per se. The embodiments and features can be performed on any type of computing device including portable devices workstations servers mobile wireless devices and so on.

