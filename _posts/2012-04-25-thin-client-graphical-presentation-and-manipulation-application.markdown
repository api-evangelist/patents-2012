---

title: Thin client graphical presentation and manipulation application
abstract: A distributed graphical presentation and manipulation application executes as a thin client application in a network. The networked graphical presentation and manipulation application can generally be used without requiring a user to install any specific software prior to using the application. In one embodiment, code may be received from a server via the network. A local environment may be generated based on the code, where the local environment may be configured to display a view of a graphical model. A request to manipulate the view may be received within the local environment. A request for a manipulated view may be transmitted to the server based on the received request. The manipulated view may be received from the server. The received manipulated view may be displayed within the local environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08423326&OS=08423326&RS=08423326
owner: The Mathworks, Inc.
number: 08423326
owner_city: Natick
owner_country: US
publication_date: 20120425
---
Graphical presentation and manipulation applications such as for example three dimensional modeling applications are typically provided as stand alone applications that use significant computational resources on the stand alone device to generate and render three dimensional models for presentation and spatial manipulation by users. Unfortunately usability of conventional modeling applications is limited to an installed user base. Moreover providing network or remote access to model data for use in a modeling application may require significant network bandwidth and may result in significant operational latency.

One aspect is directed to a computer readable medium that stores instructions executable by at least one processor to perform a method for presenting and manipulating a graphical model. The computer readable medium may include one or more instructions for receiving code from a server one or more instructions for generating a local environment based on the code where the local environment is configured to display a view of the graphical model one or more instructions for receiving a request to manipulate the view within the local environment one or more instructions for transmitting a request for a manipulated view to the server based on the received request one or more instructions for receiving the manipulated view from the server and one or more instructions for displaying the manipulated view in the local environment.

Another aspect is directed to a device including a processor and a memory coupled to the processor the memory storing instructions that when executed by the processor may cause the processor to receive a view request from a client engine where the view request corresponds to requests for a two dimensional view of a three dimensional model extract the requested view from the three dimensional model and transmit the requested view to the client engine.

Yet another aspect is directed to a method that may include presenting a view in an interactive environment executing on a client entity receiving one or more user actions corresponding to manipulation of the view identifying a view request based on the received user actions transmitting a view request to a server via a network when it is determined that the identified view request is not stored on the client entity predicting likely view requests based on historical view request information and automatically transmitting one or more view requests to the server based on the predicted likely view requests.

Still another aspect is directed to a system including client logic executing within a browser program of a client computing device the client logic including a user interface component to handle displaying of model views on the client computing device and a client engine component to locally handle requests from a user to manipulate spatial positioning of the model view on the client computing device and server logic configured to distribute the client engine to the client computing device when requested through the browser program of the client computing device the server logic including a back end server component configured to extract requested two dimensional views from corresponding three dimensional models and a front end server component configured to provide a web interface to the client computing device and forward the extracted views to the client computing device.

Yet another aspect is directed to a computer readable medium that stores instructions executable by at least one processor to perform a method for presenting a graphical model. The computer readable medium may include one or more instructions for distributing a client engine to a client computing device over a network the client engine implementing an interactive environment associated with a model viewing application and being distributed to the client computing device in response to a request from the client computing device for the model viewing application one or more instructions for receiving a view request from the client engine wherein the view request corresponds to a request for a two dimensional view of a three dimensional model one or more instructions for extracting the requested view from the three dimensional model and one or more instructions for transmitting the requested view to the client engine.

The following detailed description refers to the accompanying drawings. The detailed description does not limit the invention.

Exemplary embodiments described herein relate to a highly efficient and user friendly client server based graphical manipulation application or module. More specifically in one embodiment the client server based graphical manipulation software may include a three dimensional 3D modeling or visualization application. The client server graphical manipulation application may provide many or all of the features provided by a standard graphical manipulation application. The 3D visualization application may provide for efficient distribution and access to a number of users without requiring specialized software tools or applications. Further users may access the 3D visualization application from a variety of potentially remote locations.

A client entity may include an entity such as a personal computer a laptop or notebook computer a mobile or cellular telephone a personal digital assistant PDA or another type of computation or communication device. Users of client entities may access or receive information from server . Client entities may connect to network via wired or wireless connections.

Server may include one or more server entities that may generally interact with client entities such that client entities in conjunction with server execute a graphical presentation and manipulation application. In one embodiment the graphical presentation and manipulation application may operate in conjunction with another application such as a web browser application. Server may include a graphical modeling server component to facilitate operation of the graphical presentation and manipulation application.

As will be described in detail below server may include components configured to generate and render 3D models or visualizations. Each model may in turn be represented by numerous two dimensional 2D views depending on a desired viewing angle zoom level and displayed content.

In accordance with embodiments described herein 3D models or visualizations and their corresponding 2D views as generated or rendered by server may be based on various types of data and information. For example the 3D models may be based on data such as engineering data medical data scientific data weather data mathematical data and data from other disciplines. More specifically the models may correspond to a variety of different types of data or events including but not limited to physical objects or structures fluid flow biological systems weather patterns seismic events multi body interactions chemical processes outputs from systems or devices e.g. power curves for an engine numerical algorithms signal processing data etc.

In accordance with embodiments described herein server may transmit the 2D views to client entities in response to user requests received at client entities . The transmitted views may be cached or otherwise stored by client entities . Additionally server may transmit software or instructions to client entities to assist in enhancing a user experience for the graphical presentation and manipulation application. Although illustrated as a single device in server may be implemented as for example a single computing device or as multiple distributed computing devices. The relationship of client entity and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other. One will recognize that a device s role as either a client entity or a server device may depend on the specific application being implemented. In one exemplary embodiment client entity may access server as part of a managed service that may be offered on a subscription basis.

As mentioned above the interaction of client entities with server may be accomplished through a browser program or a similar application being executed at client entities . For example the graphical presentation and manipulation application may be a web application that runs within browsers . In this manner client entities may not be required to install any graphical presentation and manipulation specific software e.g. a dedicated data viewing application to view and manipulate a graphical e.g. 3D image at client entity . Browser programs are well known and are widely available in the art. When browsers or browser programs are discussed herein these terms are intended to refer to any program that allows a user to browse markup documents e.g. web documents regardless of whether the browser program is a stand alone program or an embedded program such as a browser program included as part of an operating system.

Processor may include any type of processor microprocessor or processing logic that interprets and executes instructions. Main memory may include a random access memory RAM or another type of dynamic storage device that may store information and instructions for execution by processor . ROM may include a ROM device or another type of static storage device that may store static information and instructions for use by processor . Storage device may include a magnetic and or optical recording medium and its corresponding drive.

Input device may include a mechanism that permits a user to input information to computing device such as a keyboard a mouse a trackball a track pad a touch sensitive display a pen voice recognition and or biometric mechanisms an accelerometer or gyroscope based motion input device a camera etc. Output device may include a mechanism that outputs information to the user including a display a printer a speaker etc. Communication interface may include any transceiver like mechanism that enables computing device to communicate with other devices and or systems. For example communication interface may include mechanisms for communicating with another device or system via a network such as network .

Graphical modeling server component may be implemented in software and stored in a computer readable medium accessible to server such as memory . Similarly browser may be implemented in a computer readable medium accessible to client entity . A computer readable medium may be defined as one or more physical or logical memory devices and or carrier waves.

The software instructions defining graphical modeling server component may be read into memory from another computer readable medium such as data storage device or from another device via communication interface . The software instructions contained in memory may cause processor to perform processes that will be described later. Alternatively hardwired circuitry may be used in place of or in combination with software instructions to implement processes consistent with exemplary embodiments described herein. Thus the embodiments described herein are not limited to any specific combination of hardware circuitry and software.

A graphical presentation and manipulation application as described herein may be implemented as a distributed web application in which portions of the application execute at one or more of client entities and at server . More specifically client entities that wish to use the graphical presentation and manipulation application may request the graphical presentation and manipulation application from server . In response server may transmit portions of the graphical presentation and manipulation application for local execution at client entities . The graphical presentation and manipulation application may thus execute as a distributed application across server and one or more of client entities .

Portions of the graphical presentation and manipulation application may also execute within client entities . For example within browser graphical presentation and manipulation application may be conceptualized as including a client engine and a user interface . Client engine may be implemented using for example JavaScript that is downloaded from server when needed by client entity . User interface may provide the user interface that is displayed in browser based on for example HTML hyper text markup language and CSS cascading style sheets data supplied from client engine .

User interface and client engine together act to improve speed and performance of traditional browser based web applications. In one embodiment client engine may add a client side layer that can handle many of the user interactions with user interface . Instead of loading a web page at the start of a user session browser may load client engine from server or alternatively from a local cache . Client engine may then be responsible for rendering the interface the user sees performing calculations or other processing based on user information and interactions and communicating with server on the user s behalf. Client engine may allow the user s interaction with the graphical presentation and manipulation application to happen asynchronously i.e. independent of communication with server .

In one embodiment the client side operation of the graphical presentation and manipulation application may be implemented using known Asynchronous JavaScript and XML AJAX web development techniques although other technologies could be used.

Although shows an exemplary modeling server component and client entity in other embodiments modeling server component and client entity may include fewer different or additional components than depicted in . Moreover one or more components of modeling server component and client entity may perform one or more functions of one or more other components of graphical presentation and manipulation application architecture.

In response to the user initiating a session client may receive client engine from graphical modeling server component block . In the AJAX embodiment briefly described above client engine may be based on several different technologies such as dynamic hypertext markup language DHTML extensible markup language XML Java JavaScript Flash etc. Regardless of the underlying technology used to form client engine it should be understood that client engine may provide a dynamic and asynchronous display interface between client entity and front end component .

Some portions of client engine may be cached at client entity from a previous session in which case these portions may not need to be re downloaded from server . In some embodiments the programming code that makes up client engine may be implemented in a modular manner. In this situation portions of client engine may be transmitted to client on an as demand basis as the functionality of those portions of client engine are needed by client . For example client engine may implement a number of core functions such as basic user interaction and display functions that are always transmitted to client . Examples of core functions may include user interface element display e.g. buttons backgrounds effects etc. . Other functions such as the display of specific graphical model views may be transmitted to client entity upon request.

Because client engine can be transmitted to client entity as needed by client entity the graphical presentation and manipulation application may be an entirely web based application in which client entity does not need to pre install any portion of client engine other than the portion included within browser . In some embodiments additional software such as a Java Virtual Machine JVM may be used in conjunction with browser to execute client engine . Advantageously a user may typically be able to use the graphical presentation and manipulation application from virtually any computing device that includes a compatible browser and that is connected to network .

Client engine once loaded at client entity may present via user interface an interactive environment for presenting and manipulating a 3D model block . This interactive environment is the data object that the graphical presentation and manipulation application presents to the user in browser . In one embodiment users may interface with the interactive environment to retrieve view and manipulate views of a 3D model.

In one embodiment consistent with exemplary embodiments described herein control elements may include direction buttons and manipulation mode buttons . Exemplary direction buttons may include a left button a right button an up button a down button while exemplary manipulation mode buttons may include a rotate mode button a zoom mode button and a pan mode button . Details regarding the effect of selection of any of control elements will be described in additional detail below.

Returning to client engine may receive a selection from one of user control elements block . As noted above control element options include direction buttons rotate mode button zoom mode button and pan mode button . In particular receipt of a selection corresponding to any one of direction buttons may indicate that the user wishes to view the displayed model in a same plane but shifted by a predetermined amount either up down left or right with respect to the current view . Selection of one of control elements may be performed in any suitable manner such as clicking with a mouse or selecting via keyboard or other input device e.g. touchscreen pen etc. . In one embodiment the image shift may be on the order of 10 degrees rotation 16 pixels translation or scaling to a factor of 5 of the total image dimensions.

In response to the selection of one of direction buttons client engine may determine whether a view corresponding to the selected view has been previously cached on client entity e.g. in one or memories or block . As will be described in additional detail below the frequency and content of model views that may be cached or stored on client entity may be based on several factors including but not limited to previous viewings predicted viewings and a speed of network .

When it is determined that a view corresponding to the selected shifted view has been previously cached on client entity the cached view may be retrieved into environment and displayed in browser block . However when it is determined that a view corresponding to the selected view has not been previously cached on client entity client engine may request the selected view from front end component on server block .

In one embodiment consistent with exemplary embodiments described herein front end component upon receipt of a view request from client entity may initially determine whether a view corresponding to the selected view is cached within front end component block . If so front end component may transmit the selected view to client engine block . Processing may then continue to block described above where the received view may be displayed in environment . However if a view corresponding to the selected view is not cached within front end component front end component may request the view from back end component block .

In one exemplary embodiment client engine may perform processing or enhancement on the received view prior to display in interactive environment . For example client engine may perform interpolation image smoothing etc. to improve an appearance of the received view. The processing may be based on user input or remote inputs e.g. from a network device . More specifically it may be determined that available bandwidth is less than optimal. In this event image processing enhancement operations may be performed to avoid having to request additional or higher resolution images from server . In one embodiment the image processing enhancement may be performed on an additional network device. Alternatively the image processing enhancement may be shared with another client entity .

Back end component may extract a 2D view corresponding to the selected view from the 3D model block and may transfer the extracted 2D view to the front end component for relay to client engine block . The process may continue to block where the selected 2D view may be transmitted from front end component to client engine . Optionally the extracted 2D view may be cached at front end component to enhance responsiveness of server in responding to subsequent requests for the selected view from this or another client entity .

Returning to block client engine may receive a user selection of rotate mode button . Upon receipt of a selection of rotate mode button client engine may place interactive environment into a rotation mode block . In one exemplary embodiment interactive environment s rotation mode may provide for virtual manipulation of the displayed model in response to user input such as mouse movements keyboard input or other suitable input device. For example upon entry into rotation mode users may click and drag on the model view to indicate the degree and extent to which they wish to rotate the model about either a horizontal axis or a vertical axis. In one embodiment each pixel of mouse movement may correspond to approximately 0.5 degrees of rotation.

In accordance with the exemplary embodiments described herein responsiveness of graphical presentation and manipulation application may be substantially enhanced by providing for the asynchronous retrieval and display of 2D model views rather than an entire 3D visualization of the model. More specifically upon receiving a user request to view a selected 3D model at front end component back end component may generate or open the selected model. Front end component may then extract or retrieve a 2D view representing the selected view and relay or transmit the 2D view to client entity .

In one exemplary embodiment the 2D views may take the form of compressed image files such as gif jpeg bmp or png files although any suitable graphic format may be used. In addition to compressed image formats various other image formats such as vector graphics formats e.g. VML SVG etc. may be used in accordance with the embodiments described herein.

In one embodiment each 2D view may include multiple related image files such that portions of the 2D view may be received and displayed prior to other portions of the 2D view. Additionally each 2D view received from front end component may include data sufficient to enable client engine to reconstruct an entirety of the selected 2D view. Alternatively view data transmitted from server to client may include only changed view data thereby reducing bandwidth requirements necessary to display the desired 2D view.

In relation to block described above retrieval of the selected shifted view from front end component on server may include retrieval of additional ones of the multiple related image files associated with the selected shifted view. For example upon selection of left button client engine may determine whether multiple image files associated with a left shifted view of the model e.g. shifted by approximately 1 inch or 120 pixels have been cached and if not client engine may request the multiple image files associated with a left shifted view of the model from front end component .

Returning to upon entry into rotation mode client engine may receive or observe input from input device corresponding to a user s desired rotation of the displayed view block . In response to the observed input client engine may provide a visual object representing observed movement of input device corresponding to a desired change in rotation angle s about a horizontal axis a vertical axis or a combination of both the horizontal and vertical axes block . In one embodiment the visual object may include a virtual 3D object such as a cube or other polygon shape overlaid over the previously viewed 2D visualization.

Returning to client engine may receive a selection of a desired view for display block . In one embodiment receiving a selection of a desired display view may correspond to a rotated view of the visual object such as visual object . In this embodiment a cessation of movement or a click release of input device may signify that the user has settled on or otherwise selected a view corresponding to the current position of the visual object. In an alternative embodiment observation of a desired view selection may correspond to user input such as a specific angle or angles of view.

Once a selected view has been received client engine may proceed to block described above where it is determined whether a view or discrete portions or elements of a view corresponding to the selected view has been previously cached on client entity . As described briefly above the frequency and content of model views or view elements that may be cached or stored on client entity may be based on several factors including but not limited to previous viewings predicted viewings and speed or latency of network .

Returning to block client engine may receive a user selection of zoom mode button . Upon receipt of a selection of zoom mode button client engine may place interactive environment into a zoom mode block . In one exemplary embodiment interactive environment s zoom mode may provide for rapid scaling of a displayed view in response to user input such as mouse movements keyboard input or other suitable input device. For example upon entry into zoom mode users may click and drag on the model view to indicate the degree and extent to which they wish to zoom in or out of the currently presented view. In one exemplary embodiment a left click may correspond to a zoom in command while a right click may correspond to a zoom out command. Alternatively keyboard input may control the zoom feature. In still another embodiment input from a mouse scroll wheel may be used to control the zoom feature. In one embodiment each click of the input device or each click in the scroll wheel may corresponding to a 2 change in magnification of the presented view.

Returning to upon entry into zoom mode client engine may receive or observe input from input device corresponding to a user s desired zoom level and view center point block . In response to the observed input client engine may initially determine whether a view corresponding to the selected zoom and center point level has been previously cached at client entity block . If so the cached view is retrieved block and displayed in interactive environment block .

If a cached view corresponding to the selected zoom level and center point has not been previously stored client engine may scale e.g. pixel scale at least a portion of the image or images currently being presented to correspond to the desired zoom level block . Although rapid scaling of the previously presented view image or images may result in a less than optimal viewing experience it may present users with a substantially instantaneous representation of the selected zoom level. Substantially simultaneously client engine may request an optimal or full resolution view corresponding to the selected zoom level and center point from front end component block . The process may then proceed to block described above for retrieval of a corresponding view from server .

Following retrieval of a full resolution view image or images corresponding to the selected zoom level and center point view of may be presented within interactive environment. Unlike view the 200 150 pixel resolution of view is not a scaled resolution.

Returning to block client engine may receive a user selection of pan mode button . Upon receipt of a selection of pan mode button client engine may place interactive environment into a pan mode block . In one exemplary embodiment interactive environment s pan mode may provide for repositioning of view in response to user input such as mouse movements keyboard input or other suitable input. For example upon entry into zoom mode users may click and drag on view to reposition view within interactive environment . In some instances such movement may cause portions of view not previously visible within environment to become visible within environment .

As described above in one embodiment each displayed view may include of a number of sub images. is a diagram illustrating one embodiment of environment for displaying a view made up of a number of sub images . To assist in facilitating an understanding of this concept each sub image boundary is designated by a dashed line in . It should be understood that this dashed line is for explanatory purposes only and that the portion of view provided on each sub image would typically flow seamlessly into neighboring sub images . To respond to user view requests as efficiently as possible client engine may request only those view sub images corresponding to the portion of view visible within environment . Consequently view sub images outside of environment may not be initially retrieved at the time of view display or rendering. For example following a zoom request view sub images corresponding to only a central portion of view may be retrieved from server .

Client engine may receive a pan request based on input from input device block . Client engine may initially determine whether view or view sub images corresponding to the selected view have been previously cached on client entity e.g. in one of memories or block . As will be described in additional detail below the frequency and content of model views or view sub images that may be cached or stored on client entity may be based on several factors including but not limited to previous viewings predicted viewings processing capabilities of client entity and speed of network .

When it is determined that view sub images corresponding to the newly visible sub images in shifted view have been previously cached on client entity the cached sub images may be retrieved into environment block and displayed in browser block . However when it is determined that a shifted view or view sub images corresponding to the selected shifted view have not been previously cached on client entity client engine may request the selected view sub images from server in the manner described in detail above block . Processing may then proceed to block described above for retrieval of a corresponding view from server . It should be noted that in instances where entire views are retrieved from server rather than view sub images determination of cached view data may be unnecessary since entire view is available to client engine regardless of the portion of view displayed in environment at any specific time.

In addition to requesting specific user requested views from server client engine may also predict likely future view requests block and may preemptively request view images corresponding to the predicted view requests from server prior to receiving requests for these views from the user block .

In one exemplary embodiment described herein client engine may predict likely future view requests based on the user s historical viewing behaviors. For example a user of client entity or graphical presentation and manipulation application may typically request a 30 isometric view and a plan view for opened models. This determination may be made based on an analysis of previous model view requests. In this example based upon the user s historical preferences client engine may identify these preferences and may preemptively request and receive views corresponding to the historically requested views such that subsequent user requests will be addressed more quickly and efficiently.

Consistent with the embodiments described herein predicted view requests may be based at least in part on a type of model or underlying data being analyzed or displayed. For example a displayed model view corresponding to an aerodynamic structure may result in different predicted view requests than a model view corresponding to flow characteristics of a water treatment facility. In one implementation client engine may predict future likely view requests based on the type of model being displayed.

Alternatively view request predictions may be made based on a database or collection of historical view requests either collectively across a number of models or specifically for each available model. In this embodiment a larger corpus of data may be used to identify trends and to assist in predicting possible view requests for a selected model.

In yet another exemplary embodiment view request predictions may be made based at least in part on stored mappings of input device e.g. mouse movements. For example it may be determined that observing a mouse movement in a vertical direction towards a top portion of a displayed view while in the rotation mode may be a precursor of a user request for a down rotated view. Similarly it may be determined that observing a mouse movement in a horizontal direction towards a right hand portion of a displayed view while in the rotation mode may be a precursor of a user request for a clockwise rotated view. Using stored mappings reflective of these preferences client engine may preemptively request one or more views corresponding to the predicted view requests. As described above with respect to historical view requests input device movement mappings may be maintained locally with respect to a given user or may be based on prior input device movements relating to a number of system users. In a collective example the input device movement mappings may be initially maintained on server and may be transmitted to client engine upon execution of the graphical presentation and manipulation application.

In an ideal environment the graphical presentation and manipulation application may be executed by an adequately powered client entity on a high speed high reliability network . Such an environment may provide large amounts of network bandwidth and client entity processing capabilities. In this environment client engine may identify request and receive a number of preemptive view images thereby minimizing the time taken to display a larger number of possible views.

However in some instances network may have lower than optimal bandwidth and or client entity may have lower than optimal processing capabilities. In these circumstances client engine may be limited in the amount of processing it may preemptively perform or the number of view images it may preemptively request and receive. For example client entity may lack sufficient processing capabilities to simultaneously predict likely view requests based on both input device mappings and historical usage patterns.

In one exemplary embodiment client engine may be configured to adaptively identify view images likely to be requested based on available processing capabilities. For example if a processor associated with client entity is operating at greater than 90 capacity view prediction by client engine may be suspended. Alternatively view prediction by client engine may be restricted to only a single criteria such as local historical viewing patterns.

Alternatively client engine may monitor bandwidth and or latency of network . Based on the monitored bandwidth and or latency client engine may limit or modify a number or frequency of preemptive view image requests. In this manner client engine may be adaptively configured to provide an optimal user experience based on the available computing environment.

In another exemplary embodiment described herein front end component may be configured to perform similar predictive processing as client engine . In this embodiment client engine may periodically transmit client side information such as input device movement mappings and historical view request information to front end component . Front end component may then identify or predict likely view requests in a manner similar to client engine . Front end component may then retrieve or request view images corresponding to the likely view requests from back end component in advance of request receipt from client engine . By providing prediction at both the client and server sides a user experience may be most completely optimized.

The above described functions and operations that are performed by the graphical presentation and manipulation application are exemplary. Through interactive environment the graphical presentation and manipulation application may permit a user to perform numerous additional operations such as modification of model attributes e.g. color texture etc. saving or exporting of model views etc.

In one embodiment client engine may handle most or all of the functionality associated with responding to user actions relating to navigating and or presenting environment without needing to contact server . Other functions of the graphical presentation and manipulation application such as the rendering or extraction of two dimensional views from three dimensional models may be handled by logic in server . By handling formatting and user actions locally at client entity the graphical presentation and manipulation application can provide a high level of responsiveness to user actions that tend to occur frequently and for which users expect immediate feedback.

In alternative embodiments the division of functions executed at client engine front end component and back end component may be modified such that client engine handles more or fewer functions and similarly front end component and back end component may also handle more or fewer functions. In one exemplary embodiment a client entity having reduced memory and or processing capabilities may be connected to an additional network device capable of sharing memory and or processing resources with client . Such a network device may be operatively connected to client device via a LAN or other network environment. In an extension of this embodiment client entity may use a memory on the network device to cache or maintain previously received or predictively received views from server .

In another exemplary embodiment server may be configured as a technical computing environment TCE that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal etc.

In one embodiment the server based TCE may include a dynamically typed language that can be used to express problems and or solutions in mathematical notations familiar to those of skill in the relevant arts. For example the server based TCE may use an array as a basic element where the array may not require dimensioning. In addition the server TCE may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development etc. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and design state based analysis and design etc.

The server based TCE may further provide mathematical functions and or graphical tools e.g. for creating plots surfaces images volumetric representations etc. . In one embodiment the server based TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting distributed processing etc. . In another embodiment the server based TCE may provide these functions as block sets. In still another embodiment the server based TCE may provide these functions in another way such as via a library etc. The server based TCE may be implemented as a text based environment a graphically based environment or another type of environment such as a hybrid environment that is both text and graphically based.

In another alternative embodiment the server based TCE may be implemented using one or more text based products. For example a text based the server based TCE may be implemented using products such as but not limited to MATLAB by The MathWorks Inc. Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence or Modelica or Dymola from Dynasim. The text based TCE may support one or more commands that support code generation constraints generation constraints checking etc.

In another alternative embodiment the server based TCE may be implemented as a graphically based TCE using products such as but not limited to Simulink Stateflow SimEvents etc. by The MathWorks Inc. VisSim by Visual Solutions LabView by National Instruments Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent System VIEW from Elanix Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhapsody or Tau from Telelogic or aspects of a Unified Modeling Language UML or SysML environment. The graphically based TCE may support code generation constraints generation constraints checking etc.

In another alternative embodiment a language that is compatible with a product that includes a server based TCE such as one or more of the above identified text based or graphically based TCE s may be used. For example MATLAB a text based TCE may use a first command to represent an array of data and a second command to transpose the array. Another TCE may be MATLAB compatible and may be able to use the array command the array transpose command or other MATLAB commands. For example the language may use the MATLAB commands to perform distributed processing.

In another alternative embodiment the server based TCE may be implemented in a hybrid TCE that combines features of a text based and graphically based TCE. In one embodiment one TCE may operate on top of the other TCE. For example a text based TCE e.g. MATLAB may operate as a foundation and a graphically based TCE e.g. Simulink may operate on top of MATLAB and may take advantage of text based features e.g. commands to provide a user with a graphical user interface and graphical outputs e.g. graphical displays for data dashboards to monitor commands and status etc. 

A client server based graphical presentation and manipulation application is described herein that executes in a distributed manner over a network. The networked graphical presentation and manipulation application can generally be used without requiring a user to install any specific software prior to using the application.

The foregoing description of exemplary embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. For example in some embodiments server may provide one or more application programming interfaces APIs that allow different content providers to integrate elements of the graphical presentation and manipulation application into their thin client applications or web sites.

Moreover while series of acts have been described with regard to and the order of the acts may be varied in other embodiments consistent with the invention. Moreover non dependent acts may be implemented in parallel.

Aspects of the invention as described above may be implemented in many different forms of software firmware and hardware in the exemplary embodiments illustrated in the figures. The actual software code or specialized control hardware used to implement aspects consistent with the exemplary embodiments is not limiting of the invention. Thus the operation and behavior of the exemplary embodiments of the invention were described without reference to the specific software code it being understood that one would be able to design software and control hardware to implement the described embodiments based on the description herein.

Further certain portions of the invention may be implemented as logic or a component that performs one or more functions. This logic may include hardware such as an application specific integrated circuit or a field programmable gate array software or a combination of hardware and software.

No element block or instruction used in the description of the invention should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

