---

title: Provisioning managed devices with states of arbitrary type
abstract: Described is a technology by which a target machine (managed device) is provisioned with arbitrary states for subsequent communication with a central authority, in which the configuration provisioning of the device is decoupled from the collection of the provisioning data. In a provisioning phase, arbitrary state information for provisioning the managed device is obtained and packaged in a container. In a configuration phase, the container is accessed, and the arbitrary state information is unpackaged to apply state to the managed device. The target machine thus may be provisioned with arbitrary states without actively communicating with the central authority.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047442&OS=09047442&RS=09047442
owner: Microsoft Technology Licensing, LLC
number: 09047442
owner_city: Redmond
owner_country: US
publication_date: 20120618
---
Contemporary enterprises have many managed devices e.g. computing machines. Each such device needs to be securely provisioned with various data and the like e.g. a trust relationship policy settings and certificates referred to as state information or simply states so that the device can join with and be securely managed from a centralized authority. For example if the centralized authority is a domain controller e.g. based upon Active Directory a managed device needs the appropriate states to join and be part of the domain.

Securely establishing states of arbitrary type between a managed device and a centralized authority heretofore depended on secure network connectivity between the managed device and the central authority at the time such states are established e.g. the device needed to be coupled directly to the private enterprise network corresponding to the central authority. Further the managed device needed to be running booted .

This causes problems in part because securely establishing states of arbitrary type for large sets of managed devices generates a heavy load on the centralized authority. Further securely establishing such states is also prone to failures due to transient network states.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards a technology by which a target machine managed device is provisioned for subsequent communication with a central authority. Upon receiving a provisioning request provisioning data related to the provisioning of the target machine is obtained in which the provisioning data contains arbitrary state such as trust relationship related data certificate related data and policy related data. The provisioning data is packaged into a container that is accessible for configuring the target machine without additional communication with the central authority.

Further described is accessing the container unpacking the provisioning data to obtain configuration data and applying the configuration data to the target machine. The accessing of the container unpacking of the provisioning data to obtain configuration data and applying of the configuration data may be independent of the provisioning of the data that is the target machine may be provisioned without actively communicating with the central authority.

In one aspect a configuration framework is coupled to a managed device. The configuration framework is configured to process provisioning data contained in a container including to invoke one or more configuration services. The one or more configuration services write state information corresponding to a plurality of states to a device storage of the managed device including when the managed device is not actively communicating with a central authority to provision the device for subsequent communication with the central authority.

In one aspect a provisioning phase and an independent configuration phase are provided in which a managed device need not be actively communicating with a central authority. In the provisioning phase arbitrary state information for provisioning the managed device for subsequent communication with the central authority is obtained and packaged in a container. In the configuration phase the container is accessed and the arbitrary state information is unpackaged to apply state to the managed device to provision the managed device for subsequent communication with the central authority.

Other advantages may become apparent from the following detailed description when taken in conjunction with the drawings.

Various aspects of the technology described herein are generally directed towards decoupling the establishment of states of arbitrary type e.g. a trust relationship policy or certificates between a managed device and a centralized authority from the application of those states to the managed device. In general the technology allows a proxy to play the role of a managed device in state creation and captures the resulting states in a container for storage and transportation. The subsequent application of the states to the managed device uses the container any may occur in a manner that does not involve the centralized authority. Once provisioned with the appropriate states which need not occur inside the corporate network the managed device may securely couple to the central authority through any suitable network including a public network.

Note that U.S. published patent application no. 20110107401 assigned to the assignee of the present invention and hereby incorporated by reference is directed towards decoupling the process of establishing a trust relationship between a managed device and a central authority from the application of that state to the managed device. In general a proxy plays the role of a managed device in state creation with the state subsequently applied to the managed device in a manner that does not involve the centralized authority. While such decoupling is extremely useful this technology only applies to trust relationship states e.g. credentials to join the domain and still needs direct connection of the managed device with the central authority via the central authority s private network before any further interaction between the managed device and the central authority can occur.

In contrast as will be understood managed devices may be provisioned with states of arbitrary type e.g. certificates and policy settings such as Windows registry keys not just trust relationship states as described herein in a decoupled manner without needing to be coupled to the central authority via the private network. By allowing for states of arbitrary type managed devices may be configured to securely connect to the central authority over a public network thereby removing the need for any direct connection between the managed device and the central authority on the central authority s private network. Moreover the provisioning of large sets of managed devices is enhanced through the isolation of common failure conditions and increased granularity of operations inherent in the phased approach described herein.

To this end an extensible framework is provided for the secure establishment capture and aggregation of states of arbitrary type between a managed device and a centralized authority using a proxy on behalf and instead of the managed device. An extensible versioned container is used for the storage and transportation of one or many elements such as managed device state metadata of arbitrary types. Container characteristics may allow for encryption and compression of the contents.

The extensible framework provides for the secure consumption of containers and the installation of the constituent container elements in a manner that does not involve a centralized authority. System e.g. framework components may be delivered as container elements including for just in time installation on managed devices. Reusable managed device state templates also may be used. Compilation and maintenance of container installation records on managed devices for the purposes of tracking and deinstallation is also facilitated.

It should be understood that any of the examples herein are non limiting. As such the present invention is not limited to any particular embodiments aspects concepts structures functionalities or examples described herein. Rather any of the embodiments aspects concepts structures functionalities or examples described herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing networking and device provisioning in general.

In as part of a provisioning phase a managed device provisioning component such as a provisioning application uses a managed device provisioning framework to facilitate the provisioning of states. In general the managed device provisioning framework provides the application with an abstract view via a suitable application programming interface API set represented by the dashed line of various underlying provisioning services which are each coupled to a central authority . An SPI Service Provider Interface is similarly represented by a dashed line between the frameworks service providers to denote provider plugability. Note that the central authority may be a domain controller or the like such as a certificate authority and may comprise a single physical or virtual machine a plurality of clustered machines e.g. with a quorum mechanism a set of distributed machines and so forth.

In one implementation the provisioning phase begins with a request from the provisioning application specifying a set of desired managed device states along with information pertinent to each state. A typical example request to provision a managed device such that it may securely connect to the central authority using a public network includes the establishment of three states namely a trust relationship state a device certificate and root certificates state and a device policy state. Other states that may be provisioned include but are not limited to an XML file and a logon script for example.

Example parameters for domain join may include credentials target domain target machine name. For certificates target certificate template names may be specified for policy states group policy may be specified. These parameters are validated to ensure they are appropriate.

For each state requested the provisioning framework invokes a corresponding one of the provisioning services e.g. a provisioning service may handle domain join provisioning functionality a provisioning service may handle certificate provisioning functionality and so on . In turn the service establishes the state with the central authority e.g. using an authenticated and encrypted protocol which may be a network protocol such as LDAP using states e.g. a trust relationship established by preceding services if needed and returns metadata representing the new state to the provisioning framework . Note that the central authority may be provided with target machine managed device related data such that the provisioning service impersonates an actual device so that for example the central authority need not be modified from how it currently works with actual managed devices.

By way of example the service provider for handling domain join communicates with a domain controller to set up a new machine account get credentials which may be existing user credentials on the domain and so forth. The provisioning framework then copies this state metadata SMD1 returned by the invoked services to a container e.g. the data may be serialized. Each other desired provisioning service is similarly invoked with the returned metadata from each packaged in a format suitable for storage and transport and returned to the requesting higher layer application . For example the certificate service provider creates a certificate template based upon a certificate name and communicates with one or more certificate authorities as appropriate to obtain a machine certificate for the given machine to be provisioned as well as copy root certificates from its local machine on which the provider runs and returns this to the provisioning framework . The policy provider resolves the names of policies into GUIDs obtains the corresponding data e.g. as system database configuration settings and returns this to the provisioning framework . The provisioning framework processes e.g. serializes each set of data into the container described below for returning to the provisioning application .

Decoupled from the provisioning of the states is device configuration based upon the provisioned data e.g. via a device configuration phase. As described herein a device configuration application receives the container which may comprise a container set comprising one or more separate and or combined containers from the provisioning application at any appropriate time and uses the information in the container to provision the managed device e.g. write information into the device storage system state . To this end a managed device configuration framework provides the device configuration application with an abstract view via a suitable API set represented by the dashed line of various underlying configuration services which are each associated with e.g. coupled to or possibly incorporated into the managed device . Note that the container may be accessed by the device configuration application via a website emailed or copied to a USB memory device and physically transported to a machine that runs the device configuration application and so forth. Further note that the container can contain a configuration service so that it can be used as needed and or a link to a configuration service if there is an online connection to such a service .

A high level application such as the device configuration application determines when and where to access the target device s persisted system state . To configure the states on the managed device the device configuration application submits the location of the device s storage system state and the container to the managed device configuration framework . The device configuration framework extracts each state metadata element from the container and invokes a corresponding one of the configuration services e.g. as identified by a GUID in a metadata element in the container corresponding to each provisioning service. For example the identifier may be that of the provisioning service that provided the data by which the corresponding configuration service is known and or the configuration service that is to be used to unpack and apply the data. Each invoked configuration service in turn applies the information contained in the state metadata to the device s persisted system state . Note that the managed device need not be on or in a running state provided that its storage system state is accessible to the framework configuration services .

At this point the various provisioning states have been established and configured on the device. Applications may use managed device provisioning frameworks to provision and configure arbitrary states singularly in batches or in large sets.

At step corresponding to the labeled arrow in the provisioning framework performs initial validation of the request parameters that the provisioning framework knows how to validate the selected provisioning services know how to validate other parameters . Via steps and the provisioning framework invokes each of the underlying provisioning services in turn beginning with a first provisioning server e.g. provisioning service . Note that not every service need be invoked for a given provisioning operation.

Step represents the selected provisioning service validating parameters that it knows how to validate. As represented by step of and arrow of the selected provisioning service interacts with the central authority to the extent needed to satisfy its portion of the application s request. Step represents the selecting provisioning service capturing any state metadata SMD1 representing the established device state that is to be provisioned. Step represents packaging the metadata in a format that is suitable for transport e.g. serializing the metadata and step returns the packaged data to the provisioning framework where it is received at step of this is also represented by the arrow labeled in .

Steps and repeat the process for each other provisioning service to be invoked until none remain. This is also represented in via the dashed arrows alongside arrows and that is the operations represented by arrows through in for the first selected service e.g. may be repeated for any other selected provisioning services . Note that some or all of such steps may be performed in parallel e.g. by invoking the selected provisioning services in parallel.

Step of represents the provisioning framework copying the data returned by each of the invoked provisioning services into a container which is then packaged in a format suitable for storage and transport. The container is returned to the provisioning application to respond to the request as represented by step of and arrow in .

At this time the provisioning phase is complete in this example with the provisioned states contained in the container. Step of the arrow of represents the resulting container being transported to the managed device. Note that this is an optional step at this time as transport may be deferred until any appropriate time. Note further that one or more intermediaries may be involved e.g. the container may be stored in a location that is accessible to the managed device.

Turning to the decoupled device configuration phase represented by and arrows through in at an appropriate desired configuration time the device configuration application submits a request to the configuration framework specifying parameters such as the container which holds the provisioning data. The request and receipt of the request at step of is also represented by the arrow labeled in .

At step the configuration framework performs initial validation of the request parameters and unpackages the container. Via steps and the configuration framework iterates through the elements 1 X in the container invoking a configuration service corresponding to the type of each element. The first such element selected invocation is represented via arrow in with dashed arrows representing subsequent service invocations .

For each invoked service the configuration service corresponding to the type of the first container element unpackages e.g. deserializes the element at step of . Step represents applying corresponding data e.g. managed device state to the device storage system state of the managed device which is also represented via arrow in . As represented via the arrow labeled in the configuration service corresponding to the type of the selected container element returns step the status of the application to the configuration framework where it is received as represented via step of via steps.

As is understood the steps corresponding to arrows through of are repeated via steps and of for any other container elements 2 X . Some or all of such operations may be performed in parallel.

When the invoked configuration services have completed their operations a final comprehensive status is returned from the configuration framework to the device configuration application as represented via step of and arrow in . Assuming there were no fatal errors or the like the device is now provisioned for subsequent e.g. at any time in the future communication with the central authority including with sufficient state information to securely connect to the central authority over a public network.

It should be noted that containers for provisioning configuring a machine a first time on a domain are not reusable once used by the machine because only one machine may use the machine specific information in the container to join a domain. However other containers that contain information that is not machine specific such as root certificate authority certificates and policy may be used by multiple machines. For example some packages may have a common set of parts e.g. a policy part whereby the creation and use of a package as a template for other packages may promote performance gains and the like. A template package may be passed in as a parameter during package creation for example whereby the provisioning framework may manage the part duplication and addition to the new package.

Turning to aspects related to the containers the data may be arranged as blobs and sub blobs e.g. via a RPC remote procedure call NDR Network Data Representation facility for data serialization for transport and deserialization for consumption . This allows compression and or encryption as desired.

On the consumption side assuming no consumer version range enforcement exists a V1 consumer is able to deserialize OP STRUCT and know that one or more extensions are included. A V2 consumer is able to deserialize OP STRUCT and OP STRUCT V2 EXT and know that one or more extensions are included. V3 and later consumers are able to deserialize OP STRUCT OP STRUCT V2 EXT and OP STRUCT V3 EXT and know that no other extensions are included.

The container arranged with package parts supports the encryption and decryption of the package part collection. A framework similar to that of the above described package part service providers may be used e.g. encryption decryption implementations can be plugged in and exposed programmatically via a GUID and structure based parameter sets.

For example when a request for a new provisioning package is made a type of encryption to be used may be specified. The request may contain additional encryption parameters e.g. a public key or these may be generated dynamically based upon the request context e.g. an RMS policy generated by the package author . The package part collection is encrypted and any resulting encryption context e.g. an RMS policy is stored in the package in the clear. Serialization of the package is completed and the serialized package is returned to the author.

After the package is delivered via any suitable means to the target consumer the consumer requests installation of the package which may optionally specify a callback routine . If package encryption is detected the callback routine is invoked and passed the encryption type and encryption context allowing for the consumer to compose a set of decryption parameters e.g. a private key a Windows Live ID and the like as needed. The encryption type encryption context if any and decryption parameters if any are used in combination to decrypt the package part collection. Deserialization of the package parts follows such that the package installation request completes and any decryption parameters are returned to the consumer for final processing.

The technology described herein may be extended to restore a managed device to its previous state at conclusion of the complete package install phase. To this end service providers may track the changes that are needed to roll back each part that they install e.g. storing the rollback changes themselves as serialized rollback parts in the device configuration settings database e.g. Windows registry . Such parts may be assembled into a rollback package for example for subsequent installation in the normal manner to restore the previous system state.

One of ordinary skill in the art can appreciate that the various embodiments and methods described herein can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment and can be connected to any kind of data store or stores. In this regard the various embodiments described herein can be implemented in any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units. This includes but is not limited to an environment with server computers and client computers deployed in a network environment or a distributed computing environment having remote or local storage.

Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for objects such as files. These resources and services also include the sharing of processing power across multiple processing units for load balancing expansion of resources specialization of processing and the like. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may participate in the resource management mechanisms as described for various embodiments of the subject disclosure.

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in communications network may comprise other computing objects and computing devices that provide services to the system of and or may represent multiple interconnected networks which are not shown. Each computing object etc. or computing object or device etc. can also contain an application such as applications that might make use of an API or other object software firmware and or hardware suitable for communication with or implementation of the application provided in accordance with various embodiments of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for example communications made incident to the systems as described in various embodiments.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client is a member of a class or group that uses the services of another class or group to which it is not related. A client can be a process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. The client process utilizes the requested service without having to know any working details about the other program or the service itself.

In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. acting as servers provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances.

A server is typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server.

In a network environment in which the communications network or bus is the Internet for example the computing objects etc. can be Web servers with which other computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Computing objects etc. acting as servers may also serve as clients e.g. computing objects or devices etc. as may be characteristic of a distributed computing environment.

As mentioned advantageously the techniques described herein can be applied to any device. It can be understood therefore that handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments. Accordingly the below general purpose remote computer described below in is but one example of a computing device.

Embodiments can partly be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is considered limiting.

With reference to an example remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation system memory may also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices . A monitor or other type of display device is also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which may be connected through output interface .

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

As mentioned above while example embodiments have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to improve efficiency of resource usage.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques provided herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more embodiments as described herein. Thus various embodiments described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

For the avoidance of doubt the subject matter disclosed herein is not limited by any examples. In addition any aspect or design described herein is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent example structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements when employed in a claim.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component module system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the example systems described herein methodologies that may be implemented in accordance with the described subject matter can also be appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the various embodiments are not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover some illustrated blocks are optional in implementing the methodologies described hereinafter.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

In addition to the various embodiments described herein it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating therefrom. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be effected across a plurality of devices. Accordingly the invention is not to be limited to any single embodiment but rather is to be construed in breadth spirit and scope in accordance with the appended claims.

