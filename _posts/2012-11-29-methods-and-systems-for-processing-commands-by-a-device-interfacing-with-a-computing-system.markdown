---

title: Methods and systems for processing commands by a device interfacing with a computing system
abstract: Method and system for processing a command received from a processor executable computing entity from among a plurality of computing entities of a computing system that interfaces with a device is provided. The method includes receiving the command by a command processing module executed by a processor of the computing system; generating a command object for the command by the command processing module, where the command object format does not change regardless of a computing entity type or a command type; placing the command object in a command queue maintained by the command processing module; sending the command to a device in a same context as a context of the computing entity, when the command object is a first command object in the command queue with the command that is ready to be sent to the device; and sending the command to the device in a different context as the context of the computing entity, when the command object is not the first command object in the command queue with the command that is ready to be sent to the device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09047151&OS=09047151&RS=09047151
owner: QLOGIC, Corporation
number: 09047151
owner_city: Aliso Viejo
owner_country: US
publication_date: 20121129
---
Computing systems are commonly used today. A computing system often communicates with different devices using device drivers. Various entities for example processes tasks interrupt handlers and others communicate using a command request response CRRI interface in a device driver communication model.

Conventional device driver model that use a CRRI has challenges. For example different entities may have their own distinct characteristics and they tend to use custom CRRIs which has limited the development of a generic interface. This approach has limitations because managing multiple types of CRRI for different entities becomes complex and burdensome.

Furthermore even when similar entities i.e. the same entity type use the same CRRI then each entity can use the CRRI asynchronously to issue commands to a device. For example two similar entities may issue commands to the same device module at the same time for reading or writing data. The entities then have to coordinate the operations associated with the command to avoid any potential conflict. This can be inefficient especially when the entities have to perform various operations and also have to expend resources in synchronizing how the commands are being processed. If the operations are not synchronized then there may be possible conflicts which can produce invalid results. Continuous efforts are being made for developing a generic framework for computing devices to communicate with each other.

The various present embodiments have several features no single one of which is solely responsible for their desirable attributes. Without limiting the scope of the present embodiments as expressed by the claims that follow their more prominent features now will be discussed briefly. After considering this discussion and particularly after reading the section entitled Detailed Description one will understand how the features of the present embodiments provide the advantages described herein.

In one embodiment a machine implemented method for processing a command received from a processor executable computing entity from among a plurality of computing entities of a computing system that interfaces with a device is provided. The method includes receiving the command by a command processing module executed by a processor of the computing system generating a command object for the command by the command processing module where the command object format does not change regardless of a computing entity type or a command type placing the command object in a command queue maintained by the command processing module sending the command to a device in a same context as a context of the computing entity when the command object is a first command object in the command queue with the command that is ready to be sent to the device and sending the command to the device in a different context as the context of the computing entity when the command object is not the first command object in the command queue with the command that is ready to be sent to the device

In another embodiment a system is provided. The system includes a computing system executing a plurality of computing entities for sending commands a device interfacing with the computing system for receiving the commands and responding to the commands a command processing module executed by the computing system having an application programming interface configured to receive a command generated by one of the plurality of computing entities generate a command object using a command object format that does not change regardless of a computing entity type or a command type places the command object in a command queue maintained by the command processing module and sends the command to the device in a same context as a context of the computing entity that sent the command when the command object is a first command object in the command queue with the command that is ready to be sent to the device and an interrupt handler that sends the command to the device in a different context as the context of the computing entity when the command object is not the first command object in the command queue with the command that is ready to be sent to the device.

In yet another embodiment a command processing module executed by a hardware based processor for a computing system that executes a plurality of computing entities for sending commands that are processed by a device interfacing with the computing system is provided. The module includes a processor executable application programming interface API configured to receive a command generated by one of the plurality of computing entities generate a command object using a command object format that does not change regardless of a computing entity type or a command type places the command object in a command queue maintained by the command processing module and sends the command to the device in a same context as a context of the computing entity that sent the command when the command object is a first command object in the command queue with the command that is ready to be sent to the device and a processor executable interrupt handler interfacing with the device sends the command to the device in a different context as the context of the computing entity when the command object is not the first command in the command queue with the command that is ready to be sent to the device.

This brief summary has been provided so that the nature of the disclosure may be understood quickly. A more complete understanding of the disclosure can be obtained by reference to the following detailed description of the embodiments thereof concerning the attached drawings.

The following detailed description describes the present embodiments with reference to the drawings. In the drawings reference numbers label elements of the present embodiments. These reference numbers are reproduced below in connection with the discussion of the corresponding drawing features.

As a preliminary note any of the embodiments described with reference to the figures may be implemented using software firmware hardware e.g. fixed logic circuitry manual processing or a combination of these implementations. The terms logic module component system and functionality as used herein generally represent software firmware hardware or a combination of these elements. For instance in the case of a software implementation the terms logic module component system and functionality represent program code that performs specified tasks when executed on a hardware processing device or devices e.g. CPU or CPUs . The program code can be stored in one or more non transitory computer readable memory devices.

More generally the illustrated separation of logic modules components systems and functionality into distinct units may reflect an actual physical grouping and allocation of software firmware and or hardware or can correspond to a conceptual allocation of different tasks performed by a single software program firmware program and or hardware unit. The illustrated logic modules components systems and functionality may be located at a single site e.g. as implemented by a processing device or may be distributed over a plurality of locations.

The term machine readable media and the like refers to any kind of non transitory storage medium for retaining information in any form including various kinds of storage devices magnetic optical static etc. .

The embodiments disclosed herein may be implemented as a computer process method a computing system or as an article of manufacture such as a computer program product or computer readable media. The computer program product may be non transitory computer storage media readable by a computer device and encoding a computer program of instructions for executing a computer process.

The computing system may include one or more processors also known as a central processing unit CPU . Processor may be or may include one or more programmable general purpose or special purpose microprocessors digital signal processors DSPs programmable controllers application specific integrated circuits ASICs programmable logic devices PLDs or the like or a combination of such hardware devices.

The processor executes computer executable process steps and interfaces with an interconnect or computer bus . The computer bus may be for example a system bus a Peripheral Component Interconnect PCI bus or PCI Express bus a HyperTransport or industry standard architecture ISA bus a SCSI bus a universal serial bus USB an Institute of Electrical and Electronics Engineers IEEE standard 1394 bus sometimes referred to as Firewire or any other interconnect type.

An adapter interface facilitates the ability of the computing system to interface with the adapter via a link . The computing system also includes other devices and interfaces which may include a display device interface a keyboard interface a pointing device interface etc. Details regarding the other devices are not germane to the embodiments disclosed herein.

The computing system may further include a storage device which may be for example a hard disk a CD ROM a non volatile memory device flash or memory stick or any other mass storage device. Storage may store operating system program files application program files and other files. Some of these files are stored on storage using an installation program. For example the processor may execute computer executable process steps of an installation program so that the processor can properly execute the application program.

Memory also interfaces to the computer bus to provide the processor with access to memory storage. Memory may include random access main memory RAM . When executing stored computer executable process steps from storage the processor may store and execute the process steps out of RAM. Read only memory ROM not shown may also be used to store invariant instruction sequences such as start up instruction sequences or basic input output system BIOS sequences for operation of a keyboard not shown .

With continued reference to link and the adapter interface couple the adapter to the computing system . The adapter may be configured to handle both network and storage traffic. Various network and storage protocols may be used to handle network and storage traffic. Some common protocols are described below.

One common network protocol is Ethernet. The original Ethernet bus or star topology was developed for local area networks LAN to transfer data at 10 Mbps mega bits per second . Newer Ethernet standards for example Fast Ethernet 100 Base T and Gigabit Ethernet support data transfer rates between 100 Mbps and 10 Gbps. The descriptions of the various embodiments described herein are based on using Ethernet which includes 100 Base T and or Gigabit Ethernet as the network protocol. However the adaptive embodiments disclosed herein are not limited to any particular protocol as long as the functional goals are met by an existing or new network protocol.

One common storage protocol used to access storage systems is Fibre Channel FC . Fibre Channel is a set of American National Standards Institute ANSI standards that provide a serial transmission protocol for storage and network protocols such as HIPPI SCSI IP ATM and others. Fibre Channel supports three different topologies point to point arbitrated loop and fabric. The point to point topology attaches two devices directly. The arbitrated loop topology attaches devices in a loop. The fabric topology attaches computing systems directly via HBAs to a fabric which are then connected to multiple devices. The Fibre Channel fabric topology allows several media types to be interconnected.

Fibre Channel fabric devices include a node port or N Port that manages Fabric connections. The N port establishes a connection to a Fabric element e.g. a switch having a fabric port or F port.

A new and upcoming standard called Fibre Channel Over Ethernet FCOE has been developed to handle both Ethernet and Fibre Channel traffic in a storage area network SAN . This functionality would allow Fibre Channel to leverage 10 Gigabit Ethernet networks while preserving the Fibre Channel protocol. The adapter shown in may be configured to operate as an FCOE adapter and may be referred to as FCOE adapter . QLogic Corporation the assignee of the present application provides one such adapter. The illustrated adapter however does not limit the scope of the present embodiments. The present embodiments may be practiced with adapters having different configurations.

Referring back to adapter interfaces with the computing system via the link and a host interface . In one embodiment the host interface may be a PCI Express interface coupled to a PCI Express link having logic circuitry for sending and receiving PCI Express packets.

The adapter may also include a processor that executes firmware instructions out of memory to control overall adapter operations. The adapter may also include storage which may be for example non volatile memory such as flash memory or any other device. The storage may store executable instructions and operating parameters that can be used for controlling adapter operations.

The adapter includes a network module for handling network traffic via a link . In one embodiment the network module includes logic and circuitry for handling network packets for example Ethernet or any other type of network packets. The network module may include memory buffers not shown to temporarily store information received from other network devices and transmitted to other network devices .

The adapter may also include a storage module for handling storage traffic to and from storage devices . The storage module may further include memory buffers not shown to temporarily store information received from the storage devices and transmitted by the adapter to the storage devices . In one embodiment the storage module is configured to process storage traffic according to the Fibre Channel storage protocol or any other protocol. It is noteworthy that adapter may only have a network module or a storage module . The embodiments described herein are not limited to any particular adapter type.

The adapter also includes a network interface that interfaces with link via one or more ports not shown . The network interface includes logic and circuitry to receive information via the network link and pass it to either the network module or the storage module depending on the packet type.

An application may be executed by processor for performing certain functions. For example application may be an email program a database application or any other application type. Application may send a command to a driver for performing an operation for example reading and or writing data at another storage device. The driver processes the request and communicates with firmware executed by processor of adapter . A component of adapter then processes the request.

Typically entities of similar type use the same CRRI to issue a command to a device. It is noteworthy that similar entity types may simultaneously issue commands using the same CRRI but then the entities have to synchronize the responses for the issued commands to avoid any conflicts. This is undesirable because it would require the entities to expend resources in synchronization rather than performing the functions that they are designed to perform.

As the number of entities increase it is inefficient to use dedicated CRRIs for each entity. Furthermore it is inefficient when entities have to synchronize command processing and responses. The embodiments disclosed herein provide a unified generic CRRI framework that allows different entities to communicate with adapter or adapter components without having to use dedicated or customized CRRIs. The embodiments described herein also do not require the entities to perform any synchronization tasks thus reducing that burden. This allows the entities to perform the designated tasks that they are designed to perform.

The command processing module also includes a timer module . API may be used to assign a timestamp for a command when the command is received from an entity. The timer module maintains the duration while the command object is waiting for processing. The time stamp is compared to a current time and if the difference has reached a threshold timeout value then a recovery process for the entity can be initiated. The recovery process will vary from entity to entity.

Command processing module also includes a monitoring module that monitors the command queue to determine if a timeout has occurred for a command. As explained above the time out is based on the difference of a current time and a threshold time.

In one embodiment the command processing module uses a common format for command objects regardless of which entity is sending a command. The common format includes a plurality of fields A E described in detail below with respect to .

Field A is used to specify the state of a command in a command object. For example a command state may be ALLOC INIT REQ SENT RES PENDING and COMPLETE. The states are set by API or interrupt handler depending on the state type. The different states provide a current status of a given command at any given time. The command states are described below in detail with respect to and .

Field B is used to indicate whether an entity wants to wait for a command response. As an example field B may be a wait flag whose value indicates that the entity wants to wait for a command response. For example if the wait flag is set to 1 then it means that the entity wants to wait for the command response. If the wait flag is set to 0 then the entity does not want to wait for the command response.

Field C provides information regarding the request from the entity. The entity issuing the command may populate this field. As an example field C may include a command number and or name command parameters command version if any or any other information type.

Field D may be populated by command processing module when a response is received from the adapter . As an example field D may include a command number and or name result of command execution e.g. pass fail response parameters if any or any other information that is needed in response to a command.

Field E is a time stamp that is generated by command processing module when a command is issued to adapter or any of its modules. The time stamp may be used to monitor the overall efficiency of command processing as described below in detail with respect to .

Before describing the various process flows of the present embodiments the following describes the two CRRI types CRRI A and CRRI B that are supported by the command object format and command processing module . CRRI A is an interface type where a host system can issue a command only when a device sends a response to a previous command. CRRI B interface is an interface type that allows a host system to issue a command even before a response is received for a previous command.

In block B API prepares a command object using the format described above with respect to . The initial state of the command is set to ALLOC. During this state appropriate memory is allocated to store the command. If the entity that sent the commands requires a wait for a response from adapter then flag B is set to a certain value for example 1 such that command processing module knows that it has to wait for a response. A timestamp is also inserted in the command object by API .

In block B API places the command object in the command queue . The command state for the command is then changed to INIT by API which means that the command is ready to be sent to adapter .

In block B API checks the command queue to determine if the inserted command object is the first object with the INIT state at the command queue . If it is the first command object then in block B API issues the command to the device and in block B sets the command state to REQ SENT. This indicates that the command has been sent. It is noteworthy that since API prepares the command places the command and then sends the command in the same context as the entity that sent the command the process is faster and more efficient.

In block B the interrupt handler receives an interrupt INT RESPONSE from the adapter . This indicates that the adapter is ready to send a response for the command. The interrupt handler then sets the state of the command object to COMPLETE such that a next command object can be processed.

The manner in which the command is de queued from the command queue depends on whether the wait flag B is set or not as determined in block B. If the wait flag is set then in block B API continues to poll for the state of the command object. The state is only changed when a response has been received by interrupt handler . Once the state is set API de queues the command and the resources associated with the command for example memory storage space at command queue are released so that the resources can be used for a next command.

If the wait flag is not set as determined in block B then in block B the interrupt handler de queues the command object from the command queue after setting the COMPLETE state. Thereafter the resources associated with the command are released.

Referring back to block B if the command object is not the first command object with the INIT state then in block B the interrupt handler sends the command to adapter after an the INT RESPONSE interrupt has been received for a previous response. For example assume that the command object is the nth command object that is inserted in block B. When a response is available for a n 1 command the adapter triggers the interrupt INT RESPONSE. The interrupt handler receives the interrupt INT RESPONSE for the n 1 command object from adapter and then the nth command is sent to adapter in a context that may be different from the context of the entity that sent the command. Thereafter the process moves to block B that has been described above.

If the command object as determined in block B is not the first command object in the command queue with the INIT state then in block B the interrupt handler sends the command to the adapter in a context that may be different from the context of the entity that sent the command after an interrupt INT REQUEST for a previous command object is received. For example if the command object in block B is the mth command object then the command is sent to adapter after the interrupt INT REQUEST is received for the m 1 command. The INT REQUEST is an interrupt type that is used for the CRRI B type interface. This interrupt indicates to the command processing module that the adapter has received the command object.

In block B the interrupt handler sets the state of the command object to REQ SENT indicating that the request has been sent. In block B the interrupt handler receives the INT REQUEST interrupt from adapter indicating that the request was received. The interrupt handler then sets the command object state to RES PENDING.

In block B the interrupt handler receives the interrupt INT RESPONSE for the current response. This indicates that a response to the command sent in block B is ready. The interrupt handler then sets the state of the command object to COMPLETE and the process moves to block B that is described below.

Referring back to block B if the command object is the first command with the INIT state then in block B API issues the command in block B in the same context as the entity that sent the command and thereafter in block B API sets the state to REQ SENT. Thereafter the process moves to block B that has been described above.

In block B the process determines if the wait flag is set for the command object. If yes then in block B API de queues the command object and the resources associated with the command object are released for a next command object.

If the wait flag is not set then in block B the interrupt handler de queues the command object and releases the resources associated with the command object.

The state machine operations begin in block when an entity calls API to send a command. This is similar to block B described above in detail.

The ALLOC state is then set in block when API prepares a command object CMD OBJ n . The INIT state is then set in block after API inserts the CMD OBJ n at a location in command queue as shown by solid line A. If the CMD OBJ n is the first command object in command queue then API sends the command to adapter and API sets the command object state to REQ SENT in block as shown by the solid line C.

When the API detects that the CMD OBJ n is not the first command object in the command queue with the INIT state then it simply waits as shown by the loop A if the wait flag is set as described below. If the wait flag is not set then API exits at this stage because the rest of the operations are handled by the interrupt handler as described below.

When the CMD OBJ n is not the first command object with the INIT state then the process waits to receive the interrupt INT RESPONSE from the adapter for a previous command object CMD OBJ n 1 . When the interrupt is received as shown by the dotted line B the command is sent to the adapter and the command object state is set by the interrupt handler to REQ SENT in block .

After the adapter processes the command for CMD OBJ n the adapter sends the interrupt INT RESPONSE for CMD OBJ n . When the interrupt is received by the interrupt handler as indicated by the dotted line A the COMPLETE state is set for CMD OBJ n in block by the interrupt handler . The command object is then de queued by API or interrupt handler based on the wait flag. For example API de queues the command object CMD OBJ n as shown by solid line A when the wait flag is set. The interrupt handler de queues CMD OBJ n as shown by dotted line B when the wait flag is not set. The resources for example the memory location used for storing the command object are then released and the state is set to FREE in block .

If the CMD OBJ n is not the first command with the INIT state then API waits as shown by the loop A if the wait flag is set. If the wait flag is not set then API exits at this stage.

When the CMD OBJ n is not the first command object with the INIT state then the process waits to receive the interrupt INT REQUEST for a previous command object CMD OBJ n 1 . The INT REQUEST indicates that the previous command has been received by adapter . The interrupt handler then sends the CMD OBJ n to adapter as shown by the dotted line B. After the command object is sent the state of the command object is set to REQ SENT by the interrupt handler in block .

Thereafter the process waits to receive the interrupt INIT REQUEST for CMD OBJ n . When the interrupt is received from adapter it is handled by interrupt handler as shown by dotted line A. Thereafter the state of CMD OBJ n is changed to RES PENDING in block by the interrupt handler . This state is only used the for CRRI B type interface.

Thereafter the process waits to receive the interrupt INT RESPONSE from the adapter which indicates that a response is ready for the command. The interrupt handler handles this interrupt and changes the state of command object to COMPLETE in block as shown by the dotted line A. The COMPLETE state and the FREE state block are similar to the states in and that have been described above with respect to . The solid line A is similar to A while the dotted line B is similar to the dotted line B described above with respect to .

In block B a recovery process is initiated when the difference between the timestamp and a current time has reached a programmable threshold timeout value. The current time may be maintained by timer module . The threshold timeout value may be programmable and stored at a memory location not shown .

The recovery process involves recovery of adapter command interface and command processing module . If adapter side command interface is integrated with firmware then the recovery process may involve the firmware. The embodiments disclosed herein are not limited to any particular recovery process or command type.

The systems and processes described above have various advantages For example customized CRRIs are not needed and instead an entity independent format as shown in is used. The command processing module serves different entities to issue commands to the adapter as well as processing responses. Therefore the entities using the module do not need to know the details around CRRI. Furthermore a single API is provided for different types of command issuing entities with various characteristics.

In another aspect any entity can issue command asynchronously to adapter . The command processing module manages all the commands and responses. Thus the entities do not need to expend any resources in synchronizing responses.

The above description presents the best mode contemplated for carrying out the present embodiments and of the manner and process of making and using them in such full clear concise and exact terms as to enable any person skilled in the art to which they pertain to make and use these embodiments. These embodiments are however susceptible to modifications and alternate constructions from that discussed above that are fully equivalent. Consequently these embodiments are not limited to the particular embodiments disclosed. On the contrary these embodiments cover all modifications and alternate constructions coming within the spirit and scope of the embodiments as generally expressed by the following claims which particularly point out and distinctly claim the subject matter of the embodiments.

