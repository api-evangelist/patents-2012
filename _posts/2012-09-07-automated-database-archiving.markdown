---

title: Automated Database Archiving
abstract: Various embodiments of systems and methods of optimizing a database are described herein. Database tables are rated based on at least one of table size and table growth rate. One or more of the database tables are then selected based on the rating of the database tables. Archiving objects for the one or more selected tables are obtained. An archiving object includes one or more archiving programs and defines data related to a business object. The archiving objects are ranked based on dependencies between them. Based on the ranking of the archiving objects, an archiving schedule including an archiving order for the archiving objects is generated. The archiving schedule is then displayed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09081806&OS=09081806&RS=09081806
owner: SAP SE
number: 09081806
owner_city: Walldorf
owner_country: DE
publication_date: 20120907
---
Data in some systems such as enterprise systems can grow at a rapid pace. The underlying database tables that store the data can become very large. Performance of a system is typically dependent on the size of database tables. Large database tables make operations such as searching and reading slower resulting in decreased productivity. Therefore some data records from database tables are moved to a storage system to increase productivity. This process of moving data records from a database table to a storage system is called archiving. Data records for archiving are identified based on various parameters. For example data records that do not need to be accessed frequently can be selected for archiving. However different systems can have different volumes of data. Therefore manual analysis of data is typically required to determine an optimal archiving schedule. Such manual analysis can be time consuming and inefficient. For example if data usage pattern changes then a new analysis needs to be performed.

Embodiments of techniques for automated database optimization are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Referring to data in a database is stored in tables . The database tables are frequently updated as a result of various operations. Data records in the database table may be changed or new data records can be added to the database tables . There can be numerous operations that require updating of database tables . For example there can be several user activities during any single day that require updating of organizational databases leading to rapid growth in data. The storage capacity of the database can be overwhelmed by such rapid growth of data. Therefore data in the database is archived by moving some data records of the database tables to a storage system . This will free up memory resources of the database . However this process of archiving is manual in nature. A user has to manually perform an analysis to identify tables that need to be archived. This analysis can be tedious time consuming and prone to errors.

In one embodiment a weightage can be given to table size and table growth rate. This weightage can be customizable and can be selected based on archiving needs of an organization. In one embodiment the table growth rate can be given more weight than the table size. For example the table growth rate can be given sixty percent weightage and the table size can be given forty percent weightage. Weightage based composite rating for a table can be defined as following Composite rating 0.4 Number of data records 0.6 Table growth rate 

The tables can have different number of data records and different growth rates. As an example table A can have thousand records and a growth rate of fifty records per day on average and table B can have ten thousand records and a growth rate of ten records per day on average. Therefore different tables have different composite ratings. A higher composite rating means that the table size and or growth rate is high. Therefore tables with higher composite ratings are good candidates for archiving.

Referring back to at tables with relatively higher composite ratings are selected for archiving. In one embodiment a threshold value of the composite rating is used for selecting the tables. The threshold values can be an average value of the composite ratings a median value of the composite ratings an upper quartile of the composite ratings or other percentile value of the composite ratings. In another embodiment top few tables having a higher composite rating are selecting. For example these top tables can be the tables having composite ratings in the upper quartile of the overall composite ratings. In this way some of the database tables are selected. As an example consider that table B and table D are selected.

At archiving objects for the selected database tables e.g. tables B and D are obtained. An archiving object is a logical unit that describes which data from the database makes up a business object. A portion of data from one or more database tables is related to a business object. The archiving object defines this portion of data as related to a particular business object. A business object is a software entity representing real world items used during the transaction of business. For example a business object may represent a business document such as a sales order a purchase order or an invoice. A business object may also represent items such as a product a business partner or a piece of equipment. A business object may include business logic and or data having any suitable structure. The structure of a business object may be determined based on the requirements of a business scenario in which the business object is to be deployed.

The archiving object also includes archiving programs such as a write program to write business objects to archive files a delete program to delete business objects from the database after archiving and a read program to display an archived business object. In one embodiment as shown in the archiving object includes a data declaration component archiving programs and customization settings . The data declaration component is used to define the data related to a business object . In addition to write read and delete programs the archiving programs can also include a preprocessing program that prepares data for archiving a post processing program to process data after archiving and a reload program to reload the archived business objects into the database. The customization settings are used to define parameters specific to archiving object for an archiving session.

Each database table can have one or more archiving objects associated with it. In one embodiment archiving metadata can be stored in the database. The archiving metadata can be stored in a table and include information about which archiving objects are associated with which database tables. Therefore archiving metadata tables can be used to obtain a list of archiving objects for the selected database tables.

Archiving objects have dependencies between them. For example the archiving object C depends from archiving object B which in turn depends on archiving object A . The archiving object D also depends on archiving object B . A dependency between two archiving objects specifies which archiving object is to be run before the other. In an archiving process the write program of an archiving object is executed. The write program creates archive files. Following which the delete program of the archiving object is executed to delete the data that had been written into archive files. The archive files are then stored. By running a parent archiving object before a child archiving object data integrity is maintained.

Referring back to at the archiving objects are ranked based on dependencies between them. The root archiving object is ranked as the first archiving object that needs to be run following which a subsequent archiving object in the dependency chain. Considering the example of the archiving object A is given a first rank the archiving object B is given a second rank the archiving object C is given a third rank. Since the archiving object D is also dependent on the archiving object B the archiving object D can also be given a third rank and the archiving processes for both the archiving objects C and archiving object D can be executed in parallel. In one embodiment one or more of the obtained archiving objects may not be dependent on other archiving objects. In this case the archiving process for such non dependent archiving objects can be run in parallel along with archiving processes of other archiving objects. In another embodiment archiving process of a non dependent archiving object is run in parallel with archiving process of a top ranked archiving object belonging to an archiving object dependency chain.

Referring back to at an archiving schedule is generated based on the ranking of the archiving objects. The archiving schedule provides an order of execution of archiving process based on the rankings of the archiving objects. Archiving object specific archiving processes such as writing and deleting are executed for each archiving object as per the order in the archiving schedule. The archiving objects are arranged from a top or high ranking archiving object to a lowest ranking archiving object. Considering the archiving objects of the archiving schedule includes the following order of archiving objects 1 archiving object A 2 archiving object B and 3 archiving object C . Therefore archiving processes for the archiving object A are executed first followed by archiving processes for the archiving object B and archiving processes for the archiving object C . The archiving object D can also be ranked third and the archiving processes for archiving object D can be executed in parallel with archiving processes for the archiving object C.

Referring back to at the archiving schedule is displayed on a user interface. illustrates an embodiment of the user interface . The archiving schedule displayed on the user interface provides an overview to a user. The archiving objects and their order can be presented using various graphical techniques. For example graphical representations of the archiving objects can be presented in a hierarchy to represent their order with archiving object A as the root component archiving object B depending from archiving object A archiving object C depending from archiving object B and archiving object D also depending from archiving object B . In one embodiment the user interface can be integrated with the method . The user interface can be part of an application embodying the method . As shown in an authorized user can access the application and initiate the method using an option on the user interface . The method is then automatically executed and the archiving schedule is provided as the output and displayed on the user interface . Therefore the user can readily know the order of the archiving objects without the need to perform any manual analysis to generate an archiving schedule.

A user has to just initiate the method via the user interface to optimize a database. The archiving processes are then executed for each archiving object as per the order in the archiving schedule. This frees up memory resources of the database as some of the data from the database is moved to a storage system as part of the archiving process. Therefore the database is optimized for better performance and operations such as reading data from the database searching the database etc. run faster.

In one embodiment the user interface displays intermediate results during database optimization. For example as shown in the user interface can display composite ratings of the selected database tables. This provides an overview of database tables that are involved in archiving process. The user interface can also display results of archiving object analysis such as the archiving objects for the selected tables and the dependencies between the archiving objects.

Referring to each archiving object is associated with a portion of data in the database. This portion of data can be large. Therefore in one embodiment this portion of data is divided into a plurality data slice variants based on one or more attributes. The attribute can be a generic attribute such as sales order type fiscal year quarter etc. such that the data slice variants are mutually exclusive. For example the portion of data related to an archiving object can be sales data for the year 2010 and the data slice variants can include a first data slice variant for sales data of the first quarter of 2010 a second data slice variant for sales data of second quarter of 2010 a third data slice variant for sales data of third quarter of 2010 and a fourth data slice variant for sales data of fourth quarter of 2010.

In one embodiment in addition to order of the archiving objects the archiving schedule includes data slice variants for the archiving objects. This archiving schedule is also displayed on the user interface as shown in . For example the archiving object A includes four data slice variants the archiving object B does not include any data slice variants the archiving object C includes two data slice variants and and the archiving object D includes two data slice variants and . A predefined set of attributes can be used to automatically determine the data slice variants for an archiving object. If one of these predefined attributes is associated with data related to an archiving object then data slice variants are automatically determined for that archiving object. Depending on these attributes some archiving objects may not have data slice variants. For an archiving object archiving processes can be executed in parallel for the data slice variants. This will speed up the archiving process. For example for the archiving object A write and delete operations can be executed in parallel for the four data slice variants since there is no overlap of data between the data slice variants .

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

