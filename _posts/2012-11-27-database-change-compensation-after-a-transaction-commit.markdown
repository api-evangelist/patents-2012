---

title: Database change compensation after a transaction commit
abstract: A virtualization manager receives a request to perform a command in a virtual machine system and executes a plurality of transactions associated with the command, each of the plurality of transactions comprising one or more operations executed on entities in the virtual machine system. The virtualization manager commits changes made to the entities in the virtual machine system as a result of the plurality of transactions to a management database for the virtual machine system. In addition, the virtualization manager generates a business entity snapshot corresponding to a first transaction of the plurality of transactions, the business entity snapshot comprising state information for one or more entities in the virtual machine system affected by the first transaction.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09081597&OS=09081597&RS=09081597
owner: Red Hat Israel, Ltd.
number: 09081597
owner_city: Raanana
owner_country: IL
publication_date: 20121127
---
This disclosure relates to the field of virtualization and in particular to database change compensation after a transaction commit.

Virtualization allows multiplexing of the underlying host machine between different virtual machines. The host computer allocates a certain amount of its resources to each of the virtual machines. Each virtual machine is then able to use the allocated resources to execute applications including operating systems referred to as guest operating systems . The software layer providing the virtualization is commonly referred to as a hypervisor and is also known as a virtual machine monitor VMM a kernel based hypervisor or a host operating system. The hypervisor emulates the underlying hardware of the host computer making the use of the virtual machine transparent to the guest operating system and the user of the virtual machine.

Generally information about the configuration and state of the entities in a virtual machine system such as virtual machines virtual disks host machines storage domains etc. is stored in a system database. When a request is received to execute a command management software executes a transaction to perform the operations needed to carry out the command. As the operations in the transaction affect entities in the virtual machine system the changes that are made to those entities are typically committed to the system database. In some cases the transactions required to carry out a command can be lengthy and resource intensive. Certain systems have attempted to solve this problem by shortening the transaction length. By breaking up a command into multiple shorter transactions any one particular resource is not locked or otherwise made unavailable for any significant period of time. In this case however the changes caused by each transactions are committed to the system database at the end of each transaction. Once the changes are committed to the system database there is generally no way to roll back those changes to revert to the previous state. Thus if there is an crash or failure during the execution of the transaction the system may not be able to recover and restore the values in the system database to the state before the command was initiated.

The following description sets forth numerous specific details such as examples of specific systems components methods and so forth in order to provide a good understanding of several embodiments of the present invention. It will be apparent to one skilled in the art however that at least some embodiments of the present invention may be practiced without these specific details. In other instances well known components or methods are not described in detail or are presented in simple block diagram format in order to avoid unnecessarily obscuring the present invention. Thus the specific details set forth are merely exemplary. Particular implementations may vary from these exemplary details and still be contemplated to be within the scope of the present invention.

Described herein is a method and system for database change compensation after a transaction commit during the handling of a set of short transactions that logically represent a single longer transaction. In one embodiment a virtualization manager controls operations of various entities e.g. host servers virtual machines virtual disks in a virtual machine system. A user or application may issue a command e.g. through a networked client device to perform some action on one or more entities in the system. The virtualization manager may identify and execute a series of transactions in order to carry out the action specified by the command. A transaction is a unit of work performed within a database management system against a database that is treated in a coherent and reliable way independent from other transactions. For example the command may be a request to start a new virtual machine stop a virtual machine create a virtual disk or some other request. Multiple transactions associated with the command may include for example locking the target virtual machine so that no other operations on that virtual machine may be performed until the virtual machine is unlocked adding a new virtual disk to the virtual machine pre allocating the virtual disk and unlocking the virtual machine.

Upon executing a transaction associated with the command the virtualization manager may create a business entity snapshot in a management database. The snapshot may include information about the transaction being executed by the virtualization manager. For example the snapshot may include an indication of the command with which it is associated an indication of the entity on which an action is performed an indication of what action was performed an indication of a change in state of the entity as a result of the action and or other information. Thus the snapshot includes a table or other data structure including one or more entries each corresponding to a different parameter. The values of these parameters can be used to describe the state of the virtualization system or at least the state of certain entities within the system at a certain point in time either before or after the transaction is executed. In one embodiment the business entity snapshot is not a copy or image of the database or system but rather an aggregation of data representing the state of the system at a certain point in time. This information in the snapshots may be maintained in the database until all of the transactions associated with the command have been successfully completed.

In one embodiment once each transaction is completed the state of the affected entities may be committed to an entity table of the management database. For example if a virtual machine is initially unlocked and then subsequently locked during execution of a transaction the state of the virtual machine in the entity table may be overwritten as locked. In the event of a crash failure or other error in one of the transactions there may not be a way to determine from the entity table itself what the previous state of that virtual machine was. Since the snapshot contains the initial state of any affected entities the information in the snapshots may be used to roll back the virtual machine system to the state that existed before the command was initiated thereby compensating for the changes after the transactions have been committed.

The use of the compensation i.e. the ability to roll back the state of the system and snapshot techniques described herein allows the virtual machine system to use a series of shorter transactions to carry out a command while still maintaining the ability to roll back to the prior state in the event of a crash or other failure. Using shorter transactions may be beneficial because certain system resources are not tied up for lengthy periods of time. In addition the risk of transactions timing out and being dropped are reduced. This may also be beneficial in read committed systems because a user will be able to monitor the progress of a command and get intermediate state information rather than having to wait until all operations associated with the command are completed.

In one embodiment the clients may include computing devices that have a wide range of processing capabilities. Some or all of the clients may be thin clients which serve as access terminals for users and depend primarily on the host servers for processing activities. For example the client may be a desktop computer laptop computer cellular phone personal digital assistant PDA etc. The client may run client applications such as a Web browser. The client may also run other client applications which receive multimedia data streams or other data from the host server and re direct the received data to a local display or other user interface.

Host servers may include server computers or any other computing devices capable of running one or more virtual machines . Each virtual machine runs a guest operating system OS that may be different from one virtual machine to another. The guest OS may include Microsoft Windows Linux Solaris Mac OS etc. The host server may include a hypervisor that emulates the underlying hardware platform for the virtual machines . The hypervisor may also be known as a virtual machine monitor VMM a kernel based hypervisor or a host operating system.

Each virtual machine can be accessed by one or more of the clients over the network and can provide a virtual desktop for the client s . From the user s point of view the virtual desktop functions as a physical desktop e.g. a personal computer and is indistinguishable from a physical desktop. Each virtual machine may be linked to one or more virtual disks . These virtual disks can be logical partitions of a physical disk managed by hypervisor can be cloud based storage devices or can be some other type of virtual storage device. In one embodiment virtual disks may form a whole or part of a logical data center. In one embodiment virtual machines and virtual disks together with host servers may be collectively referred to as entities in a virtual machine system.

The virtual machines and virtual disks are managed by the host controller . Host controller may manage the allocation of resources from host server to virtual machines . In addition host controller may monitor the state of virtual machines as well as the progress of commands and processes being executed by virtual machines and or on virtual machines . In one embodiment a command may be issued by a user or application e.g. through one of clients to perform some action. The command may be received by a virtualization manager running on host controller which identifies and executes a series of transactions in order to carry out the action specified by the command. For example the command may be a request to start a new virtual machine stop a virtual machine create a virtual disk or some other request.

In one embodiment virtualization manager controls operations of all entities in the virtual machine system. As illustrated virtualization manager may run on host controller . In other embodiments however virtualization manager may run on some other device such as one of host servers or on a virtual machine . Upon executing a transaction associated with the command virtualization manager may create a snapshot in a database residing on a data storage device . The data storage device may share the machine with the host controller e.g. a disk drive in the host controller computer or be an independent device coupled to the host controller directly or via a network e.g. as a network attached storage device NAS . The snapshot may include information about the transaction executed by virtualization manager . For example the snapshot may include an indication of the command with which it is associated an indication of the entity on which an action is performed an indication of what action was performed an indication of a change in state of the entity as a result of the action and or other information. This information in the snapshots may be maintained in database until all of the transactions associated with the command have been successfully completed. In the event of a crash failure or other error in one of the transactions the information in the snapshots may be used to roll back the virtual machine system to the state that existed before the command was initiated.

In one embodiment client interface module manages communications between virtualization manager and networked client devices . For example client interface module may receive a request from a client device requesting the execution of a command in the virtualization system. The command may be issued by a user or application e.g. through one of clients to perform some action. For example the command may be a request to start a new virtual machine stop a virtual machine create a virtual disk or some other request. In some embodiments client interface module may provide an acknowledgment of receipt of the command request to the client device .

In one embodiment upon receiving an indication of the command from client interface module command manager module may identify a series of transactions associated with the command. Each transaction may include one or more operations designed to carry out the action specified by the command. In one embodiment command manager module publishes an application programming interface API that breaks up the operations associated with a command into shorter separate transactions. Each transaction may include number of the operations included in the command that logically fit together and may be executed as a separate unit. In one embodiment the transactions associated with a command are stored in command table . In another embodiment command table may be combined with snapshot table as part of a single data structure. Command manager module may consult command table or the shared data structure with snapshot table to identify the transactions associated with the command. In one embodiment the transactions may be identified by a universal unique identifier UUID associated with the command.

In one embodiment upon identifying the transactions corresponding to the requested command operation execution module executes the operations from the transactions. For example if the command is a request to add a new virtual disk to a virtual machine the transactions may include locking the target virtual machine so that no other operations may be performed adding a new virtual disk to the virtual machine pre allocating the virtual disk and unlocking the virtual machine. Operation execution module may execute the specific operations in order to complete each of these transactions.

In one embodiment upon executing a transaction associated with the command snapshot manager module may create a snapshot in snapshot table of database . The snapshot may include information about the transaction executed by operation execution module . For example the snapshot may include an indication of the command with which it is associated an indication of the entity on which an action is performed an indication of what action was performed an indication of a change in state of the entity as a result of the action and or other information. This information in the snapshots may be maintained in snapshot table until all of the transactions associated with the command have been successfully completed. In the event of a crash failure or other error in one of the transactions the information in the snapshots may be used to roll back the virtual machine system to the state that existed before the command was initiated. Depending on the type of entity related database operation the snapshot may be created before or after the transaction is executed. For example in the case of adding a new entity such as a virtual disk the entity may first be added and the snapshot be created subsequently to indicate the addition. In another case however such as the update to the state of an entity e.g. locking a virtual machine the snapshot may be created first to reflect the prior state of the entity and then the update is performed. In some cases a second snapshot may created after the transaction is executed in order to reflect the updated state of the entity.

In one embodiment database interface module maintains the state of each entity in the system in entity tables . Once each transaction is completed database interface module commits the state of the affected entities to an entity table of the management database . For example if a virtual machine is initially unlocked and then subsequently locked during execution of a transaction database interface module may overwrite the state of the virtual machine in the entity table as locked. In the event of a crash failure or other error in one of the transactions there may be no way to determine from the entity table itself what the previous state of that virtual machine was. Since the snapshot table contains the initial state of any affected entities the information in the snapshots may be used to roll back the virtual machine system to the state that existed before the command was initiated thereby compensating for the changes after the transactions have been committed.

In one embodiment rollback module may compensate for the changes by reversing the operations performed as part of each transaction. Rollback module may perform these roll back operations upon detecting a crash failure or other error in one of the transactions or operations associated with a command. In one embodiment the snapshot includes an insertion order indicating the order in which the transactions were executed. Rollback module may undo each transaction in the reverse order in which they were performed. The end result may be returning the virtual machine system and each of the entities therein to the state that existed before the command was initiated.

In one embodiment snapshot includes command ID field . The value stored in command ID field may include a UUID indicating the command with which the transaction and snapshot are associated. In other embodiments command ID field may include any other non null value that uniquely identifies the associated command. Command type field may include a description or value representing the type of command. For example the value may indicate that the command includes adding a disk to a virtual machine or other appropriate description.

Entity ID field may include a value identifying an entity that is affected by the transaction. For example if the state of a virtual machine is being changed entity ID field may include a value identifying the particular virtual machine. Each virtual machine in system may have an identifier. It is that identifier that may be stored in entity ID field . Entity type field may include a value identifying the type of entity identified in entity ID field . For example entity type field may include the phrase virtual machine or may have a numerical value representing a virtual machine or whatever entity type is appropriate. Entity snapshot field may include a description of the operations performed during the transaction. For example entity snapshot field may have a string such as lock virtual machine. In addition entity snapshot field may also include an indication of the state of the entity prior to the transaction. Thus if the previous state of the virtual machine was unlocked entity snapshot field may have a value or description indicating unlocked. 

Snapshot type field may include a description or value representing the type of operation performed during the transaction. Some examples may include new for adding a new entity remove for removing an entity from the system or update for changing the state of an already existing entity e.g. locking or unlocking a virtual machine . Insertion order field may include a value representing the order in which snapshots were created. For example the value in insertion order field may be an integer that is incremented each time a new snapshot is created. Started at field may include a timestamp indicating a time at which the snapshot was created. In other embodiments snapshot may include some combination of these and or other fields.

Referring to at block method receives a command indication from a user for a virtual machine system. In one embodiment client interface module receives a request from a client device requesting the execution of a command in the virtualization system. The command may be issued by a user or application e.g. through one of clients to perform some action. For example the command may be a request to start a new virtual machine stop a virtual machine create a virtual disk or some other request.

At block method identifies one or more transactions corresponding to the received command. In one embodiment upon receiving an indication of the command from client interface module command manager module may identify a series of transactions associated with the command. Each transaction may include one or more operations designed to carry out the action specified by the command. Each transaction may include a number of the operations included in the command that logically fit together and may be executed as a separate unit. In one embodiment the transactions associated with a command are stored in command table . Command manager module may consult command table to identify the transactions associated with the command. In one embodiment the transactions may be identified by a universal unique identifier UUID associated with the command.

At block method performs operations associated with the transaction. In one embodiment upon identifying the transactions corresponding to the requested command operation execution module executes the operations from the transactions. For example if the command is a request to add a new virtual disk to a virtual machine the transactions may include locking the target virtual machine so that no other operations may be performed adding a new virtual disk to the virtual machine pre allocating the virtual disk and unlocking the virtual machine. Operation execution module may execute the specific operations in order to complete each of these transactions.

At block method generates a business entity snapshot for the executed transaction. In one embodiment upon executing a transaction associated with the command snapshot manager module may create a snapshot in snapshot table of database . The snapshot may include information about the transaction executed by operation execution module . Depending on the type of transaction the snapshot may be created before or after the transaction is executed. For example in the case of adding a new entity such as a virtual disk the entity may first be added and the snapshot be created subsequently to indicate the addition. In another case however such as the update to the state of an entity e.g. locking a virtual machine the snapshot may be created first to reflect the prior state of the entity and then the update is performed. In some cases a second snapshot may created after the transaction is executed in order to reflect the updated state of the entity.

At block method commits the transaction to the management database. In one embodiment database interface module maintains the state of each entity in the system in entity tables . Once each transaction is completed database interface module commits the state of the affected entities to an entity table of the management database . For example if a virtual machine is initially unlocked and then subsequently locked during execution of a transaction database interface module may overwrite the state of the virtual machine in the entity table as locked. 

At block method determines if there are additional transactions corresponding to the requested command. If there are additional transactions method may repeat the actions at blocks and for each remaining transaction. If there are no additional transactions to execute method may continue to block .

At block once all transactions associated with the command have been performed the command finishes execution. At block method clears the business entity snapshots from the database. In one embodiment snapshot manager module reads snapshot table and identifies all snapshots associated with the command e.g. by scanning the command ID field of each snapshot . Snapshot manager module can delete the snapshots to make room for new snapshots as the old snapshots are no longer needed. In addition this may prevent the system from improperly trying to roll back based on the previous set of snapshots.

Referring to at block method executes transactions corresponding to a command. As described above with respect to operation execution module executes the operations from the transactions. As each is completed snapshot manager module may generate a corresponding business entity snapshot in snapshot table and database interface module may commit the transaction to database in entity tables .

At block method determines if a failure of any transaction has been detected. If no failure is detected method returns to block and continues executing transactions for the command. If however method detects a crash error or other failure at block method continues to block .

At block method identifies snapshots in snapshot table corresponding to the current command. In one embodiment snapshot manager reads snapshot table and identifies all snapshots associated with the command e.g. by scanning the command ID field of each snapshot .

At block method undoes changes of a particular transaction and reverts the affected entities back to their previous state as identified in the business entity snapshot e.g. snapshot . In one embodiment rollback module may compensate for the changes by reversing the operations performed as part of each transaction. For example if the transaction added a new entity rollback module may remove that entity. If the transaction removed an entity rollback module may restore that entity. If the transaction changed the state of an entity e.g. locked a virtual machine rollback module may revert the entity back to the previous state e.g. unlock the virtual machine . In one embodiment the snapshot includes an insertion order field with a value indicating the order in which the transactions were executed. Rollback module may undo each transaction in the reverse order in which they were performed. The end result may be returning the virtual machine system and each of the entities therein to the state that existed before the command was initiated. In one embodiment rollback module provides instructions to database interface module causing database interface module to update the information in entity tables to reflect the undoing of the transaction. Thus the entity tables reflect the previous state of the system from before the command was initiated as well.

At block method determines if there are additional snapshots corresponding to the command. If there are additional snapshots corresponding to the command method returns to block and undoes the changes associated with the transactions for each remaining snapshot. If there are no additional snapshots method continues to block .

At block the command execution fails. Since one of the transactions suffered a crash failure or other error the command cannot be completed. The transactions associated with the command are atomic such that if they cannot all be completed successfully the remaining transactions must be undone so that the system is returned to the state before any of the transactions associated with the command were performed. At block method clears the business entity snapshots from the database. In one embodiment snapshot manager module reads snapshot table and identifies all snapshots associated with the command e.g. by scanning the command ID field of each snapshot . Snapshot manager module can delete the snapshots to make room for new snapshots as the old snapshots are no longer needed.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or Rambus DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus . Any of the signals provided over various buses described herein may be time multiplexed with other signals and provided over one or more common buses. Additionally the interconnection between circuit components or blocks may be shown as buses or as single signal lines. Each of the buses may alternatively be one or more single signal lines and each of the single signal lines may alternatively be buses.

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored one or more set of instructions e.g. software embodying any one or more of the methodologies of functions described herein. The instructions may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media. The instructions may further be transmitted or received over a network via the network interface device .

The machine readable storage medium may also be used to store instructions for database change compensation after a transaction commit as described herein. While the machine readable storage medium is shown in an exemplary embodiment to be a single medium the term machine readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. A machine readable medium includes any mechanism for storing information in a form e.g. software processing application readable by a machine e.g. a computer . The machine readable medium may include but is not limited to magnetic storage medium e.g. floppy diskette optical storage medium e.g. CD ROM magneto optical storage medium read only memory ROM random access memory RAM erasable programmable memory e.g. EPROM and EEPROM flash memory or another type of medium suitable for storing electronic instructions.

Although the operations of the methods herein are shown and described in a particular order the order of the operations of each method may be altered so that certain operations may be performed in an inverse order or so that certain operation may be performed at least in part concurrently with other operations. In another embodiment instructions or sub operations of distinct operations may be in an intermittent and or alternating manner.

