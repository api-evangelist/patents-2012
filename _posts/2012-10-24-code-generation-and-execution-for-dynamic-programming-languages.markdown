---

title: Code generation and execution for dynamic programming languages
abstract: A device receives programming code, corresponding to a dynamic programming language, that is to be executed by a computing environment, and executes the programming code. When executing the programming code, the device maintains a program counter that identifies an execution location within the programming code, and select blocks of the programming code based on the program counter. The blocks correspond to segments of the programming code, and are associated with type-based constraints that relate to types of variables that are used by the block. When executing the programming code, the device also compiles the selected blocks, caches the compiled blocks along with the type-based constraints, generates linking information between certain ones of the compiled blocks based on the type-based constraints, and executes the compiled blocks in an order based on the program counter, the type-based constraints, and the linking information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943474&OS=08943474&RS=08943474
owner: The MathWorks, Inc.
number: 08943474
owner_city: Natick
owner_country: US
publication_date: 20121024
---
This application claims priority under 35 U.S.C. 119 based on U.S. Provisional Patent Application No. 61 551 787 filed Oct. 26 2011 the disclosure of which is incorporated by reference herein in its entirety.

The accompanying drawings which are incorporated in and constitute a part of this specification illustrate one or more implementations and together with the description explain these implementations. In the drawings 

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements.

A dynamic programming language may broadly refer to a class of programming languages that may perform one or more operations at runtime that would normally be performed in a static programming language at compile time. These operations may include type checking of variables extending the behavior of program objects and or other operations.

Relative to static programming languages dynamic programming languages can provide a more flexible computing environment that may tend to decrease developer programming time. A program implemented in dynamic programming languages however frequently executes slower than a program implemented in a static programming language. Accordingly it is desirable for a computing environment that executes programs implemented using a dynamic programming language to efficiently execute the programs.

Systems and or methods described herein may generate and execute code for dynamic programming languages. For example the systems and or methods may generate code for program code provided by the dynamic programming languages. The program code may be generated a block at a time. A block may correspond to a program segment that has one entry and one or more exits. Types of values within a block may be deterministic or inferable with analysis. A block may be created for a set of types and multiple clones may be generated for a block. The clones may differ only in the types of values that the clones handle. The systems and or methods may efficiently select and link these clones for execution.

A programmer may create the program using a dynamic programming language and at some point may wish to execute the program. The programmer may initiate execution of the program through a computing environment such as a TCE or another computing environment. In one example implementation the program may be executed by segmenting the program into blocks where each block may represent a segment of the program that has one entry and one or more exits. Blocks may be selected so that within a block the types of variables within the block are deterministically known or can be inferred. Each of the blocks of the program may be compiled. In some implementations not all of the blocks of the program may be immediately compiled. For example blocks may be compiled as needed for execution of the program. In some implementations the compiled blocks may be cached so that blocks may be reused without having to be re compiled.

As further shown in the blocks may be stored in the block cache. In one example the block cache may store four blocks labeled as blocks B1 B2 B2 and B3. Each block may be associated with constraints CON beginning program counter START PC values and information about block exits EXIT INFO . The constraints for a block may represent conditions that should be satisfied before a block can be selected for execution. The conditions may be based on variables and corresponding variable types that are read within a particular block. The beginning PC values may represent a location within the program at which the block begins. The exit information may describe variables and corresponding variable types that are written within a particular block. The exit information may also include a program counter for the next block to be executed.

Multiple blocks may represent the same segment of code in the program. For example a particular segment of code in the program may read a variable X. Because the program is expressed in a dynamic programming language the type of variable X may not be determinable before execution of the program. For instance at one point during the execution of the particular segment of the program variable X may be an integer. At another point during the execution of the particular segment of the program variable X may be a real number e.g. double type . Accordingly the block cache may include multiple compilations of the particular segment of the code where the different compilations may make different assumptions about the type of variable X. The correct compiled block to use may be determined during execution of the program. In blocks B2 and B2 are shown which may represent different compilations of the same segment of the program.

During a run time operation the execution engine may execute the compiled blocks provided in the block cache. At the end of a block the next PC value in the exit information may be used to obtain a set of blocks that are next candidates to be executed. The constraints for each block in the set of blocks may be used to determine which block to execute. If no blocks are determined to be executable from the set a new block may be compiled. In the example of the execution engine is shown as having selected blocks B1 B2 and B3 as the series of blocks to execute.

In some implementations to optimize the operation of the execution engine blocks may be linked to create a series of linked blocks. A link between two blocks may indicate that a block associated with an inbound link may always follow another block associated with a corresponding outbound link. In this situation execution of the program may be made more efficient as the execution engine may not need to check the block constraints before executing the block associated with the inbound link.

The terms code program program code and or programming code as used herein are to be used interchangeably and are to be broadly interpreted to include text based code that may require further processing to execute e.g. C code Hardware Description Language HDL code very high speed integrated circuits VHSIC HDL VHDL code VERILOG JAVA and or other types of hardware or software based code that may be compiled and or synthesized binary code that may be executed e.g. executable files that may directly be executed by an operating system bitstream files that can be used to configure a field programmable gate array FPGA JAVA byte code object files combined together with linker directives source code makefiles etc. text files that may be executed in conjunction with other executables e.g. Python text files a collection of dynamic link library DLL files with text based combining configuration information that connects pre compiled modules an extensible markup language XML file describing module linkage etc. etc. In one example code may include different combinations of the above identified classes e.g. text based code binary code text files etc. . Alternatively or additionally code may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations.

Client device may include one or more devices that are capable of communicating with server device via network . For example client device may include a laptop computer a personal computer a tablet computer a desktop computer a workstation computer a smart phone a personal digital assistant PDA and or other computation and communication devices.

Server device may include one or more server devices or other types of computation and communication devices that gather process and or provide information in a manner described herein. Server device may include a device that is capable of communicating with client device e.g. via network . In one example server device may include one or more laptop computers personal computers workstation computers servers central processing units CPUs graphical processing units GPUs application specific integrated circuits ASICs field programmable gate arrays FPGAs etc. and or software e.g. a simulator executing on the aforementioned devices. In one example server device may include TCE and may perform some or all of the functionality described herein for client device . Alternatively server device may be omitted and client device may perform all of the functionality described herein for client device .

Network may include a network such as a local area network LAN a wide area network WAN a metropolitan area network MAN a telephone network such as the Public Switched Telephone Network PSTN an intranet the Internet or a combination of networks.

TCE may be provided within a computer readable medium of client device . Alternatively or additionally TCE may be provided in another device e.g. server device that is accessible by client device . TCE may include hardware or a combination of hardware and software that provides a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal etc. In one implementation TCE may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations.

For example TCE may use an array as a basic element where the array may not require dimensioning. These arrays may be used to support array based programming where an operation may apply to an entire set of values included in the arrays. Array based programming may allow array based operations to be treated as high level programming that may allow for example operations to be performed on entire aggregations of data without having to resort to explicit loops of individual non array operations. In addition TCE may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development etc. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design etc.

TCE may further provide mathematical functions and or graphical tools e.g. for creating plots surfaces images volumetric representations etc. . In one implementation TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . Alternatively or additionally TCE may provide these functions as block sets or in another way such as via a library etc.

TCE may be implemented as a text based environment e.g. MATLAB software Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence Modelica or Dymola from Dynasim etc. a graphically based environment e.g. Simulink software Stateflow software SimEvents software Simscape software etc. by The MathWorks Inc. VisSim by Visual Solutions LabView by National Instruments Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhopsody or Tau from Telelogic Ptolemy from the University of California at Berkeley aspects of a Unified Modeling Language UML or SysML environment etc. or another type of environment such as a hybrid environment that includes one or more of the above referenced text based environments and one or more of the above referenced graphically based environments.

TCE may include a programming language e.g. the MATLAB language that may be used to express problems and or solutions in mathematical notations. The programming language may be dynamically typed and or array based. In a dynamically typed array based computing language data may be contained in arrays and data types of the data may be determined e.g. assigned at program execution time.

For example suppose a program written in a dynamically typed array based computing language includes the following statements 

Now suppose the program is executed for example in a TCE such as TCE . During run time when the statement A hello is executed the data type of variable A may be a string data type. Later when the statement A int32 1 2 is executed the data type of variable A may be a 1 by 2 array containing elements whose data type are 32 bit integers. Later when the statement A 1.1 2.2 3.3 is executed since the language is dynamically typed the data type of variable A may be changed from the above 1 by 2 array to a 1 by 3 array containing elements whose data types are floating point. As can be seen by this example data in a program written in a dynamically typed array based computing language may be contained in an array. Moreover the data type of the data may be determined during execution of the program. Thus in a dynamically type array based computing language data may be represented by arrays and data types of data may be determined at run time.

TCE may provide mathematical routines and a high level programming language suitable for non professional programmers and may provide graphical tools that may be used for creating plots surfaces images volumetric representations or other representations. TCE may provide these routines and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . TCE may also provide these routines in other ways such as for example via a library local or remote database e.g. a database operating in a computing cloud remote procedure calls RPCs and or an application programming interface API . TCE may be configured to improve runtime performance when performing computing operations. For example TCE may include a just in time JIT compiler.

Although shows example components of environment in other implementations environment may include fewer components different components differently arranged components and or additional components than those depicted in . Alternatively or additionally one or more components of environment may perform one or more other tasks described as being performed by one or more other components of environment .

Processing unit may include one or more processors microprocessors or other types of processing units that may interpret and execute instructions. Main memory may include one or more random access memories RAMs or other types of dynamic storage devices that may store information and or instructions for execution by processing unit . ROM may include one or more ROM devices or other types of static storage devices that may store static information and or instructions for use by processing unit . Storage device may include a magnetic and or optical recording medium and its corresponding drive.

Input device may include a mechanism that permits a user to input information to device such as a keyboard a camera an accelerometer a gyroscope a mouse a pen a microphone voice recognition and or biometric mechanisms a remote control a touch screen a neural interface etc. Output device may include a mechanism that outputs information to the user including a display a printer a speaker etc. Communication interface may include any transceiver like mechanism that enables device to communicate with other devices networks and or systems. For example communication interface may include mechanisms for communicating with another device or system via a network.

As described herein device may perform certain operations in response to processing unit executing software instructions contained in a computer readable medium such as main memory . A computer readable medium may be defined as a non transitory memory device. A memory device may include space within a single physical memory device or spread across multiple physical memory devices. The software instructions may be read into main memory from another computer readable medium such as storage device or from another device via communication interface . The software instructions contained in main memory may cause processing unit to perform processes described herein. Alternatively hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus implementations described herein are not limited to any specific combination of hardware circuitry and software.

Although shows example components of device in other implementations device may include fewer components different components differently arranged components and or additional components than depicted in . Alternatively or additionally one or more components of device may perform one or more other tasks described as being performed by one or more other components of device .

Block diagram editor may include hardware or a combination of hardware and software that may be used to graphically specify models of dynamic systems. In one implementation block diagram editor may permit a user to perform actions such as construct edit display annotate save and or print a graphical model e.g. a block diagram that visually and or pictorially represents a dynamic system . In another implementation block diagram editor may permit a user to create and or store data relating to graphical entities .

A textual interface may be provided to permit interaction with block diagram editor . A user may write scripts that perform automatic editing operations on a model using the textual interface. For example the textual interface may provide a set of windows that may act as a canvas for the model and may permit user interaction with the model. A model may include one or more windows depending on whether the model is partitioned into multiple hierarchical levels.

Graphical entities may include hardware or a combination of hardware and software that may provide entities e.g. signal lines buses etc. that represent how data may be communicated between functional and or non functional units and blocks of a model. Blocks may include fundamental mathematical elements of a block diagram model.

Execution engine may include hardware or a combination of hardware and software that may process a graphical model to produce simulation results may convert the graphical model into executable code and or may perform other analyses and or related tasks. In one implementation for a block diagram graphical model execution engine may translate the block diagram into executable entities e.g. units of execution following the layout of the block diagram. The executable entities may be compiled and or executed on a device e.g. client device to implement the functionality specified by the model.

Graphical models may include entities with relationships between the entities and the relationships and or the entities may have attributes associated with them. The entities may include model elements such as blocks and ports. The relationships may include model elements such as lines e.g. connector lines and references. The attributes may include model elements such as value information and meta information for the model element associated with the attributes. Graphical models may be associated with configuration information. The configuration information may include information for the graphical model such as model execution information e.g. numerical integration schemes fundamental execution period etc. model diagnostic information e.g. whether an algebraic loop should be considered an error or result in a warning model optimization information e.g. whether model elements should share memory during execution model processing information e.g. whether common functionality should be shared in code that is generated for a model etc.

Additionally or alternatively a graphical model may have executable semantics and or may be executable. An executable graphical model may be a time based block diagram. A time based block diagram may consist for example of blocks e.g. blocks connected by lines e.g. connector lines . The blocks may consist of elemental dynamic systems such as a differential equation system e.g. to specify continuous time behavior a difference equation system e.g. to specify discrete time behavior an algebraic equation system e.g. to specify constraints a state transition system e.g. to specify finite state machine behavior an event based system e.g. to specify discrete event behavior etc. The lines may represent signals e.g. to specify input output relations between blocks or to specify execution dependencies between blocks variables e.g. to specify information shared between blocks physical connections e.g. to specify electrical wires pipes with volume flow rigid mechanical connections etc. etc. The attributes may consist of meta information such as sample times dimensions complexity whether there is an imaginary component to a value data type etc. associated with the model elements.

In a time based block diagram ports may be associated with blocks e.g. blocks . A relationship between two ports may be created by connecting a line e.g. a connector line between the two ports. Lines may also or alternatively be connected to other lines for example by creating branch points. For instance three or more ports can be connected by connecting a line to each of the ports and by connecting each of the lines to a common branch point for all of the lines. A common branch point for the lines that represent physical connections may be a dynamic system e.g. by summing all variables of a certain type to 0 or by equating all variables of a certain type . A port may be an input port an output port an enable port a trigger port a function call port a publish port a subscribe port an exception port an error port a physics port an entity flow port a data flow port a control flow port etc.

Relationships between blocks e.g. blocks may be causal and or non causal. For example a model may include a block that represents a continuous time integration block that may be causally related to a data logging block by using a line e.g. a connector line to connect an output port of the continuous time integration block to an input port of the data logging block. Further during execution of the model the value stored by the continuous time integrator may change as the current time of the execution progresses. The value of the state of the continuous time integrator may be available on the output port and the connection with the input port of the data logging block may make this value available to the data logging block.

A sample time may be associated with the elements of a graphical model. For example a graphical model may include a block e.g. block with a continuous sample time such as a continuous time integration block that may integrate an input value as time of execution progresses. This integration may be specified by a differential equation. During execution the continuous time behavior may be approximated by a numerical integration scheme that is part of a numerical solver. The numerical solver may take discrete steps to advance the execution time and these discrete steps may be constant during an execution e.g. fixed step integration or may be variable during an execution e.g. variable step integration .

Alternatively or additionally a graphical model may include a block e.g. block with a discrete sample time such as a unit delay block that may output values of a corresponding input after a specific delay. This delay may be a time interval and this interval may determine a sample time of the block. During execution the unit delay block may be evaluated each time the execution time has reached a point in time where an output of the unit delay block may change. These points in time may be statically determined based on a scheduling analysis of the graphical model before starting execution.

Alternatively or additionally a graphical model may include a block e.g. block with an asynchronous sample time such as a function call generator block that may schedule a connected block to be evaluated at a non periodic time. During execution a function call generator block may evaluate an input and when the input attains a specific value when the execution time has reached a point in time the function call generator block may schedule a connected block to be evaluated at this point in time and before advancing execution time.

Further the values of attributes of a graphical model may be inferred from other elements of the graphical model or attributes of the graphical model. For example the graphical model may include a block e.g. block such as a unit delay block that may have an attribute that specifies a sample time of the block. When a graphical model has an execution attribute that specifies a fundamental execution period the sample time of the unit delay block may be inferred from this fundamental execution period.

As another example the graphical model may include two unit delay blocks e.g. blocks where the output of the first of the two unit delay blocks is connected to the input of the second of the two unit delay block. The sample time of the first unit delay block may be inferred from the sample time of the second unit delay block. This inference may be performed by propagation of model element attributes such that after evaluating the sample time attribute of the second unit delay block a graph search proceeds by evaluating the sample time attribute of the first unit delay block since it is directly connected to the second unit delay block.

The values of attributes of a graphical model may be set to characteristics settings such as one or more inherited settings one or more default settings etc. For example the data type of a variable that is associated with a block e.g. block may be set to a default such as a double. Because of the default setting an alternate data type e.g. a single an integer a fixed point etc. may be inferred based on attributes of elements that the graphical model comprises e.g. the data type of a variable associated with a connected block and or attributes of the graphical model. As another example the sample time of a block may be set to be inherited. In case of an inherited sample time a specific sample time may be inferred based on attributes of elements that the graphical model comprises and or attributes of the graphical model e.g. a fundamental execution period .

Although shows example functional components of TCE in other implementations TCE may include fewer functional components different functional components differently arranged functional components and or additional functional components than depicted in . Alternatively or additionally one or more functional components of TCE may perform one or more other tasks described as being performed by one or more other functional components of TCE .

Compiler may transform an input program written in a dynamic programming language e.g. a source language into a second programming language which may be referred to as a target language. Compiler may compile program in a piecemeal fashion in which segments of program e.g. program segments are compiled on the fly and as needed for program execution. The target language may include a binary form that is designed to execute on a particular processor or hardware platform. In one example implementation compiler may first convert program into an intermediate representation IR that may then be converted into the target language. Although the operations of are described for clarity as being applied to program written in a dynamic programming language the operations of may also be applied to intermediate representation of program . In this situation program may be converted into the intermediate representation by compiler or by another component such as a pre compiler not shown . The pre compiler may then input the intermediate representation as program segments to compiler .

Each program segment after compiling by compiler may be referred to as a block or a compiled block herein. A block may include one entry and one or more exits. Blocks may be selected so that types of variables and or temporary values within the block are deterministically known or can be inferred. For example an abstract interpretation technique may be used to determine the types of variables and or temporary values within the blocks. In one example implementation occurrences of loops or other programmatic control flows may terminate a block. In such an example each block may represent a linear sequence of program instructions for which abstract interpretation can be performed. Statements that cannot be abstractly interpreted may terminate a block. Compiler may provide the compiled blocks to cache .

Cache may receive and store the compiled blocks as indicated by reference number . Cache may include for example a data structure stored in a memory such as volatile or non volatile computer memory. Blocks stored in cache may be associated with a program counter value at which a block occurs and may also be associated with constraints that define conditions that should be satisfied before a block can be executed. Linking information that defines links between blocks may also be associated with blocks . In one example implementation the constraints and the linking information may be stored as part of each block and the program counter may be used as an index by which blocks are stored in cache . Thus for any particular program counter value a corresponding set of blocks in cache may be obtained.

As compiler compiles blocks a quantity of blocks in cache may increase. If execution of program results in a previously executed block being executed a second or additional time the previously executed block may be obtained from cache without having to be re compiled by compiler . In one example implementation blocks in cache that are no longer valid such as blocks for which the associated type based constraints are rendered incomplete or are otherwise no longer valid based on a current state of the computing environment may be removed from cache . For example when a user e.g. a programmer indicates that a new or different program is to be executed cache may be cleared. Alternatively or additionally cache may continue to store blocks corresponding to program for efficient future execution of program .

Constraint analyzer may determine run time information e.g. read and write lists for blocks in cache . For example constraint analyzer may determine the read and write lists for a block based on interaction with compiler and while compiler is compiling block . As used herein a read list for a block may refer to variables that are read by block and corresponding types of the variables that are read. Similarly as used herein a write list for a block may refer to variables that are written by block and corresponding types of the variables that are written.

In one example implementation constraint analyzer may determine the read and write lists for a block based on abstract interpretation of types. Abstract interpretation may refer to an approximation of semantics of program code without executing or without fully executing the program code. Constraint analyzer may perform abstract interpretation based on a predefined association of functions input types to the functions and a corresponding result output type. For example consider the program code 

In one example implementation program may include pointer variables. The pointer variables may be aliased so that multiple different pointer variables can point to a single location. For example if two pointer variables x and y are aliased to one another changing a type of one of the variables may correspondingly change a type of the other variable. For example consider the pointer variables 

The read list for a block may correspond to initial constraints for block . In one example implementation the read list and the initial constraints for block may be based only on variables that are within a lexical scope at the start of block . Lexical scope may refer to a context within program code in which a variable name is valid and can be used. Block boundaries may be selected so that lexical scope changes are only allowed at block boundaries.

Constraint checker may verify run time types of variables. Constraint checker may for example communicate with execution engine and or be implemented as part of execution engine to determine actual types in an execution environment of variables in program code being executed by execution engine . Constraint checker may additionally determine whether the actual types of variables in the executing program code match constraints associated with blocks . Block may be executed by execution engine when variables in a read list of block include the same types in a current program state as the variables had in a program state when block was compiled by compiler .

Link manager may manage links between blocks . In one example implementation link manager may analyze blocks to determine links between blocks . The links may be used to define relationships between blocks such as whether a particular block is guaranteed or likely to follow another block . The links between blocks may be used to reduce an amount of constraint checking that may otherwise be required to determine a next block to execute. The use of links may optimize the selection of blocks and may therefore improve execution efficiency of program .

Execution engine may execute program by executing blocks . Execution engine may for example read blocks from cache in an order corresponding to a program flow of program . Execution engine may maintain a program counter PC which may include a value that defines a current execution point in program . As will be described in more detail below program counter may be used in determining which block is next in the execution of program .

Although shows example functional components of TCE in other implementations TCE may include fewer functional components different functional components differently arranged functional components and or additional functional components than depicted in . Alternatively or additionally one or more functional components of TCE may perform one or more other tasks described as being performed by one or more other functional components of TCE .

Compiled block code may include a compiled version of the program segment corresponding to block after compiling by compiler . Start PC value may indicate a starting location of block within program . Constraints may include constraints for block such as for example type constraints relating to variables or temporary values that are read by block . When block is not linked constraints may correspond to a read list for block as may be determined by constraint analyzer .

Exit information may include information about one or more exits of block . The information for an exit may include the starting PC for the next program segment if the next segment is known. The information for an exit may also include a description of the types of variables or temporary values that are guaranteed to be written by block .

Linking information may include links if any corresponding to block . The links for block may be generated and or determined by link manager . In one example implementation the links for block may be stored as one or more outbound links from block to other blocks. In this situation the other blocks may be blocks that are known to follow or that are good candidates to follow block . A link may indicate that a linked to block s constraints are guaranteed to be satisfied following block . In one example implementation the links may include direct links or indirect links. A direct link may be created when the starting PC of the next block is known and available in exit information and an indirect link may be used when the starting PC of the next block is not available in exit information . The processing of direct and indirect links is described in more detail below.

Although shows example information that may be included in block in other implementations block may include less information different information differently arranged information and or additional information than depicted in .

Block B1 may include three lines of program code . A first line of block B1 PC value 10 may write one variable t which is of type int32. A second line of block B1 PC value 11 may read one variable x which is of type int32 and may write a variable y which is also of type int32. A third line of block B1 PC value 12 may write one variable x which is of type double. As illustrated in a complete read list for block B1 may be which may indicate that the variable x in function foo is of type int32. A write list for block B1 may be . Start PC for block B1 may have a value of 10. Block B1 may have one exit exit information that contains a next PC with a value of 13 and the write list . 

Block B2 may include one line of code PC value 13 which reads two variables and writes one variable. A read list for block B2 may be and a write list for block B2 may be . Start PC for block B2 may have a value of 13. Block B2 may have one exit exit information that contains a next PC with a value of 14 and the write list . 

As described above in connection with constraints for a block may be based on the read list for block . In the example of constraints for block B1 may be and constraints for block B2 may be . In one example implementation constraints for a block may be modified such as by link manager as block is linked to other blocks.

Although shows example information that may be included in blocks in other implementations blocks may include less information different information differently arranged information and or additional information than depicted in .

As shown in process may include setting a program counter PC equal to a start value block and determining whether execution of a program is complete block . For example with reference to execution engine may set PC to a program counter value corresponding to a first statement that is executed in program . Execution engine may determine that program is complete when for example PC is assigned a value that corresponds to a termination point in program such as an end statement within a main loop of program .

As further shown in when execution of the program is determined to be complete block YES process may end block . When execution of the program is not complete block NO process may include locating blocks corresponding to a program counter PC in a cache block . For example with reference to execution engine may stop executing program when the execution of program is determined to be complete. In one example a value of PC may be used to lookup zero or more blocks from cache in which a starting PC value of blocks match the value of PC . In some situations no blocks may match the value of PC . For instance a first time a particular block is reached during execution of program the particular block may not be in cache . In some situations multiple blocks each having different sets of constraints may be located in cache .

Returning to process may include checking whether constraints corresponding to the located blocks if any are compatible with values corresponding to a current computing environment of the program block . For example with reference to constraint checker may determine actual types of variables and or temporary values in the program being executed by execution engine and may compare type based constraints in blocks to the actual types in the computing environment. If all the type based constraints for a particular block are satisfied by the actual types in the computing environment the particular block may be deemed to be a compatible block. In one example consider a block with a single constraint that includes a condition that a variable x is of type double. If the variable x in the current computing environment is of type double block may be considered a compatible block. If the variable x is of any other type block may not be considered to be a compatible block.

As further shown in process may include determining whether a compatible block is found block . When a compatible block is not found block NO such as when no blocks are located e.g. in block or when blocks are located but none of the located blocks are compatible with the current computing environment e.g. as determined in block process may include compiling a block corresponding to the current program counter block adding the compiled block to the cache block and returning to block . For example with reference to compiler may receive a program segment from program corresponding to a next block in program . Compiler may compile the next block. After compiling the next block compiler may store the next block in cache . Alternatively or additionally compiler may transmit the block directly to execution engine .

Returning to when a compatible block is found block YES such as when at least one block is located e.g. in block and the type based constraints are compatible with the current computing environment e.g. as determined in block process may include linking the compatible block the last executed block block . For example with reference to link manager may determine direct links and or indirect links between blocks . A link between a first block and a second block may indicate that when constraints of the first block are satisfied the constraints of the second block may also be satisfied. Additional details relating to the determination and use of direct and indirect links is described in more detail below.

As further shown in process may include executing the compatible block and based on exit information additional linked blocks block setting the program counter value equal to the next program counter value at the end of the last executed block block and returning to block . For example with reference to based on links associated with the compatible block one or more additional linked blocks may be subsequently executed e.g. by execution engine without having to perform additional constraint checking Alternatively or additionally the one or more additional linked blocks may be subsequently executed with a less complex constraint checking procedure relative to a block that is not associated with a link. After execution of a block execution engine may set PC to a next PC value. In one example the next PC value may be a next PC value relative to a last executed block .

As further shown in block B1 may be initially associated with a read list . The read list for block B1 may correspond to initial constraints for block B1. Block B2 may be initially associated with a read list . The read list for block B2 may correspond to initial constraints for block B2.

In general a direct link between two blocks may be created by link manager when a next program counter value after a block is known at compile time. In this case a direct link can be created between a first block and a next block that has a starting program counter value equal to the next program counter value after the first block . For blocks B1 and B2 code corresponding to block B2 is in the same lexical scope as code corresponding to block B1 since both blocks B1 and B2 include the function foo. Block B2 follows block B1 as the start PC of block B2 PC2 is the same as the next PC in the exit information of block B1. Accordingly link manager may create a direct link between blocks B1 and B2 as shown in .

Because blocks B1 and B2 are directly linked and are within the same lexical scope as one another link manager may back propagate constraints from block B2 to block B1. Back propagating constraints may refer to adding a constraint from a later block in a series of directly linked blocks to an earlier block . In one example implementation constraints may be back propagated from a directly linked next block to a previous block whenever a constraint in the next block is not in a write list of the previous block . In the example of the constraint may be back propagated from block B2 to block B1. The constraint however which is included in the write list of block B1 see may not be back propagated as the type of variable x is guaranteed for block B2. As shown in after back propagation constraints for block B1 may be and constraints for block B2 may remain . 

Since the constraint of block B1 may change after back propagation any previously established incoming links to block B1 may become invalid. In one example implementation such incoming links to block B1 may be disconnected by link manager . Alternatively or additionally a strengthened constraint of block B1 may be further back propagated through incoming links to any block linked to block B1.

In some implementations a second block that follows a first block may be directly linked even when the first and second blocks are of a different lexical scope. In particular when constraints of the second block are satisfied by a write list of the first block link manager may create a direct link from the first block to the second block . This situation may correspond to a call to a function where a target function is known at compile time.

In some situations link manager may create indirect links between blocks. An indirect link may be used in the situation in which a next program counter value cannot be determined at compile time. An example of an indirect link may be a situation that corresponds to a last block in a called function. The last block may be indirectly linked to the calling function after the return from the called function.

Although shows example operations associated with direct links in other implementations direct links may be created using additional operations and or different operations than depicted in .

When a next PC is not known at a block exit an indirect link may be created from the exit to a next block. The next PC may be unknown in the last block of a function when execution returns to a caller function or when calling a variable function. In these situations indirect links may be created through a stub such as indirect link stub . Indirect link stub may be similar to a block but may not include a start PC and constraints. Indirect link stub may include linking information LI exit information and service code that performs additional tasks such as checking for dirty bits. The code that exits the block may locate indirect link stub at a predetermined place e.g. at a top of an execution stack and may go to the next block following a link that is contained in indirect link stub .

Program variables may exist in a certain scope. For example a variable x in a function foo may exist in the scope of the function foo since x is written and read in that scope. Sometimes values may be passed from one scope to another. For example when calling a function an input value may be written in the scope of a caller and may be read e.g. as a different variable in a scope of a callee. Similarly on return from a function the callee may write a return value in the callee s scope and the caller may read the return value as a different variable in the caller s scope. When creating a link from a first block in one scope to a second block in a different scope a symbolic variable may be used to capture a type of a value being passed between the different scopes. A write list in exit information of the first block may include a pair of symbolic variables and a type at which the symbolic variable was written. A read list of the second block may include a pair of symbolic variables and a type at which the symbolic variable was read.

During execution of a program there may be situations in which a current scope changes. For example when executing a function foo active variables may be in the scope of foo. When foo calls another function bar the scope of variables may change to the scope of bar. When bar finishes execution and returns the scope of variables may change back to the scope of foo. 

When the function bar is called there may be no pre existing values in the scope of bar. A first block of bar may read the input values and may read variables captured in the first block s constraint through a symbolic variable. However after bar returns to foo pre existing variables of foo may become visible again and a block of foo following the return may read the pre existing variables. This may make the types of the pre existing variables a constraint on a compiled block. If a language supports closures a call to a closure may result in entering a scope with pre existing values.

When linking blocks that execute in different scopes constraints of a second block may not be back propagated to a first block since it would result in constraints that are out of scope. However constraints from the second block may be back propagated to a previous block that puts a stub in a pre determined location. In the example above that may be the block of foo that ends with the call to bar. Alternatively or additionally a need for back propagation may be eliminated by putting all in scope variables in a constraint of a block that puts a stub in a pre determined location. Alternatively or additionally serial numbers may be used to track a state of the execution environment.

If a language allows changing out of scope variables back propagating block constraints may not be sufficient to guarantee the types of pre existing values. Dirty bits or flags which may be checked during execution may be used to capture any type change of an out of scope variable. Any language construct that changes the type of an out of scope value may set a dirty bit for the scope to which that value belongs. A link that enters a scope with pre existing values may check whether the dirty bit is set. If the dirty bit is set the link may not be followed but the state of values may be revalidated in the execution environment. At this time link manager may create a new link based on the current execution environment or may forego the creation of the new link.

Although shows example operations associated with checked links and indirect link stubs in other implementations checked links and indirect link stubs may be created using additional operations and or different operations than depicted in .

Systems and or methods described herein may generate and execute code for dynamic programming languages. For example the systems and or methods may generate code for program code provided by the dynamic programming languages. The program code may be generated a block at a time. A block may correspond to a program segment that includes one entry one or more exits and types of values that are deterministic and inferable with trivial analysis. A block may be created for a set of types and multiple clones may be generated for a block. The clones may differ only in the types of values that the clones handle. The systems and or methods may efficiently select and link these clones for execution.

The foregoing description of implementations provides illustration and description but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the implementations.

For example while a series of blocks has been described with regard to the order of the blocks may be modified in other implementations. Further non dependent blocks may be performed in parallel.

It will be apparent that example aspects as described above may be implemented in many different forms of software firmware and hardware in the implementations illustrated in the figures. The actual software code or specialized control hardware used to implement these aspects should not be construed as limiting. Thus the operation and behavior of the aspects were described without reference to the specific software code it being understood that software and control hardware could be designed to implement the aspects based on the description herein.

Further certain portions of the implementations may be implemented as a component that performs one or more functions. This component may include hardware such as a processor an application specific integrated circuit ASIC or a field programmable gate array FPGA or a combination of hardware and software.

Even though particular combinations of features are recited in the claims and or disclosed in the specification these combinations are not intended to limit the disclosure of the specification. In fact many of these features may be combined in ways not specifically recited in the claims and or disclosed in the specification. Although each dependent claim listed below may directly depend on only one other claim the disclosure of the specification includes each dependent claim in combination with every other claim in the claim set.

No element act or instruction used in the present application should be construed as critical or essential unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

