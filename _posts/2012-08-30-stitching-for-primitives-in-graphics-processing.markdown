---

title: Stitching for primitives in graphics processing
abstract: Techniques described in the disclosure are generally related to determining the manner in which to connect points that reside along an outer ring edge and an inner ring edge for purposes of tessellation. For example, a two-dimensional (2D) stitching table may define the manner in which points along the edges should be connected together to form a plurality of primitives. The techniques may index the 2D stitching table to retrieve entry values that define the manner in which the points along the edges should be connected together.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09076260&OS=09076260&RS=09076260
owner: QUALCOMM Incorporated
number: 09076260
owner_city: San Diego
owner_country: US
publication_date: 20120830
---
This disclosure relates to stitching for primitives in graphics processing and more particularly to stitching with tessellation.

A graphics processing unit GPU may implement a graphics processing pipeline that includes a tessellation stage. The tessellation stage converts a surface into a plurality of primitives on the GPU resulting in a more detailed surface. For example the GPU can receive information for a coarse surface and generate a high resolution surface rather than receiving information for the high resolution surface. Receiving information for the high resolution surface rather than the coarse surface may be bandwidth inefficient because the amount of information needed to define the high resolution surface may be much greater than the amount of information needed to define coarse resolution surface.

In general the techniques described in this disclosure are directed to utilizing a single two dimensional 2D lookup table LUT for determining the manner in which primitives are to be stitched. For example the index to the 2D LUT may be based on tessellation factors that indicate the manner in which to generate the primitives. A tessellation unit may index the 2D LUT based on the tessellation factors to retrieve an entry value. The tessellation unit may examine each bit in the entry value to determine the manner in which to stitch points that reside along an outer ring edge and a corresponding inner ring edge.

In one example this disclosure describes a method for tessellation. The method includes determining with a graphics processing unit GPU a number of points along an outer ring edge of a domain and determining with the GPU a number of points along an inner ring edge of the domain. The method also includes utilizing with the GPU based on the number of points along the outer ring edge and the number of points along the inner ring edge only a single two dimensional 2D stitching table to determine how many points and which points of the outer ring edge and how many points and which points of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge and outputting with the GPU coordinates of the vertices.

In one example this disclosure describes a tessellation unit for a GPU. The tessellation unit includes a first unit configured to determine a number of points along an outer ring edge of a domain and determine a number of points along an inner ring edge of the domain. The tessellation unit also includes a second unit configured to utilize based on the number of points along the outer ring edge and the number of points along the inner ring edge only a single two dimensional 2D stitching table to determine how many points and which points of the outer ring edge and how many points and which points of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge and output coordinates of the vertices.

In one example this disclosure describes a device that includes a central processing unit CPU and a GPU. The CPU is configured to generate a patch to be tessellated. The GPU includes a first unit configured to receive the patch as an input patch and output control points and tessellation factors for an output patch based on the input patch. The GPU also includes a tessellation unit configured to determine a type of a domain based on the tessellation factors determine a number of points along an outer ring edge of the domain based on the tessellation factors determine a number of points along an inner ring edge of the domain based on the tessellation factors utilize based on the number of points along the outer ring edge and the number of points along the inner ring edge only a single two dimensional 2D stitching table to determine how many points and which points of the outer ring edge and how many points and which points of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge and output coordinates of the vertices. The GPU also includes a second unit configured to receive the coordinates of the vertices and add the primitives to the output patch based on the received coordinates of the vertices.

In one example this disclosure describes a tessellation unit for a GPU. The tessellation unit includes means for determining a number of points along an outer ring edge of a domain and means for determining a number of points along an inner ring edge of the domain. The tessellation unit also includes means for utilizing based on the number of points along the outer ring edge and the number of points along the inner ring edge only a single two dimensional 2D stitching table to determine how many points and which points of the outer ring edge and how many points and which points of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge and means for outputting coordinates of the vertices.

In one example this disclosure describes a computer readable storage medium including instructions stored thereon that when executed cause one or more processors to determine a number of points along an outer ring edge of a domain determine a number of points along an inner ring edge of the domain utilize based on the number of points along the outer ring edge and the number of points along the inner ring edge only a single two dimensional 2D stitching table to determine how many points and which points of the outer ring edge and how many points and which points of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge and output coordinates of the vertices.

The details of one or more examples are set forth in the accompanying drawings and the description below. Other features objects and advantages will be apparent from the description and drawings and from the claims.

Modern mobile devices such as laptop computer tablet computers smartphones and digital media players may include a CPU Central Processing Unit a graphics processing unit GPU and system memory. When rendering graphics as part of executing an application the CPU transmits instructions and graphics data to the GPU. In some examples the graphics data may be in the form of vertices which may comprise one or more data structures that describes a point in 2D or 3D space.

The application executing on the CPU may communicate with the GPU in accordance with an application programming interface API . For instance the application may communicate with the GPU in accordance with the DirectX API developed by Microsoft or the OpenGL API developed by the Khronos Group as two examples. For purposes of illustration and to ease with understanding the techniques described in this disclosure are generally described in the context of the DirectX and OpenGL APIs. However aspects of this disclosure should not be considered limited to the DirectX and OpenGL APIs and the techniques described in this disclosure may be extended to other APIs as well.

DirectX and OpenGL each define graphics processing pipelines that are to be implemented by a GPU. These graphics processing pipelines may include a combination of programmable stages as well as fixed function stages. Some recent versions of the APIs such as the Direct3D 11 API and the OpenGL 4.x API include a tessellation process that is to be performed by the GPU.

The tessellation process refers to dividing a portion referred to as patch of a surface of an object into a plurality of smaller portions and interconnecting the smaller portions together. This results in a more highly detailed surface as compared to the surface prior to tessellation. Tessellation allows the application executing on the CPU to define the surface with low resolution which may require few points and allows the GPU to generate a higher resolution surface.

With tessellation computation efficiency may be realized because the application executing on the CPU may not need to generate the higher resolution surface and may instead offload the generation the higher resolution surface to the GPU. Furthermore bandwidth efficiency may also be realized because the CPU may need to transmit information for fewer points of the surface because the low resolution surface includes fewer points as compared to the higher resolution surface and the GPU may need to retrieve fewer points of the surface.

As described above the GPU applies the tessellation process to a patch. A patch may be considered as a specialized type of a primitive. A patch is defined by one or more control points that together form a portion of a surface. For example an object such as a sphere may be divided into a plurality of surfaces. In this example the surfaces may be curved surfaces that when combined form the sphere. Each one of the surfaces may be divided into one or more patches where each of the patches is defined by one or more control points.

The control points may be defined by coordinates e.g. x and y coordinates for two dimensional patches or x y and z coordinates for three dimensional patches and the control points may be considered as vertices of the patch. There may be any number of control points in a patch. For instance in some examples the number of control points in a patch may be between one control point up to 32 control points. The number of control points in a patch may be fixed or user defined.

Unlike other primitive types the control points within the patches may be connected to one another in any way. In other words there is no predefined way in which the control points of the patches are connected. For example a standard triangle primitive includes three vertices and the primitive is defined with a specific way in which the three vertices are connected with one another to form the triangle. The control points on the other hand may not need to be connected in any specific way to form a shape. Rather as one example some control points in a patch may be connected with one another to form a triangle other control points in the same patch may be connected with one another to form a rectangle and yet other control points in the same patch may be connected with one another to form an octagon. As another example it may be possible that the control points are connected with another to form the same type of shapes as well e.g. connected to only form a plurality of triangles .

The control points that define a patch of a surface may define a low resolution surface. With the tessellation process additional detail is added to create a higher resolution surface. For example referring back to the example of the sphere. If only the control points were used to form the sphere the sphere would appear jaggy with stair step like points rather than a smooth curved surface. After tessellation additional points are added such that when these points are connected the sphere appears as if it is a smooth sphere.

The tessellation process in accordance with the both the DirectX API and the OpenGL 4.x API includes two shaders and a fixed function unit. A shader is a software application that executes on a programmable shader core of the GPU and provides substantial functional flexibility. The fixed function unit is a hardwired logic unit that performs fixed functions and may not provide functional flexibility. However it may be possible to implement the functions of the fixed function unit using a programmable shader coder to provide additional functional flexibility. Solely for purposes of illustration the functions described in this disclosure for the fixed function unit are described with a fixed function unit that provides limited functional flexibility.

In the DirectX API a graphics processing pipeline that is configured to implement the tessellation process includes a hull shader stage coupled to a tessellation stage which is coupled to a domain shader stage. The hull shader stage and the domain shader stage in the DirectX API may form the two shaders of the tessellation process and the tessellation stage may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline are similar to those in DirectX APIs that do not implement the tessellation process.

In the OpenGL 4.x API a graphics processing pipeline that is configured to implement the tessellation process includes a tessellation control shader coupled to a primitive generator which is coupled to a tessellation evaluation shader. The tessellation control shader and the tessellation evaluation shader in OpenGL 4.x may form the two shaders of the tessellation process and the primitive generator may form the fixed function unit of the tessellation process. The other stages in the graphics processing pipeline may be similar to those in OpenGL APIs that do not implement the tessellation process.

The techniques described in this disclosure are related generally to the fixed function unit of the tessellation process e.g. the tessellation stage of the DirectX graphics processing pipeline and the primitive generator of the OpenGL 4.x graphics processing pipeline . For purposes of brevity the fixed function unit of the tessellation process is referred to as a tessellation unit. For instance examples of the tessellation unit include the tessellation stage of the DirectX graphics processing pipeline the primitive generator of the OpenGL 4.x graphics processing pipeline or any other analogous unit for other types of graphics processing pipelines.

As described in more detail the shader preceding the tessellation unit e.g. the hull shader stage in DirectX or the tessellation control shader in OpenGL 4.x transmits values to the tessellation unit that indicate how many primitives are to be generated for the patch to increase the resolution i.e. increase the detail of the patch. The shader preceding the tessellation unit also transmits a domain type to the tessellation unit. The tessellation unit divides a domain into the primitives and indicates the manner in which the primitives in the domain are to be connected i.e. the manner in which the primitives in the domain are to be stitched .

The domain is a template shape that the tessellation unit divides into a plurality of primitives. It is these primitives that are then added to the patch to increase the resolution of patch. For example the additional primitives generated in the domain are then used to form a mesh on the patch thereby adding detail to the patch.

The shader subsequent to the tessellation unit e.g. the domain shader in DirectX or the tessellation evaluation shader in OpenGL 4.x receives the vertices of the primitives generated by the tessellation unit and connectivity information for the vertices from the tessellation unit. The shader subsequent to the tessellation unit then adds the primitives as generated by the tessellation unit to the patch to add more resolution to the surface.

In accordance with techniques described in this disclosure the tessellation unit may utilize a single two dimensional 2D look up table to determine the manner in which the generated primitives are to be connected i.e. stitched . For example there may be fixed pre defined ways in which the primitives are to be stitched based on various factors such as how many primitives the tessellation unit is to generate. Rather than using multiple look up tables to determine how to stitch the primitives the techniques described in this disclosure provide for a single two dimensional look up table to which the tessellation unit refers for purposes of determining how to stitch the primitives.

For example some other techniques that rely upon multiple look up tables expend computational cycles determining whether or not a value from a table is to be used. For instance computational cycles may be wasted in some of these other techniques in reading bits from the table determining whether the bits are to be used and then reading next bits if the read bits are not be used. Then in these other techniques computational cycles would be further wasted in determining which other table to use. By using a single two dimensional look up table to determine how to stitch the primitives computational efficiency may be promoted.

Stitching may be considered as the process of connecting vertices together to form primitives. For example as part of the tessellation process the tessellation unit may determine points within the domain. These points form vertices of the primitives. Stitching refers to the process of determining which of these points should be used to generate a primitive within the domain.

As described in more detail the tessellation unit may index the single 2D lookup table based on values determined by the preceding shader. For example to indicate how many primitives the tessellation unit is to generate the preceding shader may indicate the number of points that reside along an edge of an outer ring of the domain and a number of points that reside along an edge of an inner ring of the domain. The tessellation unit may utilize these values as indices to the single 2D lookup table.

From these indices the tessellation unit may retrieve an entry value from the 2D lookup table. Hence different combinations of numbers of points along the edge of the outer edge and inner ring of a domain may yield different entry values from the LUT. The entry value may include a plurality of bits such as 64 bits as one non limiting example. The tessellation unit may determine the bit value of one or more bits of the entry value. For example the tessellation unit may start from the least significant bit LSB and move to the most significant bit MSB or vice versa or in any predefined pattern within the value. Each bit value may indicate how many points the tessellation unit is to use from the outer edge and how many points the tessellation unit is to use from the inner edge for stitching.

In this manner the tessellation unit may need to access a single look up table rather than multiple look up tables to determine the manner in which the primitives are to be stitched. This may result in fewer accesses to memory where the look up table is stored as compared to when multiple look up tables are needed which promotes efficient bandwidth utilization. Furthermore by utilizing only one look up table and not any other look up table for stitching computational efficiency may also be realized. For instance the techniques described in this disclosure may result in requiring fewer bits to be read as well as a reduction in computational cycles needed to determine which table to retrieve values from.

CPU may execute various types of applications. Examples of the applications include web browsers e mail applications spreadsheets video games or other applications that generate viewable objects for display. Instructions for execution of the one or more applications may be stored within system memory . CPU may transmit graphics data of the generated viewable objects to GPU for further processing.

For example GPU may be specialized hardware that allows for massive parallel processing which functions well for processing graphics data. In this way CPU offloads graphics processing that is better handled by GPU . CPU may communicate with GPU in accordance with a particular application processing interface API . Examples of such APIs include the DirectX API by Microsoft and the OpenGL by the Khronos group however aspects of this disclosure are not limited to the DirectX and the OpenGL APIs and may be extended to other types of APIs that have been developed are currently being developed or are to be developed in the future.

In addition to defining the manner in which GPU is to receive graphics data from CPU the APIs may define a particular graphics processing pipeline that GPU is to implement. GPU in illustrates the graphics processing pipeline defined by the Direct3D 11 API. As described in more detail illustrates the graphics processing pipeline of the OpenGL 4.x API.

Examples of CPU and GPU include but are not limited to a digital signal processor DSP general purpose microprocessor application specific integrated circuit ASIC field programmable logic array FPGA or other equivalent integrated or discrete logic circuitry. In some examples GPU may be specialized hardware that includes integrated and or discrete logic circuitry that provides GPU with massive parallel processing capabilities suitable for graphics processing. In some instances GPU may also include general purpose processing and may be referred to as a general purpose GPU GPGPU . The techniques described in this disclosure may also be applicable to examples where GPU is a GPGPU.

System memory may comprise one or more computer readable storage media. Examples of system memory include but are not limited to a random access memory RAM a read only memory ROM an electrically erasable programmable read only memory EEPROM flash memory or any other medium that can be used to carry or store desired program code in the form of instructions and or data structures and that can be accessed by a computer or a processor.

In some aspects system memory may include instructions that cause CPU and or GPU to perform the functions ascribed to CPU and GPU in this disclosure. Accordingly system memory may be a computer readable storage medium comprising instructions that cause one or more processors e.g. CPU and GPU to perform various functions.

System memory may in some examples be considered as a non transitory storage medium. The term non transitory may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However the term non transitory should not be interpreted to mean that system memory is non movable. As one example system memory may be removed from device and moved to another device. As another example a system memory substantially similar to system memory may be inserted into device . In certain examples a non transitory storage medium may store data that can over time change e.g. in RAM .

The execution of the applications on CPU causes CPU to generate a plurality of primitives that connect together to form the viewable content. Examples of the primitives include points lines triangles squares or any other type of polygon. CPU may define these primitives by their respective vertices. For example CPU may define coordinates and color values for the vertices. The coordinate values may be three dimensional 3D coordinates or 2D coordinates.

In accordance with the techniques described in this disclosure in some cases CPU may also generate a special type of primitive referred to as a patch. Similar to the other primitive types a patch may be defined by a plurality of vertices referred to as control points of a patch. Unlike other primitive types the patch may not be any particular shape. For example CPU may interconnect the control points of the patch in any manner so that the interconnected control points form any desired shape. For other primitive types such as triangles CPU may define the specific manner in which the vertices are interconnected e.g. such that interconnection of the vertices results in a triangle .

Also unlike other primitive types the number of control points in a patch may be variable. For example the application executing on CPU may define a maximum number of control points that are allowed for a patch or the maximum number of control points may be user defined. In some examples the number of control points in a patch may be one to thirty two control points however the techniques described in this disclosure are not so limited.

CPU may utilize the control patch for purposes of tessellation. As described above a tessellation process refers to CPU defining a portion of a surface of a viewable object in low resolution and tessellating the portion to generate a higher resolution version of the surface. For example CPU may define control points of the patch such that when the control points are interconnected the patch forms a portion of a surface of a viewable object. If a surface were to be formed only from the control points of the patch the surface may not appear with high resolution and may appear jaggy. With tessellation additional primitives are added to the patch such that when the primitives are interconnected they add detail to the patch which increases the resolution of the patch and results in higher quality viewable content.

GPU may be configured to implement tessellation. In this way CPU may not need to define the vertices for all the additional primitives needed to create the higher resolution patch which saves on computations performed by CPU . Also CPU may need to transmit fewer vertices e.g. the vertices of the control points and not the vertices of the primitives to be added and GPU may correspondingly need to receive fewer vertices which promotes bandwidth efficiency due to fewer accesses to system memory .

To perform graphics operations GPU may implement a graphics processing pipeline. The graphics processing pipeline includes performing functions as defined by software or firmware executing on GPU and performing functions by fixed function units that are hardwired to perform very specific functions. The software or firmware executing on the GPU may be referred to as shaders and the shaders may execute on one or more shader cores of GPU . Shaders provide users with functional flexibility because a user can design the shaders to perform desired tasks in any conceivable manner. The fixed function units however are hardwired for the manner in which the fixed function units perform tasks. Accordingly the fixed function units may not provide much functional flexibility.

As indicated above the graphics processing pipeline illustrated in is a graphic processing pipeline substantially as defined by Direct3D 11. In this example GPU may include one or more of input assembler stage vertex shader stage hull shader stage tessellation stage domain shader stage geometry shader stage rasterizer stage pixel shader stage and output merge stage . GPU may include more stages than those illustrated and in some examples GPU may not necessarily include all of the illustrated stages. Also the specific ordering of the stages is provided for purposes of illustration and should not be considered limiting.

In techniques described in this disclosure CPU may output the control points of a patch to system memory . GPU may then retrieve the control points from system memory . In this manner CPU may transmit the control points to GPU . As used in this disclosure CPU transmitting to GPU or GPU receiving from CPU may generally include CPU writing to system memory from which GPU receives. Alternatively it may be possible for CPU to directly transmit to GPU and for GPU to directly receive from CPU .

Input assembler stage may read the control points from system memory as defined by CPU and assemble the control points to form the patch. For instance input assembler stage may read the coordinates color values and other such information of the control points. The coordinates color values and other such information may be commonly referred to as attributes of the control points. Based on the attributes of the control points input assembler stage may determine the general layout of the patch. In this manner input assembler stage may assemble the control points to form the patch. Input assembler stage may be a fixed function unit.

Vertex shader stage may process the vertices e.g. the control points of the patch from input assembler stage . For example vertex shader stage may perform per vertex operations such as transformations skinning morphing and per vertex lighting. Vertex shader stage may be a shader.

Hull shader stage receives the control points of the patch as processed by vertex shader stage process the control points and outputs control points for a processed patch. In other words hull shader stage receives an input patch as processed by vertex shader stage processes the input patch and outputs an output patch. Hull shader stage may perform various functions for processing the input patch. For example hull shader stage may modify the coordinates of the control points to change the locations of the control points or may even add or delete control points.

In addition hull shader stage may determine values that indicate how many primitives are to be added to the patch generated by hull shader stage i.e. the output patch . Hull shader stage may utilize various criteria to determine how many primitives are to be added to the patch. Described below are two example criteria that hull shader stage may utilize to determine how many primitives are to be added to the patch. However aspects of this disclosure are not so limited and hull shader stage may utilize any criteria to determine how many primitives should be added to the patch.

As one example hull shader stage may utilize information indicative of the depth of the patch to determine how many primitives should be added. For instance a patch that is further away from the perspective of the viewer may not need high resolution because objects further in distance appear blurry in real life. However a patch that is closer from the perspective of the viewer may need higher resolution because objects closer in distance appear sharper in real life. In this example hull shader stage may determine that fewer primitives should be added to the patch that is further away and more primitives should be added to the patch that is closer relative to one another.

As another example hull shader stage may determine how many primitives should be added based on the size of the patch. For a smaller sized patch hull shader stage may determine that fewer primitives should be added because the patch encompasses a smaller area. For a larger sized patch hull shader stage may determine that more primitives should be added because the patch encompasses a larger area.

Based on a determination of how many primitives should be added hull shader stage may output a domain type and values that indicate how many primitives are to be added to the patch to tessellation stage . The values that indicate how many primitives are to be added to the patch in the Direct3D 11 API are referred to as tessfactors.

The domain may be a considered as a template shape that tessellation stage uses for tessellation purposes. Examples of the domain type include a line a triangle a quad e.g. a four sided polygon or any other type of polygon. The domain may be a two dimensional 2D shape even if the patches define a three dimensional 3D surface or a 2D surface. When the domain is a line the domain may be a one dimensional 1D shape i.e. a line even if the patches define a 3D surface a 2D surface or a 1D surface. For purposes of illustration the techniques described in this disclosure are described with respect to the domain being a 2D surface. For instance the techniques are described with domain shapes that are the triangle or quad.

In some examples hull shader stage may not explicitly indicate the domain type. Rather tessellation stage may determine the domain type based on the number of transmitted tessfactors. For example the presence of four tessfactors may indicate that the domain type is a triangle domain type and the presence of six tessfactors may indicate that the domain type is a quad domain type.

In some examples a quad domain may be defined by 2D Cartesian coordinates u v . In some examples a triangle domain may be defined by Barycentric coordinates. Barycentric coordinates utilize three coordinates to identify any point within the triangle. For example the vertices of the triangle domain may be defined as u v w as described below in more detail. The location of any point within the triangle is defined by vertex weighting that indicates its proximity to a vertex. For instance the closer a point is to a vertex the higher its vertex weighting and the further away the point is from the vertex the lower its vertex weighting.

As an example assume the vertices of the triangle are defined with Barycentric coordinates u v w as follows 1 0 0 0 1 0 and 0 0 1 . In this example the center point is located at 1 3 1 3 1 3 because the center point is equally distant from each of the vertices. Also with the given definition of the vertex coordinates in this example the sum of the u v and w coordinates for any point within the triangle domain should equal one.

The Cartesian and Barycentric coordinates are described for purposes of illustration only and should not be considered limiting. In other examples it may be possible to define the quad domain with Barycentric coordinates or Cartesian coordinates and the triangle domain with Cartesian coordinates or Barycentric coordinates. In general a domain of any type may be defined using any coordinate system.

Tessellation stage may tessellate e.g. divide the domain into a plurality of primitives. It should be understood that in this example tessellation stage is not dividing the patch outputted by hull shader stage into primitives but rather dividing the domain into the primitives. In some examples tessellation stage may not even have access to the patch outputted by hull shader stage . Tessellation stage may be a fixed function unit although aspects of this disclosure need not be so limited.

Tessellation stage may utilize the tessfactors outputted by hull shader stage to tessellate e.g. divide the domain into a plurality of primitives. For example in addition to defining the domain type e.g. triangle or quad the tessfactors may define how many rings are to be included within the domain.

A ring may be a series of concentric shapes within the domain where the concentric shapes are the same shape as the domain shape. For example if the domain shape is a quad the perimeter of the quad may be considered as the outer ring. Hull shader stage may define the number of inner rings which may be series of smaller sized quads that reside within the quad domain. Similarly if the domain shape is a triangle the perimeter of the triangle may be considered as the outer ring and the inner rings may be series of smaller sized triangles that reside within the triangle domain.

In addition to defining the number of rings within a domain the tessfactors define the points that reside along the rings. The points that reside along the rings should not be confused with control points. The control points define the patch. The points that reside along the rings are points generated by tessellation stage based on the tessfactors. These points are generated within the domain and not within the patch.

Also it is these points that tessellation stage connects together to divide the domain into a plurality of primitives. For example assume that the primitives that tessellation stage will divide the domain into are triangles. In this example tessellation stage may connect one point that resides along the outer ring with two points that reside along the inner ring to form a triangle primitive. Alternatively tessellation stage may connect two points that reside along the outer ring with one point that resides along the inner ring to form a triangle primitive. In this way by defining the domain type the number of rings within the domain and the number of points along the outer and inner rings hull shader stage may define the number of primitives into which tessellation stage should divide the domain.

In some examples the number of points that can reside along an edge of ring may be one point to sixty four points. For example if the domain type is a triangle than there may be up to 65 points per edge of the triangle domain. Similarly if the domain type is a quad than there may be up to 65 points per edge of the quad. However the techniques described in this disclosure are not limited to an edge having a maximum of sixty four points.

Furthermore the number of points that along a ring may be different for outer and inner rings. For example the number of points that reside along an edge of the outer ring may be more than or less than the number points that reside along an edge of the inner ring. It may also be possible that number of points that reside along the edge of the outer ring and the inner ring are the same number of points.

Moreover the number points along an edge of the same ring may be different. For example for a triangle domain the number of points that reside along one of the edges may be different than the number of points that reside along one other edge or both edges. Similarly for a quad domain the number of points that reside along one of the edges may be different than the number of points that reside along one two or all three other remaining edges. It may also be possible for each of the edges of the rings to have the same number of points.

As described above in some examples tessellation stage may not divide the patch into a plurality of primitives. Accordingly in some examples tessellation stage may not receive any information such as the number of control points the locations of the control points or the size of the patch. Without any information as to the size of the patch and the locations of the control points tessellation stage may not be able to define the size of the domain that is used or the specific coordinates for the vertices of the domain.

To address this tessellation stage may rely upon a normalized coordinate system for defining the vertices of the domain as well as for determining the locations of the interconnected points within the domain. As one example of the normalized coordinates tessellation stage may define the vertices of a quad domain in u v coordinates as 0 0 1 0 0 1 and 1 1 which is a unit square. Tessellations stage may define the vertices of a triangle domain in u v w coordinates as 0 0 1 0 1 0 and 1 0 0 which is an equilateral triangle. Tessellation stage may determine the coordinates for the interconnected vertices of the plurality of primitives in this normalized coordinate system.

Tessellation stage may output the vertices of the plurality of primitives of the domain to domain shader stage in the normalized coordinate system e.g. the u v coordinates or the u v w coordinates as applicable . The function of domain shader stage may be to map the vertex coordinates as received from tessellation stage on to the patch. For example while tessellation stage may not receive information of the patch as defined by hull shader stage domain shader stage may receive such information from hull shader stage .

Domain shader stage may execute for each vertex coordinate outputted by tessellation stage . With the coordinates of the control points of the patch from hull shader stage domain shader stage may determine the location of the vertex as outputted by tessellation stage on the patch. Because tessellation stage outputs vertices of the plurality of primitives generated by tessellation stage and domain shader stage adds these primitives to the patch the combination of hull shader stage tessellation stage and domain shader stage together add additional primitives to the patch. This results in a mesh of primitives that are added to the patch creating a higher resolution more detailed patch as compared to the patch defined by CPU . In this manner hull shader stage tessellation stage and domain shader stage implement a tessellation process.

Geometry shader stage receives the vertices of the primitives added to the patch by domain shader stage and may further generate additional vertices for the primitives to add even more resolution. Rasterizer stage receives the primitives from geometry shader stage and converts the primitives into pixels for the display. For example the primitives may be defined as vectors that indicate the interconnection of the primitives and may be defined in a coordinate space that is independent of the display on which the image is to be displayed. Rasterizer stage converts these vectors into the display coordinates and performs any additional functions such as removing points within primitives that are occluded.

Pixel shader stage receives the pixels as outputted by rasterizer stage and performs post processing to assign color values to each of the pixels that are to be displayed. For example pixel shader stage may receive constant values stored in system memory texture data stored in system memory and any other data to generate per pixel outputs such as color values. Pixel shader stage may also output opacity values that indicate the opaqueness of the pixels.

Output merge stage may perform any final pixel processing. For example output merge stage may utilize depth information to further determine whether any of the pixels should be removed from being displayed. Output merge stage may also perform blending operations to generate final pixel values.

Output merge stage may output the final pixel values to a frame buffer generally located within system memory but which may be located within GPU . A display processor not shown may retrieve the pixel values from the frame buffer and cause pixels of a display not shown of device to illuminate accordingly to the pixel values to cause the display to display the image.

As described above tessellation stage interconnects points of the outer and inner rings within the domain to generate a plurality of primitives within the domain. In accordance with techniques described in this disclosure tessellation stage may utilize a single look up table referred to as a stitching table to determine the manner in which the points should be interconnected to generate the primitives within the domain.

In some examples GPU may include local memory such as cache memory and the cache memory may store the look up table. In some other examples system memory may store the look up table. For purposes of bandwidth efficiency it may be more desirable for the local memory of GPU to store the look up table rather than system memory .

Furthermore in some examples the stitching table may be a preprogrammed stitching table. In other words the stitching table may not be created during the execution of the application on CPU or based on instructions received by GPU . Rather the stitching table may define a specific way in which the primitives should be connected i.e. stitched for given tessfactors. For example for X number of points along an edge of the outer ring i.e. outer ring edge and Y number of points along an edge of the inner ring i.e. inner ring edge there is a specific way in which the points are to be connected for each X and Y pair.

The specific way in which the points are to be connected may define how many points are to be taken from the outer ring edge and how many points are to be taken from the inner ring edge to form the primitive. For example assume that tessellation stage divides a quad domain into triangle primitives. In this example two points may be taken from the outer ring edge and one point may be taken from the inner ring edge to form the triangle. Alternatively one point may be taken from the outer ring edge and two points may be taken from the inner ring edge to form a triangle. The stitching table may define how many points should be taken from each ring edge for the purposes of forming the primitives for a given number of points along the outer ring edge and the number of points along the inner ring edge.

For stitching the outer ring edge and the inner ring edge may be parallel with one another. In other words the edges that are used for forming the primitives are corresponding edges in outer and inner ring. For example when stitching primitives with points along the left edge of an outer ring of a quad domain tessellation stage may utilize the points along the left edge of the inner ring of the quad domain. The same may apply for the top bottom and right edges of the outer and inner rings.

The tessfactor that indicates the number of points that reside along the outer ring edge may form the basis for one index into the stitching table and the tessfactors that indicates the number of points that reside along the inner ring edge may form the basis for another index into the stitching table. In this manner the stitching table may be a two dimensional 2D look up table. From the indices to the stitching table tessellation stage may retrieve an entry value. The entry value may be a series of bits e.g. ones and zeros . Each bit may indicate how many points from the outer ring edge are used to form the primitive and how many points from the inner ring edge are used to form the primitive. The manner in which the entry value indicates how many points from the inner ring edge and the how many points from the outer ring edge are used is described below in more detail.

Utilizing the 2D stitching table may allow tessellation stage to determine how to interconnect the points within one clock cycle. For example the entry values in the 2D stitching table may provide sufficient information that tessellation stage does not need to access any other stitching table for the purposes of interconnecting the points of the primitives. This may allow domain shader stage to add the primitives to the patch earlier than if tessellation stage were to access multiple different look up tables to determine the manner in which the points are to be interconnected to form the primitives. For example some other techniques may waste computational cycles in reading a value from a table determining whether the value is to be used for stitching and then reading other values if the read value is not to be used for stitching. Also some other techniques may waste computational cycles in accessing different tables. By using a single 2D stitching table as described in this disclosure there may be a reduction in the number of computational cycles needed to determine the manner in which the points are to be interconnected to form the primitives.

Accordingly in some examples the techniques described in this disclosure may increase the computational efficiency of the graphics processing pipeline of GPU as compared to if tessellation stage referred to multiple look up tables. Furthermore because tessellation stage may access only one look up table i.e. the single 2D stitching table and no other table to determine the manner in which the points are to be interconnected the number of accesses to the local memory of GPU or system memory may be reduced resulting in a reduction in power consumption and an increase in bandwidth efficiency.

The OpenGL 4.x graphics processing pipeline may function in a substantially similar fashion as the Direct3D 11 graphics processing pipeline. Accordingly for purposes of brevity reference is made to to describe components that are similar to both the Direct3D 11 graphics processing pipeline and the OpenGL 4.x graphics processing pipeline.

As illustrated in the example of GPU includes input assembler vertex shader tessellation control shader primitive generator tessellation evaluation shader geometry shader clipping unit rasterizer fragment shader and post processor . Similar to in the example illustrated in GPU may include more or fewer components than those illustrated in . Also the specific ordering of the unit is provided for purposes of illustration and should not be considered limiting.

In some ways the tessellation process with the OpenGL 4.x graphics processing pipeline may be substantially similar to the tessellation process with the Direct3D 11 graphics processing pipeline. For example OpenGL 4.x tessellation process may rely upon patches and control points in the manner similar to that described above with respect to . For instance input assembler and vertex shader of may function substantially similar as input assembler stage and vertex shader stage of respectively.

As more examples for tessellation tessellation control shader of may function substantially similarly to hull shader stage of . However tessellation control shader outputs tessellation levels which may be analogous to the tessfactors of Direct3D 11. For example the tessellation levels of OpenGL 4.x may define the domain type the number of rings within the domain and the number of points per ring edge.

Primitive generator may function in a substantially similar manner as tessellation stage . For example primitive generator may utilize the tessellation levels and the domain type to divide the domain into a plurality of primitives. Also in accordance with techniques described in this disclosure primitive generator may utilize a single 2D look up table as described above i.e. the above described stitching table for determining the manner in which primitives are to be interconnected.

Tessellation evaluation shader of may function substantially similarly to domain shader stage of . For example tessellation evaluation shader may receive the vertices of the generated primitives from primitive generator and add the primitive to the patch outputted by tessellation control shader . In this manner the graphics processing pipeline of the OpenGL 4.x API may perform tessellation on a patch to increase the resolution of the patch.

Geometry shader may function substantially similar to geometry shader stage . The combination of clipping unit and rasterizer in may function substantially similarly to rasterizer stage in . Fragment shader and post processor in may function substantially similar to pixel shader stage and output merge stage in respectively. Post processor may output the final pixel values to a frame buffer and the display processor may retrieve the pixel values from the frame buffer and cause a display to illuminate according to the pixel values to display the image.

As described above tessellation control shader primitive generator and tessellation evaluation shader of function substantially similar to hull shader stage tessellation stage and domain shader stage of respectively for implementing the tessellation process. Accordingly both the Direct3D 11 and the OpenGL 4.x APIs rely upon two programmable shader units and one fixed function unit to implement the tessellation process.

For purposes of generality the techniques described in this disclosure may be described with a first tessellation shader unit a tessellation unit and a second tessellation shader unit. Examples of the first tessellation shader unit include hull shader stage and tessellation control shader . Examples of the tessellation unit include tessellation stage and primitive generator . Examples of the second tessellation shader unit include domain shader stage and tessellation evaluation shader .

Also Direct3D 11 uses the term tessfactors and OpenGL 4.x uses the term tessellation levels which may be considered analogous terms. For purposes of generality this disclosure uses the term tessellation factor examples of which include tessfactors and tessellation levels. In this way the first shader unit may be considered as outputting tessellation factors to the tessellation unit and the tessellation unit may output vertices to the second shader unit in response to the tessellation factors.

It should be noted that while the Direct3D 11 and OpenGL 4.x utilize two shader units and one fixed function unit the techniques described in this disclosure are not so limited. For example it may be possible in other systems for the first and second shader units to be fixed function units and the tessellation unit to be a shader unit. As another example all may be fixed function units or all may be shader units or any combination thereof.

Therefore in some examples it may be considered that a first unit performs functions similar to the first shader unit but may be a shader unit or a fixed function unit a second unit performs functions similar to the tessellation unit but may be a shader unit or a fixed function unit and a third unit performs functions similar to the second shader unit but may be a shader unit or a fixed function unit. Moreover although the first shader unit the tessellation unit and the second shader unit are illustrated as separate units in aspects of this disclosure are not so limited. These units and possibly any unit of the graphics processing pipelines illustrated in may be combined together into a common unit. Accordingly while the functionality of these units is described separately for ease of description these units may be implemented in shared hardware or as distinct components.

In triangle domain includes outer ring and inner ring . Outer ring includes outer ring edge and inner ring includes inner ring edge . Outer ring edge and inner ring edge are parallel with one another. In aspects described in this disclosure the tessellation unit may interconnect i.e. stitch points along outer ring edge with the points along inner ring edge . For example the tessellation factors may define the number of points that reside along outer ring edge and the number of points that reside along inner ring edge . As indicated in there is an addition inner ring which is inner to inner ring edge .

The tessellation unit may utilize these tessellation factors to determine indices into the single 2D stitching table. The entry value in the stitching table that corresponds to the indices may define how many points along outer ring edge and how many points along inner ring edge the tessellation unit should interconnect to form the primitives whose vertices reside along outer ring edge and inner ring edge .

After generating the primitive whose vertices reside along outer ring edge and inner ring edge the tessellation unit may advance to the other two edges of outer ring and inner ring in a clockwise fashion in this example. For each of these edges of outer ring and inner ring the tessellation unit may access the single 2D stitching lookup table to determine the manner in which the points that reside along these edges are to be interconnected.

In some examples after the tessellation unit completes the stitching of the primitives whose vertices reside along outer ring and inner ring the tessellation unit may proceed with the next inner ring. In this case inner ring becomes the outer ring and the ring following inner ring becomes the inner ring and the process of accessing the 2D stitching table repeats until upon progressively proceeding inward there are no more rings.

The tessellation unit may perform similar function on quad domain . For example in quad domain includes outer ring and inner ring . As illustrated there is another inner ring which is inner to inner ring . Outer ring includes outer ring edge and inner ring includes inner ring edge . Outer ring edge and inner ring edge are parallel with one another and the points along these edges may form primitives e.g. may be vertices of the primitives .

Similar to the example of the tessellation unit may utilize the tessellation factors for outer ring edge and inner ring edge to determine indices into the single 2D stitching table. The entry value in the stitching table that corresponds to the indices may define how many points along outer ring edge and how many points along inner ring edge the tessellation unit should interconnect to form the primitives whose vertices reside along outer ring edge and inner ring edge .

After generating the primitive whose vertices reside along outer ring edge and inner ring edge the tessellation unit may advance to the other two edges of outer ring and inner ring in a clockwise fashion in this example and may access the 2D stitching table to determine how the points are to be connected. In some examples after the tessellation unit completes the stitching of the primitives whose vertices reside along outer ring and inner ring the tessellation unit may proceed with the next inner ring. In this case inner ring becomes the outer ring and the ring following inner ring becomes the inner ring and the process of accessing the 2D stitching table repeats until upon progressively proceeding inward there are no more rings.

In the interconnection of the points that form the triangle may be based on the tessellation factors. For example the dense interconnections at the left edge of are due to the interconnections as defined by the stitching table. For example the tessellation factors for the left edge of may form the basis for the indices into the stitching table. In this example the entry value in the stitching table that corresponds to the indices may indicate that the points of the primitives should be connected in the manner illustrated for the left edge of . The entry values in the stitching table may similarly indicate the manner in which the points along the different edges in should be connected based on the tessellation factors for the different edges.

Tessellation unit may include setup unit point generator and connectivity generator which may be fixed function hardware units of tessellation unit . Setup unit point generator and connectivity generator are illustrated as separate components for ease of description. Setup unit point generator and connectivity generator may be formed as a single unit as separate units or a combination thereof. Stitching table is illustrated as being within connectivity generator for ease of illustration. However stitching table may reside within the local memory of GPU or system memory .

Setup unit may receive the tessellation factors as input a first shader unit such as hull shader stage of and tessellation control shader and may determine the domain type from the tessellation factors. For example if there are four tessellation factors setup unit may determine that the domain type is a triangle and if there are six tessellation factors setup unit may determine that the domain type is a quad. Setup unit may perform other setup functions such as correcting rounding problems ceiling and floor functions determining half tessellation factors and reducing and combining tessellation factors. In general setup unit may process the tessellation factors to ensure that the other components of tessellation unit can perform respective functions.

Point generator may determine how many points reside along each edge of each ring of the domain from the tessellation factors and the locations of the points e.g. the u v coordinates or the u v w coordinates of the points . Connectivity generator may connect i.e. stitch the points to form a plurality of primitives in the domain such as those illustrated in .

For example point generator may determine coordinates of points along an outer ring such as outer ring and outer ring of respectively and coordinates of points along an inner ring such as inner ring and inner ring of respectively. In some examples point generator may store the determined coordinates in buffers. For example one buffer may store the coordinates of points along the inner ring edge and another buffer may store the coordinates of points along the outer ring edge.

For each edge of the outer ring that is parallel with an edge of the inner ring connectivity generator may determine how the points of the outer ring edge should connect with the points of the inner ring edge to form primitives. For instance there may be at least two different ways in which points along the outer ring edge and the points along the inner ring edge can form triangles. As one example connectivity generator may form a triangle using two points from the outer ring edge and one point from the inner ring edge and connect them together to form a triangle. As another example connectivity generator may form a triangle using two points from the inner ring edge and one point from the outer ring edge to form the triangle.

In accordance with the techniques described in this disclosure stitching table may define which points connectivity generator should utilize to form the primitives. In some examples stitching table may define which points connectivity generator should utilize to form the primitives based on the number of points along the outer ring edge and the number of points along the inner ring edge. For example there may be specific predefined ways in which connectivity generator should connect the points for a given number of points along the outer ring edge and a number of points along the inner ring edge.

Stitching table may store such information regarding the way in which connectivity generator should connect the points of the outer ring edge and the inner ring edge. In some examples connectivity generator may only need to access stitching table and may not need to access any other table to determine the manner in which to connect the points of the outer ring edge and the inner ring edge.

As described above stitching table may be a 2D stitching table and connectivity generator may index stitching table based on the number of points that are present along the inner edge and the outer edge. The number of points that are present along the inner edge and the outer edge may be based on the received tessellation factors.

Connectivity generator may use the number of points that reside along the inner edge i as the basis for determining the column index of stitching table and the number of points that reside along the outer edge j as the basis for determining the row index of stitching table . In other words connectivity generator may utilize the values i j to access stitching table . In other examples the number of points that reside along the inner edge may form the basis for indexing the row of stitching table and the number of points that reside along the outer edge may form the basis for indexing the column of stitching table .

In some examples the manner in which connectivity generator connects the points may be based on half tessellation factors. For example connectivity generator may form primitives using half the points that reside along the outer ring edge and or using half the points that reside along the inner ring edge e.g. halfway along the length of the outer ring edge and or inner ring edge . Connectivity generator may then connect the remaining half of the points in the same way as the first half or in a reciprocal way. For example when connecting the remaining half in the reciprocal way the first half and the second half may appear as mirror primitives.

Because connectivity generator copies or inverts the manner in which it connected the primitives in the first half of the outer ring edge and or inner ring edge with the second half connectivity generator may only need to retrieve stitching information for the first half of the outer and or inner ring edge. For example assume that there are 10 points along the outer ring edge in this example connectivity generator may retrieve information for how to connect 5 of the 10 points. In this manner connectivity generator may rely upon half tessellation factors e.g. 5 divided by 10 is 0.5 to determine how to connect i.e. stitch the points.

Connectivity generator may then connect the remaining 5 points in the same way or in an inverted way as the first 5 points. For example in the inverted way connectivity generator may connect the remaining 5 points in such a manner that primitives generated from the remaining 5 points are the mirror primitives of the primitives generated from the first 5 points.

In examples where connectivity generator relies on half tessellation factors the number of rows and columns in stitching table may be approximately half the maximum possible number of points in an edge e.g. the outer ring edge or the inner ring edge . For instance as described above in some examples the maximum number of points along an edge may be 65 points. In these examples stitching table may be a 33 33 table because 33 is approximately half of 65.

In some examples there may be a requirement that half of an inner ring edge is not allowed to have less than 3 points. In these cases rather than having 1 to 33 points along half of an inner ring edge there may be 3 to 33 points along half of an inner ring edge. For these cases it may be possible to reduce the size of stitching table . For example because half of the inner ring edge may be allowed to have 3 to 33 points it may be possible to remove rows from stitching table for the cases where half of the inner ring edge has less than 3 points. For instance the rows of stitching table may be for the inner ring edge and because there may be 3 to 33 points along half of an inner edge stitching table may need 31 rows to represent the possibility of 3 to 33 points. In these examples stitching table may be a 31 33 table.

Connectivity generator may index stitching table using the half tessellation factors to retrieve entry values that define the way in which connectivity generator should connect points that reside along half an edge of the domain. For example if the tessellation factors define that there are 10 points along the outer ring edge and 8 points along the inner ring edge then the index into stitching table is 5 and 4 i.e. 10 divided by 2 is 5 and 8 divided by 2 is 4 . If however half tessellation factors are not used then the index into stitching table may be 10 and 8.

In some examples connectivity generator may subtract 2 from the half tessellation factor of the inner ring edge and use the resulting value as the index into stitching table . For example because in some instances there may be only 3 to 33 points along half of an edge of an inner ring edge resulting in 31 rows in stitching table connectivity generator may need to subtract 2 from the half tessellation factor to properly index stitching table in these instances.

In this manner connectivity generator may determine a first index into stitching table based on the number of points along the outer ring edge of the domain and may determine a second index into stitching table based on the number of points along the inner ring edge of the domain. Connectivity generator may then utilize the first index and the second index to retrieve an entry value from stitching table .

The entry values may be plurality of bits where each bit indicates how many points from the outer ring edge and how many points from the inner ring edge connectivity generator should use to connect to form the primitives. For example if the number of points on an edge is 64 then there may be a maximum of 128 primitives whose vertices reside along the outer ring edge and the inner ring edge. Accordingly there may be a maximum of 64 primitives whose vertices reside along the halfway length of the outer and inner ring edges. In this example the number of bits in the entry value may be 64 with each bit indicating the number of points from the inner and outer ring edges that connectivity generator should use to form one primitive.

As one example a bit value of 1 may indicate that connectivity generator should utilize two points from the outer ring edge and one point from the inner ring edge to form a triangle primitive. A bit value of 0 may indicate that connectivity generator should utilize one point from the outer ring edge and two points from the inner ring edge. However in other examples a bit value of 1 may indicate the connectivity generator should utilize one point from the outer ring edge and two points from the inner ring edge and a bit value of 0 may indicated that connectivity generator should utilize two points from the outer ring edge and one point from the inner ring edge.

In this example connectivity generator may determine the bit value of each of the bits in the entry value starting from the least significant bit LSB . The LSB may indicate how many points connectivity generator should use from the inner and outer ring edges to generate the first primitive along the inner and outer ring edges. The bit after the LSB may indicate how many points connectivity generator should use from the inner and outer ring edges to generate the second primitive along the inner and outer ring edges and so forth. In some examples the first primitive may be at the left bottom of the domain and the second primitive may be the next primitive moving in a clockwise direction.

Connectivity generator may repeat these steps until connectivity generator generates a predetermined number of primitives e.g. generates the primitives along half of the inner and or outer ring edges . For example the most significant bit MSB of the entry value from stitching table may indicate how many points from the outer and inner ring edges connectivity generator should use to generate the last primitive which occurs at the half way point along the inner and outer ring edges. Connectivity generator may then repeat these steps for generating the primitives that reside along the second half of the inner and outer ring edges as described above. For example the total number of primitives that connectivity generator is to create may be based on number of points along half of the outer ring edge and the number of points along half of the inner ring edge. For instance by summing the number of points along half of the outer ring edge and the number of points along half of the inner ring edge and subtracting one from the resulting value connectivity generator may determine the total number of primitives that are to be created along an inner and an outer ring edge.

In this manner connectivity generator may determine how many points of the outer ring and how many points of the inner ring edge to use to generate each of the plurality of primitives based on the retrieved entry value. The shader unit after the tessellation unit e.g. domain shader or tessellation evaluation shader uses the resulting plurality of primitives in the domain to add primitives in the patch. The resulting patch with the additional primitives is then further processed through the graphics processing pipeline and ultimately rasterized to render an image.

As described above connectivity generator may determine bit values of one or more bits e.g. from the LSB to the MSB of the entry value. In this example each bit value of the one or more bits corresponds to each one of the plurality of primitives. Connectivity generator may then connect the points of outer ring edge and the inner ring edge based on the determination to generate each of the plurality of primitives.

Furthermore in some examples connectivity generator may connect points that reside up to halfway of the edge and repeat for the other half. In these examples the indices into stitching table may be based on the half tessellation factors. In other examples connectivity generator may connect points all the way up the edge. In these examples the indices into stitching table may be based on the tessellation factors and not necessarily the half tessellation factors.

The MSB need not necessarily be the first bit in the 64 bit entry value. For example although half an edge may include a maximum of 64 primitives in some examples it is not necessary that there always be 64 primitives. In these examples connectivity generator may start with the LSB and determine bit values starting from the right to the left until connectivity generator generated all of the primitives for the half the outer and inner ring edges. In this example the last bit value that connectivity generator determined may be considered as the MSB.

Connectivity generator may then stop determining the bit value for any remaining bits in the entry value. For example if there are only 50 primitives whose vertices are points along the inner and outer edge ring then after determining the bit values for the LSB to the 50bit starting from the LSB connectivity generator may stop determining the bit values for any of the remaining 14 bits of the 64 bit entry value.

As described above stitching table may define how many points from the inner and outer ring edges connectivity generator should use for half an edge. However aspects of this disclosure are not so limited. In other examples stitching table may define how many points from the inner and outer ring edges connectivity generator should use for the entire inner and outer ring edges.

In this case the size of stitching table may be 64 64 because there are a maximum of 64 points along each of the outer and inner ring edges. Also in this case the number of bits of the entry value may be 128 because there could be up to 128 primitives whose vertices reside along the inner and outer ring edges however fewer primitives are possible. Accordingly the index for the rows and columns of stitching table may be based on the maximum number of allowable points along a ring edge. Also the number of bits in the entry value may be based on the maximum number of allowable points along a ring edge.

Using half tessellation factors as indices and determining the connectivity for primitives that reside halfway up the inner and outer ring edges may allow for a smaller sized stitching table that stores fewer bits. For example as described above when relying upon half tessellation factors the size of stitching table may be 33 33 rather than 64 64 and the number of bits in the entry value may be 64 rather than 128.

In point generator may be configured to determine a number of points along an outer ring edge of a domain . Point generator may also determine a number of points along an inner ring edge of the domain . For example point generator may divide the length of the edge with the tessellation factor to determine the number of points along the outer ring edge and inner ring edge. For instance if the tessellation factor indicates four for an edge then there are four points that reside along the edge which results in the edge being divided into five portions.

Connectivity generator may be configured to utilize only a single stitching table based on the number of points along the outer ring and the number of points along the inner ring edge to determine how many points and which ones of the outer ring edge and how many points and which ones of the inner ring edge to use to generate each of a plurality of primitives whose vertices are the points along the outer ring edge and the points along the inner ring edge . Connectivity generator may output the coordinates of the vertices . The output coordinates may then be processed utilizing the graphics processing pipeline as described above with respect to .

Due to the size of this example of stitching table stitching table is illustrated across . As described above in some examples stitching table may be a 31 33 table. illustrates the 31 rows and illustrates columns 1 7 labeled A G of the 33 columns. illustrates the 31 rows and illustrates columns 8 12 labeled H L of the 33 columns. illustrates the 31 rows and illustrates columns 13 18 labeled M R of the 33 columns. illustrates the 31 rows and illustrates columns 19 23 labeled S W of the 33 columns. illustrates the 31 rows and illustrates columns 24 28 labeled X AB of the 33 columns. illustrates the 31 rows and illustrates columns 29 31 labeled AC AE of the 33 columns. illustrates the 31 rows and illustrates columns 32 and 33 labeled AF and AG of the 33 columns.

Moreover for ease of illustration illustrate numerical values. However in some examples rather than storing numerical values stitching table may store binary value equivalents for the numerical values illustrated in . For instance in some examples stitching table may store 64 bit entry values. In these examples the values illustrated in may be represented by up to the 64 bits needed to represent the values illustrated in . It should be understood that not all values illustrated in need to be represented by 64 bits.

It is to be recognized that depending on the example certain acts or events of any of the techniques described herein can be performed in a different sequence may be added merged or left out altogether e.g. not all described acts or events are necessary for the practice of the techniques . Moreover in certain examples acts or events may be performed concurrently e.g. through multi threaded processing interrupt processing or multiple processors rather than sequentially.

In one or more examples the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored as one or more instructions or code on a computer readable medium. Computer readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions code and or data structures for implementation of the techniques described in this disclosure. By way of example and not limitation such computer readable media can comprise random access memory RAM read only memory ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that can be used to store desired program code in the form of instructions or data structures and that can be accessed by a computer. Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and Blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

The code may be executed by one or more processors such as one or more digital signal processors DSPs general purpose microprocessors application specific integrated circuits ASICs field programmable logic arrays FPGAs or other equivalent integrated or discrete logic circuitry. Accordingly the term processor as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. Also the techniques could be fully implemented in one or more circuits or logic elements.

The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses including a wireless handset an integrated circuit IC or a set of ICs i.e. a chip set . Various components modules or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques but do not necessarily require realization by different hardware units. Rather as described above various units may be combined in a hardware unit or provided by a collection of interoperative hardware units including one or more processors as described above in conjunction with suitable software and or firmware.

Various examples have been described. These and other examples are within the scope of the following claims.

