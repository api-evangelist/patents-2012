---

title: Method for application notification and tasking
abstract: A method for notifying and tasking computer applications hosted by an application execution system by computer applications external to the application execution system is provided. An external computer application may use an external Task queue API to add tasks to the internal application's task queue. The internal application can then see the tasks and act upon the tasks at a convenient, non-busy time for the internal application. An intermediary subscription system may manage an internal application's event subscriptions. When an event occurs, the intermediary subscription system may add a task to the subscribing internal application's task queue. A second intermediate system manages the access control list of an internal application's task queue. This system restricts access to the task queue to only those external applications that are explicitly granted permission in the internal application's task queue configuration file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09405602&OS=09405602&RS=09405602
owner: Google Inc.
number: 09405602
owner_city: Mountain View
owner_country: US
publication_date: 20120625
---
A distributed application execution system may be used to develop and host large numbers of computer applications with each application having its own set of fluctuating resource requirements. Such a system may contain an application master and a plurality of application servers. Computer applications running in the application execution system may be sandboxed and executed across multiple application servers in several data centers.

In some embodiments the application execution system includes one or more front end servers . The front end sever receives application execution requests from clients and returns results to the requesting clients.

The application execution system also includes a plurality of application servers e.g. through . Each of the application servers includes volatile storage for executing one or more applications non volatile storage for storing one or more applications and computational resources for executing applications in response to requests received by the application execution system .

In some embodiments the application execution system also includes an application master that distributes applications from a main library having a plurality of applications among the application servers . In the embodiment shown in the main library is stored in the application master . In some embodiments each application of the plurality of applications in the main library is a web application that is responsive to HTTP requests. However the present invention can also be used in non web based environments in which case the applications need not be web based applications.

In other embodiments the application execution system includes a data store that is accessible to each of the application servers which includes information about which application servers accept service requests for a particular application.

A distributed application execution system may be used for developing and hosting computer applications in data centers across the world. The application execution system may automatically scale a computer application as the number of requests increases for the application. Scaling may include allocating more resources for a computer application when the application experiences an increase in requests.

Furthermore the system may provide access to application programming interfaces APIs that are only available to the computer applications that exist within the application execution system. An API is a code based specification that allows software components to communicate with one another. APIs may contain information such as the methods available and the data returned by the available methods from a particular web service.

A customary distributed application execution system may provide computer applications with an API for queuing tasks. A task may be defined as a small amount of work and may consist of two parts 1 a data payload which parameterizes the task and 2 the code which implements the task. Tasks may be added to a queue in order for the tasks to be processed in the background of a computer application. Using a task queue computer applications can define tasks add them to a queue and process the tasks in aggregate and in non real time. In a customary distributed application execution system a task queue may be one of several types including a push queue or a pull queue.

A push queue pushes work to workers in a computer application when tasks are available for that application. The work is processed by the distributed application execution system s infrastructure which automatically scales the computer application which has tasks to do.

In contrast pull queues allow a task consumer to lease tasks at a specific time for processing within a specific time period. The task is locked to the task consumer for the time period of the lease. The task consumer tries to process and delete tasks before the lease ends. If the task consumer does not complete the task in the allotted time period the task is made available for other task consumers to lease. The task can be leased a configurable amount of times before the task is deleted from the queue without being processed.

Computer applications within an application execution system are considered internal applications whereas computer applications that are not in the application execution system are considered external computer applications. In some instances internal computer applications may need to perform work received from external computer applications. To perform the work an internal computer application needs to be notified about the work and assigned tasks to complete the work.

Conventional processes notify internal computer applications in real time about tasks which causes the internal computer applications to act on the tasks as they are received. This immediate reaction to tasks can interfere with the internal computer application s behavior because resources may have to be dedicated to responding to the tasks. To avoid interference with an internal computer application s real time behavior there should be an external notification and tasking process that allows an internal computer application to receive external tasks in non real time. As recognized by the inventors tasks from external systems should be sent to an internal computer application using a mechanism that allows the internal application to act upon the tasks at a convenient non busy time for the application.

This specification describes technologies relating to application execution systems application notification and tasking and specifically to methods and systems for applications outside of an application execution system to assign tasks to applications within the application execution system in non real time.

In general one aspect of the subject matter described in this specification can be embodied in a system and a method for enabling application tasking in an application execution system from an application external to the application execution system. An exemplary system includes one or more processing devices and one or more storage devices storing instructions that when executed by the one or more processing devices cause the one or more processing devices to receive a task from an external application destined for a task queue of an internal application which is inside the application execution system verify permission of the external application to the task queue responsive to verification append the task to the task queue and assign the task to a worker process in the internal application such that the worker process leases the task from the task queue processes the task and responsive to completing the task removes the task from the task queue. An exemplary method includes receiving a task from an external application destined for a task queue of an internal application which is inside the application execution system verifying that the external application has permission to access the internal task queue responsive to verification appending the received task to the internal task queue and assigning the appended received task to a worker process in the internal application.

These and other embodiments can optionally include one or more of the following features the intermediary subscription process may identify the internal application that subscribed to the event and notify the task queue of the internal application subscribed to the external application s event verifying the task to be appended to the task queue may include an intermediate process for managing an access control list and checking permissions the intermediate authorization process may verify that the external application is authorized to access the internal application s task queue using the access control list and responsive to an indication that the external application is permitted to access the internal application s queue may add a task to the task queue tasks may be appended via a method in an external REST Task Queue API and the external REST Task Queue API may include methods for retrieving a task queue retrieving a list of tasks retrieving a specific task inserting a task into the task queue deleting a task from the task queue updating a task in the task queue and leasing a task from the task queue.

The details of one or more embodiments of the invention are set forth in the accompanying drawings which are given by way of illustration only and the description below. Other features aspects and advantages of the invention will become apparent from the description the drawings and the claims. Like reference numbers and designations in the various drawings indicate like elements.

In an exemplary embodiment computer applications external to an application execution system can conveniently notify and task applications within the application execution system with work through an external REST API for task queues which may be included in the client of . Using this external REST API external applications may be able to add tasks to an internal application s push or pull task queues. Each internal application may have one or more task queues to which an external application may append tasks. The internal application may then be able to see the added tasks and may process the tasks when the internal application is not busy and processing the tasks will not interfere with the internal application s real time requests. Tasks may be processed in an order determined by the internal application. Tasks may be leased. However if a leased task should not be processed at the current time the task lease can be modified to zero seconds. By modifying the task lease to zero seconds the task becomes available for another worker to process.

In order for an internal application to be able to accept tasks to its push or pull task queue the internal application s queue configuration file should specify which external applications are allowed to write to its push or pull queue. Standards for authorization such as oAuth are used to authorize computer applications accessing a task queue.

As discussed above computer applications within an application execution system are considered internal applications whereas computer applications that are not in the application execution system are considered external computer applications. An internal application developer should create an access control list ACL as shown in which allows the developer to restrict access to the internal application s task queue to only specific email addresses with certain privileges. An ACL may be composed of identifiers and corresponding privileges for those identifiers.

Identifiers may represent users or user applications that can have access to the internal computer application s task queue. For example as depicted in two external users represented by the email addresses bar foo.com and user gmail.com may have access to the internal task queue pull queue. Each identifier is associated with at least one privilege in the ACL illustrated in . As shown bar foo.com has two ACL entries one for the privilege user email and one for the privilege writer email. User email may be a privilege which enables users or user applications to list get lease update and delete tasks. Writer email may be a privilege which enables users or user applications to insert tasks. In user gmail.com may only have the privilege writer email meaning that user gmail.com may only insert and update tasks in the pull queue task queue. User gmail.com cannot view the list of tasks get the tasks lease any tasks or delete tasks because user gmail.com does not have permission to perform these operations.

In some embodiments an external task queue REST API allows external applications to add tasks to an internal application s push or pull task queue. As discussed external applications identifiers should be added to the ACL list of an internal application s queue configuration file for the external applications to be able to access the internal application s task queue.

The external REST API may include REST methods such as get task queue list tasks get tasks delete tasks lease tasks insert tasks and update tasks.

 Get TaskQueue returns information about a specified task queue resource. A task queue resource is a resource type that specifies certain properties of a task queue. A task queue may include properties such as kind id maxLeases stats stats.totalTasks stats.oldestTask stats.leasedLastMinute and stats.leasedLastHour. Kind identifies the resource type. The id property holds the name of the task queue. This name must be unique among all queue names within the internal application. MaxLeases is the number of times a client can lease a specific task before the task will be automatically dropped from the queue. If MaxLeases is not specified all tasks will be available for an indefinite number of retries. Stats is an object that holds statistics for the queue. Stats.totalTasks represents the total number of tasks in the queue. Stats.oldestTask provide the timestamp of the oldest task in the queue. Stats.leasedLastMinute specifies the number of tasks that were leased in the last minute and stats.leasedLastHour identifies the number of tasks leased in the last hour.

 List tasks lists all non deleted Tasks in a task queue whether or not the tasks are currently leased. Tasks may be returned in the same order in which they are stored on the queue.

 Get Task returns the named task that was requested. The task is not leased but merely retrieved for viewing.

 Delete Task deletes a task from a task queue. This method should only be called by a user or user application that owns the lease for a task and has completed the task.

A user or user application with the privilege to insert may add a task into the task queue using the insert method. If an insert operation is commenced by an application that does not have permission to insert into a task queue the insert operation may fail. Failure to insert may cause a permission denied error. Tasks may also be updated by the update task method by applications with the privilege to update tasks in a particular task queue.

As illustrated in an exemplary process begins with receiving a task from an external application . If the external application is in the ACL list of an internal application s queue configuration file and the application has the appropriate privilege the task will be appended to the task queue associated with the internal application for which it was generated . After the task has been appended to the internal application s task queue the internal application may assign the task to a worker process . The worker process may lease the task from the task queue . If and when the worker process finishes processing the task the worker process may remove the task from the queue .

In some embodiments an internal computer application may subscribe to an event or events of an external computer application. When an event occurs to which the internal application is subscribed the event triggers a task to be added to the internal application s task queue. An intermediary system between external applications and the internal application may manage all of the internal application s subscriptions. Subscriptions are created and deleted in response to API calls. These subscriptions are stored in a database and checked when an event occurs in an application to which other applications are subscribed. When an event occurs in an external system the intermediary subscription system checks the subscriptions and finds the internal applications that are subscribed to the event. Then the intermediary system notifies the task queues of the applications subscribed to the event.

For example there may be an external calendaring application which needs to notify an invitee via email that an event has been updated. The email notification functionality may be done by an internal computer application. An email notification task may be inserted into the internal computer application s task queue when the event is updated. The email notification task may be defined as follows 

When the task is executed an email will be sent to the invitee notifying the person of the updates to the event.

The datacenter includes multiple racks . While only two racks are shown the datacenter may have many more racks. Each rack can include a frame or cabinet into which components such as processing modules are mounted. In general each processing module can include a circuit board such as a motherboard on which a variety of computer related components are mounted to perform data processing. The processing modules within each rack are interconnected to one another through for example a rack switch and the racks within each datacenter are also interconnected through for example a datacenter switch.

In some implementations the processing modules may each take on a role as a parent or a child process. The parent processes control scheduling and data distribution tasks among themselves and the children. A rack can include storage like one or more network attached disks that is shared by the one or more processing modules and or each processing module may include its own storage. Additionally or alternatively there may be remote storage connected to the racks through a network.

The datacenter may include dedicated optical links or other dedicated communication channels as well as supporting hardware such as modems bridges routers switches wireless antennas and towers. The datacenter may include one or more wide area networks WANs as well as multiple local area networks LANs .

Depending on the desired configuration the processor can be of any type including but not limited to a microprocessor P a microcontroller C a digital signal processor DSP or any combination thereof. The processor can include one more levels of caching such as a level one cache and a level two cache a processor core and registers . The processor core can include an arithmetic logic unit ALU a floating point unit FPU a digital signal processing core DSP Core or any combination thereof. A memory controller can also be used with the processor or in some implementations the memory controller can be an internal part of the processor .

Depending on the desired configuration the system memory can be of any type including but not limited to volatile memory such as RAM non volatile memory such as ROM flash memory etc. or any combination thereof. System memory typically includes an operating system one or more applications and program data . The application may include steps application notification and tasking. Program Data includes storing instructions that when executed by the one or more processing devices implement a system and method for allowing applications external to an application execution system to notify and task an internal application. . In some embodiments the application can be arranged to operate with program data on an operating system .

The computing device can have additional features or functionality and additional interfaces to facilitate communications between the basic configuration and any required devices and interfaces.

System memory is an example of computer storage media. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computing device . Any such computer storage media can be part of the device .

The computing device can be implemented as a portion of a small form factor portable or mobile electronic device such as a cell phone a personal data assistant PDA a personal media player device a wireless web watch device a personal headset device an application specific device or a hybrid device that include any of the above functions. The computing device can also be implemented as a personal computer including both laptop computer and non laptop computer configurations.

The foregoing detailed description has set forth various embodiments of the devices and or processes via the use of block diagrams flowcharts and or examples. Insofar as such block diagrams flowcharts and or examples contain one or more functions and or operations it will be understood by those within the art that each function and or operation within such block diagrams flowcharts or examples can be implemented individually and or collectively by a wide range of hardware software firmware or virtually any combination thereof. In one embodiment several portions of the subject matter described herein may be implemented via Application Specific Integrated Circuits ASICs Field Programmable Gate Arrays FPGAs digital signal processors DSPs or other integrated formats. However those skilled in the art will recognize that some aspects of the embodiments disclosed herein in whole or in part can be equivalently implemented in integrated circuits as one or more computer programs running on one or more computers e.g. as one or more programs running on one or more computer systems as one or more programs running on one or more processors e.g. as one or more programs running on one or more microprocessors as firmware or as virtually any combination thereof and that designing the circuitry and or writing the code for the software and or firmware would be well within the skill of one of skill in the art in light of this disclosure. In addition those skilled in the art will appreciate that the mechanisms of the subject matter described herein are capable of being distributed as a program product in a variety of forms and that an illustrative embodiment of the subject matter described herein applies regardless of the particular type of non transitory signal bearing medium used to actually carry out the distribution. Examples of a non transitory signal bearing medium include but are not limited to the following a recordable type medium such as a floppy disk a hard disk drive a Compact Disc CD a Digital Video Disk DVD a digital tape a computer memory etc. and a transmission type medium such as a digital and or an analog communication medium. e.g. a fiber optic cable a waveguide a wired communications link a wireless communication link etc. 

With respect to the use of substantially any plural and or singular terms herein those having skill in the art can translate from the plural to the singular and or from the singular to the plural as is appropriate to the context and or application. The various singular plural permutations may be expressly set forth herein for sake of clarity.

Thus particular embodiments of the subject matter have been described. Other embodiments are within the scope of the following claims. In some cases the actions recited in the claims can be performed in a different order and still achieve desirable results. In addition the processes depicted in the accompanying figures do not necessarily require the particular order shown or sequential order to achieve desirable results. In certain implementations multitasking and parallel processing may be advantageous.

