---

title: Cloud file system
abstract: A cloud storage system supporting user agnostic encryption and deduplication of encrypted files is described. Further the cloud storage system enables users to share a file, a group of files, or an entire file system with other users without a user sending each file to the other users. The cloud storage system further allows a client device to minimize the utilization of bandwidth by determining whether the encrypted data to transfer is already present in the cloud storage system. Further the cloud storage system comprises mechanisms for a client device to inform the cloud storage system of which data is likely to be required in the future so that the cloud storage system can make that data available with less latency one the client device requests the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09253166&OS=09253166&RS=09253166
owner: BITCASA, INC.
number: 09253166
owner_city: San Mateo
owner_country: US
publication_date: 20120514
---
This patent application is a U.S. National Phase Application under 35 U.S.C. 371 of International Application No. PCT US2012 037860 filed May 14 2012 entitled CLOUD FILE SYSTEM WITH SERVER SIDE DEDUPLICATION OF USER AGNOSTIC ENCRYPTED FILES which claims the benefit of the following U.S. Provisional Applications U.S. Provisional Application No. 61 549 206 filed Oct. 19 2011 U.S. Provisional Application No. 61 538 928 filed Sep. 25 2011 U.S. Provisional Application No. 61 533 264 filed Sep. 11 2011 and U.S. Provisional Application No. 61 486 240 filed May 14 2011 each of which are hereby incorporated by reference.

Embodiments of the invention relate to the field of network attached storage and more specifically to a cloud storage system.

As cloud based storage systems online backup services and large file transfer systems become commonplace storage and bandwidth requirements are two critical factors which if controlled can lead to key competitive advantages. However there is the competing factor that users of these online storage systems desired that their data be secure from both the operators of such services and other users from the services.

The traditional way of implementing an online file system as a service to customers is to allow each user to upload files to the online storage system through a world wide web interface across a file transfer protocol connection or other file transport protocol. Typically the files are sent to the service unencrypted meaning the operator of the service could access the user s data. In some cases the services encrypt the data for storage within their service while in other cases the services provide client software that encrypts data prior to uploading the data to the service. In cases where the client encrypts data prior to uploading the traditional method is to 1 have a client encrypt a file using some unique encryption key e.g. user password or public key 2 have the client upload the encrypted file 3 store the encrypted file on the server.

The traditional means of providing an encrypted upload to clients of online storage systems presents a number of drawbacks. First it is possible that two distinct clients have exact copies of data e.g. pictures movies songs documents that each client stores in the online storage system. However since both files would be uniquely encrypted by each client the encrypted data is not identical and the online storage system must store two copies of the same unencrypted data albeit in encrypted form . The service is unable to store just one copy of this data as each client would only be able to decrypt the copy that client uploaded.

One alternative approach is to have the service manage the encryption keys on the server side and thus be capable of decrypting files that the clients upload. The server is then able to determine that two decrypted files are identical and store just one copy of the decrypted data. Then when each client requests its data the server encrypts the data with that client s encryption key and transmits the requested file. This approach compromises security in that the operator has complete access to each client s data. Unscrupulous operators may rifle through their client s data. Further the service itself is a single point of weakness and a successful breach in security exposes all of the clients data.

Under either the traditional or alternative approach described each time a client saves a file to the online storage system the client must upload the encrypted data regardless of whether a copy of that file in encrypted or unencrypted form already exists in the online storage system. Thus even under the alternative approach described the client wastes valuable bandwidth resources uploading data the server does not need because the online storage system already has the data in its storage pool.

It is desirable to construct a storage system a cloud storage system which stores encrypted client data eliminates duplication of data stored in the cloud storage system without having client encryption keys on the servers and minimizes bandwidth utilization. The following description describes methods and apparatus for generating a cloud storage system that minimizes duplication of data in the cloud storage system while providing end to end encryption of data and minimizing bandwidth utilization.

In the following description numerous specific details such as logic implementations opcodes means to specify operands resource partitioning sharing duplication implementations types and interrelationships of system components and logic partitioning integration choices are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated however by one skilled in the art that the invention may be practiced without such specific details. In other instances control structures gate level circuits and full software instruction sequences have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

References in the specification to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

In the following description and claims the terms coupled and connected along with their derivatives may be used. It should be understood that these terms are not intended as synonyms for each other. Coupled is used to indicate that two or more elements which may or may not be in direct physical or electrical contact with each other co operate or interact with each other. Connected is used to indicate the establishment of communication between two or more elements that are coupled with each other.

To ease understanding dashed lines have been used in the figures to signify the optional nature of certain items e.g. features not supported by a given implementation of the invention features supported by a given implementation but used in some situations and not in others .

The techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices. Such electronic devices store and communicate internally and or with other electronic devices over a network code and data using non transitory tangible machine readable medium e.g. magnetic disks optical disks read only memory flash memory devices phase change memory and transitory machine readable communication medium e.g. electrical optical acoustical or other forms of propagated signals such as carrier waves infrared signals digital signals etc. . In addition such electronic devices typically include a set or one or more processors coupled with one or more other components such as a storage device one or more input output devices e.g. keyboard a touchscreen and or a display and a network connection. The coupling of the set of processors and other components is typically through one or more busses or bridges also termed bus controllers . The storage device and signals carrying the network traffic respectively represent one or more non transitory tangible machine readable medium and transitory machine readable communication medium. Thus the storage device of a given electronic device typically stores code and or data for execution on the set of one or more processors of that electronic device. Of course one or more parts of an embodiment of the invention may be implemented using different combination of software firmware and or hardware.

In the cloud storage system acts as a primary storage of data for cloud file systems CFS . Furthermore the client devices A D are configured to run a CFS client module configured to access the CFSs. The CFS client module further manages a local cache of the CFSs utilized by that client device A B. The local cache in each client device A D is largely transparent to users of client device A D. Further while a user utilizing a client device A is shown the appearance of each file and folder stored in that user s CFS not all data required for accessing all of those files and folders is always present in the local cache of that user s CFS. As the user accesses a file from his CFS the client device A retrieves any data from the cloud storage system that is not present in his client device s A local cache and is required to access that file. As the local cache in the user s client device A fills with data from the cloud storage system the client device A evicts data from the local cache to make room for data from the cloud storage system . In at least one embodiment the data located in the local cache of the CFS can be marked for non eviction pinned so during eviction pinned data will not be evicted from the local cache of the CFS. In at least one embodiment the client device A presents the contents of the CFS to the user as if the CFS is a local device.

For example the CFS client module may include a database of file chunks that are present in the local cache of the CFS. The database of file chunks would comprise information used by the CFS client module to track which file chunks are present which file chunks may be evicted to make room for more file chunks which file chunks have been pinned for local caching which file chunks have been saved to the cloud storage system and how much space is being used by the local cache. One method the CFS client module may use to determine which file chunks should be evicted is to determine the timestamp each of the cached file chunks was last used by the client device for instance the database would include a field that is updated each time a file chunk is accessed by the CFS client module. The CFS client module would then be able to determine any file chunks that have not been recently accessed for example accessed in the last thirty days and elect those for eviction first. The CFS client module could track the access use of a file chunk whenever the CFS client module attempts to retrieve a file chunk as described with reference to . The CFS client module may further track how often a file chunk has been used by incrementing a counter in the database each time a file chunk is used. Then the CFS client module can take into account the used counter when determining which file chunks should be evicted such that between two otherwise equal eviction candidates the candidate with a lowed used count would be evicted first. It will be appreciated by those skilled in the art that other eviction strategies may be implemented which include more less or different eviction criteria. For example it will be appreciated that the CFS client module would cache the file chunks in the client device s local storage system and a user may be enabled to set a storage limit for the local cache such that the CFS client module starts evicting file chunks as that storage limit is approached or exceeded by the data in the local cache.

In one embodiment of the database of file chunks the file chunks themselves are also stored in the database while in another embodiment the file chunks are stored separately from the database and the database is used for tracking of this file chunks.

These features present the distinct advantage of seamlessly integrating a CFS with client device A such that the user can treat the CFS similarly to other storage systems available to the client device A. Furthermore the CFS is capable of storing far more data than the amount of data saved the local cache in client device A. For example if the client device s local storage system can store 80 gigabytes GB of data and the local cache is limited to 12.5 of the local storage system then the local cache is 10 GBs. However the CFS may comprise every file ever stored in the cloud storage system. The amount of data is likely far greater than 10 GBs and is probably orders of magnitude perhaps 100 terabytes. Since the CFS client module only keeps up to 10 GBs at a time the CFS client module is able to represent all the files available to a user on the client device without actually having all the data needed for those files. As a user accesses files in the CFS the CFS client module retrieves needed data from the cloud storage system. It should be noted that the amount of storage space available to the client device for storage in the CFS is not limited based on the client device s local storage system which only requires enough storage space to provide adequate space for the local cache. Rather the amount of storage space available to the client device for storage in the CFS is limited based on the amount of storage in the cloud storage system.

This creates many desirable usage models for users on a client device. For example by using a CFS the user has access to vast amounts of storage space without ever adding large storage devices to the client device. As a user fills the capacity of their local storage system it is possible to move data into the cloud storage system to free capacity in the local storage system.

Further files are available to all of a user s client devices by mounting the CFS on that device and the CFS is available to another client device once the CFS is mounted. As such it is possible to provide a client device with access to files by granting access read or write access to a CFS. Then as the client devices accesses files that file data is retrieved from the cloud storage system making sharing of data across devices seamless and noticeable faster than waiting to download an entire library of files to share. Further a user with a large media collection could convert their media library folder to a folder in the CFS and share that CFS with all of the user s devices. Then all of the user s media collection would be available to any client device that mounted the CFS. Further the user can easily create a snapshot or a new version of an entire file system simply by copying a CFS manifest to a new name without uploading any additional file data or storing copies of the files in the CFS thereby allowing a user to keep multiple versions of entire file systems at his fingertips.

Further as the CFS client module becomes more integrated with a device for example becoming part of an operating system loaded very early in the initialization of a client device then more and more files can be stored in the cloud storage system. In fact not only would a user s documents be available in the CFS but even applications could be made available in the CFS. In fact manufacturers could easily integrate the CFS client module into the operating system on a cloud device and push operating system files and application files to the client device by updating a CFS and sharing the CFS with the client device which accesses its files from the CFS.

Further content providers now have an easy method of distributing content to subscribers by generating a CFS containing their content and sharing the CFS with users. In fact the content provider could generate individual cloud file systems specific to each user all containing the same content and only upload the content one time since each user would have access to the content once the user mounted his specific CFS. In fact utilizing central access control capabilities of the cloud storage system the content provider could disable access to CFS to users no longer subscribed.

In one embodiment the cloud storage system is a service provided to users that join the service and generally open to the public to join. Another embodiment of the invention allows an enterprise to maintain a cloud storage system for client devices A D that are members of the enterprise.

The cloud storage gateway translates requests from the client device A to cloud storage system application programming interface API calls. Furthermore in at least one embodiment the cloud storage gateway includes a remote cache of the cloud storage pool . Thus the cloud storage gateway receives requests for data as the client device requests data from the cloud storage system . In turn the cloud storage gateway utilizes cloud storage system API calls to request data from the cloud storage pool . As the cloud storage gateway receives the requested data from the cloud storage pool the cloud storage gateway transmits the requested data back to the client device A. Further in embodiments where the cloud storage gateway includes a remote cache of the cloud storage pool the cloud storage gateway saves the requested data in the remote cache of the cloud storage pool such that future requests for the requested data from the client device A or other client devices not shown can be serviced without communicating with the cloud storage pool . As the remote cache of the cloud storage pool fills the cloud storage gateway evicts data from the remote cache of the cloud storage pool to make room for more data from the cloud storage pool .

As described in the background traditional client side encryption encrypts data with keys that are unique to each user or client device. Therefore the same data encrypted by two clients using traditional client side encryption has a high probability having differences between the resulting encrypted data. However the user agnostic file encryption differs from traditional encryption in that two files with the same data encrypted by different users or client devices will produce files with identical encrypted data.

The CFS client module continues at block by storing the encrypted file in a local cache of the CFS on the client device. The CFS client module utilizes user agnostic deduplication to store the encrypted file on the client device. When utilizing user agnostic deduplication the CFS client module is able to recognize when the encrypted file is already present in the local cache of the CFS and does not store a second copy of the encrypted file.

The CFS client module continues at block by performing a server side user agnostic file deduplication wherein the CFS client module determines whether the encrypted file is already present in the cloud storage system. In the case that the encrypted file is not present in the cloud storage system the CFS client module transmits the encrypted data to the cloud storage system. The server side user agnostic file deduplication enables the CFS client module to cause the cloud storage system to store the encrypted file such that other users or client devices can access the encrypted file from the cloud storage system given the other users or client devices can identify the encrypted file. However although the other users or client devices may have access to the encrypted file the other users or client devices would not be able to decrypt the encrypted file without previously generating or receiving the encryption key used by the user agnostic file encryption function.

In at least one embodiment the CFS client module determines one or more of the chunks will benefit from a data transformation function and in that case transforms those chunks that will benefit from the transformation. For example chunks of data may benefit from a compression transformation such as zip bzip or gzip thereby reducing the size of the chunk. Still further some chunks would not benefit from transformation or it would not be desirable to transform those chunks and therefore no transformation will occur on those chunks.

In block the CFS client module generates a set of compressed chunks A N. In one embodiment the CFS client module further embeds information into the compressed chunk describing how the chunk was transformed e.g. which compression algorithm was utilized . As described above it may be that one of more of the compressed chunks A N is identical to the chunk from which it derived i.e. no compression or transformation occurred . Further one of skill in the art would recognize that compression of chunks could occur at another time in processing the chunks. For example compression could occur after the encryption key was generated in block but prior to encryption of the chunk. Even still compression could even after encryption of the chunk in block although conventional understand suggests that compression of encrypted data does not produce results as favorable of encryption on unencrypted data.

The CFS client module generates a file manifest at block . The CFS client module iterates through each chunk in the set of compressed chunks A N at block . Using each chunk e.g. chunk A the CFS client module generates an encryption key A an encrypted chunk A and a chunk identifier ID A from chunk A with user agnostic encryption in block . In block the CFS client module stores the chunk ID A and the encryption key A in the file manifest . The CFS client module stores each chunk ID A N and the encryption key A N in the file manifest in the order the corresponding chunk A N appear in the file . The encryption keys A N are sometimes referred herein as user agnostic encryption keys.

In block the CFS client module stores the encrypted chunk A in the cloud storage system at a location corresponding to the chunk ID A. For example the CFS client module may invoke a communication thread responsible for transmitting the encrypted chunk A to the cloud storage system for storage. This way the CFS client module may invoke a plurality of communication threads for uploading a plurality of chunks to the cloud storage system. These threads may be managed by the CFS client module such that at any given time only a designated number of threads exist and only a designated amount of bandwidth is consumed such that the client device s performance is not degraded by the CFS client module. Further the CFS client module can prioritize the communication threads such that certain chunks are transmitted prior to other chunks. For example if the CFS client module receives an indication that a CFS has been shared with other users or devices then the CFS client module can prioritize the upload of encrypted chunks associated with the shared CFS. In this way encrypted chunks that may be requested from other users and client devices will be uploaded to the cloud storage system before other encrypted chunks that have not been shared with other user or client devices.

In one embodiment the client device includes a local cache of the CFS and the CFS client module determines whether the local cache of the CFS already contains an encrypted chunk at the location corresponding to the chunk ID A. Since chunks are encrypted with user agnostic encryption the chunk ID A corresponds with the encrypted data A regardless of whether it was generated by another user or client device. Therefore if the local cache of the CFS contains an encrypted chunk at the location corresponding to the chunk ID A then that encrypted chunk is identical to the encrypted chunk A and the CFS client module need not store the encrypted chunk A again.

Similarly the CFS client module can inquire the cloud storage system whether the cloud storage system contains an encrypted chunk at the location corresponding to the chunk ID A and if the cloud storage system does not the CFS client module can queue an upload of the encrypted chunk A and chunk ID A to the cloud storage system. For example a cloud storage system generates a data structure indicating data that is present in the cloud storage system. This data structure is communicated to the client device and the CFS client module inquires with the data structure to the presence of a chunk. This way the CFS client module does not have to upload chunks that already exist in the cloud storage system. In one embodiment the data structure is a hash table of all chunk IDs present in the cloud storage system. In another embodiment the data structure is a bloom filter that is used to determine which chunks are present in the cloud storage system. Still other data structures may be provided to allow the CFS client module to inquire regarding which chunks are present in the cloud storage system or the CFS client module may communicate the inquiry with the cloud storage system which in turn responds with the status of the chunk s presence in the cloud storage system.

The inquiry of which chunks already exist in the cloud storage system presents significant advantages. Specifically the cloud storage system can be seeded with data from any client device since the stored chunks of identical data are identical regardless of which client device or user stored the chunk into the cloud storage system. A service provider for example could seed the cloud storage system with data it determines will be highly likely to be on client devices. For example applications and operating system files have a high degree of identity across users and client devices. If this data is added to the cloud storage system by any of the service provider a client device or a user than any subsequent client device or user will not have to upload the data since it already exists in the cloud storage system. Because data transmission consumes valuable resources e.g. time required to upload and bandwidth usage which may have a monetary cost associated the lack of uploading the data presents savings to the service provider and the client device user. This same savings can be gained with the storage of media data which has a high degree of identity. For example a song or movie retrieved from a content distributor is likely to have a high degree of identity regardless of which user retrieved said data. Once a first user or client device stores that data into the cloud storage system other client devices or users will have no need to upload the data again.

At block the user agnostic encryption function returns the completed file manifest for further processing such as adding the file manifest to a file system manifest containing the details of the files and folders location in the CFS.

For example the encryption key could be the result of hashing the data . Examples of desirable hashing algorithms include cryptographic hash functions e.g. a secure hash algorithm SHA like SHA 0 SHA 1 SHA 256 or SHA 512 or a message digest MD algorithm like MD 2 MD 4 or MD 5 . In other embodiments the encryption key could be calculated via other algorithms. For example the encryption key could be calculated as simply as retrieving a predetermined sub set of the data .

The user agnostic encryption method continues at block by generating encrypted data using the data and the encryption key . The data can be encrypted with any suitable encryption symmetric or asymmetric encryption algorithm. Non limiting examples of suitable encryption algorithms include Advanced Encryption Standard AES Data Encryption Standard DES Triple DES Blowfish Twofish Serpent Rivest Shamir Adleman RSA NTRUEncrypt and Elliptic Curve Cryptography ECC . In any case a suitable encryption algorithm and encryption key generation method are selected so that the generated encryption key is usable by the selected encryption algorithm.

In block an ID is generated from the encrypted data . The ID can be any ID that will be identically generated regardless of the user or client device generating the ID for that particular data . For example the ID could be the result of hashing the encrypted data . As described with reference to block any suitable hashing algorithm may be used. In other embodiments the ID could be calculated via other algorithms such as retrieving a predetermined sub set of the encrypted data . Still further embodiments of the invention may generate the ID using the data rather than the encrypted data though such embodiments may expose the encrypted data to potential security risks. In block the user agnostic encryption method returns the encryption key the encrypted data and the ID . It would be appreciated by one of skill in the art that the CFS client module may wish to embed information with the encrypted data . For example the CFS client module may prepend the encrypted data with a fixed or variable width chunk header. The chunk header could include information such has block type encoding type and original size. This block header could then be used by the cloud storage system and or CFS client modules to validate data and or to assist in the decryption decompression of encrypted chunks. In one embodiment the chunk header includes the block type one byte encoding type one bye and original size four byes . While another embodiment the chunk header includes more less or other fields. For example one embodiment of the invention generates a chunk header comprised of an encoding type and original size only.

Embodiments of the invention are described with reference to symmetric encryption algorithms in which the same key used to encrypt data is also used to decrypt data. However using an asymmetric algorithm one that utilizes one key for encryption and a different corresponding key for decryption is equally operable. When using an asymmetric encryption function for the user agnostic encryption the user agnostic encryption method described would need to return a decryption key corresponding to the generated encryption key instead of the encryption key . Likewise other references to saving an encryption key for future decryption of encrypted data would instead save the corresponding decryption key.

In one embodiment of the invention it is necessary for each user and client device to utilize the same algorithm when generating the ID so that data stored in the location identified by ID is identical for all users and client devices accessing said data. Further while it is described that numerous algorithms may be used to generate the encryption key the encrypted data and the encrypted data it would be appreciated by one skilled in the art that certain advantages exist when selecting the same algorithms for all users within a particular system. Particularly when each user or client device utilizing a given cloud storage system employs a given set of algorithms then for identical data each user or client device will generate identical encryption keys encrypted data and IDs. Therefore although the encryption of the data will be user agnostic the cloud storage system will be able to identify encrypted data by its corresponding ID and only store one copy of that data.

In block the CFS client module generates a file manifest encryption key an encrypted file manifest and a file manifest ID . In one embodiment these are generated with a user agnostic encryption method such as described with reference to . In block the CFS client module stores the file manifest ID and the file manifest encryption key in a file system manifest . The file system manifest comprises a listing of all files stored within the CFS. Along with information identifying the files for display to the user such as the path at which each file should be displayed the corresponding file manifest ID and file manifest encryption key is stored so that the CFS client module can retrieve the encrypted file manifest corresponding to that file from the cloud storage system and decrypt the encrypted file manifest.

In block the CFS client module optionally stores file attributes corresponding to the file . For example a file may have set of metadata associated with the file such as file size creation timestamp modification timestamp access control listings permissions read only marker hidden file marker or other attributes as used by client device.

In block the CFS client module stores the encrypted FM in the cloud storage system with user agnostic deduplication. As such the CFS client module performs a server side user agnostic deduplication wherein the CFS client module determines whether the encrypted file manifest is already present in the cloud storage system. In the case that the encrypted file manifest is not present in the cloud storage system the CFS client module transmits the encrypted file manifest to the cloud storage system along with the file manifest ID . Further the CFS client module may perform a client side user agnostic deduplication wherein the CFS client module is able to recognize when the encrypted file manifest is already present in the local cache of the CFS and does not store a second copy of the encrypted file manifest.

In one embodiment the CFS client module generates an encrypted file system manifest from file system manifest at block . One method of generating the encrypted file system manifest is to perform a user relative snapshot encryption on the file system manifest . Another method of generating the encrypted file system manifest is to perform multi user file system manifest encryption.

With the user relative snapshot encryption the CFS encrypts the file system manifest with an encryption key provided by or unique to a user or the client device. With this method the user may share the encryption key in the case of symmetric encryption or corresponding decryption key in the case asymmetric encryption with other users or devices which should be given access to this CFS. Correspondingly a copy of the encrypted file system manifest may be stored in the cloud storage system but only those users and client devices with the corresponding encryption key would be able to decrypt the encrypted file system manifest . Thus encrypted file system can be stored in the CFS but only those user and client devices with requisite encryption key would be able to access the information needed to identify decrypt the encrypted file manifests listed in the encrypted file system manifest . This method has the advantage of allowing the CFS client module to share a snapshot of a CFS with another user or client device. The CFS client module need only create an encrypted file system manifest using an encryption key to be shared with the other user or client device. Then the CFS client module can upload the encrypted file system manifest to the cloud storage system and share an ID for the encrypted file system manifest and the encryption key with the other user. In another embodiment the CFS client module can transmit the encrypted file system manifest and the encryption key directly to the other user or client device. The other user or client device would then have access to all files that were present in the CFS when the CFS client module generated the encrypted file system manifest . However any changes made by the other user or client device would only be reflected in a newly created file system manifest corresponding with the other user or client device and would not impact the user or client device that initially generated the encrypted file system manifest . Therefore a user can share a snapshot of an entire CFS with another user or client device by merely transmitting the encryption key and encrypted file system manifest or encrypted file system manifest ID.

With multi user file system manifest encryption a user can share a CFS with another user or client device in a live manner. A live manner means that changes made by the user would be reflected to the other user or client device further any changes made by the other user or client device would be reflected to the user.

Multi user file system manifest encryption starts with the CFS client module generating a universally unique identifier UUID . The CFS client module determines whether that UUID exists in the cloud storage system and continues to generate a new UUID until an unused UUID is generated. Once a new UUID is generated the cloud storage system generates a multi user file system manifest collection identified by the UUID. In one embodiment of the invention the cloud storage system further creates a set of access permissions associated with the multi user file system manifest collection and grants a user associated with the CFS client module access to the multi user file system manifest collection. The multi user file system manifest collection is a versioned bucket of encrypted file system manifests for this CFS. Now the CFS client encrypts the file system manifest with the UUID as the encryption key and transmits the encrypted file system manifest to the cloud storage system for storage in the multi user file system manifest collection. Subsequent changes to the CFS are generated as patch changes against the version of the CFS utilized by the CFS client module that generated the changes. The file system manifest and the subsequent patch changes are all stored in the multi user file manifest collection such that subsequent users and client devices which have been granted access to the multi user file system manifest can download each entry in the multi user file manifest collection to reconstruct the current state of the cloud file system. Furthermore users and client devices which have been granted access can subscribe with the cloud storage system to receive updates to the CFS. Thus as users change information the CFS those changes are seamlessly pushed to subscribed users and client devices.

In one embodiment of the invention the cloud storage system can present a user interface to the client device such as a web interface that allows the user to manage that user s file system manifests. For example the user can choose to create a shareable snapshot of a file system manifest and perform user relative snapshot encryption to make the copy of the file system manifest that is sharable with another user. For example the cloud storage system can be instructed to email a link to the snapshot. Further the email may comprise the information needed to decrypt the shared file system manifest. In another example the cloud storage system could make the snapshot available to other users of the cloud storage system through a menu in the user interface presented to the client devices.

This same user interface allows users to manage multi user file systems. For example a user on a client device can decide to generate a multi user file system from an existing cloud file system and manage the access permissions on the multi user file system. For users that have been granted access to the multi user file system the cloud storage system could make the multi user file system manifest accessible to those users via email or through the user interface. If an owner wishes to prevent a user from having access to the multi user file system the owner can change the access permissions of the multi user file system manifest such that the user will no longer be granted access to download entries from the multi user file system manifest collection identified by the corresponding UUID. Further read only permissions for users or client devices can be enabled through the same user interface.

When writing to just a portion of a file stored in a cloud file system the file chunk corresponding to the portion being written to is copied into memory. The updates to the file chunk are performed on the portion in memory and that updated file chunk is encrypted. This as described above results in a new chunk ID and encryption key for that chunk that is used to update the corresponding file manifest. In the case of adding data to the middle of a file multiple chunks may require updating as the data will shift to accommodate the new data. This requires retrieving each file chunk corresponding with each portion of the file and performing updates encryptions and file manifest updates for those portions that changed. In the case of appending data to the end of the file the process is either an update to an existing chunk as previous described a combination of an update to an existing chunk and an addition of a new chunk or just the addition of a new chunk.

The CFS client module mounts a CFS as a drive or directory on client directory using a file system manifest for that CFS. As described above a file system manifest comprises information including a list of file manifests along with a path under which each file in the file system manifest is located. To the user of the client device the CFS client module shows the CFS as a part of the client devices storage hierarchy. For example a CFS may be mounted at a mount point in the client devices storage system. A mount point may be as a drive e.g. E Drive or as a folder in an existing drive or storage system. This allows the CFS client module to present the CFS to the client device and in turn a user as any other storage system. Another way of describing this is that the CFS client module emulates a block storage device to the operating system of the client device.

The CFS client module receives a request for data from a file in the CFS at block . The request for data includes information identifying a set of data the CFS client module should return. For example the request may include a path to the file in which data resides. Further the request may include a seek position and byte count to indicate where and how much data to be read. The CFS client module locates a file manifest corresponding to the file at block . A file manifest is located in the CFS as follows. The CFS client module locates a file manifest ID corresponding to the file from the file system manifest. In one embodiment the CFS client module determines whether a decrypted file system manifest is present in a local cache of the CFS. In another embodiment the CFS client module determines whether the encrypted file system manifest is present in the local cache of the CFS. In yet another embodiment CFS client module determines whether the local cache of the CFS contains the encrypted or decrypted file manifest. If neither the encrypted or decrypted file manifest resides in the local cache of the CFS then the CFS client module retrieves the encrypted file manifest from a cloud storage system using the file manifest ID to identify the encrypted data. Once the CFS client module has the encrypted file manifest or in the case that the encrypted file manifest is in the local cache but the decrypted file manifest is not the CFS client module decrypts the encrypted file manifest using an encryption key associated with the file manifest in the file system manifest. Further the CFS client module may store the encrypted file manifest the decrypted file manifest or both in the local cache of the CFS for future access.

At block the CFS client module determines one or more file chunks needed to retrieve the requested data. In one embodiment the CFS client module uses the seek position byte count to determine which file chunks are required to retrieve the requested data from the CFS. For example if CFS client module split the file into 64 byte chunks when saving a file to the CFS then the CFS client module can determine the first chunk required by performing an integer divide on the seek position with the 64 byte chunk size. As described above the file manifest includes an ordered list of chunk IDs and encryption keys for decoding the file chunks. Further the CFS client module can determine the last chunk required by adding the byte count to the seek position and performing an integer divide on the result with the 64 byte chunk size. As such the CFS client module can determine that it needs the first chunk last chunk and all chunks in between to derive the requested data. One of skill in the art would recognize that a 64 byte chunk size may not be optimal for storing data in the CFS. A chunk size of 512 kilobytes may be optimal in some configurations other configurations may be better served with chunk sizes of other amounts such as 64 kilobytes 128 kilobytes or 256 kilobytes. One of skill in the art would understand that the invention is not limited to any particular chunk size and the chunk sizes listed are exemplary and not limiting.

At block the CFS client module iterates over each required filed chunk. At block the CFS client module determines whether the current file chunk is present in the local cache of the CFS. If the current file chunk is not present in the local cache of the CFS then the CFS client module retrieves that file chunk from the cloud storage system in block . For example when the CFS client module requires the first file chunk listed in the file manifest the CFS client module issues a request to the cloud storage system to transmit the file chunk associated with the first chunk ID. Once the CFS client module receives the file chunk requested CFS client module can further process that file chunk.

In one embodiment the CFS client module validates a received file chunk . A file chunk can be validated by generating a retrieved chunk ID from the file chunk that was received. Since chunk IDs are generated from the contents of encrypted data the chunk ID request should match the generated chunk ID if the retrieved data is valid.

In some embodiment of the invention the CFS client module uses predictive retrieval for file chunks nearby to the requested file chunk. For example it is advantageous to anticipate other file chunks that might be needed from the cloud storage system. As such the CFS client module may look in the file manifest for file chunks listed in the file manifest near the requested chunk. For example if the requested file chunk is the first file chunk listed in the file manifest the CFS client module can queue and retrieve the next file chunk listed in the file manifest so that the next file chunk will be in the local cache of the CFS if and when that chunk is needed to retrieve the requested data. One of skill in the art will recognize that it may be advantageous to queue and download the next 8 file chunks for example or the CFS client module may queue and download 4 file chunks before and 4 file chunks after. Other embodiments of the invention retrieve more or less or different sets of file chunks depending on the logic used for the predictive retrieval. For example the CFS client module may queue the next two chunks that are not present in the local cache of the CFS such that if the first next chunk and third next chunk are present but the second and fourth next chunks are not present then the CFS client module will retrieve the second and fourth next chunks.

In other embodiments the CFS client module uses analytical determinations for the predictive retrieval of file chunks. For example the CFS client module can generate a database of chunk access to model how chunks are accessed. The CFS client module can keep track of the previous chunk ID that is accessed and then when the next chunk ID is accessed the CFS client module can generate an entry indicating a first chunk ID a second chunk ID and a count. Each time a chunk ID is accessed the CFS client module can use the previous chunk ID and the current chunk ID to update this tracking. As such the previous chunk ID is used as a first chunk ID and the current chunk ID is the second chunk ID the count starts at 1 and each time the same combination of previous chunk ID and current chunk ID is accessed the count is incremented. The CFS client module can use this analytical model to determine which chunks have the greatest likelihood of being accessed based on a chunk that is being accessed. For simplicity sake let s take three file chunks that may be part of the same of different file chunks Chunk A Chunk G and Chunk P. We may find that when Chunk G is accessed on 4 occasions Chunk A was accessed previously. We may also determine that when Chunk P is accessed on 18 occasions Chunk A was accessed previously. This can be represented as Chunk A Chunk G 4 Chunk A Chunk P 18. Therefore the next time that Chunk A is accessed the CFS client module can determine that Chunk P has a higher likelihood of being accessed. Thus the CFS client module can predictively retrieve Chunk P when Chunk A is accessed. One of skill in the art will recognize that it may be advantageous to queue and download multiple chunks in a chain based on the analytical model. For example if Chunk B is being accessed and the model predicates access to Chunk C but Chunk C is present in the local cache then the CFS client module will predict a chunk that is likely to be accessed after Chunk C. The CFS client module may further determine to follow the chain until two chunks are retrieved for the local cache or until four chunks are retrieved. Those skilled in the art would recognize that different numbers of chunks may be more or less advantageous and tailor the CFS client module to take advantage of the number of chunks to predictively cache. Further the CFS client module may recognize that for one chunk many chunks have a likely chance of being accessed next and predictively cache one or more of those chunks in a chain with those chunks.

Still other embodiments may use other approaches for analytically determining a next chunk to retrieve based on user and or client device behavior. For example the CFS client module may associate user interface queues with chunk access and generate the local cache on that module. In other embodiments the CFS client module may keep track of file chunk accesses based on models of network activity or models of applications running such that when a user accesses information at certain network locations the CFS client module may associate that with accessing certain file chunks and cache those file chunks when those network locations are accessed. The CFS client module may associate the access of file chunks to when a certain application is accessed and then cache those file chunks in the local cache when that application is accessed in the future.

In support of the predictive retrieval of file chunks the CFS client module employs a queue of chunk IDs that should be retrieved and a plurality of download threads to service said queue. It is advantageous to prioritize the retrieval of file chunks based on a determination of whether the file chunk is likely to be used sooner than other file chunks in the queue. As such when the CFS client module determines it should retrieve a file chunk either a retrieval associated with access to data in the file chunk or a predictive retrieval the CFS client module will add the requested chunk ID to the download queue and associate that chunk ID with a priority value. The priority value for each chunk ID is chosen in a manner such that the download threads choose chunk IDs from the download queue that require more immediate access first. As such the CFS client module can associate chunk IDs that were requested for retrieval in block as part of the file access with a higher degree of priority while chunks added to the download queue as part of the predictive retrieval of nearby file chunks in block are associated with lower degrees of priority.

One particular implementation is to determine how close a chunk being retrieved is to a chunk being accessed. In this way a chunk ID in the download queue being retrieved as part of the chunk access in block would have a distance of 0 as it is the ID of the chunk being accessed. When the CFS client module determines it should predictively retrieve the first next chunk in the FM and fourth next chunk in the FM then the corresponding chunk IDs would receive a distance of 1 and 4 respectively as reflective of those chunks distance from the accessed chunk. This same principal may be employed when using a chain of chunk accesses with the chunk analytical method. As the CFS client module follows the chain to find the next chunk not in local cache that should be retrieved from the cloud storage system the CFS client module can track how far down the chain it travelled and use that as a distance from the chunk being accessed. Thus chunk IDs with a smaller distance from the chunk being accessed will be prioritized over chunks with a farther distance in the download queue by the download threads. One implementation is further described with reference to .

Further in embodiments of the invention in which the cloud storage system supports remote caching of the CFS the CFS client module may instruct the cloud storage system to prefetch nearby file chunks in block . For example in one embodiment of the invention the cloud storage system comprises a cloud storage gateway and a cloud storage pool. As such it is advantageous to instruct the cloud storage gateway to place file chunks that will need to be transmitted to the client device in the cloud storage gateway s remote cache of the cloud storage pool in other words instruct the cloud storage gateway to prefetch the file chunks. This way the cloud storage gateway will have the file chunk in its remote cache when the CFS client module retrieves the file chunk from the cloud storage system thereby eliminating latency that would otherwise occur if the cloud storage gateway had to retrieve the requested file chunk from the cloud storage pool. Further the CFS client module may instruct the cloud storage gateway to prefetch the next two file chunks that are not present in the local cache of the CFS that the CFS client module predicts access to. As such if the first next and third next chunks are present in the local cache but the second and fourth next chunks are not present in the local cache then the CFS client module will instruct the cloud storage gateway to prefetch the second and fourth next chunks for storage in the remote cache so that the cloud storage gateway does not have to retrieve those chunks from the cloud storage pool when the CFS client module request those chunks.

In block the CFS client module optionally stores the retrieved file chunk in the local cache of the CFS at a location associated with that file chunk s ID. At block the CFS client module performs user agnostic decryption and decompression of the file chunk. As discussed above the file manifest has an encryption key or decryption key in the case of asymmetric encryption algorithms associated with each file chunk by that chunk s ID. Therefore the CFS client module can retrieve the encryption key decryption key from the file manifest to perform the file chunk decryption. Further as discussed above some file chunks may benefit from compression and be compressed thus the CFS client module will decompress the file chunk if that is the case. In block the CFS client module optionally stores the decrypted decompressed file chunk in the local cache of the CFS at a location associated with that file chunk s ID. Once the decrypted decompressed chunk is available the CFS client module continues at block as described later.

It should be noted that one embodiment of the invention will cache the encrypted file chunk in block while another embodiment of the invention will cache the decrypted decompressed file chunk in block . Still further embodiments may cache both the encrypted file chunk in block and the decrypted decompressed block however in at least one embodiment the decrypted decompressed file chunk is cached in a portion of the local cache that is volatile such that the decrypted decompressed file chunk would not be present upon a power down or would even be removed after a determined period of time. This presents the added security that all though the encrypted file chunk may be present in the local cache the data would not be available to a user of the client device if the CFS client module was not properly activated to decrypt said data. For example it could be that the CFS client module stores the decrypted file system manifest in a volatile portion of local cache as well and requires a user to login on the client device in order to decrypt the file system manifest. Thus all the encryption keys for the file manifests and subsequent file chunks of each file would be protected from an authorized user of the client device.

Referring back to block if the CFS client module determines that the file chunk is present in the local cache of the CFS then the CFS client module continues on to block by retrieving the file chunk from the local cache. It will be evident from the previous discussion that the file chunk may be stored in the local cache as an encrypted file chunk or decrypted decompressed file chunk or both. If the encrypted file chunk is the only file chunk available then the CFS client module will perform user agnostic decryption and decompression on encrypted file chunk in block . Otherwise the CFS client module retrieves the decrypted decompressed file chunk from the local cache in block . Furthermore the CFS client module may determine to predictively retrieve nearby file chunks in block and or instruct the cloud storage system to prefetch nearby file chunks in block as described above.

In one embodiment of the invention it is necessary to split the decrypted decompressed file chunk into clusters the size of which the client device expects to receive from the CFS client module in block . For example if the file chunks are stored in chunk sizes of 256 kilobytes but the client device expects data to be stored in blocks of 4 kilobytes then the CFS client module would split the decrypted decompressed file chunk in to 64 blocks to return the data to the client device. This is especially relevant when the CFS client module is emulating a block device to the client device and specifies a block size that is smaller than chunk size used by the cloud storage system.

In block the CFS client module has the requested data from the decrypted decompressed file chunk and returns the requested data to the operating system of the client device.

A user has many ways of using a cloud file system such as cloud file system . A user may initiate the generation of a new cloud file system to be used on the client device . For example the use can direct a CFS client module running on the client device to create a new storage location e.g. a new drive or new folder that is stored in the cloud storage system . Another way of using the cloud file system is to convert a folder stored on the client device to a folder stored in the cloud storage system i.e. to virtualize a folder or drive. A user on the client device can instruct the CFS client module to convert a specified folder and then the CFS client module could assume management of the files and sub folders in the specified folder. Further this conversion can take place in a non obtrusive seemingly transparent fashion. This is particularly advantageous for a user that is running out of space in a local storage system and would like to recover storage space without changing many configuration settings because files have moved from an expected location. The CFS client module can transition files from the local storage system to the cloud storage system but present the files to the client device at the same logical path where they existed prior to the conversion.

For example the CFS client module will move all the data in the specified folder to a temporary storage location on the client device. Then the CFS client module can create a new CFS associated with the specified folder and mount the new CFS at the location i.e. mount point previously containing the specified folder. The CFS client module can then begin the process of transitioning files and subfolders from the temporary storage location to storage in the cloud storage system . During the transition period the client device can access data in the specified folder by issuing requests with the CFS client module. The CFS client module will determine whether the requested data is stored in the temporary storage location or if it has already been transitioned into the cloud storage system . If the data is located in the temporary storage location then the CFS client module retrieves the data from the temporary storage location e.g. accessing the file or folder in the temporary storage location. However if the data is located in the cloud storage system then the CFS client module will access the data from the cloud storage system in the manner prescribed in . During the transition period the CFS client module will periodically determine a file or subfolder in the specified folder that has not yet been stored in the cloud storage system and process that folder for storage in the cloud storage system .

This conversion can be made available to a user on the client device through user interface commands. For example the user can select a folder from a file system browser on the client device and invoke a context menu that includes a command to convert the selected folder e.g. virtualize or Cloudify this folder. From there the CFS client module can replace the folder with a perceptively identical folder that includes the same data to the user or the CFS client module can replace the folder with a folder that is named the same but presents an indication to the user that the folder is stored in the cloud storage system . Further the CFS client module can create an indication that the folder is in the transition from local storage to storage in the cloud storage system and further present an indication once the transition is complete that the folder is fully stored in the cloud storage system .

Once a CFS is mounted for use on the client device the CFS client module stores subfolders and files in the CFS as follows. Subfolders are stored in the CFS manifest as entries and designated as folders rather than files. The entry in the CFS manifest includes the path of the folder so that when a user on the client device navigates to a location in the CFS the CFS client module can determine all the folders that are located at that location from the CFS manifest . The storage of files in the cloud storage system is described with reference to . Further entries in the CFS manifest for files include a path for that file so that when a user on the client device navigates to a location in the CFS the CFS client module can determine all the files that are located at that location from the CFS manifest . Therefore one of skill in the art would appreciate that files and subfolders in a CFS can be presented to the user from the data in the CFS manifest without having the client device store the file chunks that comprise each file in the CFS.

The process of adding a file to the CFS is visualized along the bottom of . In the client device instructs the CFS client module to save File B to a location in the CFS . The CFS client module performs user agnostic compression and encryption on File B and generates a File B manifest FM B . Further the CFS client module transmits each encrypted chunk generated by the user agnostic compression and encryption to the cloud storage system when it determines that encrypted chunk is not already present in the cloud storage system .

Since encrypted chunks can be determined to already be present bandwidth utilization is reduced when File B contains blocks of data identical to other blocks of data in other files that have been stored in the cloud storage system . This same deduplication allows the CFS client module to reduce bandwidth when a single file stored in the cloud storage system comprises multiple chunks of data that are identical since only the first chunk uploaded will need to be transmitted. One skilled in the art would appreciate that since the encryption is user agnostic two users with the same file or two files with the same chunk of data will create one or more identical encrypted chunks and only the first transmission of an encrypted chunk is required. Thereby bandwidth is reduced with storing duplicative data in the cloud storage system .

An exemplary FM B is shown in . FM B contains a listing of chunk IDs and chunk encryption keys as described with reference to . In each chunk s ID is the hash of the data in the encrypted chunk e.g. HASH ENC.CHUNK1 HASH ENC.CHUNKN . Further the encryption key is the hash of the data in the chunk e.g. HASH CHUNK1 HASH CHUNK2 . As described in these chunk IDs and encryption keys are exemplary while other embodiments of the invention utilize other user agnostic data that is deterministic from each chunk as the chunk ID and encryption key.

The CFS client module utilizes the same user agnostic encryption employed on each block on the FM B to generate an encrypted FM B ENC.FM B and a FM B ID that is the hash of ENC.FM B . Again the CFS client module uses a user agnostic deterministic encryption key FM B ENC KEY to encrypt FM B such as the hash of the data in FM B . The CFS client module stores the ENC.FM B locally and in the cloud storage system so that it is available for later retrieval using the FM B ID.

The CFS client module adds an entry to CFS manifest corresponding to File B that includes the location at which File B is presented in a folder hierarchy in CFS . The File B entry also contains the FM B ID and FM B ENC KEY. This way once a user or client device has a CFS manifest that contains an entry with the FM B ID and corresponding FM B ENC KEY then the user can retrieve and decrypt the ENC.FM B even though that user or client device did not previously have a copy of File B.

The cloud file system manifest is encrypted with a user generated key or password. For example the cloud file system manifest may be encrypted using user relative snapshot encryption or multi user file system manifest encryption as described later with reference to . The encrypted file system manifest ENC FSM is transmitted to the cloud storage system to be stored for retrieval by this user or other users.

The addition of files to a CFS has been described with reference to generating a CFS that takes the place of an existing folder or is added to a client device as another storage location. However the same principles may be employed to allow the CFS client module to manage automatic backups of some or all data in local storage on a client device. For example upon loading of the CFS client module on a client device the CFS client module can start generating backups of the local storage system that are stored in a CFS labeled as a backup for the client device on which the CFS client module is running. Thus the CFS client module can work in the background identifying files in the local storage system adding those files to the cloud storage system and generating a file system manifest listing all the backed up files that comprise a backup of that client device s local storage system. The files on the local storage system are not necessarily removed from the local storage system but the files are listed in the backup file system manifest for future disaster recovery.

Throughout the life of a client device executing the CFS client module the CFS client module can maintain backups of files as they are updated regardless of the underlying folder being virtualized into the cloud storage system. Further the CFS client module can maintain a listing of all versions of each file that are stored in the cloud storage system along with identifying information i.e. version number or modification date. In this way the CFS client module can present a user on the client device with a listing of all available versions of a file when the user indicates a desire to restore a file from the backups maintained by the CFS client module. Further the CFS client module can track a unique identifier for the client device on which it resides and label the file manifests of each backed up file within the backup file system manifest or label the file system manifest itself according to the client device s unique identifier. Using the unique identifier the CFS client module can present the user with an option to restore files from backups of this client device or allow the user to select another client device from which to restore backed up files.

In one embodiment the backup of a local storage system is automatically managed by the CFS client module. In another embodiment the CFS client module presents configuration options to a user regarding which files should be backed up to the cloud storage system or whether backups should be performed at all.

In the case that the entire local storage system is backed up in the cloud storage system a Cloudify operation can be equated as generating a file system manifest with the contents of a selected folder removing the local copy of the folder and mounting the generated file system manifest at the location of the folder. This operation need not re upload all the encrypted blocks for each file since the encrypted blocks are already in the cloud storage system from the backup procedure though the Cloudify operation would determine any updates that must occur between the backed up files and the files currently in the selected file.

In another embodiment the CFS client module is configured to automatically virtualize files folders and drives in the local storage system of the client device. As described above the automatic backup of a local storage system does not remove a file from the local storage system. However the automatic virtualization of a file folder or drive will remove the files and folders within from the local storage system and store said files and folders in the cloud storage system. Essentially the CFS client module will automatically Cloudify the files folders and or drives that it determines are candidates for automatic virtualization. The CFS client module can determine which files folders or drives are candidates for automatic virtualization with a plurality of techniques. The CFS client module can look at a modification date or an access date of the file or the files within a folder or drive to determine whether a user has used the files recently. Since this virtualization is automatic the CFS client module can favor files that have not been used recently as the user is less impacted by any delays in future access if the file must be retrieved from the cloud storage system. Other techniques for determining candidates for virtualization include tracking file usage patterns over time and generating list of files folders and drives that make good candidates for virtualization.

The CFS client module may further be configured to provide a hybrid folder of files folders contained within a CFS and files folders contained in the local storage system. For example if the user instructed the CFS client module to mount a CFS at a mount point in the local storage system that contains files and folders then the CFS client module can merge the files in the local storage system and the CFS being mounted. The CFS client module would assume management of the file in the local storage and move the files to a managed section of the local storage system. The CFS client module would then mount a virtual folder at the location of the selected folder and take responsibility for presenting the user with the contents of that folder. The CFS client module would provide the client device with a listing of the files sub folders in the local storage system now in a managed section of the local storage system and a listing file sub folders from the CFS that was mounted anytime a directory listing was performed on the hybrid virtual folder. Read operations would be handle in the way described above with reference to pass through reads during the virtualization transition. The CFS client module would have the option of saving new files and or modifications of old files to either the managed section of the location storage system or to the cloud storage system. This option may be pre configured by the CFS client module through a setting presented to the user or the option may be presented to the user upon a write operation by the CFS client module to the hybrid folder. The CFS client module may further inform the user that a conflict exists if the user elects to mount a CFS at a location in the local storage system that contains files or folder and allow the user to elect a resolution procedure e.g. choose to move all files in the CFS choose a hybrid folder approach or choose to do nothing so the user can manage the conflict themselves.

At step e and step f the client device encrypts the compressed chunks and using the respective encryption keys and to generate encrypted chunks and eD and eD i.e. eD encrypt cD K . Encrypted chunk will be identical to encrypted data since the compressed chunks and are identical as are the encryptions keys and . Furthermore the client device is utilizing the same encryption algorithm on each chunk.

At step g and step h the client device derives chunk ID and chunk ID ID and ID from the encrypted data and i.e. ID hash eD . Since the hash function used in each step is the same algorithm and the encrypted data and are identical the chunk IDs and will also be identical.

At step i and step j the client device will attempt to store the encrypted data and in the cloud storage system based on the chunk IDs and . Assuming that step i occurs prior to step j encrypted data will be uploaded in association with chunk ID to cloud storage system . The cloud storage system will store the encrypted data in a location corresponding to chunk ID thus the cloud storage system will contain stored encrypted data and stored chunk ID . When the client device attempts to store encrypted data the client device will determine that the cloud storage system already has identical encrypted data since it contains the identical stored chunk ID . The client device will not need to transmit encrypted data in association with chunk ID thus the client device will reduce the utilization of upload bandwidth by not transmitting data that already exists in the cloud storage system .

In one embodiment of the invention each client device A and begins processing each chunk and by compressing the corresponding chunk. Thus in step a and step b the corresponding client device optionally compresses chunk or to generate a compressed chunk or cD or cD i.e. cD comp D . Compressed chunks and are identical since the client devices A and are using the identical data and the same compression algorithm or no compression if the case may be.

The client devices A and continue at step c and step d respectively by generating encryption keys and K and K from the data of each corresponding chunk and D and D . Therefore in embodiments utilizing a hash function of the data to generate the encryption key K hash D . Further since Dis identical to Dand the client devices A and are using the same algorithm to generate the encryption keys then Kwill be identical to K.

At step e and step f the client devices A and encrypt the compressed chunks and using the respective encryption keys and to generate encrypted data and eD and eD i.e. eD encrypt cD K . Encrypted data will be identical to encrypted data since the compressed chunks and are identical as are the encryptions keys and . Furthermore the client devices are utilizing the same encryption algorithm on each corresponding chunk.

At step g and step h the client devices A and B derive chunk ID and chunk ID ID and ID from the encrypted data and i.e. ID hash eD . Since the hash function used in each step is the same algorithm and the encrypted data and is identical the chunk IDs and will also be identical.

At step i and step j the client devices A and B will attempt to store the encrypted data and in the cloud storage system based on the chunk IDs and . Assuming that step j occurs prior to step i encrypted data will be uploaded in association with chunk ID to cloud storage system . The cloud storage system will store the encrypted data in a location corresponding to chunk ID thus the cloud storage system will contain stored encrypted data and stored chunk ID . When the client device A attempts to store encrypted data the client device A will determine that the cloud storage system already has identical encrypted data since it contains the identical stored chunk ID . The client device A will not need to transmit encrypted data in association with chunk ID thus the client device A will reduce the utilization of upload bandwidth by not transmitting data that already exists in the cloud storage system .

With reference to and a cloud storage gateway is coupled with a cloud storage pool and communicates with one or more client devices through a communication network as described in .

With reference to each figure is a screenshot showing element s of a user interface provided by a CFS client module according to one embodiment. These screenshots are from a client device running the Mac OS X operating system. It will be appreciated by those skilled in the art that similar interfaces are provided by client devices running operating systems different than Mac OS X.

The computer system includes bus es which is coupled with a processing system a power supply volatile memory e.g. double data rate random access memory DDR RAM single data rate SDR RAM nonvolatile memory e.g. hard drive flash memory Phase Change Memory PCM . The processing system may be further coupled to a processing system cache . The processing system may retrieve instruction s from the volatile memory and or the nonvolatile memory and execute the instruction to perform operations described above. The bus es couples the above components together and further couples a display controller one or more input output devices e.g. a network interface card a cursor control e.g. a mouse trackball touchscreen touchpad etc. a keyboard etc. and optionally one or more wireless transceivers e.g. Bluetooth WiFi Infrared etc. . In one embodiment the display controller is further coupled to a display device .

In block the CFS client module generates a file system manifest encryption key an encrypted file system manifest and a file system manifest ID. In one embodiment these are generated with a user agnostic encryption method such as described with reference to . Furthermore the CFS client module stores the encrypted file system manifest in the cloud storage system with user agnostic deduplication. At block the CFS client module generates a user manifest or if a user manifest already exists adds to the user manifest. The CFS client module adds the file system manifest encryption key and the file system manifest ID to the user manifest.

In one embodiment the CFS client module further adds metadata information associated with the file system manifest to the user manifest. The metadata information may be stored as plaintext or as encrypted text in the user manifest. The metadata includes any information used by the CFS client module for enabling the usage of cloud file systems. For example a file system manifest that includes file manifests generated by a CFS client module for backup purposes may include the unique identifier for the computer from which a file was generated. Furthermore the metadata may include index information or information identifying an index that is stored in the cloud storage system for that file system manifest. The metadata may further include information identifying the mount point at which the user has mounted the cloud file system. The metadata allows another CFS client module to have an understanding of how and where the cloud file system was generated so that when a user logs into another client device the CFS client module on that client device will understand how to mount the cloud file systems listed in the user manifest.

At block the CFS client module generates an encrypted user manifest for storage in the cloud storage system. The CFS client module encrypts the user manifest with a user specific key or password. The CFS client module stores the encrypted user manifest in the cloud storage system at block . The encrypted user manifest is stored in association with the user in the cloud storage system.

Upon a the user filling in the presented fields in the user interface and the user clicking the Create New Account button the CFS client module generates a new user with the cloud storage system. The CFS client module generates a user key to associate with the new user. For example the CFS client module may use the date and time user interface input file system information or other data or combinations of these inputs to generate a random user key. The user key is encrypted by the user s password for storage in the cloud storage system. The user key is further encrypted by one or more challenge answers for storage in the cloud storage system. The CFS client module transmits the new user information to the cloud storage system to generate the new user. As such the plurality of encrypted user keys the one or more challenge questions and the user s information email first name and last name is transmitted to the cloud storage system. In another embodiment a hash of the user s password is further transmitted.

Upon generation of the new user the cloud storage system can transmit a common file system manifest and an encryption key for the common file system manifest. For example the cloud storage system may comprise a plurality of public domain movies music files pictures books or websites that can be added to the common file system manifest. The CFS client module receives the common file system manifest and common file system manifest encryption key and adds that information to a new user manifest generated for that user. The CFS client module encrypts the user manifest with the user s key and uploads the information to the cloud storage system.

As the user creates new cloud file systems virtualizes folders or changes data in existing cloud file systems the user manifest will change. The user manifest is encrypted with the user s key prior to upload by the CFS client module as the user manifest changes. Furthermore if a user wishes to share a file system with another user the CFS client module can generate a temporary user manifest with the file system manifest entry and encrypt the temporary user manifest with a key known to or a key that will be provided to the other user.

Furthermore the metadata associated with each FSM may indicate whether to mount the FSM at startup. Upon initiating the mounting of a FSM the CFS client module may determine that the mount point is not available because data resides at the location of the mount point. The CFS client module can reconcile this conflict in a plurality of ways. First the CFS client module can mount the FSM at a different location determined either automatically or selected by the user. Further the CFS client module may automatically add the contents at the conflicting location to the FSM and the cloud storage system then remove the data from the conflicting location. After which the CFS client module can mount the FSM to the conflicting location that is now fully available. Furthermore with reference to the techniques described above the CFS client module can take over management of the folder and provide the folder as a hybrid folder of files folders contained within a CFS and files folders contained in the local storage system.

The user interface allows the user to manage these virtual folders and the corresponding configuration options. The user can select one of the virtual folders A E and manage the options for that virtual folder. The user can check box to choose to mount that selected virtual folder at startup. Button allows the user to move the mount point of a folder while textbox shows the mount point at which the selected virtual folder is to be mounted. Button allows the user to mark a virtual folder for local storage. As described above the CFS client module will mark files within the virtual folder for local caching when this button is pressed i.e. ensure the file chunks that make up the files in that virtual folder are cached locally and pin the files to prevent cache eviction. Button allows the user to remove the selected virtual folder from his user manifest. The text area displays a plurality of information associated with the selected FSM such as owner access permissions folder size amount of data within virtual folder amount of data from virtual folder in the local cache and the data added to the user s manifest. Button allows a user to connect and disconnect a virtual folder i.e. mount and unmount an FSM.

Assuming that client device B is running an operating system corresponding to the file browser shown in then the operating system has issued a request for the available space for the Common Movies CFS. A client module running on the client device B has determined the data type and generated the max value in blocks and . In the available space shown at the bottom of is 17.59 terabytes which is 17 592 186 044 416 bytes or 2 to the 44th power. Therefore CFS client module has returned a max value of at least 17.59 terabytes. For example the CFS client module may have returned a max value of 17.59 terabytes which is shown to the user by the operating or the CFS client model may have generated a max value greater than 17.59 terabytes which was truncated by the operating system prior to display to the user.

Another such method for providing an amount of available space to a client device s operating system in accordance with embodiments of the invention is to determine the maximum block size and the maximum number of available blocks that the CFS client module can return to the operating system. Thus upon a request to determine the amount of space available the CFS client module returns an indication of the maximum number of blocks allowed with the maximum block size to indicate the available space.

Server based data decryption and access can be temporarily allowed if the user enters their password into a secure web form and the server decrypts the required data on the fly to display during a web session. illustrated a cloud storage system being accessed by a web file access portal and a client device in accordance with embodiments of the invention. In a cloud storage system is coupled with a network . The network provides connectivity to the cloud storage system with a plurality of devices such as client devices A B and web file access portal .

Client device B is shown running a CFS client module as described herein. The client device B is able to preview files stored in a CFS mounted on the client device B presuming the client device s operating system provides a preview function. Further the client device B can open files from the mounted CFS and copy files to the local storage system from the CFS. As described above the CFS client module provides this functionality to the client device B by issuing a series of commands to the cloud storage system shown as messages E. Messages E comprise user requested gets i.e. commands issued to get a chunk from the cloud storage system based on data being accessed by said user. The CFS client module running on the client device B may further issue predictive get commands i.e. commands issued to get a chunk from the cloud storage system based on data the CFS client module is predicating the user will access soon. The CFS client module may further issue prefetch commands to the cloud storage system that inform the cloud storage system that it should be prepared to send a particular chunk or chunks to the client device B. Messages F are shown from the cloud storage system to the client device that comprise encrypted chunks requested by a get command user requested or predictive issued by the CFS client module running on client device B.

The web file access portal provides a mechanism for a user to access files in his cloud file systems on a client device A with or without installing the CFS client module. For example a user may arrive at a public terminal or shared computer and wish to access a file or files from his CFSs without logging into or perhaps without install the CFS client module. The web file access portal provides the user with the option of accessing his data through a web file manage presented through a web interface at the cost of exposing his password and user key to the web file access portal .

As such a user starts a web browser session on client device A and navigates to a login page provided by the web file access portal . The user is presented with an authentication page to login with his login information i.e. username email and password. Further the user may be presented with service terms with which they must agree such as agreeing that usage of the web portal requires exposing their user key and password to the web file access portal to allow the web file access portal to access the user s encrypted user manifest.

Upon authenticating with the web file access portal the web file access portal retrieves the user s user manifest and the user s encrypted user key from the cloud storage system . The web file access portal uses the user s password to decrypt the user s key. The web file access portal can now decrypt the user s user manifest with the user s key. As described above the user manifest comprise listings of available cloud file systems e.g. a listing of FSMs and corresponding metadata along with corresponding encryption keys to decrypt each FSM. Using the listing of CFSs the web file access portal can generate a web based user interface that allows the user to explore his CFSs and locate files which the user wishes to access.

The web file access portal provides security to the user by acting as a pass through buffer an intermediary but does not maintain an unencrypted local cache of the cloud storage system . Depending on the security concerns present the web file access portal may not even provide a local cache of encrypted chunks from the cloud storage system . Therefore the web file access portal runs a CFS web access module that is in many ways a modified CFS client module. The CFS web access module issues messages A to the cloud storage system comprising user requested gets and optional prefetch commands. Depending on the security model the CFS web access module does not even issue predictive gets to the cloud storage system in an effort to minimize the amount of user data located on the web file access portal . As with communication to client device B the cloud storage system communicates encrypted chunks to the web file access portal .

As a user browses the folders within a CFS eventually the user will come to a file he wishes to access or download. When selecting a file in the web file browser the web file access portal will retrieve the corresponding file manifest from that CFS s FSM and decrypt the FM with the encryption key stored in the FSM. As described above this will give the web file access portal a listing of file chunks that comprise that file corresponding metadata and encryption keys. Using this information the web file access portal generates a decrypted version of the file on the web file access portal and generates an information screen which may include an embedded preview depending on the type of file being accessed. The information screen further provides a user with the opportunity to download the file. Thus client device A issues a number of messages C to the web file access portal with requests for folder and file data. The web file access portal sends messages D that include decrypted folder and file information to the web file manager. It is important to note that the references to decrypted folder and file information in messages D refer to the fact that the information transmitted from the web file access portal to the client device A is not encrypted in accordance with the encryption principles described in embodiments of the invention. However web browsers and servers employ traditional technologies e.g. Hypertext Transfer Protocol Secure HTTPS that provide secure communication in accordance to those technologies.

In the A half client device A is running a CFS client module with a user logged and with three CFSs mounted. The first CFS is shown as FSM A mounted at a mount point of home docs. The second CFS is shown as FSM B mounted at a mount point of home movies. The third CFS is shown as FSM C mounted at a mount point of home music. The user manifest is shown related to three FSM chunks FSM CHUNK A A FSM CHUNK B B and FSM CHUNK C C. FSM CHUNK A A is related to three FM chunks FM CHUNK A A FM CHUNK B C and FM CHUNK B C. FSM CHUNK B B is related to two FM chunks FM CHUNK B C and FM CHUNK D D. FSM CHUNK C C is related to two FM chunks FM CHUNK E E and FM CHUNK F F. FM CHUNK A A is related to three file chunks FILE CHUNK A A FILE CHUNK B B and FILE CHUNK C C. FM CHUNK B B is related to two file chunks FILE CHUNK C C and FILE CHUNK E E. FM CHUNK C C is related to one file chunk FILE CHUNK D D. FM CHUNK D D is related to two file chunks FILE CHUNK E E and FILE CHUNK G G. FM CHUNK E E is related to three file chunks FILE CHUNK G G FILE CHUNK H H and FILE CHUNK I I. FM CHUNK F F is related to one file chunk FILE CHUNK F F.

As shown in half A of some FM chunks e.g. FM CHUNK C C are related to more than one FSM. Further some file chunks e.g. FILE CHUNK C FILE CHUNK E and FILE CHUNK G are related to more than one FM chunk. This can be explained in that a CFS represented by a FSM may contain the same file represented by a FM in the FSM as another CFS. In this case CFSs A and B both contain the file represented by FM C. In the same one more than one file can contain the same file chunk if those files comprise a common data chunk. In the files represented by FM CHUNK A A and FM CHUNK B B comprise a common data chunk represented by FILE CHUNK C C. The files represented by FM CHUNK B B and FM CHUNK D D comprise a common data chunk represented by FILE CHUNK E E. The files represented by FM CHUNK D D and FM CHUNK E E comprise a common data chunk represented by FILE CHUNK G G.

While half A shows the chunks stored in the cloud storage system and how those chunks relate to one another half B shows the data structures those chunks comprise and the relationship of those data structures. In half B the same client device A with the same user logged into a CFS client module and the same CFSs mounted at the same locations are shown. The user manifest comprises a profile associated with the client device A that indicates how the CFS represented by FSMs should be handled by the CFS client module on that particular client device A. In this case indicating that FSM A is mounted at home docs FSM B is mounted at home movies and FSM C is mounted at home music.

Half B of shoes the user manifest in relation to three FSMs FSM A A FSM B B and FSM C C. FSM A A is related to three FMs FM A A FM B B and FM C C. FSM B B is related to two FMs FM C C and FM D D. FSM C C is related to two FMs FM E E and FM F F. Each FM A F A F is related to a file A F A F.

Further shows a second client device B with the same user logged in. The user manifest further comprises profile information PROFILE B that indicates how the client device B is configured to utilize the user s user manifest . In the client device B is shown as mounting FSM B at a similar mount point of home movies as used by client device A. Client device B is shown as mounting FSM C at a different mount point than client device A specifically FSM C is mounted at a mount point of share music. As shown in the user has chosen or configured the user manifest in such a way that FSM A is not mounted on client device B. As shown with reference to the user may utilize a management screen to mount FSM A at a desired mount point at a later time.

As in shows the same client device A with the same user logged into a CFS client module and the same CFSs mounted at the same locations is shown. The user manifest comprises a profile PROFILE A associated with the client device A that indicates how the CFS represented by FSMs should be handled by the CFS client module on that particular client device A. In this case indicating that FSM A is mounted at home docs FSM B is mounted at home movies and FSM C is mounted at home music. The same exemplary relationship between user manifest FSMs FMs and Files is shown in as was illustrated in .

Point B shows user sharing a snapshot of FSM C C with user . If the FSM C C is a Live FSM comprised of a base FSM and a plurality of changes that comprise the current version of the FSM then the CFS client module on the client device A generates a current copy of the FSM C C and stores that copy in the cloud storage system. The CFS client module running on client device A generates information comprising identifying information and encryption information for the CFS client module running on client device B to utilize the copy of FSM C C being shared with user .

As such the user receives information identifying the snapshot of FSM C C and mounts the CFS at mount point of C MUSIC. Since the FSM is a snapshot of FSM C C and not a Live share of the FSM any changes made by user or user are not reflected on the other user s client device i.e. changes create divergent FSMs. As such the snapshot of FSM C C is shown as FSM E E with the addition of a FM J J that is associated with FILE J J. As previously mention because this is a snapshot share the addition of FM J J is not reflected in FSM C C as the two FSMs C and E are divergent upon the change of any data within. It will be evident to one of skill in the art that additions of files deletions of files and modifications to files all result in divergent FSMs.

Snapshot sharing allows a user to easily share files with another cloud storage system user. For example a user of an existing web service for sharing files requires a user to open a web browser session or other client application. The user must then initiate the file upload process and navigate to the desired folder on the user s client device. The user then selects the desired files and initiates the upload. Once the upload is complete the user can elect to share the files selected with another user who receives a link to navigate to the uploaded files and can choose to view and or download those files.

With snapshot sharing a user opens their operating system s file browser and navigates the folder containing files they wish to share. The user initiates a context menu on the desired folder and initiates a command to share the folder with another user e.g. the Share with . . . command shown in the context menu illustrated in . The user then selects another user of the cloud storage system to share the folder with. If the folder is the mount point of a CFS then the CFS client module shares the FSM ID and FSM encryption key with the other user. If the folder is not a mount point of a CFS then the CFS client module can generate a FSM comprising the files and folders contained within the folder selected. In one embodiment the CFS client module encrypts the FSM ID and FSM encryption key with a key known to or that can be generated by the user the folder is being shared with. Thus the recipient of the shared folder receives a FSM ID and FSM encryption key which is added to that user s user manifest at his direction. The recipient can then choose to mount the shared FSM on their client device and access the shared files and folders through the normal means of accessing files and folders within their operating system.

In half A shows a user manifest associated with FOLDER X FSM A A. The FSM A A comprises an entry associated with file A and metadata linking file A with the save versions of that file. In Versions 1 G are associated with FM A FM G A G. Each FM A G A G is associated with the version of the file as stored in the cloud storage system i.e. File A Version 1 G A G.

In half B shows user manifest associated with FOLDER X . FOLDER X is a CFS represented by a FSM that is linked in the user manifest . User manifest comprises a link to FOLDER X and metadata associated with FOLDER X comprising a plurality of FSMs representing saved versions of FOLDER X. This is shown as FOLDER X VERSION 1 C FSM A B A C. Each FSM A C is linked to the FMs that existed in FOLDER X at the time that the version of the FOLDER X was saved. FOLDER X VERSION 1 FSM A A is linked to three files FM A A FM H H and FM I I each associated with a corresponding File FILE A VERSION 1 A FILE B VERSION 1 H and FILE C VERSION 3 I. FOLDER X VERSION 2 FSM B B is linked to two files FM I I and FM B B each associated with a corresponding File FILE C VERSION 3 I and FILE A VERSION 2 B. FOLDER X VERSION C FSM C C is linked to three files FM I I FM B B FM G G each associated with a corresponding File FILE C VERSION 3 I FILE A VERSION 2 B FILE A VERSION G G.

Thus multiple versions of the same folder and file can be listed in a FSM and be associating a version with each saved file and folder furthermore the CFS client module can associate an identifier for the client device from which the file or folder was saved for further restoration.

In both halves shows a local drive that provides a local storage system on a client device and there exists a local file system that presents a user of a client device with folders and files that user can access. In both halves the user has access to files in folder A and files in folder B.

In top half A data from Folders A and B is stored in the local storage system on local drive . A CFS client module on the client device is maintaining a user manifest including a backup FSM . The CFS client module creates automatic backups of all files in the local storage system and therefore has added the files and folders of Folders A and B to the cloud storage system . Thus the user manifest is associated with a backup FSM that is associated with a plurality of FMs Folder A File Manifests and Folder B File Manifests each File Manifest is associated with a corresponding file FILES A1 AX and B1 BX .

In the bottom half B a CFS client module has transitioned Folder B from storage in the local storage system with an automatic backup to storage in the cloud storage system without local storage the transition of Folder B may be automatic in response to a local drive running out of drive space or may be initiated by a user. The local drive has a section that comprises the local storage system and a section which comprises local cache of the cloud storage system. Since Folder A is still in the local storage system all of Folder A s data resides on the local drive . However since Folder B is now stored in cloud storage system only a portion of cached data comprising File B1 and File B7 reside in the local cache of the cloud storage system. The local copy of Folder B data has been removed and the CFS client module has mounted a cloud FSM comprises the folder B entries in its place. The cloud FSM comprises all the folder B file manifests which already resided in the cloud storage system. This transition is extremely quick and transparent to the user of the client device since the information comprising Folder B already resided in the cloud storage system as part of the automatic backups.

Client device is the first machine associated with user X the OS File Browser shows four folders in the OS File Browser A D. Folder A is not stored in the cloud storage system and all of that folder s data is shown in the local storage system. Folders B D are stored in the cloud storage system and a portion of each B C and D is shown in the local cache of the cloud storage system. The Folder B and the Folder C originated at client device and were pushed in the cloud storage system from that device. The Folder D is common data provided by the service provider of the cloud storage system to all of that provider s users. Thus Folder D was pulled from cloud storage system furthermore all of the data contained within Folder D amounts to SIZE D.

Client device is the second machine associated with user X the OS File Browser shows two folders in the OS File Browser Folder F and Folder B. Folder F is not stored in the cloud storage system and all of that folder s data is shown in the local storage system. Folder B originated at client device and thus is pulled from the cloud storage system and a portion of that data is located in the local cache of the cloud storage system. Client device may further add information to Folder B and thus would have to push that data to the cloud storage system which would push the changed FSM to the client device . The local drive is capable of storing an amount SIZE X2 of data.

Client device is the only machine associated with user Y. User Y is somehow related to user X. The OS File Browser shows three folders in the OS File Browser Folder G Folder D and Folder C. At point D in user X has shared Folder C with user Y. Therefore Folder C has been pushed to client device from the cloud storage system of which only a portion C resides in the local cache of the cloud storage system on the client device . Folder G is comprised only in the local storage system of client device while Folder D is pushed from the cloud storage system as the common data available to all users. The local drive is capable of storing an amount SIZE Y1 of data.

Client device is the only machine associated with user Z. User Z is unrelated to user X and user Y. The OS File Browser shows two folders in the OS File Browser Folder H and Folder D. Folder H is stored in the local storage system of client device with a backup in the cloud storage system . Folder D is pushed from the cloud storage system as the common data available to all users. Thus client device pushes data for Folder H to the cloud storage system and pulls data for Folder D from the cloud. The local drive is capable of storing an amount SIZE Z1 of data.

The local drive of client device is capable of storing an amount specified data SIZE X1 SIZE X2 SIZE Y1 and SIZE Z1 of data. Since only a portion of data is needed at any given time from Folder D Folder C and Folder B the client devices need not be capable of storing all of the data comprised within the cloud storage system. As such SIZE D can be larger that SIZE X1 even though the user X can access all the data in Folder D without manually removing files to make room for additional data. In fact SIZE D can be 100 hundred times larger than SIZE X1 1000 time larger than SIZE X1 or even 1 000 000 times larger than SIZE X1. SIZE D can be greater than what the operating system on client device supports.

File A s set of encrypted file chunks A N is illustrated in a condensed form showing chunks A G and N however chunks D and F are shaded to indicate those chunks are not present in the local cache of the cloud storage system. File B s set of encrypted file chunks A F are each illustrated as shaded block to indicate all of those chunks are not present in the local cache of the cloud storage system. The cloud storage system is illustrated as comprising File A and File B s set of encrypted file chunks A N and A F.

Point 2 is illustrated on File Access A A as a prediction that access of chunks E G will occur at some time in the future and as such the CFS client module determines to cache those encrypted chunks. Since encrypted chunks E and G are already in the local cache of the cloud storage system the CFS client module need only place a retrieval for encrypted file chunk F in the encrypted file chunk retrieval queue . The priority level of chunk F is based on its A of two away from the chunk being accessed D.

Point 3 is illustrated on File Access B B as an access of encrypted chunk A. Because the local cache of the cloud storage system does not contain encrypted chunk A a CFS client module executing on the client device will queue retrieval of encrypted chunk A in the encrypted file chunk retrieval queue . The retrieval of encrypted chunk A is given a higher priority level than the priority level of chunk F since the A of A is zero while the A of F is two.

Point 4 is illustrated on File Access B B as a prediction that access of chunks B E will occur at some time in the future and as such the CFS client module determines to cache those encrypted chunks. Since none of the encrypted file chunks B E are in the local cache of the cloud storage system the CFS client module places a retrieval of each encrypted chunk B E in the encrypted file chunk retrieval queue according to those chunks priority levels in comparison to the rest of the chunks priority levels. Thus the encrypted file chunk retrieval queue has the following chunks listed in order of retrieval priority D 0 A 0 B 1 F 2 C 2 D 3 and E 4 .

Prioritizing the retrieval of encrypted file chunks while at the same time as predictively retrieving encrypted file chunks has the advantage of allowing the CFS client module to get data that is likely to be accessed soon while at the same time ensuring that data that is needed sooner will be available prior to data needed later. As described above with reference to other priority systems may be implemented such as basing priority on a tracking of next file chunk access based on prior file chunk access.

In client device A is accessing a set of encrypted file chunks corresponding to a File A. File A is comprised of three file chunks listed in a File A manifest FM A . FM A maintain a listing of chunk identifiers CHUNK ID column chunk encryption keys CHUNK ENC KEY column and originating region ORI REGION for each encrypted file chunk that is part of File A. The CHUNK ID and CHUNK ENC KEY fields maintain data as described in previous figures. The ORI REGION field maintain an identifier of the region in which the corresponding file chunk was stored in the cloud storage system thus as client device A adds data to the cloud storage system that does not already exists in the cloud storage system the ORI REGION for that data will be region A while data from another client device located in region B will be marked with an ORI REGION of region B.

In this case client device A is retrieving chunks ID 1 through ID 3 at step . This is essential a request from cloud storage gateway to return those chunks ID 1 through ID 3 this request includes the ORI REGION of each chunk. Cloud storage gateway has a listing of chunk in the region A cloud storage pool . Thus the cloud storage gateway can determine that chunks ID 1 and ID 2 are in the region A cloud storage pool A while chunk ID 3 is not. The cloud storage gateway can then retrieve chunks ID 1 and ID2 from region A cloud storage pool A in step . Using the ORI REGION included in the request for chunk ID 3 the cloud storage gateway can then retrieve chunk ID 3 from region B cloud storage pool B in step . Chunk ID 3 can then be stored in region A cloud storage pool A in step . Chunks ID 1 through ID 3 can be returned to the client device A although not all chunks were original present in the regional cloud storage pool for that client device. This presents the advantage of storing data for client devices in different regions in separate storage pools so that data that is likely to be accessed data added by a client device in that region is located near to the cloud storage gateway for a region. At the same time a cloud storage gateway is enabled to retrieve chunks from other regions should those chunks be requested by a client device in that cloud storage gateways regions. As such the cloud storage pools for various regions need not constantly synchronize the data between one another.

The top section shows a local storage system that includes a root file system A that comprises a file system hierarchy for accessing files and folders on a client device. The file system hierarchy is comprised in a set of file system entries describing paths to various file and folders including entries for Folder X File A and File B. Furthermore the root file system A comprises the data for File A and File B.

As with the top section the middle section shows a local storage system that includes a root file system A that comprises a file system hierarchy for accessing files and folders on a client device. Amongst the file system entries is an entry indicating that Folder X is a mounted network file system. In order to access Folder X a NFS module communicates network attached storage that includes file system entries indicating the contents of the NFS including File A and File. The NFS module is shown as coupled with the FS entries to indicate when Folder X is accessed the NFS module handles that access. Thus as the client device browses Folder X the NFS module communicates with NAS to determine the contents of Folder X. Further NAS contains the data that comprises File A and File thus as a user access File A or File B in the middle section the NFS client module retrieves the appropriate data from NAS .

As with the top section the bottom section shows a local storage system that includes a root file system A that comprises a file system hierarchy for accessing files and folders on a client device. Amongst the file system entries is an entry indicating that Folder X is a mounted cloud file system. In order to access Folder X a CFS client module accesses data located in a portion of the local storage system for local cache of a cloud storage system and communicates with the cloud storage system to access needed data that is not in the local cache of the cloud storage system . In the local cache of the cloud storage system comprises a file system manifest containing entries corresponding with Folder X. The CFS client module is shown as coupled with the FSM as the CFS client module is responsible to providing access to Folder X by reading information from the FSM when a user browses Folder X. The information in FSM identifies files and folders in Folder X along with information used to access those files such a file manifest corresponding with each file.

Further the local cache of the cloud storage system comprises a plurality of cached encrypted file chunks D A and N. For example assuming that File A comprises a set of encrypted file chunks A F and File B comprises a set of encrypted file chunks A N then the local cache of the cloud storage system comprises portions of both File A and File B. The cloud storage system is shown as comprising all of File A s encrypted chunks and all of File B s encrypted chunks. Thus the CFS client module can utilize the local cache of the cloud storage system to access portions of File A and File B if the CFS client module needs to access portions of data not located the local cache of the cloud storage system the CFS client module can retrieve that information from the cloud storage system . Thus the CFS client module has allocated space in the local storage system for storing data from the cloud file system.

Furthermore the CFS client module can receive a designation to convert a folder analogous to Folder X in the top section that is stored in the local storage system to storage in the cloud storage system. This can be accomplished using the client devices existing file browser and a corresponding context menu or with a second user interface provided to the user. The CFS client module can receive a designation of a folder such as a path of a folder stored in the local storage system and cloudify that folder as described above including transmitting to the cloud storage system those encrypted files chunks that are not already present in the cloud storage system . The CFS client module is able to maintain a representation of the converted folder to the user at the same logical path same location as the folder that was cloudified such that the user s data is located at the same logical place as far as the operating system of the client device is concerned. The CFS client module is then responsible for providing access to the data in the cloudified folder whenever the operating system requests data from a file or folder.

Furthermore optimizations at the CFS client module and in the cloud storage system allow the CFS client module to reduce latency associated with accessing files in a cloud file system. For example caching encrypted file chunks in the local cache of the cloud storage system means that on subsequent accesses of those file chunks the CFS client module need not communicate with the cloud storage system . These gains are furthered by enabling the CFS client module to predictively retrieve encrypted file chunks from the cloud storage system as described above. The cloud storage system can be further optimized to respond to prefetch commands to ensure that specified encrypted file chunks are available for subsequent retrieval.

As described herein instructions may refer to specific configurations of hardware such as application specific integrated circuits ASICs configured to perform certain operations or having a predetermined functionality or software instructions stored in memory embodied in a non transitory computer readable medium. Thus the techniques shown in the figures can be implemented using code and data stored and executed on one or more electronic devices e.g. an end station a network element . Such electronic devices store and communicate internally and or with other electronic devices over a network code and data using computer readable media such as non transitory computer readable storage media e.g. magnetic disks optical disks random access memory read only memory flash memory devices phase change memory and transitory computer readable communication media e.g. electrical optical acoustical or other form of propagated signals such as carrier waves infrared signals digital signals . In addition such electronic devices typically include a set of one or more processors coupled to one or more other components such as one or more storage devices non transitory computer readable storage media user input output devices e.g. a keyboard a touchscreen and or a display and network connections. The coupling of the set of processors and other components is typically through one or more busses and bridges also termed as bus controllers . Thus the storage device of a given electronic device typically stores code and or data for execution on the set of one or more processors of that electronic device. Of course one or more parts of an embodiment of the invention may be implemented using different combinations of software firmware and or hardware.

While the flow diagrams in the figures show a particular order of operations performed by certain embodiments of the invention it should be understood that such order is exemplary e.g. alternative embodiments may perform the operations in a different order combine certain operations overlap certain operations etc. .

While the invention has been described in terms of several embodiments those skilled in the art will recognize that the invention is not limited to the embodiments described can be practiced with modification and alteration within the spirit and scope of the appended claims. The description is thus to be regarded as illustrative instead of limiting.

