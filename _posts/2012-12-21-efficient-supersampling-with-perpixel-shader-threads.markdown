---

title: Efficient super-sampling with per-pixel shader threads
abstract: Techniques for dispatching pixel information in a graphics processing pipeline. A fragment processing unit generates a pixel that includes multiple samples based on a first portion of a graphics primitive received by a first thread. The fragment processing unit calculates a first value for the first pixel, where the first value is calculated only once for the pixel. The fragment processing unit calculates a first set of values for the samples, where each value in the first set of values corresponds to a different sample and is calculated only once for the corresponding sample. The fragment processing unit combines the first value with each value in the first set of values to create a second set of values. The fragment processing unit creates one or more dispatch messages to store the second set of values in a set of output registers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09495721&OS=09495721&RS=09495721
owner: NVIDIA Corporation
number: 09495721
owner_city: Santa Clara
owner_country: US
publication_date: 20121221
---
The present invention generally relates to three dimensional 3D graphics processing and more particularly to efficient super sampling with per pixel shader threads.

Computer generated images that include 3D graphics objects are typically rendered using a graphics processing unit GPU with one or more multistage graphics processing pipelines. Such graphics pipelines include various programmable and fixed function stages. Programmable stages include various processing units that execute shader programs to render graphics objects and to generate various visual effects associated with graphics objects. One example of a programmable stage is a fragment processing unit that includes a pixel shader program. Pixel shader programs receive the geometry fragments such as line segments and triangles and compute color information depth information and other attributes of each individual pixel. The resulting pixel information is stored in output registers. The output registers are subsequently read by a fixed function stage known as the raster operations unit or ROP. The ROP receives pixel color depth and other information from the pixel shader program blends this pixel information with corresponding pixel information stored in one or more render targets and stores the blended pixel information back into the one or more render targets. Typically the blending operations in the ROP are limited to a set of fixed function operations.

Certain blending effects are not achievable within the ROP due to the fixed function nature of the ROP. To create such blending effects the pixel shader program may include one or more programmable blending features where the pixel shader program reads pixel information directly from the render targets destination pixel information blends the pixel information with the pixel information calculated by the pixel shader program source pixel information and stores the blended pixel information into the output registers. The pixel shader program flexibly performs a programmable blend on the pixel information. Accordingly blending is not restricted to the fixed function blending operations included in the ROP. One drawback with this approach is that processing order of pixel shaders is generally not guaranteed in a GPU with multiple instances of pixel shader programs running at the same time or with graphics processing pipelines. Certain sequential sets of blending operations perform properly if graphics objects are blended in a specific order. In one example two graphics objects could intersect with a given pixel. The first graphics object could be blended into a render target by a first graphics processing pipeline. The second graphics object could be blended into a render target by a second graphics processing pipeline. However the result of the blending operation could be different depending on whether the first graphics object is blended into the render target before the second graphics object or after the second graphics object. As a result the GPU would not consistently blend graphics objects correctly.

In some applications image quality is improved by rendering multiple samples for each pixel where each sample can represent a subset of the area covered by a corresponding pixel. Such a mode is called super sampling mode. In a render target configured for super sampling each pixel is stored as multiple samples where each sample can include color information depth information and other attributes. With super sampling a single instance of the pixel shader program calculates and stores the color depth and related information for only one sample. Once rendering completes the samples for a given pixel are combined resulting in the final pixel color for display on the display device. One drawback with this approach is that each instance of the pixel shader program consumes a separate processing element in the GPU. For pixels that include four samples super sampling consumes four times the pixel shader resources as compared to consuming only one pixel shader per pixel.

As the foregoing illustrates what is needed in the art is an improved technique for performing pixel shading operations in a graphics processing pipeline.

One embodiment of the present invention sets forth a method for dispatching pixel information in a graphics processing pipeline. The method includes generating a pixel that includes a plurality of samples based on a first portion of a graphics primitive received by a first thread. The method further includes calculating a first value for the first pixel where the first value is calculated only once for the pixel. The method further includes calculating a first set of values for the samples in the plurality of samples where each value in the first set of values corresponds to a different sample in the plurality of samples and is calculated only once for the corresponding sample. The method further includes combining the first value with each value in the first set of values to create a second set of values. The method further includes creating one or more dispatch messages to store the second set of values in a set of output registers.

Other embodiments include without limitation a computer readable medium that includes instructions that enable a processing unit to implement one or more aspects of the disclosed methods. Other embodiments include without limitation a subsystem that includes a processing unit configured to implement one or more aspects of the disclosed methods as well as a system configured to implement one or more aspects of the disclosed methods.

One advantage of the disclosed techniques is that pixel shader programs perform per sample operations with increased efficiency. In typical scenarios the pixel shader program achieves the higher image quality of per sample pixel shading with performance approaching that of per pixel shading.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including universal serial bus USB or other port connections compact disc CD drives digital versatile disc DVD drives film recording devices and the like may also be connected to I O bridge . The various communication paths shown in including the specifically named communication paths and may be implemented using any suitable protocols such as PCI Express AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements in a single subsystem such as joining the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip instead of existing as one or more discrete devices. Large embodiments may include two or more CPUs and two or more parallel processing subsystems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to as well as in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various operations related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and the second communication path interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have a dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs in parallel processing subsystem may output data to display device or each PPU in parallel processing subsystem may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a data structure not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . A pointer to each data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from one or more pushbuffers and then executes commands asynchronously relative to the operation of CPU . Execution priorities may be specified for each pushbuffer by an application program via the device driver to control scheduling of the different pushbuffers.

Referring back now to as well as each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI Express link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the command stream stored in the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed from a work distribution unit within a task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in the command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices of data to be processed as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule execution of the processing task. Processing tasks can also be received from the processing cluster array . Optionally the TMD can include a parameter that controls whether the TMD is added to the head or the tail for a list of processing tasks or list of pointers to the processing tasks thereby providing another level of control over priority.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of dynamic random access memory DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons of ordinary skill in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI Express connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

In graphics applications ROP is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. In some embodiments of the present invention ROP is included within each GPC instead of partition unit and pixel read and write requests are transmitted over crossbar unit instead of pixel fragment data.

The processed graphics data may be displayed on display device or routed for further processing by CPU or by one of the processing entities within parallel processing subsystem . Each partition unit includes a ROP in order to distribute processing of the raster operations. In some embodiments ROP may be configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

Operation of GPC is advantageously controlled via a pipeline manager not shown that distributes processing tasks to one or more streaming multiprocessors SMs where each SM configured to process one or more thread groups. Each SM includes an instruction L1 cache that is configured to receive instructions and constants from memory via an L1.5 cache not shown within the GPC . A warp scheduler and instruction unit receives instructions and constants from the instruction L1 cache and controls local register file and SM functional units according to the instructions and constants. The SM functional units include N exec execution or processing units and P load store units LSU . The SM functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SM . A thread group may include fewer threads than the number of processing engines within the SM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SM in which case processing will take place over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that a system that in a GPC that includes streaming multiprocessors up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SM and m is the number of thread groups simultaneously active within the SM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during the thread s execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each thread s position. In one embodiment special registers include one register per thread or per exec unit within SM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all threads that execute the same processing task represented by task metadata TMD not shown or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs or queue position if the TMD encodes a queue task instead of a grid task and an identifier of the TMD to which the CTA is assigned.

If the TMD is a grid TMD execution of the TMD causes a fixed number of CTAs to be launched and executed to process the fixed amount of data stored in the queue . The number of CTAs is specified as the product of the grid width height and depth. The fixed amount of data may be stored in the TMD or the TMD may store a pointer to the data that will be processed by the CTAs. The TMD also stores a starting address of the program that is executed by the CTAs.

If the TMD is a queue TMD then a queue feature of the TMD is used meaning that the amount of data to be processed is not necessarily fixed. Queue entries store data for processing by the CTAs assigned to the TMD. The queue entries may also represent a child task that is generated by another TMD during execution of a thread thereby providing nested parallelism. Typically execution of the thread or CTA that includes the thread is suspended until execution of the child task completes. The queue may be stored in the TMD or separately from the TMD in which case the TMD stores a queue pointer to the queue. Advantageously data generated by the child task may be written to the queue while the TMD representing the child task is executing. The queue may be implemented as a circular queue so that the total amount of data is not limited to the size of the queue.

CTAs that belong to a grid have implicit grid width height and depth parameters indicating the position of the respective CTA within the grid. Special registers are written during initialization in response to commands received via front end from device driver and do not change during execution of a processing task. The front end schedules each processing task for execution. Each CTA is associated with a specific TMD for concurrent execution of one or more tasks. Additionally a single GPC may execute multiple tasks concurrently.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any thread within the same CTA or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SM to begin execution of a task that uses these parameters. Any thread within any CTA or any exec unit within SM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache . As shown GPC includes a memory management unit MMU which couples crossbar unit to one or more other units within SM .

Local register file is used by each thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the thread to which the register is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers. Additionally a uniform L1 cache stores uniform or constant values for each lane of the N exec units and P load store units LSU .

Shared memory is accessible to threads within a single CTA in other words any location in shared memory is accessible to any thread within the same CTA or to any processing engine within SM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and task ID as well as CTA and grid dimensions or queue position implementing portions of the special registers. Each LSU in SM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 cache in each SM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to the shared memory and the L1 cache via a memory and cache interconnect .

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SMs may be included within a GPC . Further as shown in a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches to execute tasks for one or more application programs.

Persons of ordinary skill in the art will understand that the architecture described in in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

Data assembler processing unit collects vertex data for high order surfaces primitives and the like and outputs the vertex data including the vertex attributes to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in L1 cache parallel processing memory or system memory by data assembler for use in processing the vertex data.

Primitive assembler receives vertex attributes from vertex processing unit reading stored vertex attributes as needed and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles line segments points and the like. Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

In some embodiments geometry processing unit may also add or delete elements in the geometry stream. Geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit . Geometry processing unit may read data that is stored in parallel processing memory or system memory for use in processing the geometry data. Viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a rasterizer .

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally rasterizer may be configured to perform z culling and other z based optimizations.

The interlock detects when the fragment processing unit is writing to the same location in the render target as a fragment processing unit in another graphics processing pipeline . In some embodiments two fragment processing units may be configured to write to the same x y location in the render target where x y represents the screen coordinates of a pixel. In such a case a fragment shader program executing on a fragment processing unit may not be launched at the same x y location as a fragment shader program on a different fragment processing unit that has not yet completed. The interlock stalls the later fragment shader program and prevents the later shader program from launching until the first fragment shader program completes the read modify write operation to the given x y location. This approach ensures that the later fragment shader program receives the final value from the prior fragment shader program directed to the same x y location. Once the prior fragment shader program completes the write to the x y location the interlock releases the later fragment shader program for execution.

Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read data that is stored in parallel processing memory or system memory for use in processing the fragment data. Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

Raster operations unit is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory e.g. parallel processing memory and or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments of the present invention raster operations unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory. In various embodiments the ROP may be located in the memory interface in the GPCs in the processing cluster array outside of the GPCs or in a separate unit not shown within the PPUs .

As described above in conjunction with the fragment processing unit is configured to execute fragment shader programs at pixel sample or other granularity depending on the programmed sampling rate. For example the fragment processing unit could execute a pixel shader program to shade pixels or a sample shader program to separately shade each sample of a given pixel. The fragment processing unit could achieve higher image quality by shading at sample granularity at reduced performance as compared with pixel granularity. As further described below in conjunction with the fragment processing unit could be configured to perform calculations once per pixel where possible. In such cases the fragment processing unit would detect when the pixel shader program is likely to produce the same result for multiple samples and in such a case perform per pixel calculations once for the multiple samples.

The input registers compose a set of registers that are local to the fragment processing unit . The input registers store fragments and coverage data received from the rasterizer . Fragments represent a portion of a graphics primitive that has been rasterized and is ready for fragment or pixel shading. A fragment is associated with various data parameters which might be interpolated including but not limited to the position of the fragment in screen space the depth value of the fragment values such as color or texture elements or surface normals a stencil mask associated with the fragment and a transparency value for the fragment. Coverage data includes the set of pixels or pixel samples in screen space that intersect with the fragment. The fragments and coverage data are then read by the pixel shader program for further processing.

The pixel shader program is a series of instructions executed on a processor not shown in the fragment processing unit . The pixel shader program is one form of a fragment shader program as described in conjunction with . As further described below the pixel shader program processes fragments and coverage data stored in the input registers and transmits the processed data to the output registers and output masks . Depending on the instructions in the pixel shader program the transmitted data may be in the form of pixel information or in the form of fragments and coverage data as described above. Pixel information includes without limitation color information typically expressed as red green and blue components and depth information. The coverage data is transmitted via the output masks which indicate the samples covered by the data in the output registers .

In one example the pixel shader program includes instructions to perform programmable blending. Blending operations include any pixel operations where pixel information is read from a render target the pixel information is modified according to a given function and the modified pixel information is written back to the render target. Typically such blending operations are performed in an atomic manner e.g. with a read operation and its paired write operation completed from to the render target without any intervening read or write operations. With programmable blending the pixel shader program could perform the blending operation according to programmed instructions. As such blending operations would not be limited to the fixed function blending operations in the ROP . The pixel information calculated by the pixel shader program could be different for each sample in a given pixel because even though the source value can be the same for all samples the destination values can be different for each sample. Alternatively the pixel information calculated by the pixel shader program could be the same for two or more samples in a given pixel. The pixel shader program could read data from the render target and perform a blending operation according to the blending function defined within the pixel shader program . The pixel shader program would then transmit the resulting pixel information to the render target via the output registers and select the affected samples via the output masks . The pixel shader program could transmit the pixel information via multiple dispatches where each dispatch would have a different output mask thereby selecting different samples. Generally there is a one to one correspondence between the total samples in a pixel and the bits in the output masks .

If the pixel information is different for each sample then the pixel shader program would transmit one dispatch for each sample. A corresponding output mask would enable only the correct sample for writing. If the pixel information is the same for two or more samples then the pixel shader program would transmit one dispatch for the set of samples that have the same pixel information. A corresponding output mask would enable only the correct multiple samples for writing. The pixel shader program could detect a condition where all samples for a pixel are identical as stored in the render target and the pixel information calculated by the pixel shader program is the same for all samples. In such a case the pixel shader program performs the per sample programmable blending operating only once and transmits the resulting pixel information once through a single dispatch. A corresponding output mask would enable all samples for the pixel for writing.

At the application programming interface API level such a programmable blending function could be exposed as a pixel shader program that includes a per pixel pass and a program selectable number of sample based passes where each sample based pass could affect multiple samples. Each sample based pass would perform at most one dispatch. The pixel shader program could combine multiple sample based passes into a single dispatch where the pixel information is identical for the corresponding samples. As such the pixel shader program would efficiently execute in a single thread first executing per pixel calculations and then executing per sample calculations. Exposing this feature at the API level as multiple dispatches advantageously provides flexibility to the pixel shader program which could combine multiple dispatches into a single dispatch at render time.

In another example the pixel shader program includes instructions to perform forward rendering in a hybrid mode where one portion of the pixel shader program would execute once per pixel and a second portion of the pixel shader program would execute once per sample. Typically a graphics processing pipeline operates in one of two modes multi sampled mode or super sampled mode. In multi sampled mode the graphics processing pipeline processes one set of pixel information for each pixel location wherein the pixel information represents the color and depth values typically at the center of each pixel. Multiple samples are generated at the final output of the graphics processing pipeline for example as a blending operation in the ROP . In super sampled mode the graphics processing pipeline processes one set of pixel information for each sample location wherein the pixel information represents the color and depth values for each sample within a pixel. Multiple samples per pixel are processed from the rasterizer through the rest of the graphics processing pipeline . Super sampled mode achieves higher image quality at the penalty of reduced performance. For example where each pixel includes four samples super sampled mode would execute at approximately one fourth the performance of multi sampled mode. That is super sampled mode would execute at a speed four times slower than multi sampled mode. Alternatively super sampled mode would consume four times the resources of the fragment processing unit within the graphics processing pipeline as multi sampled mode.

With forward rendering in a hybrid mode the image quality of super sampled mode would be achieved with performance approaching that of multi sampled mode. The stages in the graphics processing pipeline that are upstream of the fragment processing unit operate in multi sampled mode. The stages in the graphics processing pipeline that are downstream of the fragment processing unit operate in super sampled mode. The pixel shader program executing in the fragment processing unit operates in a hybrid mode performing some operations once per pixel and other operations once per sample as described below in conjunction with .

In yet another example the pixel shader program includes instructions to perform deferred rendering. With deferred rendering the input registers would be written with fragment data corresponding to high frequency attributes for each sample in a pixel where the attributes are stored in a geometry buffer G buffer not shown . The pixel shader program could pass fragment and coverage data from the input registers directly to the output registers . The pixel shader program could process the fragment or pass the fragment to the output registers without processing. One fragment would be stored in one sample location in the render target. As such when the pixel shader program dispatches a fragment a corresponding output mask enables the dispatch to be written in a single sample location. At a later time when multiple fragments have been stored in the render target the pixel shader program retrieves the fragments from the render targets. The pixel shader program would process the fragments and calculate pixel information for one or more sample locations associated with a given pixel. The pixel shader program could transmit the samples via one or more dispatches to the output registers . The output registers would then transfer the pixel information to the render targets via the memory interface or would transmit the pixel information to the ROP for ROP blending.

In some embodiments an interlock mechanism may detect when multiple pixel shader programs are performing operations for the same x y location in the render target. The interlock mechanism may prevent a pixel shader program from accessing a particular x y location in the render target when another pixel shader program is performing a blend operation such as a read modify write to the same x y location. If the pixel shader programs are performing ordered blending operations then graphics objects are blended into the render target in a particular order. An interlock mechanism such as the interlock described in conjunction with may stall a later pixel shader program until a prior pixel shader program completes a blending operation to the x y location. This technique allows later pixel shader programs to reliably use results from prior pixel shader programs that run for the same x y location.

Alternatively the pixel shader programs may be performing non ordered blending operations. In such a case the interlock mechanism does not need to ensure a particular blending order. Rather the interlock mechanism may allow the pixel shader programs to access locations in the render target in any order. In such a case the interlock mechanism may employ a software lock to ensure that blending operations are performed atomically. The pixel shader program may request a lock for a given x y location before performing a blend operation to that x y location. If the lock for the given x y location is available then the pixel shader program may acquire the lock and may complete the read modify write to the x y location. The pixel shader program may then release the lock. If the lock for the given x y location is not available then another pixel shader program may be performing a blend operation to the same x y location. The pixel shader program may wait until the lock becomes available. When the lock becomes available the pixel shader program may acquire the lock and may complete the read modify write to the x y location. The pixel shader program may then release the lock.

The output masks are a series of bits that enable or disable data received from the pixel shader program . The output masks determine which samples the are written with the data from the output registers . If the specific bit is set to one then the corresponding sample storage location would be written with the data calculated by the pixel shader program and written to the output registers . If the specific bit is set to zero then the corresponding sample storage location would not be written with the data. In another example a four bit field in the output masks could correspond to a specific set of four sample storage locations in the render targets where the four samples compose a particular pixel. If the four bit field is set to 1111 then all four corresponding sample storage locations would be written with the data calculated by the pixel shader program . If the four bit field is set to 0000 then none of the four corresponding sample storage location would be written with the data. If the four bit field is set to 0100 then only the second corresponding sample storage location would be written with the data. As a further example with multiple dispatches a first dispatch with 1000 would write the first sample with a first set of output register values a second dispatch with 0100 would write the second sample with a second set of output register values etc. Each dispatch can write to multiple render targets by having multiple subsets of the output register values each written to a corresponding render target.

The output registers include a set of registers that are local to the fragment processing unit . The output registers store data from the pixel shader program . As described above such data may be in the form of pixel information including color information depth information and other attributes of the pixels. Alternatively the data may be in the form of fragments and coverage data such as in the case of deferred rendering. Depending on the specific instructions in the pixel shader program and the state of the graphics processing pipeline the data in the output registers may be transmitted to the ROP or written directly to the render target by transmitting the data to the memory interface via the crossbar unit .

In some embodiments the output registers may not directly support multiple dispatches from the pixel shader program . In such a case the pixel shader output registers may be standard single dispatch shader registers. In such architectures when the pixel shader program terminates a separate process not shown reads the output registers and send the corresponding values downstream to the render targets or to the ROP . For output registers that do support multiple dispatch pixel shaders transfers to the render targets may be accomplished via any technically feasible approach including without limitation i stalling the pixel shader program after each dispatch until the output registers have been read and then issuing the next dispatch ii storing data in output registers that are dedicated to a particular dispatch iii storing data in a double buffered set of registers where the two buffers are swapped between dispatches and iv storing dedicated data in a single buffered register set and per sample output data in a double buffered register set.

The shadow mapping stage creates shadows that result when a graphics object blocks the path of a light source. The shadow mapping stage creates a shadow when a visible pixel is determined to be closer to a light source than another pixel in the same path of light. The shadow mapping stage transmits results of the shadow mapping operation to the ambient occlusion stage .

The ambient occlusion stage approximates the radiance of a light source where the illumination at each pixel in the image is based on other graphics object in the scene. The ambient occlusion stage transmits results of the ambient occlusion operation to the subsurface scattering stage .

The subsurface scattering stage approximates the effect where light partially penetrates the surface of a translucent graphics object at a specific point is scattered internally by the translucent object and then exits the translucent object at a different point. The subsurface scattering stage transmits results of the subsurface scattering operation to the diffuse lighting stage .

The diffuse lighting stage approximates the effect where light strikes a graphics object and is reflected in many directions by the surface. Diffuse lighting is characterized by objects that have an irregular or matted surface and is contrasted with specular lighting described below. The diffuse lighting stage transmits results of the diffuse lighting operation to the alpha testing stages .

Typically the calculations performed by the shadow mapping stage ambient occlusion stage subsurface scattering stage and diffuse lighting stage exhibit low spatial frequency. That is the resulting pixel information from these stages may not appreciably change between adjacent pixels. As such these stages may execute once per pixel without noticeable loss in image quality. After completion of these stages a single set of pixel information is transmitted to the alpha testing stages where each alpha testing stage executes once per sample.

The alpha testing stages test pixels calculated by the pixel shader program against pixels previously stored in the render target. If the calculated pixels have a depth value that is less than the depth value in the render target then the calculated pixel is stored in the render target otherwise the calculated pixel is discarded. In some embodiments the calculated pixel is blended with the stored pixel based on the respective depth values and other parameters. Typically the calculations performed by the alpha testing stages exhibit high spatial frequency. That is the resulting pixel information from the alpha testing stages may appreciably change between adjacent pixels. As such performing alpha testing once per pixel may result in noticeable loss in image quality. Accordingly alpha testing is performed once per sample. Alpha testing stages performs alpha testing for a first sample alpha testing stages performs alpha testing for a second sample and so on. Each alpha testing stage transmits results of the alpha testing operation to a corresponding specular lighting stage .

The specular lighting stages approximate the effect of light striking the surface of a graphics object and being reflected in a single direction by the surface. Specular lighting is characterized by objects that have a smooth highly reflective surface and is contrasted with diffuse lighting described above. Typically the calculations performed by the specular lighting stages exhibit high spatial frequency. That is the resulting pixel information from the specular lighting stages may change appreciably between adjacent samples. As such performing specular lighting once per pixel may result in noticeable loss in image quality. Accordingly specular lighting is performed once per sample as described above. The specular lighting stages transmit results of the specular lighting operation to the output registers as the per sample outputs of the pixel shader program by using different values of sample masks .

The MRT buffers are register banks within the portion of the output registers . Each MRT buffer includes a set of locations that corresponds to a different render target. MRT buffer corresponds to render target MRT buffer corresponds to render target and so on. Each MRT buffer includes a number of sample locations that store pixel information corresponding to a particular sample. Threads are instances of the pixel shader program and the eight threads store sample information for the first sample of eight corresponding pixels in the MRT buffer at sample locations . Likewise threads store sample information for the second sample in the MRT buffer at sample locations for the third sample in the MRT buffer at sample locations and for the fourth sample in the MRT buffer at sample locations . In this arrangement the MRT buffers for a particular thread store data for multiple samples within a pixel for a particular render target rather than for single pixels across multiple render targets as in the prior art.

The threads represent separate instances of the pixel shader program where each instance calculates pixel information for a quantity of samples in a given pixel. Typically the pixel shader program writes only one sample location in a given MRT buffer but for a given thread all the samples within a particular pixel in a render target are covered by the part of the MRT buffer corresponding to that thread. As such the instance of pixel shader program at thread writes sample to MRT buffer directed to the first render target the instance of pixel shader program at thread writes sample to MRT buffer directed to the second render target and so on. As a result thread calculates pixel information for a first group of four samples and stores the pixel information in samples and . These four samples correspond to MRT buffers respectively. Likewise thread calculates pixel information for a second group of four samples and stores the pixel information at sample locations and and so on. Once all threads populate the sample locations the MRT buffers may be transferred to the corresponding pixels in the multiple render tickets. In some embodiments the output masks may be different for each thread . For example the output mask for thread could enable only samples and for writing in a given dispatch thread could enable only samples for writing and thread could enable four samples for writing and all in the same dispatch.

As shown each of the threads calculates pixel information for a corresponding pixel in the render targets. Thread calculates pixel information for the four samples of pixel and stores the pixel information at sample locations and . Likewise thread calculates pixel information for the four samples of pixel and stores the pixel information at sample locations and and so on. Although threads populate a vertical strip of sample locations spanning the MRT buffers the sample locations may be efficiently transferred to the multiple render targets one MRT buffer at a time as further described below.

As shown MRT buffer includes sample locations corresponding to first samples for a group of four pixels as calculated by threads . A single transfer from the portion of output registers may transfer values in the sample locations to a data collector not shown associated with the multiple render targets. MRT buffer includes sample locations corresponding to second samples for the group of four pixels . A single transfer from the portion of output registers may transfer values in the sample locations to the data collector associated with the multiple render targets. Similar transfers may transfer values for the third and fourth samples from the portion of output registers to the data collector. Once the data collector includes all sample values for the four pixels the data collector rearranges the data for storage in the proper render target memory locations for the four pixels . Additional transfers may then transfer sample information calculated by threads for a second group of four pixels not shown . In some embodiments the MRT buffers are transferred from the output registers to the ROP along with corresponding output masks in one or more dispatches. In other embodiments the pixel shader program reads the MRT buffers in the output registers along with corresponding output masks and transfers the MRT buffers and output masks to the render targets in one or more dispatches.

It will be appreciated that the architecture described herein is illustrative only and that variations and modifications are possible. In one example the techniques are described herein in the context of eight threads each computing pixel information for pixels that include four samples each. However the described techniques could be employed to shade pixels that include any number of samples per pixel. In addition the described techniques could be employed across any number of threads where the direct pixel information to any number of render targets.

As shown a method begins at step where the fragment processing unit receives a fragment that includes at least one pixel where a fragment is a portion of a graphics primitive. At step the fragment processing unit generates a pixel that includes multiple samples based on the received fragment. At step the fragment processing unit calculates a set of source values where each source value corresponds to a different sample of the pixel. At step the fragment processing unit retrieves destination values from a render target where each destination value corresponds to a different source value. At step the fragment processing unit blends each source value with the corresponding destination value to create final values. At step creates one or more dispatch messages to store the final values in a set of output registers. The method then terminates.

As shown a method begins at step where the fragment processing unit receives a fragment that includes at least one pixel where a fragment is a portion of a graphics primitive. At step the fragment processing unit generates a pixel that includes multiple samples based on the received fragment. At step the fragment processing unit performs one or more calculations that are calculated once per pixel. At step the fragment processing unit performs one or more calculations that are calculated once for each sample of the pixel. At step the fragment processing unit combines the results of the per pixel calculations with the results of the per sample calculations to create final values for each sample of the pixel. At step the fragment processing unit creates one or more dispatch messages to store the final values in a set of output registers. The method then terminates.

In sum a fragment processing unit includes a pixel shader program configured to transmit multiple dispatches for each pixel to one or more render targets. The pixel shader program executes in a single thread by first performing per pixel calculations and then performing per sample calculations. Per pixel calculations are performed once for all samples in the pixel. If multiple samples for a given pixel have identical source and destination pixel information then the multiple samples are included in a sample set. The per sample calculations may be performed once for each sample set rather than once for each sample. The pixel shader program then dispatches resulting pixel information once for each sample set along with a corresponding output mask to store the blended samples back into the render targets. An interlock mechanism detects a condition where a new pixel shader program is launched for the same pixel location as a currently executing pixel shader program. In such a case the newly launched pixel shader program stalls until the currently executing pixel shader program completes.

One advantage of the disclosed techniques is that pixel shader programs perform per sample operations with increased efficiency. In typical scenarios the pixel shader program achieves the higher image quality of per sample pixel shading with performance approaching that of per pixel shading.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

