---

title: Managing code-tracing data
abstract: A method of managing code-tracing data is described. The method comprises the steps of: analyzing a log of code-tracing data to identify a module in which an error occurred; activating code-tracing at a high detail level in that module; identifying modules associated with that module; and activating code-tracing at a high detail level in those identified modules.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08874967&OS=08874967&RS=08874967
owner: NCR Corporation
number: 08874967
owner_city: Duluth
owner_country: US
publication_date: 20120330
---
To improve fault detection in software software engineers typically add instrumentation code to software components application software drivers and the like so that code tracing data is generated automatically by the instrumentation code as the software components execute. The instrumentation code typically generates code tracing data when certain functions are performed status changes occur and the like. A trace manager is used to store the code tracing data generated by the instrumentation code in a log file.

If a fault occurs then the log file can be analyzed to identify the cause of the fault. For example the code tracing data may indicate if any unexpected events occurred or if any expected events did not occur prior to the fault occurring.

Although generating and storing code tracing data has clear advantages there are also problems associated with managing code tracing data.

One problem is that instrumentation code can produce a large amount of code tracing data every second which consumes valuable storage space and may slow down the operation of the software as the log file is written to disk. Furthermore the large quantity of code tracing data produced makes it difficult to identify the code tracing data that is relevant to an error. Other errors may be detected that are irrelevant to and may obscure the error being targeted.

Another problem is that if the level of tracing is reduced then the information that may help identify the cause of an error may not be present in the code tracing data.

It would be a benefit to overcome or mitigate some of these disadvantages or other disadvantages associated with managing code tracing data.

Accordingly the invention generally provides methods systems apparatus and software for managing code tracing data.

In addition to the Summary of Invention provided above and the subject matter disclosed below in the Detailed Description the following paragraphs of this section are intended to provide further basis for alternative claim language for possible use during prosecution of this application if required. If this application is granted some aspects may relate to claims added during prosecution of this application other aspects may relate to claims deleted during prosecution other aspects may relate to subject matter never claimed. Furthermore the various aspects detailed hereinafter are independent of each other except where stated otherwise. Any claim corresponding to one aspect should not be construed as incorporating any element or feature of the other aspects unless explicitly stated in that claim.

According to a first aspect there is provided a method of managing code tracing data the method comprising the steps of 

The module in which the error occurred may comprise a service in a control application. The identified modules may comprise service providers and or drivers associated with the service.

The service providers may comprise CEN XFS modules. CEN is the European Committee for Standardization and XFS is the eXtensions for Financial Services standard. The current version of this CEN XFS standard is v.3.10.

The method may include the further step of creating a code tracing profile to include high detail level code tracing for the module in which the error occurred and associating a defect type with this profile. For example a cash in deposit module may have thrown an exception and the method may involve creating a code tracing profile associated with cash in failures. This profile may be used by default if a system is prone to cash in module failures.

The method may comprise the further steps of detecting a pattern of errors over a period of time for example exceptions thrown by a cash out module and applying a code tracing profile appropriate for the detected pattern for example a cash out module profile .

The method may comprise the further steps of detecting the absence of an error over a defined time period and reducing the code tracing detail level.

The code tracing detail may be reduced and the system may be rebooted so that the new code tracing detail is applied. Alternatively the new code tracing detail may be applied directly by updating registry settings for the modules in which the code tracing detail is to be changed.

As is known to those of skill in the art an exception is a special condition that changes the normal flow of the target program execution causing it to branch to a different routine. When an exception is thrown it will travel through the layers of code in the target program until it is dealt with. If the target program does not catch the exception for example because the programmer did not write a module to handle that particular exception then the exception makes its way to the top layer of the target program and the operating system recognizes it as an unhandled exception and shuts down the target program resulting in a fatal exception error.

According to a second aspect there is provided a system for managing code tracing data the system comprising 

a trace manager arranged to i analyze a log of code tracing data to identify a module in which an error occurred ii activate code tracing at a high detail level in that module iii identify modules associated with that module and iv activate code tracing at a high detail level in those identified modules.

The trace manager may be implemented by a CEN XFS compliant software component. Alternatively the trace manager may be implemented by a proprietary code tracing data storage component.

The trace manager may be further arranged to create a code tracing profile to include high detail level code tracing for the module in which the error occurred and associate a defect type with this profile.

The trace manager may be further arranged to detect a pattern of errors over a period of time for example exceptions thrown by a cash out module and apply a code tracing profile appropriate for the detected pattern for example a cash out module profile .

The trace manager may be further arranged to detect the absence of an error over a defined time period reboot a system executing the method and reduce the code tracing detail level.

According to a third aspect there is provided a computer program comprising program instructions for executing the steps of the first aspect.

The computer program may be stored on a computer readable medium such as a computer memory an input output data storage device such as a magnetic or optical disk or a Flash storage drive or the like.

According to a fourth aspect there is provided a computer data signal embodied on a carrier wave encoding instructions that when executed on a processor implement the method of the first aspect.

According to a fifth aspect there is provided a self service terminal comprising a plurality of modules for providing transaction related functions to a customer of the self service terminal and a controller coupled to the modules and executing a runtime platform including a trace manager the trace manager being arranged to i analyze a log of code tracing data to identify a module in which an error occurred ii activate code tracing at a high detail level in that module iii identify modules associated with that module and iv activate code tracing at a high detail level in those identified modules.

For clarity and simplicity of description not all combinations of elements provided in the aspects recited above have been set forth expressly. Notwithstanding this the skilled person will directly and unambiguously recognize that unless it is not technically possible or it is explicitly stated to the contrary the consistory clauses referring to one aspect are intended to apply mutatis mutandis as optional features of every other aspect to which those consistory clauses could possibly relate.

These and other aspects will be apparent from the following specific description given by way of example with reference to the accompanying drawings.

Reference will now be made to which is a simplified schematic diagram showing an SST memory executing software components. In this embodiment the SST is an ATM. The software components comprise a control application a runtime platform and a code tracing manager .

As is known in the art the control application presents a sequence of screens on an ATM display to a customer at the ATM collates information from the customer for example customer account information from a customer s ATM card transaction request and the like obtains authorization for a transaction request from a remote authorization host not shown and instructs modules within the ATM as needed to fulfill an authorized transaction.

As is also known in the art the control application also comprises a conventional CEN XFS interface for communicating with an XFS manager described as box below in the runtime platform . CEN is the European Committee for Standardization and XFS is the eXtensions for Financial Services standard. The current version of this CEN XFS standard is v.3.10.

The control application includes a layer logically above the CEN XFS interface called the ACTIVE XFS layer . The ACTIVE XFS layer provides an interface to support object oriented environments such as .NET COM component object model environments and the like . This is used because the standard CEN XFS interface supports primarily procedural language environments such as C .

The control application also includes many channel services layers not illustrated individually in . The channel services layers include a layer for each of the following a Cash Accept Service a Cash Dispense service a Receipt Print service a Journal Print service a Renderer display service and the like. These channel services layers are conventional on XFS compliant ATMs and suitable software components including these services are available from NCR Corporation 3097 Satellite Blvd. Duluth Ga. 30096 U.S.A.

The control application also includes business services only three of which are illustrated in labeled through although full embodiments may have more than three business services . These business services call the appropriate channel services to execute a desired transaction. The business services are components that provide a business function such as a transaction authorization a targeted advertisement a balance enquiry and such like . In this embodiment business service provides cash dispense and cash deposit transactions referred to as the cash business service in this embodiment .

The runtime platform comprises proprietary device drivers only three of which are illustrated an operating system an XFS manager and XFS service providers

In this embodiment the operating system is a Windows XP trade mark operating system available from Microsoft Corporation trade mark . The operating system includes a plurality of standard device drivers for interfacing with standard computing devices such as a magnetic disk drive a display USB ports serial ports a parallel port and such like. As is well known in the art the operating system is responsible for memory process task and disk management and includes routines for implementing these functions.

The proprietary device drivers are a set of APTRA trade mark XFS components available from NCR Corporation 3097 Satellite Blvd. Duluth Ga. 30096 U.S.A. The device drivers provide a range of programming facilities specific to self service terminal devices and services.

One function of the device drivers is to enhance the operating system so that the operating system and device drivers together provide high level access to all of the devices and modules including both standard home computing devices via the operating system and XFS computing devices via the run time components . Thus the combination of the device drivers and the operating system can be viewed as providing a complete ATM operating system.

The device drivers interface with self service specific devices and include support files not shown to allow each device or module to be operated tested maintained and configured. Although only a few device drivers are shown there are many device drivers one for each self service specific module such as a card reader not shown a receipt printer not shown an encrypting keypad not shown and FDKs not shown and a cash dispenser not shown . Furthermore there are many more devices and modules in an ATM than those described herein for example there are more standard computing devices such as USB ports and a parallel port there may also be more self service devices and modules such as a statement printer a cash accept module and the like. These devices and modules are not discussed herein because they are not essential to an understanding of the invention.

The XFS manager includes an XFS application programming interface API and a service provider interface SPI .

The service providers communicate with the XFS manager and also with the self service device drivers and the standard device drivers associated with the modules. Suitable service providers are available from NCR Corporation 3097 Satellite Blvd. Duluth Ga. 30096 U.S.A.

The service providers provide a high level of abstraction to allow the business services to issue standard XFS commands to request functions and services. The service providers translate these XFS commands for the particular device drivers used in the runtime platform . Each service provider is typically associated with one module such as a cash dispenser module .

The code tracing manager also executes in the memory and communicates with the control application . The code tracing manager can save data into a code trace log stored in the memory . Periodically the code trace log is stored as a trace file on a permanent I O storage within the ATM. In this embodiment the permanent I O storage is a disk drive.

The business services and the channel services layers within the control application all comprise instrumented code that is code that includes instrumentation . The instrumented code provides checkpoints trace lines and other diagnosis tools.

Whenever a specified event occurs in one of the modules for example the cash business service then the code tracing manager receives trace information from the instrumented code. Depending on the level of code tracing selected by the code tracing manager this trace information may be saved in the code trace log . The higher the level or detail of code tracing applied by the code tracing manager the more information that is stored in the code trace log .

In the case of a function call the instrumented code in the control application creates data to indicate i the client thread that called the function ii when the function was called iii the name of the function called and iv the names and values of the parameters input to the function and output from the function.

The instrumented code creates a code tracing object populated with i the created data ii the reference identifying the object for example the cash business service incorporating the trace line in the instrumented code that created the code tracing object and iii a category for the created data.

The reference is included so that the code tracing object identifies the function that caused the code tracing object to be created or more accurately the software containing the instrumentation code that created the code tracing object.

The category indicates what type of data is included in the code tracing object. For example the category may be one of the following entry point exit point general data information warning or error. The category is created automatically based on the type of instrumented code that created the data.

The category is a property of the code tracing object. The reference is also a property of the code tracing object.

The code tracing manager typically includes configuration information that stores the name and path of the trace file on the hard drive .

The operation of the code tracing manager will now be described with reference to which is a flowchart illustrating steps implemented by the code tracing manager when a serious error such as an unhandled exception occurs. The example of an unhandled exception will be used in the following description although another kind of serious error would be dealt with in a similar manner.

Initially the code tracing manager monitors the code trace log step to detect an unhandled exception step . Alternatively the code tracing manager may receive an event directly that indicates that an unhandled exception has occurred.

If an unhandled exception is detected then the code tracing manager accesses the trace file step . This may occur after the ATM has been rebooted if rebooting was necessitated by the unhandled exception .

The code tracing manager then analyses the data stored in the trace file to identify the function service or module that was executing when the unhandled exception occurred step . In other words the code tracing manager identifies the function that threw the exception. In this example the cash business service threw the exception.

The code tracing manager then ascertains if the function that threw the exception in this example the cash business service has the highest level of tracing enabled step .

If not then the code tracing manager assigns a higher level of tracing to the cash business service step . In this embodiment the code tracing may be set to one of three different levels low medium and high detail level. These three levels are referred to as three different tracing profiles.

The code tracing manager then ascertains if the function that threw the exception in this example the cash business service has called or accessed other functions step . In this example the cash business service has called a Cash Deposit Service in the channel services layers which called a Cash Depository Service Provider in the XFS service providers .

The code tracing manager then ascertains if each of these called modules services or functions has the highest level of tracing enabled step .

If not then the tracing level for that or those modules the Cash Deposit Service and the Cash Depository Service Provider is increased by the code tracing manager step and the flow returns to step where the code tracing manager monitors the code trace log for an unhandled exception.

If each of these called modules has the highest level of tracing enabled then the code tracing manager advances to step .

Returning to step if the function that threw the exception in this example the cash business service has the highest level of tracing enabled then the code tracing manager advances to step .

At step the code tracing manager ascertains if the unhandled exception occurred within a predefined time period since the last unhandled exception relating to that function the cash business service . This predefined time period can be set by the owner of the ATM but in this embodiment the predefined time period is twenty minutes.

If the unhandled exception occurred within this predefined time period then the code tracing manager escalates the unhandled exception as a serious incident and sends a message to a remote management centre not shown step so that a service engineer can be dispatched. In this embodiment the code tracing manager sends a trap across a network connection not shown to the remote management centre not shown .

If the unhandled exception did not occur within this predefined time period then the code tracing manager returns to step where the code tracing manager monitors the code trace log for an unhandled exception.

Returning to step if the code tracing manager does not detect an unhandled exception within a safety period also a predefined time period that can be set by the owner of the ATM step then the code tracing manager reduces the trace detail level on the modules that previously had their trace detail level increased step . This is to ensure that the software is not unduly slowed down by a high level of tracing detail if there are no exceptions occurring. In this embodiment the safety period is twelve hours.

The code tracing manager then returns to step where the code tracing manager monitors the code trace log for an unhandled exception.

It will now be appreciated that the above embodiment has the advantage that the trace manager intelligently changes the level of tracing applied based on previous unhandled exceptions and dynamically lowers the level of tracing applied if there are no unhandled exceptions for an extended period of time. Furthermore the trace file will contain the most relevant information because the most detailed tracing was directed towards the module that threw the exception and related modules. This provides a diagnostic engineer with much relevant and useful information. The levels of tracing to be applied are configurable. The modules that are selected for tracing are not hard coded but are selected based on proximity to the exception.

Various modifications may be made to the above described embodiment within the scope of the invention for example in other embodiments the SST may not implement the CEN XFS standard. In such embodiments a proprietary trace manager may be provided.

In other embodiments a different operating system may be used such as Windows 7 trade mark or Linux trade mark .

In other embodiments the self service terminal may be an information kiosk a financial services centre a bill payment kiosk a lottery kiosk a postal services machine a check in and or check out terminal such as those used in the retail hotel car rental gaming healthcare and airline industries or the like.

In other embodiments the code tracing may be selectable from more than three different detail levels or fewer than three different detail levels. The different detail levels may be referred to as profiles. Any desired number of profiles may be provided.

In the above embodiment the software components including instrumented code comprise a control application. In other embodiments the software components including instrumented code may comprise other applications executing in the environment of an operating system and or a runtime platform service providers drivers or the like.

The runtime platform may also store a trace log an XFS trace log relating to instrumented code in the service providers. The trace manager may access this XFS trace log in addition to the trace log to detect any errors occurring at the service provider level in addition to any errors occurring at the control application level.

In other embodiments the trace manager may detect patterns of unhandled exceptions and may create or update a profile to include trace details that are appropriate for those patterns.

The steps of the methods described herein may be carried out in any suitable order or simultaneously where appropriate. The methods described herein may be performed by software in machine readable form on a tangible storage medium or as a propagating signal.

The terms comprising including incorporating and having are used herein to recite an open ended list of one or more elements or steps not a closed list. When such terms are used those elements or steps recited in the list are not exclusive of other elements or steps that may be added to the list.

Unless otherwise indicated by the context the terms a and an are used herein to denote at least one of the elements integers steps features operations or components mentioned thereafter but do not exclude additional elements integers steps features operations or components.

