---

title: Declarative cluster management
abstract: An indication associated with an operation is received where the operation includes a mid-operation state and a device associated with the mid-operation state. In response to receiving the indication, the operation is processed using a declarative primitive to obtain metadata associated with one or more of the following: the device or the mid-operation state. The metadata is displayed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09218388&OS=09218388&RS=09218388
owner: EMC Corporation
number: 09218388
owner_city: Hopkinton
owner_country: US
publication_date: 20120627
---
Databases come in a variety of sizes. Some systems such as shared nothing massively parallel processing MPP systems store massive amounts of information for example on the order of terabytes or petabytes. For owners of these databases it is often very important that these databases be operational at full capacity. Downtime or even slower response times may be unacceptable. As a result it is important that operations which are performed on these systems such as management operations e.g. to migrate a database to new hardware or update software or access operations e.g. to write data to the database are well understood and or do not cause the system to crash or slow down at inconvenient times. It would be desirable if systems were able to provide services and or tools which made these operations easier to manage and or easier to understand. For example such services and or tools may be used by developers e.g. who are responsible for creating and or maintaining operations performed on a database or by users of the operations e.g. database administrators who manage a database .

The invention can be implemented in numerous ways including as a process an apparatus a system a composition of matter a computer program product embodied on a computer readable storage medium and or a processor such as a processor configured to execute instructions stored on and or provided by a memory coupled to the processor. In this specification these implementations or any other form that the invention may take may be referred to as techniques. In general the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein the term processor refers to one or more devices circuits and or processing cores configured to process data such as computer program instructions.

A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.

Mirrors are backups of primaries and mirror the state of primaries e.g. by performing duplicate instructions on mirrors so that the states of the two sets are the same . Should a primary go down e.g. primary the corresponding mirror e.g. mirror becomes the new primary e.g. responding to instructions from master . In some embodiments a distributed system does not include mirrors.

Master includes declarative primitives cluster management engine and operations . Cluster management engine performs operations e.g. in response to a user instruction using declarative primitives . In this example things like threads pools and ports are managed by cluster management engine . These are the portions of glue code which operations would otherwise have to handle themselves in order to manage nested operations. In some embodiments an instruction or indication is received from a user and cluster management engine performs the specified operation in response to the indication. Some operations stored in relate to management of the system such as editing configuration files installing applications measuring performance health monitoring provisioning infrastructure e.g. to satisfy a service level agreement adding new nodes e.g. to increase throughput or performing rebalancing e.g. to ensure high availability . Other operations in are data related operations for example to search for a certain value analyze stored content and so on.

Operations are described at a declarative level or using declarative descriptions e.g. as opposed to imperative code or issues . Put another way an operation describes goals or states e.g. states of one or more devices in distributed system through which some or all devices in a distributed system will progress during that operation i.e. mid operation . An exemplary operation may be to store information on a primary imperative details or issues such as opening a communication channel from master to the relevant primary creating a new data object on that primary to store the new data and so on may not be visible or described at least from the top level of the declarative type operation . Other examples of imperative details which may be hidden or abstracted out in an operation include building a parallel pool of threads setting up ports opening protocols and or managing sockets. An example of a declarative type operation is described in further detail below.

By including mid operation goals or states operations may provide metadata which may not have previously existed in the system. For example operations may have previously existed in a system as a large jumble of imperative code. With imperative spaghetti code it is difficult to tell e.g. in the middle of performing an operation what task or state the system is at if the overall operation is stuck if the operation is close to finishing etc. In contrast because operations include goals or states the system has as an example metadata about what states the system will go through during the operation e.g. prior to the operation being performed in what sequence those states will occur and so on. This provides a number of new and useful features and benefits some examples of which are described in further detail below.

Declarative primitives are put forth by a declarative language for performing operations . In various embodiments declarative primitives permit operations to be performed in a remote serial parallel nested or conditional manner including any combination thereof. An example of a remote expression included in an operation which a declarative primitive is able to process is On Primary Run Operation A . As shown in the previous example declarative primitives are able to understand the concept of device s on which to perform an operation e.g. Primary Primary is part of the target system. Two examples of serial expressions are Run Operation A Then Run Operation B and Run Operation A Run Operation B . An example of a parallel expression is Run Operation A and Operation B . In some embodiments declarative primitives permit operations to be nested e.g. Operation A includes just Operations B and C and actual operations of Operation A are wholly described in Operations B and C . An example of a conditional expression is When Receive Completion Signal Run Operation A . These are some examples the technique is not limited to these specific examples.

In various embodiments various e.g. markup languages are used to provide declarative primitives . In some embodiments JavaScript Object Notation JSON is used. In some embodiments YAML one embodiment of JSON is used. Other languages which may be used include XML and SDL. In some embodiments a custom text based markup format is used.

In some embodiments distributed system is a shared nothing massively parallel processing MPP database such as EMC s Greenplum Database. In some such systems primaries and or mirrors are implemented using large clusters of powerful devices which may be relatively inexpensive and or commodity like. A MPP system permits large amount of information to be stored and managed for example on the order of terabytes or petabytes. Other types of systems such as relational database management system RDBMS may not be able to manage such large amounts of information with sufficient performance. For example although a RDBMS system may technically be able to store terabytes of data the amount of time required to perform operations on the information may be too slow to be useful. In at least some cases downtime and system performance is very important. For example a financial services company may require real time access to the information stored in distributed system in order to perform customer transactions. A down system which would prevent the company from performing customer transactions or slow performance which might affect a share price and or number of shares exchanged would be extremely undesirable.

Although some of the example systems and example benefits described herein relate to distributed systems the technique is not necessarily limited to distributed systems. In some embodiments the technique is employed to manage single device non distributed systems.

On all primaries the sub operations start one database and verify start one database are performed serially. For example on Primary in the operation start one database is performed when that operation is completed verify start one database is performed on Primary . In this example on all primaries has the property that the operation s performed on one primary do not interfere with or depend upon operations s performed on another primary. For example verify start one database on Primary does not depend upon start one database finishing on Primary . Conversely in some embodiments an operation may wait for all devices to finish the same sub operation.

Next on standby signal completion is performed. For example verify start one database may output a standby signal if successfully completed and condition causes signal completion to be performed only when start one database and verify start one database have been successfully completed on all primaries.

Operation then includes on master signal completion . In this example signal completion performed on standby and signal completion performed on master are the same operation. As shown in this example an operation may be reused and or performed on different devices.

Next commence transformation is performed. As shown by the commence transformation operation it is not necessary for a sub operation to specify a device on which the operation is performed e.g. on master or a conditional expression e.g. on standby .

In the example shown components of operation are functional intuitive components similar to what a programmer would describe if explaining the operation to another person and or describing the operation in a technology or protocol agnostic manner. The programmer would describe affected devices at various mid operation states. Low level and or technology specific tasks like creating and managing threads pools ports and protocols are not mentioned or described in the names of components of operation and are hidden or abstracted out from the view shown herein.

In some embodiments a declarative type operation includes e.g. additional metadata not related to the functionality of the declarative type operation. For example in the code an operation may be called SrtAllDbs e.g. and if included as a sub operation in another operation it is referred to as such but the programmer may include additional metadata to indicate that the name of the operation to be presented to a user e.g. in a graphical or command line interface should be the more readable Start All Databases . The user may be programmer responsible for updating the operation or a user who runs the operation on a target system. Some other examples of additional metadata which may be included in an operation include historic run times or recommendations advice e.g. debugging advice if the operation failed planning advice before the operation is run affected devices etc. . In some embodiments this additional metadata is provided or specified by a programmer.

Leaf operations such as start one database and verify start one database do not by definition include other operations. In one example of a leaf operation the programmer responsible for coding verify start one database has decided to test that the database in question has been successfully started by testing all functions related to the database which was started. For simplicity suppose adding a data object in the database deleting a data object in the database writing to the database reading from the database changing a property of the database and reading a property of the database comprise the entire set of database related data and management operations. Operation in one example goes through all possible operations and confirms that all of the functions are operating for example by setting a data value or property of the database to a known value reading back the value property and confirming that the returned value is the expected value. In various embodiments the contents of a leaf operation are performed in a command line interface and or include functions exposed by an application programming interface API provided by the distributed system.

In various embodiments a variety of e.g. markup languages may be used to implement operations. Some examples include Python and YAML.

StartRemoteDatabase is included in file start remote database.py . The code in file permits file start one database.py to be invoked remotely through an secure shell SSH call. File includes the actual code to start one database the primary purpose of file is to be glue code connecting file start one database.py and StartRemoteDatabase . Similar to creation of a thread pool and creating a list of primaries in file this glue code has no direct relevance to the overarching job of starting a database and is an annoyance.

One benefit to declarative type operations e.g. including data related operations and management related operations distributed system is that management of a code base is simplified and or more manageable for the programmers compared to a code base which is implemented using imperative code. In for example a programmer has to open up 3 different files to see all of the code and the functionality of the operation i.e. to start all databases is buried amongst code which creates thread pools and handles return codes. The division of the code amongst files and also does not reflect intuitive high level functional tasks. In contrast the example of may be contained in the same file and is human readable and intuitive. A user reading operation knows what sub operations are included in operation on what devices conditions those sub operations occur in what sequence the sub operations occur and so on. Declarative type operations also permit and encourage modularity. Note for example how operation is broken up into intuitive modules as opposed to a jumble of code.

Another benefit to a declarative type operation is that it is deconstructed or divided into a hierarchy or structure with components see e.g. the structure of operation in with a plurality of components which permits a system to have metadata or state information about the operation. In one example a system is able to parse the hierarchy shown in operation e.g. without the operation actually being performed and internally build a sequence of states through which the system will progress. In some embodiments coding a declarative type operation such as operation is sufficient for a system to obtain metadata or state information and it is not necessary to specify additional and or dedicated metadata to impart state information. In some embodiments this metadata or state information is used to support planning services e.g. before and or without actually performing an operation or reporting services while the operation is being performed or failure related services in the event the operation fails.

In contrast a system which intakes files and is not able to build such a sequence of states. File for example contains thousands of lines of code as does file and there is no demarcation or division of distinct states or metadata about what is happening from a functional or high level point of view. As for file even though it is much shorter than files and it has no relation to the functional or application specific task of starting all databases i.e. it is glue code . As such it provides no insight into the start all databases operation e.g. which could be used by a user interface to present information to a user .

Another benefit to declarative type operations is simplification and or easier implementation of remote procedure calls RPC which is of particular concern in distributed systems. Cluster management engine on master in for example may want a certain operation to be performed on all of primaries . The imperatively coded example of includes infrastructure and protocols for this in file i.e. start remote database.py . Without declarative type operations RPCs require glue code to distill parameters into a command line string that can be SSH d to a remote host. A declarative type operation on the other hand is a complete articulation of a task. By adhering to this protocol anything that implements this API can be serialized for RPC easily as is the case of operation in . On all primaries and on master in operation specify respectively for sub operations and the devices on which the corresponding sub operations are performed. Put another way sub operations and and also signal completion since and are essentially the same are addressable so that an operation can be addressed or directed to desired device s .

Another benefit to declarative type operations may be observed prior to performance of an operation. The following figure shows an example of a command line interface which provides a planning service.

In some embodiments as part of a planning process a system takes into account a target system on which the operation is theoretically to be performed. In some cases some sub operations or mid operation states are not applicable because they are not relevant or necessary for that particular target system. For example if a system has no mirrors and some of the components of an operation relate to mirrors then those components of the operation are removed from a statement of work presented. In some embodiments a statement of work includes sub operations which are not relevant to the target system but they are grayed out or presenting in some other manner to indicate exist but they are not relevant for the target system.

As described above it may be very important for some users to ensure that there is no system downtime or performance lag and planning features are therefore very important. With the imperatively coded operation in planning may not be possible. For example the statement of work in command line interface would not be able to be returned using the imperatively coded operation in e.g. because there is no metadata included in the operation which can be presented to the user .

Other benefits to the system may be observed while an operation is running i.e. at run time . The following figure describes one such embodiment.

Command line interface shows another reporting embodiment. In this example real time process indicators are presented in command line interface . In the state shown therein the start all databases operation is in the middle of the verify startup one database sub operation and completion percentages are shown for that sub operation i.e. 1. On All Nodes as well as the parent component i.e. 1.2 VerifyStartupOneDatabase . When the operation progresses to 2. On Standby 2.1 SignalCompletion not shown command line interface updates itself to replace 1. On All Nodes and 1.2 VerifyStartupOneDatabase with 2. On Standby and 2.1 SignalCompletion and updates the corresponding completion percentages. In shown herein in some embodiments run time reporting is performed in real time.

Some benefits to the system may be observed in the event an operation e.g. start all databases fails. The following figure describes one such embodiment.

With the imperatively coded operation in the system would not be able to report what state the operation failed in. Note for example that StartOneDatabase in file is on the order of thousands of line of code and while the system may know at what line of code failed it may not know what intuitive task that line of code is associated with. In contrast declarative type operation in is clearly divided into distinct states or goals. Thus when declarative type operation is performed it is very clear what state a system was in when it failed. This also permits hierarchical logging and or real time process indicators in the middle of performing a declarative type operation. 

Although the exemplary interfaces described above are all command line interfaces services or features which build off of declarative type operations are not limited to command line interfaces. The following figures show some exemplary graphical user interfaces which provide planning services real time reporting while a declarative type operation is being performed and failure reporting.

Graphical user interface is in a planning mode in which the interface reports which devices are affected by a selected sub operation shown in flow window . The user has selected turn off mirrors in flow window in response to that selection system window highlights the affected devices. As shown in system window the mirrors in the distributed system are affected by turn off mirrors .

Referring back to operation shown in devices affected by an operation shown as rounded rectangles in may be indicated or flagged using markup and may thus be determined from the markup when the operation is parsed by a cluster management engine.

Although not shown herein a graphical user interface may permit a user to specify the operation in flow window and or a target system in system window e.g. because there may be multiple systems under the control of the user .

In some embodiments a graphical user interface does not reveal further details about a sub operation if it is a leaf e.g. double clicking on a leaf would not cause corresponding code to be displayed . For example a user interface may be directed towards planning and or run time services not development services. In some embodiments the contents e.g. code and or any additional metadata of a leaf are displayed depending upon the role of a user. For example a developer may have his her permissions set so that s he can see the code. In contrast the permissions for a database manager who is primarily interested in running the operation and prior to that planning for the operation may not permit that.

In some embodiments a user is able to if desired further interact with the user interface to further debug the failure. For example double clicking on mirror may cause graphical user interface to present additional information about the mirror which failed e.g. information from a log recording when the mirror could not be located suspected or known causes why the mirror could not be located make model of the mirror software version running on the mirror a user assigned name of the mirror post failure memory dumps of the mirror etc. .

At an indication associated with an operation is received where the operation includes a device and a mid operation state associated with the device. In various embodiments the indication received at is received via a command line interface see e.g. or via a graphical user interface see e.g. . Examples of a device included in an operation include one or more of master primaries and or mirrors in . In devices are indicated using rounded rectangles and mid operations states also referred to as sub operations are indicated using rectangles in some embodiments markup is used to indicate a device and or mid operation state in the declarative type code e.g. in the leaves of an operation. In various embodiments the operation is associated with system management e.g. upgrading a system starting a system changing a system setting or parameter etc. or with managing information stored on the system e.g. performing a search on stored data analyzing stored data storing new data etc. .

At in response to receiving the indication the operation is processed using a declarative primitive to obtain metadata associated with one or more of the following the device or the mid operation state. In some embodiments an indication is associated with planning and the operation is not actually performed see for example FIGS. and . In one example the operation is parsed to build an internal structure of one or more mid operation states and associated device s without actually causing those devices to enter those mid operation states. In some embodiments an indication received at is associated with performing the operation and includes performing the operation see e.g. and .

At the metadata is displayed. In for example the metadata is displayed using a command line interface and in the metadata is displayed via a graphical user interface. As shown in a variety of metadata may be displayed including but not limited to planning related metadata run time metadata and failure related metadata.

In some embodiments a user interface is interactive and a user may obtain further metadata for example by double clicking on an item in a graphical user interface or entering a command into a command line interface. In some embodiments after displaying metadata at the user repeats the process shown in this figure for example with some other operation e.g. the user is in a planning stage and wants to review planning information for a first planned operation and then a second planned operation or the same operation e.g. an operation failed and the user wants to perform the operation again after making some adjustment to the system . In some embodiments information displayed at is saved or logged e.g. so that it can be reviewed later if desired by the user . In various embodiments a system is configured to automatically log information displayed at or only after being so instructed by a user.

Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive.

