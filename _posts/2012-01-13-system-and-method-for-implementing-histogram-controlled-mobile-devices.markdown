---

title: System and method for implementing histogram controlled mobile devices
abstract: A communication network and software for its implementation that controls a mobile device based on historical user activity is provided. The mobile device communicates with a server and includes a function that is dependent on the user activity. The server senses the user activity over time and produces a histogram of that activity. The rate at which the server attempts to sense the user activity depends on the histogram. An application might change the function depending on the result of detecting the user activity and the rate at which it does so.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954571&OS=08954571&RS=08954571
owner: WaveMarket, Inc.
number: 08954571
owner_city: Emeryville
owner_country: US
publication_date: 20120113
---
This invention generally relates to wired and wireless communications. More specifically this invention relates to mobile devices whose functionality is influenced by their historical patterns of operations.

Mobile devices such as cellular telephones smart phones GPS systems and cellular enabled personal computers have become very common and very powerful. This combination of ubiquity and capability has created an ongoing demand for improved devices and unique applications. While applications currently exist for providing games social networking navigation assistance locating of points of interest location tracking targeted advertising and consumer and business related services even more capable unique and customizable applications are in demand.

A typical mobile device operates on a communication network that is provided by a mobile telephone operator. Such communication networks provide communication links and basic services such as time keeping and access to the public telephone network. A typically state of the art mobile device often referred to as a smartphone may have built in features such as communication ports touch screen displays keyboards orientation sensors accelerometers cameras one or more timers microphones audio outputs memory card readers significant internal memory and specialized software. Such mobile devices can provide a wide range of functionality such as telephone communications texting calendars alarms memo and note recording GPS navigation music MP3 and video MP4 playback video calling conference calling movie playback picture taking and sending games e mails audio and video downloading internet access and browsing short range communications such as Bluetooth mobile banking instant messaging and the ever popular specialized ringtones.

To maximize a customer s user experience a particular application may need to determine the location and status of a mobile device control a mobile device s functionality and send and retrieve data from a particular mobile device. For example some mobile devices can be configured such that the current physical location of the device as well as its current status such as being on off in standby or in use can be determined and then the functionality of the mobile device can be controlled to better serve the user. Such abilities enable applications that provide users with time location use and functional specific services and capabilities for example advertising games social networking navigation assistance points of interest and consumer and business related services.

While mobile device users can and have benefited from location specific services there are other services that are useful based on user activities. For example some services are particularly useful when a user is performing a particular activity such as driving or when actually using a communication device. This ability has opened up the possibility of user activity based applications that perform activity specific services and or that can automatically configure a mobile device s functionality based on use.

However the difficulty of actually controlling the wide range of different mobile devices on different networks retrieving data from those mobile devices and then determining locations status or user activities can become so complex that some otherwise worthwhile applications may simply not be cost effective to implement. However with over 4 billion mobile devices in existence the demand for more better and specialized applications is extensive and growing.

One approach to addressing the complexity of providing users with applications that can take advantage of mobile devices having different features on different communication networks as well as in different locations and in different operating statuses is disclosed in U.S. patent application Ser. No. 13 217 093 entitled System and Method for Enabling Control of Mobile Device Functional Components which was filed on Aug. 24 2011. That patent application is hereby incorporated by reference in its entirety as if fully disclosed herein.

While the teachings of U.S. patent application Ser. No. 13 217 093 are highly useful and beneficial some applications may demand even more control of the mobile devices they run on than is provided by the teachings of that application.

The principles of the invention provide for a method and system which facilitates the development and maintenance of applications for mobile devices that make use of historical patterns of operation while also enabling addressing issues of complexity in mobile device control and data collection.

A communication network in accord with the invention includes a mobile device having communication capability and a function that is dependent on a user activity such as driving or using the mobile device. A server with a communication capability includes activity detection logic for detecting the user activity based on the function. The server further includes a data collection unit that collects and compiles a digital histogram of the user activity which is stored in a stored histogram database. The server further includes a polling mechanism that directs the activity detection logic to detect the user activity based on the stored histogram.

Another communication network that is in accord with the invention includes a mobile device having communication capability and a function that is dependent on a user activity such as driving or using the mobile device. A client state manager with a communication capability communicates with a server having activity detection logic for detecting the user activity based on the function. The server reports the user activity back to the client state manager that collects and compiles a digital histogram of the user activity which is stored in a stored histogram database. The client state manager further includes a polling mechanism that directs the server and its activity detection logic to detect the user activity based on the stored histogram.

The user activity is beneficially either driving or using the mobile device. The stored histogram can be fixed in which case it keeps track of all user activity from an initial start time or rolling in which case old data is discarded. Preferably the stored histogram tracks the user activity over either a 24 hour or 1 week interval. Ideally there are four histograms two for driving one a 24 hour histogram the other a week histogram and two for mobile device usage one a 24 hour histogram the other a week histogram.

The communication network might further incorporate an application that depends on the user activity. By polling the user activity based one or more histograms the application can provide a better user experience by better sensing the user activity based on previous activity at this time of day or week.

The invention can be incorporated as coded instructions in computer readable storage media. Such media can implement stored client states that indicate the statuses of functional components of a mobile device. Each client state can correspond to at least one functional component. That media can further implement a digital histogram of client state activity with the histogram indicating the status of a client state activity over time.

The disclosed subject matter will now be described more fully hereinafter with reference to the accompanying drawings. However it should be understood that this invention may take many different forms and thus the invention should not be construed as being limited to the specific embodiments set forth herein.

In the figures like numbers refer to like elements. Furthermore the terms a and an as used herein do not denote a limitation of quantity but rather denote the presence of at least one of the referenced items. All documents and references referred to in are hereby incorporated by reference for all purposes.

Refer now to which is a schematic illustration of an exemplary operating environment suitable for incorporating the principles of the invention. The operating environment includes a server state manager that functions within a communications network . The communications network preferably includes at least one wireless network and possibly at least one wired network that provide communication capabilities for the devices in the operating environment . The server state manager is preferably implemented on a network server using one or more processing units hardware components and software components as required.

Still referring to the server state manager includes a client interface and a third party interface . The client interface communicates with at least one client state manager via an internal synchronous interface and an asynchronous interface . The client interface preferably implements a Representational State Transfer styled application program interface RESTful API . The server state manager exposes various functional components of the client state manager to at least one participating third party application via the third party interface using another RESTful API. Alternatively other suitable application program interface architecture might be leveraged for server state manager communications.

In practice the server state manager services a plurality possibly a very large number of different client state managers. For convenience when a particular client state manager is being referred to it will be referred to as the client state manager while when any client state manager or all state client managers are being referred to it or they will be simply referred to as a client state manager. As with client state managers the server state manager may interface and operate with a plurality possibly a very large number of third party applications including multiple versions of the same application. Again when a particular third party application is being referred to it will be referred to as the third party application while when any third party application or all third party applications are being referred to it or they will be simply referred to as a third party application.

Referencing now and as required the client state manager is preferably implemented via encoded instructions on a mobile device which preferably includes cellular telephone transmitting and receiving functionality. The encoded instructions can be hardware or software enabled. The third party application may reside on the same mobile device as the client state manager reference or the third party application may reside on a separate system which communicates with the server state manager via the communications network reference .

Referring now primarily to the client state manager includes a functional component enablement engine that enables and disables various functional components of the mobile device . Those functional components preferably include software or hardware driven features settings capabilities and resources. Different mobile devices may implement different client state managers having different functional components or may implement the same functional component but in a different way.

The server state manager includes a server state with history database that stores states that indicate the statuses of various functional components of each mobile device in communication with the server state manager specifically including the mobile device that implements the client state manager . The statuses of the functional components of the mobile devices may indicate whether a particular functional component of a mobile device is enabled or disabled or may indicate one or more scheduled time periods when a particular functional component is enabled or disabled. Significantly the statuses of the functional components can include particular sets of modifiable parameters.

The server state with history database also includes historical information regarding the operating activities of the mobile device . For example the server state with history database can contain a digital history of the times at which the user of the mobile device is driving or the times at which the mobile device is being used. That historical information is beneficially implemented in a database that corresponds to a modified histogram of the functional states of the mobile device . Such a histogram is described in more detail subsequently.

Still referring to the server state manager also includes a server digest database that stores a status digest for each of the functional states. Each digest is preferably determined via a hash function that is applied to elements of a respective state by a digest generation engine .

Turning now to the client state manager shown in the client state manager includes a client state with history database which stores the statuses of the functional states of the mobile device as well as historical information regarding the operating activates of the mobile device as well as a client digest database which stores digests corresponding to the stored states. In practice the functional states and historical information and the digest are received from the server state manager . For the purpose of clarity states histories and digests corresponding to a particular mobile device and stored by the server state manager are respectively termed server states server histories and server digests and states histories and digests received from the server state manager and stored by the client state manager are respectively termed client states client histories and client digests .

The server state manager is configured to receive from the third party application via the third party interface a request to modify the status of one or more functional components of the particular mobile device that implements the client state manager . That third party application may be implemented such that actually modifying the status of one or more functional components of the particular mobile device depends on the historical information of that mobile device . For example the third party application can seek to automatically switch to hands free operation if the user of the mobile device is usually driving at a specific time during the day. The historical information in the client state with history database can be used to determine how often a determination is made as to whether the user is driving at a particular time.

A request to modify a functional component status can come as a preference indication for example turn on mobile device location streaming or turn off mobile device location streaming or switch to hands free operation or switch from standby to active operation. A request may also include a modification of one or more parameters of a functional component and how often that modification is made can depend on the historical information regarding operational activities of the mobile device .

In response the server state manager uses a state update engine to update one or more server states that correspond to one or more functional components. When a particular server state is updated a corresponding server state digest is updated via the digest generation engine . In practice a particular functional component can be related to other functional components discussed in more detail subsequently . In such cases an application s request to modify the status of a particular functional component would trigger updates of the state database and digest database not only for the particular functional component but for the related functional components as well.

In response to server state with history database and server digest updates updated server digests are transmitted from the server state manager via the client interface to the mobile device implementing the client state manager . Beneficially the server state manager transmits updated server digests to the mobile device via asynchronous communications using the asynchronous interface and a Short Message Service SMS protocol. The client state manager compares the received server digest with its client digest using the digest comparison engine . If a difference is detected a state request corresponding to the difference is generated by a state request engine . The generated state request is then transmitted to the server state manager via its client interface .

State requests are preferably sent by the client state manager using synchronous communication via the synchronous interface . A typical protocol is the Hypertext Transfer Protocol Secure HTTPS . The server state manager then transmits via its client interface a server state that is responsive to the received state request using synchronous communication preferably using the same protocol.

The newly transmitted server digest might be the same server digest previously transmitted to the client state manager or if the server state with history database has been re updated since the corresponding server digest was sent a re updated server state with history can be transmitted to the client state manager . The server state with history is preferably transmitted along with the corresponding current digest using synchronous communication. The newly received state and digest are stored in the respective client state with history database and client digest database . Beneficially the history component in the client state with history database is not changed.

Transmitting the most current digest in the synchronous communication is important since it is possible that the particular server state and corresponding server digest may have been re updated by the state update engine since the updated digest was transmitted to the client state manager . Further additional server digests corresponding to functional components related to the particular functional component can be transmitted with the state and digest of the particular functional component responsive to the state request. Thereafter the client state manager s digest comparison engine compares each received additional server digest with its corresponding client digest and transmits another state request if a difference is determined between an additional server digest and its corresponding client digest and the server state manager thereafter returns one or more states corresponding to the new state request.

The client state manager uses the functional component enablement engine to enable or disable a functional component as indicated by the received corresponding server state. The newly received server state is stored by the client state manager as the corresponding client state in the client state with history database preferably overwriting the existing corresponding client state. Similarly the newly received server digest is stored by the client state manager as the corresponding client digest in the client digest database preferably overwriting the existing corresponding client digest. Once again the history component in the client state with history database is beneficially not changed.

Refer now once again to wherein an implementation of a network of devices suitable for practicing the invention is shown. The third party application resides on the mobile device on which the client state manager is implemented. The server state manager is implemented on a state server . A message aggregation server executing a message aggregator for example a Short Message Service SMS aggregator or Short Message Service Center SMSC disseminates asynchronous communications for example SMS messages from the server state manager to the client state manager for example via a wireless telecommunications network. Synchronous communications for example implementing HTTPS through a data network are initiated between the client state manager and the server state manager and between the third party application and the server state manager respectively.

Refer now once again to wherein another implementation of a network of devices suitable for practicing the invention is shown. In implementation the third party application resides on a separate application server that is in communication with the server state manager on the state server for example via a data network. The message aggregation server disseminates asynchronous communications for example SMS messages from the server state manager to the client state manager implemented in the mobile device . Synchronous communications are initiated between the client state manager and the server state manager and between the third party application and the server state manager respectively.

Functional components can include a mobile device s software or hardware driven features settings capabilities and resources. Examples of functional components are presented in Tables 1 5 which respectively show example features capabilities settings resources and parameters which can be set for particular features and capabilities. Some of the functional components can be enabled and disabled by the functional component enablement engine of the client state manager on a particular mobile device .

As previously indicated some functional components are interrelated to the extent that modification of the status of a particular functional component may result in modification in the status of one or more related functional components. Referring now specifically to and Tables 1 4 a particular mobile device can be enabled for example with features settings capabilities and resources . Particular features are related to particular capabilities and particular resources . Modification of the status of a particular capability or particular resource may result in modification of the status of a particular feature or vice versa. Mobile device user specific data subscriber specific data for example mobile device location data or operational state data or possibly historical information is disseminated by a mobile device based on the status of the capabilities . That data is stored in a subscriber database in the server state manager for dissemination to an authorized third party application .

One example of the interrelated functions is shown in . Capabilities C location streaming and C on demand location requesting are related to feature F location data access . A change in status of feature F can result in a change in status and histories of capability C or C or alternatively a change in status of capability C or C results in a change in the status and history of feature F. For example a request from a third party application to the client state manager to enable or disable feature F immediately or during a scheduled time period or based on historical information regarding feature F causes the client state manager to direct the server state manager to update the server states and server digests of feature F and capabilities C and C to reflect that features F and capabilities C and C are enabled or disabled. In another example a request from a third party application to the server state manager via the third party interface to disable location streaming capability C causes the state update engine to update the server state of capability C and causes the digest generation engine to update the server digest of capability C. The request further causes the server state manager to update the server state and server digest of the location data access feature F.

Another example is shown in . Capabilities C Locking interface based on time schedule and C Locking interface based on driving and resources R R are related to feature F Device interface locking control . A change in status of feature F can result in a change in status of capability C or C or alternatively a change in status of capability C or C results in a change in status of feature F. For example a request from a third party application to enable or disable the device interface locking control feature F immediately or during a scheduled time period or based on historical patterns causes the server state manager to update the server states and server digests of feature F and capabilities C and C to reflect that feature F and capabilities C and C are enabled or disabled. In another example a request from a third party application to lock the mobile device interface during a particular time period or during an activity such as driving via capability C causes the state update engine to update the server state of capability C and causes the digest generation engine to update the server digest of capability C. The request further causes the server state manager to update the server state and server digest of the device interface locking control feature F. In addition the client state manager updates the history of the user activity.

Referring now to Table 5 and particular enabled features and capabilities allow setting of parameters by a third party application. For example as shown in a third party application enabling the locking interface based on driving capability C can set 1 parameter P to select applications which can run when device interface is locked 2 parameter P to select phone numbers which interface locked device can continue to place calls to or receive calls from 3 parameter P to select phone numbers from which the interface locked device can continue to receive messages e.g. SMS from 4 parameter P to select whether a hands free device connected to the interface locked device e.g. Bluetooth headset can be used to place phone calls and 5 parameter P to select whether an auto reply message is sent to a user device sending a message e.g. SMS to the interface locked device.

As shown in Table 5 parameters P through P are also applicable to capability C locking interface based on time schedule and feature F device interface locking control. As shown in a third party application enabling the screen messaging capability C can set 1 parameter P to specify message content 2 parameter P to specify a URL link associated with a specified message and 3 parameter P to select whether to launch a device web browser and connect to a specified URL responsive to user interaction with a specified message e.g. user clicking on message .

The principles of the invention relate to collecting and using historic information regarding the operation of the mobile device and the activities of the user of that mobile device . For example an operation of the mobile device might be a user using a screen while an activity of the user might be driving a vehicle. Those principles enable the focusing of applications to users based on historical information.

The foregoing scheme of using instantaneous speed to determine whether a user is driving works great in places like central Kansas but maybe not so well in Los Angeles San Jose San Francisco Washington D.C. Houston or any other city that suffers traffic jams. During certain time periods in certain places of such cites the average rate of travel during rush hour may be less than walking. Proprietary schemes may be incorporated to determine whether a user is or is not driving. Some of those proprietary schemes can make use of historical patterns of user activity. That is if the user is usually or often driving during a time period an application may frequently poll the mobile device to determine whether the user is driving.

To be useful historical patterns of user activity must be collected and compiled in a manner that can be stored searched and used. Examples of such actions are depicted in . Software implements code that includes the activity detection logic that obtains data related to user activities and a data collection unit that collects the data from the activity detection logic . That collected data is then compiled into a collection of stored histograms of user activities that represent frequency of occurrences of different user activities over different time spans. A polling mechanism can then make use of the stored histograms to cause the activity detection logic to poll the user based on the frequency of occurrence of an activity to determine its current activities.

For example if a driving event is occurring when the activity detection logic polls the user the activity detection logic determines that the user is driving the vehicle . That determination along with the current time is sent to the data collection unit which adds the driving activity and time into a stored histogram related to driving. Similarly whenever a user turns on or off the screen on their mobile device the activity detection logic senses that the user has turned on or off the screen the time is determined and the activity and time is sent to the data collection unit which adds the on or off activity and time into a stored histogram related to phone usage.

As used herein a stored histograms is a database of a variable a user activity such as driving or using a phone over time that is useful for estimating the probability of the underlying variable activity occurring during different time intervals. That is how likely the variable will occur in or over a particular time period. Such a histogram is a digital version of a plot of density verses time data.

Typically histograms are configured such that the total area of the histogram is normalized to 1 while the lengths of the intervals along the X axis are all 1 equal . Such histograms provide a relative frequency plot of the occurrence of the variable in each interval. A stored histogram in accord with the invention is a modified version of the typical histogram but it still provides information related to the likelihood of the occurrence of the variable in a time interval. Differences include the fact that the X axis time intervals may not be the same although depending on the application they might be and that there is no need to normalize the total area to 1 although depending on the application it might be .

Referring again to the histograms show a visual representation of digital stored histograms see over a time period starting at 12 00 PM and running to 8 00 PM. Preferably there are digital stored histograms for a 24 hour period and for a week for both driving and mobile device usage . However different implementations might keep histograms for each day of a week over a fortnight daily per month or other suitable time period. Furthermore the half hour time period shown in is simply for convenience of explanation. A stored histogram can use different time periods such as minutes 5 minute intervals quarter hours and can in fact use unequal time periods. For example between 1 00 AM and 6 00 AM the time periods may be hour long while from 6 00 AM to 9 00 AM they may be kept in 5 minute intervals.

Referring now to each time interval represents a time bin and thus each stored histogram will have some number of time bins. When the activity detection logic polls the user and determines that a user activity is taking place driving in mobile device usage in the data collection unit determines the time of the polling event for example 12 30. When the next polling event takes place the data collection unit determines the time of that polling event for example 1 00 and also determines whether the user is found to be still performing the user activity driving using the mobile device . If the user activity driving mobile device usage is still occurring and if the two polling times completely span a time bin as it does in this example the data collection unit adds 1 to the time bins spanned by the polling times here the time bins and .

However if the polling times only partially span a time bin then the value added to the partially spanned time bin is scaled to indicate the amount of coverage present. For example referencing assume that at 12 00 PM the activity detection logic polls the user and determines that a user activity is taking place specifically driving . Then at 12 05 the activity detection logic polls the user and determines that the user activity is still taking place. This continues at 5 minute intervals until at 12 20 the activity detection logic polls the user and determines that the user activity is not taking place the user is no longer driving . In that case the data collection unit adds 0.5 or depending on the programming 0.67 to time bin that covers the polling times.

In practice there are preferably two different kinds of stored histograms fixed and rolling. A fixed stored histogram contains an absolute history of all variables since a given start time. New events are scaled proportional to the amount of data already in the stored histogram. Using this approach old activity is not forgotten but its relevance is diminished. A rolling stored histogram contains only n time bins worth of data while older data is thrown out. New data always has the same weight as previous data did while old data is discarded.

Rolling stored histograms are in some ways more useful than fixed stored histograms because they better reflect recent user activities. A problem exists with rolling histograms in that when they are first created there is no past data to meld with new data. However rolling stored histograms can be initialized to incorporate reasonable initial assumptions of a user s activity. This has the advantages that the new data is not given undue precedence while still enabling learning of a user s actual activity behavior over time.

Rolling stored histograms are beneficially initialized based upon guesses as to what the most common behavior is. For example from 12 00 to 6 00 AM an assumption can be made that the user is asleep. In that case the mobile device is placed in an initial state and the polling mechanism causes the activity detection logic to apply default polling intervals that were defined a priori.

Since the polling intervals of some histogram tracked activities will depend on a user s activity history and since without an actually history the default polling intervals might be used until a sufficient user activity history is determined. For example a default might assume that between 11 00 PM and 6 00 AM that a user is sleeping. Then the default might assume that from 6 00 7 00 AM a user is getting ready for work from 7 00 to 8 00 AM the user is driving to work from 8 00 AM to 5 00 PM the user is at work from 5 00 to 6 00 PM the user is driving home from 6 00 to 7 00 PM the user is eating from 7 00 to 10 00 PM the user is on the computer and from 10 00 to 11 00 PM the user is watching television.

The default assumptions may or may not match up with actual user activities of the user . The purpose of the activity detection logic the data collection unit the stored histograms and the polling mechanism is to learn the activities of the user over time and then to make use of that learning to enhance the user experience of user . If the user is a heavy user of the mobile phone the learning may be quick. For example if the user usually commutes to work between 9 00 and 10 30 instead of the default assumption of 7 00 to 8 00 AM polling of the mobile device between 7 00 and 8 00 AM will not add to the driving histogram while polling between 9 00 and 10 30 will. Additional polling between 9 00 and 10 30 will soon overwhelm the default assumption. Likewise if the user normally works between 10 00 AM and 6 00 PM and uses the mobile device from time to time that will also be learned. If the user commutes home between 6 00 and 7 30 PM this will be learned.

Until the user s activities are learned the battery life of the mobile device may be wasted and or the user might be informed of various events at a sub optimal rate. Other user activities might be included in stored histograms . For example if from 7 30 to 8 00 PM the user often goes out to dinner with friends the user might often send text messages at a high frequency. This is noticed and a stored histogram can be created. Again if the user is out and about from 8 00 to 12 00 PM this is also learned. This is noticed and a stored histogram can be created. As time goes on the default histogram profile gives way to a stored histogram profile that reflects the user s activities.

The preferred method of practicing the invention keeps at least four stored histograms . One is a defaulted see above daily rolling histogram for driving and another is a defaulted record of mobile device usage. Another stored histogram is a weekly absolute driving histogram i.e. without any default values and the last is a weekly absolute mobile device usage histogram.

Beneficially the client state manager is implemented to use the stored histograms to optimize the behavior of the application by adjusting polling times. If the user is typically driving at a given time period say 7 00 7 30 PM time bin in as determined by the driving stored histograms the client state manager increases its polling frequency to check more often to determine when driving ends and a new functionality should to be implemented by the application such as unlocking the screen of the mobile device . Contrary if the user is typically not driving such as at 3 00 AM the polling frequency decreases and driving functionality is checked less often.

The application can use the stored histograms as a basis to query for status results which are then used to control mobile device functions. For example an application might be programmed to automatically lock the mobile device when the user is driving. To determine whether a user is driving the application pings the client state manager to request the server state manager to run the activity detection logic program to determine if the user is driving. If the user is driving the application locks the mobile device . If the user is not driving the application unlocks the mobile device. The rate at which the application pings the client state manager depends upon the historical records of the histograms .

Based on the foregoing the histograms can be used to optimize the performance of the application and or the mobile device . The client state manager and the application adaptively learn the activities of the user and make use of that knowledge to provide an enhanced user experience.

While embodiments of the invention have been described in detail above the invention is not limited to the specific embodiments described above which should be considered as merely exemplary. Further modifications and extensions of the invention may be developed and all such modifications are deemed to be within the scope of the invention as defined by the appended claims.

