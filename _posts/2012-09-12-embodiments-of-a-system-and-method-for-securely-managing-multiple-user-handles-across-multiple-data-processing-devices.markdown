---

title: Embodiments of a system and method for securely managing multiple user handles across multiple data processing devices
abstract: A system and method for are described for securely linking a phone number and user identification code in a directory database. A computer-implemented method comprising: receiving a first request from a first user device to register with a first service, the request identifying a phone number of the user device and including a fingerprint code uniquely identifying the first user device; registering the phone number in a directory service; receiving a second request from the first user device to register with a second service, the request including a user identification code which is not a phone number and the fingerprint code; registering the user identification code in the directory service; detecting that the first request and second request are from the same mobile device using the fingerprint code; and responsively linking the phone number and the user identification code in the directory database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09119067&OS=09119067&RS=09119067
owner: Apple Inc.
number: 09119067
owner_city: Cupertino
owner_country: US
publication_date: 20120912
---
This application is a continuation in part of the following previously filed United States patent applications 

U.S. application Ser. No. 13 224 599 filed on Sep. 2 2011 entitled System And Method For Secure Instant Messaging now U.S. Pat.No. 8 958 559 which claims the benefit of U.S. Provisional Application No. 61 492 903 filed on Jun. 3 2011 entitled System And Method For Secure Instant Messaging .

U.S. application Ser. No. 13 224 626 filed on Sep. 2 2011 entitled System And Method For Secure Identity Service which claims the benefit of U.S. Provisional Application No. 61 492 917 filed on Jun. 3 2011 entitled System And Method For Managing User Identities .

This invention relates generally to the field of computer networking. More particularly the invention relates to an improved apparatus and method for managing multiple user handles across multiple data processing devices.

The proliferation of mobile devices such as the Apple iPad and iPhone have created new ways for users to exchange instant messages text messages and email messages. As a result users often send and receive messages using one or more mobile devices and at least one desktop or notebook computer.

Coordinating these different message types across multiple devices can be difficult. For example if a user has an iPhone and desktop computer then the user may be associated with a telephone number while using the iPhone and with a user ID such as an email address when using the desktop computer. Thus messages sent via the iPhone may be mapped to the user s telephone number and messages sent via the desktop computer may be mapped to the user s ID code. Consequently a single message thread between two users may be divided across multiple user ID codes and devices resulting in an undesirable user experience.

As such what is needed is a more efficient dynamic mechanism for identifying users with multiple types of user handles including but not limited to telephone numbers and user ID codes e.g. email addresses . What is also needed is a way to associate messages with multiple user handles such as phone numbers and user ID codes.

A system and method for are described for securely linking a phone number and user identification code in a directory database. A computer implemented method comprising receiving a first request from a first user device to register with a first service the request identifying a phone number of the user device and including a fingerprint code uniquely identifying the first user device registering the phone number in a directory service receiving a second request from the first user device to register with a second service the request including a user identification code which is not a phone number and the fingerprint code registering the user identification code in the directory service detecting that the first request and second request are from the same mobile device using the fingerprint code and responsively linking the phone number and the user identification code in the directory database.

Described below are embodiments of an apparatus method and machine readable medium for linking multiple types of user identification codes including phone numbers and email addresses to online services. Throughout the description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances well known structures and devices are not shown or are shown in a block diagram form to avoid obscuring the underlying principles of the present invention.

As illustrated in a general network topology implemented in one embodiment of the invention can include a group of client or peer mobile computing devices A D respectively communicating with one another and with one or more services over a network . Although illustrated as a single network cloud in the network can include a variety of different components including public networks such as the Internet and private networks such as local Wi Fi networks e.g. 802.11n home wireless networks or wireless hotspots local area Ethernet networks cellular data networks e.g. 3G Edge etc and WiMAX networks to name a few. For example mobile device A may be connected to a home Wi Fi network represented by network link mobile device B may be connected to a 3G network e.g. Universal Mobile Telecommunications System UMTS High Speed Uplink Packet Access HSUPA etc represented by network link mobile device C may be connected to a WiMAX network represented by network link and mobile device may be connected to a public Wi Fi network represented by network link . Each of the local network links over which the mobile devices are connected may be coupled to a public network such as the Internet through a gateway and or NAT device not shown in thereby enabling communication between the various mobile devices over the public network. However if two mobile devices are on the same local or private network e.g. the same Wi Fi network then the two devices may communicate directly over that local private network bypassing the public network. It should be noted of course that the underlying principles of the invention are not limited to any particular set of network types or network topologies.

Each of the mobile devices illustrated in can communicate with a connection data exchange CDX service a matchmaker service and an invitation service . In one embodiment the services can be implemented as software executed across one or more physical computing devices such as servers. As shown in in one embodiment the services may be implemented within the context of a larger data service managed by the same entity e.g. the same data service provider and accessible by each of the mobile devices over the network . The data service can include a local area network e.g. an Ethernet based LAN connecting various types of servers and databases. The data service may also include one or more storage area networks SANs for storing data. In one embodiment the databases store and manage data related to each of the mobile devices and the users of those devices e.g. user account data device account data user application data . . . etc. .

In one embodiment matchmaker service can match two or more mobile devices for a collaborative P2P session based on a specified set of conditions. For example users of two or more of the mobile devices may be interested in playing a particular multi player game. In such a case the matchmaker service may identify a group of mobile devices to participate in the game based on variables such as each user s level of expertise the age of each of the users the timing of the match requests the particular game for which a match is requested and various game specific variables. By way of example and not limitation the matchmaker service may attempt to match users with similar levels of expertise at playing a particular game. Additionally adults may be matched with other adults and children may be matched with other children. Moreover the matchmaker service may prioritize user requests based on the order in which those requests are received. The underlying principles of the invention are not limited to any particular set of matching criteria or any particular type of P2P application.

As described in detail below in response to a match request the matchmaker service can coordinate with the CDX service to ensure that all matched participants receive the necessary connection data for establishing P2P sessions in an efficient and secure manner.

In one embodiment the invitation service also identifies mobile devices for participation in collaborative P2P sessions. However in the case of the invitation service at least one of the participants is specifically identified by another participant. For example the user of mobile device A may specifically request a collaborative session with the user of mobile device B e.g. identifying mobile device B with a user ID or phone number . As with the matchmaker service in response to an invitation request the invitation service can identify the set of participants and coordinate with the CDX service to ensure that all participants receive the necessary connection data for establishing P2P sessions in an efficient and secure manner.

As mentioned above in one embodiment the CDX service operates as a central exchange point for connection data required to establish P2P sessions between two or more mobile devices. Specifically one embodiment of the CDX service generates NAT traversal data sometimes referred to as Hole Punch data in response to mobile device requests to enable external services and clients to communicate through the NAT of each mobile device i.e. to punch a hole through the NAT to reach the device . For example in one embodiment the CDX service detects the external IP address and port needed to communicate with the mobile device and provides this information to the mobile device. In one embodiment the CDX service also receives and processes lists of mobile devices generated by the matchmaker service and invitation service and efficiently and securely distributes connection data to each of the mobile devices included on the lists as described in detail below .

In one embodiment communication between the mobile devices and the CDX service is established using a relatively lightweight network protocol such as User Datagram Protocol UDP sockets. As is known by those of skill in the art UDP socket connections do not require hand shaking dialogues for guaranteeing packet reliability ordering or data integrity and therefore do not consume as much packet processing overhead as TCP socket connections. Consequently UDP s lightweight stateless nature is useful for servers that answer small queries from a vast number of clients. Moreover unlike TCP UDP is compatible with packet broadcasting in which packets are sent to all devices on a local network and multicasting in which packets are sent to a subset of devices on the local network . As described below even though UDP may be used security can be maintained on the CDX service by encrypting NAT traversal data using session keys.

In contrast to the low overhead lightweight network protocol used by the CDX service in one embodiment communication between the mobile devices and the matchmaker service and or invitation service is established with an inherently secure network protocol such as Hypertext Transfer Protocol Secure HTTPS which relies on Secure Sockets Layer SSL or Transport Layer Security TLS connections. Details associated with these protocols are well known by those of skill in the art.

Connection Data This is the information which potential peers need to exchange with each other to establish a Peer To Peer Session. Described below are embodiments of a mechanism for how this information can be exchanged.

CDX Server A CDX Server in one embodiment is an authenticated multicast reflector which allows authorized entities to exchange arbitrary data. This data is referred to as the Payload.

CDX Session A CDX Session refers to a group of client devices which can communicate with each other via the CDX Server. Each client device which is a part of the session is assigned a CDX Ticket. Each session has a unique CDX Session ID which is a large integer which can be used to identify or refer to an individual session.

CDX Request A request that is sent from a client device to the CDX Server. A request generally consists of two parts a CDX Ticket and the Payload. In this embodiment the payload is Connection Data encrypted with the Session Key.

CDX Response A CDX Response is what is reflected back to the other devices in a CDX Session when the CDX Server receives a CDX Request from a member of the CDX Session. It is constructed by appending the Payload to the CDX Ticket Stub of the CDX Ticket used in the given CDX Request.

CDX Ticket A CDX Ticket tells the CDX Server how to send a Payload to the members of the CDX Session. In one embodiment it is signed with the CDX Ticket Key to prevent forgery or tampering. As illustrated in in one embodiment a CDX Ticket contains the following information 

The index of which participant in the session that this ticket refers to not encrypted or obfuscated in one embodiment .

An expiration time date after which the ticket is considered invalid not encrypted or obfuscated in one embodiment .

The CDX Hole Punch Data for each participant in the session encrypted using the CDX Ticket Key in one embodiment.

A Message Authentication Code using the CDX Ticket Key which acts as a Digital Signature to ensure that the ticket is authentic.

CDX Ticket Stub The first part of a CDX Ticket minus the CDX Hole Punch Data and the Message Authentication Code.

Payload This is the second part of a CDX Request and a CDX Response. The payload is the data that a client device wishes to communicate to other devices in the CDX Session. In this embodiment the payload is the Connection Data encrypted with the Session Key. The CDX Server does not decrypt the payload in one embodiment it simply passes it along unchanged.

Session Key This is the key used by the clients to encrypt the Connection Data. In one embodiment this key is not known to the CDX server. In this embodiment the Session Key is generated by the matchmaking service and transmitted to the clients along with their individual CDX Tickets.

CDX Ticket Key This is the key used to create and sign CDX Tickets. The CDX Ticket Key is known only by the CDX Server and the service which generates CDX Tickets which as described below could be the matchmaking service and or the invitation service.

CDX Hole Punch Request A special type of CDX Request which is used to obtain the CDX Hole Punch Data from the CDX Server.

CDX Hole Punch Data This is an opaque data blob that describes how the CDX Server can send information to the client which originally requested it. It is obtained by sending a CDX Hole Punch Request to the CDX Server. CDX Hole Punch Data must be collected from each client device in the CDX Session before CDX Tickets can be generated. The CDX Hole Punch data sometimes referred to as NAT traversal data may include the public IP address and port of a requesting device.

Turning now to in one embodiment the mobile device A and mobile device B can be executing a collaborative application such as a multi player game or a collaborative chat session which requires a P2P connection with one or more other computing devices. At mobile device A transmits a CDX Hole Punch Request to the CDX Server . The CDX Server then responds with the CDX Hole Punch Data at . In one embodiment the hole punch data includes the public IP address and port of mobile device A and or any other data needed to punch a hole through mobile device A s NAT e.g. NAT type data defining mobile device A s NAT type . Similar transactions are performed for mobile device B at and respectively.

At and mobile devices A and B then send match requests including the CDX Hole Punch Data to the Matchmaking Service along with any additional matching criteria described below . At this stage mobile devices A and B may begin to construct the Connection Data needed to establish a P2P connection. This may be accomplished for example using a transaction such as a standard Internet Connectivity Establishment ICE transaction e.g. by a NAT traversal service . However the underlying principles of the invention are not limited to any particular mechanism for determining connection data.

In one embodiment once the matchmaking service has found a set of client devices with matching criteria it may generate a unique CDX Session ID a unique CDX Ticket for each member of the CDX Session and a unique Session Key. In one embodiment the matchmaking service may encrypt the CDX Hole Punch Data for the CDX ticket using a unique CDX ticket key. At and the Matchmaking service then may then send each of the mobile devices A and B their CDX Ticket and the Session Key.

Mobile device A receives the CDX Ticket and Session Key and encrypts its previously determined Connection Data using the Session Key making a Payload. In one embodiment mobile device A constructs a CDX Request by appending the constructed Payload to the CDX Ticket. At mobile device A sends the CDX Request to the CDX Server . Mobile device B could also performs the same operations and transmit a request to the CDX server at

At the CDX Server receives the CDX Request examines the ticket to ensure that it is valid and authentic e.g. based on the message authentication code . If the CDX Ticket is invalid the request is dropped. In one embodiment the CDX Server then decrypts the CDX Hole Punch Data set that is contained in the CDX Ticket using the CDX ticket key. In one embodiment the CDX ticket key can include an expiration time date which may also be transmitted with the tickets. The CDX service and the matchmaker service can store two or more different CDX ticket keys for encryption decryption a first which is currently active and a second which will become active upon reaching the expiration time date of the first. Upon receiving a ticket the CDX service can read the expiration time date to determine which ticket key to use. When a CDX ticket key has expired both the CDX service and the matchmaker service can each generate a new ticket key which will be the next key to be used after the current ticket key expires . In one embodiment the CDX service and matchmaker service execute the same key generation algorithm to ensure consistency with the two ticket keys. For example techniques such as those used for the well known RSA SecurID authentication mechanism may be used in which a new authentication code is generated at fixed intervals. In one embodiment a new CDX ticket key is generated on a daily basis. However the underlying principles of the invention are not limited to any particular mechanism for generating CDX ticket keys.

The same operations could be performed as shown at for mobile device B. The CDX Server constructs a CDX Response from the CDX Request and then uses the CDX Hole Punch Data to send the CDX Response to the participants in the CDX Session sending to mobile device B at and to mobile device A at .

Mobile device B receives the CDX Response from the CDX Server. Client Device B examines the CDX Ticket Stub to ensure that the Session ID matches the Session ID of its own CDX Ticket. Mobile device B may then decrypt the Payload using the Session Key yielding the Connection Data from Mobile device A. Mobile device B then uses the Connection Data from Mobile device A to begin the process of establishing the P2P session. In one embodiment these involve standard ICE transactions. However the underlying principles of the invention are not limited to any particular mechanism for establishing P2P communication.

As mentioned above in one embodiment mobile device A and B establish Hypertext Transfer Protocol Secure HTTPS sessions to communicate with the matchmaker service e.g. using HTTPS request response transactions and establish UDP sockets to communicate with the CDX service. The match requests can include the NAT type and the hole punch data e.g. the public IP address and port previously determined for each respective mobile device. In an embodiment which involves a multi player game each match request can identify the player on each mobile device e.g. using a unique player ID code the game that each user wishes to play the number of players to participate in the game and or other game configuration variables associated with the desired game. By way of example and not limitation the game configuration variables associated with a game may include a level of difficulty e.g. easy normal difficult a user s age e.g. under 13 a sub region of the game e.g. level 2 and or a level of player expertise e.g. expert beginner intermediate . As described in detail below these variables are sometimes referred to as a game bucket and are identified using a unique bucket ID. Each game may include different sets of bucket IDs to identify different game configuration variables.

In one embodiment mobile device B sends and acknowledgement at and . Similarly mobile device A s acknowledgement is transmitted at and . If mobile device A s or B s acknowledgements are not received after a specified period of time then the connection data may be resent to mobile device B . Either the CDX service may initiate the retry and or mobile device A may initiate the retry.

Turning now to the specific details of at mobile device A transmits a NAT type request to the NAT traversal service . In response the NAT traversal service may use various known techniques including implementing a series of transactions to determine the NAT type used by mobile device A. For example the NAT traversal service may attempt to open different IP addresses and ports on mobile device A s NAT and communicate with mobile device A through those ports using different IP port combinations. In this manner the NAT employed by mobile device A may be classified as one of the NAT types described above e.g. full cone restricted cone port restricted cone symmetric or an alternative NAT type. This information may then be provided to mobile device A as illustrated.

At mobile device A initiates a NAT traversal request with the CDX service . In response the CDX service can read the public IP address and public port number used for the request and transmits this information back to mobile device A . As described above if a device is behind a NAT its public port and IP address will be different from its private port and IP address respectively. Thus depending on the type of NAT being used the public IP address and port may be used to punch a hole through the NAT device to reach the mobile device.

At mobile device A transmits a match request to the matchmaker service . As described above in one embodiment mobile device A communicates to the matchmaker service using Hypertext Transfer Protocol Secure HTTPS sessions e.g. using HTTPS request response transactions . The match request can include the NAT type and the hole punch data e.g. the public IP address and port previously determined for mobile device A . In an embodiment which involves a multi player game the match request can identify the player on mobile device A e.g. using a unique player ID code the game that the user wishes to play the number of players to participate in the game and or other game configuration variables associated with the desired game as previously described with respect to .

At a set of transactions corresponding to transactions are performed for mobile device B and at a set of transactions corresponding to transactions are performed for mobile device C . Thus following transaction the matchmaker service has received match requests for all three of the mobile devices . In this specific example the match requests result in mobile devices being matched for a particular collaborative session such as a multi player game e.g. the users of these mobile devices may have selected the same game with the same or similar sets of variables thereby resulting in a match by the matchmaker service .

The matchmaker service uses the data contained in each of the match requests to generate Ticket A which it transmits to mobile device A at Ticket B which it transmits to mobile device B at and Ticket C which it transmits to mobile device C at . Although not shown in the matchmaker service may utilize a push notification service to push Tickets A B and C to mobile devices A B and C respectively e.g. such as the push notification service illustrated . One embodiment of the ticket data structure used for tickets A B and C is described above with respect to .

At mobile device A communicates with NAT traversal service to determine its own connection data. In one embodiment this can include a standard ICE connection data transaction. As previously mentioned the connection data may include public private IP address port and NAT type for mobile device A .

Mobile device A appends its connection data to Ticket A and at transmits Ticket A with the connection data to the CDX service . In one embodiment the CDX service processes Ticket A as described above and at transmits the connection data which may be encrypted to mobile device B and mobile device C . For these transactions the CDX service can utilize the NAT traversal data for mobile devices B and C included with Ticket A.

At a set of transactions corresponding to transactions are performed using Ticket B and at a set of transactions corresponding to transactions are performed for Ticket C. Thus following transaction connection data has been shared between each of the mobile devices . Using the connection data P2P sessions are established between mobile devices A and B mobile devices A and C and mobile devices A and C.

As illustrated in an invitation service can also be used with the CDX service either in lieu of or in addition to the matchmaker service . In one embodiment the invitation service processes invitation requests for P2P connections with specific mobile devices and or users. The invitation service can be implemented as a stateless service i.e. a service which does not tack the current state of transactions between each of the wireless devices .

Turning to this particular example at mobile device A transmits a NAT type request to the NAT traversal service . In response the NAT traversal service may use various known techniques for determining the NAT type used by mobile device A some of which are described above . At mobile device A initiates a NAT traversal request with the CDX service . In response the CDX service can read the public IP address and public port number used for the request and transmits this information back to mobile device A . As described above if a device is behind a NAT its public port and IP address will be different from its private port and IP address respectively. Thus depending on the type of NAT being used the public IP address and port may be used to punch a hole through the NAT device to reach the mobile device.

As with the matchmaker service in one embodiment each of the mobile devices communicate with the invitation service using Hypertext Transfer Protocol Secure HTTPS sessions e.g. using HTTPS request response transactions .

At mobile device A transmits an invitation request to the invitation service which includes mobile device A s NAT traversal data e.g. NAT type public IP address port . In an embodiment which utilizes a push notification service described in greater detail below the invitation request may also include mobile device A s push token. The invitation request can also include an identification code identifying one or more other users devices in this case the users of mobile devices B and C . Various different identification code types may be used. For example in the case of a multi player game the identification codes may comprise game specific player ID codes. In the case of an audio video chat session the identification codes may comprise phone numbers or unique ID codes identifying one or more users from the user of mobile device A s buddy list.

In one embodiment the invitation service reads the identification codes from the invitation request and performs a lookup in a registration database not shown to locate each of the mobile devices B and C. In one particular embodiment each of the mobile devices B and C has previously registered with a push service to receive push notifications from the invitation service . As such in this embodiment the invitation service uses the push notification service to push the invitation requests to mobile device B and mobile device C at and respectively. Additional details related to a push notification service are described below see e.g. and associated text and in the Push Notification Application referenced above.

In one embodiment the invitation requests and include the ticket data structure illustrated in and described above with respect to . Specifically the ticket sent to mobile device B includes an encrypted list identifying mobile devices A and B and the ticket sent to mobile device C includes an encrypted list identifying mobile devices A and C. In one embodiment because the invitation service may not yet have mobile device B s NAT traversal data the ticket at may include other information identifying mobile device B. For example as set forth below with respect to embodiments which utilize the relay service and push notification service see e.g. the ticket at may include the NAT traversal data for mobile device A device A s ID code device A s push token device B s ID code and the push token for mobile device B. The same types of information may be provided at for mobile devices A and C.

At mobile device B may communicate with NAT traversal service to determine its NAT type and at mobile device B may communicate with the CDX service to determine its NAT traversal data e.g. public IP address port . At mobile device B transmits an invitation response to the invitation service containing mobile device A s and mobile device B s identification code NAT traversal data and if the push notification service is used push tokens for mobile devices A and B. At mobile device B can retrieve its current connection data by communicating with NAT traversal service . At mobile device B transmits its ticket Ticket B with its current connection data to the CDX service . In response the CDX service processes the ticket as described above and forwards the connection data to mobile device A .

Upon receipt of mobile device B s invitation response the invitation service can generate an encrypted ticket for mobile device A and transmit the ticket to mobile device A at . In one embodiment the ticket includes NAT traversal data NAT type and push token if the push notification service is used for mobile devices A and B. The tickets described with respect to may be the same or different from the data structures for tickets described with respect to the matchmaker service . For example rather than generating an encrypted ticket as described above the invitation service may simply generate a unique session ID to identify the invitation session with each of the mobile devices.

At mobile device A retrieves its current connection data by communicating with NAT traversal service . Mobile device A may then append its connection data to the ticket and at transmit the ticket with its connection data to the CDX service . The CDX service processes the ticket as described above and forwards mobile device A s connection data to mobile device B. Finally at mobile devices A and B use the exchanged connection data to open a direct P2P connection. As described below in cases where mobile device A s and B s NAT types are incompatible a relay service may be used to enable communication between mobile devices A and B.

At mobile device C and mobile device A can execute a series of transactions to establish a P2P connection as described at for mobile devices B and A. Specifically at mobile device C communicates with NAT traversal service to determine its NAT type and at communicates with the CDX service to determine its NAT traversal data e.g. public IP address port . At mobile device C transmits an invitation response containing mobile device C s and mobile device A s NAT type NAT traversal data and push token if the push notification service is used . At mobile device C retrieves its current connection data through the NAT traversal P2P service and at mobile device C appends its connection data to Ticket C and transmits Ticket C to the CDX service . The CDX service processes the ticket as described above and forwards mobile device C s connection data to mobile device A .

At mobile device A receives mobile device C s invitation response from the invitation service which includes both mobile device A s and C s NAT type NAT traversal data and push tokens if the push service is used . At mobile device A retrieves its current connection data from the NAT traversal service appends its current connection data to Ticket A and at transmits Ticket A to the CDX service . Alternatively transaction may not be required because mobile device determined its connection data at transaction . The CDX service processes Ticket A as described above and forwards mobile device A s connection data to mobile device C. Finally at mobile device A and C use the exchanged connection data to establish a direct P2P connection .

In one embodiment the invitation service and the matchmaker service can rely on a push notification service not shown for pushing data to mobile devices. For example in invitation requests and may be pushed to the mobile devices B and C via the push notification service. Similarly in tickets A and B may be pushed to mobile devices A and B . In one embodiment when a mobile device is activated on the network it registers its push token in a central registration directory accessible by the push notification service. In one embodiment the registration directory associates a password protected user ID or a telephone number with a push token. If the push token can be identified in the directory the push notification service can use the push token to transmit push notifications to the mobile device. In one embodiment the push notification service is the Apple Push Notification Service APNS designed by the assignee of the present application and described for example in the Push Notification Application referenced above. It should be noted however that a push notification service is not required by the embodiments of the invention shown in . For example push notifications are not required for the CDX service to perform its operations as described herein.

Turning now to the method shown in at a NAT traversal request also sometimes referred to as a hole punch request is received for a particular mobile device mobile device A in the example. At a NAT traversal response is generated and transmitted to mobile device A. In one embodiment generating the NAT traversal response can include determining the current public IP address port and or NAT type of mobile device A.

A ticket for mobile device A may subsequently be generated and encrypted by a ticket generation entity such as the matchmaker service or invitation service described above. At the ticket generated for mobile device A Ticket A is received which includes NAT traversal data for device A and one or more other devices and connection data for device A. At the ticket is authenticated using the message authentication code and the hole punch data is decrypted using the same CDX ticket key as that used by the ticket generation entity to encrypt the ticket. As mentioned above in one embodiment the correct CDX ticket key is identified using an expiration time date associated with the CDX ticket key.

At the NAT traversal data for the mobile devices is extracted. At the connection data for mobile device A is transmitted to each of the peers using the NAT traversal data. At acknowledgements are received from each of the peers. If acknowledgements have not been received from all of the peers determined at then mobile device A s connection data is retransmitted to those peers which have not responded at . When all of the connection data has been acknowledged determined at the method terminates.

In one embodiment the method shown in can be performed for each of the peers involved in the P2P transaction to ensure that each peer receives the connection data required to establish a P2P connection.

At the ticket may be received at connection data for the mobile device is appended to the ticket and at the ticket with the connection data is transmitted. At connection data needed to establish P2P connections with one or more other peers is received. At acknowledgements indicating that one or more other wireless devices have received the connection data transmitted at are received. If all acknowledgements are not received then at the connection data is retransmitted to those mobile devices from which acknowledgements have not been received. If all acknowledgements are received determined at then the connection data received at is used to establish P2P sessions with the other mobile devices.

Current mobile devices are capable of communicating over a variety of different communication channels. For example the Apple iPhone is capable of communicating over Wi Fi networks e.g. 802.11b g n networks 3G networks e.g. Universal Mobile Telecommunications System UMTS networks High Speed Uplink Packet Access HSUPA networks etc and Bluetooth networks known as personal area networks PANs . Future mobile devices will be capable of communicating over additional communication channels such as WiMAX International Mobile Telecommunication IMT Advanced and Long Term Evolution LTE Advanced to name a few.

In operation current mobile devices select one primary communication channel from among a set of available channels. For example mobile devices are often configured to choose a Wi Fi connection if one is available and to choose a cellular data connection e.g. a UTMS connection if Wi Fi is not available.

In one embodiment of the invention a group of mobile devices initially establish primary peer to peer P2P communication channels using standard ICE connection data exchanges and or using the connection data exchange techniques described above. The mobile devices may then exchange connection data over the primary channels to establish one or more secondary communication channels which are used as backup channels if any of the primary channels fail. In one embodiment the secondary communication channels are maintained open through NAT firewalls by periodically transmitting heartbeat packets over these channels.

As used herein a communication channel refers to the full network path between two mobile devices and a communication link refers to one particular connection used in the communication path. For example if device A is connected to the Internet using a Wi Fi connection and device B is connected to the Internet using a 3G connection then the channel between device A and device B is defined by both the Wi Fi link and the 3G link device A has a Wi Fi communication link and device B has a 3 G communication link. As such if device A switches from a Wi Fi link to a 3G link then the channel between device A and device B is changed notwithstanding the fact that device B s 3G link remains the same.

Specific examples in which mobile devices establish primary and secondary communication channels will now be described with respect to . It should be noted however that the underlying principles of the invention are not limited to the particular set of communication links and communication channels shown in .

In mobile device A is capable of connecting to a network e.g. the Internet over communication link with NAT device and over communication link with NAT device . Similarly device C is capable of connecting to the network over communication link with NAT device and over communication link with NAT device . By way of example and not limitation communication links and may be 3 G communication links and communication links and may be Wi Fi communication links.

Consequently in this example there are four different communication channels which may be established between mobile device A and mobile device B a first channel which uses links and a second channel which uses links and a third channel which uses links and and a third channel which uses links and . In one embodiment mobile devices A and B will select one of these channels as the primary communication channel based on a prioritization scheme and will select the three remaining channels as backup communication channels. For example one prioritization scheme may be to select the channel with the highest bandwidth as the primary channel and to use the remaining channels as the secondary channels. If two or more channels have comparable bandwidth the prioritization scheme may include selecting the least expensive channel assuming that the user pays a fee to use one or more of the channels . Alternatively the prioritization scheme may be to select the least expensive channel as the primary channel and if the cost of each channel is the same to select the highest bandwidth channel. Various different prioritization schemes may be implemented while still complying with the underlying principles of the invention.

Mobile devices A and C may utilize the techniques described above to establish the primary communication channel e.g. by exchanging connection data via the CDX service . Alternatively the mobile devices may implement standard Internet Connectivity Establishment ICE transactions to exchange the connection data. Regardless of how the primary channel is established once it is the mobile devices A and C may exchange connection data for the secondary communication channels over the primary communication channel. For example if the primary communication channel in includes communication link and communication link then this connection once established may be used to exchange connection data for secondary communication channels which include communication links and . In this example the connection data exchanged over the primary communication channel may include NAT traversal data and NAT type data for NAT and NAT including public and private IP addresses ports for each of the mobile devices.

Once the secondary communication channels have been established they are maintained open using heartbeat packets. For example device A may periodically transmit a small heartbeat packet to device C and or device A may periodically transmit a small heartbeat packet to device C to ensure that the NAT ports used for the secondary channels remain open NATs will often close ports due to inactivity . The heartbeat packets may be UDP packets with no payload although the underlying principles of the invention are not limited to any particular packet format. The heartbeat packets may be UDP packets with a self identifying type field in their payload header and may contain optional additionally formatted information including but not limited to a channel time to live value.

As illustrated in each mobile device stores and maintains a data structure e.g. a table text file database etc containing a list of primary and secondary communication channels. A separate entry is provided for each communication channel and includes the connection data needed to utilize that channel e.g. private public IP address NAT type etc and the current status of that channel e.g. primary secondary secondary etc .

In one embodiment communication interfaces and are used for communicating over communication link and communication link respectively. A failure detection module can be executed on the mobile device to detect when a particular communication interface link has failed or has degraded below a specified threshold. In response a link management module can read the primary secondary connection data to promote a secondary channel having the next highest priority to the primary channel. The prioritization of the secondary channels may be accomplished using the same principles as those discussed above for the primary channels e.g. based on bandwidth cost reliability etc . Once a secondary channel has been selected the link management module can transmit a link failure indication to link management modules on the other mobile devices instructing those devices to promote the secondary communication channel to a primary communication channel. Those devices will then begin using the connection data associated with the selected primary channel.

In one embodiment a complete failure of the primary communication channel is not required to force a switch to one of the secondary communication channels. For example in one embodiment if the primary communication channel is sufficiently degraded e.g. below a particular bandwidth bitrate or reliability threshold then a change to a secondary channel may be implemented as described herein. In one embodiment the switch to the secondary channel is only performed if the secondary channel is capable of supporting better performance e.g. bandwidth bitrate or reliability than the current primary channel.

One embodiment of a method for establishing and maintaining secondary channels is illustrated in . In one embodiment the method may be executed by the link management module on each mobile device. However the method is not limited to any particular device configuration.

At a primary P2P communication channel is selected. As mentioned above the primary channel may be selected based on a predefined prioritization scheme. For example certain communication channel types may be prioritized ahead of other communication channel types. Channels may also be prioritized based on variables such as bandwidth cost for usage and or reliability.

At backup P2P communication channels are established. In one embodiment this is accomplished by sharing connection data between all of the mobile devices over the primary communication channel. At the backup channels are maintained. In one embodiment this involves transmitting data periodically over the secondary communication channels e.g. in the form of periodic heartbeat packets .

At if the primary P2P channel fails e.g. because the communication link of a particular mobile device went down or the mobile device moved out of range of the communication link then at the mobile devices promote the highest priority backup channel to the primary channel. In one embodiment this involves the mobile device with the failed link transmitting a notification of its link failure to the other devices over the secondary channel. Finally at the backup channel is made the primary channel and the process reverts to in which any additional backup channels are discovered and added to the prioritization scheme .

As illustrated in in addition to the CDX service matchmaker service and invitation service some embodiments of which are described above one embodiment of the invention can include a registration directory service a push notification service and a relay service . As mentioned above in one embodiment the invitation service and or the matchmaker service can use the registration directory service to identify registered mobile devices and the push notification service to push data to the mobile devices. In one embodiment when a mobile device is activated on the network it registers a push token sometimes referred to as a notification service account identifier in the Push Notification Application with a database maintained by the registration directory service by associating the push token with a password protected user ID or a telephone number. If the push token is identified in the registration directory e.g. by performing a query with the user ID the push notification service can use the push token to transmit push notifications to a mobile device. In one embodiment the push notification service is the Apple Push Notification Service APNS designed by the assignee of the present application and described for example in the Push Notification Application referenced above.

Turning now to at mobile device A transmits an invitation to invite mobile device B to invite mobile device B to a P2P communication session e.g. a collaborative video game a P2P video chat etc . In one embodiment the invitation includes a User ID code identifying mobile device B and or the user of mobile device B within the context of a particular online application. For example the user ID code may be a player ID for a particular multi player P2P game and may take the form for example of a Universally Unique Identifier UUID . Alternatively in some embodiments the ID code may be a phone number of mobile device B . A game ID code may be used to identify the multi player game that mobile device A is inviting mobile device B to join. A bucket ID may be used to identify a configuration for that game as described herein with respect to the matchmaker service .

The invitation may also include an ID code identifying mobile device A and NAT traversal connection data associated with mobile device A e.g. the public private IP addresses and ports for mobile device A and the NAT type for device A s NAT device . The NAT traversal connection data or NAT type data may have been previously determined by mobile device A prior to the invitation request e.g. via NAT traversal NAT type and connection data transactions such as those discussed above with respect to . As previously mentioned the invitation request can take the form of an HTTPS request. In addition for additional security the invitation request can include a client certificate signed by a pre specified certificate authority.

Regardless of the particular type of ID code used to identify mobile device B the ID code is received by the invitation service and at the invitation service can perform a lookup in the directory service not shown in to identify a notification service account identifier such as a push token used for pushing notifications to mobile device B push token B . In one embodiment the lookup operations can perform several checks to determine whether the invitation should be allowed. First it can confirm that the identification code for mobile device A ID A and device A s push token push token A are a registered association within the directory service database. The lookup operation can also confirm that that the user of mobile device A is permitted to invite the user of mobile device B e.g. the user of mobile device B can specify that only those other users registered as B s friends can invite user B or can specify that no invitations are permitted . In one embodiment if any of these checks fail the invitation is canceled and the invitation service returns an error to mobile device A.

While a push token is described in this embodiment it should be noted that the underlying principles of the invention are not limited to the use of a push token or any other particular data structure for authenticating and pushing notifications to mobile devices.

In one embodiment after the push token has been identified the invitation service can generate a secure one time session token assigned to the invitation session and used to identify the session in all further transactions. A copy of the session token is then transmitted back to the mobile device A and sent to mobile device B with the invitation request. In one embodiment the session token is used together with the ticket data structure described above and in another embodiment only the session token is used.

At the invitation service transmits a push request to the push notification service . In one embodiment the push request can include the NAT traversal data for mobile device A device A s ID code push token A device B s ID code and push token B. In one embodiment this information may be packaged within a ticket data structure and encrypted as described above. In another embodiment the data is simply transmitted with the invitation session ID.

Because mobile device B in this example has registered with the push notification service the push notification service is capable of locating and pushing the invitation request to mobile device B at . The pushed invitation may include the session token mobile device A s NAT traversal data connection data and mobile device B s ID code. In response to the invitation request mobile device B may determine its networking information e.g. NAT traversal connection data NAT type etc by making a call to a NAT traversal service or the CDX service as described above.

At mobile device B accepts the invitation. The accept may take the form of an HTTPS call to the invitation service and may include a client certificate signed by the pre specified certificate authority mentioned above with respect to the invitation request . In one embodiment the accept can include the ID code for mobile devices A and B and the NAT traversal connection data and or NAT type for mobile devices A and B. The accept may also include the push tokens for mobile devices A and B and or the session token. In one embodiment the accept may also contain an indication as to whether it is a retry from a previous failed direct connection attempt. However in another embodiment the accept does not contain the retry indication. Rather upon detecting a failed P2P connection attempt one of the two mobile devices may transmit a special relay invitation to the invitation service . In response the service may directly initiate the series of relay transactions described below with respect to starting at .

At the invitation service can perform a compatibility check to determine whether a direct P2P connection between mobile devices A and B is feasible. For example in one embodiment if the accept received from mobile device B indicates that it is a retry from a previous failed direct connection attempt or a specified number of previous failed direct connection attempts then the invitation service may conclude that a direct P2P connection is infeasible. The invitation service may compare the NAT type data for mobile devices A and B to determine if the NAT devices of mobile devices A and B will support a direct P2P connection. Certain combinations of NAT types are known to be incompatible for establishing P2P connections. For example a full cone NAT may be used with any other NAT type except a closed firewalled NAT to establish a direct P2P connection. By contrast a symmetric NAT can only be used with a full cone NAT to establish a direct P2P connection. The feasibility of combining various NAT types in one embodiment of the invention is set forth in the NAT compatibility table shown in in which columns represent NAT types of one mobile device e.g. mobile device A and rows represent NAT types of the other mobile device e.g. mobile device B . A 1.0 in a cell indicates that the NAT types in the associated row and column are compatible and a 0.0 indicates that the NAT types are incompatible.

In one embodiment if the compatibility check determines that a direct P2P connection is infeasible then the invitation service can transmit a relay lookup request as described below with respect to . If however the compatibility check determines that a direct P2P connection is feasible then the invitation service can transmit a push request to the push notification service containing mobile device B s acceptance of mobile device A s invitation. The push request and subsequent push communication to mobile device A from the push notification service can include the session token and both mobile device A s and B s push token ID code and or NAT traversal connection data. In one embodiment this information may be packed within the ticket data structure described above see e.g. and associated text and may be encrypted using a unique key. Alternatively this information may simply be transmitted with a unique invitation session ID. The invitation service may also notify mobile device B that a direct connection will be attempted.

At this stage mobile devices A and B have sufficient information to establish a direct P2P connection. In one embodiment this is accomplished using the CDX service as described above. For example mobile device B appends its connection data to Ticket B and at transmits Ticket B with connection data to the CDX service. Just prior to this transaction mobile device B may implement a transaction such as transaction shown in in order to ensure that its connection data is current. The CDX service then authenticates the ticket e.g. using the unique session key as described above extracts mobile device B s connection data and forwards the connection data to mobile device A at . Similarly mobile device A appends its connection data to Ticket A and at transmits Ticket A with connection data to the CDX service . Just prior to this transaction mobile device A may implement a transaction such as transaction shown in in order to ensure that its connection data is current. The CDX service then authenticates the ticket e.g. using the unique session key as described above extracts mobile device A s connection data and forwards the connection data to mobile device B at . Finally at mobile devices A and B enter into a direct P2P connection using the exchanged connection data.

Turning now to if the compatibility check determines that a direct P2P connection is infeasible then the invitation service can transmit a relay lookup request to the relay service to determine a relay host to be used by each mobile device. The request may contain the networking information for mobile devices A and B e.g. NAT traversal connection data and or NAT type data which is used by the relay service to select appropriate relay hosts for both of the mobile devices. As illustrated in one embodiment of the relay service includes a plurality of relay hosts and a relay host database containing network information related to each of the relay hosts. The invitation service transmits a relay lookup request to a relay lookup service which queries the relay host database using the network information for mobile devices A and B. Upon receiving the database results the relay lookup service provides a response identifying the selected relay hosts .

In one embodiment the relay lookup response contains a relay token generated by the relay service and the network addresses IP addresses ports of the relay hosts to be used by mobile devices A and B for the relay connection. In one embodiment the relay token is associated with the relay session and is used by the relay hosts to authenticate mobile devices A and B upon connecting to the relay service . The token may take on various forms including for example unique ID relay session ID code a digital certificate and or a unique encryption key associated with the relay session.

At the invitation service transmits a relay response to mobile device B containing an indication that a relay connection will be made. In one embodiment the relay response can include the relay token and the network information for relay host B . In one embodiment response can be sent directly to mobile device B bypassing the push notification service because it is being sent in response to mobile device B s accept .

The invitation service transmits relay response to mobile device A which can include the relay token and the network information for relay host B . In this instance the response is pushed to mobile device A via the push notification service at transaction .

At mobile device A uses the network information for relay host A to establish a connection with the relay service . Similarly at mobile device B uses the network information for relay host B to establish a connection with the relay service . In each of these transactions new holes are opened in any NAT firewalls of mobile devices A and B and the NAT traversal connection data for mobile devices A and B may be determined by the relay service and returned to mobile devices A and B respectively e.g. by determining the public IP port for the devices . In one embodiment the relay service and mobile devices A and B implement the Traversal Using Relay NAT TURN protocol which as understood by those of skill in the art allows an element behind a NAT or firewall to receive incoming data over TCP or UDP connections.

At mobile device A transmits a relay update to the invitation service which is forwarded to the push notification service at and pushed to mobile device B at . Similarly at mobile device B transmits a relay update to the invitation service which is forwarded to the push notification service at and pushed to mobile device A at . The relay update transmitted by mobile device A can include the session token each device s ID code and the NAT traversal connection data determined by the relay at and i.e. with mobile device A sending its NAT traversal connection data to mobile device B and vice versa . In one embodiment the relay update operations are performed because each mobile device s NAT information may change.

Finally at and mobile devices A and B respectively establish a P2P connection through the relay service . In one embodiment the relay connections can be established when mobile device A sends the NAT traversal connection data of mobile device B to the relay service and vice versa thereby allowing the relay service to determine the correct path to each peer s relay host .

Using the techniques described above the invitation service may be implemented as a stateless service which is inherently scalable and resilient even in a large scale system with a vast number of mobile devices. For example because the push notification service is inherently capable of locating and pushing content to registered mobile devices the invitation service is not required to track the current location of each device. Additionally because devices may transmit the entire session state data with each request and response the invitation service is never required to maintain any per connection state information thereby reducing the storage and processing requirements of the invitation service. Such an implementation is particularly useful in a large scale system.

As illustrated in one embodiment of a matchmaker service can include a matchmaker dispatcher for receiving match requests and pushing match responses to mobile devices a database for storing match requests in a request table and for storing matchable set data in a matchable set identifier MSI table and one or more matchmakers for fetching match requests from the database performing matching operations and storing the match results back in the database . It should be noted however that the underlying principles of the invention are not limited to the specific architecture shown in .

In one embodiment the matchmaker dispatcher acts as an interface to the matchmaker service receiving requests from mobile devices translating those requests into commands to store the requests in the database reading match results from the database and translating and communicating those results to the mobile devices .

In operation when a new match request arrives the matchmaker dispatcher can store the request within a row of the request table . In one embodiment the dispatcher assigns each match request a request ID RID code illustrated simply as A B and C in corresponding to mobile devices A B and C respectively . While shown using a letter designation in for simplicity the RID code may be a string integer or any other variable type suitable for tracking match requests within the database.

Each match request may be assigned a matchable set identifier MSI value which is stored in the request table . In one embodiment the MSI can identify the specific application for which a match is being requested and or the configuration parameters to be used for that application. For example an MSI value of 12 4 may identify a particular multi player game with the identifier 12 and may identify a particular configuration for the game with the identifier 4. More specifically the ID code of 12 may identify a particular multi player racing game and the ID code of 4 may specify a particular racing track speed or player experience level for the racing game. In one embodiment application developers are provided the option to specify any application configuration parameters using MSI values in this manner. In one embodiment rather than specifying an MSI directly application developers specify a game ID to identify a particular game and a bucket ID to identify a particular game configuration and these values are mapped to an MSI value by the matchmaker dispatcher .

Additionally several different MSI values may be used within a single MSI to specify multiple different configuration parameters e.g. 12 4 1 might represent 12 racing game 4 track and 1 experience level . As described in detail below in one embodiment each MSI is used by a matchmaker to identify a set of match requests in which matchmaking operations can be performed e.g. requests are grouped based on MSI and matches are performed within each MSI group . In one embodiment each MSI may be dynamically modified selected by the dispatcher to include a partition ID identifying different machine partitions. For example if a particular MSI becomes overloaded the dispatcher may split the MSI between two or more different servers and or storage partitions e.g. using designations such as 4 3 1 and 4 3 2 where the last digits identify partitions and respectively . A different matchmaker may then independently retrieve and process requests from each of the different MSIs from each of the different servers.

As illustrated in match request data may also be stored within the request table for each request. The request data may include any data usable for rendering a matchmaking decision and or any data needed to access the mobile device initiating the request over the network. For example in one embodiment the match request data for each request includes the NAT type data and or NAT traversal connection data for the mobile device initiating the request. Other types of request data may also be stored within the request table such as device connection speed 100 kbps 1 Mbps etc connection type e.g. 3G EDGE WiFi etc device location e.g. determined by geo location techniques language English Spanish etc and or user preferences. The request data may be determined by each mobile device and transmitted to the matchmaking dispatcher with each match request. For example each mobile device may determine its connection data connection type device location etc using various techniques some of which are described herein e.g. communicating with a NAT traversal server to determine NAT traversal connection data using GPS to determine device location reading HTTP information to determine language etc .

As illustrated in in one embodiment each active MSI can be assigned a row in the MSI table . In one embodiment when a new request arrives in addition to adding the request to the request table the dispatcher also checks the MSI table to determine whether an MSI already exists for that request i.e. whether other requests having the same MSI have already been received . If no matching MSI is found then the dispatcher may create a new entry in the MSI table for the new request. If a matching MSI is found then the dispatcher can simply add the new request to the request table as described above.

Once the request table and MSI table are updated by the matchmaker dispatcher an instance of a matchmaker module hereinafter simply referred to as matchmaker fetches the data to perform matchmaking operations. Multiple matchmaker instances may be concurrently executed to perform matchmaking requests and a single matchmaker may concurrently process multiple matchmaking operations on multiple different MSI groups.

In one embodiment when a matchmaker becomes available e.g. after completing matching operations for an MSI group or after being initialized it queries the MSI table to identify a new MSI to process. In the N A value in the matchmaker ID fields for MSI 3 1 indicate that the responsibility for processing this MSI has not yet been assigned to a matchmaker. In one embodiment each MSI entry is time stamped and the matchmaker selects an MSI having the oldest time stamp.

In one embodiment when a matchmaker assumes responsibility for a particular MSI it updates its matchmaker ID code in the MSI table and specifies a lease duration for that MSI e.g. 5 seconds . In one embodiment the matchmaker continually updates the lease value as it processes matches for that MSI. The lease values may be used to identify MSIs which were assigned to failed matchmakers . For example if the lease value has expired that MSI may be claimed by a new matchmaker notwithstanding the fact that the MSI table indicates that the MSI is already assigned to a matchmaker.

Once the matchmaker has assumed responsibility for an MSI it can query the request table to read requests associated with that MSI into memory. The matchmaker can then perform matching operations to match users and mobile devices according to a set of matching criteria e.g. as described below . The matchmaker can update the request table to indicate when matches of mobile device have been made. For example the matchmaker can remove the MSI values from the MSI column in the request table and enter a predefined value to indicate that the match has been completed. In addition the matchmaker may update the request data field for each participant to identify the other participants with which that participant was matched e.g. by writing the NAT traversal connection data needed to communicate with the other participants .

The dispatcher can periodically query the request table to identify completed matches. In response to detecting a completed match the dispatcher may transmit a push notification to the mobile devices involved in the match e.g. using the push notification techniques described herein and in the co pending applications . In one embodiment the push notification includes the ticket data structure described above. The mobile devices may then use each of their tickets to exchange connection data via the CDX service as described above.

In addition to using push notifications in one embodiment the mobile devices may periodically query the dispatcher to determine if a match has been made. Periodic queries are useful in case the push notification has not made it to the mobile device. However because a push architecture is used the periodic queries may be set to a relatively low rate thereby reducing the load on the matchmaker service .

At a match request is received from mobile device A. At mobile device A s request is entered in the request table and a new MSI entry MSI 1 1 is entered in the MSI table if one does not already exist as illustrated in . At a match request is received from mobile device B and at mobile device B s match request is also entered in the request table as illustrated in

At a particular matchmaker instance matchmaker N checks the MSI table and detects that MSI 1 1 has not been claimed by another matchmaker instance. Alternatively the matchmaker may detect an MSI table entry with an expired lease indicating that the matchmaker previously working on the MSI has failed. In one embodiment MSI entries with expired leases are given higher priority than new MSI entries which have not yet been assigned a matchmaker . In addition in one embodiment relatively older MSI entries may be given higher priority than relatively newer MSI entries. Regardless of how the matchmaker selects the MSI when it does it adds its identifier and sets a new lease value for the MSI entry as illustrated in e.g. using a lease value of 5 seconds in the illustrated example . The matchmaker may then query the request table and read the request table entries with that MSI into memory so that they can be processed.

At the matchmaker performs a series of matching operations to select an appropriate match for each of the requests. Certain embodiments of the matching operations are described below with respect to . Briefly in one embodiment the variables which are evaluated to determine appropriate matches include the NAT type e.g. full cone port restricted symmetric etc the connection type e.g. WiFi 3G Edge etc the language associated with the user derived from the HTTP request accept language header and the age of each of the match requests. In general the matchmaker may attempt to match mobile devices having compatible NAT types although the relay service may sometimes be used as described below the same connection types and the same language. In one embodiment the matchmaker may be more liberal with the matching requirements based on the age of the matching requests i.e. the older the request the more liberally the matching constraints will be applied .

Returning to at following the matching decision the matchmaker may update the request table to indicate that the matching is complete as indicated in . As part of the update the matchmaker may also update the request data for mobile devices A and B. For example in one embodiment the matchmaker writes mobile device B s NAT traversal connection data in the request data column for mobile device A and writes mobile device A s NAT traversal connection data in the request column for mobile device B.

At the dispatcher can read through the request table to identify request entries which have been matched. In one embodiment when it detects that mobile devices A and B have been matched it reads the request data updated by the matchmaker as described above and generates a notification for mobile devices A and B. In one embodiment the notification is the ticket data structure described above which is encrypted and includes the NAT traversal connection data for each mobile device. As previously described in one embodiment the push notification service is used to push the notifications to mobile devices A and B. In addition mobile devices A and B may periodically poll the dispatcher to determine whether a match has been made. In this embodiment the polling technique may be done at a relatively slow rate to identify matches which for some reason were not successfully pushed to one of the mobile devices. Using push notifications to manage polling request load significantly reduces the load on the matchmaker service which would otherwise be loaded with polling requests from mobile devices.

If additional match requests are pending for the same MSI determined at the matchmaker may continue to match mobile devices users within the MSI. At the matchmaker may reset the lease value within the MSI table . At additional matches are performed and the request table is updated as described above . At the additional matches are read from the request table and the additional mobile devices are updated as described above . If no additional match requests are pending for the MSI then at the MSI entry is removed from the MSI table e.g. via a delete command from either the dispatcher and or the matchmaker .

As indicated in Table A below in one embodiment the evaluation of fitness is a numeric value between 0.0 and 1.0. Using a floating point value allows for normalization of the fitness for each criteria. To avoid floating point arithmetic non normalized integer values can be used with suitable evaluation so fitness values can be compared.

In one embodiment all criteria have a binary fit where they are either compatible having a normalized value of 1.0 or not compatible having a normalized value of less than 1.0 . These can be thought of as required criteria where the fit may change with age as described below . If location is added as a variable then the best fit may be one with the closest player that matches the required criteria.

In one embodiment the Fit is equal to the Sum Of Normalized Weight Aged Factor Value for each of the above criteria. The Aged Factor Value may start with a value of 1 and increase after a predetermined period of time has passed. It may then continue to increase as more time passes e.g. periodically increasing by a specified amount . In one embodiment instead of using the Aged Factor Value described above age thresholds may be established as described below. The normalized weighted values of certain variables such as Connection Type and Language may be applied above certain age thresholds even if they do not match .

In one embodiment the fit between a pair of requests A and B is the average of the fit of A with B and B with A. Moreover the fit of A with B for each factor may be adjusted based on A s age and vice versa . In one embodiment a fit of 1.0 may be required for a compatible match. This means A and B will only match if the NAT compatibility Connection Type and Language match resulting in a normalized value of 1.0 or if A and or B have aged so that some of the above variables e.g. the Connection Type and Language are effectively ignored either using the aged factor value above or the thresholds below .

Age thresholds may be established as set forth in Table B above. As each age threshold is passed i.e. as the request becomes older than the specified threshold the aged factor value may be increased to successively larger values e.g. 1.5 2.0 etc . Alternatively or in addition as different age thresholds are passed weighted values for certain variables may be added to the matching decision e.g. such as connection type and language as described below .

In one embodiment the request age limits specified in Table B are adjusted according to the match flow rate for a given MSI. In one embodiment the flow rate is specified as a number of matches being performed per a specified unit of time e.g. every 10 seconds every minute etc . Thus the flow rate provides an indication as to how busy a particular MSI set is. In one embodiment the busier the set the lower each of the above thresholds may be set in Table B above to increase the probability of an early successful match and reduce the load on the matchmaker. Moreover the load for a given MSI set may be provided to the end user e.g. in the form of an estimated time to match value so that the end user can choose whether to attempt to enter a multi player game which is particularly busy. The load value may be provided to the user in the form of a push notification.

Turning now to each of the variables from Table A in one embodiment NAT compatibility is determined from the NAT compatibility chart shown in . If two NATs are determined to be compatible based on this chart then the NAT compatibility weight may be applied.

The connection type may be evaluated using a chart such as that shown above as Table C. In this example if the connection type of devices A and B is the same as indicated by a 1.0 in the cells where the same connection types meet then the weighted connection type value from Table A may be included in the fitness determination. As mentioned above the age of each of the requests may be used to affect the connection type determination. For example in one embodiment the fit value for connection type is selected using the matrix in Table C for ages at threshold and . For ages at threshold or above the connection type may be set to 1.0 even for non matching connection types and the corresponding weighted connection type value may be applied. While connection type is used in some embodiments connection speed may be determined and used with or instead of connection type. For example connection speeds within certain specified ranges may be considered compatible e.g. 0 100 kbps 100 500 kbps 500 1000 kbps 1000 1500 kbps etc . Any of the matching variables discussed herein may also be applied as weights to the match fit calculation and aged as described above.

In one embodiment the player language can be derived from the HTTP request accept language header which may contain one or more languages with a preference qfactor. The dispatcher can extract the most preferred language and pass this information to the matchmaker. In one embodiment the weighted language value from Table A is set to 1.0 if the languages are the same or 0.0 if they are not. However in one embodiment the weighted language value may be applied even if the languages are different if the age is above a specified threshold e.g. if the age is at threshold or above in Table B .

In one embodiment a match may be made between two users with incompatible NAT types. For example if the matchmaker is having difficulty matching users for a particular MSI after a specified period of time it may route connections through the relay service using the techniques described above. In this way the relay service acts as a pressure valve allowing aging matches to occur notwithstanding incompatible NAT types. The relay service may also be used in response to detecting one or more failed match attempts. In this embodiment each match request submitted by a mobile device may include an indication as to whether one or more unsuccessful matches was previously attempted.

Various additional match criteria may be evaluated and provided a weight value as part of the match fit determination including by way of example and not limitation an indication as to whether any of the users requesting matches are friends. For example the matchmaker may attempt to match any requests for users who are friends by applying a friends weight to the match fit calculation. Similarly friends of friends may also be weighted e.g. with 2 or more degrees of separation . Additionally a player may rate other players for a particular game and the matchmaker may evaluate those ratings when performing a match with a tendency to match a user with those players who have relatively higher ratings and not to match a user with players who have low ratings . Moreover the latency of a user s connection may be evaluated e.g. using a simple ping operation and used as part of the matchmaking decision.

Yet another variable used to match players may be device type. For example the matchmaker may attempt to match players with similar device types e.g. iPads iPods iTouches iPhones RIM Blackberries etc . Additional variables may include a user s leaderboard ranking current location current residence age gender and similar game collections may similarly be evaluated for the match determination i.e. in many cases tending to favor matches between those users with similar criteria . Finally parental controls may be evaluated by the matchmaker to ensure that users are only matched with appropriate MSIs and with other users of the same age.

The matchmaker service may retrieve any of the above variables from one or more databases managed within the data service see e.g. database described below with respect to . For example a user s friend data may be accessed from a friends service database and other information such as each user s age gender game collection etc may be accessed from one or more other databases e.g. a user profile a games database a leaderboard database etc . In one embodiment all of the services described herein are provided with access to the same central database or group of databases for storing all of the various different types of user device data used for making matchmaking decisions.

While several specific examples are provided above it will be appreciated that the underlying principles of the invention are not limited to any particular set of variables for determining a fitness level for a match. In one embodiment application programmers designing applications to be run on the system and method described herein may specify their own set of criteria for matching and or for grouping requests using different MSI criteria.

Turning back to the method of once the match fit between each pair has been determined at the pairs are sorted by descending fit e.g. with the pairs having the highest fit at the top of the list . At match sets are seeded with those pairs which have the highest fit values above the specified threshold. As described above the threshold value may be set to the normalized value of 1.0 shown above in Table A. At new prospective partners are added to the match set which have fit values with one or all of the current members in the match set above a specified threshold. For example if a match set has initially been seeded with A and B then C may be added to the match set if the fit value of A C and or B C are above the specified threshold. In one embodiment if only a single match fit is above a threshold for a prospective party then that party may be added to the match set i.e. because if necessary that party will be able to communicate to all of the parties through the one party with which it has a suitable match fit . Once one or more new parties have been added to the match set if the size requirements for the match have been met determined at then the match results are stored and reported at e.g. by updating the request table and transmitting notifications as described above . In one embodiment a single match request may represent multiple users e.g. when a match request follows an invitation sequence as described below . In this case the size requirements are evaluated based on the number of users represented by each match request. If the size requirements have not been met then the process returns to and a new party is added to the match set i.e. a party having a match fit with one or more of the current members of the set above a specified threshold .

At the matched requests are removed from the current set of requests being processed by the matchmaker . At the next seeded match set is selected and the process returns to for additional matching. Although illustrated in as a sequential process it should be noted that multiple seeded match sets may be processed concurrently while still complying with the underlying principles of the invention.

Although described above as separate services the matchmaker service and the invitation service may operate together to connect P2P users. For example in one embodiment a first user may invite one or more friends to an online session and request a match with one or more additional users e.g. INVITE friend Bob and match 3 additional players for a multilayer video game . In such a case the invitation service may initially process the first user s invitation request to connect the first user and the first user s friend s . The results of the invitation request e.g. a successful P2P connection may then be reported back to the user s mobile device. The matchmaking service may then receive a match request from the first user s mobile device or in one embodiment directly from the invitation service or from the first user s friends requesting additional players. In response the matchmaker service may match the first user with one or more other match requests having the same MSI as the first user s request as described above . The match request may include only the first user s matching criteria or may include the first user s and the first user s friend s matching criteria e.g. NAT type connection type language location etc . In one embodiment if one or more of the first user s friends cannot establish a direct P2P connection with another matched user the matched user s connection with the first user s friends may by established through the first user s data processing device e.g. using the first user s mobile device as a proxy for the connection and or the relay service may be used to connect the users as described above .

In one embodiment the first user may initially be matched with one or more users by the matchmaking service as described above and then the first user may invite one or more friends to join the online session with the first user and the matched users. In this embodiment both the user s information and the matched users information e.g. NAT connection data user IDs push tokens etc may be exchanged with the invited users through the invitation service as described above . The underlying principles of the invention remain the same regardless of whether matching occurs first followed by invitation or whether invitation occurs first followed by matching.

As illustrated in one embodiment of the invention is implemented within the context of a mobile device having a predefined software framework with an application programming interface API for interfacing with one or more applications and a service side API for communicating with a plurality of network services . As shown in the network services may be designed and or managed by the same online data service although such a configuration is not required . Applications such as P2P gaming applications and other types of collaborative online applications may be designed to access the network services through the API by making calls to the API . The design of applications may be facilitated using a software development kid SDK provided by the developer of the framework and the network services . A more specific implementation of the framework and APIs is described below with respect to .

As illustrated each of the services may be provided with access to a database for storing data used by the services. One particular example is the database used by the matchmaker service described above . Other examples may include a leaderboard database for storing leaderboard data a friend service database for storing friend state records a profile database for storing user profile data and a games database for storing data related to online games. Any type of database may be used e.g. MySQL Microsoft SQL etc but in one particular embodiment a key value database such as Berkley DB and or MZBasic DB can be used. The databases may be spread across a large number mass storage devices e.g. hard drives in a Storage Area Network SAN or other storage configuration.

Consequently when a particular service processes and or stores data as described above the data may be stored within the database . Some services however may not utilize a database. For example as described above the invitation service may be implemented as a stateless service and therefore may not be required to store data within a database although such an implementation is still possible in accordance with the underlying principles of the invention .

The API may be designed to communicate and exchange information with the network services using any suitable network protocol stack including for example TCP IP or UDP IP at the network layer and HTTPS at the application layer. An remote procedure call RPC based protocol over HTTP or HTTPS such as SOAP may be used and or a Representational State Transfer REST protocol may be used. Moreover the services may be implemented on any computing platform including by way of example Xserve or similar servers running Unix Linux or an Apache software platform. In one particular embodiment the platform includes Web objects implemented on Linux. The foregoing examples are provided merely for the purpose of illustration. The underlying principles of the invention are not limited to any particular mechanism for linking applications to services or any particular set of network protocols.

In the architecture shown in a game framework is provided to support the various multi party features and P2P features described herein. In one embodiment the game framework is designed to run on the mobile device s operating system . For example if the mobile device is an iPhone iPad or iPod Touch the operating system can be the iPhone OS a mobile operating system designed by the assignee of the present application.

The game framework can include a public application programming interface API and a private or secure API . In one embodiment a game center application designed to provide various game related features described herein can make calls to both the public API and the private API whereas other applications e.g. applications designed by third parties are provided with access to only the public API . For example the designer of the mobile device may wish to keep certain API functions which involve potentially sensitive information out of the public API to avoid abuse by third party developers e.g. friend requests friends lists etc . However both the secure API and the public API may be merged into a single API accessible by all applications on the mobile device i.e. the separation of the API into separate public and private components is not required for complying with the underlying principles of the invention . The designation API is sometimes used below to refer to operations which may be found in either the public API and or the private API

One embodiment of the game center application is described in the co pending application entitled Systems and Methods for Providing a Game Center Attorney Docket No. 4860.P9127USP1 Ser. No. 61 321 861 Filed Apr. 7 2010 having inventors Marcel Van Os and Mike Lampell hereinafter Game Center patent application which is assigned to the assignee of the present application and which are incorporated herein by reference. Briefly the game center application includes a game centric graphical user interface GUI for navigating through multi player games purchasing new games retrieving information related to games e.g. leaderboard information achievements friend information etc contacting friends to play games requesting game matches with other users and inviting specific users. Various other functions performed by the game center application are described in the Game Center patent application referenced above. Some of the game center functions may be provided by the game framework and made accessible to other applications through the public API

In one embodiment the API exposed by the game framework simplifies the process of designing multi player collaborative games for the mobile device . In particular in one embodiment the API allows developers to make a simple API call to invoke the relatively complex process of connecting users for a multi player P2P game session. For example a simple API call such as INVITE Player B ID Bucket ID may be invoked from the API to initiate the detailed invitation sequence described above. Similarly an API call such as MATCH Player A ID Bucket ID may be invoked from the API to initiate the detailed matchmaking sequence described above. The INVITE and MATCH functions are sometimes generally referred to herein as P2P Connection Functions. In one embodiment the game framework includes the program code required to manage the invitation and matchmaking operations in response to these API calls as described in greater detail below . It should be noted that the actual API functions may have somewhat different data formats than those set forth above although they may result in the similar operations performed by the game framework . The underlying principles of the invention are not limited to any particular format for specifying API functions.

Various other types of game related transactions and information may also be managed by the game framework on behalf of the game center and other applications . Some of this information is described in the Game Center patent application. By way of example and not limitation this information may include leaderboard information related to those users who have achieved top scores for each game and achievements information identifying users who have completed certain game specific achievements. Each application developer may specify their own set of achievements for each game application e.g. completed levels 1 3 completed level 1 in under 5 minutes over 50 kills per level knocked down 20 flags etc .

The game framework may also include program code for managing a user s friends data and for integrating the friends data within the context of the game center and other gaming applications . For example when the user selects a link to a particular game within the game center information related to each of the user s friends may be displayed for that game e.g. the friends ranking on the leaderboard the friends achievements the results when the user played the game with each of his her friends etc . In one embodiment the API of the game framework includes functions for accessing friends data managed by a friend service such as that described in the co pending applications entitled Apparatus and Method for Efficiently Managing Data in a Social Networking Service Attorney Docket No. 4860.P9240 Ser. No. 61 321 848 Filed Apr. 7 2010 having inventors Amol Pattekar Jeremy Werner Patrick Gates and Andrew H. Vyrros hereinafter Friend Service application and Attorney docket No. 4860.P9240Z Ser. No. 12 831 888 filed Jul. 7 2010 which are assigned to the assignee of the present application and which is incorporated herein by reference.

As illustrated in in one embodiment a game daemon may interface the game framework to a first set of services and a game services component may interface the game framework to a second set of services . By way of example the first set of services may include the invitation service matchmaker service and relay service described above and the friend service described in the Friend Service application referenced above. Other services which may be accessed via the game daemon include a leaderboard service providing leaderboard data a game service providing statistics and other data related to each of the games and the ability to purchase game a user authentication service for authenticating the user of the mobile device and or a user profile service for storing user profile data such as user preferences . The second set of services accessed via the game services component may include the connection data exchange CDX service and the NAT traversal services described above. Although illustrated as separate components in for the purpose of illustration the game daemon and the game services module may actually be components of the game framework . In one embodiment the game daemon and communicate with each of the network services through a predefined API which in one embodiment is a private API i.e. not published to third party developers .

In one embodiment the game daemon can communicate with the matchmaker service invitation service and other services using the HTTPS protocol while the game services module can communicate with the CDX service and the NAT traversal services using a relatively lightweight protocol such as UDP sockets. However as previously mentioned various other network protocols may be employed while still complying with the underlying principles of the invention.

In addition as illustrated in the game daemon may receive push notifications generated by certain services e.g. the invitation service and matchmaker service while other types of push notifications may be received directly by the game center e.g. friend service notifications such as new friend requests . In one embodiment these push notifications are provided directly to the game center to ensure that a user s sensitive data is not made accessible to applications designed by third party application developers.

Returning to the game invitation examples set forth above in when an application on mobile device A makes an invitation call to the API of the game framework to invite a user of mobile device B e.g. INVITE Player B ID Game Bucket ID the game framework may pass the invitation request to the game daemon of mobile device A. The game daemon may then communicate with the invitation service to submit the invitation request. The invitation service can then use the push notification service as described above to push the invitation to the game daemon of mobile device B. The game daemon of mobile device B may then communicate with the game framework of mobile device B to determine whether the game for which the invitation was sent is installed on mobile device B. If so then the game framework may trigger the application and or generate a visual notification of the invitation. If the application is not installed then the game framework may trigger a visual notification of the invitation to the user of mobile device B with an offer to purchase the game e.g. via the game center GUI . Alternatively the visual notification may be generated by a push notification daemon running on the mobile device not shown . If the user of mobile device B purchases the game the invitation sequence may continue following the purchase. If user of mobile device B accepts the invitation request then the game framework of mobile device B may pass the invitation request to its game daemon which can then respond to the invitation service .

Recall that in the compatibility check determines that the NAT types of mobile devices A and B are compatible. Thus at mobile device A s game daemon may receive mobile device B s acceptance e.g. via push notification in the example and in one embodiment passes the acceptance to the game framework . At this stage the game framework of mobile device A may either notify the requesting application that mobile device B has accepted via the API or may wait to notify the requesting application until the devices have been successfully connected. In either case the game framework may pass a connection request to the game services module which in one embodiment may initiate a connection data exchange with mobile device B. In particular the game services module may transmit mobile device A s connection data to mobile device B using the CDX service see e.g. transactions and in . As described above this communication may be implemented as a UDP connection using a secure ticket data structure.

Recall that in if the compatibility check determines that the NAT types of mobile devices A and B are not compatible then the relay service may be used to provide a connection between the devices. Consequently the game daemon of mobile device B may receive a relay response from the invitation service shown in and the game daemon of mobile device A may receive a relay response from the invitation service via the push notification service . The game daemons of mobile devices A and B may communicate with the relay service at and to retrieve configuration data. At the game daemon of mobile device B receives relay update data from mobile device A and at the game daemon of mobile device A receives relay update data from mobile device B.

The end result of the processes shown in is that mobile devices A and B have established a connection with one another either a direct P2P connection or a relay connection . In one embodiment upon detecting a successful connection the game framework may notify the application which requested the connection using an API call e.g. CONNECTED Player A ID Player B ID . Mobile devices A and B may then play the specified game or other collaborative application using the established connection.

Thus in response to a relatively simply call from the API e.g. INVITE Player B ID Game Bucket ID a complex series of transactions may be managed by the game framework to establish a P2P or a relay connection between mobile devices A and B. In one embodiment the game framework performs the sequence of operations to connect mobile devices A and B and then provides the results to the requesting application thereby leaving the details of the API call transparent to the application designer. As such the application designer is not required to understand how to connect mobile devices A and B on the network or to perform various other functions required for enabling communication between the devices thereby simplifying the application design process.

In a similar manner the game framework can establish a match between mobile device A and other participants using the matchmaker service as described above with respect to . In this example the application may make a simple call to the API such as MATCH Player A ID Game Bundle ID . In response the game framework can manage the matching and connection data exchange operations. When the matching operations and or P2P connections are complete the game framework provides the results back to the application .

For example in the game framework may use the game services module to communicate with the connection data exchange CDX service and NAT traversal services and may use the game daemon to communicate with the matchmaker service . Once a match has been made the game daemon of mobile device A receives Ticket A at and the game framework uses this information to implement a connection data exchange through the game services module . For example at it may request its own connection data through the NAT traversal service and may then exchange its connection data at through the CDX service . At and the game services module of mobile device A receives connection data for mobile devices B and C respectively. Following these exchanges the game services module establishes P2P connections at and the game framework notifies the application that the connection process is complete using an API notification e.g. MATCH COMPLETE Player B ID Player C ID . The application may then execute using the established P2P connection.

In some embodiments the user may be given the option to play a game with other friends who are currently registered as online. In this case the notification that certain friends are online may be provided via the push notifications or push notifications received directly by the game center . The game center and or applications may then provide the notifications to the user and provide the user the option to play with one or more selected online friends. It should be noted however that the invitation sequence described herein will work regardless of whether online notifications are provided. In one embodiment the user s online status may be monitored by a service accessible by the game daemon e.g. by the friend service mentioned above or by a separate presence service .

One embodiment of the game framework provides for a combination invitation matchmaking operation in which a user may invite one or more friends to play a game with a group of unknown matched participants. For example if a game requires 4 players and a first user invites a second user to play the game then the invitation service may initially connect the first user and second user and the matchmaking service may then match the first user and second user with two or more other players. In this embodiment the game framework may initially perform the invitation sequences described above to connect the first user and the second user. In one embodiment once the first user and second user have been successfully connected the game framework may implement the matchmaking sequences to identify and connect with the other users. A mentioned above in one embodiment the matching criteria applied by the matchmaking service may include both the first and second user e.g. NAT types connection types language etc of both the first and second user . Alternatively the criteria of one of the two users may be evaluated to make the matching decision.

Once all of the users are connected the game framework may provide the connection results to the application which requested the connection via the API . Once again in response to a relatively simple API call by an application the game framework enters into a set of complex transactions to connect each of the devices. Once the devices have been successfully connected the game framework provides the results back to the requesting application .

As illustrated in the game framework may include a communication buffer to temporarily store communication between the user and other game participants. The communication may include for example text audio and or video communication. The game framework can establish the buffer based on the requirements of each application . For example a relatively larger buffer may be required for audio video communication with a slow network connection. In one embodiment each application may make an explicit request to establish a communication buffer of a certain size via the API e.g. using a BUFFER size command . Alternatively the game framework may automatically create a buffer based on the communication requirements of each application. For example the game framework may select a particular buffer size based on whether text audio and or video need to be supported.

In one embodiment the communication buffer may temporarily store communication streams before all of the P2P connections have been established between users. For example after the invitation service or matchmaker service has identified each of the users but before the CDX service has completed the connection data exchange operations each user may be notified of the other game participants in the process of being connected. At this stage the user of the mobile device may transmit text audio and or video communication streams to the other participants. The game framework will store the communication streams within the communication buffer for those participants who are not yet connected. The game framework may then transmit the text audio and or video from the buffer as the connection for each device is completed.

In one embodiment the game daemon includes a cache for caching data persisted on each of the services to reduce the network traffic. For example the user s friends list leaderboard data achievements data presence data and profile data may be stored in the cache as specified by a cache management policy. In one embodiment the cache management policy is driven by each individual service on which the data is stored. Consequently for n different services n different cache management policies may be applied to the cache . In addition because the cache management policy is driven by the services it may be modified dynamically based on current network and or server load conditions. For example during periods of time when a service is heavily loaded e.g. Christmas the day of a new product release etc. the service may dynamically specify a cache management policy with relatively infrequent cache updates e.g. updates every 12 hours . By contrast during periods of time when a service is not heavily loaded the service may specify a caching policy with more frequent cache updates e.g. updates every hour hour 2 hours etc .

In one embodiment the cache management policy is specified using a time to live TTL value for certain data records stored in the cache . When a data record has been stored in the cache past its TTL value then that data is considered stale and a local request for that data may be forwarded directly to the service associated with that data. In one embodiment the request includes an ID code identifying a current version of the data. If the ID code matches the ID code on the service then the data is still valid and does not need to be updated. A response may then be sent back from the service indicating that the data in the cache is current and the TTL value for the data record may be reset.

In addition to using a cache management policy as described above in one embodiment cache updates for certain types of data may be pushed to the mobile device using the push notification service . For example changes to a user s friends list or to the current online status of the user s friends may be dynamically pushed to the user s mobile device . The push notification may be received by the game daemon which may then update the cache to include the relevant portion of the data pushed by the service i.e. an update all of the data in the cache associated with that service may not be required . By contrast some push notifications may instruct the game daemon to overwrite the entire contents of cache or at least the portion of the cache associated with the service performing the push .

Those services which utilize push to update the cache may choose relatively high TTL values and or may not set TTL values because they have the ability to push notifications to update data stored in the cache . In one embodiment each service specifies a set of events which may trigger a push notification cache update. For example cache update events may include a change to a friend s online status a new friend request an acceptance of a friend request a de friend operation an indication that a friend is playing a particular game a game achievement reached by a friend an update to the top 10 of a particular leaderboard or any other events deemed to be of sufficient importance to warrant a cache update. Using push notifications to update the cache in this manner may decrease network and service load because with push updates periodic polling between the mobile device and the service is not required.

One embodiment of the game framework uniquely formats data presented to the end user based on the country and or geographical location of the user. For example values such as current date time and monetary values may be presented differently for users in different countries and locations. By way of example in the United States the date format may be month day year e.g. Apr. 25 2010 whereas in other countries the date format may be day month year e.g. 25 Apr. 2010 . Similarly when representing time in the US and some other countries the AM PM designation may be used and a colon may be used between hours and minutes e.g. 3 00 PM . By contrast many other countries do not use the AM PM designation and or use a comma between hours and minutes e.g. 15 00 . As another example many parts of the world use the metric system while some parts of the world do not e.g. the United States . It should be noted that these are simply illustrative examples which may be used by certain embodiments of the invention. The underlying principles of the invention are not limited to any particular set of data formats.

In one embodiment these different data formats may be selected when displaying leaderboard data achievements data friends data and or any other data processed by the game framework . The game framework may determine the country and or geographical location of the user in various ways. For example in one embodiment this information is simply provided in the user s profile data and or may be determined based on the user s cellular service provider. The user s location may also be determined using for example Global Positioning System GPS tracking.

Other types of data formatting which are unrelated to geographical location and or country may also be managed by the game framework . For example when displaying leaderboard data it is important to know whether the lowest score should place the user at the top or bottom of the leaderboard. For some games e.g. golf track racing skiing etc a lower number indicates a better performance whereas in other games e.g. football baseball etc a higher number indicates a better performance. Thus in one embodiment the application specifies the type of score which will be used via the API e.g. ascending or descending . The game framework may then use the appropriate set of labels and formatting for displaying the score.

One embodiment of the game framework also filters user data based on the relationship between the user and the user s friends. For example one embodiment of the invention allows for a detailed view a friends view and a public view. In one embodiment the detailed view is available to the user who owns the data i.e. the user s personal information the friends view is available to the user s friends and the public view is available to all other users.

By way of example the public view may simply include an alias name associated with each user the games played by the alias and associated scores and the dates times on which the games were played. This information may be used by the game framework to populate a public leaderboard which may then be displayed via the game center .

The friends view may include all of the information from the general view as well as any additional information to be shared among the user s friends including for example the games owned by the user the games played by the user the user s achievements and scores how many friends the user has the identify of those friends URL identifying the user s avatars and or the user s online status to name a few. In one embodiment the friends view provides a default set of information to be shared with friends but the end user may adjust this default configuration and specify with particularity the types of information to be shared by each individual friend or groups of friends e.g. co workers family members college high school friends etc .

The detailed view may include all of the information from the public and friend views as well as any other information managed by the various services on behalf of the end user. By way of example this may include all of the user s profile data the user s Universally Unique Identifier UUID sometimes referred to herein as the Player ID player name alias names number of games and the identity of the games the user s friends all of the user s achievements etc.

In some circumstances an application may only require a small amount of information related to each user such as each user s Player ID. For example in one embodiment when a match is requested the game framework may initially only require each player s ID. As matches are made by the matchmaker service see above the game framework may determine whether any of the matched users are friends e.g. via communication with the friend service and or by interrogating the user s local friend data . If so then the game framework may retrieve additional user data and provide that data to any matched friends. In this way the game framework filters information based on the identity of the users and the relationship between each of the users.

In one embodiment the game framework initially provides a public view between a first user and a second user if the two users do not have a friend relationship. However in one embodiment the game framework allows the first user to send a friend request to the second user e.g. using the second user s alias . If the friend request is accepted then the game framework will provide additional information to each of the users e.g. the default friend view .

The API implemented in one embodiment is an interface implemented by a software component hereinafter API implementing software component that allows a different software component hereinafter API calling software component to access and use one or more functions methods procedures data structures and or other services provided by the API implementing software component. For example an API allows a developer of an API calling software component which may be a third party developer to leverage specified features provided by an API implementing software component. There may be one API calling software component or there may be more than one such software component. An API can be a source code interface that a computer system or program library provides in order to support requests for services from a software application. An API can be specified in terms of a programming language that can be interpretative or compiled when an application is built rather than an explicit low level description of how data is laid out in memory.

The API defines the language and parameters that API calling software components use when accessing and using specified features of the API implementing software component. For example an API calling software component accesses the specified features of the API implementing software component through one or more API calls sometimes referred to as function or method calls exposed by the API. The API implementing software component may return a value through the API in response to an API call from an API calling software component. While the API defines the syntax and result of an API call e.g. how to invoke the API call and what the API call does the API typically does not reveal how the API call accomplishes the function specified by the API call. Various function calls or messages are transferred via the one or more application programming interfaces between the calling software API calling software component and an API implementing software component. Transferring the function calls or messages may include issuing initiating invoking calling receiving returning or responding to the function calls or messages. Hence an API calling software component can transfer a call and an API implementing software component can transfer a call.

By way of example the API implementing software component and the API calling software component may be an operating system a library a device driver an API an application program or other software module it should be understood that the API implementing software component and the API calling software component may be the same or different type of software module from each other . The API calling software component may be a local software component i.e. on the same data processing system as the API implementing software component or a remote software component i.e. on a different data processing system as the API implementing software component that communicates with the API implementing software component through the API over a network. It should be understood that an API implementing software component may also act as an API calling software component i.e. it may make API calls to an API exposed by a different API implementing software component and an API calling software component may also act as an API implementing software component by implementing an API that is exposed to a different API calling software component.

The API may allow multiple API calling software components written in different programming languages to communicate with the API implementing software component thus the API may include features for translating calls and returns between the API implementing software component and the API calling software component however the API may be implemented in terms of a specific programming language.

It will be appreciated that the API implementing software component may include additional functions methods classes data structures and or other features that are not specified through the API and are not available to the API calling software component . It should be understood that the API calling software component may be on the same system as the API implementing software component or may be located remotely and accesses the API implementing software component using the API over a network. While illustrates a single API calling software component interacting with the API it should be understood that other API calling software components which may be written in different languages or the same language than the API calling software component may use the API .

The API implementing software component the API and the API calling software component may be stored in a machine readable medium which includes any mechanism for storing information in a form readable by a machine e.g. a computer or other data processing system . For example a machine readable medium includes magnetic disks optical disks random access memory read only memory flash memory devices etc.

In Software Stack an exemplary embodiment applications can make calls to Services or using several Service APIs and to Operating System OS using several OS APIs. Services and can make calls to OS using several OS APIs.

Note that the Service has two APIs one of which Service API receives calls from and returns values to Application and the other Service API receives calls from and returns values to Application . Service which can be for example a software library makes calls to and receives returned values from OS API and Service which can be for example a software library makes calls to and receives returned values from both OS API and OS API . Application makes calls to and receives returned values from OS API .

As illustrated in the computer system which is a form of a data processing system includes the bus es which is coupled with the processing system power supply memory and the nonvolatile memory e.g. a hard drive flash memory Phase Change Memory PCM etc. . The bus es may be connected to each other through various bridges controllers and or adapters as is well known in the art. The processing system may retrieve instruction s from the memory and or the nonvolatile memory and execute the instructions to perform operations as described above. The bus interconnects the above components together and also interconnects those components to the optional dock the display controller display device Input Output devices e.g. NIC Network Interface Card a cursor control e.g. mouse touchscreen touchpad etc. a keyboard etc. and the optional wireless transceiver s e.g. Bluetooth WiFi Infrared etc. .

According to one embodiment of the invention the exemplary architecture of the data processing system may used for the mobile devices described above. The data processing system includes the processing system which may include one or more microprocessors and or a system on an integrated circuit. The processing system is coupled with a memory a power supply which includes one or more batteries an audio input output a display controller and display device optional input output input device s and wireless transceiver s . It will be appreciated that additional components not shown in may also be a part of the data processing system in certain embodiments of the invention and in certain embodiments of the invention fewer components than shown in may be used. In addition it will be appreciated that one or more buses not shown in may be used to interconnect the various components as is well known in the art.

The memory may store data and or programs for execution by the data processing system . The audio input output may include a microphone and or a speaker to for example play music and or provide telephony functionality through the speaker and microphone. The display controller and display device may include a graphical user interface GUI . The wireless e.g. RF transceivers e.g. a WiFi transceiver an infrared transceiver a Bluetooth transceiver a wireless cellular telephony transceiver etc. may be used to communicate with other data processing systems. The one or more input devices allow a user to provide input to the system. These input devices may be a keypad keyboard touch panel multi touch panel etc. The optional other input output may be a connector for a dock.

In one embodiment of the invention the architectures described above are extended to allow peers at different service providers to establish peer to peer P2P connections such as real time audio video and or chat connections. Because the different service providers may utilize their own protocols and their own client ID namespaces these embodiments of the invention provide techniques to allow devices to interoperate regardless of the protocols used and to integrate the namespaces into a single global namespace.

A global database may be maintained to track a global namespace of all users on all systems. However given the vast number of users spread across service providers a global database approach might be difficult to manage. Alternatively names used to identity users and or data processing devices e.g. user IDs phone numbers may be broadcast to all other service providers to identify who can respond to the requested connection. Once again however such a system would not scale well i.e. sending a broadcast message for each attempted connection would consume a significant amount of bandwidth .

To address the foregoing issues one embodiment of the invention uses Bloom filters to locate relevant service providers during connection attempts. This embodiment will be described with respect to the architectures shown in . Four service providers are illustrated in FIG. service provider A service provider B service provider C and service provider D . As in prior embodiments each service provider manages a registration database containing user IDs and or telephone numbers of a set of users who are provided with data communication service from the service provider. By way of example in users A C are provided with service from service provider A and users D F are provided with service from service provider D . As previously described in one embodiment the registration databases map phone numbers or user IDs to a push token of each user s data processing device. Thus servers maintained by the service providers enable the users of a particular service provider to locate and establish peer to peer P2P connections with one another using the techniques described above see e.g. and associated text . As one example the servers maintained by the service providers allow user to establish audio video chat sessions with one another such as FaceTime Chat sessions a technology designed by the assignee of the present patent application .

In addition to enabling P2P connections between a service provider s own users the embodiments illustrated in enable users of different service providers to establish P2P connections with one another. In particular as shown in each service provider includes a user location service for initially querying the service provider s registration database to determine if a particular user is managed by the service provider. Only two service providers providers A and D are illustrated in for simplicity. If user A requests a P2P connection with another user managed by the same service provider e.g. user B the user location service of service provider A will identify user B from the registration database and send the connection request to user B e.g. with user B s push token retrieved from the registration database .

If however user A requests a P2P connection with a user managed by a different service provider e.g. user F then the location service of service provider A will attempt to locate user F at a different service provider using the bloom filters received from each of the other service providers. In particular as illustrated in each service provider includes a bloom filter generator for generating a bloom filter based the current contents of its registration database . As is known by those of skill in the art a bloom filter is a is a space efficient probabilistic data structure that is used to test whether an element is a member of a set. False positives are possible but false negatives are not. In the embodiments described herein the elements used to generate each bloom filter are the User ID s and or phone numbers of each user. In for example the bloom filter generator of service provider A uses all of it s User IDs Andy124 Tom4546 etc to generate its bloom filter . Similarly bloom filter generator of service provider D uses all of the user IDs in its registration database Woody1234 Rick456 etc to generate its bloom filter . In one embodiment each service provider generates its own bloom filter in this manner and periodically transmits the bloom filter to all other service providers. Each service provider may then use the bloom filters received from the other service providers to test and determine whether particular user is managed by the other service providers.

By way of example in if user A with a user ID of Andy attempts to establish a P2P session e.g. a personal audio video chat with user F with a user ID of Woody123 then the user location service of service provider A may initially attempt to locate user F s user name Woody123 in its own registration database . If unsuccessful in one embodiment it will query the bloom filters of the other service providers an attempt to locate the service provider which manages the User ID Woody123. As mentioned bloom filters may provide false positives but will not provide false negatives. Thus if the bloom filter indicates that service providers B and C do not manage Woody123 then service provider A will know definitively that Woody123 is not managed by these service providers. In the illustrated example the bloom filter query indicates that Woody123 may be managed by Service Provider D and may also indicate that Woody123 is managed by one or more other service providers. As such in one embodiment service provider A will send an initiate message e.g. an INVITE command inviting user F to a P2P session to each of the service providers who potentially manage this user ID. The service providers which do in fact manage this user ID will respond to service provider A in the affirmative. Once the correct service provider has identified itself service provider D in the example the two service providers may then act as proxies for their respective users Users A and F in the example and to open a communication channel between the users. Once users A and F have exchanged connection data they may open direct P2P communication channels with one another e.g. by exchanging using the techniques described above with respect to and or implementing a standard Internet Connectivity Establishment ICE transaction . Alternatively if a direct P2P connection is infeasible e.g. because of incompatible NAT types then users A and F may open a relay connection using the relay service illustrated in see also and associated text .

In one embodiment each service provider is expected to continually update its own bloom filter and transmit the bloom filter to each of the other service providers participating to support P2P audio video connections. The updates may occur at regular intervals e.g. once every hour day etc and or after a certain number of new User IDs have been added to the registration database. The underlying principles of the invention are not limited to any particular mechanism for exchanging bloom filters between service providers.

One embodiment of a method for generating and updating bloom filters is illustrated in . The method may be executed on the architecture shown in but is not limited to any particular system architecture. At the user registration database at a particular service provider is updated. For example new User IDs phone numbers may be added and old User IDs phone numbers may be deleted. At a new bloom filter is generated using the complete set of User IDs phone numbers. At the new bloom filter is transmitted to participating service providers.

One embodiment of a method for using a bloom filter to locate a service provider for a client is illustrated in . The method may be executed on the architecture shown in but is not limited to any particular system architecture. At the bloom filters of a group of participating service providers are received. The bloom filters may be stored in a volatile memory for efficient access and or persisted to a non volatile storage location. At a connection request is received from a user User A in the example to establish a P2P connection with another user User F . At a bloom filter function is executed on the user ID of User F e.g. Woody123 from the example above to rule out certain service providers. If the bloom filter function returns a negative result for a particular bloom filter then User F is not managed by that particular bloom filter. However if a positive result is returned for a bloom filter then there is a reasonable chance that the service provider associated with the bloom filter manages User F. If only one positive result is returned then at a connection invitation is transmitted to that service provider. If multiple positive results are returned then at a separate connection invitation may be transmitted to each relevant service provider.

The service provider at which User F has a registration then responds in the affirmative and the two service providers may act as proxies at to permit the users to exchange connection data as described above e.g. push tokens public private network addresses ports NAT types etc . If more than one service provider responds in the affirmative meaning that two service providers support users with the same User ID then additional steps may be taken to identify the correct user e.g. comparing the phone numbers real names network addresses or other information known about the user with whom a connection is desired .

Once the correct service provider for User F has been identified and the necessary connection data exchanged then at a direct P2P connection or a relay connection if necessary is established between User A and User F as described above.

As mentioned above with respect to in some embodiments of the invention the various servers used to establish a P2P connection between two or more users do not need to maintain any connection state information during the connection process. This includes for example the invitation service and the connection data exchange service . Rather in these embodiments the complete connection state including but not limited to public private IP and port sometimes referred to generally as network information NAT type user IDs push tokens etc is accumulated and transmitted with each successive user transaction. As illustrated in one additional piece of state information in a multi provider context which is transmitted with each transaction is a provider ID code.

Turning to the specific details of User A transmits an initiate request sometimes referred to herein as an invitation request which includes its own network ID ID A it s own network information e.g. public private IP port data NAT type etc determined using the techniques described above its own push token Token A and an ID code phone number and or other type of identifier for User F. The initiate request is initially received by User A s service provider which may implement any of the techniques described above with respect to to locate the service provider of User F e.g. using a bloom filter to rule out certain service providers . User A s and User F s service providers are not illustrated in for simplicity. 

In one embodiment once User F s service provider is identified an initiate push operation is transmitted from User F s service provider to User F which includes an identifier for User A s service provider Provider A in the example. The identifier for Provider A may be as simple as an N bit identification code e.g. 16 bit 32 bit 64 bit etc . Alternatively the identifier for Provider A may include a public IP address identifying Provider A s network gateway or other networking data needed to connect to Provider D. The underlying principles of the invention remain the same regardless of the format used to identity Provider A with the sequence of P2P connection transactions.

In one embodiment the push transaction is generated by a push notification service such as push notification service discussed above see e.g. and associated text . As mentioned all of the original state information provided by User A and any additional state information collected by servers of service provider A is included in the initiate push transaction .

In the example shown in User F responds with an Accept transaction containing all of the prior state information ID A NetInfo A Provider A along with User F s information needed to establish a P2P connection including by way of example and not limitation User F s ID ID F User F s network information NetInfo F which may include public private IP address port NAT type etc and User F s token Token F . All of the connection state information for User A and User F is received by User F s service provider Provider D in the example which attaches it s own provider ID code to the transaction Provider D and forwards it to User A s service provider. As described above for Provider A the identifier for Provider D may be as simple as an N bit identification code. Alternatively the identifier for Provider D may include a public IP address identifying Provider D s network gateway or other networking data required to connect to Provider D. The underlying principles of the invention remain the same regardless of the format used to identity Provider D within the sequence of P2P connection transactions.

Once all of the connection state data is received by User A including the Provider D data User A and User F may establish a P2P connection using the techniques described above as indicated by transaction .

As discussed above under certain conditions User A and User F may need to establish a connection through a relay service see e.g. instead of a direct P2P connection. As illustrated in in one embodiment both service providers A and F may use their own relay services and or have relationships with third party relay services . In one embodiment if the attempted P2P connection between User A and User F fails then service provider A s relay service i.e. the provider of the user initiating the P2P connection is used to support the connection. In an alternate embodiment User F s relay service i.e. the provider of the user with whom a connection is being requested is used to support the connection as indicated by dotted lines between User A relay service and User F in . In yet another embodiment all of the providers agree upon a single relay service and utilize that relay service to establish P2P connections between users.

One embodiment of the invention combines a variety of different communication protocols to support secure audio video P2P communication between user devices. These protocols include but are not limited to Datagram Transport Layer Security DTLS protocol to provide secure communication over P2P connections the Secure Real time Transport Protocol or SRTP which defines a profile of RTP Real time Transport Protocol intended to provide encryption message authentication and integrity and replay protection to the RTP data for both unicast device to device and multicast device to multiple device applications and Session Initiation Protocol SIP to establish voice video connections between user devices. These protocols may be employed within the context of any of the embodiments of the invention described herein.

In one embodiment each device on the open inter provider network illustrated in will be securely identifiable to other devices for the purposes of identity verification and end to end encryption of the stream using STRP. A certificate format required to be issued by each of the service providers to enable secure communication is described below.

In one embodiment each provider will need to know how to discover other peer providers. In one embodiment there is a global and secured list of providers to query for call routing and peer information. This is a list of trusted servers and their addressing information. One of the providers may host this service.

Described below is the level of security and authentication needed between providers to validate and trust the connection between them. This may be a different set of credentials than are used between the provider and the global lookup database as well as those used to authenticate the P2P connection.

In one embodiment at call routing time the recipient s provider i.e. the user being called provides a peer certificate to return to the caller to be used to authenticate the P2P connection between the endpoints. This certificate may be able to be signed by an external entity and the certificate requirements may allow for any type of identity not just an email.

In addition in one embodiment audio video and signaling data is multiplexed together on each data processing device over a single data port. The audio video and signaling data is then demultiplexed and decoded at the destination device.

The inter provider network illustrated in consists of multiple interoperating layers. The interaction of these layers may be specified by various protocols. The goal of this interaction is to process a user request to establish a connection performing the necessary exchange of information between the user endpoints identified as Users A F in so that they can establish an audio video calling session.

In operation the inter provider network shown in is implemented as a set of servers which communicate with one another originating and responding to requests. These requests are the protocol actions that are necessary to forward requests so that user endpoints can exchange media channel connection data and form an audio video calling session. In one embodiment each service provider manages all direct communication with its user endpoints.

In one embodiment user endpoints are represented via a Uniform Resource Identifier URI that identifies the party that controls the endpoint. The initial supported URI schemes are tel for telephone numbers and mailto for email addresses . Other URI schemes may be supported in the future.

In one embodiment the mapping of URI to each user endpoint is not an identity mapping it is a many to many relationship. A single URI may map to multiple endpoints and a single endpoint may be mapped to by multiple URIs. In addition URI to endpoint mappings may span multiple Providers. For instance there may be one Endpoint on Provider A and a different Endpoint on Provider B and both of these Endpoints may be mapped by the same URI. However in one embodiment endpoints may only be hosted by a single Provider at a time. In one embodiment Endpoint URIs are generic user level identifiers like phone numbers and email addresses. The mapping of these to providers and endpoints is performed by the system and is transparent to the end user.

In one embodiment the meta protocol used for the inter provider communication illustrated in is dictionaries over HTTP. In this embodiment all actions are performed as either an HTTP GET or POST. If the action is specified as an HTTP GET the body will be empty. If the action is specified as an HTTP POST the body will contain the request parameters encoded as a dictionary. Responses will have a body which contains the response parameters encoded as a dictionary. In one embodiment the initial encoding of dictionaries is Apple XML Property Lists. Other encodings such as JSON or Protocol Buffers may also be used. In one embodiment different service providers may use any set of protocols or communication mechanisms to communicate with individual user devices.

In one embodiment a provider discovery protocol is employed to allow the service providers shown in to discover one another. In one embodiment a bootstrap URI is published by the managing entity of the network e.g. a primary or managing service provider . This bootstrap URI points to a discovery dictionary containing the set of providers that are the accepted members of this network. For each service provider this dictionary contains identifying information as well as further URIs which specify how to communicate with this provider. In one embodiment when service providers start up and periodically thereafter they retrieve the discovery dictionary. Then they configure themselves to communicate with the other providers based on the information in the dictionary.

Details for one particular set of protocols for establishing P2P communication sessions between users will now be described. It should be noted however that these specific details represent just particular embodiment and are not required for complying with the underlying principles of the invention.

The Invitation Protocol of one embodiment is used for initial call setup. This is the out of band signaling used by user endpoints e.g. user endpoints in to exchange media channel connection data which will be used to establish the media channel for the video calling session.

Sent by the initiating Endpoint to start a call. Fields session id self uri self token self blob peer uri.

Sent by the receiving Endpoint to indicate that it s not willing to participate in the call. Fields session id self uri self token self blob peer uri peer token peerblob.

Sent by the either Endpoint to indicate that the call should be terminated. Fields session id self uri self token self blob peer uri peer token peer blob.

When an Endpoint wishes to establish a connection it needs a URI to identify receiving Endpoints. This URI is most likely derived from some information provided by the user for instance a dialed phone number or an email address stored in an address book. Then the endpoint calls Initiate Request on its hosting provider.

The initiating provider looks at the URI and determines the set of receiving providers which host endpoints that are mapped by this URI. This set of Providers may include the initiating Provider itself. It then calls Initiate Forward on all applicable receiving Providers.

The receiving endpoint gets the Initiate Push and presents the information to the user. This would typically be UI along the lines of XXX is calling. If the user decides to take the call the endpoint will call Accept Request. Otherwise it will call Reject Request. 

The initiating end point gets the Accept Push and indicates to the user that it can proceed with forming a connection. At this point both Endpoints have exchanged media channel connection data so they are ready to establish a media channel for the audio video calling session. From here the flow continues with Media Channel Establishment as documented in Media Session Management below .

As discussed in detail above in one embodiment Bloom filters are used to choose the candidate service providers which will be able to respond to an initiate call request. In one embodiment providers are required to maintain an up to date Bloom filter representing all the URIs of the Endpoints that they currently host. The Bloom filters for all providers may distributed to all other providers in an incremental fashion.

Dispatch Optimization Protocol. When dispatching an originated call providers first consult the Bloom filter of all other Providers. From this they will obtain a candidate set of Providers that can actually service the call. The Initiate action is then sent only to this candidate list.

Media session management refers to the setup control and teardown of the media channel and media streams running over the media channel. Media session management is detailed in the following sections.

Network packets for media signaling media flow and session teardown are sent over the media channel. The media channel is established through either NAT traversal or relay configuration as described in detail above . Both NAT traversal and relay configuration require that each endpoint possesses the media channel connection data for both endpoints.

In one embodiment the NAT traversal protocol is used to establish a media channel over a direct peer to peer connection. It includes usage of techniques covered in Interactive Connectivity Establishment ICE RFC 5245 .

In one embodiment the relay protocol is used to establish a media channel over a relay network. In one embodiment it includes usage of TURN RFC 5761 .

Media signaling covers set up of security for media negotiation and media encryption and media negotiation for audio and video parameters.

As mentioned in one embodiment Datagram Transport Layer Security DTLS RFC 4347 is used to secure communication of network traffic over the media channel. The DTLS protocol may be implemented to provide end to end encryption such that a service provider will not be able to access encrypted content within voice video packets transmitted between users.

In one embodiment SIP RFC 3261 is used for negotiating the audio and video parameters of the video calling session.

Media flow control covers management of active media streams and notification of media state changes over the media channel.

In one embodiment network adaptation techniques are implemented to account for communication channel fluctuations. In particular a user endpoint may adjust stream parameters such as audio and or video bitrates in order to adapt to varying network conditions such as changes in throughput packet loss and latency.

An endpoint sending video may mute unmute video. Notifications are sent to the remote endpoint using SIP MESSAGE.

An endpoint sending video may alter the orientation of the video. Notifications are sent to the remote endpoint using RTP header extension information.

An endpoint sending video may switch the source of video. For example on a user device which includes both front facing and back facing cameras the video may switch from front facing to back facing. Notifications may be sent to the remote endpoint using RTP header extension information.

In one embodiment an endpoint can explicitly terminate an active session by sending a SIP BYE message.

A media session may be torn down explicitly or implicitly. An explicit teardown of the media channel is done via sending or receiving a SIP BYE message. An implicit teardown may occur due to network connectivity loss or poor network performance.

In one embodiment communications between endpoints in the inter provider system shown in are secured using public key cryptography. Each entity Provider and Endpoint has a certificate issued by a trusted CA which signs its identity. This certificate contains the URI belonging to the entity as well as other identifying information. The certificate can be used by counter parties to verify the identity of the entity when communicating.

In one embodiment the audio signal acoustic characteristics are specified by the 3GPP spec for WideBand telephony terminals TS 26.131 and TS 26.132.

In one embodiment sequence parameter set SPS and picture parameter set PPS NALUs are used to carry the video stream description in the bitstream.

In one embodiment the Video Codec used to communicate between users in is H.264 High Profile without b frames Level 1.2 effectively QVGA 15 fps max 300 kbps . It should be noted however that the underlying principles of the invention are not limited to any particular audio video format.

As mentioned the Realtime Transport Protocol RTP may be used to support audio video communication between user endpoints. As illustrated in in one embodiment an RFC 3984 header i.e. as defined by RFC 3984 RTP Payload Format for H.264 Video is appended to each 12 byte RTP Payload containing an RTP data packet . The header specifies how the RTP data is packetized using an H.264 image description extension.

One embodiment of the invention provides an architecture to enable secure peer to peer sessions between mobile devices for applications such as instant messaging and video chat. As illustrated in this embodiment of the invention includes an identity service for authenticating users a push notification service for pushing notifications to mobile devices as previously described and secure instant messaging service for establishing secure instant messaging sessions between two or more mobile users users A and B are illustrated in . In one embodiment the identity service manages a user registration directory of active user IDs authentication keys and push tokens which may be used by the notification service as described herein to send push notifications to mobile devices. In one embodiment the user IDs are email addresses although the underlying principles of the invention are not limited to any particular type of user ID. Moreover a single user may have multiple user IDs for different applications e.g. instant messaging video chat file sharing etc and may have different mobile devices e.g. an iPhone and a separate iPad devices designed by the assignee of the present patent application .

One embodiment of a computer implemented method for establishing secure peer to peer communication channels is illustrated in . While this method will initially be described within the context of the architecture shown in it should be noted that the underlying principles of the invention are not limited to this particular architecture.

At user A transmits a query including an identifier for user B s e.g. user B s email address and or phone number to the identity service to initiate a secure communication channel with user B. In response the identity service determines whether any user ID matches the query at e.g. whether user B s email address or telephone number is registered within the identity service . If not at the identity service transmits a failure notification to user A.

If a match is found then at user A retrieves user B s network address info and public key from the identity service . In one embodiment the address info includes a token for user B s computing device thereby authorizing user A to talk to user B with this specific address device A s token can talk to B s token . If user B has multiple devices multiple tokens may be provided from the identity service one for each device and routed separately to user A.

In one embodiment a session key is also generated sometimes referred to herein as a query signature which is a signature over a timestamp of the current time user A s ID user B s ID user A s token and user B s token provided by the identity service . This session key is subsequently used by the secure IM service to authenticate the two users without involving the identity service as described below .

User A now has addressing information and public key for each of these address units target IDs tokens . At device A encrypt the message and attachments to be sent to user B with user A s private key and device B s public key. In one embodiment this comprises encrypting the content of the text attachments with user B s key and signing the content with user A s key. Once encrypted the message cannot be decrypted at any of the severs situated between user A and user B although the servers can see the type of message being transmitted e.g. whether it is a text message or read receipt . As a result of the encryption using user B s public key only user B can read the message contents. User B can also verify the sender user A with using user A s signature.

At user A opens a secure communication channel with the push notification service using datagram transport layer security DTLS and sends the encrypted message to the push notification service with user B s token user ID and user A s user ID. As is known by those of skill in the art the DTLS protocol provides communications privacy allowing datagram based applications to communicate in a way that is designed to prevent eavesdropping tampering or message forgery. The specific details associated with the DTLS protocol are well known and therefore will not be described here in detail.

In one embodiment user A s token is not transmitted to the push notification service in this step but is inferred based on user A s communication with the push notification service . At the push notification service opens a secure communication channel with the secure instant messaging service and upon request provides the secure instant messaging service with user A s push token. Thus at this stage the secure instant messaging service has user B s token and ID and user A s token and ID. In one embodiment it verifies this information using the session key mentioned above e.g. by re generating the session key with user B s token and ID and user A s token and ID and a timestamp and comparing the generated session key to the one received from the push notification service . In one embodiment the if the current timestamp is too far ahead of the original timestamp then the signatures will not match and a verification failure will occur. If the signatures match i.e. if the message is well signed then at the secure instant messaging service opens a second outgoing secure communication channel with the push notification service adds user A s push token to the message along with user B s push token and ID and transmits the message to the push notification service for delivery to user B. Significantly at this stage the secure IM service does not need to query the identity service for verification purposes thereby preserving network bandwidth.

At the push notification service opens a secure communication channel with user B using transport layer security TLS and pushes the message to user B. At user B performs the same verification operations described above for user A to verify and decrypt the message. In particular user B may query the identity service to retrieve user A s public key and then uses the public key to verify the message which had been previously been signed using user A s private key and encrypted with user B s public key . At this stage users A and B have all of the information needed to establish a secure IM session at e.g. public keys and tokens .

In one embodiment illustrated in Off the Record Messaging OTR negotiation may be used in lieu of or in addition to the techniques described above. As is known by those of skill in the art OTR is a cryptographic protocol that provides strong encryption for instant messaging conversations which uses a combination of the AES symmetric key algorithm the Diffie Hellman key exchange and the SHA 1 hash function. In one embodiment the secure messaging techniques described above are attempted and if unsuccessful then the OTR techniques illustrated in are employed.

At user A queries the identity service using User B s ID e.g. email address phone number etc and retrieves User B s public key from the identity service. At user A generates a secure OTR session request by encrypting using user B s public key and transmits the request to user B. At user B decrypts using user B s private key and in response to the session request user B retrieves user A s public key.

At user B generates an OTR response encrypting the response with user A s public key. At users A and B exchange additional OTR connection messages. The specific messages exchanged at this stage may be are defined by the current OTR specification and are therefore not described in detail here. At once all necessary connection data has been exchanged users A and B open secure instant messaging communication channels with one another.

While the embodiments described above focus on an instant messaging implementation the underlying principles of the invention may be implemented with other types of peer to peer communication services such as peer to peer audio and or video services.

As mentioned above in one embodiment the identity service manages a user registration directory of active user IDs authentication keys and push tokens. The identity service is used by other services such as the push notification service and the secure instant messaging service to provide efficient identifying information for mobile devices and users based on human usable input. In particular in one embodiment the identity service comprises a shared user registration database with tables that map convenient user readable user ID codes e.g. phone numbers email addresses game center nicknames etc to detailed user device information.

In one embodiment a single user ID may map to multiple physical devices within the user registration directory . For example a user with the ID tom bstz.com may have multiple mobile devices such as an iPhone and a separate iPad devices designed by the assignee of the present patent application and a separate notebook desktop personal computer. Any user or service with the necessary authentication credentials may query the identity service to retrieve information about other users. While the foregoing specific devices are used for the purposes of illustration the underlying principles of the invention are not limited to any particular device type.

In one embodiment the device information maintained for each device comprises 1 a push token for the device which includes network addressing information for the device as described above and 2 a set of capabilities of the device. The capabilities may include the identity of the service provider for the device e.g. AT T vs Verizon device version information e.g. software OS version and or application versions and one or more protocols supported by the device e.g. based on the application program code installed on the device . For example if the device has the Facetime application installed then this information will be stored by the identity service along with device information. Additionally the device information may specify the types of services that each user device is capable of communicating with e.g. such as the secure instant messaging service described above .

Thus in response to a query to retrieve user B s device information user A may receive a response from the identity service containing the above device information for each of user B s devices. This will effectively inform user A s device of the different ways in which user A s device can communicate with user B. For example if user A has some of the same communication applications as user B e.g. the same instant messaging client Facetime application file sharing application etc with the correct versions installed then user A s device may use this information to attempt to open a communication channel with user B.

In one embodiment the device information also includes a set of flags which identify the specific application capabilities for each application. Returning to the Facetime example above the device information may specify that User B s device supports Facetime channels over 3G networks. In such a case user A s device may then attempt to open a communication channel with user B s device over a 3G network using the specific protocols supported by user B s device. Of course the foregoing are merely illustrative examples. The underlying principles of the invention are not limited to any particular set of application capabilities or protocols.

In one embodiment of the invention illustrated in there are four operations that a device may perform to interact with the identity service 1 authenticate 2 registration 3 canonicalize and 4 query.

 Authenticate as used herein refers to proving the identity of a particular user identifier ID . In one embodiment the authentication performed may be different for different types of ID codes e.g. email addresses service nicknames user ID codes phone numbers etc . For example authentication of email addresses may be different from authentication of phone numbers or service ID codes.

These operations will be described with respect to the system architecture shown in and the method set forth in . It should be noted however that the method illustrated in may be implemented on different system architectures while still complying with the underlying principles of the invention.

At user A transmits a set of application specific credentials to the application authentication service . In the case of an email application for example the credentials may include user A s email address and password in the case of a game application this may include the user ID for the game service and a password and in the case of a phone number it may include a short message service SMS signature. Moreover while illustrated in as separate services the application authentication service and identity service may form a single integrated service.

In response at the application authentication service takes the provided authentication credentials signs them puts them into an authentication certificate referred to herein as a provisioning certificate and transmits the provisioning certificate to user A. In one embodiment the provisioning certificate comprises a cryptographic nonce e.g. a timestamp and the signature.

In addition to the provisioning certificate in one embodiment user A is provided with a push certificate received from the push notification service at which includes a signature over user A s push token a nonce e.g. a timestamp and a list of user A s capabilities e.g. specific applications installed on user A s device . In one embodiment the push certificate is provided to user A s device when user A s device is initially provisioned on the network.

At user A registers its push certificate and its provisioning certificate with the identity service and at the identity service extracts certain predetermined information from the push certificate and provisioning certificate and generates its own signature for these entities referred to herein as the identity certificate of user A which may subsequently be used to verify the identity of user A with any of the services on the network i.e. without the need for the services to individually contact the identity service for verification .

Certain types of user IDs are noisy meaning that they are often represented using a variety of different formats. For example the same phone number can be represented as either 408 555 1212 1 408 555 212 or 4085551212. There are also a variety of international access codes and carrier access codes which take on different formats. Consequently a first user may know the phone number of a second user but may not know the particular format needed to reach the user given the current context e.g. where the user is currently roaming how the phone number is formatted to locate the second user s phone number in the registration database .

It would be inefficient to store each of the different variations of a particular user ID within the registration database i.e. it would consume a significant amount of space and might not successfully capture all of the different possible formats . As such to address this problem one embodiment of the invention canonicalizes user IDs prior to storing the user IDs within the registration database e.g. using an agreed upon canonical format .

In one embodiment the identity service includes logic for performing the canonicalization based on the current context of the user and the settings on the requesting device. For example in user B may provide the identity service with the identity of its home carrier e.g. AT T its current roaming carrier e.g. TMobile user settings e.g. an indication as to whether international assist is being used and a raw target ID code e.g. User A s phone number in a non canonicalized form such as 4085551212 . In response the identity service will canonicalize the raw target ID based on all of the foregoing variables prior to performing the query on the registration database . Thus the canonical ID of user A not the raw ID is provided to user B in response to user B s query to the identity service described in greater detail below .

As previously described in order to establish a secure communication channel with a target user a user initially queries the identity service to retrieve identities for the target user. As illustrated in User B transmits a query for User A s identity sending its own identity certificate as part of the query. In response the identity service sends back 0 or more identity certificates each of which include User A s ID code in a canonicalized format as mentioned above a push token for that identity and a query signature generated over User A s ID and push token and User B s ID and push token.

It would be inefficient to force each service to query the IDS every time authentication is required. For example when user A wants to send a message to user B the instant messaging service described above would need to query the identity service with user A s token and signature and user B s token and signature which would consume network resources.

To address this issue in the embodiments of the invention described herein a set of 0 or more signatures is generated by the identity service for each transaction between users and this set of signatures is sent along with each request to each service. The signature is over the tuple of source ID source token target ID target token and timestamp as described above. Thus any service can perform verification itself by dynamically generating a cryptographic signature over these entities to verify without contacting the identity service.

In addition each individual service can make a decision as to how fresh the timestamp needs to be for the verification to occur successfully. As long as the verification is taking place within a pre specified window of time from the original timestamp generated by the identity service then the transaction will be successfully verified. Thus the identity service provides tools for allowing application services to authenticate users but does not make policy decisions on how authentication should occur e.g. how fresh the timestamp needs to be . Thus different applications may have different policies for authentication.

One embodiment of the identity service implements a caching architecture for queries to further reduce the amount of network traffic. As illustrated in in this embodiment a device cache of user IDs is maintained on each user device and an intermediate system cache is implemented on the network between the identity service and the device to service identity requests and thereby reduce the load on the identity service. In one embodiment the system cache is provided by a content distribution network such as currently available from Akamai and other content distribution services.

As illustrated in if the system cache does not currently have a valid entry for user A it will forward the request to the identity service which will respond with 0 or more identities for user A as described above. In addition in the embodiment shown in the identity service generates a fingerprint for user A s identities and transmits the fingerprint back to the system cache. In one embodiment the fingerprint is a hash over the entities which comprise user A s identity i.e. A s canonicalized ID push token and timestamp . In one embodiment the hash is an SHA 1 hash although the underlying principles of the invention are not limited to any particular type of hash algorithm.

The fingerprint is then cached with user A s identities on the system cache as indicated in e.g. indexed using user A s canonicalized identities . In addition the fingerprint and associated IDs may be cached within the device cache on user B s device.

When user B subsequently needs to query for user A s identities user B will initially look within the device cache to determine whether a valid cache entry exists for user A s identities. In one embodiment each cache entry has a time to live TTL value associated therewith as determined by the timestamp column shown in . As long as the request for an identity occurs within a specified window of time from the timestamp then the entry in the device cache is valid and a query over the network is not required i.e. user B reads user A s identities from the device cache .

If however the cache entry within the device cache has expired i.e. is past the TTL value then user B transmits a query for user A s identities to the system cache which looks up the fingerprint for user A using user A s canonicalized ID code and transmits the fingerprint to the identity service along with the query for user A. If the fingerprint is still valid as determined by the identity service e.g. if the timestamp is still within a valid window of time then the only response required by the identity service is an indication of the fingerprint s validity. The system cache then returns its cached copy of user A s identities to user B as indicated in . The foregoing caching techniques save a considerable amount of processing resources that would otherwise be required to generate a new set of signatures over user B s and user A s identities.

In one embodiment the cache TTL value mentioned above may be configurable on a per application basis i.e. based on the security preferences of the application designer . Thus for example an application such as Facetime may be provided with a different TTL value than iChat . In addition the TTL value may be dynamically set based on current network conditions. For example if the network is currently overloaded with traffic then the TTL value may be set dynamically to a higher value so that the cached identity is valid for a longer period of time . In addition in one embodiment all of the caching techniques described above are implemented within an API exposed to application developers. As such the caching of identities occurs transparently to the applications which use them.

The embodiments of the invention described below provide techniques for securely mapping multiple types of identification codes such as phone numbers and email addresses to end users. By so doing the embodiments of the invention transparently provide users with improved flexibility when accessing online services and communicating with one another. In one embodiment a phone number registration process and user ID e.g. email address registration process are tied together cryptographically and used to identify the end user. This provides seamlessness because the same set of handles are used across multiple devices. Phone numbers are good for things like imessage if phone works everywhere it is transparent to you.

As illustrated in in one embodiment authentication provisioning and registration of a mobile device using a phone number occurs as described below 

Transaction 1 Request Authenticate The mobile device initiates the process by transmitting its push token to the identity service via the a short message service SMS communication channel. Because the message is received over SMS the identity service is able to determine the mobile device s phone number i.e. because this information is inherently included in the SMS transport . Once received the identify service generates a cryptographic signature over both the phone number and push token.

Transaction 1 Response Authenticate The identify service transmits the cryptographic signature back to the mobile device via SMS . The cryptographic signature is sometimes referred to herein as an authentication token. The mobile device may then use the authentication token to authenticate subsequent transactions with the identity service as described below .

Transaction 2 Request Provisioning During provisioning the mobile device transmits the authentication token generated in transaction 1 phone number and push token directly to the identity service over a data network.

Transaction 2 Response Provisioning In one embodiment the identity service generates the provisioning certificate over the phone number and push token of the mobile device and then transmits the provisioning certificate to the mobile device . Details related to the generation of the provisioning certificate have already been described above see e.g. and associated text .

Transaction 3 Request Registration In one embodiment the mobile device then transmits a registration request to register with the identity service . The request includes the provisioning certificate from transaction 2 a device fingerprint and the push token. In one embodiment the device fingerprint is a code which uniquely identifies the mobile device . Any technique for generating a unique fingerprint may be employed. However in one embodiment the fingerprint is generated using Fairplay DRM designed by the assignee of the present application. In one embodiment a fingerprint module reads portions of the hardware software of the mobile device and creates a signature over these items.

Transaction 3 Response Registration In one embodiment the identity service verifies the identity of the mobile device with the fingerprint and generates a new signature using the push token and phone number referred to herein as the identity certificate of user A. In one embodiment a fingerprint module executed on the identity service reconstructs the fingerprint for verification i.e. using the known hardware software features of the user device . As described above the identity certificate may be used to verify the identity of user A with any of the services on the network i.e. without the need for the services to individually contact the identity service for verification . The identity service then transmits the identity certificate back to the mobile device .

As illustrated in in one embodiment authentication provisioning and registration of a mobile device using a user ID such as an email address occurs as described below 

Transaction 1 Request Authenticate In one embodiment the mobile device transmits a user ID code e.g. email address an associated password and push token to the identity service via the data network. The data network may be the Internet a private network or a combination thereof.

Transaction 1 Response Authenticate In one embodiment the identify service uses the user ID code to look up or create an internal directory service ID code DSID for the user s account on the directory service i.e. stored in the directory service database . It then generates a cryptographic signature over the DSID and push token authentication token and transmits the authentication token and DSID back to the mobile device . The mobile device may then use the authentication token to authenticate subsequent transactions with the identity service as described below .

Transaction 2 Request Provisioning During provisioning the mobile device transmits the authentication token generated in transaction 1 DSID and one or more email addresses associated with the DSID code to the identity service over a data network. In one embodiment multiple email addresses may be associated with a single DSID code i.e. the user may have multiple email handles for a single user account . Thus the user may provision and register all email addresses in a single transaction.

Transaction 2 Response Provisioning In one embodiment the identity service generates the provisioning certificate over the DSID and push token of the mobile device and transmits the provisioning certificate to the mobile device. Details related to the generation of the provisioning certificate have already been described above see e.g. and associated text .

Transaction 3 Request Registration In one embodiment the mobile device then transmits a registration request to register with the identity service . The request includes the provisioning certificate from transaction 2 a device fingerprint and the push token. As mentioned device fingerprint is a code which uniquely identifies the mobile device based on specific features of the hardware software of the mobile device.

Transaction 3 Response Registration In one embodiment the identity service verifies the identity of the mobile device with the fingerprint and generates a new signature using the push token DSID and email addresses of the mobile device referred to herein as the identity certificate of user A. A fingerprint module on the identity service may generate the fingerprint based on the known hardware software features of the user device . The identity service then transmits the identity certificate back to the mobile device .

If the user subsequently connects to the identify service to register one or more user IDs from the mobile device the directory service will associate the DSID and associated user IDs e.g. email addresses in the database with the same fingerprint because the registration step is initiated by the same mobile device . In one embodiment the identity service will recognize that the same device fingerprint is associated with both a phone number and a DSID as well as one or more user ID s and will cause the directory service to link the two within the database .

In one embodiment the foregoing operations are accomplished using a modified provisioning step. For example when performing provisioning using a phone number SMS the mobile device will send a request to the identity service containing not only the phone number and authentication token as previously described but will also transmit the mobile device s DSID and user ID codes if available. Similarly when performing provisioning with user ID codes the mobile device will send a request to the identity service containing not only the DSID and user ID codes but will also transmit the phone number of the mobile device if available.

Regardless of how the association between phone numbers and ID codes is established once it is any new device provisioned and registered by the user will automatically be associated with both the registered phone number and user ID codes. For example assuming that an association between a phone number and one or more user ID codes has been established in the database for user device when the user sends an authentication request from a new user device or containing a valid user ID and password the identity service will collect all of the handles stored in the database for that user e.g. phone numbers email addresses DSID codes etc and send them to the new user device as part of the authentication response. The remaining steps of provisioning and registration of the new user device will then occur as described above but using both phone numbers and user ID codes. In one embodiment the fingerprint of the new user device will also be stored in the database and associated with the various handles.

In one embodiment to store the association between a phone number an a user ID the phone number of the mobile device is written into the user ID record within the database . It should be noted however that the underlying principles of the invention are not limited to any particular mechanism for associating a telephone number with a user ID.

Phone number user ID registration may occur in a reverse order from that described above. For example a non telephony device or telephony device may initially register with a user ID in the database and the same user may subsequently register via the telephone number of the telephony device . If the same telephony device is used for both transactions then the fingerprint of the telephony device may be used to automatically link the user IDs and phone numbers. Alternatively or in addition a message may be pushed to the non telephony device asking the user if the phone number should be associated with the non telephony device . If the user answers in the affirmative then the association between the phone number and user ID may be stored in the database as described above.

At a new user device attempts authentication with either a phone number or user ID. If authentication is successful determined at e.g. the user enters a correct password associated with the user ID or phone number then at all of the user handles associated with the user s account are retrieved from the directory database and transmitted to the new user device.

Embodiments of the invention provide various techniques for decoupling user IDs and phone numbers in response to certain events. In one embodiment when these events are detected a state machine on the identity service determines whether to decouple the user IDs phone numbers.

In one embodiment if a user logs out from all services with which the user is registered via either phone number or user ID then the identity service will decouple the phone number and user ID. For example the table shown in indicates whether the user is currently logged in to various services identified in rows with a phone number first column or a user ID second column . A Y in a column indicates that the user is currently logged in using either a phone number or user ID. If the user ever becomes logged out from all services using one particular type of handle i.e. one of the two columns contain no Ys an event is generated causing the state machine on the identity service to decouple the phone number from the user IDs within the directory service .

In one embodiment a heartbeat mechanism is provided for phone numbers. Specifically if the user device fails to connect to a service with a phone number for a specified period of time e.g. a week month etc then this will trigger the state machine on the identity service to decouple the phone number from the user IDs. Phone numbers are singled out for this embodiment because they tend to be more transient than user IDs i.e. phone numbers change more frequently as a user may move to different geographical locations or change service providers . Thus this embodiment automatically ensures that old unused phone numbers will be removed from the association.

In one embodiment any attempt by the user to change a password or remotely wipe the data from one of the user devices e.g. using an application such as find my iPhone will cause the state machine to decouple the phone number from the user IDs. A password change and or remote wipe operation generally signifies that the user has lost a particular device. Thus the decoupling will occur automatically in response to one of these events for security reasons.

As a result of the embodiments of the invention described above users may be located by other users with either a phone number or a user ID thereby improving the visibility of users on various network services. Additionally using the foregoing techniques an incoming phone call or Facetime connection request may be sent to all of a user s mobile devices concurrently and established on the device on which the user answers the phone call or connection request . Moreover the threads for messaging sessions may be linked across multiple devices more easily. For example SMS instant messaging and email between two users may be associated together into a single comprehensive messaging thread. When a user responds to a message the response will be updated on all the user s devices and potentially across all messaging applications regardless of the particular messaging application used for the response.

Embodiments of the invention may include various steps as set forth above. The steps may be embodied in machine executable instructions which cause a general purpose or special purpose processor to perform certain steps. Alternatively these steps may be performed by specific hardware components that contain hardwired logic for performing the steps or by any combination of programmed computer components and custom hardware components.

Elements of the present invention may also be provided as a machine readable medium for storing the machine executable program code. The machine readable medium may include but is not limited to floppy diskettes optical disks CD ROMs and magneto optical disks ROMs RAMs EPROMs EEPROMs magnetic or optical cards or other type of media machine readable medium suitable for storing electronic program code.

Throughout the foregoing description for the purposes of explanation numerous specific details were set forth in order to provide a thorough understanding of the invention. It will be apparent however to one skilled in the art that the invention may be practiced without some of these specific details. For example it will be readily apparent to those of skill in the art that the functional modules and methods described herein may be implemented as software hardware or any combination thereof. Moreover although embodiments of the invention are described herein within the context of a mobile computing environment i.e. using mobile devices the underlying principles of the invention are not limited to a mobile computing implementation. Virtually any type of client or peer data processing devices may be used in some embodiments including for example desktop or workstation computers. Accordingly the scope and spirit of the invention should be judged in terms of the claims which follow.

