---

title: GPU accelerated compositing on a multithreaded browser
abstract: A method for an accelerated rendering of graphics on a webpage. The method comprises providing a layer tree, wherein the layer tree includes a plurality of layers and is in a sandbox environment. The method further comprises identifying a dirty layer within the layer tree, and generating rendering data and the plurality of rendering instructions for processing the dirty layer. The method further comprises storing the rendering data and the plurality of rendering instructions in a storage region outside of the sandbox environment for processing using a graphics processing unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08913067&OS=08913067&RS=08913067
owner: Google Inc.
number: 08913067
owner_city: Mountain View
owner_country: US
publication_date: 20120206
---
This application claims the benefit of U.S. Provisional Application No. 61 448 088 filed on Mar. 1 2011 and is incorporated by reference in its entirety.

Conventionally web browsers rely on the central processing unit CPU to render content of the webpage. However as graphics processing units GPUs are becoming an integral part of every day computing devices such as smartphones tablet computing devices notebooks and laptops the graphics rich media such as 3D graphics and video are playing an increasingly important role in the user s web experience. One way to increase speed and efficiency of rendering graphics rich media on a computing device is for a GPU to process the content. For example processing graphics content on a GPU eliminates expensive and slow copies of large amounts of data to and from system memory. Additionally a GPU achieves a superior performance in processing complex 3D graphics and video as it is adept at handling complex mathematical computations that are common in 3D graphics and video manipulation in parallel.

Conventional browsers and renderers however operate in a sandbox environment. Because of the sandbox environment they are unable to issue calls that include graphics commands that manipulate data directly to the GPU.

Methods systems and computer readable medium designed to perform accelerated compositing of a webpage on a multi threaded browser and a GPU.

According to an embodiment a method for using a compositor to accelerate the rendering of the three dimensional 3D graphics using a GPU is provided. A method includes providing a layer tree wherein the layer tree includes a plurality of layers and is in a sandbox environment. A method further includes identifying a dirty layer within the layer tree. After the dirty layer is identified method further includes generating rendering data and rendering instructions for processing the dirty layer rendering instructions being in a platform independent language. The method further includes storing the rendering data and the rendering instructions in a storage region outside the sandbox environment for processing on a GPU to render on a webpage.

According to another embodiment the method includes determining whether the storage region has a memory space for storing rendering instructions and rendering data. When the storage region is full the method includes blocking rendering instructions and rendering data from being stored in the storage region.

According to another embodiment the method includes validating the bitmap and the rendering instructions. After the instructions are validated the method includes translating the rendering instructions into a platform dependent graphics language. The method further includes executing the translated instructions on the rendering data and displaying the result of the execution on a webpage.

Further features and advantages of the present invention as well as the structure and operation of various embodiments thereof are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

While the present invention is described herein with references to illustrative embodiments for particular applications it should be understood that the invention is not limited thereto. Those skilled in the art with access to the teachings herein will recognize additional modifications applications and embodiments within the scope thereof and additional fields in which the invention would be of significant utility.

Network may be any network or combination of networks that can carry data communication. Such a network may include but is not limited to a local area network medium area network and or wide area network such as the Internet. Network can support protocols and technologies including but not limited to World Wide Web protocols and or services. Intermediate web servers gateways or other servers may be provided between components of the system shown in depending upon a particular application or environment.

Web server is an electronic device capable of sending receiving and storing resources . Resources are any data that can be provided over network . Resources include data inserted into hypertext markup language HTML pages word processing documents portable document format PDF documents two and three dimensional images video feed sources and multimedia content to name only a few. In an embodiment web server receives a request such as an HTTP request from client and in response sends resources for display to client .

Web server hosts multiple websites . Website has one or more webpages associated with a domain name and hosted by one or more web servers . An example website is a collection of webpages formatted in a HTML that can contain resources described herein as well as various programming elements such as scripts.

Client is an electronic computing device capable of requesting receiving and displaying resources over network . Example clients are personal computers mobile communication devices e.g. smartphones tablet computing devices notebooks set top boxes game console embedded systems and other devices that can send and receive resources over network . Client includes a rendering module a browser a shared system memory a GPU processing module a GPU and a processor .

GPU is a specialized microprocessor that accelerates graphics rendering on client . GPU is efficient at graphics renderings due to its highly parallel architecture that is adept at processing complex mathematical algorithms common in graphics calculations and rendering.

Processor is any conventional or special purpose processor including but not limited to digital signal processor DSP field programmable gate array FPGA and application specific integrated circuit ASIC . Processor executes applications such as Browser and rendering module .

Browser is an application that client executes to display resources to a user. In an embodiment browser can be a multi threaded browser such as a CHROME browser available from Google Inc.

Rendering module shared system memory and GPU processing module facilitate an accelerated compositing environment on browser . is an exemplary embodiment of the accelerated compositing environment.

Rendering module and browser are applications that execute in a sandbox environment . Applications executing in a sandbox environment have limited access to system memory and other resources available to applications and processes that are executing outside of the sandbox environment on client . A person skilled in the art will appreciate that applications may execute in sandbox environment to protect a computing device such as client from computer viruses and other malicious software. For example when browser executes in a sandbox environment sandbox environment protects user s privacy from malicious software cookies and viruses that browser may download by preventing the downloaded software from obtaining unrestricted access to client s system memory.

In an embodiment instructions and data may be passed between applications internal and external to sandbox environment . For example rendering module communicates with GPU processing module by writing instructions and data into a specific memory location such as shared system memory . GPU processing module is able to access shared system memory and retrieve data and instructions written by rendering module .

When client receives messages that include visual content such as an HTML document that includes resources rendering module initiates the rendering process. Rendering module includes a layout engine and a compositor . Layout engine may be an open source engine such as WebKit. Layout engine receives resources in the HTML document and parses the HTML document into a document object model DOM tree. A person skilled in the art will appreciate that tree nodes in a DOM tree store HTML elements and associated text included in the HTML document.

Layout engine generates a rendering object for each node in the DOM tree that produces visual output. Each rendering object presents the content of each node to a display surface. A rendering object presents the content by for example storing draw calls that act on the contents of a corresponding DOM tree node. Those draw calls are interpreted by the GPU processing module and are executed using a GPU as described herein. In an embodiment the generated rendering objects are stored in a rendering object tree.

Layout engine also splits the visual content included in the rendering objects into multiple layers. Layout engine applies an algorithm to the rendering object tree that determines the rendering object s that may be included in each layer. In an embodiment rendering objects that are likely to change independently of the rest of the webpage content are included in a separate layer. For example when a DOM tree contains a node that includes an image with cascading style sheet CSS animation layout engine includes the image on a layer that is separate from the layer that includes the rest of the webpage. During animation the image is unlikely to change as it moves around the webpage whereas the content of the webpage is likely to change as the image moves around. However because the image is in a separate layer from the rest of the content layout engine can issue instructions that cause re rendering of a layer that includes the content but not the layer that includes the image.

In an embodiment layout engine may allocate a layer to a rendering object when the rendering object has explicit CSS position properties. In another embodiment layout engine may allocate a layer to a rendering object when it generates a transparent layer with a particular alpha mask or reflection. In another embodiment layout engine may allocate a layer to a rendering object when the rendering object includes instructions for a canvas element that has a 3D context or a video element.

Layout engine also generates a layer tree using the generated layers. In an embodiment the hierarchy of the layer tree indicates the rendering order of the layers on a webpage. The descendents of each parent node in the layer tree include layers that are visually contained within the parent node. Each child node of the parent node is sorted in an ascending order according to the depth index such as the z index. The child nodes that contain layers with a negative z index value are painted below the layer included in the parent node and the child nodes that contain a layer having a positive z index value are painted above the layer included in the parent node.

In conventional systems a conventional layout engine paints the contents of each layer in the layer tree sequentially to a single destination bitmap. Because each layer is painted to a single destination bitmap the entire webpage requires re rendering when a content of a single layer changes. Additionally because each layer is painted within the sandbox environment each layer is painted using a GPU which is inefficient at processing computationally heavy 3D graphics and video content. Moreover in conventional systems once the conventional layout engine paints a bitmap the bitmap is copied to a browser using a slow and computationally intensive memory transfer.

Compositor allows layout engine to use the GPU located outside of sandbox environment to process computationally heavy 3D graphics. Compositor causes layout engine to paint the contents of each layer into multiple bitmaps that are stored in shared system memory located outside of sandbox environment as described below. After the bitmaps are stored in shared system memory compositor determines the layers where content has changed and issues instructions that initiate the layer s re rendering. Because shared system memory stores layers in multiple bitmaps a change in one layer does not require re rendering of the entire webpage.

Compositor identifies each layer in the layer tree that requires re rendering a dirty layer by traversing the layer tree. A dirty layer is a layer whose content has changed and is no being displayed on a webpage. In an embodiment compositor traverses the layer tree using an in order traversal. A person skilled in the art will appreciate that in an in order traversal compositor recursively retrieves the layers in the left child of a parent node the parent node and then the right child of the parent node.

When compositor identifies a dirty layer compositor initiates a process that causes GPU processing module and GPU to re render the dirty layer. Because compositor is isolated from GPU processing module due to a sandbox environment compositor issues instructions that cause rendering module to store changes in a dirty layer also known as rendering data and rendering instructions described herein in shared system memory .

Shared system memory is a memory region on client that is accessible to applications executing in sandbox environment and to applications external to sandbox environment . Shared system memory allows rendering module to store rendering instructions and data for rendering each layer. Shared system memory also allows GPU processing module to retrieve those instructions and data for rendering on GPU .

Shared system memory includes a command buffer and a data region . Data region stores data such a bitmaps with textures vertex arrays etc. and rendering data that is associated with a dirty layer. For example when compositor identifies a dirty layer in the layer tree compositor causes layer engine to upload rendering data such as the contents or a portion of a dirty layer to a bitmap stored in data region .

Command buffer is a storage area that stores rendering instructions . GPU uses rendering instructions to re render dirty layers. In an embodiment rendering instructions are written in a platform independent graphics language that compositor and GPU processing module understand. In an embodiment the platform independent graphics language is a serialized version of OpenGL for embedded systems OpenGL ES such as OpenGL ES 2.0 API. A person skilled in the art will appreciate that OpenGL ES API is a graphics language designed for embedded devices such as mobile phones and video game consoles.

When compositor causes layer engine to upload rendering data to data region compositor also uploads rendering instructions to command buffer . An example rendering instructions that compositor uploads to command buffer are instructions that represent a dirty layer as a quad and instructions that represent a quad as a plurality of triangles. Another example rendering instructions are instructions that upload a bitmap to a texture.

Compositor also stores a data pointer in rendering instructions . The data pointer stores the memory address associated with rendering data that corresponds to rendering instructions .

In an embodiment command buffer is a circular buffer. A circular buffer includes a head pointer and a tail pointer that reference a memory region. In an embodiment when a head pointer points to the same memory address as a tail pointer command buffer is empty and does not include any rendering instructions that require processing. In another embodiment when the head pointer and the tail pointer are one address space apart the command buffer is full. When compositor determines that the command buffer is full compositor blocks and does not write additional rendering instructions into command buffer until there is free memory space in command buffer .

GPU processing module includes a validation module and a command translation module . GPU processing module uploads and processes rendering instructions and rendering data stored in shared system memory . For example GPU processing module requires rendering instructions that render a portion of a layer using a quad that includes triangles and rendering instructions that upload a bitmap to a texture.

Validation module prevents invalid rendering instructions and rendering data from reaching GPU . For example when rendering module is compromised and begins to issue incorrect rendering instructions validation module prevents those rendering instructions from being executed on GPU . Similarly when rendering module issues rendering data that includes undefined data corrupt data or rendering instructions validation module prevents rendering data from reaching GPU . A person skilled in the art will appreciate that examples herein are given by way of example and not limitation and that multiple validation techniques that validate rendering instructions and rendering data may be used.

Command translation module translates rendering instructions that are in a platform independent graphics language into a graphics language that is specific to the computing platform. For example the graphics language that executes on a Mac OS X or Linux computing platform may be different than the graphics language that may execute on Microsoft Windows. Additionally with increase of mobile computing devices such as smartphones tablets video game consoles etc. many traditional graphics languages include a lightweight application programming interface for rendering graphics on those portable devices.

In an embodiment when client includes a computing platform such as a Mac OS X or Linux command translation module translates the platform independent graphics language such as serialized OpenGL ES into Desktop GL. In another embodiment when client includes a computing platform such as Microsoft Windows command translation module translates the platform independent graphics language into Microsoft s Direct 3D D3D . In an embodiment where GPU is operable to execute a platform independent graphics language command translation module forwards rendering instructions and rendering data for rendering to GPU .

GPU renders a webpage or re renders a webpage using translated rendering instructions and rendering data . For example GPU applies translated rendering instructions to rendering data and modifies the content of the dirty layer into a new layer. After GPU modifies the dirty layer GPU re composites the dirty layer with existing layers and draws the result directly to the display screen associated with client .

In an embodiment system includes an inter process communication channel IPC channel . IPC channel enables GPU processing module to communicate with compositor executing inside of sandbox environment when compositor issues rendering instructions which return a result from GPU processing module or from GPU . One example of such a rendering instruction is an instruction that returns a value calculated by GPU or a parameter that returns a state of GPU . Compositor may use the returned result to for example issue additional rendering instructions or traverse a layer tree.

At stage a message is received from a web server. For example rendering module receives a message from web server . The message may include for example resources embedded in an HTML document.

At stage a DOM tree is created. For example rendering module builds a DOM tree and a rendering object tree from a message received in stage . As described herein each node in a DOM tree that includes visual content has a corresponding rendering object in a rendering object tree.

At stage a layer is determined from one or more rendering objects. For example layout engine determines the rendering objects in the rendering object tree that are included in each layer.

At stage a layer tree is generated. For example layout engine builds a layer tree from the layers determined in stage . As described herein each layer is a node in a layer tree. The order of each node determines the rendering order of each layer on a webpage.

At stage dirty layers are identified. For example compositor traverses the layer tree and identifies dirty layers. As described herein dirty layers are layers that include content that has changed and is not being displayed on a webpage.

At stage rendering data and rendering instructions for each dirty layer are determined. For example compositor determines the rendering data associated with the dirty layer and rendering instructions . is a flowchart of a method for determining rendering instructions and rendering data .

At stage rendering instructions and rendering data are uploaded into shared system memory. For example compositor stores rendering instructions and rendering data associated with each dirty layer in shared system memory . At stage compositor also generates a data pointer that contains the memory address of rendering data and includes the pointer in rendering instructions . As described herein shared system memory is a storage area outside of sandbox environment . As compositor completes stage rendering instructions and rendering data leave the boundary of sandbox environment and are accessible to GPU processing module .

At stage rendering data for a dirty layer is generated. For example layout engine determines rendering data as a portion of a dirty layer that is uploaded to a bitmap or generates a vertex array for the dirty layer.

At stage rendering instructions that manipulate rendering data of stage are generated. For example compositor generates rendering instructions that may upload rendering data such as bitmap of stage to a texture. In another example as described herein compositor may generate rendering instructions that create a quad or a triangle representation of a layer in a platform independent graphics language such as a serialized version of OpenGL ES.

At stage instructions and rendering data are retrieved from a shared system memory. For example GPU processing module retrieves rendering instructions and rendering data from shared system memory .

At stage rendering instructions and rendering data are validated. For example validation module validates rendering instructions and rendering data . If validation module determines that rendering instructions or rendering data are corrupt or incorrect flowchart ends.

At stage rendering instructions are translated. For example command translation module translates rendering instructions from instructions in the platform independent graphics language into instructions in a graphics language that is compatible with a computing platform executing on client .

At stage translated rendering instructions are processed. For example GPU processes the translated rendering instructions and rendering data . At stage GPU also recomposites the processed data with the data from the unmodified layers.

Web server and client can include one or more computing devices. According to an embodiment web server and client can include one or more processors one or more non volatile storage mediums and one or more memory devices a communication infrastructure a display screen and a communication interface . Processors can include any conventional or special purpose processor including but not limited to digital signal processor DSP field programmable gate array FPGA and application specific integrated circuit ASIC .

GPU is a specialized processor that executes instructions and programs selected for complex graphics and mathematical operations in parallel.

Non volatile storage can include one or more of a hard disk drive flash memory and like devices that can store computer program instructions and data on computer readable media. One or more of non volatile storage device can be a removable storage device. Memory devices can include one or more volatile memory devices such as but not limited to random access memory. Communication infrastructure can include one or more device interconnection buses such as Ethernet Peripheral Component Interconnect PCI and the like.

Typically computer instructions executing on web server or client are executed using one or more processors and can be stored in non volatile storage medium or memory devices .

Display screen allows results of the computer operations to be displayed to a user or an application developer.

Communication interface allows software and data to be transferred between computer system and external devices. Communication interface may include a modem a network interface such as an Ethernet card a communication port a PCMCIA slot and card or the like. Software and data transferred via communication interface may be in the form of signals which may be electronic electromagnetic optical or other signals capable of being received by communication interface . These signals may be provided to communication interface via a communication path. A communication path carries signals and may be implemented using wire or cable fiber optics a phone line a cellular phone link an RE link or other communications channels.

Embodiments may also be directed to computer program products comprising software stored on any computer useable medium. Such software when executed in one or more data processing device causes a data processing device s to operate as described herein. Embodiments of the invention employ any computer useable or readable medium. Examples of computer useable mediums include but are not limited to primary storage devices e.g. any type of random access memory secondary storage devices e.g. hard drives floppy disks Co ROMS ZIP disks tapes magnetic storage devices and optical storage devices MEMS nanotechnological storage device etc. .

The embodiments have been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teachings and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The Summary section may set forth one or more but not all exemplary embodiments as contemplated by the inventor s and thus are not intended to limit the present invention and the appended claims in any way.

The breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

