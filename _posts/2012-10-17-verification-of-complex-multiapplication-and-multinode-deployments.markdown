---

title: Verification of complex multi-application and multi-node deployments
abstract: Systems and methods are disclosed for identifying software components stored on one or more virtual machines (VM). An installation directory is traversed and an ordered installation index of file paths and content identifiers are created for the files thereof. The installation index may be transmitted to a client that accesses artifact indexes for artifacts of software installed on the VMs. The artifact indexes include file paths and content identifiers for the fields of the artifact. Where all artifacts of a software package are found in the installation index, the package is deemed to be installed and a portal for accessing the VM may be updated to so indicate. The software packages found to be installed on a VM may be evaluated with respect to an application manifest to verify proper provisioning according to the manifest.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09058330&OS=09058330&RS=09058330
owner: WAL-MART STORES, INC.
number: 09058330
owner_city: Bentonville
owner_country: US
publication_date: 20121017
---
This invention relates to systems and methods for managing an application installation and associated resources.

Today s applications are very complex both in terms of actual functionality and in the number of components that must interact in order to provide a computing service. In particular applications often require various external resources to facilitate their operation. Often these resources are standardized software modules or systems such as databases web servers and the like. The deployment of applications has also recently been facilitated by using commoditized services such as a Platform as a Service PaaS that provides the capability to provision the different artifacts of a computing platform on demand such as an operating system database web server file system storage and network resources where applications can be deployed. Typically the PaaS also interacts with an IaaS component to provision the virtual machines or compute power before the software can be deployed.

The following detailed description provides scalable and improved systems and methods for verifying the overall installation of a complex application including multiple software components and dependencies therebetween across a set of virtual machines typical of software deployments in the cloud.

It will be readily understood that the components of the present invention as generally described and illustrated in the Figures herein could be arranged and designed in a wide variety of different configurations. Thus the following more detailed description of the embodiments of the invention as represented in the Figures is not intended to limit the scope of the invention as claimed but is merely representative of certain examples of presently contemplated embodiments in accordance with the invention. The presently described embodiments will be best understood by reference to the drawings wherein like parts are designated by like numerals throughout.

The invention has been developed in response to the present state of the art and in particular in response to the problems and needs in the art that have not yet been fully solved by currently available apparatus and methods.

Embodiments in accordance with the present invention may be embodied as an apparatus method or computer program product. Accordingly the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a module or system. Furthermore the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.

Any combination of one or more computer usable or computer readable media may be utilized. For example a computer readable medium may include one or more of a portable computer diskette a hard disk a random access memory RAM device a read only memory ROM device an erasable programmable read only memory EPROM or Flash memory device a portable compact disc read only memory CDROM an optical storage device and a magnetic storage device. In selected embodiments a computer readable medium may comprise any non transitory medium that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on a computer system as a stand alone software package on a stand alone hardware unit partly on a remote computer spaced some distance from the computer or entirely on a remote computer or server. In the latter scenario the remote computer may be connected to the computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

The present invention is described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions or code. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instruction means which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The VM systems may be accessible may means of a portal . In some embodiments the functionality of the portal may be provided by a VM system . For example the portal may be operably connected by any networking protocol or component attachment protocol to both the VM systems and one or more clients . A client may be a set of virtual machines in itself having computational power and storage running software shown in . In some embodiments the ability to verify a software installation may exist as an action within the user interface of the portal . In some embodiments a client may also automatically trigger verification of installation through the portal via a REST API call that the portal would expose.

Computing device includes one or more processor s one or more memory device s one or more interface s one or more mass storage device s one or more Input Output I O device s and a display device all of which are coupled to a bus . Processor s include one or more processors or controllers that execute instructions stored in memory device s and or mass storage device s . Processor s may also include various types of computer readable media such as cache memory.

Memory device s include various computer readable media such as volatile memory e.g. random access memory RAM and or nonvolatile memory e.g. read only memory ROM . Memory device s may also include rewritable ROM such as Flash memory.

Mass storage device s include various computer readable media such as magnetic tapes magnetic disks optical disks solid state memory e.g. Flash memory and so forth. As shown in a particular mass storage device is a hard disk drive . Various drives may also be included in mass storage device s to enable reading from and or writing to the various computer readable media. Mass storage device s include removable media and or non removable media.

I O device s include various devices that allow data and or other information to be input to or retrieved from computing device . Example I O device s include cursor control devices keyboards keypads microphones monitors or other display devices speakers printers network interface cards modems lenses CCDs or other image capture devices and the like.

Display device includes any type of device capable of displaying information to one or more users of computing device . Examples of display device include a monitor display terminal video projection device and the like.

Interface s include various interfaces that allow computing device to interact with other systems devices or computing environments. Example interface s include any number of different network interfaces such as interfaces to local area networks LANs wide area networks WANs wireless networks and the Internet. Other interface s include user interface and peripheral device interface . The interface s may also include one or more user interface elements . The interface s may also include one or more peripheral interfaces such as interfaces for printers pointing devices mice track pad etc. keyboards and the like.

Bus allows processor s memory device s interface s mass storage device s and I O device s to communicate with one another as well as other devices or components coupled to bus . Bus represents one or more of several types of bus structures such as a system bus PCI bus IEEE 1394 bus USB bus and so forth.

For purposes of illustration programs and other executable program components are shown herein as discrete blocks although it is understood that such programs and components may reside at various times in different storage components of computing device and are executed by processor s . Alternatively the systems and procedures described herein can be implemented in hardware or a combination of hardware software and or firmware. For example one or more application specific integrated circuits ASICs can be programmed to carry out one or more of the systems and procedures described herein.

In some embodiment the introspector operates within a servlet container operating in the same or different computer system as a VM being analyzed. The servlet may operate with permissions of a read only user in some embodiments. In some embodiments the servlet may be deployed at ROOT and therefore URLs exposed by the servlet may be perceived as a utility to the VM rather than as an application. The introspector may operate within the servlet container to prove a web server type functionality whereby the introspector exposes a URL unique to a VM and responds to HTTP requests at the URL with information as described below. The introspector such as the servlet container hosting the introspector may operate in a thread that is of low priority. The URL exposed to enable access to the introspector may be an obscure port e.g. somewhere in the higher ranges of ports within a computer system that is less than 65535 that is unlikely to carry production or payload traffic of the application that is installed on VM corresponding to the introspector .

In particular the introspector by means of a URL or some other method provides information from or access to an installation index . The installation index is derived from the software installation . The software installation may be organized as a directory tree such that the introspector traverses the directory tree and adds entries to the installation index for files encountered in the installation directory. For example entries in the installation index may be created by the introspector that include some or all of the file path for a file in the software installation and a checksum hash or other value derived by the introspector or some other component from the contents of the file and uniquely identifying the contents of the file.

The client may communicate with the introspector through the portal . This may be via a REST API that the portal would expose. The client may include one or more components or modules for performing methods disclosed herein. For example the client may include an aggregator indexer comparator and a validator .

As noted above software components that are dependent on one another may be hosted on different VMs on different VM systems . Accordingly the aggregator may be operable to request installation indexes from each VM on each VM system for which dependencies exist and for which evaluation is desired. As will be discussed in greater detail below an application manifest may define a number of software components which may include VMs themselves that may be provisioned to support an application. The application manifest may be an application manifest as described in U.S. patent application Ser. Nos. 13 631 177 13 631 203 13 631 323 filed Sep. 28 2012 which are hereby incorporated herein by reference in their entirety for all purposes. Accordingly the aggregator may request and receive installation indexes for each VM implicated by the application manifest as having a software component that was provisioned or otherwise allocated or used according to the application manifest.

The indexer may be operable to characterize or otherwise analyze an installation repository . The indexer may characterize all directories of the VM or only those that contain applications or application artifacts. An installation repository may store one or more artifacts that are part of one or more application packages . As known in the art an artifact may include a collection of files or directory of files that has been packaged and or compressed and may be used in one or more software packages. For example an artifact may be a .jar .tar .war .ear file or the like. The installation repository may also store the application manifest . Alternatively the client may retrieve the application manifest from another location for use in accordance with the methods disclosed herein.

The indexer may generate a repository index according to the analysis of the files of the installation repository . In some embodiments artifacts may be expanded and the files thereof may be analyzed. An index file may be generated for each artifact or for a group of artifacts corresponding to a specific application package .

A comparator evaluates the installation index or installation indexes from multiple VMs with respect to the repository index and identifies software packages installed on the VMs according to the comparison such as according to methods described in further detail with respect to . A validator compares identified application packages with those that are required according to the application manifest. If the validator finds that a application package is not present a report or some other alert indicating which application package is not present may be generated and stored or transmitted for display to an administrator.

In some embodiments to avoid slowing production processing of the VM only one request for an installation index will be processed at a time. Accordingly when a request is received a running flag may be evaluated. If the flag indicates that a previous request is still being processed then the request received will be ignored. If the flag does not indicate that a previous request is being processed or when the received request is retrieved from the queue then the remainder of the method may be executed with respect to the received request. The remainder of the method may be executed in a low priority thread. A low priority thread may be spawned in response to each received request so as to not disrupt the production application that is possibly running on the VM .

Once a request is selected for processing the directories of a VM may be traversed to identify files. The directory traversed may be rooted at a directory corresponding to the VM instance corresponding to the introspector processing the request. Traversing the directory may include traversing the directory and identifying all file paths in the directory. The file paths may additionally be sorted such as in ascending order. The file path may include the name of a file as well as the path in a directory to a starting directory for the instance.

Each file path may then be evaluated and the files in the file path processed to generate an identifier uniquely identifying the file such as a checksum or hash of the file. The generated content identifier may be stored in the installation index such as in a pair. Once entries have been generated for all files the index may be sorted such as in ascending order by file path. The method may then include transmitting the installation index to the requesting component such as a client or the aggregator of a client .

The method may include identifying unindexed artifacts groups of artifacts or versions of artifacts. This may include identifying those software packages artifact groups or individual artifacts were not previously indexed. In some embodiments once a software package artifact group or artifact is indexed according to the method a record of this fact and a file path of the artifact may be recorded in a persistent file or artifact map that is referenced when performing the method . Accordingly identifying unindexed artifacts may include comparing artifacts software packages groups of artifacts present in a repository to this persistent file.

For those artifacts that have been identified as unindexed the method may include expanding the artifacts. This may include extracting the artifacts using a decompression algorithm where the artifacts have been compressed. Expanding an artifact may additionally include extracting the files and directories of the artifact from any package format used to create the artifact. Once an artifact is expanded an artifact index may be generated for the files of each artifact. This may include generating an index file including for each file of the artifact a file path which may include the file name and a content identifier for each file in the artifact. The file path may include the file path in accordance with the directory structure that was preserved within the artifact and may include parent directories of the artifact itself. The content identifier may be any code that uniquely identifies the content of the file such as a checksum or hash. The artifact index may be stored or referenced under a title that includes one or more of a group identifier for a group to which the identifier belongs the name of the artifact and a version number of the artifact.

In some embodiments steps may be repeated periodically and independent of any particular request to verify the installation on a VM . For example standalone process may be initiated every N days to perform steps with respect to a repository. For example a standalone java class may be instantiated through a job scheduler to perform steps with respect to an installation repository every N days e.g. every two days.

The remainder of the method may also be performed periodically or may be invoked by a user or some other software component in response to detection of failure to determine whether a cause of the failure was due to improper installation. For example the method may include requesting and receiving the installation indexes from one or more VMs . For example installation indexes may be requested from all VMs having software components executing thereon that are part of an interdependent system such as one provisioned or defined according to an application manifest. The aggregator may generate the requests. As noted previously the introspector may expose a URL and operate as a web server. Accordingly requesting installation indexes may include requesting the URL corresponding to a particular VM . As known in the art of HTTP protocol the process requesting the URL may be configured asynchronously such that the client does not block while waiting for the installation indexes from the introspector .

The received installation indexes may be aggregated and compared to the repository index such as a repository index that has been previously generated . Comparing the indexes may include attempting to identify each of the files of each artifact of each software package. If all the files for a software package or group of artifacts are found to be represented in the installation indexes or an aggregation of installation indexes the software package or group may be deemed to have been installed successfully. If not then the software package or group may be deemed not to have been installed.

In some embodiments a persistent file stores an artifact map that is updated or generated during the generation of the repository index. The repository map may store a file path including file name for the artifacts that were previously indexed. For each of these entries the installation index or aggregation of installation indexes may be searched to identify the entry in the installation index or aggregation of installation indexes.

If the file path of an artifact recorded in the artifact map is found in the installation index then the artifact index i.e the artifact with the correct group identifier artifact identifier and version identifier corresponding to that file path may be retrieved and the installation index may be searched to identify the entries of the artifact index in the installation index. If all entries of the artifact index are found e.g. a checksum corresponding to the files of the artifact index were found in the installation index then the artifact may be deemed to be properly installed if not then the artifact is deemed not to have been installed. Inasmuch as the indexes artifact index and installation index may have been sorted if a particular file is not found in the expected place in the listing of files in the installation index further search for the files of an artifact index may be stopped. As soon as the files of an artifact have been mapped to entries of the installation index those entries may be removed from the installation index in order to reduce searching time for subsequent artifacts. The file paths of the artifact map may be continue to be evaluated until no more matches are found in the installation index.

In some embodiments where multiple instances of the same application VM or VM image including one or more installed software components are installed on multiple VMs evaluating of the installation indexes corresponding thereto may be accelerated. For example once a first installation index has been compared to the repository index a second installation index for an identical image may be evaluated by comparing the checksum thereof to the checksum of the first installation index. If they are not identical then the second installation index may be compared to the repository index as described above to identify any artifacts that may be missing.

Once all of the entries of the artifact map have been found to be absent in the installation index or the corresponding artifact indexes compared to the installation index then any artifacts found to be completely present may be evaluated to identify software packages that were found to be installed on the VM or VMs from which installation indexes were received. This may include comparing the identifiers of artifacts found to lists or groupings of artifacts corresponding to a particular software package. If all artifacts for a software package are found to be present then the software package may be deemed to be installed otherwise not. Where some but not all artifacts of a software package are found to be present the absent artifacts thereof may be reported or recorded for later diagnosis.

In some embodiments a portal by which a VM is accessed maintains for each VM a record of all software installed on a VM . Accordingly once the identity of software properly installed on a VM has been identified the records used by the portal may be updated to reflect the software identified for each VM accessed thereby.

In some embodiments the list of identified software for a VM may be compared to an expected list of software. Where a software package is absent or not properly installed then errors or alerts may be generated and transmitted for display to a user and or saved for later diagnosis. Where VM or group of VMs are provisioned or set up according to an application manifest the identified may be evaluated with respect to the application manifest to identify whether the software to be provisioned according to the manifest was actually installed on the one or more VM . Where a software component is found not to have been installed properly a report or alert may be generated and transmitted for display to an operator and or stored for later diagnosis.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

