---

title: Shared script files in multi-tab browser
abstract: A cloud-based server executes instances of a browser application responsive to requests from a plurality of user devices. The server interprets embedded code in a web document retrieved by a given browsing instance, and stores an intermediate representation of the embedded code in the web document in a dedicated memory resource associated with the given browsing instance. The server also stores the intermediate representation of an external file referenced by the web document in a shared memory resource such that the intermediate representation is accessible to the other browsing instances of the other user devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471704&OS=09471704&RS=09471704
owner: Telefonaktiebolaget LM Ericsson (publ)
number: 09471704
owner_city: Stockholm
owner_country: SE
publication_date: 20120925
---
This application is a Continuation In Part application of and claims priority to U.S. patent application Ser. No. 12 574 077 filed Oct. 6 2009 and entitled SHARED SCRIPT FILES IN MULTI TAB BROWSER the entire contents of which are incorporated herein by reference.

The present invention relates generally to cloud based servers that execute web browsers and more particularly to a server based mechanism for sharing intermediate representations of commonly used script files between different tabs windows frames panels or other browser display components for viewing web content.

JavaScript is a well known scripting language used to allow computer applications to access software objects within other applications. When first invented JavaScript comprised code snippets that were sparsely embedded in a web page and was used to manipulate the Document Object Model DOM . JavaScript has since matured and is now used in a more library like manner. That is instead of embedding JavaScript code among other HyperText Markup Language HTML code in a given web page JavaScript code is encapsulated in separate files. Each file may be associated with a different functionality or set of features and is included in the web pages. In this manner a given JavaScript file can be included in different web pages and one web page can include more than one JavaScript file. This helps improve the reusability and modularity of JavaScript .

By way of example the common features of a website such as common user interface logic may be provided as separate JavaScript files. These files are included in multiple web pages within a website and provided to a user when the user accesses the website. Thus when the user interacts with one web page to enter data for example the user is presented with a user interface having generally the same look and feel as the other web pages in the website.

The Apple website illustrates this type of usage very well. Particularly it puts most of its JavaScript code into several JavaScript files in a modular manner. Then it uses the same JavaScript files across several different web pages to provide the same or similar functionality across those web pages. At the time of writing Apple s home page www.apple.com Apple s Mac page www.apple.com mac and Apple s iPhone page www.apple.com iphone include seven 7 of the same JavaScript files while the Mac and iPhone pages themselves share three 3 additional JavaScript files between them.

Typically web pages import JavaScript files within the same domain website. In addition however web pages can also import JavaScript files from one or more different domains websites. For example Google Maps Facebook and other such services provide JavaScript Application Programming Interfaces APIs so that other developers can develop applications that access the services provided by their JavaScript files. In such cases the JavaScript files would be located at google.com or facebook.com or some other common repository and included in the web pages from other websites that intend to use Google Maps or Facebook services.

Additionally there is another category of standalone JavaScript files that are used as libraries. Some examples include but are not limited to Prototype JQuery and Yahoo UI YUI Library. These libraries wrap up common logic into related files and abstract the interfaces used to manipulate web pages. Such libraries make creating and building web pages easier and more maintainable. A large number of well known websites some of which are listed by the Pingdom website http royal.pingdom.com 2008 06 11 javascript framework usage among top websites for example are now using such JavaScript libraries to facilitate the construction and maintenance of websites.

Currently most web browsers support the opening of multiple web page instances simultaneously. For example a web browser that opens a web page containing frames in framesets or iframes which load other web pages maintain multiple web page instances. Another example is the multi tab browser. As is known in the art a multi tab browser allows multiple tabs to be open at the same time in a single browser window. Each tab is a display component of a web browser that allows a user to view web content such as a web page. Additionally other display components exist that are able to display web content. Such components include but are not limited to windows frames and panels or other construct that enables a user to view and interact with web content. However for simplicity sake each of these different components are referred to herein as tab or display component. 

Typically multi tab browsers execute on single end user devices such as a desktop or laptop computer. However even resource limited devices such as mobile devices provide multi tab browser functionality. For example the iPhone and iPod provide their users with the Safari browser. Similarly Android provides the WebKit based browser. Such browsers although they may not actually visually display multiple tabs still provide the multi tab functionality. In addition there is now an ongoing trend in that each tab executes as its own separate process to facilitate stability and security while the core functions of the browser execute as another process. Some examples of modern browsers that use this approach are Google Chrome and Microsoft s Internet Explorer IE 8.

Based on the current trends of importing external JavaScript files and the use of multi tab browsing as described above there is a high probability that web pages opened in multiple tabs will include or use the same JavaScript files. Such a situation is likely to happen for example when a user clicks a link in one tab to open a new tab that loads a different web page from the same website. In these cases some of the JavaScript files included with the web page in the newly opened tab are likely to be the same as those included with the web page in the current tab. In another scenario a user may simultaneously open a plurality of tabs each loading a different website. The web pages in each different tab may all use a common set of services from another entity such as Google Maps or Facebook and therefore include the same JavaScript files from Google Maps or Facebook. In yet another scenario the web pages in different tabs may all use third party JavaScript libraries such as Prototype or JQuery and therefore include copies of the same JavaScript files.

JavaScript is used in an increasingly library like manner. This trend continues to strengthen due at least in part to the increased use of HTML5 and the need to optimize different web sites for use with an array of different types of devices having different form factors e.g. the different screen sizes for a smartphone and an iPad . Such needs help to fuel the development of a variety of different JavaScript libraries to perform these functions. Thus the size of external JavaScript files tends to increase and the logical structure of the JavaScript files tend to become more complex.

Still given these facts no one has attempted to optimize the resource usage and performance of a browser. Where different tabs include the same JavaScript files the browser will repeat the parsing of each file to the JavaScript syntax tree and just in time JIT compile the files to bytecode. Additionally largely same copies of the data structures will also be stored in multiple places in the memory.

As previously stated web browser applications are typically executed on a single user device. However there is a growing trend towards executing browser applications on a server disposed in a cloud network. Particularly a cloud based server executes the core browser functionality including interpreting the JavaScript files parsing a given web page into the DOM tree and constructing a render tree from the DOM tree. The user device renders the visual elements contained in the render tree in the order specified by the render tree. The render tree is persistently synchronized between the cloud and the user s device to ensure that the user s device has the most up to date rendering information.

Executing a browser application on a cloud based server does not solve the issues mentioned above with respect to executing the browser application on a single end host device. In fact migrating the execution of the browser to the cloud network may complicate these issues and make the problems worse. Particularly a cloud based server permits connections between the browser application and many different end host devices each of which will likely access many different web pages and related files. Because the browser applications still may not utilize JavaScript files as libraries a browser application executing on a cloud based server could also repeat the parsing of a JavaScript file to the JavaScript syntax tree and JIT compile the file to bytecode even though that same JavaScript file may have already been parsed and JIT compiled for another tab. Further like a user device a browser application executing on a cloud based server could store many of the same data structures in multiple places in memory. Considering the number of different user devices that may simultaneously connect to the browser application executing on the server the amount of memory and other resources that the user devices could use when using the browser application is concerning.

The present invention provides a mechanism that allows multiple instances of a browser window such as a tab a window a frame or a panel for example executing on a cloud based server to share the intermediate representations of commonly utilized JavaScript files. According to one or more embodiments such sharing between browsing instances occurs between multiple browsing instances associated with a single user device as well as between multiple browsing instances associated with different user devices.

In one embodiment the cloud based server comprises a communication interface to communicate data with a plurality of different user devices via a communications network. A memory at the server stores a web browser application. The server also includes a controller that executes one or more browsing instances of the browser application responsive to receiving corresponding requests from one or more of the user devices. Particularly the controller interprets embedded code in a web document retrieved by a first browsing instance generates an intermediate representation of the embedded code in the web document and stores the intermediate representation of the embedded code in a corresponding dedicated memory resource associated with the first browsing instance. The controller then determines whether the intermediate representation of an external file referenced by the web document is stored in a shared memory resource accessible to other browsing instances associated with one or more other user devices. If the intermediate representation of the external file is not stored in the shared memory resource the controller fetches the external file generates the intermediate representation of the external file and stores the intermediate representation of the external file in the shared memory resource.

Of course those skilled in the art will appreciate that the present invention is not limited to the above contexts or examples and will recognize additional features and advantages upon reading the following detailed description and upon viewing the accompanying drawings.

Referring now to the drawings illustrates an exemplary architecture for a multi tab web browser in accordance with one embodiment of the present invention. The web browser is an application program that runs on a host device having processing and memory resources for executing software applications. The host device may comprise for example a general purpose programmable computer a smart phone or personal digital assistant.

The main components of the web browser comprise a browser engine a networking subsystem a JavaScript interpreter and an eXtensible Mark up Language XML parser display back end and data store . The browser engine loads Uniform Resource Identifiers URIs and supports a variety of different browser actions such as forward back and reload. The browser engine also provides various hooks for viewing aspects of a browsing session such as current page load progress. As seen in the browser engine may comprise or interface with other components such as a rendering engine and a user interface layer . The rendering engine produces a visual representation of a web page described in a language such as HTML and XML code. The user interface is the software layer between the user and the browser engine and provides user interface components e.g. toolbar progress meters etc. and services to the desktop environment or operating system. The networking subsystem implements file transfer protocols such as HTTP and FTP. The JavaScript interpreter evaluates and processes JavaScript code embedded in web pages and JavaScript code from the external JavaScript files. The XML parser parses XML documents into a document object model DOM .

Those skilled in the art will understand that although not specifically shown in the figures many browsers will also include other components. One such component is a display back end that provides a set of fonts and user interface widgets which may be used by the user interface. Another component is a data store that stores data associated with browsing activity such as bookmarks toolbar settings cookies and cached files. Both of these components could for example communicate with the browser engine via the user interface .

Memory represents the entire hierarchy of memory in host device and may include both random access memory RAM and read only memory ROM . Software programs and data required for operating host device may be stored in non volatile memory such as EPROM EEPROM and or flash memory and may be implemented as discrete devices stacked devices or integrated with controller . The software programs may include an operating system such as WINDOWS XP or NT UNIX LINUX APPLE COMPUTER S OS X and the like. The software programs may also include user application programs that perform some function for the user. In one embodiment for example memory stores browser that allows a user to connect to and interact with the Internet.

The UI comprises a display and an input device . Display may comprise a traditional CRT monitor a liquid crystal display LCD a plasma screen or the like or may comprise a display sized for a mobile communication device. Controller may output the results obtained from executing the present invention to the display for viewing by the user. The input device may include inter alia a keyboard and or a pointing device such as a mouse or a keypad for smaller mobile devices. The user input device permits a user to enter commands data and generally control the operation of host system .

Host device may further include a communication interface to communicate with one or more remote parties via a communications network. The communications interface comprises a transceiver that allows the host device to communicate with one or more remote parties via a communication network. In one embodiment the communications interface comprises a fully functional cellular radio transceiver that can operate according to any known standard including the standards known generally as the Global System for Mobile Communications GSM cdma2000 Universal Mobile Telecommunications System UMTS Wideband Code Division Multiple Access WCDMA 3GPP Long Term Evolution LTE and Worldwide Interoperability for Microwave Access WiMAX . In other embodiments the communications interface may comprise a suitable interface includes an Ethernet based interface adapter cards such as 10 BASE T Fast Ethernet 10 GbE or the like for example that connects host device to a packet data communications network. In yet other embodiment the communication interface may comprise a wireless LAN 802.11x interface or is a wireless interface card operating according to WiFi standards e.g. IEEE 802.11 or BLUETOOTH. Those skilled in the art will appreciate that the interfaces listed herein does not comprise an exhaustive list and that there are many additional interfaces that may be used to connect host device to a communications network.

As previously stated the present invention provides a mechanism that allows browser to share the intermediate representation of external JavaScript files among multiple tabs windows frames panels or other display components in the web browser. The intermediate representation includes but is not limited to the content of the JavaScript file the resultant syntax tree the variable list i.e. the symbol table and in some embodiments the bytecode. Additionally the present invention may allow the multiple display components to share data structures and other related data generated from the external JavaScript files that are used by browser to interpret the JavaScript . Such a mechanism will help to reduce memory usage and significantly improve the performance of both web page rendering and JavaScript execution during multi tab browsing. This is particularly beneficial for resource limited devices like mobile devices.

The intermediate representations of the JavaScript files are pulled from the intermediate representations of the JavaScript code embedded in tabs . The intermediate representations are then saved separately in an external JavaScript files pool . Once stored the intermediate representation of embedded JavaScript in the browser tab links to that of JavaScript files and in external JavaScript files pool while the intermediate representation of embedded JavaScript in the browser tab links with that of JavaScript file in external JavaScript files pool . As a result host device does not need to repeatedly parse JavaScript file to a JavaScript syntax tree. Nor does host device need to just in time compile the file to bytecode for both browser tabs and . Further only one instance of the intermediate representation of JavaScript file is saved to memory that all browser tabs can access. This saves memory resources over the conventional method of allocating memory for each browser tab that uses the JavaScript files. This also reduces execution time over the conventional method of compiling JavaScript code and just in time compiling to bytecode repeatedly for each browser tab that uses the JavaScript files.

Since JavaScript is an interpreted language the controller will instantly execute the JavaScript code as the interpreter parses the code. More particularly the JavaScript interpreter resident on host device will first parse the JavaScript code to produce an intermediate representation format like the syntax tree box . A syntax tree is a tree based multi node data structure that represents the grammatical structure of the original JavaScript language. Each node of the tree denotes a unit of expression or statement. Once the syntax tree is created the interpreter recursively traverses the tree and performs the operation corresponding to each node while propagating the execution context state along the traverse box . Some operations may result in the definition of new variables. If so the new variables will be appended to the variable list associated with a specific scope.

As those of ordinary skill in the art know some JavaScript interpreters also provide a just in time compiler that compiles the JavaScript to bytecode prior to executing the generated bytecode. Bytecode compilation allows for a more efficient and dynamic execution of the code than that of binary code. For example the SquirrelFish JavaScript interpreter in the WebKit browser engine compiles a syntax tree to corresponding bytecode. When a new function is defined the content of the function is saved as corresponding syntax tree under the tree node that denotes the function variable. That corresponding syntax tree is not compiled to bytecode however until the first time that the function is invoked. Thereafter the resultant bytecode may be directly used responsive to invocations of that function.

To illustrate method consider Apple s home page and their iPhone web page. The Apple home page i.e. http www.apple.com currently imports approximately fifteen 15 external JavaScript files. According to the present invention launching a browser and visiting apple.com will create fifteen 15 corresponding records in the external JavaScript files pool . Additionally the intermediate representation of the embedded JavaScript and the data structure that represents the DOM structures of the home page in the tab are saved to the dedicated memory space. The Apple s iPhone web page imports fourteen 14 external JavaScript files seven 7 of which are identical to those associated with Apple s home page. If the user opens the iPhone web page in a new tab the interpreter goes through each script tag to determine whether the imported external JavaScript file associated with the script tag is already cached in the pool . In this case the interpreter would find seven 7 records in pool that could be re used and linked to by the newly opened tab.

As previously stated the current trend is to allow each tab to execute as its own separate process. Therefore the memory where the intermediate representations of the external JavaScript files in pool are stored is shared among the multiple processes. As those skilled in the art will readily appreciate there are many methods in which to share memory across processes. However one embodiment of the present invention utilizes an Inter Process Communication IPC mechanism to facilitate such sharing. For example a Portable Operating System Interface for Unix POSIX compliant mmap system call and the Unix System V IPC Shared Memory facilities are both suitable for implementing shared JavaScript .

With some operating systems such as Linux the shared library comprises a read only part and a read write part. The read only part includes the symbol table the text binary of the instructions and read only data. The read write part includes other data such as regular data for example. When multiple programs that link with the same shared library execute simultaneously there is only one copy of the read only part of the shared library in the memory. However there is one copy of the read write part per instance of the program. Therefore the program maintains the modifications of the read write data for itself while the read only part is shared among the other instances of the executing programs. However the language feature of JavaScript dictates that there be no division between read only and read write parts for a JavaScript shared library. Thus any symbol can be rewritten at runtime. Even a function in JavaScript is one of the variable types and is not particularly different from other variable types such as the object type or string type. Moreover the variable type is not strictly bound with the variable and thus the variable can always be re assigned with a value of another variable type at runtime.

When webpage1.html is opened the generated intermediate representation associated with the lib.js of is saved to the external JavaScript libraries pool . In this embodiment the intermediate representation saved to the pool includes the syntax tree that describes the grammatical structure of lib.js the variable list containing the function foo and the object bar. If the JavaScript interpreter uses lazy just in time bytecode compilation the interpreter will delay generating the bytecode for function foo until foo is invoked in webpage1.html. Thereafter the generated bytecode for foo is saved among the other data associated with lib.js in the pool . Once invoked foo is re assigned with a string in webpage1.html. However this modification is not written back to the pool . Instead foo is appended to a dirty variable list of lib.js with a new string value. The dirty variable list of lib.js is then saved with the other intermediate representation of webpage1.html instead of in the external JavaScript files pool . This dirty variable list of lib.js includes all variables of lib.js that have been modified locally in webpage1.html.

When webpage2.html is opened e.g. in a new tab or a new instance of a browser window the interpreter determines that the html code imports the external script file lib.js from an inspection of the URI www.company.com lib.js. However instead of interpreting the JavaScript file lib.js the interpreter first searches the external JavaScript libraries pool to determine whether a record for the lib.js JavaScript file already exists. Upon determining that a record for lib.js already exists in the pool the saved JavaScript syntax tree the variable list and the bytecode associated with lib.js are directly linked to webpage2.html. Thereafter when foo is invoked as a function by webpage2.html the interpreter searches the saved linked variable list of lib.js for the definition of function foo The bytecode of function foo that was generated during its invocation in webpage1.html is then directly used for execution in webpage2.html.

Any modifications of foo by webpage1.html such as the dirty variable list are not visible to webpage2.html. Nor are modifications of foo by webpage2.html visible to webpage1.html. Therefore if webpage2.html were to modify the property name2 of object bar to 99 the modified bar object is appended to the dirty variable list of lib.js in webpage2.html. Although this modification overwrites the original value for name2 in the original bar object in lib.js the modification is seen only by the code in webpage2.html. Provided webpage1.html did not modify the value for name2 in its copy of bar the code in webpage1.html will still reference the original name2 of 100 value in lib.js.

As previously stated the present invention first searches the pool to determine whether a given JavaScript file or code referenced in a web page should be imported. Such a search is likely to occur for example in three different scenarios. The first scenario occurs whenever a user clicks a link in one tab to open a new tab that loads a different web page from the same website. The second scenario occurs whenever the user simultaneously opens a plurality of tabs each loading a different website. The third scenario occurs when different web pages in different tabs all include copies of the same third party JavaScript files.

For the first and second scenarios the controller could inspect the URI identifying the JavaScript files in the web page HTML code. However HTML code in which a script tag has the same URI as its src attribute does not necessarily mean that it references the same JavaScript file. Even if they are the same the content of the JavaScript file could have changed over time. For example the browser typically generates and sends an HTTP GET message to retrieve a given JavaScript file from a network server. The HTTP GET request message typically includes the URI to identify the JavaScript file. However the URI that is extracted from the HTML code may reference a JavaScript file that has been modified by the server on which it resides. Thus the JavaScript file identified in the HTTP GET request message may be a different version of the file already represented in the pool . Additionally the HTTP server providing the HTTP response may generate the JavaScript file content that is returned in the body of the HTTP response on the fly. In such cases the JavaScript file represented in the pool may not be exactly the same as the actual JavaScript files referenced in the HTML code or provided by the server.

Therefore one embodiment of the present invention illustrated in advantageously utilizes the HTTP cache mechanism in these situations to determine whether a JavaScript file referenced in an HTML web page already exists in the pool . Method of begins with the controller executing code that extracts the URI from the HTML code of a web page box . Once extracted the controller generates an HTTP GET request message to obtain the JavaScript file identified by the extracted URI and sends the message to the server box . The generated HTTP GET request message includes the extracted URI and a modification request indicator that signals the server to determine whether the target JavaScript file has been modified. By way of example the controller may include an HTTP entity tag as a modification request indicator in the HTTP GET request message to the server. Upon receipt the server would determine whether the target file was modified and return an HTTP entity tag as one of the HTTP validators in a response. Upon receiving the response box the controller would inspect the returned entity tag box .

If the server returns for example a Not Modified response message with no file content in the body the browser can safely determine that the URI references the exact same copy of the JavaScript file as that of an existing tab. That is a copy of the intermediate representations for the JavaScript file identified by the URI in the script tag already exists in the pool. In that case the controller would simply link the tab having the webpage to that data in pool box . If the server returns a Modified indicator in the response message however the controller would then extract the JavaScript code from the body of the response message box and create a new record for the intermediate representation data as previously described box before linking the tab with the newly created record box .

If the HTTP response message indicates that the previous cache has expired or that the HTTP response does not support cache mechanism e.g. the HTTP response message is sent with a NO CACHE indicator in the cache control header then the controller extracts the JavaScript file from the new HTTP response and compares it to a cached JavaScript file from the previous response box . The comparison is a literal comparison and will determine whether the JavaScript file identified by the URI is identical to a previously received file. If the comparison indicates that the files are the same the controller will simply link the tab to the associated record stored in memory box . Otherwise controller determines that it is a different JavaScript file extracts the file from the HTTP response box and creates and saves a new record to store the intermediate representation to the external JavaScript file pool .

The literal comparison of box may be performed by any method known in the art. In some embodiments for example a hash value or checksum is used to assist processing the lexical comparison. In another embodiment a lexical comparison of the file content is performed however analyzing the URI of the JavaScript file and performing the lexical comparison of the file content may be somewhat more complex. For example to load the Google Maps JavaScript API the code calling the API would set the src attribute of script tag to 

Regarding the third scenario i.e. when different web pages in different tabs all include copies of the same third party JavaScript files the URI cannot be used to determine whether the JavaScript files already exist in the pool . Because third party JavaScript libraries like Prototype or JQuery are considerably large the user needs to download those libraries to their web server and then include them as local JavaScript files instead of importing them from remote sites. For example the apple.com web pages use Prototype v.1.6.0.2 and include it as a local file at 

In another embodiment the present invention is applied to the just in time compiling feature for multiple Java applications in a Multiple Address Space MAS operating system such as Linux or UNIX. This embodiment is conceptually similar to JavaScript running in multi tab browser. Particularly Java applications typically share classes e.g. java.lang.string . These classes will generally be just in time compiled from bytecode to native binary code prior to execution. If the common classes are compiled within each application as is conventional the costs are high in terms of memory and execution time. However those costs can be lowered by compiling the common classes once and using them for all applications.

In these cases the fork system call in UNIX is used. If the virtual machine execution starts with a main Java application which then launches other Java applications the overhead for the common classes will be shared by all applications. This is of course assuming that these common classes are compiled by the main application. Generally the behavior of the fork system call is particularly important in the context of just in time compilation. That is it allows binary compiled code to be shared in a straight forward way at runtime. However this Java UNIX case is different from the present invention because it relies on the fork system call to clone the application. Particularly the fork system call creates a clone of the parent process including its data. This results in several copies of the same data. In contrast the present invention permits sharing JavaScript code being executed in independent browser tabs. The JavaScript would share some common components but would never be a clone of another process.

A related topic is the shared web worker defined in HTML5. Web worker is a new set of APIs that run JavaScript in parallel in the background. A worker can be defined in a separate JavaScript file and created using a related API e.g. var worker new Worker worker.js . This is different from importing an external JavaScript file in that the JavaScript variables defined in worker.js are not visible externally. The only way to communicate with the worker is via message passing. A shared worker as one category of web worker is able to coordinate with multiple pages as used in W3C Web Worker Working Draft and is equivalent with tab in this context via message passing. A shared worker can also help set up direct message channel between two tabs.

Shared workers are different from the present invention because the present invention proposes a way to share intermediate representation of external JavaScript files imported in multiple tabs. A shared worker in contrast is a new API to facilitate the coordination of message passing between tabs. Further the present invention aims to improve the performance of the current browser s JavaScript interpretation implementation and it requires no changes in the existing W3C web standards.

As mentioned above this invention helps the multi tab browser avoid repeatedly interpreting the duplicated JavaScript files and generating the syntax tree and bytecode. Therefore it will significantly save memory resources eliminate the wasteful runtime overhead associated with interpreting the same file multiple times and reduce execution time as a result. Such improvements are particularly beneficial to resources limited devices like mobile devices.

Table 1 illustrates how much execution time can be potentially reduced using the present invention. The values in Table 1 are collected from a WebKit r38097 Gtk port in Linux executing on an HP Compaq DC7900 Core2 Quad core 2.83 GHz . The JavaScript engine in WebKit r38097 is SquirrelFish Extreme SFX . The clock function from GNU C library was used at the beginning and the end of various steps of JavaScript interpretation and the values were subtracted to get the number of CPU clock ticks elapsed in each step. The number of clock ticks per second measured by clock function is 1 000 000 in this case. The minimum resolution of clock function is 10 000. Therefore where the number of clock ticks was lower than 10 000 that value is displayed as 0.

The WebKit instance was used to browse Apple s home page http www.apple.com . The instance measured the number of CPU clock ticks used in generating syntax tree and bytecode respectively. The SFX is also able to just in time compile bytecode to native code in a x86 platform but this step is not measured because it is not applicable to embedded platforms like ARM yet. The result are shown as follows in Table 1. Not all the JavaScript files used by Apple s home page are listed. Further www.apple.com indicates the JavaScript code embedded in Apple s home page.

Of the JavaScript files listed in Table 1 s code h.js shortcuts.js apple core.js scriptaculous.js and prototype.js are also used by other apple.com web pages including the Mac web page. As a result at least 580 000 CPU clock ticks of execution time can be saved while browsing the Mac web page in a second tab. This corresponds to approximately 0.58 seconds of CPU time. Those skilled in the art will appreciate however that this value is collected using a Core2 Quad core 2.83 GHz desktop PC. This value might be substantially larger for a mobile device.

Similarly the potential memory size that can be saved is measured by the amount of memory required to store the data structure of the syntax tree the bytecode and other artifacts related to the JavaScript files that are shared among tabs. Measuring memory size per application or per data structure is never an easy task. Factors such as shared memory committed memory and others in Linux for example tend to complicate such calculations. However in this example the prototype.js file was retrieved from apple.com and a mock up web page was created to include that JavaScript file. Thereafter the values of free memory size from proc meminfo were read while loading the mock up web page both with and without importing the JavaScript file prototype.js. Both values were then subtracted to get an approximate value of how much memory is allocated for prototype.js and its related data structure. The experiment was conducted several times to get the average figure to minimize error. The final figure is approximately 3.75M. Therefore if the second tab having the apple.com Mac web page can re use the intermediate representation of prototype.js loaded with the first tab having the apple.com home page about 3.75M of memory space can be potentially saved.

The previous embodiments describe the present disclosure in terms of host device being a single user device executing a browser application. However as stated above the present invention is not limited simply to use on a single user device. Rather the present invention may be utilized on a cloud based server that provides the browser application as a service to one or more user devices.

Particularly multiple users may connect to the cloud based server which executes the browser application for the users. In accordance with the present invention the server is configured to allow each of the connected multiple users to share the intermediate representations of commonly utilized JavaScript files between multiple tabs or browsing instances in the Cloud. Such sharing may occur among the multiple tabs associated with a single user device and or among the multiple tabs of a plurality of different users connected to the cloud based server. As previously described the intermediate representations may include but are not limited to file content syntax trees variable lists or symbol tables bytecode and other related data and data structures generated by the JavaScript files and used to interpret the JavaScript at the cloud based server. Such a mechanism not only improves the browsing performance for the users but also reduces the resource load placed on the cloud based server executing the browser application as well as on the network. illustrate this aspect of the present disclosure in more detail.

Cloud comprises a communication network having a variety of different nodes . Each node operates alone or in conjunction with one or more of the other nodes to provide a variety of different on demand computational resources for consumption by the host devices . The nodes may comprise for example one or more servers gateways databases or other hardware entities that avail their software and hardware resources to the host devices . With such resources host devices are able to perform tasks such as view and edit blogs store view and communicate images videos and documents interact with remote parties using a social networking application such as FACEBOOK or TWITTER access desired web sites send and receive email and text messages participate in chat sessions store and retrieve personal contact lists and the like.

The APs comprise the requisite hardware and software needed to communicatively link the host devices to the Cloud . The APs may comprise for example a Radio Access Network RAN a wireless access point WAP or an IP network . The RAN typically comprises one or more base stations that communicate with wireless devices according to any known standard. Some exemplary standards include but are not limited to the standards known generally as the Global System for Mobile Communications GSM cdma2000 Universal Mobile Telecommunications System UMTS Wideband Code Division Multiple Access CDMA 3GPP Long Term Evolution LTE and Worldwide Interoperability for Microwave Access WiMAX .

The WAP also interconnects the host devices to the Cloud . Usually the WAP has a wired connection to the Cloud via a router not shown and communicates with the various nodes e.g. gateways in the Cloud using Transport Control Part TCP Internet Protocol IP . The WAP also communicates with suitably equipped wireless devices such as host devices according to the IEEE 802.xx standards. In operation the WAP receives messages and data from the host devices and forwards them to the nodes . Similarly the WAP receieves data from the nodes and forwards that data wirelessly to the host devices 

In some embodiments a host device such as host device is not configured to communicate wirelessly with RAN or WAP . In these cases the host device may comprise a hardware port e.g. an Ethernet port configured to communicatively connect the host device to a packet data communications network . The network may be for example a private or public IP network connected to one or more nodes of the Cloud . In operation the network sends and receives signaling and other messages to and from the Cloud and the host device

The cloud based server comprises a controller a communication interface and a memory . Browser application as well as other software packages not specifically discussed herein may be stored in memory .

The controller comprises one or more microprocessors microcontrollers hardware or a combination thereof. Similarly to controller above the controller communicatively connects to the communication interface and the memory in server . As described below in more detail controller executes software application programs stored in memory to share the intermediate representations of JavaScript code and data across multiple tabs in the multi tab browser application . In such a cloud based server environment the intermediate representations of the code and data may be shared across multiple tabs for a single user as well as across the browser tabs associated with one or more different users connected to the server and communicating with the browser application . Further according to the present invention the controller may perform these functions without compromising the security of the individual users.

The communication interface includes the requisite hardware and software needed to allow the server to communicate with one or more host devices via the communications network and one or more of the APs . Communication interface also contains the hardware and software needed for server to communicate with one or more of the other nodes in network . Those of ordinary skill in the art will appreciate that although depicts the communication interface as a single block the communication device may comprise the same or different circuitry for communicating with the different end devices via different APs .

In one embodiment the communications interface comprises a suitable Ethernet based interface adapter card such as a 10 BASE T Fast Ethernet 10 GbE or similar network card. In operation the adapter card connects the cloud based server to a host device via a packet data communications network. In yet another embodiment the communication interface may comprise a wireless LAN 802.11x interface or is a wireless interface card operating according to WiFi standards e.g. IEEE 802.11 or BLUETOOTH. Those skilled in the art will appreciate that the interfaces listed herein do not comprise an exhaustive list and that there are many additional interfaces that may be used to connect the cloud based server to multiple different types of host devices via communications network .

Memory represents the entire hierarchy of memory in server and may include both random access memory RAM and read only memory ROM . Software programs and data required for operating server may be stored in non volatile memory such as EPROM EEPROM and or flash memory and may be implemented as discrete devices stacked devices or integrated with controller . The software programs may include an operating system such as WINDOWS UNIX LINUX APPLE COMPUTER S OS X and the like. The software programs may also include user application programs that perform some function for one or more users that are connected to the server via network . In one embodiment for example memory includes two partitions a shared memory resource and a dedicated memory resource . Memory also stores the browser application . As described in more detail later one or more users connect to the server and remotely execute the browser application to interact with the Internet. The browser application stores the intermediate representations in the shared memory so that all users connected to the server can share commonly used JavaScript files as previously stated and maintains any user specific data and code in the dedicated memory resource .

Method begins with the server receiving a request to open a new browser tab from the host device and executing a browsing instance to provide the user with the requested tab box . The request may be for example a request to retrieve a desired web page or a request for a new browser tab in which the user can manually enter the URL for a desired web page. Regardless of the request however server opens a browser tab retrieves web page requested by the user and processes code that defines the web page as previously described.

As discussed in the previous embodiments the web page requested by the user may include or reference one or more JavaScript files. Therefore while processing the web page the browser application first identifies these JavaScript files box . Upon identifying a JavaScript file the server determines whether the given file already exists and is referenced in the shared pool box . Such would be the case for example if one or more of the users already connected to server had already accessed a web page that used or referenced the identified JavaScript file. If the JavaScript file exists in the shared pool the controller saves the intermediate representation of the embedded JavaScript code generated during the processing of the web page to the dedicated memory resource associated with the browser instance e.g. the browser tab processing the web page box . Controller then links the intermediate representation of the embedded JavaScript file in the shared pool to the intermediate representation of the embedded JavaScript code stored in dedicated memory resource and to the browser instance that processed the web page in which the JavaScript file is used box .

If the file does not already exist in the shared pool the controller creates a new record in the shared pool such that the record and the information it contains remains accessible to multiple users across multiple browser instances box . The new record is then tagged with the specified URI of the JavaScript file to associate the record with the file box . The intermediate representation of the JavaScript file is then generated and the content of the JavaScript file that was retrieved by the HTTP client or by the file system the resultant syntax tree and the variable list are saved to the new record in the shared pool box .

As above the JavaScript file need not be saved to the shared pool if the server supports an HTML caching mechanism. However the web page may still maintain its own JavaScript syntax tree variable list and bytecode that are generated from the JavaScript code snippets embedded within the web page. Therefore controller may save those artifacts to the dedicated memory resource associated with the browser instance processing the web page box and link to the file in the shared memory resource box as previously described.

Identifying the JavaScript file s and linking the intermediate representations together at the cloud server is different from performing these operations at a single host device . This is because the cloud based server provides a very different environment compared to that of host device . For example the cloud based server allows each of a plurality of users to invoke multiple windows tabs or other browser components. This means that the same cloud based server can simultaneously execute and maintain different browsing instances initiated by different users. However although the present invention allows these different browsing instances to access and share the intermediate representation s of the external JavaScript files it does not compromise a user s privacy. Particularly the external JavaScript files are already publicly available to each of the users and thus sharing them among different users poses no privacy risks. Further the application code i.e. the JavaScript lacks the ability to access the shared memory pool and thus is not able to determine whether certain JavaScript files already exist in the shared memory pool as does the present invention. Therefore the interpreter at the cloud based server is configured to perform this function.

The JavaScript language does provide features that allow JavaScript files to determine whether a given symbol can be modified at runtime by the embedded JavaScript code or some other external JavaScript code. However as previously described any such local runtime modifications to these symbols or variables are saved to the dedicated memory resource associated with the specific browsing instance i.e. the dirty variable list . Therefore the method of the present invention poses no greater security risk with respect to a user s privacy than is already present at the cloud based server .

Additionally when executing on a cloud based server consideration must be given to the fact that different users can and do use different browsers to access the web each of which may use a different interpreter. Thus the server is configured to process and store the intermediate representations in accordance with each of the JavaScript interpreters. By way of example only some users may employ MICROSOFT S INTERNET EXPLORER while other users employ MOZILLA FIREFOX GOOGLE CHROME or SAFARI. Each may utilize a different JavaScript interpreter and therefore require different processing. According to one embodiment each intermediate representation of an external JavaScript file in the shared pool is tagged with a value or other identifier an identifier that identifies the particular browser instance with which it is associated. Each associated external JavaScript file is also correspondingly marked with the identifier. Then before the intermediate representation in the shared memory pool can be linked to the dedicated memory resource associated with the browsing instance the intermediate representation is matched to the browsing instance.

Additionally linking the intermediate representation of the JavaScript file in the shared pool to the dedicated memory resource associated with the browsing instance in the cloud based server embodiments can at times be more complex than when such linking is performed at host device . For example on as host device the shared memory in which the intermediate representations of the JavaScript files are stored is simply mapped to the browser instance process. However cloud based embodiments have an added consideration i.e. whether the cloud based server is also running one or more Virtual Machines VMs . If the cloud based server executes and maintains the browsing instances as processes outside the boundaries of the VMs or if there are no VMs on the server then the shared memory storing the intermediate representation can simply be mapped to the process associated with the particular browsing instance. However if the browsing instances of different users are running in different VMs on one or more physical machines the intermediate representations may be stored in a virtual storage device that is mounted to a selected VM such that all VMs can access the intermediate representations stored thereon. Other inter VM shared memory mechanisms can also be used.

Thus the present invention when executed in the realm of a cloud based server helps the browser applications executing on the server to avoid repeatedly interpreting commonly used JavaScript files. Rather the present invention configures the server to generate a syntax tree and the bytecode for a given JavaScript file only once and then places these artifacts in a memory that is accessible across a plurality of different browser instances associated with one or more different users. This will save a significant amount of memory at the server by avoiding the generation and storage of redundant data structures and eliminate or greatly reduce the overhead associated with the subsequent runtime interpretation of the file. The present invention will also reduce execution time and therefore will improve the users browsing experience and save on the costs for cloud infrastructure.

The present invention may of course be carried out in other ways than those specifically set forth herein without departing from essential characteristics of the invention. Therefore the present embodiments are to be considered in all respects as illustrative and not restrictive and all changes coming within the meaning and equivalency range of the appended claims are intended to be embraced therein.

