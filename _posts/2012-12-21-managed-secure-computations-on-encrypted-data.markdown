---

title: Managed secure computations on encrypted data
abstract: The subject disclosure is directed towards secure computations of encrypted data over a network. In response to user desired security settings with respect to the encrypted data, software/hardware library components automatically select parameter data for configuring a fully homomorphic encryption scheme to secure the encrypted data items while executing a set of computational operations. A client initiates the set of computational operations via the library components and if requested, receives secure computation results in return.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09306738&OS=09306738&RS=09306738
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09306738
owner_city: Redmond
owner_country: US
publication_date: 20121221
---
Maintaining data confidentiality is an important concern for all computing device users regardless of task s performed. Encryption schemes represent one form of technology directed towards securing data when stored in memory and or transmitted over networks. Fully homomorphic encryption FHE refers to an encryption scheme that allows an untrusted server to execute arbitrary computation on encrypted data on behalf of a computing device often referred to as a client.

Conventional solutions for constructing a FHE scheme often incur significant costs due to a reliance on certain mathematical concepts e.g. ideal lattices to evaluate any function on encrypted data. In practice these constructions can be improved using conventional techniques such as those related to batch wise or bit wise encryption but often remain unworkable for a number of reasons for example necessitating deep circuits such as those based on encryption standards and or substantial storage space to process ciphertexts. While some FHE constructions are capable of computing block ciphertexts homomorphically evaluating a single block using these constructions are several orders of magnitude slower in terms of throughput and latency when compared to evaluating a single block non homomorphically. Such a performance difference highlights the current impracticality of implementing FHE schemes using these conventional solutions.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards implementing a fully homomorphic encryption scheme to evaluate an encryption standard circuit. In one aspect a ring based public key encryption system is fully homomorphic when constructed using well known lattice problems and or reduced ciphertexts in order to ensure correctness and security. In another aspect the fully homomorphic encryption scheme encodes integers by partitioning such integers based upon an encoding parameter such that computations are performed in parallel.

Based upon user input the fully homomorphic encryption scheme is automatically configured to perform such computations. In one aspect one or more software hardware library components select one or more parameters for configuring the encryption scheme to operate efficiently. In one aspect restricting a cryptographic key space enables higher throughput and reduced memory usage while maintaining security and correctness. In one aspect a computing device uses a library component to configure the fully homomorphic encryption scheme to perform the computations on the encrypted data.

The library component is configured to provide access to homomorphic functionality. One such function performs a mathematical operation on one or more encrypted data items. In one aspect the library component is extended with additional homomorphic functions that are built upon other homomorphic functions. The library component is configured to process the user s input sets bounds on computational operations and either executes such operations or issues errors if correctness cannot be assured. In one aspect the library component informs the user when decrypted output from a homomorphic function is not equal to the result of a same computation on the input had such input been unencrypted.

Other advantages may become apparent from the following detailed description when taken in conjunction with the drawings.

Various aspects of the technology described herein are generally directed towards a library configured to perform computations on encrypted data over a network. Access to the library s functionality may be provided via a network resource such as a local area network server or a cloud computing environment. The network resource may be untrusted by other computing devices herein referred to as clients. Hence the client may use the library to prevent any adversarial computing device from deciphering the encrypted data during transmission and or while stored in memory at the network resource. According to one example implementation components of the library construct a fully homomorphic encrypted scheme which may be used to privately outsource computational operations to the network resource when data is being uploaded from distributed computing devices while achieving a certain level of data correctness and security.

Some embodiments of the library implement a leveled fully homomorphic encryption scheme based ideal lattice problems such as the ring learning with errors problem. One example encryption scheme may be based on the quantum hardness of short vector problems in ideal lattices. The leveled fully homomorphic encryption scheme described herein reduces ciphertext size and eliminates ciphertext expansion in homomorphic multiplication simplifying key switching functionality. Such a scheme also may be scale invariant and therefore negating the use of modulus switching functionality.

The leveled fully homomorphic encryption scheme also may reduce an overall complexity incurred in homomorphic computation by utilizing separate small plaintext moduli that are later combined via the Chinese remainder theorem CRT into a larger plaintext modulus. Such a reduction may result in more efficient plaintext ciphertext sizes and a lower probability of reaching a maximum amount of computation and or the like. In one example implementation a data item is first encoded to produce a set of encoded values and then each value is encrypted as a ciphertext. Computations performed on the data item may process each ciphertext individually which may be facilitated by a small ciphertext size and combine processing results into a larger ciphertext.

To illustrate one example encoding integers using a CRT based technique described herein enhances computation precision since each integer is transformed into to more efficiently sized e.g. smaller integers. The CRT based technique also enables encoding of large integers by reducing each large integer into smaller integers that are processed separately and combined into a correct result. An Integer up to a bound B may be encoded as a set of integers of which each integer is encoded up to a bound t. Computational operations may be correctly performed on the set of integers given that each modulus tis co prime and the product over all tis greater than bound B. Each integer x mod tin the set may be encrypted and then processed in parallel to return encrypted results which are then decrypted decoded to recover an original integer.

It should be understood that any of the examples herein are non limiting. As such the present invention is not limited to any particular embodiments aspects concepts structures functionalities or examples described herein. Rather any of the embodiments aspects concepts structures functionalities or examples described herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing and secure computations in general.

The following refers to embodiments in which the network resource facilitates the provision of services such as computation services to the example client . Various computing devices including a physical machine or virtual machine herein referred to as a server may operate within the network resource and perform computations on stored data sets such as an example data set comprising encrypted data . Example architecture for the network resource decouples dedicated hardware from software such that each hardware software component may be virtualized into units which then may be further grouped around functionality. When performing a task the network resource may automate provisioning and configuration of some units such that each unit performs a portion of the task in parallel.

The network resource may configure one or more components of the library back end to operate in various computing environments e.g. a local computer cluster a private cloud computing environment a public cloud computing environment and or a hybrid computing environment . By encoding encrypting the example data set and executing various computational operations on the example data set while maintaining the example data set in an encrypted state the library back end secures the example data set from unauthorized access modification and or misappropriation such as by an untrusted resource.

As described further below the library front end provides access to an encryption mechanism providing functionality with respect to a homomorphic encryption scheme . Such functionality enables a computation module to automatically select parameter data for dynamically executing secure computations on the encryption data .

Via a number of implementations of the homomorphic encryption scheme one or more components of the library back end evaluate a standard encryption circuit of a particular depth level correctly and securely. At least some implementations of the homomorphic encryption scheme include a leveled fully homomorphic scheme in which a user inputs a circuit depth level e.g. a depth three 3 level four 4 circuit for 128 bit encryption . Instead of applying a bootstrapping procedure or one that utilizes bit wise encryption a leveled homomorphic encryption scheme is scale invariant by limiting inherent noise growth and eliminating the modulus switching technique.

The library front end may be used to build a private cloud computational service for outsourcing computation on the encrypted data . The computation module may be configured to automatically establish bounds on data set size for the encrypted data. These bounds may be determined based upon user inputs including desired security level one or more computational operations amount and type of data to be handled and or the like. Each computational operation may refer to a single homomorphic function or a series of such functions. An example homomorphic function may be configured to evaluate encryption circuits such as through addition or multiplication of ciphertexts. One example implementation of the computation operation combines these functions to provide additional functionality such as for statistical purposes predictive modeling machine learning and or the like. To illustrate the user via the library front end may instruct the library back end to use the addition and or multiplication functions to compute a mean a standard deviation regression values and other statistical data. The library front end may be programmed to use homomorphic evaluation functions to initialize and or train a linear classifier.

Configuring an instance of the homomorphic encryption scheme to ensure security and correctness may rely upon computational hardness assumptions related to well known lattice problems such as the Shortest Vector Problem SVP . Specifically Ring Learning With Errors RLWE based implementations of the homomorphic encryption scheme utilize polynomial rings where polynomials are represented as vectors in a lattice and truncate these polynomial rings using various techniques. Example techniques include reducing a ciphertext size space and or a plaintext message size space by a modulus factor restricting a cryptographic key space to a bounded distribution encoding polynomial ring elements using a Chinese Remainder Theorem CRT based technique and so forth. A bounded cryptographic key distribution from which polynomial ring elements representing cryptographic keys are sampled for instance may accomplish key space restriction. Encoding an integer data item including a large integer as a collection of smaller integers enables efficient computations on that integer data item.

Generally the ring learning with errors RLWE assumption which is related to the learning with errors LWE assumption refers to preventing an adversary from distinguishing one sequence of samples from random pairs of polynomial ring elements. It is appreciated that the polynomial ring elements may refer to any type of polynomial such as a cyclotomic polynomial. By being unable to discern one polynomial from another polynomial without substantial computing power and time the adversary cannot reasonably decode computation results based on input polynomials. It is well understood the RLWE assumption may be reduced to the worst case hardness of short vector problems on ideal lattices.

Although the homomorphic encryption scheme performs computations on elements of ring R each element may be encoded using an encoding parameter such that an encoded vector of polynomial coefficients is identical or invertible to the original polynomial. According to one example implementation for all polynomials that are considered to be elements of ring R the homomorphic encryption scheme reduces polynomial coefficients modulus q to produce the encoded vector. The encryption mechanism may configure the homomorphic encryption scheme to map each element in R to an integer within an integer domain of size q. Generally such a mapping may be expressed as function r a to denote reduction of element a to interval 0 q .

Using the homomorphic encryption scheme the encryption mechanism samples cryptographic keys and or random error polynomials from Gaussian distributions in each distribution is of a different width and may be bounded to a specific interval. A bounded Gaussian cryptographic key distribution for instance represents a restricted key space from which efficient cryptographic keys are generated. A set of cryptographic keys may include a public and a private key derived from a B bounded distribution whereas errors are deduced from a B bounded distribution. Some example implementations of the homomorphic encryption scheme also generate another cryptographic key referred to as an evaluation key.

Using the homomorphic encryption scheme the library back end may generate ciphertexts that only map to a single ring element in contrast to the two or more as dictated in pure ring learning with errors RLWE based schemes. Evaluating the homomorphic encryption scheme in addition results in little or no ciphertext expansion while executing homomorphic multiplication. The encryption mechanism may rely on a decisional small polynomial ratio DSPR assumption to extend a basic construction of the homomorphic encryption scheme . For instance by using a tensoring technique the homomorphic encryption scheme ensures that the public key distribution is statistically similar to a uniform distribution provided that the cryptographic key elements are sampled from Gaussian distributions of sufficient width.

One example implementation includes a structural representation of a ring R such as a polynomial ring. Let d be a positive integer and define R X X as the ring of polynomials with integer coefficients modulo the d th cyclotomic polynomial X X . The degree of is n d where is Euler s totient function. The elements of R may be represented by all polynomials in Z X of degree less than n. Elements of ring R are of arithmetic modulo X which is implicit whenever terms or equalities involving elements in R are described herein.

A vector of coefficients may represent an arbitrary element a R as a a a . . . a where a . Hence a polynomial for a may be expressed as follows 

In particular element a can be viewed as an element of the vector space . The example library component selects a maximum norm on to measure the size of elements in R. One example implementation of the maximum norm of a may be computed as follows 

Let be a probability distribution on R according to which elements are sampled from R. Using notation a to denote that a R is sampled the distribution on R is B bounded for some B 0 if for all elements a an inequality a 

By way of an example of a distribution on R a discrete Gaussian distribution may be designed with a mean zero 0 and a standard deviation over the integer set which assigns a probability proportional to exp x to each element x . When d is a power of two 2 and X X 1 may be a spherical discrete Gaussian such that each coefficient of the polynomial is sampled according to the one dimensional distribution .

Step commences the example steps of and proceeds to step where one or more library components for performing computational operations on the encrypted data are provided to the client. To illustrate one example implementation an example library component comprises instructions configured to compute a set of homomorphic functions including linear algebra functions e.g. vector dot product matrix multiplication and or the like and or more complex mathematical functions.

Step refers to user input processing and parameter generation with respect to executing a set of computational operations. Some user input may indicate a desired security level a data set size a computation precision and or the like. Based upon such user input the example library component selects parameters to dynamically configure execution of the set of computational operations while rendering secure and correct computation results. One example parameter includes a specific modulus referred to as modulus q having a variable or fixed size e.g. 128 bit or 1024 bit and being a power of two or alternatively being a Mersenne prime. Another example parameter involves setting a degree n of an evaluation polynomial equal to d .

The example library component may alternatively use pre determined parameter data such as a base field and dimension of ideal lattices. The example library component may modify the parameter data to adapt to new bounds and estimates assuring correctness and security. Automatically selecting these and or other parameters prevent substantial inherent noise from causing inaccurate evaluation when executing the computational operations. Step determines whether a noise estimate for the set of computational operations is acceptable.

As described herein the distribution is used in many fully homomorphic encryption schemes based upon the ring learning with errors RLWE problem assumption such as for sampling random error polynomials that have small coefficients with high probability. Such random error polynomials are a significant part of noise term computations used in the encryption process.

Because an inherent noise term of small norm allows recovery of plaintext e.g. decrypted data from ciphertext e.g. encrypted data a bound on the inherent noise in a ciphertext assuming key and error distributions are bounded ensures correctness in the homomorphic encryption scheme described herein.

To deduce meaningful bounds on inherent noise size and or growth during homomorphic functions the distribution is B bounded for some B. For the discrete Gaussian distribution this assumption is appropriate because sampled elements tend to be small in size with a high probability. Bounding enables sampling from a truncated Gaussian distribution which is statistically close to the true discrete Gaussian if B is chosen large enough. For example if the truncated distribution is bounded by B 6 all samples are B bounded with very high probability.

By computing at least one bound for the noise estimate the example library component establishes a particular level of computational security and correctness. If the noise estimate fails to satisfy the at least one bound step proceeds to step where the example steps depicted in end. If the noise estimate complies with the inherent noise bound step proceeds to step . Step is directed to a transformation between each computational operation and structured homomorphic functions. As an example computing an average or mean in a set involves a series of homomorphic additions. As another example computing a dot product between vectors of size N involves N homomorphic multiplications and N 1 homomorphic additions. In yet another example the computational operation may involve a number of vector dot products and possibly other homomorphic functions.

Step executes the structured homomorphic functions. It is appreciated that other implementations may have only one homomorphic function to execute at step . Nonetheless during such execution the example library component updates the noise estimate and or inherent noise bound. If the noise estimate exceeds the inherent noise bound according to one example implementation the example library component issues errors and or reconfiguration messages for example when a specific e.g. maximum amount of computation is reached or if a considerably large data set is entered. Upon completion of the execution of the structured homomorphic functions the example library component performs step and communicates encrypted results to the client. Step terminates the example steps described herein with respect to .

The example steps may refer to following leveled homomorphic encryption scheme as constructed by one or more hardware software components e.g. of the library back end of . Such a scheme is parameterized by a modulus q and a plaintext modulus t where 1

Step commences the example steps of and proceeds to step where one or more library components access a data set and generate a set of cryptographic keys based on automatically selected parameters. For instance the modulus q may be generalized to a specific power of two e.g. 128 bit or 1024 bit . Another example parameter involves setting a degree n of the evaluation polynomial equal to d based upon a user inputted security parameter.

Other example parameters include bounds for distributions on R. For instance a Gaussian distribution may be Bbounded within a certain number of standard deviations. To demonstrate an example embodiment using B 1 even when the polynomials f g have coefficients in 1 0 1 and the public key h is equal to tgf the public key h remains indistinguishable from a key sampled from a uniform distribution. The standard deviation of an error distribution on R bounded by Bmay be fixed at 3 2. The high probability bound on the size of the coefficients of errors drawn from Gaussian distributions may be selected as 6 .

The following example instructions labeled INSTR below correspond to a homomorphic function for generating a private key and a public key referred to as KeyGen d q t 

Step refers to encoding certain data items within the data set. A data item includes plaintext data mapping to a set of integer coefficients of a representative polynomial in R. The example library component may employ a well known Chinese Remainder Theorem to determine a modulus q for encoding the plaintext data prior to encryption. Because the polynomial f described herein is invertible modulo q polynomial coefficients may be reduced by an integer modulo q. Thus a map may reduce an integer x modulo q to a result and represents that result by an element in the interval q 2 q 2 . The map may be extended to polynomials in X and R by separately applying an appropriate map entry to each coefficient as denoted by the following 

Similarly the above notation may be modified for vectors of polynomials by applying mappings to vectors entries separately. One alternative implementation uses reduction integer x modulo q to represent any vector coefficient as an element in 0 q . In addition to a modulus q that is used to reduce the coefficients of the elements that represent ciphertexts there is a second modulus t

Step refers to encrypting the encoded data items using a leveled homomorphic encryption scheme. The following example instructions labeled INSTR below correspond to homomorphic function referred to as Encrypt pk m for encrypting a plaintext message m where a plaintext message space is defined as R tR and refers the ring of polynomials in R modulo t 

The following equation corresponds to homomorphic function referred to as Decrypt sk c for decrypting a ciphertext message c 

One example embodiment of the leveled homomorphic encryption scheme described herein includes a word length w e.g. a positive integer w 1 used to represent integers in a radix w system. By defining l log q where w

Regarding such an embodiment the following instructions labeled INSTR below correspond to an example function referred to as KeyGen d q t w that generates a private key a public key and an evaluation key 

An alternative to the above implementations includes a leveled fully homomorphic encryption scheme that is provably secure under the assumed quantum hardness of standard worst case lattice problems. The following description refers to ring based encryption systems based on the RLWE assumption and a circular security assumption given the DSPR assumption is satisfied for this setting of parameters. The polynomial ring R is given by R Z x X 1 where n is a power of 2 and d 2n. Furthermore gcd q t 1 and q mod d such that X 1 splits into distinct linear factors modulo q. Proving the DSPR assumption holds requires guaranteeing public key uniformity in accordance with any relevant technique. The standard deviation of the Gaussian distribution needs to be larger than q which makes the bound Blarger than q. Hence the bound for the inherent noise in an initial ciphertext q. After executing one homomorphic multiplication function a tensoring method may prevent the overall inherent noise bound from exceeding a threshold.

Given a security parameter as user input the example library component outputs a data precision setting modulus q a word size w a random error polynomial distribution a cryptographic key distribution a degree n of the evaluation polynomial equal to d and or the like where d 2n is the power of 2 that determines X X 1 to define R q t are moduli. and with standard deviations and respectively are discrete Gaussian distributions on that sample invertible elements by discarding non invertible ones. Under such a configuration the example library component samples e s computes fP D f D f e h s R and outputs a triple comprising a public key pk a private key sk and an evaluation key evk equal to polynomials h f .

Step represents basic homographic function production. The example library component uses parameter data to complete configuration of various homographic function specifications. One example homomorphic function refers to an Add c c function defined to compute an addition of input ciphertexts c1 c2 with the following equation 

Another example homomorphic function includes a Mult c c function that computes a multiplication of input ciphertexts c cusing an evaluation key evk with the following equation 

As another example homomorphic function a KeySwitch function transforms the ciphertext tilde over c encrypting the product mm of plaintext m1 and m2 which is recoverable using the evaluation key evk into a ciphertext cthat is capable of being decrypted with the original private key pk. Alternatively the example library component employs a known key switching function to build homomorphic multiplication functions.

The example library component may utilize other software hardware components to perform a modulus reduction where polynomial coefficients are scaled down by a factor such as a reduction by modulo q. The modulus reduction homomorphic function may be applied to any set of polynomial coefficients in ring R including plaintext e.g. decrypted data and or ciphertext e.g. decrypted data. Accordingly an original set of coefficients and an encoded set of coefficients are congruent to each other modulo q where q may be equal to two 2 a power of 2 a prime number and or the like . Such a function may be employed to encode the plaintext data prior to encryption which limits ciphertext size reduces inherent noise e.g. magnitude improve computation latency and or provide additional benefits. Regarding example implementations that involve encoding data as described with respect to step a congruency between an original plaintext message m and an encoded plaintext encoded message m may be expressed via the following equation mod 

Step is directed to building other homographic functions. The example library component may utilize software hardware components to perform a linear algebra function. One example homomorphic function performs a dot product operation of the plaintext message comprising a set of vector coefficients in R with another set of vector coefficients in R. In one example implementation the example library component builds upon instances of such a dot product homomorphic function to provide homomorphic matrix multiplication functionality where each matrix entry comprises a set of vector coefficients in R. Similar to the Mult and Encrypt functions a noise estimate homomorphic function may estimate an inherent noise magnitude and project the influence such noise on the security or correctness future computations.

Yet another example homomorphic function computes a noise estimate indicating the noise magnitude when encrypting the plaintext into the ciphertext. This function may couple the noise estimate to the ciphertext with the ring R. Optionally this function computes a noise estimate associated with an execution of any other homomorphic function including any of the functions described herein such as Add or Mult or other homomorphic functions such as those corresponding to implementing other encryption schemes.

Using the notation described herein inherent noise terms may be modeled when estimating noise increases for any homomorphic function. The following description includes details on determining bounds for such noise terms when word length is set to w and l log q and vin R denotes an example inherent noise term in c. Hence assuming cstores results from executing function Add c c a corresponding noise term vis bounded according to expression v v v r q . If crefers to an encrypted product of two ciphertexts the proceeding inequality bounds a corresponding noise term v 

The noise terms described above are directed towards homomorphic addition and multiplication but such terms may be interpolated when deducing bounds for computational operations involving other homomorphic functions. The obtained bounds can then be used to deduce suitable parameters for automatically configuring future computations for correctness and security using the leveled fully homomorphic encryption scheme described herein.

According to one example implementation in which a leveled tree structure of multiplication functions represents a set of computational operations ciphertexts at each level are assumed to have inherent noise terms substantially equal in magnitude. Such an assumption may approximate unbalanced inherent noise terms which results in accurate noise bound estimates.

Hence the example library component may build a structure comprising a series of Mult functions that are executed iteratively. A homomorphic rounding function may involve a considerable number of consecutive multiplications. The leveled homomorphic scheme may utilize scaling by rational numbers such that the resulting polynomials have rational coefficients instead of integer coefficients. When applied the rounding function reverts the rational coefficients back into the corresponding integer coefficients. Additional example homographic functions include encryption standard based functions such AES functions e.g. AddKey SubBytes ShiftRows MixColumns and or the like and or the like.

Step refers to providing a plurality of clients e.g. computing devices with access to the homographic functions. Via the example library component any client may interact with and use embodiments of the other homomorphic functions through hardware mechanisms e.g. microprocessor instruction sets and or software mechanisms e.g. driver based software libraries . Step terminates the example steps of .

As described herein an example library component e.g. a library front end of may be configured to perform at least some of the example steps by initiating secure computations on encrypted data and or analyzing any results from such computations. Step commences the example steps and proceeds to step where a security parameter is established. As noted in the present disclosure the security parameter defines certain desired settings including a depth level for a standardized encryption circuit. The user for instance may request 128 bit fully homomorphic encryption on an AES circuit of depth level N e.g. 3 . By entering the security parameter as input into the computational service the user may indicate a level of correctness for example in terms of precision and or security for example in terms of indistinguishability to an adversary. The computation service returns a set of additional parameters for configuring the leveled fully homomorphic encryption scheme in a manner that substantially satisfies the security parameter.

Step refers to using the computation service to encrypt data items of a data set. As described herein using principals founded in the Chinese Remainder Theorem CRT the example library component may instruct the computation service to encode each encrypted data item such that the adversary cannot distinguish between that data item and another random data item.

Step selects a computational operation for the computation service to perform. Accordingly step proceeds to issue a command via step step and or step . If the computation operation refers to a homomorphic addition function step proceeds to step . If the command is directed towards a homomorphic multiplication function step proceeds to step . If the user desires results from another homomorphic function step proceeds to step . Although some computation operations may include a single homomorphic function other computational operations involve executing structured homomorphic functions in which an arrangement of function calls perform any type of mathematical computation. For instance a series of function calls may be configured to train a linear classifier.

Step determines whether to process computation results or perform another computational operation. Step returns to step if for example the client is running a process engaged in a continuous computations such as an online machine learning application. Step proceeds to step however when the computation results are to be analyzed. Because both the encrypted and the computation results remain in an encrypted state throughout the computational operation the encryption scheme prevents an untrusted resource from deciphering the encrypted data during transmission and or storage. An adversary on an untrusted host server or otherwise connected to the client for instance cannot distinguish between two additions of random data item pairs. Step refers to the example library component using the computation service to decrypt the encrypted computation results. Step terminates the example steps depicted in .

One of ordinary skill in the art can appreciate that the various embodiments and methods described herein can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment and can be connected to any kind of data store or stores. In this regard the various embodiments described herein can be implemented in any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units. This includes but is not limited to an environment with server computers and client computers deployed in a network environment or a distributed computing environment having remote or local storage.

Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for objects such as files. These resources and services also include the sharing of processing power across multiple processing units for load balancing expansion of resources specialization of processing and the like. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may participate in the resource management mechanisms as described for various embodiments of the subject disclosure.

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in communications network may comprise other computing objects and computing devices that provide services to the system of and or may represent multiple interconnected networks which are not shown. Each computing object etc. or computing object or device etc. can also contain an application such as applications that might make use of an API or other object software firmware and or hardware suitable for communication with or implementation of the application provided in accordance with various embodiments of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for example communications made incident to the systems as described in various embodiments.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client is a member of a class or group that uses the services of another class or group to which it is not related. A client can be a process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. The client process utilizes the requested service without having to know any working details about the other program or the service itself.

In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. acting as servers provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances.

A server is typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server.

In a network environment in which the communications network or bus is the Internet for example the computing objects etc. can be Web servers with which other computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Computing objects etc. acting as servers may also serve as clients e.g. computing objects or devices etc. as may be characteristic of a distributed computing environment.

As mentioned advantageously the techniques described herein can be applied to any device. It can be understood therefore that handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments. Accordingly the below general purpose remote computer described below in is but one example of a computing device.

Embodiments can partly be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is considered limiting.

With reference to an example remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation system memory may also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices . A monitor or other type of display device is also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which may be connected through output interface .

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

As mentioned above while example embodiments have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to improve efficiency of resource usage.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques provided herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more embodiments as described herein. Thus various embodiments described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

The word exemplary is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements when employed in a claim.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component module system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the example systems described herein methodologies that may be implemented in accordance with the described subject matter can also be appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the various embodiments are not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover some illustrated blocks are optional in implementing the methodologies described hereinafter.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

In addition to the various embodiments described herein it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating therefrom. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be effected across a plurality of devices. Accordingly the invention is not to be limited to any single embodiment but rather is to be construed in breadth spirit and scope in accordance with the appended claims.

