---

title: Virtualized communication sockets for multi-flow access to message channel infrastructure within CPU
abstract: A message channel optimization method and system enables multi-flow access to the message channel infrastructure within a CPU of a processor-based system. A user (pcode) employs a virtual channel to submit message channel transactions, with the message channel driver processing the transaction “behind the scenes”. The message channel driver thus allows the user to continue processing without having to block other transactions from being processed. Each transaction will be processed, either immediately or at some future time, by the message channel driver. The message channel optimization method and system are useful for tasks involving message channel transactions as well as non-message channel transactions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09092581&OS=09092581&RS=09092581
owner: INTEL CORPORATION
number: 09092581
owner_city: Santa Clara
owner_country: US
publication_date: 20121009
---
This application relates to multiprocessor systems portable machine code and message channel transaction processing.

Also featured in the multiprocessor system are up to N peripheral controller hubs PCHs A . . . N collectively PCHs coupled to the CPUs via up to N specialized busses known as direct media interface DMI busses A B . . . N. The PCHs interface between the CPUs and one or more peripheral devices of the multiprocessor system . The PCHs may include display input output I O control a real time clock and other functions and may connect to an integrated display as well as other peripheral devices such as a keyboard a mouse a non volatile storage device and so on.

For communication between endpoints within the processor of a multiprocessor system or a single processor based system a message channel is used. The message channel is the transmission medium for these communications and may be thought of as a type of tunnel or subway between end points inside the processor. There may be many message channel endpoints and a message may be sent from any endpoint to any other endpoint with the endpoints being functional entities within the processor. Portable machine code or pcode is used to communicate between the entities and the pcode has its own endpoint for sending messages to other endpoints. No endpoint sends an autonomous message to the pcode as the only message that is received by the pcode endpoint is a response to a message that the pcode originated. Power management request PMReq messages go to other entities using the QPI bus which is similar to the message channel except that the QPI bus is an external bus interface. The message channel by contrast is strictly internal to the processor.

In CPU based systems such as a single processor system or the multiprocessor system of a message channel is used by many disparate pcode flows and functions. These functions may be used to read and write encore control registers issue PMReqs and send messages to other platform entities e.g. other CPUs PCHs . The pcode uses the message channel quite frequently from hundreds of times per millisecond to thousands of times per millisecond.

Some newer multiprocessor systems are designed in such a way that the message channel may become blocked at various times such as during a frequency transition. Previous multiprocessor systems did not have this issue as their message channel interfaces were always fully functional. So the pcode in previous projects could use the message channel in a blocking manner by sending the transaction onto the message channel and waiting in a tight loop for the completion of the transaction.

For newer multiprocessor systems the use of blocking transactions on the message channel is deemed unacceptable because the blocking transaction can potentially lock up pcode for several tens of microseconds. The blocking transactions thus lead to a higher latency for other non message channel related functions and impact the performance of the CPU. In addition there is a risk of a deadlock because the message channel is blocked by some function that is waiting for something from the pcode via a sideband interface but the pcode is blocked waiting for a message channel transaction to complete.

Additionally PMreq messages require arbitration for use of a single buffer in a PMReq engine PME .PMreq messages go over the message channel to the PME and then over the QPI bus to another CPU or over the DMI bus to the PCH . As part of the PMreq protocol correctness the PMEwill wait for a completion CMP from the other CPU PCH and will keep the PMReq buffer locked until the completion is actually received. In this case if a blocking message channel transaction is used the pcode will be locked up for the entire round trip duration of the PMreq CMP exchange. There may be delays on the other CPU due to a frequency change etc. which further prolongs the duration of the lock up.

In accordance with the embodiments described herein a virtual message channel and driver are disclosed for enabling multi flow access to the message channel infrastructure within a CPU of a processor based system. Each pcode flow that uses the message channel is assigned a virtual channel identifier. Each flow with a virtual channel identifier can register a callback address and can submit one message channel transaction for processing. The transaction will be processed either immediately or at some future time by a message channel driver.

In the following detailed description reference is made to the accompanying drawings which show by way of illustration specific embodiments in which the subject matter described herein may be practiced. However it is to be understood that other embodiments will become apparent to those of ordinary skill in the art upon reading this disclosure. The following detailed description is therefore not to be construed in a limiting sense as the scope of the subject matter is defined by the claims.

In some embodiments the optimization method solves the issues described in the background section for systems such as the multiprocessor system of by using the virtual message channels rather than blocking use of the message channel . Although the optimization method addresses a problem found in multiprocessor systems the method may also be used in single processor systems.

Users denoted as user A user B . . . user K K collectively users represent portions of the pcode flow throughout the multiprocessor system. Tools consisting of application programming interface API and helper functions are available to both the message channel driver and to the users .

In some embodiments the method assigns a virtual channel identifier VOID to each user pcode flow that uses the message channel . Virtual channel identifiers A . . . K collectively VCIDs are available to each user A B . . . K respectively. Each pcode flow with a VCID is also capable of registering a callback address. Callback addresses A B . . . K are featured in for users . . . K respectively collectively callback addresses . The callback address for each user enables the message channel driver to return to the pcode flow at the appropriate address following processing of the message channel transaction for that user. Each user with a VCID can submit one message channel transaction for processing.

In some embodiments each user A . . . K includes a respective buffer A B . . . K collectively buffers . The buffers are temporary storage for message channel data that is to be returned following a message transaction. In some embodiments the message channel driver retrieves the returned data to the respective buffer when processing message channel transactions.

Further in some embodiments the message channel driver includes a queue to keep track of transactions that are waiting to be processed. When processing a succeeding transaction the message channel driver will retrieve the transaction from the queue . In some embodiments the queue is a first in first out queue.

The users of are presumed to be those pcode flows in which message channel transactions are to take place. Other pcode flows may not engage in message channel transactions. Such pcode flows are thus not assigned a VOID in some embodiments. Nevertheless as is shown below in some embodiments pcode flows for both message channel transactions and non message channel transaction benefit from the optimization method described herein.

In some embodiments the message channel transaction is processed either immediately or at some future time by the message channel driver . The message channel driver registers an event that causes a kernel within the processor based system to run a callback function when the message channel transaction has completed. The user pcode flow that submitted the transaction becomes notified of the completion when its callback function runs enabling the user to take any further desired actions subsequent to the completion.

For those tasks involving message channel transactions the task is divided into 1 preparation of data 2 a transaction on the message channel 3 processing of the results of the message channel and 4 other data processing that may not be message channel related.

At a first time period time period task a first pcode flow user begins block . Following data preparation block at time period the pcode flow issues a message channel transaction at time period block thus invoking the message channel . The first pcode flow waits for the transaction to complete block with no further processing taking place. In this example there is a timeout period of 100 time units and the pcode flow is blocked during that entire period known as a blocking transaction. At time period the results of the message transaction are processed block and task is completed block .

The pcode flow further includes a second task task . Task commences at time period block . Data processing takes place at time period block and task is completed by time period block with additional tasks to be performed following the completion of task .

Initially the first part of the first task task is processed in a manner similar to how task was processed in . At a first time period time period task a first pcode flow begins block . Following data preparation at time period block the pcode flow issues a message channel transaction at time period block thus invoking the message channel . In this example rather than having the first pcode flow wait for the transaction to complete as in block of the message channel transaction is queued by the message channel driver in time period block . Task the first part of task is completed at time period block .

As with the method in the method the pcode flow further includes the second task task . Task commences at time period block . Data processing takes place at time period block and task is completed by time period block with additional tasks to be performed following the completion of task . Note that in task completed at time period while in the current example task completed one hundred time units sooner at time period .

Returning to the processing of the first task when the message channel transaction is issued block the transaction is being processed just as in . And just as in the the transaction uses 100 time periods to be processed. In the transaction processing has not been disrupted or changed instead the transaction is queued by the message channel driver allowing the task processing to complete such that the next task task may be processed.

Meanwhile in some embodiments when the message channel transaction that was initiated during task completes a hardware event is generated in time period block . The message channel driver responds to the hardware event by issuing a callback to the address of the second part of task task in time period block . The callback address for the given pcode flow user contains the address. Task commences in time period block . Since the message channel transaction is completed the results processing is performed in time period block and task ends in time period block .

It is instructive to compare the operations of with the optimized operations of . In two pcode flow tasks task and task are processed in 108 time periods. In the same two pcode flow tasks task and task with the first task further being subdivided into tasks and are processed in 107 time periods for an improvement of one time period. Furthermore however there is a further opportunity for additional tasks to be processed sequentially following the completion of task with 95 time periods being available between time period and time period . And either tasks that issue message channel transactions such as task or tasks that do not issue message channel transactions such as task may be processed during these 95 time periods. Thus the operations of provide additional opportunities for efficient processing of message channel transactions without the need to block one or more transactions.

Further in some embodiments the processing of the task transactions commences much earlier with the method than in the method . And by being able to process more tasks sequentially in the 95 additional time periods the cycles may provide a functional benefit to the system processing the transactions. In some embodiments the pcode issues hundreds of message channel transactions per millisecond so the potential benefit of using the cycles may be significant.

Recall that both the message channel driver and the users use tools to assist with performing the optimization method . shows the tools used by the optimization method in some embodiments. There are four functions and which are classified as application programming interface API functions and two functions and which are deemed helper functions. Functionally the user interfaces with the driver via the API functions and the driver interfaces with the processor. The API functions therefore enable the users to access the processor via the driver .

In some embodiments the first API function is virtual message channel busy enables the user to determine whether its virtual channel is busy or idle. The VCID for the user is provided as an input to this function . Recall that based on the VCID the virtual channel is assigned to the user . If the user senses a request on its virtual channel another request cannot be sent until the first message has been processed. Thus before proceeding with the second message the user ascertains using the API function whether its virtual message channel is not busy. Further if the message channel request is one that returns data the user uses the API function to determine whether the request has been completed thus enabling the user to retrieve the returned data. The API function is thus essentially a handshaking mechanism between the user and the message channel driver . The API function returns a run busy bit for the virtual message channel specified by the VCID for the user .

In some embodiments the second API function message channel virtual read returns the contents of the virtual message channel specified by the input VCID . In some embodiments a 64 bit message channel payload result is returned by the API function . The message channel driver returns the read information to the buffer associated with the user . Thus upon invoking this read function the user will read the contents of the buffer .

In some embodiments the third API function message channel virtual send is the means by which the user sends a message on the message channel using its virtual message channel . Recall that the message channel is used by many disparate pcode flows and functions between endpoints in the processor such as to read and write uncore control registers issue power management requests PMReqs as well as to send messages to other platform entities e.g. other CPUs PCHs in the multiprocessor system . Again the VCID for the user is provided as an input to this function . Once the message is on the virtual message channel the message channel driver is able to process the message on the message channel .

In some embodiments the fourth API function message channel virtual send PMreq is a special version of the third API function which processes a PMreq transmission. As with the other API functions the VCID for the user is provided as an input to this function . PMreq short for power management request is a special type of transaction used by the QPI bus that interconnects between CPUs .

While both the users and the message channel driver use the above API functions only the driver uses the helper functions and in some embodiments. The helper functions allow facile movement of data between the virtual channels and the physical message channel . The first helper function message channel send to physical enables the message channel driver to send data to the physical message channel . The second helper function message channel poll physical with timeout enables the message channel driver to poll the physical message channel for completion of an operation and includes a timeout.

In some embodiments the message channel driver registers an event that causes a kernel within the single processor based system or the multiprocessor system to run a callback function when the message channel transaction has completed. The event is a hardware event such as an interrupt that indicates that the message channel is no longer busy which means that the last thing the driver put in the message channel has completed.

In some embodiments on behalf of a user pcode flow the message channel driver puts a message from the assigned virtual channels of the user into the message channel . The message channel driver understands whether the message is to return data or not. Where data is to be returned the message channel driver retrieves the data and puts it in the buffer dedicated to the user . Subsequent to the retrieval by the driver the user employs API read function to retrieve the contents of the buffer .

Once the processing of a message channel transaction on behalf of one user is completed the message channel driver may proceed to connect another virtual channel to the message channel on behalf of another user .

First describes the send operation. Before the user can issue any transaction on the message channel the user assigned virtual message channel must be available in some embodiments. Thus the user issues the first API function to determine whether the virtual message channel is available block . Once available the user issues an API send function either the general API send function or the specialized API send PMreq function block . The user also registers a callback address block that the message channel driver will use to return to a predetermined address of the user block . At this point the message channel send transaction is queued by the message channel driver block . This frees up the user to continue with other transaction processing.

When the send transaction is issued by the user the message channel may not be available. The pcode of a typical multiprocessor system uses the message channel quite frequently from hundreds to thousands of times per millisecond. Thus until the message channel is not busy the send transaction is not processed block . Once the message channel is available a hardware event such as an interrupt will notify the message channel driver that the message channel is available.

The message channel driver however is processing virtual message channel transactions for a number of different users. Once the message channel is available and once the user is at the top of the message channel driver s queue the message channel driver sends the message channel transaction from the user s virtual channel to the message channel block . Once at the message channel the message channel transaction is processed block . The message channel driver then registers an event. This event causes the kernel of the single processor based system or multiprocessor system to run the callback function to the callback address of the user block . The user is thus able to complete the send transaction block .

Once the message channel is available block and once the user is at the top of the message channel driver s queue the message channel driver sends the message channel transaction from the user s virtual channel to the message channel block . Once at the message channel the message channel transaction is processed block . The message channel driver then registers an event. This causes the kernel of the single processor based system or multiprocessor system to run the callback function to the callback address of the user block . Since the transaction is a read transaction the message channel driver put the contents of the read in the buffer of the user . The user thus retrieves the contents of the buffer block and completes the read transaction block .

The message channel optimization method and system thus enable multi flow access to the message channel infrastructure within a CPU of a single processor based system or multiprocessor system. The user employs a virtual channel to submit message channel transactions with the message channel driver processing the transaction behind the scenes . Each transaction will be processed either immediately or at some future time by the message channel driver. Tasks involving message channel transactions as well as non message channel transactions are processed more efficiently in some embodiments.

While the application has been described with respect to a limited number of embodiments those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover all such modifications and variations as fall within the true spirit and scope of the invention.

