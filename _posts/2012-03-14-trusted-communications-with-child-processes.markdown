---

title: Trusted communications with child processes
abstract: A method to identify a child process to a parent process in an operating system includes obtaining a token and login identifier from the operating system. The parent process creates a remote procedure call communications endpoint to communicate with the child process. Thereafter, a child process is spawned by the parent process. A child-initiated request to communicate with the parent process is then received by the parent process. In order to verify the identity of the child-initiated request, the parent process impersonates the child process and receives as identifier that identifies the requestor child process. The requestor process identifier and the spawned child identifier are compared. Based on the comparison, the parent process responds to the child-initiated request. In another embodiment, process identifiers are used by the parent process to verify the identity of a child process the requests communication with the parent process.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943579&OS=08943579&RS=08943579
owner: Microsoft Corporation
number: 08943579
owner_city: Redmond
owner_country: US
publication_date: 20120314
---
This application is a continuation of U.S. application Ser. No. 11 488 979 filed Jul. 19 2006 now U.S. Pat. No. 8 161 544 issued Apr. 17 2012 the contents of which is incorporated herein by reference in its entirety.

This invention relates in general to the field of operating systems and more specifically to a method for identifying a legitimate child process by a parent process in an operating system.

A software application within a computer s operating system typically performs a set of well defined tasks. During the execution of the software application the computer s operating system may create one or more new processes . Sometimes a new process is a sub program. Hence it is not surprising that during the execution of a process e.g. a software application the operating system may create a set of new sub processes which in turn may require the creation of their own sub processes and so on until the entire process is completed executed.

If an operating system creates a sub process while executing a given process then this sub process is called the child process of the given process which in turn is called the parent process . In particular when a child process is created it can communicate with its parent process through an allotted communication channel to send and receive information regarding the tasks that need to be performed.

Since the above mentioned phenomenon of creating sub processes is fairly common among most if not all of the operating systems certain computer viruses denial of service attacks and other malicious systems often try to create malicious processes. These malicious processes can then claim to be the child processes of a legitimate parent process that executes as a part of the software application. Furthermore they can start sending incorrect results to their parent processes their sibling processes and even their child processes. These malicious processes may also perform undesired tasks thereby degrading the efficiency of the operating system and other systems within the computer system. It is clear that although malicious processes are more likely to claim themselves as a legitimate child process of a true parent process the above mentioned phenomenon can even occur with new processes that have gone awry. In some instances a sub process may claim to be the child process of one parent process when they are actually the child processes of another.

It would be beneficial if a method existed that can identify a legitimate child process with respect to its parent process before the child process can communicate with the parent process before the parent process relies on the requesting child process.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

One method to identify a child process to a parent process on an operating system involves the use of impersonation of a child process. In this method the parent process uses the Application Program Interface API of an operating system to initiate a logon session. The API returns a token that can identify security information of the logon session back to the parent process. The parent process creates a Remote Procedure Call RPC communications endpoint and establishes a server that can respond to communication requests. Thereafter a child process is spawned by the parent process. During spawning the parent process keeps a track of a logon identifier of the child process. Further the parent process sets a security descriptor on the child process. The parent process waits for a termination notification from the API of the operating system which indicates the termination of the child process. On receiving the termination notification the parent process refuses communication with the child process and closes the RPC communications endpoint. If no termination notification is received the parent process may receive a requestor initiated request. In order to verify the identity of the requestor the parent process impersonates it. In response the operating system provides the security logon identifier that identifies the requestor process. The parent process then compares the requesting logon identifier with the spawned child logon identifier. In case the comparison of the requesting security identifier and the spawned child security identifier is a match the parent process responds to the child initiated request. If it is not a match the parent process refuses the request.

In another embodiment a method to identify a child process to a parent process on an operating system in computer software involves the use of a process identifier. The parent process uses the API of an operating system to initiate a logon session. The API returns a token that can identify security information of the logon session back to the parent process. The parent process then creates an RPC communications endpoint and establishes a parent server that can respond to communication requests. Thereafter a child process is spawned by the parent process. During spawning the parent process passes the RPC communications endpoint as a command line parameter. A child process identifier of the child process is generated by the OS during spawning. The parent process keeps a track of the child process identifier. Thereafter the parent process sets a security descriptor on the child process. Further the parent process waits for a child process termination notification from the API of the operating system which indicates the termination of a child process. On receiving the child process termination notification the parent process refuses communication with the child process and closes the RPC communications endpoint. While waiting for the child process termination notification the parent process may receive a child initiated request for communication. The requestor initiated request includes a requesting process identifier. In order to verify the identity of the requestor the parent process queries the operating system for a spawned child process identifier. On receiving the spawned child process identifier from the operating system the parent process compares the requestor process identifier with the spawned child process identifier. In case the comparison of the requestor identifier and the spawned child process identifier is a match the parent process responds to the child initiated request. If it is not a match the parent process refuses the child initiated request and closes the RPC communications endpoint.

The parent process creates a remote procedure call RPC endpoint as the communication channel with the child process. The parent process creates a server to respond to requests on the communications endpoint. The parent process spawns a child process passing the endpoint name as a command line parameter and keeps track of the login security identifier Logon SID of the child process which can be determined from the earlier acquired token. A Logon SID is a security identifier SID that identifies a logon session. A logon SID is valid until the user logs off and is unique while the computer is running no other logon session will have the same logon SID. The logon SID can be retrieved from a token using operating system provided APIs.

The parent process also sets a security descriptor on the child process such that only the Local System and Administrators have any access to the child process. This may include setting the owner to Local System and setting the Discretionary Access Control List DACL to allow Admin Local System access. This action prevents any other process running with the same identity as the child process from controlling the child process.

The OS returns a process notification after spawning. On receiving a special purpose termination process notification the parent process refuses communication with any process and closes the RPC communications endpoint. The termination notification API returns only if the child process terminates or is terminated. Anytime the process terminates the parent process refuses all communication requests closes the endpoint and starts over if a new child process is needed. Otherwise the parent process continues and waits for a child process request.

The parent process waits for the child process to communicate a request for service of the parent process. The parent process waits for this request in a separate thread. An operating system supplied API is used for this purpose. The child process makes a communication request for receiving sending data on the parent process by communicating with the supplied endpoint.

At this point the parent process does not know the identity of the process connecting to it. To verify that this is indeed the process it spawned it impersonates the client process. Impersonation is the ability of a thread in a process to execute in a security context that may be different from the security context of the process in which the thread runs. This security context corresponds to some identity on the system. When running in this identity s security context the thread is that identity. The thread uses an access token representing the identity s credentials to obtain access to the securable objects to which the identity has access and no more. Once the child process is impersonated the parent process can determine the Logon SID of the child process from the current thread token. Only if this Logon SID matches the Logon SID determined earlier does the parent process respond positively to the communication request made by the child. Otherwise the child is not properly identified by the parent process and the parent process closes the endpoint.

In one embodiment every communication request received by the parent process on the communication channel from the child process is impersonated and compared to confirm the identity of the requesting child process. It is notable that since the Logon SID is guaranteed to be unique for every unique logon session until the machine is restarted there can be no other process on the machine which can have the same Logon SID. This guarantees that a malicious process cannot masquerade as the child process. This mechanism assumes that the child process does not give its token away to a malicious process.

At step parent process spawns child process and passes the RPC communications endpoint to child process . Child process may be spawned with a limited access. Alternatively child process may be spawned with the same access control as that of parent process . During the spawning parent process keeps track of the logon SID of child process . In one embodiment only a parent process identity can access the spawned child process. Child process can communicate with parent process to retrieve or send additional information on the tasks that are being executed by the child process . To communicate with parent process child process sends a request to parent process . This child initiated request is received by parent process at step . The child initiated request includes a requesting child logon SID. The requesting child logon SID is included for identifying child process as a legitimate child process.

At step parent process impersonates child process to the operating system in order to verify whether the child initiated request for communication is from a legitimate child process of parent process . When parent process impersonates child process a thread containing an impersonation token is created. The impersonation token contains the security information of the logon session initiated by parent process . Using the impersonation token generated during the impersonation process parent process with the help of the operating system can identify a spawned child logon SID.

At step parent process compares the requesting child login SID with the spawned child logon SID. If the comparison of the security identifiers is a match at step parent process responds to the child initiated request at step . If subsequent child initiated process are generated at step then step are repeated. If the security identifiers do not match parent process refuses the child initiated request to communicate at step .

The parent process creates the remote procedure call RPC endpoint as the communication channel with the child process. The parent process creates a server to respond to requests on the communications endpoint. The parent process may spawn child process and pass the token to the spawned child process . The parent process also keeps track of the child process identifier that is returned when the child process is spawned. The child process identifier is a value that can be used to identify a process. The value is valid from the time the process is created until the time the process is terminated.

The parent process then waits for the child process to request service of the parent process. Child process communicates a request for service with parent process through the RPC communication channel.

The parent process spawns a child process passing the endpoint name as a command line parameter and keeps track of the child process identifier returned when spawning it. The parent process sets a security descriptor on the child process such that only the local system and administrators have any access to the child process. This may include setting the owner to Local System and setting the DACL to allow the Administrator or Local System access. This prevents any other process running with the same identity as the child process from controlling the child process.

The child process may return a special purpose termination process notification after spawning. An operating system supplied API may be used for this purpose. The API returns only if the child process terminates or is terminated. Anytime the process terminates the parent process refuses all communication requests closes the endpoint and starts over if a new child process is needed.

The parent process waits for the child process to communicate a request for service of the parent process. The parent process waits for this request in a separate thread. The child process makes a communication request for receiving sending data on the parent process by communicating with the supplied endpoint.

At this point the parent process does not know the identity of the process connecting to it. To verify that this is indeed the process it spawned the parent queries for the child process identifier from the communications channel. In one embodiment this is available on Windows XP and up. Only if the requesting child process identifier matches the process identifier for the process the parent process spawned does the parent process respond positively to the communication request. Otherwise the child is not properly identified by the parent process and the parent process closes the endpoint.

In one embodiment every communication request received by the parent process on the communication channel from the child process has an child process identifier which is compared to a known spawned child process identifier to confirm the identity of the requesting child process. Since process identifiers can be recycled by the operating system there is a possibility that the child process is killed and a malicious process gets itself created with the same process identifier. To prevent this the parent process can identify if the child process was ever terminated. If it was terminated the child process request for parent process service is ignored.

At step parent process spawns child process and passes the RPC communications endpoint to child process . Child process may be spawned under the same security information as parent process . Alternatively child process may be created under different security information as compared to parent process . During the spawning of child process a child process identifier is generated. The child process identifier is a unique identifier that can be used to identify child process . The child process identifier is then transmitted by security subsystem of the operating system to parent process . The parent process then keeps a track of the child process identifier. For example in MICROSOFT s Windows Operating System and its variants an API returns the child process identifier of child process to parent process . The child process identifier can uniquely identify child process while the computer system executes processes in the operating system i.e. no other process should have the same child process identifier. Moreover the child process identifier is valid from the time child process is created to the time child process is terminated.

During the spawning of child process parent process passes the RPC communications endpoint as one of the command line parameters to child process . Child process can then communicate with parent process by using the RPC communications endpoint. Once child process is spawned parent process sets a security descriptor on child process . The security descriptor contains information pertaining to access rights provided to other processes for accessing a child process .

Further during the operation of an application a parent process might receive a process termination notification from the operating system. It informs a parent process that its child process has been terminated. Parent process then checks if the child process notification has been returned by the operating system. If parent process receives the child process notification in a separate thread from the operating system parent process refuses all communication requests from child process . Thereafter parent process closes the RPC communications endpoint for child process .

While parent process waits for the child process termination notification from the operating system parent process receives a child initiated request from child process at step . In one embodiment the child initiated communications request may include for example a request for sending or receiving data from parent process . Child process addresses the child initiated request to the RPC communications endpoint. Along with the child initiated request child process also transmits the child process identifier to parent process . In a more secure environment the parent process gets the child s process identifier from the operating system since the child process itself isn t necessarily trustworthy. The child process identifier is referred to as a requesting child process identifier. At the instance of receiving the child initiated request parent process may not recognize the identity of the child process that transmitted the child initiated request and hence does not respond to the child initiated request immediately. To verify that the child initiated request is from an existing child process of parent process the parent process checks if the requesting child process identifier and the child process identifier of the child process are the same. As a result at step parent process queries the operating system for a spawned child process identifier. The operating system then provides the spawned child process identifier to parent process .

At step parent process compares the requesting child process identifier with the spawned child process identifier. If the requesting process identifier and the spawned child process identifier match at step then the parent process acknowledges that the process corresponding to the initiated request is a legitimate child process . Thereafter parent process responds to the child initiated request from child process at step . Further for every new child initiated request at step parent process repeats the steps of querying comparing and responding as described in the preceding paragraphs and steps . If the requesting child process identifier and the spawned child process identifier do not match at step then parent process closes the RPC communications endpoint.

Although not required embodiments of the invention can also be implemented via an operating system for use by a developer of services for a device or object and or included within application software. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. Typically the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover those skilled in the art will appreciate that various embodiments of the invention may be practiced with other computer configurations. Other well known computing systems environments and or configurations that may be suitable for use include but are not limited to personal computers PCs automated teller machines server computers hand held or laptop devices multi processor systems microprocessor based systems programmable consumer electronics network PCs appliances lights environmental control elements minicomputers mainframe computers and the like. Embodiments of the invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network bus or other data transmission medium. In a distributed computing environment program modules may be located in both local and remote computer storage media including memory storage devices and client nodes may in turn behave as server nodes.

With reference to an exemplary system for implementing an example host computer includes a general purpose computing device in the form of a computer system . Components of computer system may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures.

Computer system typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer system and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to Random Access Memory RAM Read Only Memory ROM Electrically Erasable Programmable Read Only Memory EEPROM flash memory or other memory technology Compact Disk Read Only Memory CDROM compact disc rewritable CDRW digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can accessed by computer system .

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer system such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer system may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM CDRW DVD or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer system . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer system through input devices such as a keyboard and pointing device commonly referred to as a mouse trackball or touch pad. Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface which may in turn communicate with video memory not shown . In addition to monitor computer systems may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer system may operate in a networked or distributed environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer system although only a memory storage device has been illustrated in . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer system is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer system typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer system or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

As mentioned above while exemplary embodiments of the invention have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any computing device or system in which it is desirable to implement a method for identifying child processes in an operating system. Thus the methods and systems described in connection with embodiments of the present invention may be applied to a variety of applications and devices. While exemplary programming languages names and examples are chosen herein as representative of various choices these languages names and examples are not intended to be limiting. One of ordinary skill in the art will appreciate that there are numerous ways of providing object code that achieves the same similar or equivalent systems and methods achieved by embodiments of the invention.

The various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. Thus the methods and apparatus of the invention or certain aspects or portions thereof may take the form of program code i.e. instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other machine readable storage medium wherein when the program code is loaded into and executed by a machine such as a computer the machine becomes an apparatus for practicing the invention.

While aspects of the present invention has been described in connection with the preferred embodiments of the various figures it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. Furthermore it should be emphasized that a variety of computer platforms including handheld device operating systems and other application specific operating systems are contemplated especially as the number of wireless networked devices continues to proliferate. Therefore the claimed invention should not be limited to any single embodiment but rather should be construed in breadth and scope in accordance with the appended claims.

