---

title: System, method, and computer program product for sampling a hierarchical depth map
abstract: A system, process, and computer program product are provided for sampling a hierarchical depth map. An approach for sampling the hierarchical depth map includes the steps of generating a hierarchical depth map and reading a value associated with a sample pixel from a target level of the hierarchical depth map based on a difference between the sample pixel and a target pixel. The hierarchical depth map includes at least two levels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09111393&OS=09111393&RS=09111393
owner: NVIDIA Corporation
number: 09111393
owner_city: Santa Clara
owner_country: US
publication_date: 20121126
---
The present invention relates to computer graphics and more particularly to the algorithms that utilize depth buffers.

Depth buffers store a plurality of values that indicate a depth for surfaces of objects in a three dimensional scene. Depth buffers are implemented for many types of computer graphics rendering applications. A depth value may be used to determine whether an object is occluded by other objects relative to a particular viewpoint. Typically a depth buffer includes a plurality of values associated with a corresponding plurality of pixels in a digital image. Each value in the depth buffer may represent the depth of the closest object to a viewpoint corresponding with a particular pixel.

Some algorithms such as screen space ambient occlusion algorithms sample a plurality of different values within the depth buffer to calculate an ambient obscurance AO value for each pixel. The net performance of these techniques suffers because of a large number of scattered reads of the depth buffer which yields low cache efficiency. Thus there is a need for addressing this issue and or other issues associated with the prior art.

A system method and computer program product are provided for sampling a hierarchical depth map. An approach for sampling the hierarchical depth map includes the steps of generating a hierarchical depth map and reading a value associated with a sample pixel from a target level of the hierarchical depth map based on a difference between the sample pixel and a target pixel. The hierarchical depth map includes at least two levels.

Many different types of rendering algorithms utilize depth buffers i.e. Z buffers n one or more calculations as part of the algorithm. For example Ambient Occlusion AO algorithms generate a shading effect to approximate the way light radiates in the real world. The AO algorithms determine the amount by which nearby geometry occludes a specific point on a surface. If the nearby geometry occludes the point then the point may be rendered to include a shadow e.g. rendered with a lower intensity . However if nearby geometry does not occlude the point then the point may be rendered without a shadow e.g. rendered with a higher intensity . It will be appreciated by one of ordinary skill that performing ambient occlusion calculated in model space i.e. by sampling each object to determine if the object occludes the point cannot be performed in real time at full high definition resolution using conventional GPUs while maintaining interactive frame rates. Therefore one technique that generates sufficient approximations to a full AO algorithm is screen space ambient occlusion SSAO .

In SSAO algorithms the model is first rasterized to produce a depth buffer that associates each pixel location or sample location if the depth buffer is implemented at a sub pixel resolution with a depth of the geometry that is closest to the viewpoint for the pixel. Once the depth buffer is generated an approximate ambient obscurance for a pixel may be calculated by sampling a plurality of nearby pixels to determine whether that pixel is likely occluded by the nearby geometry. In some SSAO algorithms both the depth and the surface normal for each pixel may be used to determine the approximate occlusion. Conventional SSAO algorithms have poor performance due to the scattering of the sampled points in the depth buffer which yields low cache efficiency and generates a large number of long latency memory access requests.

An exemplary technique for encoding depth buffers is disclosed which improves performance of algorithms that sample a large number of scattered entries in the depth buffer thereby improving cache efficiency and reducing the number of long latency memory access requests for sampling nearby entries.

At step a depth buffer is generated by performing a high precision Z pass in a graphics processing unit GPU . In one embodiment the high precision Z pass is performed as a depth only pre pass through a GPU. A set of model data i.e. graphics primitives such as triangles quads or triangle strips is transmitted to a GPU. The model data is transformed and rasterized in depth to produce a z coordinate for each fragment i.e. portion of a pixel associated with a given surface object . The z coordinate is tested against all other z coordinates associated with that pixel location to determine the closest object to a particular viewpoint and if the z coordinate is the closest object then the z coordinate is stored in the depth buffer at an entry corresponding to that pixel location. Once all of the model data has been rasterized the resulting depth buffer represents the length of a ray from the viewpoint to the closest surface at each pixel location in a rasterized image.

In order to increase the accuracy of results in the SAO algorithm care should be taken to populate the depth buffer with the highest precision possible. In one embodiment the precision of the depth buffer may be increased by implementing the following optimizations. A model view projection matrix may be computed at double precision on a host processor before casting the model view projection matrix to single precision for transformations performed in vertex shaders on the GPU. For the model view projection matrix a far clipping plane may be chosen at a depth of negative infinity which may reduce the number of floating point operations performed when calculating the matrix product. In addition when calculating transformations in the GPU half a bit of precision may be saved by multiplying vectors on the left of column major matrices e.g. the model view projection matrix . It will be appreciated that the optimizations above are merely suggestions for improving the accuracy of the algorithm and should not be construed as limiting in any manner.

At step a hierarchical depth map is generated based on the depth buffer. In one embodiment the depth buffer is used to populate a base level of the hierarchical depth map. Typically the depth buffer generated by GPUs stores depth values as floating point values between zero and one. The base level of the hierarchical depth map converts the depth values in the depth buffer to camera space values that indicate a z value between the location of the near clipping plane z and the location of the far clipping plane z . Successive higher levels of the hierarchical depth map are populated by selecting a subset of values from the next lowest level of the hierarchical depth map. The hierarchical depth map includes at least two levels abase level corresponding to the full resolution of the digital image and a first level corresponding to a resolution less than that of the base level e.g. half the resolution of the base level . The higher levels of the hierarchical depth map i.e. level 1 level 2 etc. ensure that spatially distributed samples are read with high cache efficiency i.e. adjacent pixels processed in parallel by the GPU will typically read the same samples from the hierarchical depth map when sampling pixels farther away from the target pixel location . Because a small region of each level of the hierarchical depth map remains in the cache fewer read requests will be transmitted to memory i.e. DRAM resulting in high bandwidth and low latency.

At step for each target pixel of a digital image for which the SAO algorithm is being executed a plurality of sample pixels are selected. In one embodiment for each target pixel the plurality of sample pixels are distributed on a half sphere around a point C centered at a point on a surface intersected by a ray projected from the viewpoint in a direction associated with the target pixel. In one embodiment the point C is reconstructed from a value zwhich is read from the base level of the hierarchical depth map at an index associated with the target pixel given by an x coordinate x and a y coordinate y . The x coordinate and y coordinate of point C are given by the equations 

In Equations 1 and 2 n and h represent the width and height of the digital image and P is the model view projection matrix. Equations 1 and 2 invert the projection matrix at a pixel x y to find a camera space position point C. Equation 3 gives the estimated surface normal at point C based on the screen space gradient of z which gives the orientation of the half ball. The world space radius of the half ball r corresponds to a screen space radius r given by the equation 

In Equation 3 S is the pixel size of a one meter radius object at z equal to negative one meter. In one embodiment the plurality of sample pixels is placed in a spiral pattern around the target pixel. Each sample pixel s is located at a different distance h from the target pixel given by Equation 7 shown below. The location of each of the sample pixels may be given by the following equation 

In Equation 7 constant is the number of turns in the spiral and angular offset is the rotation angle given by Equation 9. In other embodiments the plurality of sample pixels may be distributed at random on the surface of the half ball. However it should be noted that random distribution has the potential to skew the results if the majority of samples are located on only a portion of the half ball.

At step for each sample pixel associated with a target pixel a filtered value is generated by applying a bilateral filter to the hierarchical depth map. Each sample pixel is associated with a particular level m of the hierarchical depth map. A sample value for the sample pixel is given by selecting a value in the particular level of the hierarchical depth map associated with the location of the sample pixel as given by the equation 

In Equation 10 the level m associated with a sample pixel s is clamped to a value greater than or equal to zero and less than or equal to the highest level in the hierarchical depth map. Constant q is a screen space radius increment that represents the distance from the target pixel at which the level of the hierarchical depth map referenced by the sample pixel changes to a different level of the hierarchical depth map. In one embodiment the ratio of h and q is rounded up to the next highest integer. The optimal value for q may depend on the architecture implementing the SAO algorithm. Example values for q that have resulted in accurate ambient obscurance maps as calculated by some experimental architectures are between 8 and 32.

Each sample pixel sis reconstructed by applying Equations 1 and 2 to z i.e. z z . In one embodiment a bilateral 2 2 filter may be applied to the generated sample pixels averaging four weighted values to reduce the variance across a continuous surface i.e. the filter kernel generates the filtered value with Gaussian weights modulated by the difference in depth between the generated sample pixels and nearby pixels .

At step an ambient obscurance map is generated for each of the pixels of the digital image by filtering the raw sample map generated in step using a bilateral filter with a number of taps. The bilateral filter ensures the final value is smoothed across surfaces while not applying the filter across depth discontinuities. In one embodiment a two pass bilateral one dimensional filter is applied one horizontal pass and one vertical pass having seven taps in each pass which generates a final AO value based on 196 sample values per target pixel based on the 2 2 bilateral filter applied in step and the 7 7 taps in the two pass bilateral one dimensional filter applied in step . Each of the taps may be spread out by incrementing the pixel locations by three pixels in each direction. In other embodiments a different number of taps or distance between taps may be implemented in the two pass bilateral one dimensional filter.

More illustrative information will now be set forth regarding various optional architectures and features with which the foregoing framework may or may not be implemented per the desires of the user. It should be strongly noted that the following information is set forth for illustrative purposes and should not be construed as limiting in any manner. Any of the following features may be optionally incorporated with or without the exclusion of other features described.

The base level of the hierarchical depth map is populated from a depth buffer associated with a digital image. In other words each of the depth values in the base level corresponds to a z value stored in the depth buffer for one of the pixels of the digital image. For example a first depth value located at entry Z 0 0 in the base level corresponds to a first pixel in the digital image located at the upper left corner of the digital image. In some embodiments each of the depth values corresponds to a portion of a pixel of the digital image such as embodiments where multi sample antialiasing MSAA is implemented in the graphics pipeline.

The hierarchical depth map includes additional levels e.g. etc. that include a subset of values from the base level of the hierarchical depth map . The resolution of each of the additional levels may be smaller than the next lower level within the hierarchy. For example in one embodiment the resolution of the first level of the hierarchical depth map is half both vertically and horizontally that of the base level of the hierarchical depth map . In other embodiments the resolution of each successive level of the hierarchical depth map may be reduced by a different amount such as the reduction of the resolution by a quarter with each successive level of the hierarchical depth map .

As shown in the hierarchical depth map includes a first level Z at half the resolution of the base level of the hierarchical depth map . Each of the depth values stored in the first level Z corresponds to a single one of the depth values stored in the base level of the hierarchical depth map . Unlike a mip map where the values in the lower resolution mip maps are calculated as an average of multiple values sampled from a higher resolution mip map each of the values in a particular level of the hierarchical depth map is selected from one of every N values e.g. one out of every 4 values of the previous level in the hierarchy.

In one embodiment the values selected from the next lower level of the hierarchical depth map are selected based on a rotated grid pattern. An equation governing the selection of values according to one such rotated grid pattern is illustrated by Equation 12 2 2 Eq. 12 

In other words a depth value stored in an m 1 level of the hierarchical depth map having an x coordinate and a y coordinate is selected from an m level of the hierarchical depth map that 1 has a first coordinate calculated as two times the x coordinate plus an exclusive bitwise OR of one and a bitwise AND of the y coordinate and one and 2 has a second coordinate calculated as two times the y coordinate plus an exclusive bitwise OR of one and a bitwise AND of the x coordinate and one. The rotated grid pattern set forth above selects four depth values for every sixteen depth values in a particular level of the hierarchical depth map to generate four corresponding values in the next successive level of the hierarchical depth map . Other embodiments may select the depth values based on a different type of mapping such as a mapping that selects the upper left value in every 2 2 array of pixels or a mapping that selects four depth values for every sixty four depth values in the case where resolution is quartered . It is contemplated that other types of mappings are within the scope of the present disclosure.

The hierarchical depth map also includes a second level Z at half the resolution of the first level of the hierarchical depth map . In other words the second level is at quarter the resolution of the base level of the hierarchical depth map . The depth values stored in entries of the second level correspond to depth values stored in entries of the first level of the hierarchical depth map according to the same mapping that is used to map depth values stored in entries of the first level depth values stored in entries of the base level of the hierarchical depth map . For example a first depth value stored in entry Z 0 0 in the second level of the hierarchical depth map corresponds to a fourth depth value stored in entry Z 1 1 in the first level of the hierarchical depth map . The first depth value stored in entry Z 0 0 in the second level of the hierarchical depth map also corresponds to a fourth depth value stored in entry Z 2 2 in the base level of the hierarchical depth map . In one embodiment the different levels of the hierarchical depth map may be generated in parallel.

Although not shown additional levels may be included in the hierarchal depth map up to a final level i.e. a Klevel that only includes a single depth value stored in entry Z 0 0 . Specific implementations may omit any number of levels of the hierarchal depth map as long as the hierarchal depth map includes at least one additional level in addition to the base level .

In one embodiment when reading a sample from the hierarchal depth map a thread determines which level mof the hierarchal depth map the sample should be read from such as by applying Equation 10 to the location of the sample pixel . The circles represent the portion of the screen space corresponding to different levels of the hierarchical depth map . For example the first circle represents one i.e. 2 times qand has a radius of four pixels. The second circle represents two i.e. 2 times qand has a radius of eight pixels. The third circle represents four i.e. 2 times qand has a radius of sixteen pixels. As stated above the screen space radius increment qis typically between 8 and 32 for good results. However a screen space radius increment of four pixels is shown in for illustrative purposes.

Reading a depth value for each sample pixel located inside the first circle is performed by reading a value from the base level of the hierarchical depth map . Reading a depth value for each sample pixel located between the first circle and the second circle is performed by reading a depth value from the first level of the hierarchical depth map . Reading a depth value for each sample pixel located between the second circle and the third circle is performed by reading a depth value from the second level of the hierarchical depth map and so forth.

For example as shown in a target pixel may have an x coordinate of 24 and a y coordinate of 8 with respect to the upper left pixel of the digital image i.e. a pixel with an x coordinate of 0 and a y coordinate of 0 . Each of the shaded pixels in represents a sample pixel used in the calculation of the ambient obscurance value. The sample pixel is located at an x coordinate of 30 and a y coordinate of 7 with respect to the upper left pixel of the digital image . In order to determine which level of the hierarchical depth map to read the depth value associated with sample pixel the distance of the sample pixel to the target pixel is calculated. As shown in the distance hfor sample pixel is approximately 5 pixels and the value zi for sample pixel is read from the first level of the hierarchical depth map .

in one embodiment the PPU includes an input output I O unit configured to transmit and receive communications i.e. commands data etc. from a central processing unit CPU not shown over the system bus . The I O unit may implement a Peripheral Component Interconnect Express PCIe interface for communications over a PCIe bus. In alternative embodiments the I O unit may implement other types of well known bus interfaces.

The PPU also includes a host interface unit that decodes the commands and transmits the commands to the grid management unit or other units of the PPU e.g. memory interface as the commands may specify. The host interface unit is configured to route communications between and among the various logical units of the PPU .

In one embodiment a program encoded as a command stream is written to a buffer by the CPU. The buffer is a region in memory e.g. memory or system memory that is accessible i.e. read write by both the CPU and the PPU . The CPU writes the command stream to the buffer and then transmits a pointer to the start of the command stream to the PPU . The host interface unit provides the grid management unit GMU with pointers to one or more streams. The GMU selects one or more streams and is configured to organize the selected streams as a pool of pending grids. The pool of pending grids may include new grids that have not yet been selected for execution and grids that have been partially executed and have been suspended.

A work distribution unit that is coupled between the GMU and the SMs manages a pool of active grids selecting and dispatching active grids for execution by the SMs . Pending grids are transferred to the active grid pool by the GMU when a pending grid is eligible to execute i.e. has no unresolved data dependencies. An active grid is transferred to the pending pool when execution of the active grid is blocked by a dependency. When execution of a grid is completed the grid is removed from the active grid pool by the work distribution unit . In addition to receiving grids from the host interface unit and the work distribution unit the GMU also receives grids that are dynamically generated by the SMs during execution of a grid. These dynamically generated grids join the other pending grids in the pending grid pool.

In one embodiment the CPU executes a driver kernel that implements an application programming interface API that enables one or more applications executing on the CPU to schedule operations for execution on the PPU . An application may include instructions i.e. API calls that cause the driver kernel to generate one or more grids for execution. In one embodiment the PPU implements a SIMD Single Instruction Multiple Data architecture where each thread block i.e. warp in a grid is concurrently executed on a different data net by different threads in the thread block. The driver kernel defines thread blocks that are comprised of k related threads such that threads in the same thread block may exchange data through shared memory. In one embodiment a thread block comprises 32 related threads and a grid is an array of one or more thread blocks that execute the same stream and the different thread blocks may exchange data through global memory.

In one embodiment the PPU comprises X SMs X . For example the PPU may include 15 distinct SMs . Each SM is multi threaded and configured to execute a plurality of threads e.g. threads from a particular thread block concurrently. Each of the SMs is connected to a level two L2 cache via a crossbar or other type of interconnect network . The L2 cache is connected to one or more memory interfaces . Memory interfaces implement 16 32 64 128 bit data buses or the like for high speed data transfer. In one embodiment the Pal comprises U memory interfaces U where each memory interface U is connected to a corresponding memory device U . For example PPU may be connected to up to 6 memory devices such as graphics double data rate version 5 synchronous dynamic random access memory GDDR5 SDRAM .

In one embodiment the PPU implements a multi level memory hierarchy. The memory is located off chip in SDRAM coupled to the Pal . Data from the memory may be fetched and stored in the L2 cache which is located on chip and is shared between the various SMs . In one embodiment each of the SMs also implements an L1 cache. The L1 cache is private memory that is dedicated to a particular SM . Each of the L1 caches is coupled to the shared L2 cache . Data from the L2 cache may be fetched and stored in each of the L1 caches for processing in the functional units of the SMs .

In one embodiment the PPU comprises a graphics processing unit GPU . The PPU is configured to receive commands that specify shader programs for processing graphics data. Graphics data may be defined as a set of primitives such as points lines triangles quads triangle strips and the like. Typically a primitive includes data that specifies a number of vertices for the primitive e.g. in a model space coordinate system as well as attributes associated with each vertex of the primitive. The PPU can be configured to process the graphics primitives to generate a frame buffer i.e. pixel data for each of the pixels of the display . The driver kernel implements a graphics processing pipeline such as the graphics processing pipeline defined by the OpenGL API.

An application writes model data for a scene i.e. a collection of vertices and attributes to memory. The model data defines each of the objects that may be visible on a display. The application then makes an API call to the driver kernel that requests the model data to be rendered and displayed. The driver kernel reads the model data and writes commands to the buffer to perform one or more operations to process the model data. The commands may encode different shader programs including one or more of a vertex shader shader geometry shader pixel shader etc. For example the GMU may configure one or more SMs to execute a vertex shader program that processes a number of vertices defined by the model data. In one embodiment the GMU may configure different SMs to execute different shader programs concurrently. For example a first subset of SMs may be configured to execute a vertex shader program while a second subset of SMs may be configured to execute a pixel shader program. The first subset of SMs processes vertex data to produce processed vertex data and writes the processed vertex data to the L2 cache and or the memory . After the processed vertex data is rasterized i.e. transformed from three dimensional data into two dimensional data in screen space to produce fragment data the second subset of SMs executes a pixel shader to produce processed fragment data which is then blended with other processed fragment data and written to the frame buffer in memory . The vertex shader program and pixel shader program may execute concurrently processing different data from the same scene in a pipelined fashion until all of the model data for the scene has been rendered to the frame buffer. Then the contents of the frame buffer are transmitted to a display controller for display on a display device.

The PPU may be included in a desktop computer a laptop computer a tablet computer a smart phone e.g. a wireless hand held device personal digital assistant PDA a digital camera a hand held electronic device and the like. In one embodiment the PPU is embodied on a single semiconductor substrate. In another embodiment the PPU is included in a system on a chip SoC along with one or more other logic units such as a reduced instruction set computer RISC CPU a memory management unit MMU a digital to analog converter DAC and the like.

In one embodiment the PPU may be included on a graphics card that includes one or more memory devices such as GDDR5 SDRAM. The graphics card may be configured to interface with a PCIe slot on a motherboard of a desktop computer that includes e.g. a northbridge chipset and a southbridge chipset. In yet another embodiment the PPU may be an integrated graphics processing unit iGPU included in the chipset i.e. Northbridge of the motherboard.

As described above the work distribution unit dispatches active grids for execution on one or more SMs of the PPU . The scheduler unit receives the grids from the work distribution unit and manages instruction scheduling for one or more thread blocks of each active grid. The scheduler unit schedules threads for execution in groups of parallel threads where each group is called a warp. In one embodiment each warp includes 32 threads. The scheduler unit may manage a plurality of different thread blocks allocating the thread blocks to warps for execution and then scheduling instructions from the plurality of different warps on the various functional units i.e. cores DPUs SFUs and LSUs during each clock cycle.

In one embodiment each scheduler unit includes one or more instruction dispatch units . Each dispatch unit is configured to transmit instructions to one or more of the functional units. In the embodiment shown in the scheduler unit includes two dispatch units that enable two different instructions from the same warp to be dispatched during each clock cycle. In alternative embodiments each scheduler unit may include a single dispatch unit or additional dispatch units .

Each SM includes a register file that provides a set of registers for the functional units of the SM . In one embodiment the register file is divided between each of the functional units such that each functional unit is allocated a dedicated portion of the register file . In another embodiment the register file is divided between the different warps being executed by the SM . The register file provides temporary storage for operands connected to the data paths of the functional units.

Each SM comprises L processing cores . In one embodiment the SM includes a large number e.g. 192 etc. of distinct processing cores . Each core is a fully pipelined single precision processing unit that includes a floating point arithmetic logic unit and an integer arithmetic logic unit. In one embodiment the floating point arithmetic logic units implement the IEEE 754 2008 standard for floating point arithmetic. Each SM also comprises M DPUs that implement double precision floating point arithmetic N SFUs that perform special functions e.g. copy rectangle pixel blending operations and the like and P LSUs that implement load and store operations between the shared memory L1 cache and the register file . In one embodiment the SM includes 64 DPUs 32 SFUs and 32 LSUs .

Each SM includes an interconnect network that connects each of the functional units to the register file and the shared memory L1 cache . In one embodiment the interconnect network is a crossbar that can be configured to connect any of the functional units to any of the registers in the register file or the memory locations in shared memory L1 cache .

In one embodiment the SM is implemented within a GPU. In such an embodiment the SM comprises J texture units . The texture units are configured to load texture maps i.e. a 2D array of texels from the memory and sample the texture maps to produce sampled texture values for use in shader programs. The texture units implement texture operations such as anti aliasing operations using mip maps i.e. texture maps of varying levels of detail . In one embodiment the SM includes 16 texture units .

The PPU described above may be configured to perform highly parallel computations much faster than conventional CPUs. Parallel computing has advantages in graphics processing data compression biometrics stream processing algorithms and the like.

For example an application in memory may be configured to generate the hierarchical depth map using PPU . In one embodiment the application transmits commands to PPU through the driver kernel that cause PPU to generate a depth buffer for a three dimensional scene. The application may then read the depth buffer from memory or by querying PPU through the driver kernel to generate the hierarchical depth map . In one embodiment the hierarchical depth map may be encoded as a texture map and the steps of the SAO algorithm may be performed in parallel for different target pixels of the digital image by implementing a pixel shader executed on PPU . The threads of the pixel shader may correspond to a particular target pixel of the digital image and the ambient obscurance map may be generated by PPU .

The system also includes input devices a graphics processor and a display i.e. a conventional CRT cathode ray tube LCD liquid crystal display LED light emitting diode plasma display or the like. User input may be received from the input devices e.g. keyboard mouse touchpad microphone and the like. In one embodiment the graphics processor may include a plurality of shader modules a rasterization module etc. Each of the foregoing modules may even be situated on a single semiconductor platform to form a graphics processing unit CPU .

In the present description a single semiconductor platform may refer to a sole unitary semiconductor based integrated circuit or chip. It should be noted that the term single semiconductor platform may also refer to multi chip modules with increased connectivity which simulate on chip operation and make substantial improvements over utilizing a conventional central processing unit CPU and bus implementation. Of course the various modules may also be situated separately or in various combinations of semiconductor platforms per the desires of the user.

The system may also include a secondary storage . The secondary storage includes for example a hard disk drive and or a removable storage drive representing a floppy disk drive a magnetic tape drive a compact disk drive digital versatile disk DVD drive recording device universal serial bus USB flash memory. The removable storage drive reads from and or writes to a removable storage unit in a well known manner.

Computer programs or computer control logic algorithms may be stored in the main memory and or the secondary storage . Such computer programs when executed enable the system to perform various functions. The memory the storage and or any other storage are possible examples of computer readable media.

In one embodiment the architecture and or functionality of the various previous figures may be implemented in the context of the central processor the graphics processor an integrated circuit not shown that is capable of at least a portion of the capabilities of both the central processor and the graphics processor a chipset i.e. a group of integrated circuits designed to work and sold as a unit for performing related functions etc. and or any other integrated circuit for that matter.

Still yet the architecture and or functionality of the various previous figures may be implemented in the context of a general computer system a circuit board system a game console system dedicated for entertainment purposes an application specific system and or any other desired system. For example the system may take the form of a desktop computer laptop computer server workstation game consoles embedded system and or any other type of logic. Still yet the system may take the form of various other devices including but not limited to a personal digital assistant PDA device a mobile phone device a television etc.

Further while not shown the system may be coupled to a network e.g. a telecommunications network local area network LAN wireless network wide area network WAN such as the Internet peer to peer network cable network or the like for communication purposes.

While various embodiments have been described above it should be understood that they have been presented by way of example only and not limitation. Thus the breadth and scope of a preferred embodiment should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

