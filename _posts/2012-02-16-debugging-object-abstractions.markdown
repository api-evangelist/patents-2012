---

title: Debugging object abstractions
abstract: The claimed subject matter provides for systems and/or methods for debugging a computer-executable file. The computer-executable file may be executing in a first runtime environment and located in a first process. The file may further comprise on object having a proxy in that first runtime environment. One method embodiment comprises the steps of debugging said computer-executable file; detecting a proxy for an object called by said file; decoding said proxy to obtain physical information regarding said object; returning said physical object information; and transforming said physical object information into logical object information. In addition, one embodiment of a system is provided that comprising a debugger, said debugger debugging client code; a proxy decoder, said proxy decoder providing information to said debugger about the object pointed by said proxy; and an abstraction transformation, said abstraction transformation transforming physical expressions of a proxy into higher level logical expressions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262298&OS=09262298&RS=09262298
owner: Microsoft Technology Licensing, LLC
number: 09262298
owner_city: Redmond
owner_country: US
publication_date: 20120216
---
Modern software runtime environments create abstractions when implementing Application Programming Interfaces APIs . Such abstractions hide the complexity of the system and provide a logical view of the system to the user.

Debugging objects in such modern software runtime environments presents a challenge as debugging such objects typically executes the code within the context of the application being debugged. As a result debugging objects in an environment potentially changes the environment.

The following presents a simplified summary of the innovation in order to provide a basic understanding of some aspects described herein. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope of the subject innovation. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.

Some embodiments of the present application provide for systems and or methods for debugging a computer executable file. The computer executable file may be executing in a first runtime environment and located in a first process. The file may further comprise on object having a proxy in that first runtime environment.

One method embodiment comprises the steps of debugging said computer executable file detecting a proxy for an object called by said file decoding said proxy to obtain physical information regarding said object returning said physical object information and optionally transforming said physical object information into logical object information.

In addition one embodiment of a system is provided that comprising a debugger said debugger debugging client code a proxy decoder said proxy decoder providing information to said debugger about the object pointed by said proxy and an optional abstraction transformation said abstraction transformation transforming physical expressions of a proxy into higher level logical expressions.

Other features and aspects of the present system are presented below in the Detailed Description when read in connection with the drawings presented within this application.

As utilized herein terms component system interface and the like are intended to refer to a computer related entity either hardware software e.g. in execution and or firmware. For example a component can be a process running on a processor a processor an object an executable a program and or a computer. By way of illustration both an application running on a server and the server can be a component. One or more components can reside within a process and a component can be localized on one computer and or distributed between two or more computers.

The claimed subject matter is described with reference to the drawings wherein like reference numerals are used to refer to like elements throughout. In the following description for purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the subject innovation. It may be evident however that the claimed subject matter may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to facilitate describing the subject innovation.

It is common practice for software runtime environments to create abstractions over the implementation of the application programming interface API provided by that runtime. These abstractions provide the public surface area of the underlying systems implementation. Such abstractions exist to 1 hide the complexities of the system to consumer software 2 allow the implementation of a system to vary from the public surface area and 3 provide a more logical view of the system itself.

These abstractions are created using software interfaces that contain functions or methods to be called from client software code to invoke operations on the system. Software interfaces may also provide access to properties that describe the current state of the system. Often times these properties are implemented using special functions that can get and set desired values. Sometimes these properties are backed by a simple data field but need not be. For runtime systems that use a function based model the properties may be implemented using arbitrarily complex software code.

Viewing the values of these properties of the system as exposed through the abstractions provided by the API is one aspect to developing software running in such an environment. Traditionally debugging objects using a property based system meant actually executing the underlying property getter code. This approach to debugging is usually called function evaluation or func eval . Because the actual code implementing the property is executed within the context of the application being debugged this approach may not be desirable for several reasons 1 since the debugger is injecting calls into the debuggee i.e. the process code and or application being debugged process at random points within the execution of the debuggee process the system or debuggee may not be able to execute the call to the property getter. Therefore values of properties may not be visible in the debugger or inspecting them may result in debuggee corruption 2 if the system contains objects that depend on more threads than the one being inspected func eval based inspection may not work. For instance if the property being evaluated has affinity to a specific thread and is inspected from the wrong thread inspecting that property can lead to deadlocks or debuggee corruption 3 any side effects in the implementation of the property getter may persist in the application 4 constraints of the runtime environment may have to be violated in order to make the call to the property getter. For instance exception unwind information may be incorrect at the time the call is made and 5 the debuggee process should be in a good enough state to actually evaluate the property getter. For instance if the debuggee process is near an out of memory condition or is corrupt enough that threads do not run debugging the system becomes difficult.

Conventional debuggers read values directly from the debuggee application. However the debuggee may call objects that are not in the debuggee s process. In general an out of process object refers to an object and or an application that is called or caused to run by a host object in one process but that runs in a memory space that is different from a host object and its process. The debuggee may contain proxies e.g. an interface that point to objects that are out of process to the debuggee.

In one embodiment native code debuggers have depended on another model for inspecting debuggee state out of process inspection e.g. wherein the debuggee is out of process to the debugger. When the debuggee is out of process to the debugger data values that represent the state of the application are read out of the debuggee process memory without executing code within the debuggee process. This model may increase the reliability of inspecting debuggee process state because obtaining the values may not depend on executing code within the debuggee process at random points. This model may be desirable as evaluation may not depend on the stability of the debuggee side effects of evaluations may not persist debuggees may not be corrupted by the debugger and offline dump scenarios may work.

However the out of process inspection model may have several areas for improvement 1 the abstractions created in the public API specifically properties may be lost. Thus the end developer debugging code running on such a runtime may have to understand enough of the implementation details of the platform to mentally rebuild the abstraction from the underlying raw data 2 such rebuilding of the abstraction may not be possible if the value is calculated when the property is called or no underlying data exists and 3 distributed objects running in another software context or process may be opaque to the debugger. One example of such opaqueness is proxy objects and or interfaces that stand in for real implementations but route calls across a protocol to another process.

One embodiment of a debugger made in accordance with this present application may comprise a debugging methodology of an application on a system using a property getter model where such property getter model may use the out of process inspection of objects avoiding the limitations of the func eval model while allowing the platform s original abstraction to be accurately modeled as well as removing the opaqueness of proxied objects being inspected in such a system.

To give perspective depicts one aspect to the complexity of the modern software runtime environments. Multiple processes e.g. Process A and Process B may be executing on one or more computing processors e.g. . . . . Each of these computing processors may be in communication with a subset of each other either directly or indirectly. Each process such as Process A may comprise a number of runtime environments through . Each such runtime environment may be executing on a number of processors. Each of these runtime environments may comprise client code or other objects such as proxies as described further herein. These and other objects should be effectively tracked by any debugger called to debug client code.

One embodiment of a debugger may employ a debugger object inspection model based on out of process inspection. Debugger of the present application may comprise a debugger perhaps a native code debugger a managed debugger a script debugger or any other suitable debugger an optional abstraction transformations and proxy decoder . Debugger reads memory for values during the course of its debugging the client code. During the course of debugging debugger may detect that objects are referenced by the client code that may be in a second i.e. different runtime environment than the first runtime environment but possibly in the same process that contains the client code. At other times debugger may detect that objects are referenced that are not only in a different runtime environment but may also be out of process to the client code. Occasionally these object references may comprise calls to proxies for implementations that are in a different runtime environment than and possibly out of process to the client code.

Abstraction transformation may optionally be called and used to convert the raw fields of objects within the system into a logical higher level view of the public abstractions provided by that system. Proxy Decoder may affect a method and or mechanism of decoding opaque proxies to objects running within another software context such as apartment or process. In addition it may be desired that the debugger display decoded proxy objects within the context of the proxy itself again perhaps using an out of process based debugger inspection model.

Out of process debugger inspection of an object uses the ability of a debugger to directly read the underlying data for an object out of debuggee memory. The debugger finds the object in question using the state of the debuggee process and the debug information for the type. An example of such debug information is the Program Database file PDB created by current compilers. The PDB defines among other things the physical structure of the layout of memory for a class as well as source code names for each piece of data contained within the class. However in practice the actual data fields backing the object often do not match up with the properties from the public abstraction of a class. Therefore the developer should understand the details of the object in order to transform the implementation of the object into the logical view. In one embodiment the debugger may perform an extra step before presenting the view of a property getter based object to the end developer. This transformation uses information provided by the developer that created the object to transform the physical view of the object into the logical view.

At step the type of the physical object is determined from the debug information. The debugger searches the transforms for one that matches this type taking version information of the type into account at step . In one implementation of this algorithm the transformations may be contained within a separate file from the debug information or the debuggee binaries but it should be appreciated that the transformations may be stored in a variety of known manners.

At step the system checks to see that for each expression contained within the object being viewed that each physical expression has been mapped into a logical expression. Transformations exist that inform the debugger how to perform the mapping from physical expression into to a logical expression. These transforms may contain very complex debugger expressions.

The logical expressions should be evaluated by the debugger within the context of the debuggee at and the object being inspected using out of process inspection. The logical view of the expression is displayed to the end user of the debugging process and or system at . In addition the debugger may also choose to expose the physical view of the object to the user as well.

A simple example of the transformation is as follows. Assume a developer has architected an interface ISquid that contains a single property getter Length . Now assume the concrete implementation of ISquid Length is calculated by obtaining the sub lengths of the various pieces of the squid. For instance it would return the length of the tentacles plus the length of the body plus the length of the fin that sits on top of a squid s head. In C the definition of Length might look like this 

In a typical out of process debugger the end developer would see a view of a CSquid that looks something like this 

The end developer would understand the implementation of the length property well enough to know that the total length is these three values added together. While this is an easy example this becomes much harder when the end developer is missing information about the implementation of CSquid because the developer lacks source code for it as is often the case when debugging code owned by an operating system or third party library. Furthermore as is often the case the abstraction laid out may not be anything like the actual physical implementation.

Continuing with this example the debugger transformation for CSquid would map a logical view of the Length property so the user would see this 

The debugger might interpret this as Any time a type named CSquid from seafood.dll version 2.3.4 until version 3.0 is encountered by the debugger show a property named Length whose value is calculated by evaluating the three sub values . Thus the public abstraction may now be visible in the debugger.

In continued reference to it is common for objects to span multiple runtime environments within the same process or in multiple processes or even across machine boundaries. In such environments objects from a different runtime environment may be represented by Proxies e.g. to client code rather than clients having direct access to the objects or protocols themselves. Concrete examples of runtime environments that make use of the proxy model are cross apartment objects in Microsoft s Component Object Model COM or .Net Remoting. It should be noted that the client object and server objects may be logically separated for some purpose such as thread affinity. A boundary such as a process or machine transition may not exist for this model to be in use. Proxies abstract out the underlying transport mechanism of the runtime transition. Their public interfaces may look substantially identical to the real object but the implementation of the methods route calls across a protocol to the actual implementation object. The protocol may route calls to objects across different runtime environments within the same process to objects in different processes on the same machine or to objects running on another machine.

In an out of process debugger model proxied objects may be opaque to the end developer. The developer may often only see the shape of the public abstraction but may not see any details of the underlying objects. If a func eval is performed to see such details such func eval may be potentially corrupting when actually executed in the context of the debuggee process. In one embodiment of this application these traditionally opaque objects may be unwrapped and displayed to the end developer without the need for func eval.

The protocol used to route calls from proxy to implementation should contain target information about the object being called. In the case of an intra process cross runtime environment call or cross process call such target information may comprise 1 the runtime environment or pointer to the concrete object on target side and 2 the process that the target object resides in. The proxy object may maintain either contain this information directly or obtain it from the system using some unique identifier for the proxy implementation pair. If the underlying runtime can decode this information using a proxy pointer the debugger may obtain the physical view of the implementation object from the target runtime environment or process and display that to the end developer. Furthermore the abstracted view of the implementation may then be re created using the transformation model described above. The end result of such an embodiment is that previously opaque objects may be easily diagnosable without the need for corrupting func evals.

Continuing on with the example from assume the client for the ISquid interface and the implementation of CSquid live in different logical runtime environments e.g. and respectively within the same process. When a developer looks at a proxy to ISquid in the debugger all that may be seen is the object s v table. This is because the proxy does not contain any real data. The v table is not very useful for diagnosing issues. ISquid proxy view in typical debugger may look like 

When a debugger and runtime support the decoding model the debugger can ask the runtime to decode the proxy pointer and return the suitable information to find the concrete object. The debugger may then use typical type information contained within the debug information to construct a physical view of the object. In this example this might look like this in the debugger 

This may be a desirable view of the ISquid proxy. The end developer may now see the actual physical backing state behind the object that the pSquid proxy represents.

Next the debugger may apply a logical transformation to the CSquid implementation object in order to show the view of the abstraction as described above. One embodiment might look like this in a debugger 

The end developer may now have the complete view of the implementation backing the pSquid proxy while being able to see the value of the public abstraction as well as the physical values.

At the time the proxies are created each proxy object pair may be registered with the centralized proxy manager service. Each call from client code to proxy is routed across a channel to the correct implementation . When the end developer debugs the client code the debugger may see detect and or locate Proxy and Proxy that may be called by the client code. In one embodiment debugger may comprise a native code debugger and a proxy decoder that translates the location of a proxy to the location of its implementations. Once the debugger detects and or locates a proxy in client code in the course of debugging the proxy decoder is called to make such a translation.

The debugger may pass proxy locations to the Proxy Decoder at to pass the locations of the implementations for the proxies at and in one embodiment return a suitable set of information e.g. the thread id process id and implementation object of the object. The debugger may use that information to read memory data at within the correct context of the object to obtain and or return the physical view of the implementation objects at . The debugger consults the abstraction transformations at to convert the physical view of the implementation objects into logical views. The logical and possible physical views of the implementation object are displayed to the end developer in the debugger along with the proxy at .

What has been described above includes examples of the subject innovation. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the claimed subject matter but one of ordinary skill in the art may recognize that many further combinations and permutations of the subject innovation are possible. Accordingly the claimed subject matter is intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims.

In particular and in regard to the various functions performed by the above described components devices circuits systems and the like the terms including a reference to a means used to describe such components are intended to correspond unless otherwise indicated to any component which performs the specified function of the described component e.g. a functional equivalent even though not structurally equivalent to the disclosed structure which performs the function in the herein illustrated exemplary aspects of the claimed subject matter. In this regard it will also be recognized that the innovation includes a system as well as a computer readable medium having computer executable instructions for performing the acts and or events of the various methods of the claimed subject matter.

In addition while a particular feature of the subject innovation may have been disclosed with respect to only one of several implementations such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore to the extent that the terms includes and including and variants thereof are used in either the detailed description or the claims these terms are intended to be inclusive in a manner similar to the term comprising. 

