---

title: Method and system for presenting and analyzing software source code through intermediate representation
abstract: The present invention provides a method and system for producing intermediate representation of source code listings with possibly mixed syntaxes to assist software development applications in presenting and analyzing the source code listings through reading the intermediate representation. A source code processor calls Application Programming Interfaces (APIs) to preserve source code information, which includes intermediate representation data sets and is preferably stored in a file-based repository. The source code processor is of a compiler, a preprocessor, a parser, or a comment document processor. The data sets capture lexical, syntax and semantic information of source code construct elements, and comprise of location, processor identification, construct category, and attribute data. A software development environment through a source code search engine is able to present source code construct elements, outlines, and symbol references from software packages over a plurality of distributed servers in a network such as the Internet.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08719805&OS=08719805&RS=08719805
owner: 
number: 08719805
owner_city: Dublin
owner_country: US
publication_date: 20120509
---
The present application is a continuation of U.S. patent application Ser. No. 11 971 904 filed on Jan. 9 2008 now U.S. Pat. No. 8 181 167 and entitled Method And System For Presenting And Analyzing Software Source Code Through Intermediate Representation the contents of which is incorporated by reference herein in its entirety and for all purposes.

This invention relates to software development tools and in particular to a method for presenting source code to software developers and analyzing software source code.

A conventional compiler may save limited source code information in a symbol table for a debugging tool after compilation of a source code listing. The ctags and or etags programs often found in UNIX like operating systems generate an index or tag file for a variety of language objects found in source code file s . The tag index files assist editors such as Vi and Emacs to locate the construct associated with a name symbol appearing in a source code file and jump to the file and line which defines the name. However a tag index file preserves only symbol definitions references and may generate inaccurate tags occasionally. A source code presentation tool such as an IDE Integrated Development Environment presents source code with typical features such as easy access of referenced symbol syntax highlighting outline of symbol definitions and collapsing expanding of source code constructs. Symbol tables and or tag index files are not enough to supply information to support all those features. U.S. Pat. No. 4 931 928 provides a method for analyzing source code with a dedicated parser to extract source code information to be inserted into a database. In general source code presentation source code metrics collection software reverse engineering and other analysis tools require a parser to process the source code listings in order to obtain source code information of interest. Thus there is a need to preserve lexical syntax and semantic information of source code listings for source code presentation as well as analysis especially after compilation.

Source code listings of computer software are likely a mixture of syntaxes of one or more programming languages preprocessing and documentation and thus will be supplied to those language or syntax processors respectively. For example a source code listing in JavaServer Pages JSP is a mixture of HTML and Java . AST Abstract Syntax Trees of source code is typically used to represent the source code during compilation or source code analysis. DATRIX ASG Abstract Semantic Graph is an extension of AST and offers a method to save source code syntax as well as semantics in flat files using data records. However both AST and ASG are not a choice for representation of multiple syntaxes. Extending a programming language by means of a preprocessor has both merits and drawbacks. A preprocessor allows certain language extensions such as macro substitution file inclusion and conditional compilation. However source code in a computer language with preprocessing syntax causes a syntax dependent on another syntax preprocessing syntax and is often context sensitive. As a result a source code analyzer or a software reverse engineering tool based on AST for C or C often has to impose restrictions on the use of preprocessing. Preprocessing is an important feature of C and C however there is no standard way of recording macro definition and expansion in a datastore. For programming languages such as Java and C that do not use or use limited preprocessing a source code file in those languages is often a mixture of syntaxes of a programming language and structured documentation in comments. For example Javadoc is a document standard for generating Java API documents from Java source code and Doxygen is a documentation system for C C Java and many other languages.

Browsing source code through a web browser often takes two approaches static HTML pages and dynamically generated pages. An approach of the former is described in U.S. Pat. No. 5 940 615 that provides a method to generate static HTML pages from source code listings. A method using static HTML pages does not support user preferences and selections. In a latter approach upon a request of a web browser an HTML page is dynamically generated from a datastore maintaining source code information. Dynamically generating web pages allows the control of the page content on demand and the display of source code listings with preferred user settings and drawings of dynamically generated graphs from the source code information datastore. Examples of graphs for source code listings are class relationship method function call graph and reverse engineered design graph.

Open source web sites such as SourceForge.net Tigris.org and GNU.org manage software release packages for download and version control. Some of the sites provide links to view individual source files. However it is not possible to browse symbol definitions and references among large number of files nor is it possible to show program structure or design through various graphs. In addition a user cannot conveniently search a symbol usage across many packages.

At present there are web sites such as Google s source code engine and Koders.com for searching open source software. In Google s source code engine source code browsing page does not provide syntax and semantic information such as symbol reference. Koders.com is a site with all packages installed or copied to a local system then source code files are processed locally to extract source code information with a parser and it is not implemented for distributed servers hosting source code packages. For a distributed source code search engine the search engine and hosting servers are not integrated and the search engine does not have to perform syntax and semantic analysis of source code packages on distributed hosting servers.

Integrated development environments IDEs such as Eclipse Redhat Source Navigator Microsoft Visual Studio and JetBrains IntelliJ IDEA are used to manage projects for software development. Browsing and presenting source code are often limited to source files of managed projects. They are stand alone tools and are not designed to search and browse software over Internet. In addition they are not targeted to manage thousands of software packages. There is a need to provide a method to search and present source code packages through an IDE from a network of distributed servers as if those packages are managed projects.

The current invention provides a method for source code processors including compiler preprocessor parser and comment document processor to parse source code listings with possibly mixed syntaxes to generate Source code Intermediate Representation SIR data capturing source code syntax as well as semantic information. The method merges source code information generated from the source code processors and different rounds of compilation of a header source code file due to multiple inclusions.

The current invention eliminates source code parsing from a conventional source code presentation and analysis tools by making SIR data repository as a common ground for the needs of source code analysis as well as dynamic source code presentation through editor integrated development environment and web browser. A source code presentation tool which may access source code listings hosted at a remote server through a network presents source code construct elements outlines and symbol references without parsing the source code listings.

The current invention provides a method for constructing a site server hosting a plurality of source code packages for the purpose of source code presentation and maintenance and facilitating a source code search engine to collect source code information from a plurality of distributes servers in a network. The current invention fulfills the demand to build a distributed client server system for searching maintaining and browsing source code among a multitude of software packages particularly open source software.

Features and advantages of the invention will become apparent upon review of the following description in association with the accompanying drawings.

For clarity and simplicity the present invention will be described in reference to embodiments that process source code in C provide services through web servers and present source code through a web browser and an IDE Integrated Development Environment . However the current invention is not limited to any particular language presentation environment application or specific implementation. In one of the embodiments below although the current invention is illustrated through a C compiler any source code analyzer or language parser that is capable of processing syntax and semantics of source code may also incorporate methods of the current invention. The order of algorithms and steps within them described in exemplary embodiments may be altered without affecting data results. In addition for those skilled in the art it is readily available to provide authentication process for restricting client access to a server through a network. Source code intermediate representation information in the following description is preferably stored in a file system and can also be stored in a database.

It is understood by those skilled in the art that as used herein source code refers to the text that describes a computer software program and encompasses the concepts of source code comment file header and the like. Similarly for those skilled in the art it is understood the word source code package or package that used herein to encompass the concepts of source code listing source code file makefile build script executable data file object file document directory archived file and the like. In addition source code construct element or construct refers to a segment of source code and encompasses token expression declaration statement function method class type and the like.

The present invention may be implemented in full or partial environment of a distributed computing system such as system described in or modifications thereof as will be readily apparent to those of skilled in the art. Distributed computing system is a network of computers such as user computer and server computer connected through network . Network is a medium used to provide communication between computers within distributed computing system . Network may be a local area network LAN a wide area network WAN or a local area network connected to a wide area network through a combination of hardware devices such as firewalls and routers. An example of distributed system is the Internet. Due to varieties of network usages distributed computing system may involve additional servers clients and other devices not shown.

A computer such as client computer or server computer is a computing system comprising of coupled through a system bus one or more Central Processing Units CPUs a system memory and one or more of devices such as keyboard display sound storage printing modem and network interface computing system components are not shown in the drawing . The system bus may include a memory controller an I O controller and may use any of various bus architectures. The system memory may include read only memory ROM and random access memory RAM . A computing system is also provided with a firmware program for example a basic input output system BIOS an operating system Windows XP or Linux for example and one or more application programs such as web browser IDE Integrated Development Environment software reverse engineering tool source code symbol analyzer web site server search engine server and other applications not shown. An application consists of one or more executable files and possibly other shared or archived libraries that are loaded to memory during execution. A shared or archived library may be a Java archive file or dynamically linked library for example .dll library file for Windows or .so library file for Linux . In web site server includes service module which provides services for accessing source code packages hosted not shown in on the server and may be of shared or archived library.

User computer for example a personal computer a workstation computer or a laptop computer is connected to a network as needed. User computer when connected to a network can make requests to server computer for example obtaining source code listings and information for syntax and semantics of the listings through network . Server computer for example a computer hosting site server for source code packages is constantly connected to a network through one or more devices such as router proxy and or firewall not shown in and ready to service requests from client computers at any moment. A server computer may also make requests to another server computer through a network. For example network search engine may collect information from site server . In addition software applications such as source code analyzers and may also run on server computer . Those skilled in the art may implement the invention with other computer system configurations such clustered computers and mainframe computers.

Diagram in is a block diagram showing data flow among data source destination source code processors and software development application collections and . Source code processors generate Source code Intermediate Representation SIR data stored in repository for source code package . SIR repository becomes part of package . Software development application collections and make use of the SIR data Repository . Source code listings as well as generated SIR data in repository belong to package . Applications in collection are source code analyzers for example reverse engineering tool and symbol analyzer in . Applications in collection are source code presentation tools for example IDE and source code site server for web browser . Applications in both collections for the current invention make use of SIR data for source code analysis or presentation. Source code processors listed in block are modified from conventional source code processors to call APIs Application Programming Interfaces to produce SIR data. Source code processor as used herein refers to a software application that comprises operations performing lexical syntax and or semantics analysis of a source code listing.

A source code listing goes through one or more source code processors. If the source code listing is of C it is preprocessed by preprocessor and then compiled by compiler . The control flow between preprocessor and compiler is depicted using a dashed line with an arrow end . If a source code listing is of Java besides compilation it may be processed by document processor to obtain documentation information. If a source code listing is of a scripting language or an interpreted language that does not require a compilation parser may be used to extract SIR data. Source code in a compilation language may also be fed to parser to generate SIR data.

An exemplary embodiment of the current invention uses a C compiler to generate SIR data. describes a high level flowchart for C compilation process. For a C compiler preprocessor and compiler are two phases that execute in sequence. Compiler generates object files from preprocessed source files. Finally linker creates executable programs from object files. Repository shows data components of a SIR repository. The current invention incorporates changes to both phases of the C compiler to generate SIR data stored in repository . Both preprocessor and compiler write to SIR repository through APIs Application Programming Interfaces . Procedures for generating SIR data for a compilation phase are described in and .

SIR repository in and describes a composition of a SIR repository. The repository comprises multiple entities containing data records to store a processor identifier mapping table a source code file identifier mapping table and a SIR record file for each source code file assuming that a source code listing is stored in a file. The purpose of creating an identifier for a processor is to let all SIR records in a repository hold a processor identifier to keep track of which source code processor has created the records using specific compilation options if any and language specification version if any. A unique integer may be assigned to each processor and saved in a processor identifier mapping table as part of composition in SIR repository . For example a macro symbol definition record holds the identifier of a preprocessor. In addition processor name and options passed to the processor may be saved in processor identifier mapping table. Processor and file identifier tables may be stored together in a file. Identifiers for processors and files are keys with fewer bytes for uniquely identifying processors and files respectively. However SIR records for each source code file is preferably stored in a separate file so that a compiler may load and save an individually changed file on demand. The file name of SIR record file may be named using file identifier with an extension for example 2.sir for a source code file having 2 as the identifier. A compiler through APIs creates and maintains a SIR repository which may be maintained in a subdirectory of a source code package.

In a different embodiment SIR records of a source code file by different processors may be stored separately so that a record does not need to include processor information in such a case the processor information is implicitly embedded in the SIR record.

Block in and contains a data structure layout for a SIR record file which consists of a header record and a list of line records each of which may contain pointers to a list of SIR records for a line of source code. Header record may comprise fields storing information about version information of a SIR repository and properties such as time stamp checksum and total number of lines of the source code file.

Diagram in shows a flowchart for compiler illustrating high level stages for the current invention. After stage for initialization including processing compilation options a conventional compiler is wrapped inside stages and . Stage creates a processor identifier in a processor identifier mapping table if an identifier for compiler does not exist. Stage is to perform lexical analysis of a conventional compiler and is modified for the current invention to call SIR insertion APIs and insert records for source code tokens. Stage is to perform syntax analysis to identify the syntactic structure of a source code and is modified to call SIR insertion APIs and insert records for source code construct elements. Stage is to perform semantic analysis and is modified to call SIR insertion APIs to add semantic information to syntactic construct elements. Stage is an intermediate code generation stage of a conventional compiler. Stage is for code optimization. Stage is for code generation. Finally if there are no errors stage for the current invention is to save and close SIR repository data files.

Chart of depicts a flowchart illustrating operations of a SIR insertion API. At step content of a SIR record is collected from arguments and accessible variables objects. Decision step branches the control flow into two flows depending on the status of a source code file in the repository. If the file has not been processed before a file identifier does NOT exist in table step will create a mapping entry for the file. If the file has been processed before and the SIR file for the source code file is not loaded NO at decision step then the SIR file is loaded into memory in step conditional step makes use of time stamp saved in header record to decide whether or not to create a new SIR file at step . Step inserts a record to list if the record is not already in the list. Checking presence of a record in list is needed to ensure that no multiple copies of a record getting inserted due to multiple processing of the same file for instance file inclusion of a header file may be included multiple times as a result it gets compiled multiple times during compilation. In addition different stages of compilation may call multiple APIs to create SIR records to be associated with the same construct element. The operation of checking and combining data attributes of SIR records for the same construct element to form a single record with multiple attributes is called record merging merging SIR records .

In SIR file gets loaded into memory in step . Step of writes memory copies of modified SIR files into files on disk. It is necessary to load and save SIR files on demand in order to reduce compilation time and memory usage.

During preprocessing or compiling a source code file a source code processor calls a SIR insertion API shown in the flowchart of when it detects a symbol definition a new type for example a symbol reference expanding a macro for example or a boundary start and or end of a source code construct start of conditional compilation block if for example or start of a function definition .

An insertion API for a construct boundary may carry the following arguments or may get the following data objects from its scope 1 Location of the construct boundary 2 Processor identification for example a processor identifier from a mapping table 3 SIR Category of boundary indicating starting and or ending of a source code construct and 4 Construct type such as class function statement macro definition or conditional compilation block .

A symbol definition insertion API for adding a SIR record of source code construct may carry the following arguments or may get the following data objects from its scope 1 Location of the symbol 2 Processor that recognizes the symbol 3 Symbol definition category such as macro class variable or method and 4 Symbol token string 

A symbol reference insertion API for a symbol binding may carry the following arguments 1 Location of the symbol making a reference 2 Processor that recognizes the symbol 3 Symbol reference category such as macro expansion or reference to a class 4 Symbol token string and 5 Location of the referenced symbol.

The above three insertion APIs are APIs used to provide fundamental source code information for a tool to present navigate and search program source files. Additional insertion APIs may be added to represent source code lexical syntax and semantic information for example APIs that add SIR records to store header file inclusion to store macro expansion during preprocessing and to store all tokens of a file so that a SIR file can recover the original source code content. Insertion API may be used to track document syntax in comments for a document processor. All SIR records are merged into groups for source code listings and lines.

A SIR record is created with respect to two construct elements an enclosure construct and a role construct. The enclosure construct is a construct that the SIR record is created for and provides interpretation information for. The role construct is a construct that plays a role in contributing to the SIR record. A location in the SIR record is associated with the role construct. The role construct may be the same as the enclosure construct. In general the role construct is a child construct for composing the enclosure construct. For example for a SIR record created for a function definition the function name symbol is the role construct and the function is the enclosure construct. The example illustrated in and uses terminal constructs i.e. tokens as role constructs for associating SIR records.

In comparison to conventional AST ASG representation the source code representation using SIR records preserves syntax and semantics information by associating the information with locations of role constructs. By inspecting localized SIR records associated with a role construct a software development application is able to quickly find out the roles of the construct and provide accurate presentation and analytic data of source code listings. The representation does not require a complete recording of syntax and semantics and SIR records are added accumulatively and as needed.

The information gathered for an API creating a SIR record is grouped into four segments 1 Location of a role construct 2 Information of processor invoking the API 3 SIR record category information 4 Data attributes describing the record. The location of the role construct may include starting and ending character locations of the construct. An implementation of the current invention may store only the column number and other location information can be derived from the SIR file arrangement of a SIR record and token string length. In a different embodiment of the current invention SIR records created by different processors may be separately stored in different files so that SIR records within a file are produced by the same processor and may not need to carry processor information since the file storing SIR records implicitly supplies the processor information. Source code intermediate representation data set is a term used to collectively describe all explicit fields of a record plus additional implicit fields implied by the context storing the record.

SIR records for lexical syntax and semantics of source code in a programming language may have the high level categories listed in Table 1

A data attribute of a SIR record preserves lexical syntax or semantics information of a role construct element for describing an explanation or a property of the role construct element in regard to an enclosure construct element. The data attribute may also be used to store a boundary or a description of the enclosure construct element. SIR records provide a way to represent source code listings with parsing information reserved. A SIR record may carry multiple data attributes.

In block shows a composite of a SIR repository after compilation of main.c and add.c . Mapping table is for processor identifiers. Mapping table is for file identifiers. Block shows a data structure for the SIR file of main.c block for add.h and block for add.c content of 3.sir is not shown in block respectively. Assume that a compilation process preprocesses main.c first since add.h is included by main.c at line 1 thus main.c has a file identifier of 1 and then add.h has an identifier of 2. Those skilled in the art may alter SIR file data structure shown in without departing from the scope and spirit of the current invention.

For the purpose of illustration braces and surround the content of a SIR record. A data attribute in a SIR record is surrounded by parentheses and . A triplet of referenced file identifier line and column surrounded by parentheses describes the location of a reference relation inside an attribute. Since SIR records are organized within a line the location in a SIR record is described using the column number of the first character of a token. A listing of detailed categories for SIR records used herein is described in Table 2

For clarity of illustration SIR records shown in are associated with role constructs at atomic level namely tokens. In a different embodiment SIR records can be associated with higher level composite constructs such as expression statement and function. In addition shows limited categories of SIR records and SIR records are attached to tokens with syntax and semantic information. However pure tokens such as parentheses and operators are not recorded. Not all data fields of a SIR file are shown in . For example block is the header record for 1.SIR and shows only two relevant fields of SIR file header record file id and number of lines. The number of attribute fields in a SIR record is not fixed and each SIR record contains column location processor identifier SIR category and at least one data attribute. A SIR record may carry boundary attribute such as SIR record record record and record token string attribute such as record header file inclusion attribute such as record function definition attribute such as record and function declaration such record . SIR record shows a string add.h with file identifier 2 for representing file inclusion at line 1 of main.c. SIR record shows a function declaration reference with symbol add file identifier 2 for add.h line number 3 and column number 5. Record declares a parameter argv of function main . SIR record shows a macro reference with symbol N2 file identifier 2 line number 2 and column number 9. SIR record shows a symbol add for declaration of a function. A token or character location may be associated with more than one SIR record for example SIR records and . SIR records may be nested and a SIR record may be an attribute of another SIR record. Nested SIR records are used to describe macro expansion in C preprocessing.

If all tokens and statement boundaries are included the SIR record list for line 6 of 1.sir for main.c becomes the following 3 2 CS A BTYPE BT STMT 3 2 RDV A RSYM sum 1 5 7 7 2 TK A TOKEN 9 2 RDC A RSM add 2 3 5 12 2 TK A TOKEN 13 1 RDM A RSYM N1 2 1 9 13 1 ME A ME 1 2 TK A TOKEN 1 15 2 TK A TOKEN 17 1 RDM A RSYM N2 2 2 9 17 1 ME A ME 2 1 2 TK A TOKEN 2 19 2 TK A TOKEN 20 2 TK A TOKEN 20 2 CE A BTYPE BT STMT .

SIR records may also be used to describe an abstract syntax tree AST . For example the AST shown in for the assignment statement in line 6 of main.c can be represented using the following SIR record list 7 2 AST ASSIGN A AST CHILD AST ASSIGN L 1 6 3 AST ASSIGN R 1 6 12 3 2 AST ASSIGN L A AST CHILD AST SYM 1 6 3 3 2 AST SYM A AST TERM 9 2 AST ASSIGN R A AST CHILD AST CALL 1 6 12 9 2 AST CALL A LEN 11 A AST CHILD AST SYM 1 6 9 AST PARM 1 6 13 AST PARM 1 6 17 9 2 AST SYM A AST TERM 13 1 ME A ME 1 1 2 TK A TOKEN 1 1 2 AST PARM A AST CHILD AST NUM 1 1 2 AST NUM A AST TERM 17 1 ME A ME 2 1 2 TK A TOKEN 2 1 2 AST PARM A AST CHILD AST NUM 1 1 2 AST NUM A AST TERM .

In a different embodiment of the current invention each SIR file may contain a file identifier mapping table and a processor identifier mapping table instead of package shared mapping table or completely eliminate mapping tables through replacing identifiers in SIR records with text of file path or processor description. Identifier mapping and SIR files may be stored in structured binary format or text format such as XML format. In addition a symbol location mapping table for externally referenced symbols constructs may be created for location independent relationship. A SIR record of relationship category may contain a location of another construct element. The location used in are absolute line and column location with in a file if the file is modified the relationship location becomes invalid and needs to be updated. An entry in a symbol location mapping table of a SIR file assigns an identifier for a symbol defined in its source code file and the entry stores the location of the symbol. The identifier may be an integer or a mangled symbol from symbol definition signature. With the mapping table a relationship record may be established using the mapped identifier of a referenced symbol construct. A change causing location shift for symbol definitions needs only to update locations in the mapping table.

A method is provided to consume the SIR file of a source code file to present source code with easy access of referenced symbols and syntax highlighting. The environment for an embodiment of the method is depicted in . Source code files with their SIR files are stored in a server computer such as server computer . Web Browser makes an HTTP request to web site server through network . Then site server deliver the request to server module to be handled.

Flowchart in shows a procedure implemented for server module to create an HTML page for a requested source code file or a segment of a file. shows a screen dump of three window frames of a web browser such as browser in for browsing source code. For the purpose of clarity each frame is given a name control frame main frame and overview frame . Control frame on the left hand side is to support searching and navigation of files and directories. Main frame is to display source code file. Overview frame is for displaying a segment of source code for example definition of a referenced symbol upon clicking a hypertext link in main frame . For instance by clicking on N2 label a code segment showing the macro definition is displayed in overview frame indicated by label . Procedure in flowchart may be used to generate an HTML page for a source file to be displayed in main frame or an HTML page for a segment of source file e.g. referenced symbol definition to be displayed in overview frame .

In flowchart step reads the request parameters from web site server and gets source code file information from the parameters. The information may include a path source file identifier location of selected source code region and or selected symbol. The path may be the path for a package or the requested file path that also includes package path. If file identifier is present in the parameters step gets file name and path from file identifier mapping table of the package pointed by the package path. Then step opens the source code file plus its SIR file.

Steps between and inclusive of chart generate an HTML page for a web browser to display the requested source code file or a segment of the file . As an example main frame shows the HTML page generated by steps between and . Step creates HTML content indicated by label in . Steps between and inclusive of chart creates the following HTML segment using SIR records described in 

In flowchart step performs lexical analysis since not all lexical SIR records are preserved in and reads symbol token and delimiters from opened source code file. Step outputs delimiters and line numbers. At decision step if there is no more token step will output HTML tag ending verbatim. If a token is found step uses line and column location of the token to locate associated SIR records for the token. If no record is found at decision step step outputs the token symbol or string. If a SIR record exists decision steps and are to determine the hyperlink or syntax highlight of the token.

In the above HTML segment for file main.c source code line 6 contains 4 reference SIR records reference of variable definition sum reference of function declaration add reference of macro N1 and reference of macro N2 . Step creates the hyperlinks for those references. Similarly step creates hyper link for preprocessing include statement i.e. line 1 of main.c . Step controls syntax highlighting of symbols. More decision steps may be added after step for more categories of tokens for syntax highlighting for example variable declaration.

In a different embodiment a client application such as IDE in may download the syntax and semantics of a source code listing from server computer . For example the IDE may download a source code file together with its SIR file to present source code with referenced symbols syntax highlighting symbol outline and collapsing expanding multi line source code constructs. Other source code presentation tools may include but not limited to applet of a web browser a browser script in JavaScript and a source code editor.

In frame displays function main of file main.c which is displayed in frame title bar . Frame display region in frame display source code line numbers and controls for collapsing and expanding a source code construct region for example control icon is for collapsing function main . The region boundary information is obtained from SIR records of boundary category. Popup window uses SIR reference information in relationship SIR record of macro N2 to display its macro definition in frame .

A procedure is provided to describe outlined steps to analyze source code files of a package through processing SIR files. The resulting data is called derived source code presentation DSIR data which is any source code information generated by applying an algorithm to a SIR repository.

In a different embodiment of the current invention a source code analyzer may follow SIR records of relationship category to obtain graphical presentation of source code construct elements for example class inheritance relationship for source code in an object oriented programming language method function call graph and reverse engineered design graph.

A source code search engine in uses captured source code information in a datastore in and produces listings of source code information that best match searched criteria which may be one or composition of language symbol string symbol type package name developer license key word and such. The captured source code information stored in datastore may be collected from SIR repositories of packages hosted by distributed servers.

Procedure shown in is a block flowchart to generate datastore database for a source code search engine. Datastore provides source code search information for search engine in . At step the procedure collects hosting servers through possible methods such as server registration domain gathering and IP address scanning. Then starting at step the procedure goes through each collected server sites and each package hosted by a server to collect source code information. At decision step if there are no more sites then the procedure terminates. Otherwise at step the procedure connects to a server to collect a list of accessible packages. The package list may be provided by the server or may be obtained through navigating through server package organization structure.

At decision step if there are no more packages at a site then the control loops back to step to find the next site. If there are more packages at step the procedure collects information about a package such as name developer version license and home URL and then inserts it into datastore . The package information may be described in a data file provided the server. Then at step the process downloads processor and file identifier mapping tables to collect source code processors and source code files from the package and save the information into the datastore. At step the procedure download source code files with their SIR data from the server to collect source code SIR data and save the data of interest to the datastore. The source code data include but not limited to definitions and references from the SIR data. By reading SIR data and derived SIR data a search engine is able to obtain source code information without parsing and analyzing the source code. In a different embodiment of the current invention the procedure may download the package symbol datastore to get source code symbol definitions and references or the process may download an entire package together with its SIR repository for building search entries.

It is import to note that the preceding examples for illustrations have been provided merely for the purpose of explanation and are in no way to be exhaustive or limited to the current invention. Although the invention has been described with reference to particular computer hardware computer programming languages algorithms data formats and embodiments those of ordinary skill in the art understand the current invention for various embodiments with various modifications without deviating from the spirit and scope of the invention. Therefore it is intended that this invention encompass all such variations and modifications as fall within the scope of the appended claims.

