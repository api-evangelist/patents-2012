---

title: Dynamic index file creation for media streaming
abstract: Systems and methods for providing index files for streaming media over a network are disclosed. These systems and methods provide for receiving requests for a media file and responding to these requests by generating corresponding index files used in streaming the media file. The index file can then be provided to the requesting entity. These systems and methods, which can be utilized together with a dynamic chunk generator, enable the insertion of advertisements at any point during playback of the media file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08327013&OS=08327013&RS=08327013
owner: Unicorn Media, Inc.
number: 08327013
owner_city: Tempe
owner_country: US
publication_date: 20120326
---
This application is a continuation application of U.S. patent application Ser. No. 12 976 883 filed Dec. 22 2010 entitled DYNAMIC CHUNKING FOR MEDIA STREAMING which will issue as U.S. Pat. No. 8 145 782 on Mar. 27 2012 which claims priority to Australian Patent Application Serial No. 2010202741 filed Jun. 30 2010 entitled DYNAMIC CHUNKING FOR MEDIA STREAMING all of which is incorporated herein by reference for all purposes.

This disclosure relates in general to cloud based computer processing and but not by way of limitation to indexing and chunking media files for use in media streaming.

The delivery of media over networks such as the Internet can be accomplished in many ways including progressive downloading or streaming. Streaming is often preferred to progressive downloading because it offers additional features such as content protection and the ability to seek to undownloaded parts of a media file. The process of preparing a media file for streaming typically involves chunking the file or dividing files up into smaller segments for delivery. Information including where chunks may be accessed can be stored in an index file. This index file can be delivered to a client such as a media player application for use in streaming.

The processes of chunking and indexing files for streaming present challenges to a content delivery network or content provider desiring to host media files for streaming. For example a significant amount of preprocessing is required to prepare media for streaming. Media content may be encoded into several different files to accommodate several different sub streams. Each of these files typically are chunked stored and indexed before the media content is available for streaming. This preprocessing leaves little flexibility for inserting an advertisement during streaming and can require a large amount of storage space to store the preprocessed chunks of media.

Systems and methods for providing index files for streaming media over a network are disclosed. These systems and methods provide for receiving requests for a media file and responding to these requests by generating corresponding index files used in streaming the media file. The index file can then be provided to the requesting entity. These systems and methods which can be utilized together with a dynamic chunk generator enable the insertion of advertisements at any point during playback of the media file.

According to one embodiment a server for generating index files for use in communicating with a network a media file having a plurality of segments is disclosed. The server includes a memory an interface for communicating with the network and a processor communicatively coupled with the interface and the memory. The processor is configured to execute computer code for receiving with the interface a request for a first index file determining in response to the request for the first index file a first segment of media for streaming. The first segment of media includes one of a plurality of separately addressable segments of the media file and the determination includes determining whether to include media other than the media file in the first segment of media for streaming. The determination further includes determining a starting point and an ending point of the first segment of media for streaming. The processor is also configured to execute computer code for generating the requested first index file based at least in part on the determination of the first segment of media for streaming providing with the interface the requested first index file and receiving with the interface a request for a second index file for use in streaming the media file. The processor is further configured to execute computer code for determining in response to the request for the second index file a second segment of media for streaming the second segment of media comprising one of the plurality of separately addressable segments of the media file. The determination includes determining whether to include media other than the media file in the second segment of media for streaming and the determination further includes determining a starting point and an ending point of the second segment of media for streaming. Finally the processor is configured to execute computer code for generating the requested second index file based at least in part on the determination of the second segment of media for streaming and providing with the interface the requested second index file. Receiving the requests for the first and second index files and providing the requested first and second index files occur during playback of the media file by a device communicatively linked to the network.

According to another embodiment a method for generating index files for streaming a media file via a network is disclosed. The method includes receiving with the network a request for a first index file and determining a first segment of media for streaming. The first segment of media is one of a plurality of separately addressable segments of the media file. The determination includes determining whether to include media other than the media file in the first segment of media for streaming and the determination further includes determining a starting point and an ending point of the first segment of media for streaming. The method also includes generating the requested first index file based at least in part on the determination of the first segment of media for streaming providing with the network the requested first index file and receiving with the network a request for a second index file for use in streaming the media file. The method also includes determining a second segment of media for streaming the second segment of media comprising one of the plurality of separately addressable segments of the media file. The determination includes determining whether to include media other than the media file in the second segment of media for streaming and the determination further includes determining a starting point and an ending point of the second segment of media for streaming. The method finally includes generating the requested second index file based at least in part on the determination of the second segment of media for streaming and providing with the network the requested second index file. Receiving the requests for the first and second index files and providing the requested first and second index files occur during playback of the media file by a device communicatively linked to the network.

According to yet another embodiment a method for providing index files and Universal Resource Indicators URIs to indicate chunks of a media file for streaming is provided. The method includes receiving from a media streaming application a request for an index file and determining a chunk of media for streaming the chunk of media comprising one of a plurality a plurality of separately addressable chunks of the media file. The determining includes determining whether to include media other than the media file in the chunk of media for streaming and the determining further includes determining a starting point and an ending point of the chunk of media for streaming. The method further includes generating the requested index file based at least in part on the determining of the chunk of media for streaming providing the requested index file to the media streaming application and receiving a request generated by the media streaming application for the chunk of media for streaming. Receiving the request for the chunk of media for streaming is based at least in part on the index file. The method finally includes determining a URI for the chunk of media wherei the URI is based at least in part on the request for the chunk of media for streaming and providing the URI to the media streaming application. The requested index file and the URI can occur during playback of the media file by the media streaming application.

In the appended figures similar components and or features may have the same reference label. Further various components of the same type may be distinguished by following the reference label by a dash and a second label that distinguishes among the similar components. If only the first reference label is used in the specification the description is applicable to any one of the similar components having the same first reference label irrespective of the second reference label.

The ensuing description provides preferred exemplary embodiment s only and is not intended to limit the scope applicability or configuration of the disclosure. Rather the ensuing description of the preferred exemplary embodiment s will provide those skilled in the art with an enabling description for implementing a preferred exemplary embodiment. It is understood that various changes may be made in the function and arrangement of elements without departing from the spirit and scope as set forth in the appended claims.

The increased availability of media content over data communications networks such as the Internet has mirrored the increased bandwidth for these networks. Because media has recently taken a more prominent role in data communications the distribution of media and the data associated with such distribution has become increasingly important particularly to media content providers. Media streaming has become a widely used method of media distribution but the preprocessing associated with streaming can be burdensome. Certain protocols including forms of Hypertext Transfer Protocol HTTP streaming require chunking and storing media assets and generating a corresponding index files. These requirements can deprive a content provider of the ability to dynamically insert additional media such as advertisements into a media stream and can consume a large amount of storage space to store chunks of media for a media asset including chunks for any alternative sub streams e.g. streams with alternative bitrates captions alternative languages etc. . Certain systems and methods can be utilized however to introduce the desired functionality back into the system.

A traditional approach to preprocessing media for streaming involves chunking and storing media assets then creating corresponding index files to indicate where chunks may be located to download for streaming. Streaming protocols often provide for frequently updating an index file for instances where the corresponding media is frequently updated such as during live streaming. Thus an index file does not need to contain all chunks for a requested media asset. In addition because media files are frequently stored in a format that requires little additional processing to chunk the chunks can be created in real time during the streaming of a media file. The systems and methods disclosed herein take advantage of these features to enable dynamic index file creation and dynamic media file chunking.

For instance rather than preprocess media assets for streaming by chunking and indexing all files with relevant sub streams prior to streaming the media a server can dynamically create and update an index file during streaming. The dynamically created index file can contain information regarding a next chunk of media in the various available sub streams. The next chunk of media may not be cached at a location specified in the index file in which case a chunk may be dynamically created by pulling all or part of the media file of interest from a media file origin chunking it and making it available for download. The chunk also may be cached thereby eliminating the need to create the chunk again if it is requested at some later time.

Because the chunks are created during streaming a content provider and or media distributer can have more information and control during the streaming process. Rather than generate single index file for a given media asset an instance of the index file generator may be created at the beginning of the media streaming to provide individualized media content to a particular end user and unique information regarding the streaming session to a content provider. The file index generator can vary the length of each chunk by for example indicating starting and ending points in the index file. Thus the file index generator may determine a uniform chunk length for a media asset varying the length of the chunks for different media assets or the file index generator may adjust the length of the chunks within a single media asset. The index file generator can further insert additional media such as an advertisement at any time during the streaming by specifying the location of the additional media in the index file. The determination to insert advertisements can be based on any information including data collected during the streaming session.

As the index file generator receives requests for and generates index files it can further gather data regarding the streaming session for reporting to a content provider. Content providers often rely on beaconing data collected from media player applications to determine when an end user stops plays pauses skips etc. the streaming media content. Such information can be vital in determining the value of the media.

Because not all media player applications provide this beaconing data the data gathered by the index file generator can serve as a substitute for or complement to the beaconing data. For example if a request is made for a chunk that does not immediately follow a previously requested chunk a skip was made. If the amount of time elapsed between a previous request and a subsequent request exceeds the time for playback of the previously requested chunk a pause was made. If a request is not received within a certain time since a prior request it can be determined that a stop was made.

As illustrated above the state of a client may be determined from a variety of factors. This can include when the request for the index file is received when the index file is provided a length of time to play back the segment of media for streaming and or the starting and or ending point of the segment of media for streaming. The determined state of a client may also be based on whether the request for the index file has been received within a certain amount of time since receipt of a previous request for an index file whether the segment of media for streaming includes media other than the media file and more. The state of a client and or the data from which it was determined may be used to create reporting data to serve as a substitute or complement to beaconing data from a client media player application. Because the index file generator can determine the length of the chunks it therefore can determine the frequency of subsequent index file requests and the resolution of the reporting data based on the requests. The index file generator may log the reporting data and or transmit the reporting data over a network during streaming.

The determined state of a client may be used by the index file generator and or other services for various purposes. For example it may be used in behavioral advertisement targeting and enforcement of session advertisement behavior adjusting advertisement content and playback based on the behavior of a user as determined by the stated of a client. The state of a client further may be used to support resume features on a per client basis allowing a user to continue playback of a media asset from a point at which the user had previously stopped playback. The state of a client also may be used to support individual encryption keys in an encryption scheme and allow the index file generator to return secure URLs e.g. time expiring or Internet Protocol IP allowed for chunks to support functions such as payment services.

Additionally or alternatively the tasks of generating the index file and providing a location a requested chunk can be split up thereby enabling the system to determine which chunks are actually requested. For example a system may be configured to dynamically create an index file having links to one or more redirectors on the system. These redirectors can be configured to issue the location of the chunk which can be created dynamically. The redirectors can further determine which chunk is actually requested thereby enabling among other things calculation of Quality of Service QOS metrics an increase the accuracy of reporting data a decrease the frequency of index file generation if efficient to do so and the ability to more easily handle keys of an encryption scheme.

While the above embodiments may be implemented in a variety of different systems some particular embodiments may be implemented as part of a media service system. is a block diagram illustrating a media servicing system according to some embodiments of the present invention. The system may deliver media content to the end user device through a network such as the Internet . The end user device can be one of any number of devices configured to receive media over the Internet such as a mobile phone tablet computer personal computer portable media device etc. A media asset provided by a content provider can be processed and indexed by cloud hosted integrated multi node pipelining system CHIMPS and further stored on content delivery network CDN . Additionally or alternatively the CHIMPS may also be adapted to store the media asset.

The media servicing system further enables a content provider or other entity to gather information regarding user behavior during media playback. For example a content provider can be provided with data indicating that end users tend to stop watching a video at a certain point in playback or that users tended to follow links associated with certain advertisements displayed during playback. With this data a content provider can adjust factors such as media content advertisement placement and content etc. to increase revenue associated with the media content and provide the end user device with a more desirable playback experience.

End user device can request a media asset to stream with a client program executed by the end user device . The client program can be for example a media player browser or other application adapted to request and or play media assets. In response to a request for a media asset the CHIMPS can utilize any number of application centers and or kernel application center s to provide the client program with a data object concerning the requested media asset. The data object can include information about the media asset including where the media asset can be located such as within the CDN or within the CHIMPS itself. Location information may be provided by Universal Resource Indicator URI a Universal Resource Locator URL or other indicator. During playback of the media asset the CHIMPS can collect data regarding the playback through beaconing provided by a client program executed by the end user device and or indexing service from within the CHIMPS and or CDN. The CHIMPS can subsequently provide the data and or any analytics information derived from the data to the content provider .

Components within the kernel application center can communicate through network such as a local area network LAN and can include one or more origin servers and a storage array with which data objects and or media assets may be stored and distributed. The storage array may also be utilized by services running on processing server s and or transcoding server s that may require temporary or long term storage. Kernel server can utilize processing server s transcoding server s to provide various functional capabilities to the CHIMPS .

For example as described in more detail below the CHIMPS can provide transcoding service for media assets provided by a content provider for syndication. Such a service can allow a content provider to upload a media asset to an application center after which the application center would notify the kernel server that the media asset has been uploaded. The kernel server can then notify services running on the processing server s of the upload. These services can utilize transcoding server s to transcode the media asset which can then be moved to a CDN and or stored locally by storage array and origin server s . Services running on the processing server s can also update the associated data object stored by the storage array and origin server s .

Media can be ingested into the CHIMPS when a content provider uploads a media asset to ingestion server s in an application center by utilizing a client . The client can be a stand alone application or browser based for example and can communicate with ingest server s through an application programming interface API configured for the ingestion of media assets.

Ingest server s can communicate with devices in the kernel application center executing programs such as kernel server and file replication service . The kernel server can be configured organize the workflow among services such as transcoding file system manager and other services e.g. analytics dynamic API etc. Upon a particular event for example the kernel server can be configured to notify the relevant services of the event causing the services to process tasks associated with the event.

The file replication service under direction of the kernel server can coordinate the movement of the media assets between services. For example retrieving the uploaded media asset from the ingest server s and storing it on the file archive or retrieving transcoded media assets from transcoding server s and storing them in the media asset origin.

The data object updater keeps the data object origin up to date in response to any changes in the system. When for example a file is uploaded transcoded and stored in media asset origin the location and other metadata concerning the transcoded media assets need to be created or updated in the data object origin to ensure an end user device that accesses the object in the data object origin has the correct information regarding the related media asset. Because the data object updater receives updates from the kernel server which is notified when a transcoded media asset is stored in the media asset origin the system ensures the data objects in the data object origin are constantly up to date.

The upload of a media asset to the ingest server s as described above can provide an example of how the kernel server may coordinate workflow. For instance in response to the upload the ingest server s can notify the kernel server that a media asset has been uploaded. The kernel server informs the file replication service of the uploaded media asset and the file replication service moves the uploaded media asset into the file archive and notifies the kernel server of the move. In response the kernel server notifies the file replication service the file system manager and the transcoding master of the move. The file replication service then will know it can delete the uploaded media asset from the ingest server s the file system manager will update the file system accordingly and the transcoding master will notify transcoding service s of different transcoding tasks to be performed. The transcoding service s can then retrieve the uploaded media asset from the file archive to create transcoded media assets. The transcoding service s notify the kernel server once transcoding is complete and the kernel server relays this information to the file replication service . The file replication service then takes the transcoded media assets from the transcoding services and moves them to the media asset origin . Once the file replication service notifies the kernel server of the move the kernel server in turn notifies the file replication service and the data object updater . The data object updater which updates the data object origin accordingly and the file replication service deletes the transcoded media assets from the transcoding services .

The modular nature of the system enables all tasks associated with an event to be completed quickly. As illustrated in the example above workflow relating to a particular event such as a media asset upload can be spread among the various services simultaneously. Moreover because the system s modularity enables it to be scaled to accommodate differing hardware capacities and because the system can be configured to dynamically allocate hardware to different services according to the needs of the system the speed of completing tasks relating to a particular event can further be increased. For example a server of the CHIMPS can be configured to dynamically switch its purpose based on external conditions such as load and overall system performance providing functions such as transcode upload metrics collection application web service and more on an as needed basis.

Embodiments of such systems may include other systems that manage various requests from end users. For example a system for dynamic index file generation and media file chunking Referring to shows an embodiment of such a system . Media may be streamed to end user device though a client . As mentioned above the client can be stand alone media player a plug in a browser or other application which can be executed on a personal computer or other electronic device.

An index file generator as discussed previously can be a program instantiated for media streaming to a particular client . The index file generator can be executed on a server or other computing device within an application center of the CHIMPS . Index files generated by the index file generator can include a wide variety of information such as starting ending and or run times for media chunks and locations for media chunks. This information can be embedded in a single string of data such as a URI or a URL. If media includes various sub streams e.g. streams with alternative bitrates captions alternative languages etc. the index file can include data for chunks corresponding to each of the alternative sub streams as well as information regarding the bitrate and or other unique information for each stream. Alternatively or in addition index files indicating alternative sub streams may be separate from index files indicating one or more media chunks for streaming.

It should be understood that the index file can further comprise a wide variety of formats which can depend on the particular protocol. HTTP streaming may for example require index files to comprise one or more of M3U M3U8 XML and XML based formats. Of course other formats can be used in accordance with relevant streaming protocols.

Table 1 illustrates a simplified example of a generated index file in M3U9 format indicating chunk of media for streaming. The index file in this example provides a URI for a chunk of media. The URI indicates the chunk is to be generated by dynamic segmentor the chunk being 10 seconds long starting at 9 seconds into the media file and ending 19 seconds into the media file.

Referring again to the index file generator can also include an indicator within an index file to indicate whether a chunk of media is to be dynamically created. If for example it is determined that a requested media asset has not been chunked and that the asset will be chunked dynamically the index file generator can include the indicator in data corresponding to a chunk of media to be created. The indicator which can be as simple as including the term seg in a URL will indicate that a requested chunk of media needs to be generated.

The chunks of media can be generated during media streaming by a dynamic segmentor which can be incorporated into an HTTP service . The HTTP service as well as the media asset origin can be located within a kernel application center of the CHIMPS on for example a media asset origin server. The system can be configured such that the kernel application center provides dynamically created chunks of media to a CDN for delivery to client . The CDN can store the chunks locally in for example a media asset cache thereby forgoing the need to dynamically create a chunk again if the same chunk is requested in the future.

In sum the system for dynamic index file generation and media asset chunking can after receiving a request for an index file from a client dynamically generate an index file with an index file generator . The index file can among other things indicate where a next chunk of media may be located. A client can then request the chunk from the location indicated by the index file which can comprise a media asset cache in a CDN . If the chunk is not found in the media asset cache the cache miss can redirect the request to a segmentor of an HTTP service which can dynamically generate the requested chunk of media by accessing the corresponding media asset in the media asset origin . The requested media chunk can then be provided to the CDN for storage in the media asset cache and delivery to the client . If the same chunk is requested at a later point in time the CDN can deliver the chunk from the media asset cache thereby forgoing the need to redirect the request to the segmentor to regenerate the chunk.

Embodiments utilizing one or more redirectors can have several advantages. For example and not by way of limitation if a certain client were implemented in such a way that it reads ahead to request chunks it could result in incorrect reporting data. Thus it would be advantageous to determine which chunk is actually requested by the client. Additionally or alternatively where chunks are available in various sub streams with different bitrates determining the actual requested chunk can be useful in calculating Quality of Service QOS metrics. Furthermore it there may be scenarios in which it is more efficient to create larger index files having many chunks comprising large segments of media reducing the number of index files required to stream a media asset and thereby reducing the processing requirements to create the index files. If encryption is used having for example a rotating key or a per client key encryption scheme in which a valid key might change during playback of a media asset it also may be advantageous to incorporate redirector s for handling legacy keys for some period of time.

At block the method additionally provides for receiving input from an advertising service. According to some embodiments this input could be the availability of an advertisement and can be provided by a service inside or outside the CHIMPS. In other embodiments the input could come from a service that factors in any of a variety of factors to indicate that a specific advertisement or type of advertisement should be shown. Or that any advertisement should be shown.

At block a determination is made whether to include an advertisement in the next chunk. According to some embodiments this determination can be made with or without input from an advertisement service. It should be known that this determination can include the factors used by an advertisement service to provide the input of block . Whether the determination includes input from an advertisement service of block or not the determination can still include factors such as information about an end user collected before or during streaming of the media. This can include behavior of the end user during streaming of the media as determined for example by machine based logic through beaconing data and or requested chunks of media provided by a client . Factors can also include information regarding the media asset used for streaming such as type of content or preferred points within the media for an advertisement preference s and or selection s of an end user when a previous advertisement was shown time of day and more. It can further include information regarding the source of a media asset such as who created and or provided the asset for viewing by an end user. It will be understood that other embodiments contemplate include secondary media other than advertisements into the media stream in this manner. Moreover the secondary media and or advertisement can be of any length and also may be chunked. Thus it may be determined that the next chunk includes all or a select portion of an advertisement of any specific length.

An index file is created based on the request as well as the determination of whether media such as an advertisement should be streamed indicated by block . As discussed above the index file can assume a variety of formats and include any amount of information regarding a next chunk of media for streaming. For example HTTP streaming can utilize index files having the URLs of available chunks of media. Information can be embedded in these URLs to indicate a location to download the corresponding chunk of media starting point and or ending point of a chunk of media an indicator to indicate whether the chunk is to be dynamically created by a segmentor a location of an advertisement to be streamed and more. This information is included in the index file and sent to the client at block .

At block reporting data can be created based on information included in the index file. As previously discussed information included in an index file and or index file request can indicate the behavior of an end user device during streaming such as a pause stop skip play etc. of the media. According to some embodiments this information can be extracted from requests for an index file and or providing the requested index file. The information can be gathered in addition to or as a substitute for beaconing data provided by a client . Moreover if beaconing data is provided the creation of reporting data may be omitted altogether.

Reporting data can include any amount of information regarding end user behavior as indicated through index file requests and or provided index files. This can include a particular action and when it was performed. Additionally or alternatively the data may be kept in a more rudimentary form depending on the application or embodiment indicating the data included in a index file request and or an index file. This reporting data may be stored in a log file for reporting after streaming and or transmitted during streaming to a relevant service that collects such metrics.

As indicated by block the reporting data may be sent to a metrics collector for analytics. A metrics collector according to certain embodiments may be an application executed by a server from within the application center in which the index file generator is executed or it may be executed elsewhere such as in a kernel application center or in a system outside the CHIMPS . Depending on the form of the reporting data the metrics collector can further process and store the information.

The method can begin at block when a request for a chunk of media is received from a CDN . As discussed above this request may be made in response to a cache miss at the CDN and or because an indicator was included in the request for the chunk of media that the chunk was to be created dynamically. As discussed herein if the CDN has the requested chunk cached from a prior request the CDN can provide the requested chunk and preclude the need to send the request to a dynamic segmentor to generate the chunk. It should be understood that the request may come from sources other than a CDN according to alternative embodiments. One such source includes the media caching server of embodiment as shown in .

The starting and ending points of a requested chunk of media are then determined at block . This information can be included directly in the request or derived from the request a previous request and or other sources. At block the information as well as information identifying the requested chunk of media can be used to retrieve all or part of the relevant media asset from a media asset origin . The retrieved portion will include at least the relevant media from the starting point to the ending point of the requested chunk of media.

At block the requested media chunk is generated by converting the relevant portion of the media asset into a deliverable chunk. The media asset as stored in the media asset origin may not be chunked it may be stored in its entirety as a media file or group of alternative files corresponding to alternative sub streams . Generating the chunk therefore can require determining the starting and ending points from the retrieved portion of the media asset and converting the resulting segment of media into a deliverable chunk.

Although the generation of the deliverable chunk may involve transcoding it may not. The media asset can be stored in a format where transcoding may not be needed thereby reducing the processing requirements for creating chunks of media during streaming. For example media assets may be stored such as H.264 or MPEG 4 video format and or AAC HE AAC or MP3 audio format. According to some streaming protocols such as some forms of HTTP streaming chunks of media in these formats would not need transcoding before being wrapped in an MPEG 2 transport stream container format. Instead such a conversion essentially would require the addition of metadata to create the streaming format from the format of the stored media asset. In other words generating a deliverable chunk of media may only require identifying the stored media asset extracting the relevant segment of the media from the media asset and adding certain metadata in accordance with a container format. This process requires little processing power and can be easily performed on the fly during streaming. Once the deliverable chunk of media is generated it is sent to the CDN or other requesting entity at block .

The index file generator generates an index file to indicate the next chunk of media . As described above this chunk may include an advertisement and the index file can include any amount of information about a chunk of media including information regarding alternative sub streams for streaming. The dynamic index file generator can include information regarding existing chunks of media and when used in conjunction with a dynamic segmentor may also include information regarding chunks of media that may need to be created. As detailed above if a chunk of media is to be generated dynamically the index file generator may indicate this by including an indicator in the generated index file such as in a URL for one or more chunks described within the index file. Once the index file is generated the index file generator sends the index file which is received by the client .

Alternative embodiments may provide for the generation of index files containing more than a next chunk of media. For example an index file generator may generate an index file containing information regarding several chunks of media in which case the chunks of media can be dynamically generated by a dynamic segmentor when requested by the client. The determination of whether to include information regarding more than a next chunk of media can include factors such as whether the index generator is generating reporting data the desired frequency of such reporting data and more.

Using information contained in the index file the client can then request the next chunk of media and this request can be received by a CDN . The CDN then checks to see if the chunk is already stored in the cache . If so the CDN can provide the requested chunk to the client blocks and . The requested chunk may be found in a CDN s cache if the chunk was created and stored in the CDN during preprocessing or if the chunk was dynamically created and stored in the CDN from an earlier request.

If the chunk is not found on the CDN the chunk can be requested of the dynamic segmentor which receives the request and retrieves the corresponding media asset from an asset origin server . As discussed above the entirety of the relevant media asset does not need to be retrieved as long as at least the portion containing the relevant segment for the requested chunk is retrieved. It will be understood that alternative embodiments can provide for the media asset being stored in a variety of locations accessible directly or indirectly to the dynamic segmentor.

The dynamic segmentor can then generate the requested chunk by converting the retrieved media into a deliverable chunk. That is the dynamic segmentor converts the retrieved media into an acceptable format for streaming which can vary depending on the streaming protocol utilized. The dynamic segmentor can then return the requested chunk to the CDN which can cache the chunk and return it to the client . Once the chunk is received by the client the client can play the chunk to an end user.

It should be noted that the methods systems and devices discussed above are intended merely to be examples. It must be stressed that various embodiments may omit substitute or add various procedures or components as appropriate. For instance it should be appreciated that in alternative embodiments the methods may be performed in an order different from that described and that various steps may be added omitted or combined. Also features described with respect to certain embodiments may be combined in various other embodiments. Different aspects and elements of the embodiments may be combined in a similar manner. Also it should be emphasized that technology evolves and thus many of the elements are examples and should not be interpreted to limit the scope of the invention.

Specific details are given in the description to provide a thorough understanding of the embodiments. However it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example well known circuits processes algorithms structures and techniques have been shown without unnecessary detail in order to avoid obscuring the embodiments. This description provides example embodiments only and is not intended to limit the scope applicability or configuration of the invention. Rather the preceding description of the embodiments will provide those skilled in the art with an enabling description for implementing embodiments of the invention. Various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the invention.

Also it is noted that the embodiments may be described as a process which is depicted as a flow diagram or block diagram. Although each may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. In addition the order of the operations may be rearranged. A process may have additional steps not included in the figure. Furthermore embodiments of the methods may be implemented by hardware software firmware middleware microcode hardware description languages or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a computer readable medium such as a storage medium. Processors may perform the necessary tasks.

Having described several embodiments it will be recognized by those of skill in the art that various modifications alternative constructions and equivalents may be used without departing from the spirit of the invention. For example the above elements may merely be a component of a larger system wherein other rules may take precedence over or otherwise modify the application of the invention. Also a number of steps may be undertaken before during or after the above elements are considered. Accordingly the above description should not be taken as limiting the scope of the invention.

