---

title: Pointer unification
abstract: Embodiments relate to a computing device having storage, a processor, a display, a first human input device, and a second human input device, where the first human input device is in a first category of human input devices and the second human input device is in a second category of human input devices. The computing device may perform a process involving executing a windowing environment that manages windows of applications executing on the computing device. The windowing environment may receive raw inputs from the first and second human input devices and in turn generate input pointers for the raw inputs, respectively. The input pointers may be or include instances of an input pointer class implemented by the windowing environment, the pointer class used by the windowing environment for arbitrary different types of human input pointer devices including the first human input device and the second human input device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483155&OS=09483155&RS=09483155
owner: Microsoft Technology Licensing, LLC
number: 09483155
owner_city: Redmond
owner_country: US
publication_date: 20120913
---
The Human Interface Device HID standard is a protocol that allows human operated input devices to send data to a host computer. HID is flexible regarding what information devices are allowed to report. Pointer devices e.g. mice pens touch digitizers etc. all report x y coordinates but depending on the device data such as pressure tilt and contact geometry may or may not be reported. In addition HID allows devices to report custom properties effectively allowing them to include any arbitrary information. The fact that certain data may or may not be present makes it challenging for developers to write software that supports these devices. Often a developer must write different sections of code to support different types of devices.

In addition developers must contend with different user interface frameworks that use different coordinate systems which may be relative to the physical screen the application window UI elements within the window or other reference frames. Keeping track of a variety of coordinate systems is tedious and forces developers to write code differently based on the UI framework being used.

In addition when performing gesture recognition most gesture recognizers work on a full set of inputs. It has not been possible for a developer to code for basic gesture detection at the contact level without sacrificing the use of system provided gesture recognition.

Finally legacy applications may expect traditional mouse messages. Such applications may not expect device neutral pointer messages containing mouse data there has not been any way to support these applications while at the same time providing a mechanism that transforms generic pointer data into legacy mouse data in an efficient way.

Discussed below are techniques related to providing unified access to inputs pointers from pointer devices such as mice touch surfaces pens or other input devices that allow a user to point in two or three dimensions.

The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter which is set forth by the claims presented at the end.

Embodiments relate to a computing device having storage a processor a display a first human input device and a second human input device where the first human input device is in a first category of human input devices and the second human input device is in a second category of human input devices. The computing device may perform a process involving executing a windowing environment that manages windows of applications executing on the computing device. The windowing environment may receive raw inputs from the first and second human input devices and in turn generate input pointers for the raw inputs respectively. The input pointers may be or include instances of an input pointer class implemented by the windowing environment the pointer class used by the windowing environment for arbitrary different types of human input pointer devices including the first human input device and the second human input device.

Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.

Embodiments discussed below relate to unified handling of pointer devices in a windowing environment. Discussion will begin with an overview of an example prior approach and limitations thereof. A windowing environment that allows applications to handle pointing devices and their inputs in a unified manner is then described followed by discussion of example implementations.

The windowing environment also may handle inputs from human input devices such as a keyboard a mouse a pen a touch device or any other human operated input device. Of particular note are pointer type input devices by which a user can specify arbitrary two or three dimensional input points and other inputs. Input devices may pass raw input device data up through respective driver stacks to a kernel module which may in turn pass input data to the windowing environment which decides which applications to notify about which inputs or input activated events.

The windowing environment treats each input device as a separate and distinct data type. That is the windowing environment may have a different set of data types and interfaces for each type of input device. For example the windowing environment may have a mouse specific API a mouse object class and may pass mouse specific messages to applications and the windowing environment may also pass other window messages e.g. refresh minimize move resize close etc. . The windowing environment may also pass touch specific messages to applications and . In short applications and if they are to operate for any of the input devices must have different code to handle the different types of inputs even in cases where the different types of input devices have semantic similarities such as with pointer devices.

The windowing environment may also include gesture recognition functionality possibly passing gesture recognition messages to applications . However if applications are to deal with raw input they may need additional code for handling raw input messages received from driver stacks . Such raw input may be unusable with native gesture recognition functionality provided by the windowing environment thus possibly requiring an application to forego using gesture recognition functions provided by windowing environment and instead disadvantageously include custom written gesture recognition code.

In addition if the application uses gestures the pointer message can be passed to an instance of a gesture processor which may use information about the pointer message i.e. pointer input to determine whether a gesture or manipulation has occurred. When a gesture or manipulation e.g. an affine transformation is identified the gesture processor in turn may signal the application with an event or callback indicating the identified gesture or manipulation.

While this description refers to classes objects event handlers and other object oriented constructs these are only non limiting examples used for convenience of explanation. Such examples are not to be taken as implying that any of the components or embodiments described herein are object oriented or require an object oriented environment. To the contrary a windowing environment may well have no classes or other object oriented constructs. Those skilled in the art of computer programming will appreciate that data structures data types messages functions and other non object oriented C style constructs and APIs can be used with equal effect. Embodiments may also be implemented in simplified object oriented environments such as Javascript . Any use of object and class and related features such as methods and members will be understood as used herein as also describing implementations that use data structures and data types functions flat APIs and the like as the case may be. For example the Win32 module uses no classes per se. The companion User32 module sends for example window messages e.g. pointer messages to applications which in turn may process those messages using various associated functions. In sum the embodiments described herein can be implemented in any type of programming environment using any type of programming language.

Regardless of the type of pointer input device used e.g. pen mouse touch surface or other the same gesture handling code may be used by the application. In addition if necessary the application may access information about the device associated with a pointer input to handle the input in a device specific manner.

As mentioned above it may be desirable to provide the pointer class with a property or field indicating whether a pointer is deemed to be a primary pointer. Various heuristics or rules may be used to determine whether a pointer device s input is primary. For example a mouse device s inputs may always be considered primary to the exclusion of other device inputs. When multiple concurrent touches are presented by a touch input device inputs from a first contact point may be given primary status. If a primary touch input is lifted and a second touch input remains down even though a state is reached where there is not a current primary input it is not until all touch contacts are determined to have ended e.g. the second touch is lifted that another new initial contact can become a new primary input. Note that the concept of a primary pointer can be tied to which input gets promoted to a legacy mouse construct as described below.

In some cases so called legacy applications that are not coded to work with the above described pointer input model may nonetheless execute with the unified input windowing environment A. In one embodiment the unified input windowing environment A probes a new application to determine if the application will recognize messages for the pointer input model for instance sending unified device messages. If an error occurs or there is no response the unified input windowing environment A may translate the pointer inputs into traditional mouse messages as described with reference to e.g. mouse events mouse specific objects etc. . It is also possible that the application may have an environment setting that allows the unified input windowing environment A to explicitly determine whether the application is a legacy application that cannot understand the unified pointer input model which may also be mitigated by translating to older input formats that are suitable to the application when such an environment setting is detected probing may be avoided . When translation occurs the primary property may be used to identify which inputs are to be mouse inputs other inputs may be handled as raw input or in other ways.

As mentioned embodiments and features discussed above can be realized in the form of information stored in volatile or non volatile computer or device readable media. This is deemed to include at least media such as optical storage e.g. compact disk read only memory CD ROM magnetic media flash read only memory ROM or any other means of storing digital information in a way that is convenient for use by a computer but excluding signals and energy per se. The stored information can be in the form of machine executable instructions e.g. compiled executable binary code source code bytecode or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as random access memory RAM and or virtual memory storing information such as central processing unit CPU instructions during execution of a program carrying out an embodiment as well as non volatile media storing information that allows a program or executable to be loaded and executed.

