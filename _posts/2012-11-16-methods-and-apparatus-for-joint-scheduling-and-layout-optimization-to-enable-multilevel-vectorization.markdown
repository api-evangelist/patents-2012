---

title: Methods and apparatus for joint scheduling and layout optimization to enable multi-level vectorization
abstract: Methods, apparatus and computer software product for source code optimization are provided. In an exemplary embodiment, a first custom computing apparatus is used to optimize the execution of source code on a second computing apparatus. In this embodiment, the first custom computing apparatus contains a memory, a storage medium and at least one processor with at least one multi-stage execution unit. The second computing apparatus contains at least one vector execution unit that allow for parallel execution of tasks on constant-strided memory locations. The first custom computing apparatus optimizes the code for parallelism, locality of operations, constant-strided memory accesses and vectorized execution on the second computing apparatus. This Abstract is provided for the sole purpose of complying with the Abstract requirement rules. This Abstract is submitted with the explicit understanding that it will not be used to interpret or to limit the scope or the meaning of the claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489180&OS=09489180&RS=09489180
owner: Reservoir Labs, Inc.
number: 09489180
owner_city: New York
owner_country: US
publication_date: 20121116
---
This application is related to and claims the benefit of priority to U.S. Provisional Application Ser. No. 61 561 394 filed on Nov. 18 2011 the entirety of which is hereby incorporated by reference.

This invention was made with Government support under Agreement No. HR0011 10 3 0007 awarded by DARPA. The Government has certain rights in the invention.

The present invention generally concerns computer programming. More particularly the invention concerns a system methods and apparatus for source code compilation.

The progression of the computer industry in recent years has illustrated the need for more complex processor architectures capable of processing large volumes of data and executing increasingly complex software. A number of systems resort to multiple processing cores on a single processor. Other systems include multiple processors in a single computing device. Additionally many of these systems utilize multiple threads per processing core and have access to vector units which require specific know how to be fully utilized. One limitation that these architectures experience is that the current commercially available compilers cannot efficiently take advantage of the increase of computational resources.

In the software design and implementation process compilers are responsible for translating the abstract operational semantics of the source program into a form that makes efficient use of a highly complex heterogeneous machine. Multiple architectural phenomena occur and interact simultaneously this requires the optimizer to combine multiple program transformations. For instance there is often a tradeoff between exploiting parallelism and exploiting locality to reduce the ever widening disparity between memory bandwidth and the frequency of processors the memory wall. The tension between parallelism and locality of memory references is an important topic in the field of compiler optimization. More parallelism allows more concurrent execution of the parallel portions of a program. Additional parallelism implicitly relates to more available computational operations per second. Increasing locality directly translates into communication reduction between memories and processing elements. Typically however the portions of a program that may be executed in parallel are not interdependent and as such these portions together may access non local data or data that are distributed throughout the memory Because of these program semantics constraints increasing parallelism may decrease locality and vice versa.

An additional architectural phenomenon related to both parallelism and the memory wall is the ability for processors to better process data elements whose addresses in memory are evenly spaced also referred to as constant strides . Such regularity of memory accesses allow the program to take advantage of hardware streaming prefetchers that increase the sheer memory bandwidth available to processors as well as of vector units that allow the execution of multiple logical instructions as a single hardware instruction. This additional constant stride memory constraint conflicts with parallelism and locality in the sense that programs with good parallelism and locality may not exhibit constant strides and vice versa.

Current trends in computer architecture amplify the utilization of vector units on a chip. Modern multiple core computer architectures that include general purpose multi core architectures and specialized parallel architectures such as the IBM Cell Broadband Engine Intel Xeon processors with SSE4 SIMD instructions Intel Many Integrated Core Architecture with AVX extensions and NVIDIA Graphics Processing Units GPUs have very high computation power per chip thanks to the use of wide vector units per chip. Current and future architectures are increasingly evolving towards heterogeneous mixes of general purpose and specialized parallel architectures. Such an execution model comes with the need for the application to exhibit joint parallelism locality and constant strided memory accesses. Increased parallelism may be obtained by explicitly writing programs with more parallelism or by using auto parallelizing compilers.

While programming such systems by hand has been demonstrated for a range of applications this is a difficult and costly endeavor likely one to be revisited to allow the application to port to rapidly arriving new generations and configurations of heterogeneous architectures and programming abstractions that change the optimization tradeoffs.

Even when programming models are explicitly parallel threads data parallelism vectors they usually rely on advanced compiler technology to relieve the programmer from scheduling and mapping the application to computational cores understanding the memory model and communication details. Even provided with enough static information or annotations OpenMP directives pointer aliasing separate compilation assumptions compilers have a hard time exploring the huge and unstructured search space associated with these mapping and optimization challenges. Indeed the task of the compiler can hardly been called optimization anymore in the traditional meaning of reducing the performance penalty entailed by the level of abstraction of a higher level language. Together with the run time system whether implemented in software or hardware the compiler is responsible for most of the combinatorial code generation decisions to map the simplified and ideal operational semantics of the source program to the highly complex and heterogeneous machine.

The polyhedral model is a powerful framework to unify coarse grained and fine grained parallelism extraction with locality and constant strided memory access optimizations. To date this promise has not yet been completely fulfilled as no existing affine scheduling and constant strided memory technique can perform all these optimizations in a unified i.e. non phase ordered and unbiased manner. Typically parallelism optimization algorithms optimize for degrees of parallelism but cannot be used to also optimize for constant strided memory accesses. In like manner algorithms used for data layout transformations reshape the position of data elements in memory but cannot be used both for extracting parallelism and locality. Additional difficulties arise when optimizing source code for the particular architecture of a target computing apparatus.

Therefore there exists a need for improved source code optimization methods and apparatus that can jointly optimize scheduling and constant stride memory accesses at multiple level of the heterogeneous hardware hierarchy.

The present invention provides a system apparatus and methods for overcoming some of the difficulties presented above. Various embodiments of the present invention provide a method apparatus and computer software product for optimization of a computer program on a first computing apparatus for execution on a second computing apparatus.

In an exemplary provided method computer program source code is received into a memory on a first computing apparatus. In this embodiment the first computing apparatus processor contains at least one multi stage execution unit. The source code contains at least one arbitrary loop nest. The provided method produces program code that is optimized for execution on a second computing apparatus. In this method the second computing apparatus contains at least a multi stage vector execution unit. With this unit there is an opportunity for vector operations through the exposition of both parallel operations and constant stride memory accesses. In its optimization of the code the first computing apparatus takes into account the opportunity for parallel operations and constant stride memory accesses and analyses the tradeoff of execution costs between vector execution and non vector execution on the second computing apparatus. In this embodiment the first computing apparatus minimizes the total costs and produces code that is optimized for execution on the second computing apparatus.

In another embodiment a custom computing apparatus is provided. In this embodiment the custom computing apparatus contains a storage medium such as a hard disk or solid state drive a memory such as a Random Access Memory RAM and at least one processor. In this embodiment the at least one processor contains at least one multi stage execution unit. In this embodiment the storage medium is customized to contain a set of processor executable instructions that when executed by the at least one processor configure the custom computing apparatus to optimize source code for execution on a second computing apparatus.

The second computing apparatus in this embodiment is configured with at least a multi stage vector execution unit. With this unit there is an opportunity for vector operations through the exposition of both parallel operations and constant stride memory accesses. In its optimization of the code the first computing apparatus takes into account the opportunity for parallel operations and constant stride memory accesses when additional data layout transformations are permitted and analyses the tradeoff of execution costs between vector execution and non vector execution on the second computing apparatus. This configuration allows the execution of some tasks by the at least one vector unit and others in serial on a single execution unit. In the optimization process the at least one processor takes into account the tradeoff between the cost of data layout transformation operations on the second computing apparatus and the benefit of vector operations on a single vector multi stage execution unit in the second computing apparatus.

Accordingly in one aspect a computer implemented method an apparatus including a processor and a memory including processor executable instructions that when executed by the processor configure the apparatus and or an article of manufacture including a non transitory machine readable medium storing instructions that when executed by a machine configure the machine are provided to receive a computer program in the memory. The method and or instructions in the apparatus and or the article are also provided to transform the computer program for execution on the second computing apparatus the transformation comprising optimization of a selective tradeoff of a cost of parallelism locality vectorization and data layout transformations to orchestrate computations associated with the program. Moreover the program and or instructions produce an optimized computer program for execution on the second computing apparatus.

In some embodiments the optimization of the selective tradeoff includes determination of an optimization problem representing i each statement in a set of statements in the program at least one statement in the set being associated with a multi dimensional memory reference ii a set of candidate schedules each candidate schedule representing at least a partial order of execution of operations in the program on the second computing apparatus and iii a set of aggregate costs. Each aggregate cost may be a cost of execution according to a corresponding candidate schedule and the aggregate cost may include a parallelism cost and a locality cost and at least one of a vectorization cost and a data layout transformation cost. The optimization of the selective tradeoff also includes optimization of the problem by selecting a loop transformation a data layout transformation or both to obtain a final schedule such that the aggregate cost associated with the final schedule is minimized and identification of the selected loop transformation the selected data layout transformation or both. The identified data layout transformation may correspond to any one dimension of the multi dimensional memory reference.

In some embodiments the aggregate cost corresponding to a candidate schedule in the set of candidate schedules is based on at least in part a static evaluation of a model of cost of executing operations of the at least one statement according to the candidate schedule. The aggregate cost corresponding to a candidate schedule in the set of candidate schedules may also be based on at least in part a dynamic evaluation of a model of cost of executing operations of the at least one statement according to the candidate schedule. The dynamic evaluation may be based on at least in part the second computing apparatus. The method and or the instructions of the apparatus article may iteratively refine the aggregate cost using at least one of the static evaluation and the dynamic evaluation.

In some embodiments the method and or the instructions provide for determining an search space to be used in the step of optimizing the optimization problem and at least one candidate schedule in the set of candidate schedules is selected by traversing the search space. The search space which may be an optimized search space may be traversed exhaustively. The set of candidate schedules may include each schedule in the search space. In some embodiments the set of operations includes at least one loop nest.

The transformation according to the method or that caused by the instructions may include receiving a first schedule dimension within several schedule dimensions associated with the loop nest. The optimization may include solving the optimization problem to obtain the final schedule wherein the final schedule corresponds to the first schedule dimension. The first schedule dimension may corresponds to any linear combination of any loops in the loop nest.

The transformation according to the method or that caused by the instructions may additional include receiving a second schedule dimension within the plurality of schedule dimensions associated with the loop nest adding schedule orthogonality constraints based on the first schedule dimension and repeating the optimization by solving and identification based on the second schedule dimension. As a result a loop transformation and or a data layout transformation associated with the final schedule corresponds to one or both of the first and second schedule dimensions.

In some embodiments the optimization includes computing a difference between a speed of sequentially executing operations of a loop in the loop nest on a single execution unit in the second computing apparatus and b speed of executing those operations in parallel on a plurality of execution units in the second computing apparatus. In some embodiments the loop nest includes first and second loops and the optimization includes computing a difference between a speed of alternately executing an operation of the first loop and an operation of the second loop and b speed of executing all operations of the first loop followed by executing all operations of the second loop.

The optimization may also include computing a difference between a speed of executing operations of the at least one statement associated with the multi dimensional memory reference such that a plurality of memory locations associated with the memory reference are accessed according to a uniform spacing between successive accesses and b speed of executing those operations such that the plurality of memory locations accessed are spaced apart nonuniformly. In some embodiments the optimization includes a penalty for performing a data layout transformation so as to adjust a spacing between memory access associated with the multi dimensional memory reference. The optimization may also include assigning a decision variable corresponding to at least one of parallelism locality vectorization and data layout transformations.

In some embodiments the set of operations includes one or more loop nest and the decision variable specifies one or more of i if a loop in the loop nest is to be executed in parallel by the second computing apparatus ii if a pair of loops in the loop nest are to be executed together by the second computing apparatus iii if a loop in the loop nest is to be executed as a vector loop and iv if a memory reference associated with a loop within the loop nest requires a data layout transformation allowing for vector access to the memory reference during execution of operations of the loop. The optimization may include optimizing a global weighted parametric function of i the parallelism cost ii the locality cost iii the vectorization cost iv the data layout transformations cost and v four decision variables. The decision variables can be those described above.

In some embodiments the method and or the instructions provide for identifying several schedules of operations in the set of operations at least one of the identified schedules improving one or more of parallelism locality vectorization and contiguity of memory accesses of the at least some of the operations. The method and or the instructions may provide for determining a set of conditions preserving semantic correctness of the program if the at least some of the operations are executed according to one of the schedules in the plurality of schedules. Each schedule violating at least one condition may be eliminated from the identified schedules so as to obtain a search space to be used for optimizing the selective tradeoff.

It will be recognized that some or all of the figures are schematic representations for purposes of illustration and do not necessarily depict the actual relative sizes or locations of the elements shown. The Figures are provided for the purpose of illustrating one or more embodiments with the explicit understanding that they will not be used to limit the scope or the meaning of the claims.

In the following paragraphs the present invention will be described in detail by way of example with reference to the attached drawings. While this invention is capable of embodiment in many different forms there is shown in the drawings and will herein be described in detail specific embodiments with the understanding that the present disclosure is to be considered as an example of the principles of the invention and not intended to limit the invention to the specific embodiments shown and described. That is throughout this description the embodiments and examples shown should be considered as exemplars rather than as limitations on the present invention. Descriptions of well known components methods and or processing techniques are omitted so as to not unnecessarily obscure the invention. As used herein the present invention refers to any one of the embodiments of the invention described herein and any equivalents. Furthermore reference to various feature s of the present invention throughout this document does not mean that all claimed embodiments or methods must include the referenced feature s .

The trend of increasing the frequency at which processors perform computations has come to an end. Power consumption and control complexity have reached such high levels that manufacturers are backing out of this design path. Current machines have evolved to multiprocessor architectures on a chip with increasingly many cores per chip and multiple threads per core. This trend is expected to dramatically increase reaching thousands of cores per chip in the next few years. Thus modern computers increasingly need to exploit parallelism at different levels to provide sustained performance. On the other hand parallel programming techniques have not evolved at the same speed and the gap between theoretical machine speed and actual utilization continues to increase. In this context an important source of performance resides in the vector units of processors.

Compilers are responsible for translating the abstract operational semantics of the source program i.e. a text description of what the program s execution is supposed to perform into an executable form that makes efficient use of a highly complex heterogeneous machine. Multiple architectural phenomena occur and interact simultaneously within the targeted computer during the execution of the program this requires the optimizing compiler to combine multiple program transformations in order to define a program execution that takes advantage of those architectural phenomena. For instance when targeting computers that have multiple processing elements multi core computers there is often a trade off between exploiting more processing elements simultaneously parallelism and exploiting data access locality to reduce memory traffic. Indeed the speed and bandwidth of the memory subsystems are almost always a bottleneck. The problem is typically worse for multi core computers. The tradeoffs between parallelism and locality are but one aspect of the optimization problem. Another important aspect is the tradeoff with constant strided memory accesses. Constant strided memory accesses have been linked to good utilization of hardware memory prefetchers boosting the memory bandwidth capabilities of modern micro processors. Additionally when parallelism at the proper granularity is available concurrently with constant strided memory accesses vector execution is enabled. Obtaining both parallelism and constant strided memory accesses is traditionally implemented as a multi phase process in which loop transformations are selected then a data memory layout transformation is sought. It is an object of this invention to provide a joint formulation to optimize these phases simultaneously. It is a further object of this invention to provide a search procedure to traverse a joint search space and extract good tradeoffs between parallelism locality and constant strided memory accesses that can be further exploited for vector execution.

Since in traditional compilers optimization problems are associated with huge and unstructured search spaces this combinational task is poorly achieved in general resulting in poor scalability and disappointing sustained performance of the supposedly optimized program.

It is an object of embodiments of the present invention to provide a customized computing apparatus methods and computer software product that simultaneously optimizes a computer program for execution on a particular computing device with vector execution units. It is another object of the invention to provide embodiments of methods which can explore the complete solution space for legal schedules for potential solutions. It is a further object of the invention to provide methods containing new formulations that encode the tradeoffs between parallelism locality constant strided memory accesses and vectorization directly in the constraints and the objective functions of an optimization problem.

The effect of loop fusion is to interleave the execution of the first loop with the execution of the second loop.

A consequence of loop fusion is that memory locations a i and b i referenced by the former 2 loops are now accessed in an interleaved fashion. In the former code memory locations were accessed in the order a 0 a 1 . . . a 100 then b 0 b 1 . . . b 100 . In the code comprising the fused loops the memory locations are now accessed in the order a 0 b 0 a 1 b 1 . . . a 100 b 100 . Loop fusion can lead to better locality when multiple loops access the same memory locations. It is common general knowledge in the field of compilers that better locality reduces the time a processing element must wait for the data resident in memory to be brought into a local memory such as a cache or a register. In the remainder of this document we shall say that loops are fused or equivalently that they are executed together when such a loop fusion transformation is applied to the received program to produce the optimized program.

Loop fusion can change the order in which memory locations of a program are accessed and require special care to preserve original program semantics 

In the previous program the computation of b i depends on the previously computed value of a i 1 . Simple loop fusion in that case is illegal. If we consider the value computed for b 0 2 a 1 in the following fused program b 0 will read a 1 at iteration i 0 before a 1 is computed at iteration i 1.

It is common general knowledge in the field of high level compiler transformations that enabling transformations such as loop shifting loop peeling loop interchange loop reversal loop scaling and loop skewing can be used to make fusion legal.

The problem of parallelism extraction is related to the problem of loop fusion in the aspect of preserving original program semantics. A loop in a program can be executed in parallel if there are no dependences between its iterations. For example the first program loop below can be executed in parallel while the second loop must be executed in sequential order 

It is common knowledge in the field of high level compiler transformations that the problems of fusion and parallelism heavily influence each other. In some cases fusing 2 loops can force them to be executed sequentially.

Loop permutability is another important property of program optimizations. A set of nested loop is said permutable if their order in the loop nest can be interchanged without altering the semantics of the program. It is common knowledge in the field of high level compiler optimization that loop permutability also means the loops in the permutable set of loops dismiss the same set of dependences. It is also common knowledge that such dependences are forward only when the loops are permutable. This means the multi dimensional vector of the dependence distances has only nonnegative components. Consider the following set of loops 

Loop permutability is important because it allows loop tiling alternatively named loop blocking . Loop tiling is a transformation that changes the order of the iterations in the program and ensures all the iterations of a tile are executed before any iteration of the next tile. When tiling by sizes i 2 j 4 is applied to the previous code the result is 

Loop tiling is traditionally performed with respect to tiling hyperplanes. In this example the tiling hyperplanes used are the trivial i and j hyperplanes. In the general case any linearly independent combination of hyperplanes may be used for tiling provided it does not violate program semantics. For example i j and i 2 j could as well be used and the resulting program would be much more complex.

Another important loop transformation is loop skewing. It is common knowledge that loop permutability combined with loop skewing results in the production of parallelism. In the following permutable loops the inner loop can be executed in parallel after loop skewing 

The skewing transformation helps extract parallelism at the inner level when the loops are permutable. It is also common knowledge that loop tiling and loop skewing can be combined to form parallel tiles that increase the amount of parallelism and decrease the frequency of synchronizations and communications in the program.

Another desirable property of a program is the access to constant strided memory locations which can enable hardware streaming prefetchers as well vector and SIMD unit utilization. In the following program accesses to array a exhibit constant strided memory accesses along loops i and j and memory dimensions 0 and 1.

In contrast the following program exhibits a non constant strided memory access to array a along loop j by virtue of the a i j 1 j 1 . A sufficient condition for constant strided memory access along loop j is clear the index j may appear only once in each access function.

In addition when a loop exhibits constant stride memory access and is also parallel the loop has vectorization semantics. The following 2 examples illustrate innermost along j and outermost along i vector loop semantics respectively.

When either a loop lacks doall semantics or a single access has non constant stride access along said loop the loop does not exhibit vectorization semantics.

Additional opportunities are available when considering data layout transformations and allowing constant strided memory accesses along the non innermost memory dimension. The following example demonstrates a loop that does not have constant strided innermost memory dimension access whatever the schedule chosen either A or B will have non constant stride access along the innermost memory dimension.

It is possible to relax the innermost memory dimension constraint and allow constant strided memory access along any memory dimension provided the proper data layout transformations are inserted. In the following example b tmp is an auxiliary array introduced to hold the results of such a data layout transformation loop j now exhibits vectorization semantics.

It is a further objective of this innovation to provide a search procedure to distinguish between those cases and exhibit schedules that maximize the amount of vectorizable loops while minimizing the cost of data layout transformations. These objectives are conflicting and it is a further objective to balance them with optimizations for parallelism and locality.

Generating efficient code for deep parallelism and deep memory hierarchies with additional vector units is a difficult task the compiler and run time system has to take the burden of tasks that only expert programmers would be able to carry. In order to exploit parallelism the first necessary step is to compute a representation which models the producer consumer relationships of a program as closely as possible. The power of an automatic optimizer or parallelizer greatly depends on its capacity to decide whether two portions of the program execution may be interchanged or run in parallel. Such knowledge is related to the task of dependence analysis which aims at precisely disambiguating memory references. The issue is to statically form a compact description of the dynamic properties of a program. Forming a precise description is generally undecidable and approximations have to be made.

When considering high level loop transformations it is common practice to represent dependences in the form of affine relations. The first step is to assign to each statement in the program an iteration space and an iteration vector. Consider the program composed of the 2 loops below 

The iteration domain of the statement S is D i j in Z2 1 i n 1 j n. The second step is to identify when two operations may be executed in parallel or when a producer consumer relationship prevents parallelism. This is done by identifying the set of dependences in the program. In this example the set of dependences is R i j i j i i j j 1 i j in D i j in D 

It is common practice to represent the dependence relations using a directed dependence graph whose nodes represent the statements in the program and whose edges represent the dependence relations. In the previous example the dependence graph has 1 node and 2 edges. It is common practice to decompose the dependence graph in strongly connected components. Usually strongly connected components represent loops whose semantics require them to be fused in the optimized code. There are many possible cases however and one of the objects of this invention is also to perform the selective tradeoff of which loops to fuse at which depth. It is common knowledge that a strongly connected component of a graph is a maximal set of nodes that can be reached from any node of the set when following the directed edges in the graph.

Once dependence analysis has been computed a compiler performs program transformations to the code with respect to different sometimes conflicting performance criteria. Any program transformation must ultimately respect the dependence relations in order to guarantee the correct execution of the program. A class of transformations targeting the loop nests of a program such as DO loops in the FORTRAN language and for and while loops in languages derived from the C language are known to account for the most compute intensive parts of many programs. The polyhedral model is a representation of a program s structure particularly suited for expressing complex sequences of loop nests complex sequences of loop nest transformations and other relevant information such as for instance dependences communications and array layouts.

A polyhedron is defined as a set of points verifying a set of affine inequalities and equalities on a number of variables. There exist alternate but equivalent definitions for polyhedrons such as the one based on a combination of vertices rays and lines proposed by Minkowski. There are also alternate representations often based on the alternate definitions. While the present disclosure teaches using one of those definitions and representations to illustrate the various embodiments various embodiments are in no way restricted to a particular definition or representation.

A polyhedral domain is defined as a finite union of polyhedrons. One of the main interests in using polyhedral domains is that they provide a precise representation of sets and relations among sets on which many optimization problems can be phrased and solved using a rich set of algorithms which are mostly available in the literature. Some embodiments of the sets in question represent loop iterations mono and multi dimensional data sets sets of processing elements data transfers synchronizations and dependences. Thus essential characteristics of the execution of a program can be summarized into compact mathematical objects polyhedrons which can be manipulated and transcribed into an executable program that has desired execution properties.

The polyhedral model is a mathematical abstraction to represent and reason about programs in a compact representation. In an embodiment this innovation operates on a generalized dependence graph GDG based Intermediate Representation IR containing the following information.

In some embodiment a statement S is a set of operations grouped together. Statements are the atomic unit of scheduling and often correspond to a statement in the original program. Depending on the level of abstraction a statement can be arbitrarily simple i.e. micro code or arbitrarily complex i.e. external precompiled object .

In another embodiment an iteration domain DS is an ordered set of iterations associated to each statement S and describes the loop iterations in the original program which control the execution of S. To model multiple levels of nested loops iteration domains are multi dimensional sets. Order between 2 iterations i1 and i2 of S is written i1

In a further embodiment a memory reference F is a function that maps domain iterations to locations in the memory space. The image of DS by F represents the set of memory locations read or written by S through memory reference F. If F is injective distinct memory locations are touched otherwise memory reuse exists within the program. Each statement can access multiple memory references in read and or write mode.

In yet another embodiment a scheduling function maps the iterations of S to time. It is a partial order that represents the relative execution order of each iteration of S relative to all other iterations of any statement in the program. Well established terminology in the field decomposes in a linear part for unimodular and non unimodular loop transformations a parametric constant part for multi dimensional shifts and a constant vector that encodes all possible imperfectly nested loop structures. If the function is injective the output program is sequential otherwise parallel iterations exist. In particular the order 

In an embodiment a dependence T S is a relation between the set of iterations of S and T. It conveys the information that some iteration of T depends on some iteration of S they access the same memory location by application of a memory reference and that iS

It is a particular object of this invention to form the convex set of all legal schedules in the program. In this multi dimensional formulation dependences in the program are modeled by dependence edges in the GDG. Each edge is decorated by a dependence polyhedron. It is common knowledge in the field that a necessary and sufficient condition for a transformed program to be legal is that the order of all iterations in a dependence be preserved. The convex set of all legal schedules is constructed by virtue of the linear inequality constraints 

In some embodiments invertible schedules are exhibited. When is not invertible it is always possible to complete it into a full rank schedule to iterate over all the points in the domain. In some embodiment this completion is performed at code generation and consists in adding innermost parallel loops to each statement. In some embodiments this procedure degrades the parallelism granularity and does not exploit degrees of freedom in the program to improve locality constant strided memory accesses or vectorization. In these embodiments singular schedules give the impression a loop dimension is parallel with the caveat that it may contain only a single point. It is a purpose of our invention to avoid this issue.

The following example exemplifies the problem. Consider the example of a single statement S i j k . In this example the objective is to maximize the 2 outermost degrees of parallelism the returned schedule parallelism markers may be i i j doall doall seq .

The following code exemplifies the singular schedule i i j doall doall seq with the doall j loop executing only 1 iteration.

In this form the program is incorrect and a subsequent non singular completion would result in the following code 

The result of the completion step is to transform the singular schedule i j into a full rank schedule of rank 3 i i j k doall doall seq doall . By the linear redundancy of the first two dimensions the full rank schedule is equivalent to i j k doall seq doall . In other words a scheduler may wrongly think it has found 2 outermost levels of parallelism when it may have missed a potential k i j i i j k doall doall seq solution.

It is the purpose of our innovation to use the convex multi dimensional formulation of all legal schedules to search for invertible schedules. In a possible embodiment the procedure computes full schedules at each step that is all the elements of a square matrix. These schedules may not be invertible as a result of a single step of the integer linear programming optimization problem. In other embodiments additional linear independence constraints are added incrementally from the lower dimensions to the higher dimensions while searching for a full schedule. Since a singular schedule can always be completed at the innermost level this proposed embodiment will always succeed. Linear independence constraints are added using the expression of orthogonal subspaces which is well known in the field of polyhedral compilation. As an illustration consider a 3 3 schedule matrix. In the first step the integer linear programming problem has no linear independence constraints. A possible result could be schedule k j k . At the first step the search procedure would retain only the first row k and would iterate again by adding the constraint k orthogonal to the integer linear programming problem. A possible result for the second iteration would be k i j i j k . This schedule is still singular because it is of rank 2. The algorithm then iterates and adds the constraints k i j orthogonal. Eventually at the third iteration the solution could resemble k i j i k is guaranteed to be invertible.

In further embodiments the constant strided memory access constraints necessitate the multi dimensional formulation and the search of full functions at each step.

In some embodiments the scheduling algorithm performs tradeoffs between the amount of parallelism amount of locality and amount of constant strided memory accesses in a joint optimization problem. Constant stride memory accesses result in optimized spatial reuse for memory hierarchies where accessing a regularly spaced set of memory references is crucial to obtaining high performance. Such hardware features include hardware prefetch streams simd and vector operations and coalescing hardware in GPUs.

In further embodiments constant strided access for a statement S along an access function F is characterized by the linear part of an r dimensional access function F to a memory reference R. In such cases where the affine part of the scheduling function is invertible constant stride access along memory dimension r and along some unspecified schedule dimension d for reference F is obtained when cardi m 0 1 in 

Further embodiments include this additional card constraint in an integer linear programming search procedure. In such embodiments the last column of the inverse of the matrix F represents the innermost dimension of the array access after the process of polyhedral code generation. Other embodiments use the notation Uto denote the sub matrix obtained by removing row k from given a matrix U. When the number of loops enclosing statement S is d the invertible affine schedule matrix has d rows and we are interested in . Constraints for a single statement S of dimension d accessing a memory reference R with access function F are described. The coefficients of the matrix F are known coefficients of are unknown. Constant stride access along the innermost schedule dimension d of S and along the innermost array subscript r proceeds as follows. For each tuple F d and r a contiguity decision variable cencodes whether contiguity is achieved along memory dimension r and schedule dimension d. The constraints added to the multi dimensional linear space of all legal schedules to link care 0 1 1 0 1 0 Where is the current row of being computed are unconstrained variables to help write the linear dependence of on Fand N are large enough constants. Such an embodiment realizes a search procedure for a schedule such that the access to the r th memory dimension has a constant stride.

Other embodiments drive the search in the constraint space by virtue of maximizing a cost function for maximal expected benefit of constant strided memory accesses 

The following examples illustrate the effects of affine transformations on strided memory accesses. The linear programming objectives used are in their order of magnitude 1 maximize the constant strided memory access metric and 2 minimize the absolute value of schedule coefficients in . In particular these examples only attempt to optimize constant strided accesses along the innermost level of schedule and the innermost level of memory. The original code is exhibited on the left and the result of optimizing constant strided access on the right.

In a possible embodiment of our invention the above example illustrates the optimization of a single array reference. The schedule is j i k i and the access to A is constant stride along k in the innermost array dimension with stride 1 on k.

In another possible embodiment of our invention the above example illustrates the optimization of multiple array references and the tendency of the schedule to fission loops in the absence of any fusion optimization objective. The schedule computed is i k j for the first statement and k i j for the second.

Further embodiments also encompass specifying optimization costs and decision variables for vectorizable execution of loops. For each statement S of depth d and each loop level I in 1 d a decision variable is introduced which encodes whether statement S is vectorizable along loop I. Constraints are added to ensure that a loop is vectorizable only if it is parallel 0 . Additional details regarding scheduling and processes related to the various embodiments described herein are described in Applicants co pending U.S. patent application Ser. No. 12 561 152 published as U.S. Pat. App. Pub. No. 2010 0070956 titled Methods and Apparatus for Joint Parallelism and Locality Optimization in Source Code Compilation the contents of which are incorporated herein by reference in their entirety.

Constant stride access constraints for all references within a statement are linked together one schedule dimension at a time for each tuple S I F where S is a statement I a loop enclosing the statement F an access function for S 0 c where r is the dimension of F. Constant stride constraints force all arrays touched by S to be accessed with a constant stride along schedule dimension I if the loop I is to be vectorizable.

Cost coefficients for vectorization are introduced. For each a corresponding cost coefficient is introduced and the cost for vectorizable loops is introduced as another linear objective in the global cost function 

In some embodiments the example above demonstrates the results of setting larger cost coefficients for the value of the outermost i loop. In the above example the code on the left represents the original program and the code on the right represents the transformed program. The outermost loop doall i is parallel and accesses the array A with a constant stride of 1 it is therefore vectorizable at the outermost level. The schedule achieving this vectorization is i j k j k and is obtained by minimizing the global cost function

In further embodiments of our innovation contiguous strided accesses along multiple memory dimensions are exploited making the problem less constrained and allowing more opportunities for vectorization. In such embodiments data layout transformations are discovered during the search for a tradeoff between parallelism locality constant strided access and vectorization. Data layout transformations permute the constant strided access dimension with the innermost array dimension to make minimize the length of the stride. Data layout transformations are applied in a subsequent optimization phase. In some embodiments the output of our innovation is a schedule for each statement S in the program and a data layout transformation DL for each array accessed in the program.

In further embodiments new Boolean decision variables pare introduced for each tuple S A I consisting of a statement S an array A accessed by that statement and a possible schedule depth I for S. Each decision variable encodes whether all the references to A within S have constant stride memory access along schedule dimension I and some unspecified memory dimension.

In other embodiments new Boolean decision variables qare introduced for each tuple S A I r consisting of a statement S an array A accessed by that statement a possible schedule depth I for S and a possible memory dimensions r for A. Each decision variable encodes whether all the references to A within S have constant stride memory access along schedule dimension I and the fixed memory dimension r.

In further embodiments the vector decision variables are linked to the pdecision variables and the pdecision variables are linked to the qdecision variables through the following linear constraints 

In further embodiment our innovation is exemplified by the code snippet below when only allowing vectorization along the innermost schedule dimension. The code on the left is the result of an optimization when allowing constant strided access only on the innermost memory dimension with schedules i j k and j k i respectively. The code on the right is the result of an optimization when allowing constant strided access on multiple memory dimensions with schedules j k i and k i j respectively. The code on the right exhibits more parallelism and vectorization by virtue of the doall k loop on the second statement which accesses array B.

In further embodiments of our invention the expression of data layout transformations is at the granularity of a statement in the program and further data transformations are performed. The code on the right in the previous example is an illustration of this phenomenon the second and third data dimensions of arrays A and B should be permuted between the 2 loop nests in order to achieve innermost constant stride access of stride 1 for both arrays .

In further embodiments the relative value of the costs w f is determined by using static properties of the program such as estimated number of computations and arithmetic intensity to memory footprint ratio for different statements in the program. In other embodiments the costs are also dependent on the level of the machine hierarchy for which scheduling is performed.

Embodiments of the present invention provide a custom computing apparatus illustrated in that is configured to optimize computer source code for operation on a second computing apparatus. As illustrated first custom computing apparatus is configured to communicate with second computing apparatus across network . A further illustration of computing apparatus is provided in . In this illustration custom computing apparatus contains at least one processor a communication port communicating with the at least one processor . Custom computing apparatus additionally includes memory which in some embodiments includes dependence analysis module . Custom computing apparatus in some embodiments additionally includes drive configured to accept external storage medium . In some embodiments external storage medium is a CD in others a DVD. In these embodiments drive is configured to accept the appropriate external storage medium . While CD and DVD are specifically enumerated in these embodiments there are many external storage media that can be used to practice various aspects of the invention therefore some embodiments are not limited to the particular drive configuration or external media . Custom computing apparatus additionally includes storage medium . Storage medium in some embodiments is a hard disk drive and in others is a solid state drive. In some embodiments storage medium contains a set of processor executable instructions that when executed by the at least one processor configure custom computing apparatus to optimize computer code for execution on computing apparatus . While custom computing apparatus and computing apparatus are illustrated in communicating over network various embodiments of the invention do not require this inter computer communication.

In some embodiments the second computing apparatus includes a vector unit processor and a memory unit. The vector unit processor may be a multi stage vector execution unit. In addition the second computing apparatus may include one or more non vector execution units that may execute at least portions of the program concurrently. illustrates a vector execution unit also referred to as SIMD Single Instruction Multiple Data . The operands in registers A and B correspond to data spaced in memory with a uniform increment of one. Several execution units included in the vector execution unit operate in parallel and in a single operation perform several computations X on each piece of data and store the corresponding results in a register C. The operations performed in a single step by the unit are C 1 A 1 X B 1 C 2 A 2 X B 2 C 3 A 3 X B 3 and C 4 A 4 X B 4 . It should be understood that a vector unit having four parallel execution units is illustrative only and that vector units having fewer or more parallel execution units are within the scope of the invention.

These operations are semantically legal if they can be executed in parallel. The selective tradeoff described below may identify such operations in the source code. In addition when the data operands in memory are also spaced with a uniform increment loading of the data from the memory to the registers requires less overhead. The selective tradeoff described below may also identify any data layout transformations required so that the data operands in memory are spaced evenly. The selective tradeoff may also take into account the penalty of performing such transformations. Accordingly the selective tradeoff facilitates both aspects of vector execution unit utilization parallelism and short uniform increments.

Turning now to where the flow of provided method of source code optimization is illustrated. Flow begins in block where source code is received in memory on a custom first computing apparatus . Flow continues to block where a selective tradeoff of parallelism locality vectorization and data layout transformations is created for execution of the code on the second computing apparatus . Flow then continues to block where a scheduling function and data layout transformations are produced at least one of which optimizes the selective tradeoff. Flow continues to block where the data layout transformations may be used to modify memory access patterns in the optimized program. Flow then continues to block where the scheduling function is used to assign a partial order to the statements of the source code and an optimized program is produced for execution on the second computing apparatus . In one embodiment the received program code contains at least one loop nest. As previously discussed the custom first computing apparatus contains memory a storage medium and at least one processor with a multi stage execution unit.

An exemplary provided method for source code optimization is illustrated in . In this embodiment flow begins in block where source code is received in memory on a custom first computing apparatus . Flow continues to block where the code is optimized in terms of parallelism locality vectorization and data layout transformations for execution on a second computing apparatus . In this embodiment the optimization block includes various functional blocks. Within block flow continues on two paths one starting with block and the other starting with block . In block an unassigned loop is identified. Flow then continues on three subpaths. In a first subpath flow continues to block where a first cost function is assigned in block . This first cost function is related to a difference in execution speed between parallel and sequential operations of the statements within the loop on second computing apparatus . Flow then continues to block where a decision variable is assigned to the loop under consideration this decision variable indicating whether the loop is to be executed in parallel in the optimized program. In some embodiments the cost is determined through static evaluation of a model of the execution cost of the instructions in the loop under consideration. In other embodiments the cost is determined through a dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the loop under consideration. In a further embodiment the cost is determined by an iterative refining process consisting of at least one static evaluation of a model of the execution cost and at least one dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the loop under consideration. Flow then continues to decision block where it is determined if there are additional unassigned loops.

As used herein executed together generally means fused. Specifically executed together means that loops that are consecutive in the original program become interleaved in the optimized program. In particular loops that are not executed together in the sense of loop fusion can be executed together on the same processor in the more general sense. In the second optimization subpath illustrated in flow continues from block to block where an unassigned loop pair is identified. Flow then continues to block where a second cost function is assigned for locality optimization. This second cost function is related to a difference in execution speed between operations where the loops in the pair of loops are executed together on the second computing apparatus and where the loops in the pair of loops are not executed together on the second computing apparatus. Flow then continues to block where a decision variable is assigned for locality. This second decision variable specifies if the loops in the loop pair under consideration are to be executed together in the optimized program.

In one embodiment the second cost is determined through static evaluation of a model of the execution cost of the instructions in the at least one loop pair. In another embodiment the second cost is determined through of a dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the at least one loop pair. In a further embodiment the cost is determined through an iterative refining process consisting of at least one static evaluation of a model of the execution cost and at least one dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the at least one loop pair. Flow then continues to decision block where it is determined if additional unassigned loop pairs exist. If additional unassigned loop pairs exist flow continues back to block and the process iterates until no additional unassigned loop pairs are found. When decision block determines no additional loop pairs are present flow continues to decision block .

In the third optimization subpath illustrated in flow continues from block to block where a third cost function is assigned for exploring vectorization. This third cost function is related to a difference in execution speed between operations where the operations in the loop under consideration are executed using the vector unit processor of the second computing apparatus and where those operations are not executed using the vector unit processor. Flow then continues to block where a decision variable is assigned for vectorization. This third decision variable specifies if the operations of the loop under consideration are to be executed using the vector unit processor of the second computing apparatus in the optimized program.

In one embodiment the third cost is determined through static evaluation of a model of the execution cost of the instructions in the loop under consideration. In another embodiment the third cost is determined through a dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the loop under consideration. In a further embodiment the cost is determined through an iterative refining process including at least one static evaluation of a model of the execution cost and at least one dynamic execution on the second computing apparatus as described above. Flow then continues to decision block .

If in decision block it is determined that additional unassigned loops exist flow continues back to block and the process iterates until no additional unassigned loops may be identified. Flow then continues to block explained in detail below.

In the second optimization path illustrated in flow continues from block to block where an unassigned memory reference is identified. Flow then continues to block where a fourth cost function is assigned for data layout transformations. This fourth cost function is related to a difference in execution speed between operations where the memory is accessed contiguously on the second computing apparatus and where the memory is not accessed contiguously on the second computing apparatus. The fourth cost may also include the cost related to the penalty of performing a data layout transformation on at least one memory reference. Flow then continues to block where a decision variable is assigned for data layout transformation. This fourth decision variable specifies if a memory reference under consideration is to be reordered in the optimized program.

In one embodiment the fourth cost is determined through static evaluation of a model of the execution cost of the instructions in the program. In another embodiment the fourth cost is determined through of a dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the program. In a further embodiment the cost is determined through an iterative refining process consisting of at least one static evaluation of a model of the execution cost and at least one dynamic execution on the second computing apparatus of at least a set of instructions representative of the code in the program to be optimized. Flow then continues to decision block where it is determined if additional unassigned memory references exist. If additional unassigned memory references exist flow continues back to block and the process iterates until no additional unassigned memory references are found. When decision block determines that no additional memory references are present flow continues to block .

In block a selective tradeoff is created for parallelism locality vectorization and data layout transformations during the execution on second computing apparatus . Flow then continues to block where a scheduling function is produced that optimizes the selective tradeoff. Flow then continues to block where optimized code is produced.

The flow of a further provided embodiment of a method for source code optimization is illustrated in . In this embodiment flow begins in block where source code is received in memory on a custom first computing apparatus . Flow continues to block where a selective tradeoff in terms of parallelism locality vectorization and data layout transformations is created for execution of optimized code on a second computing apparatus . Flow then continues to block where a scheduling function and data layout transformations are produced that optimize the tradeoff. In this embodiment the block includes various functional blocks. Within block flow continues to block where the conditions for semantic correctness of the program are determined. Flow then continues to block where a search space is derived that meet the conditions for semantic correctness. In one embodiment the search space characterizes all parallelism and locality opportunities that meet the conditions of semantic correctness. Flow then continues to block where the selective tradeoff is optimized. Flow then continues to block where the scheduling function is derived from the optimized tradeoff. Flow also continues to block where at least one data layout transformation is derived. Flow then continues to block where optimized code is produced.

The flow of a further provided embodiment of a method for source code optimization is illustrated in . In this embodiment flow begins in block where source code of the program to be optimized is received in memory on a custom first computing apparatus . Flow continues to block conditions for semantic correctness of the program are determined. In block a single multidimensional convex space of all legal schedule sis derived. This can be achieved by eliminating those schedules that violate any conditions determined in the block .

Flow continues to block where a schedule dimension to be explored k is initialized to zero. In block a selective tradeoff in terms of parallelism locality vectorization and data layout transformations is created for execution of optimized code on a second computing apparatus . That tradeoff is optimized using a mathematical solver e.g. an integer linear programming solver in block . Flow then continues to block where an element from the search space is selected the selected element being the solution of the optimization in block .

Flow then continues to a decision block and if at least one program statement having an unscheduled dimension is determined to exists flow continues to block . Otherwise flow continues along two paths to blocks as described below. In block schedules of the schedule dimensions that have been explored already are preserved for each program statement. Flow continues to block where the single multidimensional convex space is updated with orthogonality constraints. These constraints also called linear independent constraints may be derived in this block. The schedule dimension is incremented by one in block and flow continues to block so as to allow exploration of the next schedule dimensions.

If the decision block determines that there is no program statement with at least one unscheduled dimension the flow continues to block where a scheduling function optimizing the tradeoff is produced. In addition in block at least one data layout transformation optimizing the tradeoff is also produced. Flow then continues to block where the scheduling function produced in block is used to assign at least a partial order to the statements of the source code. The data layout transformations produced in block are used to change the order of memory locations read and written from a memory on the second computing apparatus and an optimized program is produced.

Thus it is seen that methods and an apparatus for optimizing source code on a custom first computing apparatus for execution on a second computing apparatus are provided. One skilled in the art will appreciate that the present invention can be practiced by other than the above described embodiments which are presented in this description for purposes of illustration and not of limitation. The specification and drawings are not intended to limit the exclusionary scope of this patent document. It is noted that various equivalents for the particular embodiments discussed in this description may practice the invention as well. That is while the present invention has been described in conjunction with specific embodiments it is evident that many alternatives modifications transformations and variations will become apparent to those of ordinary skill in the art in light of the foregoing description. Accordingly it is intended that the present invention embrace all such alternatives modifications and variations as fall within the scope of the appended claims. The fact that a product process or method exhibits differences from one or more of the above described exemplary embodiments does not mean that the product or process is outside the scope literal scope and or other legally recognized scope of the following claims.

