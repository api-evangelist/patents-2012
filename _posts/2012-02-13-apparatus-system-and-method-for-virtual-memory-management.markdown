---

title: Apparatus, system, and method for virtual memory management
abstract: An apparatus, system, and method for virtual memory management. The method includes detecting a memory access to a virtual memory address within a monitored page of data not loaded in main memory of a computing device. The method includes determining a first address for a loaded page of data in the main memory. The first address is defined in a sparse virtual address space exposed by a persistent storage device. The first address is associated in an index with a first deterministic storage location. The method includes storing the loaded page on a persistent storage device at the first deterministic storage location. The method includes moving the monitored page from a second deterministic storage location to the main memory. The second deterministic storage location is associated with a second address in the index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251087&OS=09251087&RS=09251087
owner: SanDisk Technologies, Inc.
number: 09251087
owner_city: Plano
owner_country: US
publication_date: 20120213
---
This application claims priority to U.S. Provisional Patent Application No. 61 442 118 entitled APPARATUS SYSTEM AND METHOD FOR APPLICATION DIRECT VIRTUAL MEMORY MANAGEMENT and filed on Feb. 11 2011 for David Nellans et al. which is incorporated herein by reference.

The subject matter disclosed herein relates to virtual memory management and more particularly relates to performing virtual memory management directly for an application.

In typical virtual memory management in a process called paging or swapping an operating system or other swap manager moves an application s data between main memory and persistent storage. The operating system may remove certain data pages from main memory such as those not recently accessed to make room for other data pages for access by the application. The operating system typically maintains its own tables and or indexes to determine where to store a particular data page onto persistent storage or where to find a particular data page on persistent storage when performing virtual memory swapping.

Furthermore operating systems or other swap managers typically do not differentiate between applications when performing virtual memory swapping.

A method is presented for application direct virtual memory management. In one embodiment the method includes detecting a memory access to a virtual memory address within a monitored page of data not loaded in main memory of a computing device. In one embodiment the method includes determining a first address for a loaded page of data in the main memory. The first address in certain embodiments is defined in a sparse virtual address space exposed by a persistent storage device and the first address is associated in an index with a first deterministic storage location. In one embodiment the method includes storing the loaded page on a persistent storage device at the first deterministic storage location. In one embodiment the method includes copying the monitored page from a second deterministic storage location to the main memory. The second deterministic storage location in certain embodiments is associated with a second address in the index.

The apparatus for virtual memory management is provided with a plurality of modules including a determination module a storing module and a moving module.

In certain embodiments the determination module determines a first address for a loaded page of data in Random Access Memory RAM . The first address in certain embodiments is defined in a sparse virtual address space exposed by a persistent storage device. In one embodiment the first address is associated in an index with a first deterministic storage location. In one embodiment the storing module stores the loaded page on a persistent storage device at the first deterministic storage location. In one embodiment the moving module copies a monitored page of data not loaded in RAM from a second deterministic storage location on a persistent storage device to the RAM. The second deterministic storage location in certain embodiments is associated with a second address in the index.

A system is also presented for virtual memory management. The system may be embodied by a persistent storage device in communication with a host device a device driver for the persistent storage device and a user space library. In particular in one embodiment the device driver exposes a sparse virtual address space. In one embodiment the user space library includes a detection module a determination module a storing module and a moving module.

In one embodiment the detection module detects a memory access to a virtual memory address within a monitored range of virtual memory addresses not loaded in volatile memory of a computing device. In certain embodiments the determination module determines a first address for a loaded page of data in volatile memory. The first address in certain embodiments is defined in a sparse virtual address space exposed by a persistent storage device. In one embodiment the first address is associated in an index with a first deterministic storage location. In one embodiment the storing module stores the loaded page on a persistent storage device at the first deterministic storage location. In one embodiment the moving module moves data at the monitored range of virtual memory addresses from a second deterministic storage location to volatile memory. The second deterministic storage location in certain embodiments is associated with a second address in the index.

Another method is presented for virtual memory management. In one embodiment the method includes receiving a memory request to a virtual memory address within a monitored range of virtual memory addresses having data stored on a persistent storage device. In one embodiment the method includes storing data residing in main memory pertaining to a second range of virtual memory addresses to a persistent storage device at a first deterministic storage location. The first deterministic storage location in certain embodiments is associated with a first virtual memory address in an index. In one embodiment the method includes transferring data at the monitored range of virtual memory addresses from a second deterministic storage location to a second virtual memory address in the main memory. The second deterministic storage location in certain embodiments is associated with a second virtual memory address in the index.

References throughout this specification to features advantages or similar language do not imply that all of the features and advantages may be realized in any single embodiment. Rather language referring to the features and advantages is understood to mean that a specific feature advantage or characteristic is included in at least one embodiment. Thus discussion of the features and advantages and similar language throughout this specification may but do not necessarily refer to the same embodiment.

Furthermore the described features advantages and characteristics of the embodiments may be combined in any suitable manner. One skilled in the relevant art will recognize that the embodiments may be practiced without one or more of the specific features or advantages of a particular embodiment. In other instances additional features and advantages may be recognized in certain embodiments that may not be present in all embodiments.

These features and advantages of the embodiments will become more fully apparent from the following description and appended claims or may be learned by the practice of embodiments as set forth hereinafter.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Many of the functional units described in this specification have been labeled as modules in order to more particularly emphasize their implementation independence. For example a module may be implemented as a hardware circuit comprising custom VLSI circuits or gate arrays off the shelf semiconductors such as logic chips transistors or other discrete components. A module may also be implemented in programmable hardware devices such as field programmable gate arrays programmable array logic programmable logic devices or the like.

Modules may also be implemented in software for execution by various types of processors. An identified module of computer readable program code may for instance comprise one or more physical or logical blocks of computer instructions which may for instance be organized as an object procedure or function. Nevertheless the executables of an identified module need not be physically located together but may comprise disparate instructions stored in different locations which when joined logically together comprise the module and achieve the stated purpose for the module.

Indeed a module of computer readable program code may be a single instruction or many instructions and may even be distributed over several different code segments among different programs and across several memory devices. Similarly operational data may be identified and illustrated herein within modules and may be embodied in any suitable form and organized within any suitable type of data structure. The operational data may be collected as a single data set or may be distributed over different locations including over different storage devices and may exist at least partially merely as electronic signals on a system or network. Where a module or portions of a module are implemented in software the computer readable program code may be stored and or propagated on or in one or more computer readable medium s .

The computer readable medium may be a tangible computer readable storage medium storing the computer readable program code. The computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared holographic micromechanical or semiconductor system apparatus or device or any suitable combination of the foregoing.

More specific examples of the computer readable medium may include but are not limited to a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory a portable compact disc read only memory CD ROM a digital versatile disc DVD an optical storage device a magnetic storage device a holographic storage medium a micromechanical storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain and or store computer readable program code for use by and or in connection with an instruction execution system apparatus or device.

The computer readable medium may also be a computer readable signal medium. A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electrical electro magnetic magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport computer readable program code for use by or in connection with an instruction execution system apparatus or device. Computer readable program code embodied on a computer readable signal medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable Radio Frequency RF or the like or any suitable combination of the foregoing. In one embodiment the computer readable medium may comprise a combination of one or more computer readable storage mediums and one or more computer readable signal mediums. For example computer readable program code may be both propagated as an electro magnetic signal through a fiber optic cable for execution by a processor and stored on RAM storage device for execution by the processor.

Computer readable program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The computer readable program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Reference throughout this specification to one embodiment an embodiment or similar language means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment. Thus appearances of the phrases in one embodiment in an embodiment and similar language throughout this specification may but do not necessarily all refer to the same embodiment but mean one or more but not all embodiments unless expressly specified otherwise. The terms including comprising having and variations thereof mean including but not limited to unless expressly specified otherwise. An enumerated listing of items does not imply that any or all of the items are mutually exclusive unless expressly specified otherwise. The terms a an and the also refer to one or more unless expressly specified otherwise.

Furthermore the described features structures or characteristics of the embodiments may be combined in any suitable manner. In the following description numerous specific details are provided such as examples of programming software modules user selections network transactions database queries database structures hardware modules hardware circuits hardware chips etc. to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that embodiments may be practiced without one or more of the specific details or with other methods components materials and so forth. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of an embodiment.

Aspects of the embodiments are described below with reference to schematic flowchart diagrams and or schematic block diagrams of methods apparatuses systems and computer program products according to embodiments of the invention. It will be understood that each block of the schematic flowchart diagrams and or schematic block diagrams and combinations of blocks in the schematic flowchart diagrams and or schematic block diagrams can be implemented by computer readable program code. These computer readable program code may be provided to a processor of a general purpose computer special purpose computer sequencer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the schematic flowchart diagrams and or schematic block diagrams block or blocks.

The computer readable program code may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the schematic flowchart diagrams and or schematic block diagrams block or blocks.

The computer readable program code may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the program code which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The schematic flowchart diagrams and or schematic block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of apparatuses systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the schematic flowchart diagrams and or schematic block diagrams may represent a module segment or portion of code which comprises one or more executable instructions of the program code for implementing the specified logical function s .

It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the Figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. Other steps and methods may be conceived that are equivalent in function logic or effect to one or more blocks or portions thereof of the illustrated Figures.

Although various arrow types and line types may be employed in the flowchart and or block diagrams they are understood not to limit the scope of the corresponding embodiments. Indeed some arrows or other connectors may be used to indicate only the logical flow of the depicted embodiment. For instance an arrow may indicate a waiting or monitoring period of unspecified duration between enumerated steps of the depicted embodiment. It will also be noted that each block of the block diagrams and or flowchart diagrams and combinations of blocks in the block diagrams and or flowchart diagrams can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer readable program code.

The system includes at least one solid state storage device . In another embodiment the system includes two or more solid state storage devices . Each solid state storage device may include non volatile solid state storage such as flash memory nano random access memory nano RAM or NRAM magneto resistive RAM MRAM dynamic RAM DRAM phase change RAM PRAM etc. In further embodiments the data storage device may include other types of non volatile and or volatile data storage such as dynamic RAM DRAM static RAM SRAM magnetic data storage optical data storage and or other data storage technologies.

The solid state storage device is described in more detail with respect to . The solid state storage device is depicted in a computer connected to a client through a computer network . In one embodiment the solid state storage device is internal to the computer and is connected using a system bus such as a peripheral component interconnect express PCI e bus a Serial Advanced Technology Attachment serial ATA bus or the like. In another embodiment the solid state storage device is external to the computer and is connected a universal serial bus USB connection an Institute of Electrical and Electronics Engineers IEEE 1394 bus FireWire or the like. In other embodiments the solid state storage device is connected to the computer using a peripheral component interconnect PCI express bus using external electrical or optical bus extension or bus networking solution such as Infiniband or PCI Express Advanced Switching PCIe AS or the like.

In various embodiments the solid state storage device may be in the form of a dual inline memory module DIMM a daughter card or a micro module. In another embodiment the solid state storage device is an element within a rack mounted blade. In another embodiment the solid state storage device is contained within a package that is integrated directly onto a higher level assembly e.g. mother board lap top graphics processor . In another embodiment individual components comprising the solid state storage device are integrated directly onto a higher level assembly without intermediate packaging.

The solid state storage device includes one or more solid state storage controllers each may include a write data pipeline and a read data pipeline and each includes a solid state storage which are described in more detail below with respect to .

The system includes one or more computers connected to the solid state storage device . A computer may be a host a server a storage controller of a storage area network SAN a workstation a personal computer a laptop computer a handheld computer a supercomputer a computer cluster a network switch router or appliance a database or storage appliance a data acquisition or data capture system a diagnostic system a test system a robot a portable electronic device a wireless device or the like. In another embodiment a computer may be a client and the solid state storage device operates autonomously to service data requests sent from the computer . In this embodiment the computer and solid state storage device may be connected using a computer network system bus Direct Attached Storage DAS or other communication means suitable for connection between a computer and an autonomous solid state storage device .

In one embodiment the system includes one or more clients connected to one or more computer through one or more computer networks . A client may be a host a server a storage controller of a SAN a workstation a personal computer a laptop computer a handheld computer a supercomputer a computer cluster a network switch router or appliance a database or storage appliance a data acquisition or data capture system a diagnostic system a test system a robot a portable electronic device a wireless device or the like. The computer network may include the Internet a wide area network WAN a metropolitan area network MAN a local area network LAN a token ring a wireless network a fiber channel network a SAN network attached storage NAS ESCON or the like or any combination of networks. The computer network may also include a network from the IEEE 802 family of network technologies such Ethernet token ring WiFi WiMax and the like.

In a further embodiment instead of being connected directly to the computer as DAS the data storage device may be connected to the computer over a data network. For example the data storage device may include a storage area network SAN storage device a network attached storage NAS device a network share or the like. In one embodiment the system may include a data network such as the Internet a wide area network WAN a metropolitan area network MAN a local area network LAN a token ring a wireless network a fiber channel network a SAN a NAS ESCON or the like or any combination of networks. A data network may also include a network from the IEEE 802 family of network technologies such Ethernet token ring Wi Fi Wi Max and the like. A data network may include servers switches routers cabling radios and other equipment used to facilitate networking between the computer and the data storage device .

The computer network may include servers switches routers cabling radios and other equipment used to facilitate networking computers and clients . In one embodiment the system includes multiple computers that communicate as peers over a computer network . In another embodiment the system includes multiple solid state storage devices that communicate as peers over a computer network . One of skill in the art will recognize other computer networks comprising one or more computer networks and related equipment with single or redundant connection between one or more clients or other computer with one or more solid state storage devices or one or more solid state storage devices connected to one or more computers . In one embodiment the system includes two or more solid state storage devices connected through the computer network to a client without a computer .

In one embodiment the data storage device has a block device interface that support block device commands. For example the first data storage device may support the ATA interface standard the ATA Packet Interface ATAPI standard the small computer system interface SCSI standard and or the Fibre Channel standard which are maintained by the InterNational Committee for Information Technology Standards INCITS .

In one embodiment at least one solid state controller is field programmable gate array FPGA and controller functions are programmed into the FPGA. In a particular embodiment the FPGA is a Xilinx FPGA. In another embodiment the solid state storage controller comprises components specifically designed as a solid state storage controller such as an application specific integrated circuit ASIC or custom logic solution. Each solid state storage controller typically includes a write data pipeline and a read data pipeline which are describe further in relation to . In another embodiment at least one solid state storage controller is made up of a combination FPGA ASIC and custom logic components.

The solid state storage media is an array of non volatile solid state storage elements arranged in banks and accessed in parallel through a bi directional storage input output I O bus . The storage I O bus in one embodiment is capable of unidirectional communication at any one time. For example when data is being written to the solid state storage media data cannot be read from the solid state storage media . In another embodiment data can flow both directions simultaneously. However bi directional as used herein with respect to a data bus refers to a data pathway that can have data flowing in only one direction at a time but when data flowing one direction on the bi directional data bus is stopped data can flow in the opposite direction on the bi directional data bus.

A solid state storage element e.g. SSS . is typically configured as a chip a package of one or more dies or a die on a circuit board. As depicted a solid state storage element e.g. operates independently or semi independently of other solid state storage elements e.g. even if these several elements are packaged together in a chip package a stack of chip packages or some other package element. As depicted a row of solid state storage elements is designated as a bank . As depicted there may be n banks and m solid state storage elements per bank in an array of n m solid state storage elements in a solid state storage media . Of course different embodiments may include different values for n and m. In one embodiment the solid state storage media includes twenty solid state storage elements per bank with eight banks . In one embodiment the solid state storage media includes twenty four solid state storage elements per bank with eight banks . In addition to the n m storage elements one or more additional columns P may also be addressed and operated in parallel with other solid state storage elements for one or more rows. The added P columns in one embodiment store parity data for the portions of an ECC chunk i.e. an ECC codeword that span m storage elements for a particular bank. In one embodiment each solid state storage element is comprised of single level cell SLC devices. In another embodiment each solid state storage element is comprised of multi level cell MLC devices.

In one embodiment solid state storage elements that share a common storage I O bus e.g. are packaged together. In one embodiment a solid state storage element may have one or more dies per chip with one or more chips stacked vertically and each die may be accessed independently. In another embodiment a solid state storage element e.g. SSS . may have one or more virtual dies per die and one or more dies per chip and one or more chips stacked vertically and each virtual die may be accessed independently. In another embodiment a solid state storage element SSS . may have one or more virtual dies per die and one or more dies per chip with some or all of the one or more dies stacked vertically and each virtual die may be accessed independently.

In one embodiment two dies are stacked vertically with four stacks per group to form eight storage elements e.g. SSS . SSS . each in a separate bank . In another embodiment 24 storage elements e.g. SSS . SSS . form a logical bank so that each of the eight logical banks has 24 storage elements e.g. SSS. SSS . . Data is sent to the solid state storage media over the storage I O bus to all storage elements of a particular group of storage elements SSS . SSS . . The storage control bus is used to select a particular bank e.g. Bank so that the data received over the storage I O bus connected to all banks is written just to the selected bank

In a one embodiment the storage I O bus is comprised of one or more independent I O buses IIOBa m comprising wherein the solid state storage elements within each column share one of the independent I O buses that accesses each solid state storage element in parallel so that all banks are accessed simultaneously. For example one channel of the storage I O bus may access a first solid state storage element of each bank simultaneously. A second channel of the storage I O bus may access a second solid state storage element of each bank simultaneously. Each row of solid state storage element is accessed simultaneously. In one embodiment where solid state storage elements are multi level physically stacked all physical levels of the solid state storage elements are accessed simultaneously. As used herein simultaneously also includes near simultaneous access where devices are accessed at slightly different intervals to avoid switching noise. Simultaneously is used in this context to be distinguished from a sequential or serial access wherein commands and or data are sent individually one after the other.

Typically banks are independently selected using the storage control bus . In one embodiment a bank is selected using a chip enable or chip select. Where both chip select and chip enable are available the storage control bus may select one level of a multi level solid state storage element . In other embodiments other commands are used by the storage control bus to individually select one level of a multi level solid state storage element . Solid state storage elements may also be selected through a combination of control and of address information transmitted on storage I O bus and the storage control bus .

In one embodiment each solid state storage element is partitioned into erase blocks and each erase block is partitioned into pages. An erase block on a solid state storage element may be called a physical erase block or PEB. A typical page is 2000 bytes 2 kB . In one example a solid state storage element e.g. SSS . includes two registers and can program two pages so that a two register solid state storage element has a capacity of 4 kB. A bank of 20 solid state storage elements would then have an 80 kB capacity of pages accessed with the same address going out the channels of the storage I O bus .

This group of pages in a bank of solid state storage elements of 80 kB may be called a logical page or virtual page. Similarly an erase block of each storage element of a bank may be grouped to form a logical erase block or a virtual erase block. In one embodiment an erase block of pages within a solid state storage element is erased when an erase command is received within a solid state storage element . Whereas the size and number of erase blocks pages planes or other logical and physical divisions within a solid state storage element are expected to change over time with advancements in technology it is to be expected that many embodiments consistent with new configurations are possible and are consistent with the general description herein.

Typically when a packet is written to a particular location within a solid state storage element wherein the packet is intended to be written to a location within a particular page which is specific to a particular physical erase block of a particular storage element of a particular bank a physical address is sent on the storage I O bus and followed by the packet. The physical address contains enough information for the solid state storage element to direct the packet to the designated location within the page. Since all storage elements in a column of storage elements e.g. SSS . SSS N. are accessed simultaneously by the appropriate bus within the storage I O bus to reach the proper page and to avoid writing the data packet to similarly addressed pages in the column of storage elements SSS . SSS N. the bank that includes the solid state storage element SSS . with the correct page where the data packet is to be written is simultaneously selected by the storage control bus .

Similarly satisfying a read command on the storage I O bus requires a simultaneous signal on the storage control bus to select a single bank and the appropriate page within that bank . In one embodiment a read command reads an entire page and because there are multiple solid state storage elements in parallel in a bank an entire logical page is read with a read command. However the read command may be broken into subcommands as will be explained below with respect to bank interleave. A logical page may also be accessed in a write operation.

An erase block erase command may be sent out to erase an erase block over the storage I O bus with a particular erase block address to erase a particular erase block. Typically an erase block erase command may be sent over the parallel paths of the storage I O bus to erase a logical erase block each with a particular erase block address to erase a particular erase block. Simultaneously a particular bank e.g. Bank is selected over the storage control bus to prevent erasure of similarly addressed erase blocks in all of the banks Banks N . Alternatively no particular bank e.g. Bank is selected over the storage control bus to enable erasure of similarly addressed erase blocks in all of the banks Banks N simultaneously. Other commands may also be sent to a particular location using a combination of the storage I O bus and the storage control bus . One of skill in the art will recognize other ways to select a particular storage location using the bi directional storage I O bus and the storage control bus .

In one embodiment packets are written sequentially to the solid state storage media . For example packets are streamed to the storage write buffers of a bank of storage elements and when the buffers are full the packets are programmed to a designated logical page. Packets then refill the storage write buffers and when full the packets are written to the next logical page. The next logical page may be in the same bank or another bank e.g. . This process continues logical page after logical page typically until a logical erase block is filled. In another embodiment the streaming may continue across logical erase block boundaries with the process continuing logical erase block after logical erase block.

In a read modify write operation data packets associated with requested data are located and read in a read operation. Data segments of the modified requested data that have been modified are not written to the location from which they are read. Instead the modified data segments are again converted to data packets and then written sequentially to the next available location in the logical page currently being written. The index entries for the respective data packets are modified to point to the packets that contain the modified data segments. The entry or entries in the index for data packets associated with the same requested data that have not been modified will include pointers to original location of the unmodified data packets. Thus if the original requested data is maintained for example to maintain a previous version of the requested data the original requested data will have pointers in the index to all data packets as originally written. The new requested data will have pointers in the index to some of the original data packets and pointers to the modified data packets in the logical page that is currently being written.

In a copy operation the index includes an entry for the original requested data mapped to a number of packets stored in the solid state storage media . When a copy is made new copy of the requested data is created and a new entry is created in the index mapping the new copy of the requested data to the original packets. The new copy of the requested data is also written to the solid state storage media with its location mapped to the new entry in the index. The new copy of the requested data packets may be used to identify the packets within the original requested data that are referenced in case changes have been made in the original requested data that have not been propagated to the copy of the requested data and the index is lost or corrupted.

Beneficially sequentially writing packets facilitates a more even use of the solid state storage media and allows the solid storage device controller to monitor storage hot spots and level usage of the various logical pages in the solid state storage media . Sequentially writing packets also facilitates a powerful efficient garbage collection system which is described in detail below. One of skill in the art will recognize other benefits of sequential storage of data packets.

In various embodiments the solid state storage device controller also includes a data bus a local bus a buffer controller buffers N a master controller a direct memory access DMA controller a memory controller a dynamic memory array a static random memory array a management controller a management bus a bridge to a system bus and miscellaneous logic which are described below. In other embodiments the system bus is coupled to one or more network interface cards NICs some of which may include remote DMA RDMA controllers one or more central processing unit CPU one or more external memory controllers and associated external memory arrays one or more storage controllers peer controllers and application specific processors which are described below. The components connected to the system bus may be located in the computer or may be other devices.

Typically the solid state storage controller s communicate data to the solid state storage media over a storage I O bus . In a typical embodiment where the solid state storage is arranged in banks and each bank includes multiple storage elements accessed in parallel the storage I O bus is an array of busses one for each column of storage elements spanning the banks . As used herein the term storage I O bus may refer to one storage I O bus or an array of data independent busses . In one embodiment each storage I O bus accessing a column of storage elements e.g. may include a logical to physical mapping for storage divisions e.g. erase blocks accessed in a column of storage elements . This mapping or bad block remapping allows a logical address mapped to a physical address of a storage division to be remapped to a different storage division if the first storage division fails partially fails is inaccessible or has some other problem.

Data may also be communicated to the solid state storage controller s from a requesting device through the system bus bridge local bus buffer s and finally over a data bus . The data bus typically is connected to one or more buffers controlled with a buffer controller . The buffer controller typically controls transfer of data from the local bus to the buffers and through the data bus to the pipeline input buffer and output buffer . The buffer controller typically controls how data arriving from a requesting device can be temporarily stored in a buffer and then transferred onto a data bus or vice versa to account for different clock domains to prevent data collisions etc. The buffer controller typically works in conjunction with the master controller to coordinate data flow. As data arrives the data will arrive on the system bus be transferred to the local bus through a bridge .

Typically the data is transferred from the local bus to one or more data buffers as directed by the master controller and the buffer controller . The data then flows out of the buffer s to the data bus through a solid state controller and on to the solid state storage media such as NAND flash or other storage media. In one embodiment data and associated out of band metadata metadata arriving with the data is communicated using one or more data channels comprising one or more solid state storage controllers 1 and associated solid state storage media 1 while at least one channel solid state storage controller solid state storage media is dedicated to in band metadata such as index information and other metadata generated internally to the solid state storage device .

The local bus is typically a bidirectional bus or set of busses that allows for communication of data and commands between devices internal to the solid state storage device controller and between devices internal to the solid state storage device and devices connected to the system bus . The bridge facilitates communication between the local bus and system bus . One of skill in the art will recognize other embodiments such as ring structures or switched star configurations and functions of buses and bridges .

The system bus is typically a bus of a computer or other device in which the solid state storage device is installed or connected. In one embodiment the system bus may be a PCI e bus a Serial Advanced Technology Attachment serial ATA bus parallel ATA or the like. In another embodiment the system bus is an external bus such as small computer system interface SCSI FireWire Fiber Channel USB PCIe AS or the like. The solid state storage device may be packaged to fit internally to a device or as an externally connected device.

The solid state storage device controller includes a master controller that controls higher level functions within the solid state storage device . The master controller in various embodiments controls data flow by interpreting object requests and other requests directs creation of indexes to map object identifiers associated with data to physical locations of associated data coordinating DMA requests etc. Many of the functions described herein are controlled wholly or in part by the master controller .

In one embodiment the master controller uses embedded controller s . In another embodiment the master controller uses local memory such as a dynamic memory array dynamic random access memory DRAM a static memory array static random access memory SRAM etc. In one embodiment the local memory is controlled using the master controller . In another embodiment the master controller accesses the local memory via a memory controller . In another embodiment the master controller runs a Linux server and may support various common server interfaces such as the World Wide Web hyper text markup language HTML etc. In another embodiment the master controller uses a nano processor. The master controller may be constructed using programmable or standard logic or any combination of controller types listed above. One skilled in the art will recognize many embodiments for the master controller .

In one embodiment where the storage device solid state storage device controller manages multiple data storage devices solid state storage media the master controller divides the work load among internal controllers such as the solid state storage controllers . For example the master controller may divide an object to be written to the data storage devices e.g. solid state storage media so that a portion of the object is stored on each of the attached data storage devices. This feature is a performance enhancement allowing quicker storage and access to an object. In one embodiment the master controller is implemented using an FPGA. In another embodiment the firmware within the master controller may be updated through the management bus the system bus over a network connected to a NIC or other device connected to the system bus .

In one embodiment the master controller which manages objects emulates block storage such that a computer or other device connected to the storage device solid state storage device views the storage device solid state storage device as a block storage device and sends data to specific physical addresses in the storage device solid state storage device . The master controller then divides up the blocks and stores the data blocks as it would objects. The master controller then maps the blocks and physical address sent with the block to the actual locations determined by the master controller . The mapping is stored in the object index. Typically for block emulation a block device application program interface API is provided in a driver in the computer client or other device wishing to use the storage device solid state storage device as a block storage device.

In another embodiment the master controller coordinates with NIC controllers and embedded RDMA controllers to deliver just in time RDMA transfers of data and command sets. NIC controller may be hidden behind a non transparent port to enable the use of custom drivers. Also a driver on a client may have access to the computer network through an I O memory driver using a standard stack API and operating in conjunction with NICs .

In one embodiment the master controller is also a redundant array of independent drive RAID controller. Where the data storage device solid state storage device is networked with one or more other data storage devices solid state storage devices the master controller may be a RAID controller for single tier RAID multi tier RAID progressive RAID etc. The master controller also allows some objects to be stored in a RAID array and other objects to be stored without RAID. In another embodiment the master controller may be a distributed RAID controller element. In another embodiment the master controller may comprise many RAID distributed RAID and other functions as described elsewhere. In one embodiment the master controller controls storage of data in a RAID like structure where parity information is stored in one or more storage elements of a logical page where the parity information protects data stored in the other storage elements of the same logical page.

In one embodiment the master controller coordinates with single or redundant network managers e.g. switches to establish routing to balance bandwidth utilization failover etc. In another embodiment the master controller coordinates with integrated application specific logic via local bus and associated driver software. In another embodiment the master controller coordinates with attached application specific processors or logic via the external system bus and associated driver software. In another embodiment the master controller coordinates with remote application specific logic via the computer network and associated driver software. In another embodiment the master controller coordinates with the local bus or external bus attached hard disk drive HDD storage controller.

In one embodiment the master controller communicates with one or more storage controllers where the storage device solid state storage device may appear as a storage device connected through a SCSI bus Internet SCSI iSCSI fiber channel etc. Meanwhile the storage device solid state storage device may autonomously manage objects and may appear as an object file system or distributed object file system. The master controller may also be accessed by peer controllers and or application specific processors .

In another embodiment the master controller coordinates with an autonomous integrated management controller to periodically validate FPGA code and or controller software validate FPGA code while running reset and or validate controller software during power on reset support external reset requests support reset requests due to watchdog timeouts and support voltage current power temperature and other environmental measurements and setting of threshold interrupts. In another embodiment the master controller manages garbage collection to free erase blocks for reuse. In another embodiment the master controller manages wear leveling. In another embodiment the master controller allows the data storage device solid state storage device to be partitioned into multiple virtual devices and allows partition based media encryption. In yet another embodiment the master controller supports a solid state storage controller with advanced multi bit ECC correction. One of skill in the art will recognize other features and functions of a master controller in a storage controller or more specifically in a solid state storage device .

In one embodiment the solid state storage device controller includes a memory controller which controls a dynamic random memory array and or a static random memory array . As stated above the memory controller may be independent or integrated with the master controller . The memory controller typically controls volatile memory of some type such as DRAM dynamic random memory array and SRAM static random memory array . In other examples the memory controller also controls other memory types such as electrically erasable programmable read only memory EEPROM etc. In other embodiments the memory controller controls two or more memory types and the memory controller may include more than one controller. Typically the memory controller controls as much SRAM as is feasible and by DRAM to supplement the SRAM .

In one embodiment the object index is stored in memory and then periodically off loaded to a channel of the solid state storage media or other non volatile memory. One of skill in the art will recognize other uses and configurations of the memory controller dynamic memory array and static memory array .

In one embodiment the solid state storage device controller includes a DMA controller that controls DMA operations between the storage device solid state storage device and one or more external memory controllers and associated external memory arrays and CPUs . Note that the external memory controllers and external memory arrays are called external because they are external to the storage device solid state storage device . In addition the DMA controller may also control RDMA operations with requesting devices through a NIC and associated RDMA controller .

In one embodiment the solid state storage device controller includes a management controller connected to a management bus . Typically the management controller manages environmental metrics and status of the storage device solid state storage device . The management controller may monitor device temperature fan speed power supply settings etc. over the management bus . The management controller may support the reading and programming of erasable programmable read only memory EEPROM for storage of FPGA code and controller software. Typically the management bus is connected to the various components within the storage device solid state storage device . The management controller may communicate alerts interrupts etc. over the local bus or may include a separate connection to a system bus or other bus. In one embodiment the management bus is an Inter Integrated Circuit I2C bus. One of skill in the art will recognize other related functions and uses of a management controller connected to components of the storage device solid state storage device by a management bus .

In one embodiment the solid state storage device controller includes miscellaneous logic that may be customized for a specific application. Typically where the solid state device controller or master controller is are configured using a FPGA or other configurable controller custom logic may be included based on a particular application customer requirement storage requirement etc.

The write data pipeline includes a packetizer that receives a data or metadata segment to be written to the solid state storage either directly or indirectly through another write data pipeline stage and creates one or more packets sized for the solid state storage . The data or metadata segment is typically part of an object but may also include an entire object. In another embodiment the data segment is part of a block of data but may also include an entire block of data. Typically a set of data such as an object is received from a computer client or other computer or device and is transmitted to the solid state storage device in data segments streamed to the solid state storage device or computer . A data segment may also be known by another name such as data parcel but as referenced herein includes all or a portion of an object or data block.

Each object is stored as one or more packets. Each object may have one or more container packets. Each packet contains a header. The header may include a header type field. Type fields may include data object attribute metadata data segment delimiters multi packet object structures object linkages and the like. The header may also include information regarding the size of the packet such as the number of bytes of data included in the packet. The length of the packet may be established by the packet type. The header may include information that establishes the relationship of the packet to the object. An example might be the use of an offset in a data packet header to identify the location of the data segment within the object. One of skill in the art will recognize other information that may be included in a header added to data by a packetizer and other information that may be added to a data packet.

Each packet includes a header and possibly data from the data or metadata segment. The header of each packet includes pertinent information to relate the packet to the object to which the packet belongs. For example the header may include an object identifier and offset that indicates the data segment object or data block from which the data packet was formed. The header may also include a logical address used by the storage bus controller to store the packet. The header may also include information regarding the size of the packet such as the number of bytes included in the packet. The header may also include a sequence number that identifies where the data segment belongs with respect to other packets within the object when reconstructing the data segment or object. The header may include a header type field. Type fields may include data object attributes metadata data segment delimiters multi packet object structures object linkages and the like. One of skill in the art will recognize other information that may be included in a header added to data or metadata by a packetizer and other information that may be added to a packet.

The write data pipeline includes an ECC generator that that generates one or more error correcting codes ECC for the one or more packets received from the packetizer . The ECC generator typically uses an error correcting algorithm to generate ECC check bits which are stored with the one or more data packets. The ECC codes generated by the ECC generator together with the one or more data packets associated with the ECC codes comprise an ECC chunk. The ECC data stored with the one or more data packets is used to detect and to correct errors introduced into the data through transmission and storage. In one embodiment packets are streamed into the ECC generator as un encoded blocks of length N. A syndrome of length S is calculated appended and output as an encoded block of length N S. The value of N and S are dependent upon the characteristics of the algorithm which is selected to achieve specific performance efficiency and robustness metrics. In one embodiment there is no fixed relationship between the ECC blocks and the packets the packet may comprise more than one ECC block the ECC block may comprise more than one packet and a first packet may end anywhere within the ECC block and a second packet may begin after the end of the first packet within the same ECC block. In one embodiment ECC algorithms are not dynamically modified. In one embodiment the ECC data stored with the data packets is robust enough to correct errors in more than two bits.

Beneficially using a robust ECC algorithm allowing more than single bit correction or even double bit correction allows the life of the solid state storage to be extended. For example if flash memory is used as the storage medium in the solid state storage the flash memory may be written approximately 100 000 times without error per erase cycle. This usage limit may be extended using a robust ECC algorithm. Having the ECC generator and corresponding ECC correction module onboard the solid state storage device the solid state storage device can internally correct errors and has a longer useful life than if a less robust ECC algorithm is used such as single bit correction. However in other embodiments the ECC generator may use a less robust algorithm and may correct single bit or double bit errors. In another embodiment the solid state storage device may comprise less reliable storage such as multi level cell MLC flash in order to increase capacity which storage may not be sufficiently reliable without more robust ECC algorithms.

In one embodiment the write pipeline includes an input buffer that receives a data segment to be written to the solid state storage and stores the incoming data segments until the next stage of the write data pipeline such as the packetizer or other stage for a more complex write data pipeline is ready to process the next data segment. The input buffer typically allows for discrepancies between the rate data segments are received and processed by the write data pipeline using an appropriately sized data buffer. The input buffer also allows the data bus to transfer data to the write data pipeline at rates greater than can be sustained by the write data pipeline in order to improve efficiency of operation of the data bus . Typically when the write data pipeline does not include an input buffer a buffering function is performed elsewhere such as in the solid state storage device but outside the write data pipeline in the computer such as within a network interface card NIC or at another device for example when using remote direct memory access RDMA .

In another embodiment the write data pipeline also includes a write synchronization buffer that buffers packets received from the ECC generator prior to writing the packets to the solid state storage . The write synch buffer is located at a boundary between a local clock domain and a solid state storage clock domain and provides buffering to account for the clock domain differences. In other embodiments synchronous solid state storage may be used and synchronization buffers may be eliminated.

In one embodiment the write data pipeline also includes a bias module that receives the one or more packets from the packetizer either directly or indirectly. The bias module biases the bits of the data packets toward a bias of storage cells of the solid state storage . As used herein a bias is a preference probability or tendency of values for bits within a set of bits to exhibit a specific data pattern. A bias may be a natural property a designed attribute or a random occurrence. Data itself may have a bias and data storage media may have a bias. A bias may be toward binary ones toward binary zeroes toward a balance of binary ones and zeroes toward a certain binary value for certain bits or the like.

For example in one embodiment end sections of data files may be padded with binary zeroes causing the data packets that store the end sections to exhibit a bias toward binary zeroes meaning that the data packets have more binary zeroes than binary ones. Other data packets may have more binary ones than zeroes or a balance of binary ones and zeroes. While data packets may each have an individual bias based on data within the packets a bias of the storage cells of the solid state storage may be based on some benefit associated with the storage of a particular binary value or pattern or some property of the storage cells. One example of a storage cell property NAND flash storage cells presently are biased to all binary one values or almost all binary one values when provided by a manufacturer. In addition performing an erase operation on the NAND flash storage cells sets the binary values in each storage cell to a binary one such that programming of the storage cells comprises changing certain storage cells to a binary zero value.

Each of the storage elements in one embodiment store binary data in a plurality of storage cells that exhibit a bias. Each storage cell stores one or more binary bits or values. Flash memory storage cells may be single level cells SLC that each store a single binary bit or multi level cells MLC that each store two or more binary bits. Examples of storage cells include transistors capacitors magnetic elements mechanical elements optical elements and the like. In flash memory each storage cell is typically a floating gate transistor. NRAM MRAM DRAM PRAM and other types of solid state storage may have other types of storage cells and may store either a single binary bit or two or more binary bits per storage cell.

In one embodiment the storage cells in the storage elements in an empty or erased state store initial binary values. The initial binary values represent a bias for the storage cells. For example the storage cells may have a physical electrical mechanical or other quality that causes them to store a certain value by default. In another embodiment the bias may be intentionally selected based on design considerations of the solid state storage on security considerations on compatibility issues or the like and may not be based on a default property of the storage cells.

For example in one embodiment the storage cells of the storage elements may each store a binary value of one upon delivery from a manufacturer and may each be erased to a value of one prior to being programmed or written to as is typical with flash memory. In another embodiment the storage cells of the storage elements may be biased toward binary zeroes toward a balance or equal amount of binary ones and zeroes toward a certain binary value for a plurality of bits or the like. The process of erasing a logical erase block in a bank of the solid state storage is described in greater detail below with regard to .

The bias module biases a packet by changing a bias of the packet to more closely match a bias of the storage cells of the solid state storage . The bias module biases the packets in a reversible manner such that the inverse bias module can convert the packets back to their original data values with their original biases. In one embodiment the packets that the bias module biases are sized for storage in a specific logical or physical storage region or division of the solid state storage such as an erase block a virtual erase block a page a virtual page an ECC chunk a division within a page or the like. In one embodiment the bias module selectively biases certain packets based on a bias of the packets and may not bias other packets. The bias module is described in greater detail below with regard to U.S. Patent Application Ser. No. 61 305 496 filed 17 Feb. 2010 which is hereby incorporated by reference.

By biasing data packets toward the bias of the storage cells the bias module increases performance and endurance of the solid state storage and the solid state storage device . For example biasing packets to more closely match the bias of the storage cells decreases write times and erase times because fewer actual storage cells must be changed to execute the operation. It also increases the writable life of the storage cells because fewer operations that are executed on a storage cell mean that the storage cell will last longer before wear begins to affect the storage cell. In certain embodiments biasing data packets may decrease power consumption or have other additional benefits. Because in one embodiment the storage cells store initial binary values that satisfy a bias just prior to being programmed or written to the closer that the data packets match the bias of the storage cells the fewer the number of storage cells that are changed to store the data packets and the more storage cells that remain in a biased state.

As depicted the bias module biases the one or more packets prior to sending the packets to the ECC generator . Depending on the method that the bias module uses to bias the packets and on other design considerations in a further embodiment the bias module may receive data subsequent to the ECC generator in the write data pipeline or be placed elsewhere in the write data pipeline . For example in certain embodiments it may be beneficial to keep ECC data separate from data that the bias module biases while in other embodiments it may be beneficial for the bias module to bias data that includes ECC data from the ECC generator .

In another embodiment the bias module may be integrated with another element of the write data pipeline such as the compression module the encryption module the ECC generator or the like. The bias module and corresponding inverse bias module transparently increase the performance of the solid state storage as the bias module biases data packets before they are written and the inverse bias module converts the biased data packets back to their original state after they are read.

In another embodiment the write data pipeline also includes an encryption module that encrypts a data or metadata segment received from the input buffer either directly or indirectly prior sending the data segment to the packetizer the data segment encrypted using an encryption key received in conjunction with the data segment. The encryption keys used by the encryption module to encrypt data may not be common to all data stored within the solid state storage device but may vary on an object basis and received in conjunction with receiving data segments as described below. For example an encryption key for a data segment to be encrypted by the encryption module may be received with the data segment or may be received as part of a command to write an object to which the data segment belongs. The solid state storage device may use and store a non secret cryptographic nonce in each object packet that is used in conjunction with the encryption key. A different nonce may be stored with every packet. Data segments may be split between multiple packets with unique nonces for the purpose of improving protection by the encryption algorithm.

The encryption key may be received from a client a computer key manager or other device that holds the encryption key to be used to encrypt the data segment. In one embodiment encryption keys are transferred to the solid state storage controller from one of a solid state storage device computer client or other external agent which has the ability to execute industry standard methods to securely transfer and protect private and public keys.

In one embodiment the encryption module encrypts a first packet with a first encryption key received in conjunction with the packet and encrypts a second packet with a second encryption key received in conjunction with the second packet. In another embodiment the encryption module encrypts a first packet with a first encryption key received in conjunction with the packet and passes a second data packet on to the next stage without encryption. Beneficially the encryption module included in the write data pipeline of the solid state storage device allows object by object or segment by segment data encryption without a single file system or other external system to keep track of the different encryption keys used to store corresponding objects or data segments. Each requesting device or related key manager independently manages encryption keys used to encrypt only the objects or data segments sent by the requesting device .

In one embodiment the encryption module may encrypt the one or more packets using an encryption key unique to the solid state storage device . The encryption module may perform this media encryption independently or in addition to the encryption described above. Typically the entire packet is encrypted including the headers. In another embodiment headers are not encrypted. The media encryption by the encryption module provides a level of security for data stored in the solid state storage . For example where data is encrypted with media encryption unique to the specific solid state storage device if the solid state storage is connected to a different solid state storage controller solid state storage device or computer the contents of the solid state storage typically could not be read without use of the same encryption key used during the write of the data to the solid state storage without significant effort.

In another embodiment the write data pipeline includes a compression module that compresses the data for metadata segment prior to sending the data segment to the packetizer . The compression module typically compresses a data or metadata segment using a compression routine known to those of skill in the art to reduce the storage size of the segment. For example if a data segment includes a string of 512 zeros the compression module may replace the 512 zeros with code or token indicating the 512 zeros where the code is much more compact than the space taken by the 512 zeros.

In one embodiment the compression module compresses a first segment with a first compression routine and passes along a second segment without compression. In another embodiment the compression module compresses a first segment with a first compression routine and compresses the second segment with a second compression routine. Having this flexibility within the solid state storage device is beneficial so that clients or other devices writing data to the solid state storage device may each specify a compression routine or so that one can specify a compression routine while another specifies no compression. Selection of compression routines may also be selected according to default settings on a per object type or object class basis. For example a first object of a specific object may be able to override default compression routine settings and a second object of the same object class and object type may use the default compression routine and a third object of the same object class and object type may use no compression.

In one embodiment the write data pipeline includes a garbage collector bypass that receives data segments from the read data pipeline as part of a data bypass in a garbage collection system. A garbage collection system typically marks packets that are no longer valid typically because the packet is marked for deletion or has been modified and the modified data is stored in a different location. At some point the garbage collection system determines that a particular section of storage may be recovered. This determination may be due to a lack of available storage capacity the percentage of data marked as invalid reaching a threshold a consolidation of valid data an error detection rate for that section of storage reaching a threshold or improving performance based on data distribution etc. Numerous factors may be considered by a garbage collection algorithm to determine when a section of storage is to be recovered.

Once a section of storage has been marked for recovery valid packets in the section typically must be relocated. The garbage collector bypass allows packets to be read into the read data pipeline and then transferred directly to the write data pipeline without being routed out of the solid state storage controller . In one embodiment the garbage collector bypass is part of an autonomous garbage collector system that operates within the solid state storage device . This allows the solid state storage device to manage data so that data is systematically spread throughout the solid state storage to improve performance data reliability and to avoid overuse and underuse of any one location or area of the solid state storage and to lengthen the useful life of the solid state storage .

The garbage collector bypass coordinates insertion of segments into the write data pipeline with other segments being written by clients or other devices. In the depicted embodiment the garbage collector bypass is before the packetizer in the write data pipeline and after the depacketizer in the read data pipeline but may also be located elsewhere in the read and write data pipelines . The garbage collector bypass may be used during a flush of the write pipeline to fill the remainder of the virtual page in order to improve the efficiency of storage within the Solid State Storage and thereby reduce the frequency of garbage collection.

In one embodiment the write data pipeline includes a write buffer that buffers data for efficient write operations. Typically the write buffer includes enough capacity for packets to fill at least one virtual page in the solid state storage . This allows a write operation to send an entire page of data to the solid state storage without interruption. By sizing the write buffer of the write data pipeline and buffers within the read data pipeline to be the same capacity or larger than a storage write buffer within the solid state storage writing and reading data is more efficient since a single write command may be crafted to send a full virtual page of data to the solid state storage instead of multiple commands.

While the write buffer is being filled the solid state storage may be used for other read operations. This is advantageous because other solid state devices with a smaller write buffer or no write buffer may tie up the solid state storage when data is written to a storage write buffer and data flowing into the storage write buffer stalls. Read operations will be blocked until the entire storage write buffer is filled and programmed. Another approach for systems without a write buffer or a small write buffer is to flush the storage write buffer that is not full in order to enable reads. Again this is inefficient because multiple write program cycles are required to fill a page.

For depicted embodiment with a write buffer sized larger than a virtual page a single write command which includes numerous subcommands can then be followed by a single program command to transfer the page of data from the storage write buffer in each solid state storage element to the designated page within each solid state storage element . This technique has the benefits of eliminating partial page programming which is known to reduce data reliability and durability and freeing up the destination bank for reads and other commands while the buffer fills.

In one embodiment the write buffer is a ping pong buffer where one side of the buffer is filled and then designated for transfer at an appropriate time while the other side of the ping pong buffer is being filled. In another embodiment the write buffer includes a first in first out FIFO register with a capacity of more than a virtual page of data segments. One of skill in the art will recognize other write buffer configurations that allow a virtual page of data to be stored prior to writing the data to the solid state storage .

In another embodiment the write buffer is sized smaller than a virtual page so that less than a page of information could be written to a storage write buffer in the solid state storage . In the embodiment to prevent a stall in the write data pipeline from holding up read operations data is queued using the garbage collection system that needs to be moved from one location to another as part of the garbage collection process. In case of a data stall in the write data pipeline the data can be fed through the garbage collector bypass to the write buffer and then on to the storage write buffer in the solid state storage to fill the pages of a virtual page prior to programming the data. In this way a data stall in the write data pipeline would not stall reading from the solid state storage device .

In another embodiment the write data pipeline includes a write program module with one or more user definable functions within the write data pipeline . The write program module allows a user to customize the write data pipeline . A user may customize the write data pipeline based on a particular data requirement or application. Where the solid state storage controller is an FPGA the user may program the write data pipeline with custom commands and functions relatively easily. A user may also use the write program module to include custom functions with an ASIC however customizing an ASIC may be more difficult than with an FPGA. The write program module may include buffers and bypass mechanisms to allow a first data segment to execute in the write program module while a second data segment may continue through the write data pipeline . In another embodiment the write program module may include a processor core that can be programmed through software.

Note that the write program module is shown between the input buffer and the compression module however the write program module could be anywhere in the write data pipeline and may be distributed among the various stages . In addition there may be multiple write program modules distributed among the various states that are programmed and operate independently. In addition the order of the stages may be altered. One of skill in the art will recognize workable alterations to the order of the stages based on particular user requirements.

The read data pipeline includes an ECC correction module that determines if a data error exists in ECC blocks a requested packet received from the solid state storage by using ECC stored with each ECC block of the requested packet. The ECC correction module then corrects any errors in the requested packet if any error exists and the errors are correctable using the ECC. For example if the ECC can detect an error in six bits but can only correct three bit errors the ECC correction module corrects ECC blocks of the requested packet with up to three bits in error. The ECC correction module corrects the bits in error by changing the bits in error to the correct one or zero state so that the requested data packet is identical to when it was written to the solid state storage and the ECC was generated for the packet.

If the ECC correction module determines that the requested packets contains more bits in error than the ECC can correct the ECC correction module cannot correct the errors in the corrupted ECC blocks of the requested packet and sends an interrupt. In one embodiment the ECC correction module sends an interrupt with a message indicating that the requested packet is in error. The message may include information that the ECC correction module cannot correct the errors or the inability of the ECC correction module to correct the errors may be implied. In another embodiment the ECC correction module sends the corrupted ECC blocks of the requested packet with the interrupt and or the message.

In one embodiment a corrupted ECC block or portion of a corrupted ECC block of the requested packet that cannot be corrected by the ECC correction module is read by the master controller corrected and returned to the ECC correction module for further processing by the read data pipeline . In one embodiment a corrupted ECC block or portion of a corrupted ECC block of the requested packet is sent to the device requesting the data. The requesting device may correct the ECC block or replace the data using another copy such as a backup or mirror copy and then may use the replacement data of the requested data packet or return it to the read data pipeline . The requesting device may use header information in the requested packet in error to identify data required to replace the corrupted requested packet or to replace the object to which the packet belongs. In another embodiment the solid state storage controller stores data using some type of RAID and is able to recover the corrupted data. In another embodiment the ECC correction module sends an interrupt and or message and the receiving device fails the read operation associated with the requested data packet. One of skill in the art will recognize other options and actions to be taken as a result of the ECC correction module determining that one or more ECC blocks of the requested packet are corrupted and that the ECC correction module cannot correct the errors.

The read data pipeline includes a depacketizer that receives ECC blocks of the requested packet from the ECC correction module directly or indirectly and checks and removes one or more packet headers. The depacketizer may validate the packet headers by checking packet identifiers data length data location etc. within the headers. In one embodiment the header includes a hash code that can be used to validate that the packet delivered to the read data pipeline is the requested packet. The depacketizer also removes the headers from the requested packet added by the packetizer . The depacketizer may directed to not operate on certain packets but pass these forward without modification. An example might be a container label that is requested during the course of a rebuild process where the header information is required by the object index reconstruction module . Further examples include the transfer of packets of various types destined for use within the solid state storage device . In another embodiment the depacketizer operation may be packet type dependent.

The read data pipeline includes an alignment module that receives data from the depacketizer and removes unwanted data. In one embodiment a read command sent to the solid state storage retrieves a packet of data. A device requesting the data may not require all data within the retrieved packet and the alignment module removes the unwanted data. If all data within a retrieved page is requested data the alignment module does not remove any data.

The alignment module re formats the data as data segments of an object in a form compatible with a device requesting the data segment prior to forwarding the data segment to the next stage. Typically as data is processed by the read data pipeline the size of data segments or packets changes at various stages. The alignment module uses received data to format the data into data segments suitable to be sent to the requesting device and joined to form a response. For example data from a portion of a first data packet may be combined with data from a portion of a second data packet. If a data segment is larger than a data requested by the requesting device the alignment module may discard the unwanted data.

In one embodiment the read data pipeline includes a read synchronization buffer that buffers one or more requested packets read from the solid state storage prior to processing by the read data pipeline . The read synchronization buffer is at the boundary between the solid state storage clock domain and the local bus clock domain and provides buffering to account for the clock domain differences.

In another embodiment the read data pipeline includes an output buffer that receives requested packets from the alignment module and stores the packets prior to transmission to the requesting device . The output buffer accounts for differences between when data segments are received from stages of the read data pipeline and when the data segments are transmitted to other parts of the solid state storage controller or to the requesting device . The output buffer also allows the data bus to receive data from the read data pipeline at rates greater than can be sustained by the read data pipeline in order to improve efficiency of operation of the data bus .

In one embodiment the read data pipeline includes an inverse bias module that receives one or more requested biased packets from the ECC correction module and converts the one or more requested packets back to their original form by reversing the biasing process of the bias module prior to sending the one or more requested packets to the depacketizer . In one embodiment the inverse bias module may use one or more indicators stored by the bias module to convert the biased packets back to their original data.

In a further embodiment the inverse bias module converts the biased packets back to their original data without using an indicator. Instead of using an indicator the inverse bias module may implement an algorithm that is the inverse operation of the bias module . This algorithm may inverse the bias for each data packet received and or a select number of data packets received. In the depicted embodiment the inverse bias module is located between the ECC correction module and the depacketizer . In a further embodiment the inverse bias module may be located elsewhere in the read data pipeline based on the location of the bias module in the write data pipeline . The inverse bias module is described in greater detail with regard to U.S. Patent Application Ser. No. 61 305 496 filed 17 Feb. 2010 which is hereby incorporated by reference.

In another embodiment the read data pipeline includes a decryption module that decrypts a data segment formatted by the depacketizer prior to sending the data segment to the output buffer . The data segment may be decrypted using an encryption key received in conjunction with the read request that initiates retrieval of the requested packet received by the read synchronization buffer . The decryption module may decrypt a first packet with an encryption key received in conjunction with the read request for the first packet and then may decrypt a second packet with a different encryption key or may pass the second packet on to the next stage of the read data pipeline without decryption. When the packet was stored with a non secret cryptographic nonce the nonce is used in conjunction with an encryption key to decrypt the data packet. The encryption key may be received from a client a computer key manager or other device that manages the encryption key to be used by the solid state storage controller .

In another embodiment the read data pipeline includes a decompression module that decompresses a data segment formatted by the depacketizer . In one embodiment the decompression module uses compression information stored in one or both of the packet header and the container label to select a complementary routine to that used to compress the data by the compression module . In another embodiment the decompression routine used by the decompression module is dictated by the device requesting the data segment being decompressed. In another embodiment the decompression module selects a decompression routine according to default settings on a per object type or object class basis. A first packet of a first object may be able to override a default decompression routine and a second packet of a second object of the same object class and object type may use the default decompression routine and a third packet of a third object of the same object class and object type may use no decompression.

In another embodiment the read data pipeline includes a read program module that includes one or more user definable functions within the read data pipeline . The read program module has similar characteristics to the write program module and allows a user to provide custom functions to the read data pipeline . The read program module may be located as shown in may be located in another position within the read data pipeline or may include multiple parts in multiple locations within the read data pipeline . Additionally there may be multiple read program modules within multiple locations within the read data pipeline that operate independently. One of skill in the art will recognize other forms of a read program module within a read data pipeline . As with the write data pipeline the stages of the read data pipeline may be rearranged and one of skill in the art will recognize other orders of stages within the read data pipeline .

The solid state storage controller includes control and status registers and corresponding control queues . The control and status registers and control queues facilitate control and sequencing commands and subcommands associated with data processed in the write and read data pipelines . For example a data segment in the packetizer may have one or more corresponding control commands or instructions in a control queue associated with the ECC generator . As the data segment is packetized some of the instructions or commands may be executed within the packetizer . Other commands or instructions may be passed to the next control queue through the control and status registers as the newly formed data packet created from the data segment is passed to the next stage.

Commands or instructions may be simultaneously loaded into the control queues for a packet being forwarded to the write data pipeline with each pipeline stage pulling the appropriate command or instruction as the respective packet is executed by that stage. Similarly commands or instructions may be simultaneously loaded into the control queues for a packet being requested from the read data pipeline with each pipeline stage pulling the appropriate command or instruction as the respective packet is executed by that stage. One of skill in the art will recognize other features and functions of control and status registers and control queues .

The solid state storage controller and or solid state storage device may also include a bank interleave controller a synchronization buffer a storage bus controller and a multiplexer MUX which are described in relation to .

The bank interleave controller directs one or more commands to two or more queues in the bank interleave controller and coordinates among the banks of the solid state storage execution of the commands stored in the queues such that a command of a first type executes on one bank while a command of a second type executes on a second bank . The one or more commands are separated by command type into the queues. Each bank of the solid state storage has a corresponding set of queues within the bank interleave controller and each set of queues includes a queue for each command type.

The bank interleave controller coordinates among the banks of the solid state storage execution of the commands stored in the queues. For example a command of a first type executes on one bank while a command of a second type executes on a second bank . Typically the command types and queue types include read and write commands and queues but may also include other commands and queues that are storage media specific. For example in the embodiment depicted in erase and management queues are included and would be appropriate for flash memory NRAM MRAM DRAM PRAM etc.

For other types of solid state storage other types of commands and corresponding queues may be included without straying from the scope of the invention. The flexible nature of an FPGA solid state storage controller allows flexibility in storage media. If flash memory were changed to another solid state storage type the bank interleave controller storage bus controller and MUX could be altered to accommodate the media type without significantly affecting the data pipelines and other solid state storage controller functions.

In the embodiment depicted in the bank interleave controller includes for each bank a read queue for reading data from the solid state storage a write queue for write commands to the solid state storage an erase queue for erasing an erase block in the solid state storage an a management queue for management commands. The bank interleave controller also includes corresponding read write erase and management agents . In another embodiment the control and status registers and control queues or similar components queue commands for data sent to the banks of the solid state storage without a bank interleave controller .

The agents in one embodiment direct commands of the appropriate type destined for a particular bank to the correct queue for the bank . For example the read agent may receive a read command for bank and directs the read command to the bank read queue . The write agent may receive a write command to write data to a location in bank of the solid state storage and will then send the write command to the bank write queue . Similarly the erase agent may receive an erase command to erase an erase block in bank and will then pass the erase command to the bank erase queue . The management agent typically receives management commands status requests and the like such as a reset command or a request to read a configuration register of a bank such as bank . The management agent sends the management command to the bank management queue

The agents typically also monitor status of the queues and send status interrupt or other messages when the queues are full nearly full non functional etc. In one embodiment the agents receive commands and generate corresponding sub commands. In one embodiment the agents receive commands through the control status registers and generate corresponding sub commands which are forwarded to the queues . One of skill in the art will recognize other functions of the agents .

The queues typically receive commands and store the commands until required to be sent to the solid state storage banks . In a typical embodiment the queues are first in first out FIFO registers or a similar component that operates as a FIFO. In another embodiment the queues store commands in an order that matches data order of importance or other criteria.

The bank controllers typically receive commands from the queues and generate appropriate subcommands. For example the bank write queue may receive a command to write a page of data packets to bank . The bank controller may receive the write command at an appropriate time and may generate one or more write subcommands for each data packet stored in the write buffer to be written to the page in bank . For example bank controller may generate commands to validate the status of bank and the solid state storage array select the appropriate location for writing one or more data packets clear the input buffers within the solid state storage memory array transfer the one or more data packets to the input buffers program the input buffers into the selected location verify that the data was correctly programmed and if program failures occur do one or more of interrupting the master controller retrying the write to the same physical location and retrying the write to a different physical location. Additionally in conjunction with example write command the storage bus controller will cause the one or more commands to multiplied to each of the each of the storage I O buses with the logical address of the command mapped to a first physical addresses for storage I O bus and mapped to a second physical address for storage I O bus and so forth as further described below.

Typically bus arbiter selects from among the bank controllers and pulls subcommands from output queues within the bank controllers and forwards these to the Storage Bus Controller in a sequence that optimizes the performance of the banks . In another embodiment the bus arbiter may respond to a high level interrupt and modify the normal selection criteria. In another embodiment the master controller can control the bus arbiter through the control and status registers . One of skill in the art will recognize other means by which the bus arbiter may control and interleave the sequence of commands from the bank controllers to the solid state storage .

The bus arbiter typically coordinates selection of appropriate commands and corresponding data when required for the command type from the bank controllers and sends the commands and data to the storage bus controller . The bus arbiter typically also sends commands to the storage control bus to select the appropriate bank . For the case of flash memory or other solid state storage with an asynchronous bi directional serial storage I O bus only one command control information or set of data can be transmitted at a time. For example when write commands or data are being transmitted to the solid state storage on the storage I O bus read commands data being read erase commands management commands or other status commands cannot be transmitted on the storage I O bus . For example when data is being read from the storage I O bus data cannot be written to the solid state storage .

For example during a write operation on bank the bus arbiter selects the bank controller which may have a write command or a series of write sub commands on the top of its queue which cause the storage bus controller to execute the following sequence. The bus arbiter forwards the write command to the storage bus controller which sets up a write command by selecting bank through the storage control bus sending a command to clear the input buffers of the solid state storage elements associated with the bank and sending a command to validate the status of the solid state storage elements associated with the bank . The storage bus controller then transmits a write subcommand on the storage I O bus which contains the physical addresses including the address of the logical erase block for each individual physical erase solid stage storage element as mapped from the logical erase block address. The storage bus controller then muxes the write buffer through the write sync buffer to the storage I O bus through the MUX and streams write data to the appropriate page. When the page is full then storage bus controller causes the solid state storage elements associated with the bank to program the input buffer to the memory cells within the solid state storage elements . Finally the storage bus controller validates the status to ensure that page was correctly programmed.

A read operation is similar to the write example above. During a read operation typically the bus arbiter or other component of the bank interleave controller receives data and corresponding status information and sends the data to the read data pipeline while sending the status information on to the control and status registers . Typically a read data command forwarded from bus arbiter to the storage bus controller will cause the MUX to gate the read data on storage I O bus to the read data pipeline and send status information to the appropriate control and status registers through the status MUX .

The bus arbiter coordinates the various command types and data access modes so that only an appropriate command type or corresponding data is on the bus at any given time. If the bus arbiter has selected a write command and write subcommands and corresponding data are being written to the solid state storage the bus arbiter will not allow other command types on the storage I O bus . Beneficially the bus arbiter uses timing information such as predicted command execution times along with status information received concerning bank status to coordinate execution of the various commands on the bus with the goal of minimizing or eliminating idle time of the busses.

The master controller through the bus arbiter typically uses expected completion times of the commands stored in the queues along with status information so that when the subcommands associated with a command are executing on one bank other subcommands of other commands are executing on other banks . When one command is fully executed on a bank the bus arbiter directs another command to the bank . The bus arbiter may also coordinate commands stored in the queues with other commands that are not stored in the queues .

For example an erase command may be sent out to erase a group of erase blocks within the solid state storage . An erase command may take 10 to 1000 times more time to execute than a write or a read command or 10 to 100 times more time to execute than a program command. For N banks the bank interleave controller may split the erase command into N commands each to erase a virtual erase block of a bank . While Bank is executing an erase command the bus arbiter may select other commands for execution on the other banks . The bus arbiter may also work with other components such as the storage bus controller the master controller etc. to coordinate command execution among the buses. Coordinating execution of commands using the bus arbiter bank controllers queues and agents of the bank interleave controller can dramatically increase performance over other solid state storage systems without a bank interleave function.

In one embodiment the solid state controller includes one bank interleave controller that serves all of the storage elements of the solid state storage . In another embodiment the solid state controller includes a bank interleave controller for each set of storage elements . For example one bank interleave controller serves one set of storage elements SSS . SSS N. . . . a second bank interleave controller serves a second set of storage elements SSS . SSS N. . . . etc.

The solid state storage controller includes a synchronization buffer that buffers commands and status messages sent and received from the solid state storage . The synchronization buffer is located at the boundary between the solid state storage clock domain and the local bus clock domain and provides buffering to account for the clock domain differences. The synchronization buffer write synchronization buffer and read synchronization buffer may be independent or may act together to buffer data commands status messages etc. In one embodiment the synchronization buffer is located where there are the fewest number of signals crossing the clock domains. One skilled in the art will recognize that synchronization between clock domains may be arbitrarily moved to other locations within the solid state storage device in order to optimize some aspect of design implementation.

The solid state storage controller includes a storage bus controller that interprets and translates commands for data sent to and read from the solid state storage and status messages received from the solid state storage based on the type of solid state storage . For example the storage bus controller may have different timing requirements for different types of storage storage with different performance characteristics storage from different manufacturers etc. The storage bus controller also sends control commands to the storage control bus .

In one embodiment the solid state storage controller includes a MUX that comprises an array of multiplexers where each multiplexer is dedicated to a set of solid state storage elements either a row or a column in the solid state storage array . For example multiplexer is associated with solid state storage elements . MUX routes the data from the write data pipeline and commands from the storage bus controller to the solid state storage via the storage I O bus and routes data and status messages from the solid state storage via the storage I O bus to the read data pipeline and the control and status registers through the storage bus controller synchronization buffer and bank interleave controller .

In one embodiment the solid state storage controller includes a MUX for each column of solid state storage elements e.g. SSS . SSS . SSS N. . A MUX combines data from the write data pipeline and commands sent to the solid state storage via the storage I O bus and separates data to be processed by the read data pipeline from commands. Packets stored in the write buffer are directed on busses out of the write buffer through a write synchronization buffer for each column of solid state storage elements SSS .to SSS N.x to the MUX for each column of solid state storage elements SSS .to SSS N.x . The commands and read data are received by the MUXes from the storage I O bus . The MUXes also direct status messages to the storage bus controller .

The storage bus controller includes a mapping module . The mapping module maps a logical address of an erase block to one or more physical addresses of an erase block. For example a solid state storage with an array of twenty storage elements e.g. SSS . to SSS .M per bank may have a logical address for a particular erase block mapped to twenty physical addresses of the erase block one physical address per storage element. Because the storage elements are accessed in parallel erase blocks at the same position in each storage element in a column of storage elements will share a physical address. To select one erase block e.g. in storage element SSS . instead of all erase blocks in the column e.g. in storage elements SSS . . . . . N. one bank in this case Bank is selected.

This logical to physical mapping for erase blocks is beneficial because if one erase block becomes damaged or inaccessible the mapping can be changed to map to another erase block. This mitigates the loss of losing an entire virtual erase block when one element s erase block is faulty. The remapping module changes a mapping of a logical address of an erase block to one or more physical addresses of a virtual erase block spread over the array of storage elements . For example virtual erase block may be mapped to erase block of storage element SSS . to erase block of storage element SSS . . . . and to storage element .M virtual erase block may be mapped to erase block of storage element SSS . to erase block of storage element SSS . . . . and to storage element .M etc. Alternatively virtual erase block may be mapped to one erase block from each storage element in an array such that virtual erase block includes erase block of storage element SSS . to erase block of storage element SSS . to storage element .M and erase block of storage element SSS . to erase block of storage element SSS . . . . and to storage element .M for each storage element in the array up to erase block of storage element N.M

If erase block of a storage element SSS. is damaged experiencing errors due to wear etc. or cannot be used for some reason the remapping module could change the logical to physical mapping for the logical address that pointed to erase block of virtual erase block . If a spare erase block call it erase block of storage element SSS . is available and currently not mapped the remapping module could change the mapping of virtual erase block to point to erase block of storage element SSS . while continuing to point to erase block of storage element SSS . erase block of storage element SSS . not shown . . . and to storage element .M . The mapping module or remapping module could map erase blocks in a prescribed order virtual erase block to erase block of the storage elements virtual erase block to erase block of the storage elements etc. or may map erase blocks of the storage elements in another order based on some other criteria.

In one embodiment the erase blocks could be grouped by access time. Grouping by access time meaning time to execute a command such as programming writing data into pages of specific erase blocks can level command completion so that a command executed across the erase blocks of a virtual erase block is not limited by the slowest erase block. In other embodiments the erase blocks may be grouped by wear level health etc. One of skill in the art will recognize other factors to consider when mapping or remapping erase blocks.

In one embodiment the storage bus controller includes a status capture module that receives status messages from the solid state storage and sends the status messages to the status MUX . In another embodiment when the solid state storage is flash memory the storage bus controller includes a NAND bus controller . The NAND bus controller directs commands from the read and write data pipelines to the correct location in the solid state storage coordinates timing of command execution based on characteristics of the flash memory etc. If the solid state storage is another solid state storage type the NAND bus controller would be replaced by a bus controller specific to the storage type. One of skill in the art will recognize other functions of a NAND bus controller .

The storage controller manages a solid state storage array . The storage controller may include various hardware and software controllers drivers and software such as the depicted hardware controllers .

In one embodiment the depicted hardware controllers may be substantially similar to and include similar functionality as the solid state controllers and accompanying controllers and modules depicted in and or the bank interleave controller and storage bus controller depicted in . Furthermore the ECC correction module may be substantially similar and include similar functionality to the ECC correction module and or the ECC generator depicted in . In addition the read data pipeline and the write data pipeline may be substantially similar to the read data pipeline and the write data pipeline depicted in and . The solid state storage array may include an array of solid state storage banks similar to the solid state storage media and corresponding solid state storage banks depicted in .

In one embodiment the user application is a software application operating on or in conjunction with the storage client . The storage client manages files and data and utilizes the functions and features of the storage controller and associated solid state storage array . Representative examples of storage clients include but are not limited to a server a file system an operating system a database management system DBMS a volume manager and the like. The storage client is in communication with the storage controller . In one embodiment the storage client communicates through an Input Output I O interface represented by a block I O emulation layer .

Certain conventional block storage devices divide the storage media into volumes or partitions. Each volume or partition may include a plurality of sectors. One or more sectors are organized into a logical block. In certain storage systems such as those interfacing with the Windows operating systems the logical blocks are referred to as clusters. In other storage systems such as those interfacing with UNIX Linux or similar operating systems the logical blocks are referred to simply as blocks. A logical block or cluster represents a smallest physical amount of storage space on the storage media that is managed by the storage manager. A block storage device may associate n logical blocks available for user data storage across the storage media with a logical block address numbered from 0 to n. In certain block storage devices the logical block addresses may range from 0 to n per volume or partition. In conventional block storage devices a logical block address maps directly to a particular logical block. In conventional block storage devices each logical block maps to a particular set of physical sectors on the storage media.

However certain storage devices do not directly or necessarily associate logical block addresses with particular physical blocks. These storage devices may emulate a conventional block storage interface to maintain compatibility with block storage clients .

When the storage client communicates through the block I O emulation layer the storage device appears to the storage client as a conventional block storage device. In one embodiment the storage controller provides a block I O emulation layer which serves as a block device interface or API. In this embodiment the storage client communicates with the storage device through this block device interface. In one embodiment the block I O emulation layer receives commands and logical block addresses from the storage client in accordance with this block device interface. As a result the block I O emulation layer provides the storage device compatibility with block storage clients .

In one embodiment a storage client communicates with the storage controller through a direct interface layer . In this embodiment the storage device directly exchanges information specific to non volatile storage devices. A storage device using direct interface may store data on the solid state storage media as blocks sectors pages logical blocks logical pages erase blocks logical erase blocks ECC chunks logical ECC chunks or in any other format or structure advantageous to the technical characteristics of the solid state storage media . The storage controller receives a logical address and a command from the storage client and performs the corresponding operation in relation to the non volatile solid state storage media . The storage controller may support a block I O emulation layer a direct interface or both a block I O emulation layer and a direct interface .

As described above certain storage devices while appearing to a storage client to be a block storage device do not directly associate particular logical block addresses with particular physical blocks also referred to in the art as sectors. Such storage devices may use a logical to physical translation layer . The logical to physical translation layer provides a level of abstraction between the logical block addresses used by the storage client and the physical block addresses at which the storage controller stores the data. The logical to physical translation layer maps logical block addresses to physical block addresses of data stored on solid state storage media . This mapping allows data to be referenced in a logical address space using logical identifiers such as a logical block address. A logical identifier does not indicate the physical location of data on the solid state storage media but is an abstract reference to the data.

The storage controller manages the physical block addresses in the physical address space. In one example contiguous logical block addresses may in fact be stored in non contiguous physical block addresses as the logical to physical translation layer determines the location on the solid state storage media to perform data operations.

Furthermore in one embodiment the logical address space is substantially larger than the physical address space. This thinly provisioned or sparse address space embodiment allows the number of logical identifiers for data references to greatly exceed the number of possible physical addresses. Specifically the logical address space may be sparse and as such may comprise a logical capacity that exceeds the physical storage capacity of the solid state storage array . Accordingly the logical address space may be defined independent of the solid state storage array the logical address space may present a larger address space than the physical storage capacity of the solid state storage array may present different storage location partitions and or block sizes than provided by the solid state storage array and so on.

The storage controller may support a sparse address space by writing data using a log based append only cyclic writing structure. Specifically the storage controller in one embodiment writes data of a write request to physical storage media of the solid state storage array at one or more logical addresses of the physical storage media corresponding to the addresses of the write request as mapped by the logical to physical translation layer . In a further embodiment the storage controller writes the data of the write request to the physical storage media by appending the data to a sequential log based writing structure of the physical storage media of the solid state storage array at an append point. The storage controller in one embodiment returns one or more physical addresses corresponding to the append point and the logical to physical translation layer maps the one or more logical addresses to the one or more physical addresses corresponding to the append point.

As the storage controller clears trims replaces expires and or evicts data from the physical addresses and associated physical storage media the solid state storage media in the depicted embodiment are freed to store data for other logical addresses. In one embodiment the storage controller stores data at the physical addresses using a log based append only writing structure such that data overwritten by a subsequent write request invalidates other data in the log. Consequently a garbage collection process recovers the physical capacity of the invalid data in the log. One embodiment of the log based append only writing structure is a logically ring like data structure as new data is appended to the log based writing structure previously used physical capacity is reused in a circular theoretically infinite manner.

In one embodiment the logical to physical translation layer includes a map or index a forward map that maps logical block addresses to physical block addresses. Often logical addresses used to identify stored data represent a very small number of logical addresses that are possible within a name space or range of possible logical addresses. Searching this sparsely populated space may be cumbersome. For this reason the forward map is typically a data structure that facilitates quickly traversing the forward map to find a physical address based on a logical address. For example the forward map may include a B tree a content addressable memory CAM a binary tree a hash table or other data structure that facilitates quickly searching a sparsely populated space or range. By using a forward map that quickly searches a sparsely populated logical namespace or address space the logical to physical translation layer provides an efficient way to determine one or more physical addresses from a logical address. In certain embodiments the logical to physical translation layer is a tree with nodes that represent logical block addresses and comprise corresponding physical block addresses.

In one embodiment the forward map binds in a logical to physical map bound LBAs to physical storage locations. The storage controller may determine if the logical space has sufficient unallocated logical space using the logical to physical map. The logical to physical map may be used to track allocation of bound LBAs unbound LBAs allocated LBAs unallocated LBAs allocated LBA capacity unallocated LBA capacity and the like. In one embodiment the forward map binds LBAs to corresponding physical storage location addresses in multiple maps.

The forward map the sparse logical address space and the log based writing are described in further detail in U.S. patent application Ser. No. 12 986 117 entitled Apparatus System and Method for a Virtual Storage Layer filed 6 Jan. 2011 for David Flynn et al. and U.S. Provisional Patent Application Ser. No. 61 373 271 entitled Apparatus System and Method for Caching Data filed 12 Aug. 2010 for David Flynn which are hereby incorporated by reference.

As stated above in conventional block storage devices a logical block address maps directly to a particular physical block. When a storage client communicating with the conventional block storage device deletes data for a particular logical block address the storage client may note that the particular logical block address is deleted and can re use the physical block associated with that deleted logical block address without the need to perform any other action.

Conversely when a storage client communicating with a storage controller with a logical to physical translation layer a storage controller that does not map a logical block address directly to a particular physical block deletes a logical block address the corresponding physical block address remains allocated because the storage client does not communicate the change in used blocks to the storage controller . The storage client may not be configured to communicate changes in used blocks also referred to herein as data block usage information . Because the storage client uses the block I O emulation layer the storage client may erroneously believe that the storage controller is a conventional storage controller that would not utilize the data block usage information. Or in certain embodiments other software layers between the storage client and the storage controller may fail to pass on data block usage information.

Consequently the storage controller preserves the relationship between the logical block address and a physical address and the data on the storage device corresponding to the physical block. As the number of allocated blocks increases the performance of the storage controller may suffer depending on the configuration of the storage controller .

Specifically in certain embodiments the storage controller is configured to store data sequentially using an append only writing process and use a storage space recovery process that re uses non volatile storage media storing deallocated unused logical blocks. Specifically as described above the storage controller may sequentially write data on the solid state storage media in a log structured format and within one or more physical structures of the storage elements the data is sequentially stored on the solid state storage media .

As a result of storing data sequentially and using an append only writing process the storage controller achieves a high write throughput and a high number of I O operations per second IOPS . The storage controller includes a storage space recovery or garbage collection process that re uses data storage cells to provide sufficient storage capacity. The storage space recovery process reuses storage cells for logical blocks marked as deallocated invalid unused or otherwise designated as available for storage space recovery in the logical physical translation layer .

As described above the storage space recovery process determines that a particular section of storage may be recovered. Once a section of storage has been marked for recovery the storage controller may relocate valid blocks in the section. The storage space recovery process when relocating valid blocks copies the packets and writes them to another location so that the particular section of storage may be reused as available storage space typically after an erase operation on the particular section. The storage controller may then use the available storage space to continue sequentially writing data in an append only fashion. Consequently the storage controller expends resources and overhead in preserving data in valid blocks. Therefore physical blocks corresponding to deleted logical blocks may be unnecessarily preserved by the storage controller which expends unnecessary resources in relocating the physical blocks during storage space recovery.

Some storage devices are configured to receive messages or commands notifying the storage device of these unused logical blocks so that the storage device may deallocate the corresponding physical blocks. As used herein to deallocate a physical block includes marking the physical block as invalid unused or otherwise designating the physical block as available for storage space recovery its contents on storage media no longer needing to be preserved by the storage controller . Data block usage information in reference to the storage controller may also refer to information maintained by the storage controller regarding which physical blocks are allocated and or deallocated unallocated and changes in the allocation of physical blocks and or logical to physical block mapping information. Data block usage information in reference to the storage controller may also refer to information maintained by the storage controller regarding which blocks are in use and which blocks are not in use by a storage client. Use of a block may include storing of data in the block on behalf of the client reserving the block for use by a client and the like.

While physical blocks may be deallocated in certain embodiments the storage controller may not immediately erase the data on the storage media. An erase operation may be performed later in time. In certain embodiments the data in a deallocated physical block may be marked as unavailable by the storage controller such that subsequent requests for data in the physical block return a null result or an empty set of data.

One example of a command or message for such deallocation is the Trim function of the Data Set Management command under the T13 technical committee command set specification maintained by INCITS. A storage device upon receiving a Trim command may deallocate physical blocks for logical blocks whose data is no longer needed by the storage client . A storage controller that deallocates physical blocks may achieve better performance and increased storage space especially storage controllers that write data using certain processes and or use a similar data storage recovery process as that described above.

Consequently the performance of the storage controller is enhanced as physical blocks are deallocated when they are no longer needed such as through the Trim command or other similar deallocation commands issued to the storage controller .

The processor executes computer readable programs stored on the memory module as is well known to those skilled in the art. The processor may include a cache to reduce the average time to access the memory module . In one embodiment the processor comprises a multiprocessor having one or more cores independent processing units . The processor may include a memory management unit MMU that translates virtual memory addresses from a client such as an operating system and or application to physical memory addresses that in conventional computing devices may correspond to physical locations on the storage media of the memory module . For example in conventional computing devices an operating system may send a memory read request memory write request or other type of system memory access to the processor that includes virtual memory addresses for a page stored in the memory module . The MMU may translate the virtual memory addresses to physical memory addresses corresponding to locations of page data on the memory module . As used herein a system memory access is a command and or request to read data write date and or the like to from main memory. A system memory access may originate from an application attempting to read or write data to a page in main memory.

The processor may communicate with the IO module . The IO module may support and communicate with the PCIe module the storage device and other components as is known in the art. Computer readable programs may be stored in non volatile storage on the storage device . The storage device may include a hard disk drive an optical storage device a holographic storage device a micromechanical storage device a solid state storage device described above in relation to and the like. A solid state storage device such as that described above may also communicate with the IO module through the PCIe module using a PCIe bus.

In conventional computing devices the memory module or main memory includes volatile memory such as dynamic random access memory DRAM and static random access memory SRAM . Specifically the memory module may include one or more storage media such as one or more dual in line memory modules DIMM s of volatile memory. Each DIMM may comprise a series of volatile memory integrated circuits.

As described above the processor may be a multiprocessor having one or more cores. As described above the processor may include an MMU that translates virtual memory addresses from a client to physical memory addresses that in conventional computing devices may correspond to physical locations on one or more of the media of main memory. The physical memory addresses from the MMU may be communicated to the main memory by the memory controller which is described below.

The memory controller communicates with is coupled to and or integrated with the processor . The memory controller manages data communication between the processor and the main memory . In one embodiment the memory controller communicates system memory accesses to the main memory . System memory accesses may include but are not limited to data read requests data write requests and the like. In addition a data operation command in one embodiment contains a physical memory address from the MMU. For example the memory controller may send a 64 bit memory address in a system memory access to request a word of data from the main memory .

The MMU may translate virtual memory addresses to physical memory addresses through the TLB . The TLB may improve address translation speed by caching logical to physical mappings. In one embodiment the TLB stores entries for data pages e.g. 4 KB pages . A data page is a unit of main memory used for virtual memory addressing. A page may comprise the smallest unit of data for memory allocation performed by the operating system for swapping application data between main memory and persistent storage e.g. secondary storage such as a hard disk drive solid state storage drive pcie storage device and or the like . If a virtual memory address requested by the MMU is present in the TLB called a TLB hit the TLB entry can be used to access memory. If the virtual memory address requested by the MMU is not in the TLB called a TLB miss the virtual memory address and its associated physical memory address is referenced in the page table retrieved and copied to the TLB . If the page table entry for the virtual memory address is either not located in the page table or indicated in the page table as having been swapped to persistent storage e.g. the page is indicated as active but not present the MMU may trigger a page fault. 

Referring also to an operating system may include a virtual memory manager and a swap manager configured to manage memory of the computer system. Specifically the virtual memory manager may reference entries in the page table for virtual memory addresses and the swap manager may perform swapping also referred to as paging to store and retrieve data from persistent storage such as a hard disk solid state storage device discussed above and the like for use in main memory . Specifically the swap manager may store pages of data from main memory to persistent storage to free up more room on main memory .

When the processor attempts to access swapped pages using a system memory access as described above pages not in main memory this results in a page fault such as for example in response to a request from an application a page fault is triggered and the swap manager locates the pages in persistent storage . To locate the data pages in persistent storage the swap manager performs a lookup of the page in a swap table or other index that maps a page identifier to a physical location e.g. the sector on the persistent storage where the page is located. After locating the page the swap manager loads the page into main memory and updates the page table entry for the page with the physical memory address for the page on main memory for the virtual memory manager to reference. The operating system may then return control to the program to retry the memory access. Therefore pages represented by addresses in a virtual address space may be loaded in main memory or may have been swapped and stored on persistent storage .

An operating system may trigger a segmentation fault for a program attempting to access data pages in main memory using virtual memory addresses that are outside of the virtual memory address range or that are part of a protected set of virtual memory addresses. A conventional application may crash and or abandon a memory access request in response to receiving a segmentation fault.

In addition to or instead of the virtual memory swapping performed by the swap manager the direct virtual memory apparatus applications and or storage controller may implement application direct virtual memory management. Specifically the storage controller in one embodiment may expose at least a portion of its logical to physical translation layer as a sparse virtual address space to support virtual memory swapping. This swapping may be independent of virtual memory swapping performed by the swap manager and may be mutually exclusive to memory swapping performed by the swap manager . Specifically the direct virtual memory apparatus in certain embodiments performs virtual memory swapping in addition to or in place of the virtual memory swapping of the swap manager . Furthermore the direct virtual memory apparatus may perform application specific virtual memory swapping. This application direct virtual memory management may provide applications with greater control in virtual memory management allowing for application specific memory management memory management optimized for a specific storage media application type and the like.

Furthermore the direct virtual memory apparatus may swap data pages from main memory in and out of the persistent storage device referencing the data pages defined within the exposed sparse virtual address space of the logical to physical translation layer . The storage controller provides and manages an index as part of the logical to physical translation layer which maps logical virtual addresses to physical storage locations on persistent storage . Therefore the direct virtual memory apparatus does not have to determine a physical location on the persistent storage device to store or retrieve data pages as this overhead is already performed by the storage controller . The direct virtual memory apparatus may determine a swap address or a virtual address in the exposed sparse virtual address space for a particular data page and initiate a read or write operation for a data page using the swap address without having to perform the physical address lookup itself. In contrast as described above the swap manager locates physical locations for data pages on the persistent storage device by performing a lookup operation in a swap table. By using an exposed sparse virtual address space the direct virtual memory apparatus saves overhead and time by not performing the physical location lookup. For example in one embodiment as described below the exposed sparse virtual address space may directly map swap addresses to the virtual memory addresses of pages for applications. In one embodiment also described below the direct virtual memory apparatus maps virtual memory addresses to swap addresses using a hash function.

The direct virtual memory apparatus may comprise an object application process thread service user space library or the like executing in user space . In addition all or a portion of the direct virtual memory apparatus may reside in one or more of the applications in kernel space in the operating system and or the storage controller .

In one embodiment the logical to physical translation layer provides a direct interface to a virtual address space that is accessible by objects and or applications in user space . As stated above the virtual address space may be substantially larger than the physical address space in a thinly provisioned or sparse address space embodiment allowing the number of logical identifiers for data references to greatly exceed the number of possible physical addresses. Therefore in one embodiment the exposed sparse virtual address space may be a sparse address space supported with log based append only writing and garbage collection as described above.

Specifically the storage controller in one embodiment maintains an index of associations between logical memory addresses of data and physical locations comprising the data on the media of the persistent storage device . In one embodiment the storage controller maps logical memory addresses to actual physical addresses and or locations on the memory media using the index. In a further embodiment the storage controller uses a single mapping structure as the index to map logical memory addresses to physical addresses specifying actual locations on the memory media.

The index in various embodiments may include a B tree B tree B tree a CAM a binary tree a hash table an index an array a linked list a look up table or another mapping data structure. Use of a B tree as the index in certain embodiments is particularly advantageous where the logical address space presented is a very large address space 2 64 addressable blocks which may or may not be sparsely populated . Because B trees maintain an ordered structure searching such a large space remains very fast. For example in one embodiment the index includes a B tree with multiple nodes and each node may store several entries. In the example embodiment each entry may map a variable sized range or ranges of logical memory addresses to a location on the memory media. Furthermore the number of nodes in the B tree may vary as the B tree grows wider and or deeper.

In one embodiment the index only includes a node or entry for logical memory addresses that are associated with currently stored data in the memory media. In this embodiment membership in the index represents membership in presence on the memory media. The storage controller in one embodiment adds entries nodes and the like to the index as data is stored on the memory media and removes entries nodes and the like from the index in response to data being cleared trimmed or otherwise deallocated from physical media. Similarly membership in the index may represent valid allocated memory units such as data pages on the memory media. The storage controller in one embodiment adds entries nodes and the like to the index as data is stored on the memory media and removes entries nodes and the like from the index in response to data being invalidated cleared trimmed or otherwise removed from the memory media.

In addition the storage controller may be configured initially or on demand to present a different size virtual address space as determined by a configuration setting a particular host architecture a particular operating system or the like to correspond with various sized virtual address spaces for various applications . For example on one host computer with a particular operating system that provides each application with a 32 bit virtual address space the storage controller may present the exposed sparse virtual address space as a 32 bit logical address space. On a different host computer and or operating system the storage controller may present a 48 bit 60 bit or 64 bit virtual address space to correspond with a 48 bit 60 bit or 64 bit virtual address space that the host computer operating system provides for each application 

In the depicted embodiment the direct virtual memory apparatus communicates directly with logical to physical translation layer through the direct interface to access the exposed sparse virtual address space. Furthermore the direct interface may provide an Application Programming Interface API and or other protocols to access and to perform memory operations in the logical to physical translation layer .

As described above the page table includes entries for data pages. Each entry may include a page identifier e.g. a virtual memory address in the virtual address space where the page begins with pages having a fixed size and a status for the page indicating whether the page is loaded in main memory or is swapped out to the persistent storage device . In one embodiment the page table may not have an entry for a particular data page because the page does not exist and any calls to such page result in a segfault is protected or is swapped out of main memory. The swap table includes entries for swapped data pages with a page identifier such as the virtual memory address and a location identifier indicating a physical location on the persistent storage device where a swapped page resides. As described above if the page table entry for a virtual memory address is indicated in the page table as having been swapped to the persistent storage device the MMU may trigger a page fault triggering the swap manager to look up the page in the swap table locate the physical location on memory media of the persistent storage device and move the page back into main memory.

In one embodiment the direct virtual memory apparatus handles virtual memory swapping for a particular range of virtual memory addresses while the swap manager handles virtual memory swapping for other virtual memory addresses of the application . In one embodiment the direct virtual memory apparatus performs virtual memory swapping for one application exclusive of the swap manager meaning that the direct virtual memory apparatus handles all swapping for one or more applications . In the same embodiment the direct virtual memory apparatus performs virtual memory swapping for application while the swap manager performs virtual memory swapping for other applications not illustrated . In other words the direct virtual memory apparatus depending on the embodiment may handle all of virtual memory swapping for one or more applications and share the main memory with the swap manager that is managing swapping for other applications.

Alternatively or in addition the direct virtual memory apparatus depending on the embodiment may handle virtual memory swapping for a single applications for a specific range of virtual memory addresses but share swapping with the swap manager for other virtual memory addresses of the application . In this manner the persistent storage device can be used as memory swap capacity to augment the virtual memory management performed by the swap manager . In one embodiment the direct virtual memory apparatus handles swapping transparent to the application meaning the application is not aware and or does not request the direct virtual memory apparatus to handle swapping. For example once installed the direct virtual memory apparatus may cooperate with the swap manager to swap memory pages for a predetermined set of memory pages i.e. the upper address range pages or lower address range pages 

In one embodiment the application explicitly requests pages to be handled by the direct virtual memory apparatus . Specifically in an embodiment in which the direct virtual memory apparatus performs virtual memory swapping in addition to that of the swap manager an application may explicitly designate pages for which swapping is to be handled by the direct virtual memory apparatus using an extension of an existing API for a memory allocation command malloc . In one embodiment for data pages allocated using this extended malloc command the direct virtual memory apparatus allocates pages from main memory for the application and sets a protection bit in the page table upon allocation to indicate to the swap manager that the pages are not to be swapped. The direct virtual memory apparatus then performs swapping for these pages. In such an embodiment the direct virtual memory apparatus uses a segfault as a signal to return swapped pages to main memory . In other words the direct virtual memory apparatus traps a segment fault segfault and swaps a referenced page in from the persistent storage device . The direct virtual memory apparatus configures the swap manager and virtual memory manager to signal a segfault when a system access is attempted on the referenced page.

Specifically as pages managed by the direct virtual memory apparatus are moved from main memory during swapping the direct virtual memory apparatus marks the pages as unavailable or protected e.g. protected by issuing an mprotect for a memory range that includes the pages . This protection mechanism signals to the virtual memory manager and swap manage that the protected page is not swappable and any system access calls to addresses in the protected page are to be directed to the direct virtual memory apparatus . The address range for these pages may stay protected and marked as unavailable for as long as the corresponding pages are swapped out onto the persistent storage device .

As a result when an application attempts to use a system memory access to access an unavailable page e.g. an address in the range protected by the mprotect the operating system causes a segfault in response to the attempt. As described below the direct virtual memory apparatus may use this segfault as a cue or trigger to swap pages. In one embodiment an application may allocate memory with the extended malloc command recognizing that the direct virtual memory apparatus will handle memory references within that allocated memory and swap pages in and out as needed in response to the segfaults such reference will create. After the direct virtual memory apparatus moves a page back into main memory from the persistent storage device the direct virtual memory apparatus in one embodiment updates the page table to indicate that the page is present in main memory .

In an embodiment in which swapping performed by the direct virtual memory apparatus is handled invisibly to the application the direct virtual memory apparatus may not require pages to have been allocated by special memory allocation commands before handling swapping for those pages. The direct virtual memory apparatus may select a certain address range e.g. the virtual memory addresses associated with the first n pages or last n pages of the virtual memory space or the like of pages for an application and protect them in the virtual address space by setting a bit in the page table as described above without awareness of the application .

The detection module in one embodiment monitors for system memory accesses involving pages monitored pages for which the apparatus handles swapping. The detection module may monitor pages for each executing application such as for example if the apparatus is handling all virtual memory swapping for the computer system. In other embodiments the detection module may monitor a subset of pages such as pages for a specific application or a subset of pages for a specific application . System memory accesses in one embodiment serve as an indicator that a particular monitored page is to be moved to main memory from the persistent storage device .

Specifically the detection module in one embodiment detects a system memory access to a virtual memory address within a monitored page of data not loaded in main memory of a computing system. As described above the system memory access may include a memory read or a memory write command to one or more pages. Furthermore the system memory access may also be a system memory call e.g. the extended malloc command from an application allocated the monitored page. The detection module may intercept a system memory call determine whether the system memory call includes any virtual memory addresses corresponding to a monitored page and signal the determination module in response to determining that the system memory call includes at least one of such virtual memory addresses.

In one embodiment a system memory access may trigger a segmentation fault if the system memory access attempts to access a protected page such as a page allocated using the extended malloc command. As described above when the apparatus handles virtual memory swapping in addition to virtual memory swapping performed by the swap manager a segmentation fault triggered by an application attempting to access a swapped page that has been protected signals the apparatus to move the page back into main memory .

When the apparatus exclusively handles virtual memory swapping the system memory access may be a page fault. In one embodiment the monitored page is allocated to an application executing at run time. The monitored page may be allocated using standard allocation commands. In one embodiment the monitored page has been allocated using the extended malloc command as described above thereby indicating that the monitored page is to be monitored by the detection module . In one embodiment each page of main memory is allocated to one or more applications e.g. main memory is full when the detection module detects the system memory access. Therefore in one embodiment one or more data pages are swapped out of main memory as described below to make room for the monitored page to be swapped in.

As stated above in certain embodiments the apparatus performs virtual memory swapping in addition to that performed by the swap manager using a segfault as a signal to swap pages out of and back into main memory . Therefore in certain embodiments the detection module comprises a segfault handler as described below. In one embodiment the detection module comprises a user space shared library that monitors detects and or intercepts system memory calls from applications in user space.

The determination module in one embodiment determines obtains and or computes addresses for pages to be stored from main memory onto the persistent storage device . In one embodiment before the monitored page may be loaded into main memory one or more loaded pages pages currently loaded in main memory are swapped to the persistent storage device by the apparatus . The loaded page like the monitored page above may also be allocated to an application either the same application or a different application executing at runtime. The addresses determined by the determination module referred to herein as swap addresses may be virtual addresses used by the index of the storage driver to reference pages swapped to the persistent storage device by the apparatus .

Specifically in one embodiment the determination module determines a first swap address for a loaded page of data in main memory . The swap address may be defined in a sparse virtual address space exposed by the persistent storage device .

The persistent storage device may comprise but is not limited to memory modules memory media storage media one or more storage devices a solid state storage device and or the like. The persistent storage device may be embodied as a storage device within the computer system or as a storage device in another computer system in communication with the computer system. Advantageously the persistent storage device has an I O latency between the latency of RAM and the latency of conventional disk drive storage devices.

In certain embodiments the swap address is associated in an index with a storage location on the media of the persistent storage device . As described above the index is managed by the persistent storage device e.g. a device driver managing the persistent storage device .

In certain embodiments swap addresses comprise logical block addresses LBA s used by the index . The determination module initiates mapping of the swap addresses to physical locations for the pages on media of the persistent storage by using the exposed sparse virtual address space of the logical to physical translation layer . Each swap address implemented as an LBA may be a node in the index associated with stored data in the persistent storage device . Specifically in one embodiment a swap address is a node in the index structure e.g. a tree as described above that represents a logical block address and includes a corresponding physical block address.

In certain embodiments physical locations on memory media of the persistent storage device that are associated with swap addresses are deterministic storage locations. In one embodiment a deterministic storage location comprises a physical storage location on memory media that is determined and or managed by the persistent storage device . A deterministic storage location may comprise a next available storage location such as a next free page in an ordered free pages pool. A deterministic storage location may also comprise an append point of a sequential log based writing structure persisted on the persistent storage device . The deterministic storage location may be defined before data is stored on the media or after data is stored on the media. For example in one embodiment the storage driver determines a physical location on the media and then stores the data. In another embodiment the data is sent for storage on the media and a write agent as described above in relation to reports the physical location to the storage driver .

The sequential log based writing structure may store the loaded page together with the swap address. The index associates the swap address of the sparse virtual address space with physical media storage locations. A deterministic storage location may be related to the swap address in a direct mapped relationship e.g. the swap address is an LBA pointing to only one physical block or the swap address may comprise an LBA that may be mapped to any physical block on the storage media . In one embodiment the deterministic storage location is related to the swap address in a many to many relationship and a current address of the deterministic storage location is maintained by the index of the persistent storage device .

The determination module may determine a swap address with a direct mapping function a hash function and or the like as described below. In one embodiment the determination module determines a swap address for a page each time a page is swapped whether or not the page has been swapped before and already has an existing swap address in the index . Because the exposed sparse virtual address space is a sparse address space in which the number of logical identifiers available greatly exceed the number of possible physical addresses the exposed sparse address space may accommodate numerous swap addresses hashing into the swap address space and the like with minimal or no risk of duplicate addresses. For example the determination module may directly map a virtual memory address for a page using the virtual memory address plus an offset e.g. if the offset is 4 virtual memory address 5 maps to LBA 9 virtual memory address 6 maps to LBA 10 and the like .

In one embodiment the determination module derives a swap address for a page from a unique application identifier e.g. a process ID for the application associated with the page. In one embodiment the determination module derives the swap address for a page using the unique application identifier and the virtual memory address of the page. For example the determination module may input the unique application identifier and the virtual memory address into a hash function to obtain the swap address as described below.

In one embodiment the determination module determines a swap address for a page based on data content of the page. As described below the determination module and or the hash module may determine the swap address using a signature representing data of the page. Therefore two identical pages would have the same signature. In one embodiment if the hash function can reasonably avoid hash collisions for pages that are not identical the determination module may determine two pages with the same determined swap address are identical. As described below the storing module may use a form of deduplication and instead of storing a duplicate page onto the persistent storage device when two pages share a common signature increment a reference count corresponding to the earlier stored page.

The storing module in one embodiment copies data pages from main memory to the persistent storage device . In one embodiment the storing module stores the loaded page on a persistent storage device at the first deterministic storage location. If the loaded page has already been stored on the persistent storage device the loaded page may already have a swap address represented in the index e.g. a node exists in the index for the loaded page . In certain embodiments the storing module associates the swap address for the loaded page with the swap address of the loaded page found in the index . For example the storing module may create a node in the index for the first swap address and map a deterministic storage location on the media of the persistent storage device to the node. The storing module may store the loaded page at this deterministic storage location.

In one embodiment a deterministic storage location at which a page is stored varies each time the page is swapped to the persistent storage device . For example the moving module described below may move the loaded page back into main memory after the loaded page has been stored on the persistent storage device . On a subsequent swap e.g. when the loaded page is moved back to the persistent storage device after having already been stored there the storing module may store the loaded page at a deterministic location different than the first deterministic location and update the index to associate this deterministic location with the same original swap address. For example on the subsequent swap the swap address remains the same e.g. the same LBA value but the actual location where the page is stored may be at a different append point.

In the embodiment described above in which a swap address is based on content of a page if an identical page to the loaded page is already stored on the persistent storage device to avoid storing a duplicate page the storing module may not store the loaded page. In the embodiment the storing module skips storing the loaded page to the persistent storage device in response to the determination module determining that a swap address for a first page matches a swap address associated with an existing page stored on the persistent storage device e.g. the signature for the first page and the existing page match . Accordingly the storage module increments a reference count associated with the existing swap address the moving module described below may decrement the reference count for a page moved back to main memory .

The storing module copies pages from this allocated portion of main memory to the persistent storage device directly through the direct interface to the logical to physical translation layer . In one embodiment the storing module may store pages through the block I O emulation interface . In other words the storing module may issue standard block I O commands to store pages of data on the persistent storage device . The storing module may store page data according to memory operation protocols. The storing module may store to the persistent storage device directly through the direct interface to the logical to physical translation layer . In one embodiment the storing module may store pages through the block I O emulation interface .

The hash module may translate a requested load or store of one or more addressable units into a read or write of the page that holds the requested addressable unit s . Therefore the storing module in one embodiment instead of storing data on the persistent storage device by sector stores a page of data corresponding to a particular unique address from the hash module as described below.

In one embodiment the storing module may store pages from main memory to the persistent storage device in a single location. In certain embodiments the storing module may replicate the pages on one or more storage devices. For example the storing module may automatically store one or more copies of an application s memory across multiple storage devices e.g. drives chips and the like . In one embodiment the storing module supports copy on write and automatically creates one or more duplicate copies of the pages without awareness of a higher level application . In one embodiment the storing module receives an acknowledgment from each storage device to which it copies the pages before acknowledging a successful swap operation. In some embodiments the storing module acknowledging a successful storing operation after receiving an acknowledgment from a specific storage device i.e. where a primary copy of the pages reside .

The multiple storage devices receiving one or more duplicate copies may include remote storage devices storage devices attached to different I O controllers and the like. In one embodiment the storing module includes user configurable swap settings to determine an amount of redundancy to identify which devices to copy swapped memory and the like. In some embodiments the storing module utilizes PCIe multicast and or accelerator operations for replicating writes across multiple storage devices.

The moving module in one embodiment moves the monitored page from a deterministic storage location associated with the monitored page to the main memory . The second deterministic storage location may be associated with a second swap address in the index . As with the first deterministic storage location the second deterministic storage location may be located on and managed by the persistent storage device and may comprise a physical address of an append point as described above. The moving module may determine the swap address for the monitored page similar to the determination module determining the swap address for the loaded page e.g. using a hash function with process id for the application allocated the monitored page and the virtual memory address using a direct mapping and the like . Specifically the swap address is computed in one embodiment by passing the process id of the application associated with the monitored page and the virtual address of the request through the hashing function. The swap address then serves as the key to the index to locate the monitored page on the persistent storage device .

In one embodiment the moving module moves and or copies one or more pages from the persistent storage device to main memory and returns from the segfault. In one embodiment the moving module may use sequential prefetching when copying pages to main memory . Specifically the moving module may copy additional pages adjacent to pages that the application is attempting to access such that these additional pages are available in main memory should the application request them. As described above multiple copies of the swapped pages may exist on multiple storage devices local and or remote. In one embodiment reads of the swapped page data are served from physically closest copies. In one embodiment the moving module may use prefetching in cooperation with the optimization module to implement intelligent prefetching as directed by information hints directives from the application . In one embodiment when a page has an associated reference count the moving module may decrement the reference count for a page moved back to main memory .

The apparatus in the depicted embodiment includes the detection module the determination module the storing module and the moving module described above with regard to and the detection module includes a segfault handler and the apparatus further includes a designation module an update module a hash module and an optimization module . Similar to the apparatus of all or a portion of the modules may reside in one or more of the applications in the operating system and or the storage controller .

The segfault handler in one embodiment intercepts a segfault from the operating system to the application and uses the segfault as a signal to fetch pages from the persistent storage device that have been swapped from main memory. In certain embodiments the operating system may use the swap manager to provide virtual memory support for other applications while a segfault for one or more applications may be routed to the segfault handler. In certain embodiments all or a portion of the segfault handler resides in a shared resource thread service application library in user space accessible by applications resides in one or more applications and or resides in the operating system . For example in one embodiment one or more applications may have their own segfault handler which forward segfault calls to the segfault handler. Consequently the segfault handler may use an existing mechanism the segfault process as a signal to swap pages back into main memory .

The designation module in one embodiment designates a set of virtual memory address typically contiguous ranges of addresses that corresponds to one or more monitored pages. Specifically the designation module issues a command to protect the virtual memory addresses for pages swapped to the persistent storage device . As stated above the designation module may issue an mprotect command for pages that are not loaded in main memory . The designation module sets aside a certain number of virtual memory pages for use and management by the direct virtual memory apparatus .

In one embodiment the designation module after pages have been copied to main memory may indicate that the page is available for access by the operating system e.g. by unprotecting the main memory range for those pages using an unprotect memory command .

The update module in one embodiment updates a page table entry for a monitored page to indicate the monitored page is loaded in main memory . In one embodiment the update module after a page e.g. the monitored page has been moved back into main memory updates the page table entry for the page such that the application upon returning from the segfault obtains access to data of the page. Specifically after an application returns from a segfault the operating system retries the data access operation that previously failed. Consequently the operating system tries to access memory within the page range again and finding the range unprotected the page table entry updated and the page stored in main memory successfully access the requested data of the page.

The hash module in one embodiment generates an address for use in storing each page in the sparse virtual address space presented by the logical to physical translation layer . In one embodiment the hash module executes a hash function to uniquely map a swapped page into the exposed sparse virtual address space . The output of the hash function comprises a the swap address for the swapped page. From the perspective of the storage controller the unique identifier for each swapped page is treated as a logical block address in certain embodiments. Specifically for pages to be stored retrieved using application direct virtual memory management the hash module may hash a unique application identifier e.g. a process id for application combined with a virtual memory address for a page in the application s virtual address space using a hash function to obtain the unique identifier for the pages in the sparse virtual address space . In one embodiment the unique application identifier is a process ID assigned by the operating system for an application . The hash module in certain embodiments is part of the determination module in communication with the determination module and or works in conjunction with the determination module to determine a swap address.

A hash function is a deterministic function that converts an initial value a key from a domain into a value in a range or hash value . In certain embodiments of the present invention the range may be significantly smaller than the domain. In other embodiments the cardinality of the range matches the cardinality of the domain. A hash collision occurs when two distinct initial values provided as input to a hash function result in an identical hash value result. A hash function that maps each key to a distinct hash value result is called a perfect hash function. However perfect hash functions generally require that key values in the domain be of a fixed cardinality and are predetermined.

Nevertheless because the storage controller presents a very large and sparse address space the hash module may utilize a hash function and a range of such a large size up to 64 bits or more to obtain near perfect hashing. Specifically the chances of a collision are based in part on a ratio of a domain size to a range size. As the ratio of the domain size to the range size increases the chance of a collision increases. In one embodiment the size of the address space the range is sufficiently large in comparison with a potential number of swapped pages the domain to substantially avoid collisions as the larger the range of possible hash values the less likely collisions will occur. In one embodiment the hash module uses an address space of a particular size to approximate an optimal domain size to range size ratio. For example in one embodiment the address space comprises a 32 bit address space providing 4 294 967 296 possible distinct hash values. In one embodiment the address space is a 48 bit address space. In yet another embodiment the address space comprises a 64 bit address space.

In one embodiment a user may configure the size of the address space based on an estimated number of pages that the hash module may store in the address space to ensure an optimal domain to range ratio. In one embodiment the hash module direct interface logical to physical translation layer and or storage controller may deterministically modify the address space size increasing or decreasing the address space or deterministically adjusting the inputs to the hash function as needed to prevent collisions. The hash module may rely on the sparse logical address space such that in most cases each application identifier and virtual memory address results in a unique hash value.

As stated above often hash functions have a non zero probability of a collision. One of skill in the art will recognize how to trade simplicity and speed of the hash function used with strength of a hash function which is typically a measure of how many collisions might be expected for the hash function. In addition to an optimum domain size to range size ratio the hash module may reduce the chances of a collision with an adequate hash function. In one embodiment the hash module uses a Secure Hash Algorithm 1 SHA 1 hash function a Message Digest Algorithm 5 MD5 hash function or the like. In one embodiment the chance of a collision is small enough that if a collision were to occur the hash module may return an error and or determine that it cannot swap the particular pages instead of managing the collision e.g. with a linked list at the particular hash value for the collision .

In one embodiment if the hash module detects a collision the hash module signals the storing module to swap a different page out of main memory . In one embodiment if the hash module detects a collision the hash module hashes a third value along with the unique application identifier and swap page identifier to obtain a different hash value and avoid the collision. This third value is a deterministically reproducible value such as for example a sequence number of a logical erase block for the LEB that stores the swap page. The sequence number may be used to maintain the log based append only writing structure for managing storing of data and retrieving data from the persistent storage device .

Furthermore the risk of collision exists when the hash module generates a new hash value for a page that has not yet been swapped stored on the storage device as updates to previously stored pages will use previously determined hash values as unique swap page identifiers. In addition the hash module may detect a collision by referencing the logical to physical translation layer . Specifically LBAs representative of a hash key value that are already assigned in the index already have a node in the map or tree. The storage controller may quickly traverse the index to determine the existence of a particular node representing an LBA. In one embodiment the index only includes a node or entry for logical addresses that are associated with currently stored data on the physical storage medium of the persistent storage device . In this embodiment membership in the forward map may represent valid allocated blocks on the persistent storage media. The storage controller in one embodiment adds entries nodes and the like to the index as data is stored on the persistent media and removes entries nodes and the like from the index in response to data being invalidated cleared trimmed or otherwise removed from the persistent media. Therefore existence of a node or entry in the index represents an LBA that is taken exists or is allocated meaning that a collision has occurred.

The hash module determines addresses for lookups reads and writes according to the hash function to obtain consistent addresses. In certain embodiments the hash module determines swap addresses every time a page swap is performed once for the page being swapped out and once to determine the swap address in the exposed sparse virtual address space for the page being swapped in. In one embodiment the hash module determines a swap address for a page even if the page has been swapped before and a swap address exists in the index . Furthermore by hashing into an exposed sparse virtual address space of the pre existing logical to physical translation layer the hash module eliminates the need for duplicate logical to physical translation layers costly swap table lookups or the like. Moreover a hash function saves time and resources over a swap table lookup because a hash function is a constant time equation not a table lookup or a tree traversal which may involve a variable time lookup depending on where the entry is located in the table or tree.

In one embodiment as described above a swap address is based on content of a page. Specifically the swap address computed by the hash function may be based on a signature of the page. In one embodiment the hash function computes a signature for a portion of a page e.g. the 100 000 K or last 100 000 K . In one embodiment if the page portions yield a preliminary match the hash module computes and compares signatures for entire pages. Therefore if the hash function arrives at a swap address for a first page that is the same as the swap address for a second page already stored the first and second pages are identical. The storing module may skip storing the first page. The storing module and or hash module may increment a reference count associated with the second swap address.

The optimization module optimizes virtual memory swapping for a specific application a group of applications a storage medium and or a computing system as a whole. In one embodiment the optimization module optimizes virtual memory for a particular application . For example for a database application the optimization module may maintain hot data such as the database application s log in main memory but direct the storing module to swap out colder data such as the actual database data.

In one embodiment the optimization module receives hints from applications on virtual memory usage. The hint may comprise a suggestion or instruction to move one or more particular pages from main memory to the persistent storage device to move one or more particular pages from the persistent storage device to main memory to pin one or more particular pages in main memory and or to unpin one or more particular pages in main memory . For example the optimization module may provide an API to receive hints as to specific pages to swap and or to leave in main memory . In some embodiments the optimization module determines virtual memory usage for an application based on an application s history. The optimization module may also optimize virtual memory usage for a certain type of storage medium such as flash. In one embodiment the hint may comprise a notification without a requirement for action by the optimization module e.g. the optimization module may comply with the hint or not . In another embodiment the hint comprises a directive that requires the optimization module to carry out the instruction given by the hint.

The optimization module may support sequential pre fetching and or intelligent preloading e.g. each time page x is loaded page s is loaded so load page s in connection with loading page x and other autonomic learned behavior. The optimization module may also consider performance factors in swapping how much main memory to offload latency considerations and the like. In one embodiment the optimization module may swap pages in main memory that aren t active so that data that is more active is placed in main memory . For example an application may periodically determine whether certain pages in memory have been used and send hints to the optimization module to swap pages for these less active pages.

Next the storing module stores the loaded page on a persistent storage device at a deterministic storage location. The moving module determines the swap address for the monitored page and moves the monitored page from a second deterministic storage location identified by finding the swap address in the index the node in the index maps the swap address to the second deterministic storage location to the main memory . The second deterministic storage location in one embodiment is associated with a second swap address in the index . The moving module may determine the swap address for the monitored page similar to the determination module determining the swap address for the loaded page e.g. using a hash function with the virtual memory address using a direct mapping and the like . Specifically the second swap address is computed in one embodiment by passing the process id of the application associated with the monitored page and the virtual address of the request through the hashing function. The second swap address then serves as the key to the index to locate the monitored page on the persistent storage device . The method returns and the detection module continues to monitor for a system memory access as described above.

Next the storing module stores the loaded page on a persistent storage device at the first deterministic storage location. The moving module moves the monitored page from a second deterministic storage location to the main memory . The second deterministic storage location in one embodiment is associated with a second swap address in the index . The update module updates a page table entry for the monitored page to indicate the monitored page is loaded in main memory . The method returns and the detection module continues to monitor for a system memory access as described above.

The mapping structure in the depicted embodiment includes a plurality of nodes. Each node in the depicted embodiment is capable of storing two entries. In other embodiments each node may be capable of storing a greater number of entries the number of entries at each level may change as the mapping structure grows or shrinks through use or the like.

Each entry in the depicted embodiment maps a variable length range of LBAs of the solid state storage device to a physical location in the storage media for the solid state storage device . Further while variable length ranges of LBAs in the depicted embodiment are represented by a starting address and an ending address in other embodiments a variable length range of LBAs may be represented by a starting address and a length or the like. In one embodiment the capital letters A through M represent a logical or physical erase block in the physical storage media of the solid state storage device that stores the data of the corresponding range of LBAs. In other embodiments the capital letters may represent other physical addresses or locations of the solid state storage device . In the depicted embodiment the capital letters A through M are also depicted in the log based writing structure which represents the physical storage media of the solid state storage device .

In the depicted embodiment membership in the mapping structure denotes membership or storage in the solid state storage device . In another embodiment an entry may further include an indicator of whether the solid state storage device stores data corresponding to a logical block within the range of LBAs data of a reverse map and or other data.

In the depicted embodiment the root node includes entries with noncontiguous ranges of LBAs. A hole exists at LBA between the two entries of the root node. In one embodiment a hole indicates that the solid state storage device does not store data corresponding to one or more LBAs corresponding to the hole. In one embodiment the solid state storage device supports block I O requests read write trim etc. with multiple contiguous and or noncontiguous ranges of LBAs i.e. ranges that include one or more holes in them . A hole in one embodiment may be the result of a single block I O request with two or more noncontiguous ranges of LBAs. In a further embodiment a hole may be the result of several different block I O requests with LBA ranges bordering the hole. 

In the depicted embodiment similar holes or noncontiguous ranges of LBAs exist between the entries of the node between the entries of the left child node of the node between entries of the node and between entries of the node . In one embodiment similar holes may also exist between entries in parent nodes and child nodes. For example in the depicted embodiment a hole of LBAs 060 071 exists between the left entry of the node and the right entry of the left child node of the node .

The hole at LBA 003 in the depicted embodiment can also be seen in the logical address space of the solid state storage device at logical address 003 . The hash marks at LBA 003 represent an empty location or a location for which the solid state storage device does not store data. The hole at LBA in the logical address space is due to one or more block I O requests with noncontiguous ranges a trim or other deallocation command to the solid state storage device or the like. The mapping structure supports holes noncontiguous ranges of LBAs and the like due to the sparse and or thinly provisioned nature of the logical address space .

The logical address space of the solid state storage device in the depicted embodiment is sparse and or thinly provisioned and is larger than the physical storage capacity and corresponding storage device address space of the solid state storage device . In the depicted embodiment the solid state storage device has a 64 bit logical address space beginning at logical address 0 and extending to logical address 2 1 . Because the storage device address space corresponds to only a subset of the logical address space of the solid state storage device the rest of the logical address space may be allocated mapped and used for other functions of the solid state storage device .

The sequential log based append only writing structure in the depicted embodiment is a logical representation of the physical storage media of the solid state storage device . In certain embodiments the solid state storage device stores data sequentially appending data to the log based writing structure at an append point . The solid state storage device in a further embodiment uses a storage space recovery process such as a garbage collection module or other storage space recovery module that re uses non volatile storage media storing deallocated unused logical blocks. Non volatile storage media storing deallocated unused logical blocks in the depicted embodiment is added to an available storage pool for the solid state storage device . By clearing invalid data from the solid state storage device as described above and adding the physical storage capacity corresponding to the cleared data back to the available storage pool in one embodiment the log based writing structure is cyclic ring like and has a theoretically infinite capacity.

In the depicted embodiment the append point progresses around the log based append only writing structure in a circular pattern . In one embodiment the circular pattern wear balances the solid state storage media increasing a usable life of the solid state storage media . In the depicted embodiment a garbage collection module or other storage capacity recovery process has marked several blocks as invalid represented by an X marking on the blocks . The garbage collection module in one embodiment will recover the physical storage capacity of the invalid blocks and add the recovered capacity to the available storage pool . In the depicted embodiment modified versions of the blocks have been appended to the log based writing structure as new blocks in a read modify write operation or the like allowing the original blocks to be recovered.

The present invention may be embodied in other specific forms without departing from its spirit or essential characteristics. The described embodiments are to be considered in all respects only as illustrative and not restrictive. The scope of the invention is therefore indicated by the appended claims rather than by the foregoing description. All changes which come within the meaning and range of equivalency of the claims are to be embraced within their scope.

