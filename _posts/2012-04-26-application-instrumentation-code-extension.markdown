---

title: Application instrumentation code extension
abstract: The embodiments provide an application diagnostics apparatus including an instrumentation engine configured to monitor one or more methods of a call chain of the application in response to a server request according to an instrumentation file specifying which methods are monitored and which methods are associated with a code extension, an extension determining unit configured to determine that at least one monitored method is associated with the code extension based on code extension identification information, a class loading unit configured to load the code extension from a resource file when the at least one monitored method associated with the code extension is called within the call chain, a code extension execution unit configured to execute one or more data collection processes, and a report generator configured to generate at least one report for display based on collected parameters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09251026&OS=09251026&RS=09251026
owner: BMC Software, Inc.
number: 09251026
owner_city: Houston
owner_country: US
publication_date: 20120426
---
This application claims the benefit under 35 U.S.C. 119 e of U.S. Provisional Patent Application Ser. No. 61 618 755 filed on Mar. 31 2012. The disclosure of U.S. Provisional Application Ser. No. 61 618 755 is incorporated by reference herein in its entirety.

In most cases a relatively large concern for customer facing Internet based applications e.g. banking retail services is the quality of service and or end user experience for their customers. This service generally translates into server requests e.g. associated with web based applications which are the entry points for customer based transactions and generally impact a company s ability to generate revenue. Currently there are a number of methods that may monitor the performance of such web based applications. However most conventional monitoring products have a fixed set of instrumentation that is applied to measuring the round trip and associated dependencies for an individual server request. For example a monitoring product may measure the incremental flow through the actual application method calls that service that request. The classes containing the method calls are generally instrumented in such a way that the instrumentation which is inserted for interception is called when the method is entered and called when the method is exited. The instrumentation in most cases is based on a descriptive file e.g. instrumentation file recording file etc. that essentially identifies the particular classes and methods to be monitored as well as how they should be handled and what information should be collected.

However in the event that the customer wishes to change the instrumentation and or has a new set of customized methods that the customer wishes to monitor implementing dynamic custom changes in a timely manner without affecting the application is a difficult challenge. For example in order to deploy a customized change to the underlying instrumentation the application may have to be shut down for a lengthy period of time which may be cost prohibitive and or disadvantageous when assisting customers who desire to minimize downtime e.g. some restarts can be excess of 45 minutes to complete . Further making changes to the underlying instrumentation is a complex process that requires a relatively significant amount of time to implement and often involving a highly skilled person with an in depth understanding of the instrumentation product and or the underlying server application.

Embodiments provide an application diagnostics apparatus for monitoring performance of an application executing on an application server. The application diagnostics apparatus includes at least one processor and a non transitory computer readable storage medium including instructions executable by the at least one processor. The instructions are configured to implement an instrumentation engine configured to monitor one or more methods of a call chain of the application in response to a server request according to an instrumentation file. The instrumentation file specifies which methods are monitored and which methods are associated with a code extension. The instructions are configured to implement an extension determining unit configured to determine that at least one monitored method is associated with the code extension based on code extension identification information being included in the instrumentation file a class loading unit configured to load the code extension from a resource file storing a plurality of code extensions using the code extension identification information when the at least one monitored method associated with the code extension is called within the call chain a code extension execution unit configured to execute one or more data collection processes specified by the code extension at an exit point of the at least one monitored method including obtaining at least one parameter related to the at least one monitored method and a report generator configured to generate at least one report for display based on the obtained at least one parameter.

The application diagnostics apparatus also includes a code extension updating unit configured to update the code extension or add one or more new code extensions based on information received via a code extension interface. In one embodiment the code extension updating unit is configured to update the code extension or add the one or more new code extensions without restarting the application.

The instrumentation engine configured to monitor one or more methods of a call chain of the application in response to a server request according to an instrumentation file may include intercepting the one or more methods according to the instrumentation file interjecting code at entries and exits of the one or more methods and monitoring the one or more methods in response to the server request during runtime of the call chain.

According to one embodiment the instrumentation file may include a plurality of rules and each rule specifies at least one method to be monitored. At least one of the rules may include information identifying the at least one monitored method tier information identifying which tier the at least one monitored method is located signature information and the code extension identification information. The code extension identification information includes information identifying the code extension and location information specifying the resource file.

The class loading unit may be configured to load the code extension from the resource file using a same class loader that was used to load the application. According to an embodiment the class loading unit may be configured to rename a class associated with code extension to a unique class name and call the same class loader that was used to load the application. The at least one parameter may include an argument and return value of the at least one monitored method.

The report generator may include a parameter map generator configured to generate a parameter map based on the obtained at least one parameter where the parameter map includes at least one key value pair representing a parameter and associated value and an analysis unit configured to analyze the parameter map and generate the at least one report based on the analyzed parameter map.

The embodiments provide a method for monitoring performance of an application executing on an application server performed by one or more processors. The method may include monitoring one or more methods of a call chain of the application in response to a server request according to an instrumentation file where the instrumentation file specifies which methods are monitored and which methods are associated with a code extension determining that at least one monitored method is associated with the code extension based on code extension identification information being included in the instrumentation file loading the code extension from a resource file storing a plurality of code extensions using the code extension identification information when the at least one monitored method associated with the code extension is called within the call chain executing one or more data collection processes specified by the code extension at an exit point of the at least one monitored method including obtaining at least one parameter related to the at least one monitored method and generating at least one report for display based on the obtained at least one parameter.

The method may further include updating the code extension or adding one or more new code extensions based on information received via a code extension interface. According to one embodiment the updating adding step may update the code extension or adds the one or more new code extensions without restarting the application.

The instrumentation file may include a plurality of rules and each rule may specify at least one method to be monitored. At least one of the rules may include information identifying the at least one monitored method tier information identifying which tier the at least one monitored method is located signature information and the code extension identification information.

In one embodiment the loading step may load the code extension from the resource file using a same class loader that was used to load the application. Also the generating step may include generating a parameter map based on the obtained at least one parameter where the parameter map includes at least one key value pair representing a parameter and associated value and generating the at least one report based on the parameter map.

The embodiments provide a non transitory computer readable medium storing instructions that when executed cause one or more processors to perform a monitoring process. The instructions comprising instructions to monitor one or more methods of a call chain of the application in response to a server request according to an instrumentation file where the instrumentation file specifies which methods are monitored and which methods are associated with a code extension determine that at least one monitored method is associated with the code extension based on code extension identification information being included in the instrumentation file load the code extension from a resource file storing a plurality of code extensions using the code extension identification information when the at least one monitored method associated with the code extension is called within the call chain execute one or more data collection processes specified by the code extension at an exit point of the at least one monitored method including obtaining at least one parameter related to the at least one monitored method and generate at least one report for display based on the obtained at least one parameter.

The instructions may include instructions to update the code extension or add one or more new code extensions based on information received via a code extension interface. In one embodiment the code extension s is are updated or added without restarting the application.

The embodiments provide an application diagnostics apparatus for monitoring performance of an application executing on an application server. The application diagnostics apparatus allows a user to dynamically extend the functionality of an application diagnostics module without requiring the application to be restarted and alter the monitoring effectiveness with surgical precision. The extension of the application diagnostics module may be implemented via one or more code extensions within an instrumentation file. The instrumentation file may specify in part which methods are monitored and which methods are associated with the code extension. The code extension itself provides the logic for performing one or more data collection processes such as the capturing of parameters e.g. key parameter indicators KPIs as well as potentially altering the application flow itself during runtime of the application. The code extensions may be able to dynamically insert themselves into the application in an accurate manner e.g. loaded with an appropriate class loader without the need to restart the application. Also developers of the code extensions do not necessarily have to have in depth knowledge of the instrumentation product. Rather the development of the code extensions may be accomplished via an extensions code interface and when implemented may permit virtually any programmer with sufficient domain knowledge to create and maintain the code extensions without requiring in depth knowledge of the inner workings of the instrumentation engine which is generally the most complex part of these types of products.

Furthermore because the modification or the addition of code extensions do not require application restart e.g. some applications may take over 45 minutes to restart and the development of the code extension may not require in depth knowledge of the underlying instrumentation the amount of time required to make a change modification addition from proof of concept POC to development may be significantly decreased. The data collection processes specified by the code extensions may obtain valuable information regarding the operations of the methods calls initiated by the server requests which may be actual new KPIs or contextual information specific to such methods. This information may be analyzed and presented to the user in the form of reports that may provide useful insight in evaluating the performance of an application such as the amount of time to execute certain method calls the arguments and or return values for the methods calls and or other information e.g. the latencies within each tier of an application and other server performance metrics . In short the application diagnostics apparatus may have the ability to provide customized instrumentation e.g. code extensions that are implemented on the fly without requiring in depth expertise of the instrumentation product and without being invasive to the operation of the application.

The application server may include the application diagnostics apparatus configured to monitor the performance of the application executing on the application server . For example the application may receive a server request that starts or prompts the execution of the methods according to a call chain initiated by the server request. The server requests may be in the form of general Hypertext Transfer Protocol HTTP posts Java Message Service JMS messaging or Representational State Transfer REST Remote Procedure Calls RPC based web service requests and are generally the entry points into the application . In one example the server request may be a login to a banking transaction for example.

The application diagnostics apparatus may monitor the performance of the application such as the entries into the methods and the exits out of the methods and create a call chain including the methods which were entered and exited in the course of the server request. Generally the application diagnostics apparatus may measure the amount of time spent in each part of the call chain and collect information regarding the specific attributes of each part of the application that was utilized by the called methods . In particular the application diagnostics apparatus may capture collect KPIs metrics and or properties that occur within the call chain initiated by the server request. From this information the application diagnostics apparatus may generate one or more reports and or SLA alerts analyzing the performance of the application .

The application diagnostics apparatus may include an instrumentation file an instrumentation engine an extension determining unit a resource file a code extension execution unit a report generator a code extension updating unit and a code extension interface . Also the application diagnostics apparatus may include other components that are well known to one of ordinary skill in the art.

The instrumentation engine may monitor one or more methods of a call chain of the application in response to the server request according to the instrumentation file . The instrumentation file may include information that specifies which methods are monitored. In some examples the instrumentation file may also be referred to as a recording file rules file or apoints file. The instrumentation engine may intercept the one or more methods according to instructions specified in the instrumentation file interject code at entries and exits of the one or more methods and monitor the one or more methods during runtime of the call chain which may include the capture collection of parameters related to the specified methods . According to the embodiments the instrumentation file may also include code extension information specifying which methods are associated with a code extension. The code extension itself provides in part the logic for performing one or more data collection processes such as the capturing of parameters e.g. key parameter indicators KPIs as well as potentially altering the application flow itself. In addition the code extension may provide the ability to change a user interface associated with the application .

According to the embodiments the instrumentation file associates the code extension with a particular rule which controls which methods should be instrumented collected at runtime. The instrumentation file may include a plurality of rules and each rule may specify one or more methods to be monitored. An example portion of the instrumentation file is illustrated below.

The above example illustrates a single rule e.g. GenericServlet included in the instrumentation file . However the instrumentation file may include any number of rules. At least some of the rules may be associated with the code extension as illustrated in the above example e.g. referred as a snapin . For example a rule may specify one or more methods to be monitored class information specifying the class associated with the one or more methods tier information identifying which tier the one or more methods are located signature information the code extension information and one or more modifiers. Referring to the above example the GenericServlet rule includes the tier information e.g. tier 1 the class information e.g. containsclass javax.servlet.http.HttpServlet the methods to be monitored e.g. doPost and doGet signature information e.g. Ljavax serlet http HttpServletRequest Ljavax servlet http HttpServletResponse the code extension information e.g. snapin com.bmc.aps.agent.trace.ServletMethodParameterSnapin snapins adops.jar and the modifiers e.g. deep entrypoint priority 2 .

In more detail the code extension information may include information identifying the code extension e.g. ServletMethodParameterSnapin and location information specifying the resource file snapins adops.jar . The resource file may be a designated source archive that stores a plurality of code extensions . In one embodiment the resource file may be a Java Archive JAR file. The code extensions may be stored in the resource file in such a manner that the code extensions are autonomous. In other words the code extensions are not dependent on any other information stored in the resource file . For example the resource file may also include customer information or any other type of information commonly stored in a JAR file. However the code extensions are packaged in the resource file such that they are not dependent on any other information contained in the resource file .

The methods e.g. doPost and doGet should contain the identified signature information and the modifiers place limits on the implementation rule. For example the modifier deep refers to the action of searching through all inherited classes of the identified methods . For instance if the rule did not contain the modifier deep the instrumentation engine may only look at the initial class being evaluated. Also the modifiers may include priority information e.g. priority 2 which indicates the priority of the rule. For example as indicated above there may be a number of different rules specifying different methods to be monitored. As such two or more rules may apply to the same method. The instrumentation engine may select one of the rules based on the priority information provided by the modifiers. The above described modifiers are merely examples where the embodiments encompass many different types and variations of modifying instruments that place limits on the implementation rule.

When the application is loaded the instrumentation engine may review every class associated with the methods of the application and if one or more of the rules apply to the loaded class the instrumentation engine instruments the specified methods by inserting code at the entries and exits of the specified methods . The loading unit may utilize an appropriate loader for loading the various classes of the application as specified by the methods . When the loader loads the classes corresponding to the respective method the instrumentation engine may review the loaded classes and if one or more of the rules applies to the loaded class the instrumentation engine may instrument the specified methods by inserting code at the entries and exits of the specified methods .

Thereafter during runtime of the application e.g. after it has been loaded the application proceeds to call the appropriate methods by the call chain instituted by the server request. During runtime an extension determining unit may be configured to determine that the one or more methods specified in the rule are associated with the code extension based on the code extension information . For example if the rule includes the code extension information the extension determining unit determines that the one or more specified methods are associated with the code extension . Thereafter the loading unit dynamically loads the code extension from the resource file and the code extension execution unit may carry out one or more data collection processes as specified by the code extension as further described below.

Also it is noted that the extension determining unit may determine that a particular method identified in the instrumentation file is not associated with the code extension . In this case the instrumentation engine may perform basic instrumentation functionalities associated with the identified method such as the collection of parameters and the timing associated with each identified method. However the code extension provides the ability for the application diagnostics apparatus to collect additional parameters above and beyond the basic instrumentation such as the ability to derive new KPIs. Further it is also noted that not every method within the call chain is instrumented. For instance the instrumentation file usually specifies which method an owner operator of the application is interested.

The loading unit may load the code extension from the resource file using the code extension information when the monitored one or more methods are called within the call chain. For example the loading unit loads the code extension specified by the code extension information . In one embodiment the loading unit may be configured to determine which loader was used to load the application and select the same loader e.g. loader to load the code extension from the resource file . As a result the code extension may be loaded into the proper location in order to ensure that the application continues to execute in a proper manner.

According to one embodiment the loading unit may use one or more techniques in order to bypass class loading delegation. Class loading delegation refers to the action of delegating downstream in order to locate a certain class. For example the application may be associated with a number of hierarchical class loaders in the order of a boot class loader an extensions class loader an application class loader and a WAR class loader. If the application is using the WAR class loader and a request for a class is received the WAR class loader will delegate downstream to the boot class loader. Then the boot class loader will attempt to locate the class and if a match was not found the next class loader in the hierarchy e.g. the extensions class loader will attempt to locate the class. This process is repeated until reaching the WAR class loader. For example if none of the parents to the requested loader finds a match the requested class loader will be used to load the class.

In order to prevent class loading delegation according to one technique the class loading unit may be configured to rename a class associated with the code extension to a unique class name. For example by giving the class a unique name one or more parent class loaders will never find a match to the class name. As such the requested class loader will always be used to load the extension. According to another technique the class loading unit may directly call the same class loader that was used to load the application e.g. found by traversing the original class data structure after directly loading the re named class into the loader . As a result bypass delegation may be prevented which ensures that the loaded code extension is loaded into same class loader as the class being instrumented which insures proper access to that classes internal and referenced classes.

Once loaded a code extension execution unit may be configured to execute one or more data collection processes specified by the code extension at an exit point of the one or more monitored methods . Although the code extension execution unit and extension determining unit is illustrated as a separate logic block from the instrumentation engine the code extension execution unit and extension determining unit may be included in or otherwise associated with the instrumentation engine . The one or more data collection processes may include obtaining one or more parameters associated with the one or more monitored methods . For example the code extension execution unit may collect KPIs parameters attributes and or other information related to the monitored methods . The collected KPIs parameters attributes may include the arguments and return values associated with the monitored methods. Also it is noted that the code extension execution is configured to collect the parameters at the exit point of the monitored methods in order to process the return values of the called methods. From the arguments and return values new information such as KPIs may be derived or created which may provide insight into how the application is performing. Although the code extension has been described with reference to a somewhat generic code extension each code extension is specific to the type of environment of the executed method s and well as the type of server request. As such the collected parameters may encompass virtually any type of parameter associated with the called methods.

The code extension updating unit may be configured to update the code extension and or add one or more new code extensions based on information received from the code extension interface . In one embodiment the code extension updating unit may be configured to update the code extension or add the one or more new code extensions without restarting the application. For example the code extension may be conformed to the code extension interface and when implemented permits a developer to change modify delete add one or more code extensions . An example code extension interface is illustrated below.

The above example relates to a code extension called IMethodParameterSnapin. The example code extension interface provides the code in order to update the code extensions in the resource file as well as the code extension information in the instrumentation file . Basically the code extension interface describes the capabilities of the code extension .

Generally the code extension execution unit includes an ability to use the arguments and or return values to create key parameters on the fly. These parameters may be transferred to the report generator for further processing. The report generator may be configured to generate one or more reports based on the obtained parameters. For example the report generator may include a parameter map generator and an analysis unit . The parameter map generator may be configured to generate a parameter map based on the obtained parameters. In one embodiment the parameter map may include a number of key value pairs where each key value pair represents a collected parameter and associated value. For example the parameter map generator may be configured to populate a parameter map with the parameters obtained by the code extension execution unit . The analysis unit may be configured to analyse the parameter map and generate one or more reports based on the analysed parameter map. The one or more reports may be provided to a user interfere for display such as the code extension interface . The reports are further illustrated with respect to .

As indicated above the actual contents of the code extension can widely vary depending on the application component being used to execute the specified method e.g. database call and the type of server request. However a specific example of the code extension is provided below.

One or more methods of a call chain of the application may be monitored in response to a server request according to an instrumentation file . For example the instrumentation engine may monitor one or more methods of a call chain of the application in response to the server request according to the instrumentation file . The instrumentation file may include information that specifies which methods are monitored. The instrumentation engine may intercept the one or more methods according to instructions specified in the instrumentation file interject code at entries and exits of the one or more methods and monitor the one or more methods during runtime of the call chain which may include the capture collection of parameters related to the specified methods . According to the embodiments the instrumentation file may also include the code extension information specifying which methods are associated with a code extension. The code extension itself provides in part the logic for performing one or more data collection processes such as the capturing of parameters e.g. key parameter indicators KPIs as well as potentially altering the application flow itself.

At least one monitored method may be determined as being associated with the code extension based on code extension identification information being included in the instrumentation file . During runtime the extension determining unit may be configured to determine that the one or more methods specified in the rule s in the instrumentation file are associated with the code extension based on the code extension information . For example if the rule s include s the code extension information the extension determining unit determines that the one or more specified methods are associated with the code extension .

The code extension may be loaded from a resource file storing a plurality of code extension using the code extension identification information when the at least one monitored method associated with the code extension is called within the call chain . The loading unit may load the code extension from the resource file using the code extension information when the monitored one or more methods are called within the call chain. For example the loading unit may load the code extension specified by the code extension information . In one embodiment the loading unit may be configured to determine which loader was used to load the application and select the same loader e.g. loader to load the code extension from the resource file . As a result the code extension may be loaded into the proper location in order to ensure that the application continues to execute in a proper manner.

One or more data collection processes specified by the code extension may be executed at an exit point of the at least one monitored method . Once loaded a code extension execution unit may be configured to execute one or more data collection processes specified by the code extension at an exit point of the one or more monitored methods . The one or more data collection processes may include obtaining one or more parameters associated with the one or more monitored methods . For example the code extension execution unit may collect KPIs parameters attributes and or other information related to the specified methods . The collected KPIs parameters attributes may include the arguments and return values associated with the monitored methods . From the arguments and return values new information such as KPIs may be derived or created which may provide insight into how the application is performing. However generally the collected parameters may encompass virtually any type of parameter associated with the called methods.

At least one report for display may be generated based on the obtained at least one parameter . The report generator may be configured to generate one or more reports based on the obtained parameters. For example the report generator may include a parameter map generator and an analysis unit . The parameter map generator may be configured to generate a parameter map based on the obtained parameters. In one embodiment the parameter map may include a number of key value pairs where each key value pair represents a collected parameter and associated value. In example the parameter map generator may be configured to populate a parameter map with the parameters obtained by the code extension execution unit . The analysis unit may be configured to analyse the parameter map and generate one or more reports based on the analysed parameter map.

In summary the application diagnostics apparatus may allow a user to dynamically extend the functionality of an application diagnostics module via one or more code extension within the instrumentation file . The instrumentation file may specify in part which methods are monitored and which methods are associated with the code extension. The code extension itself provides the logic for performing one or more data collection processes such as the capturing of parameters e.g. key parameter indicators KPIs as well as potentially altering the application flow itself during runtime of the application. The code extensions may be able to dynamically insert themselves into the application in an accurate manner e.g. loaded with an appropriate class loader without the need to restart the application . Also developers of the code extensions do not necessarily have to have in depth knowledge of the instrumentation engine. Rather the development of the code extensions may be accomplished via the extensions code interface and when implemented may permit virtually any programmer with sufficient domain knowledge to create and maintain the code extensions without requiring in depth knowledge of the inner workings of the instrumentation engine which is generally a highly complex component. The information collected by the code extensions maybe analyzed and presented to the user in the form of reports that may provide useful insight in evaluating the performance of the application such as the amount of time to execute certain method calls the arguments and or return values for the methods calls and or other information such as the latencies within each tier of the application and other server performance metrics. In short the application diagnostics apparatus may have the ability to provide customized instrumentation e.g. code extensions that are implemented on the fly without requiring in depth expertise of the instrumentation engine and without being invasive to the operation of the application .

Implementations of the various techniques described herein may be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Implementations may implemented as a computer program product i.e. a computer program tangibly embodied in an information carrier e.g. in a machine readable storage device or in a propagated signal for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers. A computer program such as the computer program s described above can be written in any form of programming language including compiled or interpreted languages and can be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program can be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.

Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. Method steps also may be performed by and an apparatus may be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array or an ASIC application specific integrated circuit .

Processors suitable for the execution of a computer program include by way of example both general and special purpose microprocessors and any one or more processors of any kind of digital computer. Generally a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally a computer also may include or be operatively coupled to receive data from or transfer data to or both one or more mass storage devices for storing data e.g. magnetic magneto optical disks or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices e.g. EPROM EEPROM and flash memory devices magnetic disks e.g. internal hard disks or removable disks magneto optical disks and CD ROM and DVD ROM disks. The processor and the memory may be supplemented by or incorporated in special purpose logic circuitry.

To provide for interaction with a user implementations may be implemented on a computer having a display device e.g. a cathode ray tube CRT or liquid crystal display LCD monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

Implementations may be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation or any combination of such back end middleware or front end components. Components may be interconnected by any form or medium of digital data communication e.g. a communication network. Examples of communication networks include a local area network LAN and a wide area network WAN e.g. the Internet.

While certain features of the described implementations have been illustrated as described herein many modifications substitutions changes and equivalents will now occur to those skilled in the art.

