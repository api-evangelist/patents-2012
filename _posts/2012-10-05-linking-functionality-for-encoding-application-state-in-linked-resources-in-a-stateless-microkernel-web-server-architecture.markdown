---

title: Linking functionality for encoding application state in linked resources in a stateless microkernel web server architecture
abstract: A method of serving a resource to a client via a computer network is provided. The method may include at an HTTP server system having a stateless microkernel architecture, the server system including one or more link resource servers, receiving an HTTP request for a resource from an HTTP client via a computer network, the request being to perform a resource operation, the resource operation being to retrieve the resource and send the resource to the requesting client, wherein the resource is a data object. The method may further include determining if the resource operation is authorized based on the request. If the resource operation is authorized, the method may include sending the resource operation to an object server associated with the resource identified by the request, in response receiving a data object from the object server, providing, via a linking engine, the data object to each link resource server of the one or more link resource servers, in response receiving one or more links from each of the one or more link resource servers, embedding the links in the data object, and sending the data object to the requesting client via the computer network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09143385&OS=09143385&RS=09143385
owner: Elastic Path Software, Inc.
number: 09143385
owner_city: Vancouver
owner_country: CA
publication_date: 20121005
---
This application claims priority from U.S. Provisional Patent Application No. 61 584 037 filed Jan. 6 2012 and entitled ENCODING APPLICATION STATE IN LINKED RESOURCES IN A STATELESS MICROKERNEL WEB SERVER ARCHITECTURE the entirety of which is hereby incorporated herein by reference for all intents and purposes.

Representing the state of user sessions of client server interactions is a challenging task and conventional client server systems represent state using a variety of software architectures. For example some systems may save session state in a cookie on the client while other systems may save the state in a data file on the server or utilize server sessions to track state. Yet other systems may communicate state through the networked resources themselves.

One example of the latter approach is the HATEOAS Hypermedia as the Engine of Application State REST Representational State Transfer style of software architecture. The REST architecture is a style of software architecture utilized by distributed hypermedia systems such as the World Wide Web WWW that attempts to represent application state over a computer network via linked hypermedia. Software systems that comply with the principles of REST architecture are client server based stateless layered cacheable optionally utilize on demand code and maintain a unified interface between the clients and servers.

HATEOAS is a constraint of the REST architecture that specifies all interaction between client s and server s is accomplished through hypermedia dynamically provided by the server s . In principle interactions utilizing such an approach may not require an intermediary session state i.e. state may be completely represented in the hypermedia itself . A typical HATEOAS system is composed of discrete resources objects each of which has a consistent address e.g. Uniform Resource Location URL that can be accessed by a requesting client over a computer network such as the Internet. Each individual resource also has a consistent representation which is indicated by a MIME Multipurpose Internet Mail Extensions type defined via the HTTP Content Type header for the resource. The representations can be encoded and transmitted between the server and client in any suitable format such as JSON and XML for example.

Resources of a typical HATEOAS system are inter related via relationships that are defined exclusively by links embedded in the data object which is a representation of each resource. In other words as a HATEOS system is stateless in principle the state of the system is contained in the resources themselves and the links between resources. Each link includes a REL field defining the name of the relationship to the other resource and a HREF field defining the address e.g. URL to the other resource. During client server interactions a HATEOAS system provides four actions on resources GET POST PUT and DELETE.

In practice the REST HATEOAS architectural style has numerous deficiencies which the present invention has been conceived to address. For example in the REST HATEOAS architecture additional information is included within the HTTP header thus tying a typical HATEOAS system to the HTTP protocol itself. Such a configuration may therefore render the typical system unusable with protocols other than HTTP. To address this deficiency the embodiments disclosed herein remove the HTTP protocol and provide the semantics in a more neutral manner thereby allowing for client server interaction across a variety of protocols if desired. Nonetheless the HTTP protocol may be one of the protocols among others used to engage a system in accordance with embodiments of the present disclosure.

A second deficiency of the REST HATEOAS architecture arises once the objects are separated from their HTTP receiver endpoint. Specifically the objects lose the content type and URL identity and therefore this information must be provided via other mechanism s . Thus the disclosed embodiments embed this information in a data structure referred to as the self entity of the object itself.

A third deficiency of the REST HATEOAS architecture is that the Content Type headers must transmit two distinct pieces of information the type of the object and the encoding method. In typical systems these two pieces of information may be concatenated with a symbol within the HTTP header string. However this practice obfuscates both pieces of information and potentially makes processing of incoming requests from clients difficult and or error prone. Accordingly the disclosed embodiments move the MIME type of the object into the above mentioned self entity and preserve the Content Type HTTP header for the purpose of expressing the object encoding method such as JSON XML etc.

A fourth deficiency of the REST HATEOAS architecture is that a URL of a resource is a poor identifier in a complex highly scaled web server implementation. For example once a client accesses the system on one server all the links in the representations are typically configured to point to the same server instance thus sticking that client to that server instance. Thus in practice a scaled deployment utilizing a pool of servers must rely on a single entry point such as a server load balancer that routes request s from requesting client s to a particular server within the pool of servers. The servers in the pool must know the name of this entry point and construct their URLs to point to this entry point explicitly. Furthermore the object itself is highly inflexible and breakable as its URL points to a hard server entry point. For example as the pool of available servers decreases as one or more severs become unavailable URL reference s to the unavailable server s are lost. As another example as the pool of available servers increases the clients that are stuck to particular server instances may not be able to utilize the additional computing resources thereby leading to unbalanced server loading.

More importantly by combining the server location and the URI of the resource together to form the URL a typical system breaks a central REST tenet namely statelessness. The disclosed embodiments address these issues by separating the identity of the object from the server that provided the object. This identity referred to as the URI is stored in the above described self entity and can be used to address the same logical resource on one or more other server instances.

As a fifth deficiency the REST HATEOAS architecture has no concept of the user performing operations and instead assumes completely anonymous interactions. Such a configuration is woefully impractical in most modern systems e.g. e commerce systems where user authorization and or authentication are required to consume resources and execute transactions. The disclosed embodiments address this issue by introducing the concept of a resource operation e.g. action to be performed on a resource and defining an authorization server to determine whether a requesting user is authorized to perform a given resource operation. Accordingly all resource operations must provide a user identifier indicating the identity of the requesting user. The identity of the user may be an anonymous identifier a user role identifier or other identifier which does indicate personally identifiable information. Such a configuration may therefore allow the user to access resources that are dedicated exclusively to the user and or to access resources that are dedicated to a particular role shared by the user and one or more other users.

The pool of available servers decreases as one or more severs become unavailable URL reference s to the unavailable server s are lost. As another example as the pool of available servers increases the clients that are stuck to particular server instances may not be able to utilize the additional computing resources thereby leading to unbalanced server loading.

More importantly by combining the server location and the URI of the resource together to form the URL a typical system breaks a central REST tenet namely statelessness. The disclosed embodiments address these issues by separating the identity of the object from the server that provided the object. This identity referred to as the URI is stored in the above described self entity and can be used to address the same logical resource on one or more other server instances.

As a fifth deficiency the REST HATEOAS architecture has no concept of the user performing operations and instead assumes completely anonymous interactions. Such a configuration is woefully impractical in most modern systems e.g. e commerce systems where user authorization and or authentication are required to consume resources and execute transactions. The disclosed embodiments address this issue by introducing the concept of a resource operation e.g. action to be performed on a resource and defining an authorization server to determine whether a requesting user is authorized to perform a given resource operation. Accordingly all resource operations must provide a user identifier indicating the identity of the requesting user. The identity of the user may be an anonymous identifier a user role identifier or other identifier which does indicate personally identifiable information. Such a configuration may therefore allow the user to access resources that are dedicated exclusively to the user and or to access resources that are dedicated to a particular role shared by the user and one or more other users.

A method of serving a resource to a client via a computer network is provided. The method may include at an HTTP server system having a stateless microkernel architecture the server system including one or more link resource servers receiving an HTTP request for a resource from an HTTP client via a computer network the request being to perform a resource operation the resource operation being to retrieve the resource and send its representation to the requesting client wherein the representation is a data object. The method may further include determining if the resource operation is authorized based on the request. If the resource operation is authorized the method may include sending the resource operation to an object server associated with the resource identified by the request in response receiving a data object from the object server providing via a linking engine the data object to each link resource server of the one or more link resource servers in response receiving one or more links from each of the one or more link resource servers embedding the links in the data object and sending the data object to the requesting client via the computer network.

From the preceding discussion it will be appreciated that HATEOAS is a constraint of the REST architecture that specifies all interaction between client s and server s is accomplished through hypermedia dynamically provided by the servers. REST systems are stateless in that each request from a client to a server contains all information necessary to interpret the request. This approach allows for a particular server to handle a request from a client regardless of whether or not that server has handled previous requests from that client.

In order to meet said constraints each resource in a HATEOAS system is a network addressable object accessible via a consistent Uniform Resource Locator URL and HATEOAS systems operate on these objects. In other words the term resource as used herein refers to a network addressable data object hereinafter object that encompasses some meaningful concept. Each object includes all information necessary to understand how to interact with the corresponding resource such as how to provide a representation of the resource e.g. how to visually present the object to a user via a display device and how to link to from the resource. Before continuing it will be understood that an object may represent a resource in that the object provides the current state of the resource and the object may be usable by each requesting client to provide a representation of the object that may be dependent upon one or more characteristics of the client. In other words as will be described in greater detail below the same object may be usable to provide different representations on different clients. Put another way a resource may be thought of as a software implementation of business logic an object may be thought of as an encoding of that business logic and a representation may be thought of as a manifestation of an object at the client device.

As one non limiting example an electronic commerce system utilizing the HATEOAS architecture may comprise a shipping resource to maintain shipping information and thus to respond to requests e.g. resource operations for the shipping information e.g. user account shipping information available shipping methods etc. . Similarly the example e commerce system may further comprise an inventory resource to maintain inventory information a price resource to maintain pricing information and a cart resource to maintain an online shopping cart. From this example it will therefore be appreciated that the information provided by each resource may be related to e.g. depend on depend from etc. any one or more other resources.

A given resource may be related to one or more other resources defined by links within the object representing the resource. As one simple example a saleable good resource may link to a current availability resource indicating the availability of a particular saleable good. As will be described in greater detail below a HATEOAS system according to embodiments of the present disclosure provides a corresponding resource server for one or more resources where each resource server is configured to maintain the resource and or respond to external requests for the resource e.g. provide links .

Continuing with the above example the link to the cart link may subsequently be acted upon e.g. upon actuation of a displayed add to cart button in order to add the saleable good to the online shopping cart and or to otherwise interact with the online shopping cart. In this way state transitions are defined via the links and one or more of the links may be acted upon in order to effect one or more of the transitions. Such a configuration therefore satisfies the central pillar of the REST architecture that all possible next state transitions be defined within an object provided to the client.

In complex systems e.g. e commerce systems factory floor systems etc. such linking may be unduly burdensome due to the myriad of interconnected and interdependent rules e.g. business rules error handling etc. which are inherent to such systems. This potential shortcoming has restrained widespread adoption of the HATEOAS architecture for typical complex systems. For example in an e commerce system once a particular saleable good is recognized as out of stock such an event may effect removal of the saleable good from an online shopping cart provision of a request to reorder the good changes to a product page an increase in price to one or more related goods provision of backorder notifications for pending transactions and or one or more other dependent actions. Failure to effect one or more of these dependent actions may lead to an undefined system state and or may provide an unsatisfactory user experience. For example if the available inventory of a particular saleable good is depleted without updating one or more affected resources users of an e commerce system may place an order for the saleable good without being aware that the item is out of stock.

Accordingly typical complex systems may utilize non HATEOAS architectures. These systems may be exception driven or error driven such that branching e.g. business logic is implemented upon occurrence of an exception error. For example in some embodiments upon occurrence of an out of stock error exception e.g. upon trying to checkout with an out of stock product typical systems may have to for example determine whether the product should still be orderable e.g. via backorder remove the add to cart button remove the page from search results etc. Such error handling may be hardcoded into the client software potentially requiring frequent updates to the client software as business rules are updated. In other embodiments the out of stock error may simply be returned to the user and the user may thus be expected to manually handle the error accordingly e.g. remove out of stock items from cart before ordering . However such a configuration relies heavily on the user and may therefore provide inaccurate results and or may otherwise degrade the user experience. As described below the disclosed embodiments enable a client without knowledge of a complete set of business rules to present all available options to a user in a representation of the object presented to the user and effect appropriate state transitions upon selection of an option.

It will therefore be appreciated that it may be desirable to cluster each of the business rules decision logic etc. around a corresponding resource server. In other words the business rule s related to the maintenance of the current availability resource e.g. reordering out of stock notifications etc. may be instantiated within the logic of the current availability resource server. Such a configuration may therefore provide for each resource a single repository where logic related to the resource may be maintained. Accordingly update s to the business rules to link s between the resources and or to the visual representations of the resources may potentially be updated on the server without extensive modification the client software. Furthermore by instantiating such logic within one or more servers and thus removing the logic from the clients the described HATEOAS architecture may potentially allow for lighter weight client s as compared to typical systems.

It will be further appreciated that by clustering the logic for a given resource with the corresponding resource server an improved schema for linking between objects may be realized. As will be discussed in detail below requests to a HATEOAS server for a particular object may effect collecting of link s related to the object and subsequent attaching the link s to the object before returning the object to the requesting client. As each resource server is substantially independent i.e. does not directly interact with a resource of another resource server it may be possible for each resource server to be queried e.g. for links associated with a particular object in parallel and or for such querying to be substantially order agnostic. Accordingly the disclosed embodiments may potentially provide a more resilient and extensible linking schema that is suitable for implementing complex systems. Although an e commerce system is used herein as an example of a system usable with the described improved HATEOAS REST architecture it will be appreciated that the architecture may be utilized by any stateful process and or any data model comprising inter related information without departing from the scope of the present disclosure.

Turning to an example of an embodiment of a HATEOAS based client server system including server configured to execute a HTTP server program via microkernel is illustrated. System further comprises client computing device configured to communicate with server via network . Client computing device may provide client e.g. web browser so as to facilitate such communication. Client may be configured for example to provide representation of a data object hereinafter object . As previously mentioned the term representation as used herein refers to a specific presentation e.g. visual audio etc. of an object. It will be understood that each object may be interpreted and presented according to various features preferences etc. of each client . In other words a representation of object other than representation may be provided by client s other than client .

As described above typical HATEOAS systems rely upon the HTTP protocol implementation to provide low level functions. Specifically the MIME type also referred to as Content type component of the HTTP header may be used to define both the representation of the resource and the encoding method. Including additional information within the HTTP header may restrict use of other communication protocol s and or may otherwise negatively affect operation of the system. The typical HATEOAS architecture may therefore not be able to provide the features of an e commerce system.

Accordingly it may be desirable to develop an architecture that is protocol independent and as such object includes a self entity e.g. data structure comprising a plurality of characterizing data that may have otherwise been included in the HTTP header in a typical HATEOAS system. The characterizing data may include but is not limited to type Uniform Resource Identifier URI HREF and max age .

Type provides a name of a data schema and may be used to define one or more characterizing features of object . As one non limiting example type of a movie object may be a schema such as application vnd.imdb.movie informing client that the object is a movie. The schema may further indicate to the client what additional field s if any to expect within object . For example the application vnd.imdb.movie schema may be defined to have a field called rating that describes the rating of the movie. Thus upon recognizing an object being of the above described movie object type the client may access the rating field to determine the rating if desired. In some embodiments the additional field s may be provided within self entity and or elsewhere within object . It will be understood that the schema does not define the kinds of links to expect which will be discussed in greater detail below but rather defines feature s of the object such as the zero or more additional field s in the particular object.

URI may identify the resource represented by the object whereas HREF may identify the location of the resource. In other words HREF may identify how to access the resource identified by URI . For example HREF may comprise a location of server URI of the particular resource an action to perform on the resource and or a protocol to provide such interaction. As one non limiting example URI of a cart type object of an e commerce system may be store cart 123 whereas HREF may be https www.mystore.com store cart 123. 

Max age field indicates a maximum age e.g. in seconds from creation download of object that client may display or otherwise provide representation of object . Once this maximum age is surpassed client may be configured to request an updated instance of object from server rather than display representation which is over the aging limit. For example if a particular object includes max age field of 86 400 seconds i.e. 24 hours client may use this information to cache the object locally so as to avoid further calls to the system e.g. READ requests for the object for 24 hours. As mentioned above typical HATEOAS systems provide information via the HTTP header and max age field may constitute at least some of that information. As not all HTTP clients may be able to manage this information in the HTTP headers typical configurations may effect unnecessary network traffic and server load. Further by placing field inside object each client may manage its own caching of the object.

Object further comprises zero or more links illustrated as an arbitrary number N links each defining a relationship between the object and a related resource. Each link may comprise for example TYPE element defining the type of object returned by the link REL element defining the name of the relationship between object and the returned object URI element identifying the resource providing the returned object and HREF element defining the location of the linked resource.

One non limiting example of object is an online shopping cart as follows. Self entity of the example shopping cart object includes a content type of application vnd.elasticpath.cart and an additional object field called total quantity defined by the content type that indicates how many items are in the cart. In other words the schema identified via content may alert the receiving client to expect a total quantity field.

In combination with self entity links provide all the information necessary to implement a HATEOAS system as described above. In other words if object is instructed e.g. via user interaction such as clicking with representation to perform a state transition e.g. follow link object includes all information needed to access the link e.g. how to contact server in order to follow the link and or to manipulate the representation itself.

For example during operation client may send resource operation request corresponding to a particular link in object downloaded to client computing device . The request is defined by HREF element of the particular link and may include for example URL indicating a location of the linked resource and action indicating an action e.g. PUT GET POST or DELETE to perform on the linked resource. For example upon following an add to cart link request may include a request to POST an add to cart request to the shopping cart resource. In some embodiments the request may further comprise user identifier which will be discussed in greater detail below. Such a request is provided for the purpose of example and is not intended to be limiting in any manner.

Request is sent to server via computer network and is received at server by acceptor associated with microkernel . Acceptor performs processing of request and dispatches the request to an appropriate handler thread of microkernel for further processing. The handler thread in turn calls various resource servers associated with various resources in order to retrieve the requested data. For example as illustrated resources may be stored in file systems and or databases or programmatically generated from data stored therein.

Based upon the processing of resource servers response including object is generated and is subsequently transmitted via network to client computing device .

As with object client may be configured upon receiving object to provide representation of object . Specifically client may be configured to examine type and or the REL element of each link included within object in order to provide representation . For example if client identifies object as a catalog entry e.g. by examining type and if an add to cart link is not present within the object client may be configured to provide a disabled e.g. grayed out add to cart button via representation . In other embodiments client may be configured to display no add to cart button. It will be understood that these scenarios are presented for the purpose of example and are not intended to be limiting in any manner.

Interaction with representation e.g. via clicking may effect transmission of a second resource operation request and subsequent receipt of a third object not illustrated . It will be appreciated that such interaction may be repeated ad infinitum and or until a desired state is reached.

Turning now to a non limiting example of a HATEOAS system in accordance with another embodiment of the present disclosure is schematically illustrated. System comprises server communicatively coupled to HTTP client via network . Server is configured to receive via acceptor request from client and to send via the acceptor response . Server includes kernel configured to interact with the remaining elements of the server thereby acting as the central communications hub of server . For example kernel may provide a handler thread to handle the described request response lifecycle. Server yet further includes authorization solver and resource linker . The resource linker may utilize the authorization solver to determine if a particular resource server is authorized to attach links as is discussed in greater detail below.

Server includes one or more object servers and one or more link resource servers each sometimes referred to as resource servers. Although object servers and link resource servers are illustrated via an arbitrary number N of object servers and an arbitrary number N of link resource servers respectively it will be appreciated that such illustration is provided for ease of understanding and that server may include additional and or different resource servers in other embodiments without departing from the scope of the present disclosure. It will be further appreciated that although object servers and link resource servers are illustrated as distinct components any particular resource server may operate as an object server or a link resource server depending on the particular request as will be described in more detail below.

The object servers and link resource servers are distinct software programs configured to interact with each other by exchanging i.e. sending and or receiving resource operations via kernel . Each resource server operates independently from the others and is the only resource server that serves data objects for its resource. In other words no resource servers other than the resource server corresponding to a particular resource are able to directly interact with or modify the resource. For example in the depicted configuration Object Server may not directly interact with resources other than Resource . Such a configuration may therefore enable the implementation of business rules and or other logic associated with a particular resource within the associated resource server. In this way each object server and or link resource server is responsible for a particular resource e.g. e commerce platform inventory management system data management system database file system etc . For example in an e commerce scenario one of the resource servers may be a price resource server configured to provide requested price s and all pricing related logic e.g. bulk discounts sales other promotions etc. may be implemented by the price resource server and only the price resource server.

An example request response lifecycle of system is as follows. Request comprises a request to retrieve e.g. READ a particular resource of resources . Upon receiving request from client via acceptor kernel is configured to provide the request to the resource server identified by the request. In some embodiments kernel may be configured to parse the URI identified by the request e.g. URI derived by acceptor from URL to determine the corresponding resource server. In other embodiments kernel may be configured to determine the corresponding server via one or more other mechanism s . As illustrated kernel provides resource operation request to Object Server and microkernel receives object in response. Object corresponds to the resource i.e. Resource providing the object server and represents the state of the resource after performance of the resource operation request.

Upon receiving object microkernel is configured to provide the object to resource linker in order to aggregate and to subsequently attach to the object any one or more links provided by the remaining resource servers e.g. by link resource servers . In other words the resource linker is configured to collect links with additional related information from the other resource servers.

In an example e commerce scenario object may represent a product entry in an online catalog. For example request may comprise a request for a product information page for a particular product where the page includes a description price and indication of available inventory for the product. Thus the example object received from the appropriate object server comprises a catalog entry object corresponding to the product. For example object may comprise a product identifier e.g. product ID product title etc. and or additional information such that the remaining resource servers may provide information related to the product e.g. description pricing etc. .

Accordingly once object is received at resource linker via microkernel the resource linker is configured to provide the object to the one or more link resource servers in order to populate the catalog entry through receipt and subsequent embedding of links . For example link resource servers in this scenario may include a price resource server an inventory resource server a product description resource server and a shipping resource server. Each of the resource servers upon receiving object from the resource linker may examine the object and respond with any relevant links . Thus the object may be augmented with price data returned by the price resource server inventory data returned by the inventory server description data returned by the product description server and shipping information returned by the shipping resource server. Generally speaking each link resource server may implement one or more linking rules e.g. business rules other logic etc. to determine which link s to return for a given object . The result of such linking as discussed above in reference to is stored within the object and is eventually returned to the requesting client.

Although the above description pertains to so called monolithic resources servers e.g. shipping resource server to provide shipping information there may be one or more subresources for each of any one or more resources in some embodiments. Each subresource may be utilized to provide additional information to a given resource . Accordingly subresources may be added deleted or modified without any update to the associated resource thereby potentially further increasing the extensibility of system . The subresources along with the rest of the resources are queried during linking to determine if the subresources have related information. For example returning to the above e commerce scenario although the shipping resource exists to provide shipping information e.g. shipping method selection pricing estimated delivery etc. it is each subresource that may define the individual shipping options e.g. 3 day etc. Thus if a new shipping option e.g. overnight becomes available a new subresource can be created to define said option without updating the parent shipping resource. In such scenarios after the shipping resource has handled a shipping resource operation the linker may query the subresources to determine additional details.

In order to provide information related to object each link resource server may be configured to examine the type element of object e.g. TYPE as more than one object encountered by a particular resource server may comprise similar or equivalent names e.g. REL . Each resource server may implement one or more functions and each of these functions may be defined for any one or more object types. In other words each resource server may be configured to perform type granular resource operations on a corresponding resource of resources . For example a shopping cart resource server may be configured to not provide an add to cart link to an object of image type but may be configured to provide such a link to an object of product type. As another example upon encountering an object type for which no corresponding logic exists e.g. new object type at a particular resource server the resource server may be configured to provide no links . It will be understood that depending on the particular use case scenario and or configuration of server links may include direct information and or indirect information e.g. information usable to programmatically retrieve other information . For example in some embodiments the product description resource server may be configured to provide a text based description of the product such that the information provided in the link s is directly usable to provide the product description. In other embodiments where the information is indirect the information provided by the product description resource server may be usable by client upon receipt to programmatically retrieve the product description e.g. from the product description resource server .

In some instances one or more of link resource servers may not be able to provide links and may instead perform in response to the query a default action. In some instances such a default action may include for example providing an error status e.g. Out of stock notification providing a link to an error status e.g. link to error status with up to date information and or providing nothing e.g. no response response with no data payload etc. . In other instances a resource server may provide different and or additional default actions without departing from the scope of the present disclosure.

Generally speaking resource linker is configured to collect any information related to object . Accordingly resource linker may be configured to provide object to every resource server of server . Thus the resource linker may be configured to maintain an understanding of all of the resource servers e.g. via a resource server list etc. of server . As mentioned previously each resource server may be substantially independent of the other resource server s . Therefore linker may be configured to query the resource servers in any desired order so long as each resource server is queried. For example in some embodiments linker may query one or more of the resource servers in parallel to increase throughput.

Regardless of the order by which the resource servers are queried the resource server is aware that linking is complete for a particular object once all resource servers have been queried. As object is passed to each resource server and as each resource server is configured to provide information i.e. links independent of the information provided by the other resource server s it will be appreciated that the links are not embedded within the object until all link s have been collected from all of the resource servers. Once all the links have been collected and embedded in the object the object is returned to the requesting client.

Although operation of resource linker has been described with reference to interactions between the linker and one or more resource servers it will be appreciated that such interaction may be provided via kernel . As mentioned above the resource servers are isolated modules configured to interact with each other by exchanging e.g. sending and or receiving resource operations via kernel . Accordingly in order to query a particular resource server linker may be configured to provide a query resource operation e.g. READ operation for the particular resource server to the kernel and the kernel may subsequently provide the query to the corresponding resource server. Similarly the link s provided by the resource server may be received by linker via kernel .

As mentioned above HATEOAS systems are by design typically unaware of the concept of users and may therefore be ill suited for e commerce scenarios and or for other applications utilizing user based permissions preferences etc. Accordingly server system further includes authorization solver so as to provide kernel with user authentication needed for the improved HATEOAS architecture. Specifically after microkernel receives a resource operation e.g. resource operation request linking operation requests etc. the kernel may be configured to communicate with the authorization solver to ensure that the given resource operation is allowed. In other embodiments the kernel may forward a subset of the resource operation request data.

For example in some embodiments request may further comprise a user identifier e.g. user identifier indicating the user providing the request. The user identifier may comprise any data or combination of data used to determine the permissions of a given user. For example in some embodiments the user identifier may be a substantially unique identity e.g. user name . In other embodiments the user identifier may define a role e.g. administrator with which permissions are associated and the role may be shared amongst any one or more users. Generally speaking request may comprise at least some identifying information such that server system may examine this information to determine whether or not the resource operation identified by the request is allowed to be performed.

Accordingly upon receiving request kernel e.g. handler of kernel may be configured to determine the user identifier role identifier and or other identifying information and may thus supply authorization solver with this information. Authorization solver may then be configured to examine the information and to provide an indication e.g. yes no detailed result etc. to kernel as to whether or not the request should be handled. In other embodiments kernel may forward request to authorization solver without first identifying a user role etc. It will be appreciated that these scenarios are presented for the purpose of example and are not intended to be limiting in any manner. The interaction between the various elements of will now be discussed in greater detail with reference to .

At method further comprises determining if the resource operation is authorized based on the request. In some embodiments such a determination may comprise determining a user identifier based on the request and querying an authorization solver e.g. authorization solver to determine whether a user corresponding to the user identifier is authorized to perform the resource operation. For example a kernel of the HTTP server system e.g. kernel may be configured to determine the user identifier from the request e.g. by parsing the request and to query the authorization solver by providing the user identifier. In other embodiments the entire request and or a different subset of the request may be provided to the authorization solver. If the resource operation is not authorized method ends and thus the resource operation is not performed. In some embodiments a message indicating the operation failure may be sent to the requesting client.

However if the resource operation is authorized method further comprises at sending the resource operation to an object server associated with the resource identified by the request. For example as mentioned above the kernel of the server system may be configured to determine the user identifier by parsing the user request and such parsing may further comprise parsing a link included in the request to identify the requested resource. In other embodiments parsing of the link may be performed upon determining that the resource operation is allowed. Nonetheless determining which particular resource is requested may be accomplished by recognizing a URI of the resource within the request. These scenarios are presented for the purpose of example and are not intended to be limiting in any manner.

In response to sending the resource operation to the object server method further comprises at receiving an object from the object server where the object represents the resource upon performance of the resource operation. In other words the object may represent the result of the resource operation. For example as the request includes a GET READ action e.g. retrieve the resource the object may represent the state of the resource upon performance of the GET action. In other embodiments where the request includes a POST UPDATE action e.g. update the resource with new information the object may represent the state of the resource after the resource has been updated with the new information.

At method further comprises embedding in the object a content type identifier e.g. TYPE indicating a content type of the object and a resource location identifier e.g. HREF indicating a location of the resource. As mentioned previously typical HATEOAS systems embed such identifying information within the HTTP header itself. However as this increases dependency upon the HTTP protocol itself such a configuration may not provide suitable extensibility and or may be otherwise undesirable. Accordingly by embedding the information within the object the identifying information remains with the object while freeing the HTTP header to provide the standard functionality.

As described above handling of a READ operation may include not just returning a particular object if at all but may also comprise determining related information. For example if the request received at includes a request for an online shopping cart merely returning the shopping cart object e.g. cart comprising a list of items without related information e.g. price inventory etc. may be undesirable. In such scenarios the client may be configured to provide one or more calls for the additional information thereby increasing the complexity of the client and or decreasing throughput. As such it may be desirable to both determine the related information and attach the information to the object before returning the object to the requesting client.

Accordingly at method further comprises providing via a linking engine e.g. resource linker the object to each link resource server of the one or more link resource servers. As discussed above the resource linker is configured to query each of the resource servers to determine if said resources servers are aware of any information related to the resource operation. Said querying may be accomplished for example by utilizing the method of . In other words the linker may query the resource servers by constructing a resource operation for each resource server. In some embodiments authorization may be performed instead of or in addition to the authorization performed at . For example authorization may be performed upon receiving the object and or before providing each linking resource operation.

As said resource operations result from a primary resource operation said resource operations may be referred to as secondary resource operations. By allowing non kernel elements of the microkernel to query other elements each element does not need to be aware of the state of any other resource since the state can be queried as needed. Such a configuration ensures that only the appropriate resource server acts upon a given resource operation and that any other resource server must interact with the resource server instead of directly accessing the resource.

In order to provide the related information each link resource server may be configured to examine the embedded content type of the object. Generally speaking each link resource server includes linking rules e.g. business rules other logic etc. for one or more object types. Accordingly upon recognizing the content type of the object as a content type for which linking rule s exist each resource server is configured to return one or more links according to the linking rules corresponding to the content type of the object. As mentioned above if a particular link resource server does not recognize the object type or otherwise cannot provide a response to the query the link resource server may be configured to provide a default action. It will be understood that each resource server receives the object and does not receive any links provided by the other resource servers. In other words there may exist no pre defined order by which the resource servers are queried and instead the resource servers may be queried in any particular order so long as each of the link resource servers is queried. In some embodiments two or more of the resource servers may be queried in parallel.

Thus in response to the provision at method further comprises at receiving one or more links from each of the one or more link resource servers. In some instances there may be no suitable links. At method further comprises embedding the links in the object e.g. within a links data structure field etc. . Upon embedding the links method comprises sending the object to the requesting client via the computer network at .

Turning now to a process flow depicting an embodiment of a method for operating a stateless microkernel architecture server including a first link resource server and a second link resource server is illustrated. At method comprises receiving an HTTP request for a resource from an HTTP client via a computer network the request being to perform a resource operation the resource operation being to retrieve the resource and send the resource to the requesting client wherein the resource is a data object.

At method comprises sending the resource operation to an object server associated with the resource identified by the request. At method further comprises in response receiving the data object from the object server and at embedding in the data object a content type identifier indicating the a content type of the data object and a resource location identifier indicating a location of the resource. In other words the requested data object has been received and the identifier s have been embedded in the object. However it will be appreciated from the preceding discussion that one or more link resource servers may maintain information that is related to the data object.

Accordingly at method further comprises providing the data object to the first link resource server via a linking engine. In response at method further comprises receiving one or more first links from the first link resource server. Similarly at method comprises providing the data object to the second link resource server via the linking engine Method further comprises at in response receiving default information from the second link resource server. The default information may be received for example if the second link resource server does not maintain information related to the object and or if the second link resource server is unavailable. As previously mentioned and as illustrated at the default information may include one or more of a link to a status of the second link resource server and a status notification.

Method further comprises at embedding the one or more first links in the data object. In some embodiments method may further comprise at if the default information includes the link to the status of the second link resource server appending the link to the status of the second link resource server to the data object before sending the object to the requesting client. In other words if the default information includes a link the link is embedded in the object. At method further comprises sending the object to the requesting client via the computer network.

The above systems and methods may be utilized to realize a complex stateful system according to the REST HATEOAS architecture. Generally speaking by clustering business rules and or other logic associated with a particular resource around the associated resource server each resource may be individually maintained while still providing for instantiation of inter resource relationships. Further as each resource server is substantially independent of the other resource servers such a configuration may provide greater extensibility by enabling resource granular updating of the logic. Yet further by implementing the complex logic within the server as opposed to the clients the described systems may potentially allow for lighter weight client s as compared to typical client server systems.

As this invention may be embodied in several forms without departing from the spirit of essential characteristics thereof the present embodiments are therefore illustrative and not restrictive since the scope of the invention is defined by the appended claims rather than by the description preceding them and all changes that fall within metes and bounds of the claims or equivalence of such metes and bounds thereof are therefore intended to be embraced by the claims.

