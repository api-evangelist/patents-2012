---

title: Method and system for dynamic provisioning using server dormant mode for virtual server dormancy
abstract: A method for dynamic provisioning of server deployments using a dormant mode for content servers. Client devices may conduct transactions with servers when the servers are in an active mode. However, in the dormant mode, the servers do not accept new transactions. Thus, by utilizing the dormant mode on one or more servers, a server deployment scheme can be effectively scaled down by reducing the number of active servers. In order to scale up the deployment, one or more active servers are added to the deployment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09319274&OS=09319274&RS=09319274
owner: EMC Corporation
number: 09319274
owner_city: Hopkinton
owner_country: US
publication_date: 20120329
---
This disclosure relates generally to the field of virtual server deployment and more particularly to active and dormant states of operation for server components.

An enterprise ready platform for server virtualization and cloud computing provides many advantages for users. As one example users benefit from having an enterprise service providing a content management system and repository. However such solutions often have many components such as contents in a file system full text index on a full text engine and metadata in a database system as well as the logic and instructions for managing these resources. Where there are multiple components it can be difficult if not impossible for them to be properly synchronized in order to guarantee data integrity.

One prior solution was to manually shut down each component to ensure that no system data would be changed during the interval when a component was shutdown. This of course causes extra downtime for the system.

It would be desirable to provide a mechanism to make components aware of the availability of other components so as to minimize downtime and to perform upgrade and restarts safely and seamlessly.

It would also be desirable to provide more elasticity in the system architecture so that capacity could be adjusted and balanced or dynamically provisioned with simple techniques.

This disclosure describes systems and methods for providing and using a dormant state in components of an enterprise content management system and repository. A component in the dormant state cannot accept any new connections and will become read only for any existing connections except that pending transactions will first be committed or aborted. Only users with a specialized privilege setting are able to set and use the dormant state.

The dormant state is useful to provide flexibility to the system. For example in the cloud based environment the ability to scale up or scale down to adjust and balance for system load requirements on demand is critical. The use of the dormant state provides a simple tool to scale down a server deployment. Likewise the dormant state may be used as a tool for load balancing.

The dormant state is also useful to perform software upgrades and updates. For example each server in a server cluster may be placed in a dormant state one at a time provided with a software upgrade then returned to its active state. Alternatively if all components are placed into a dormant state a read only image of one point in time of the components is provided until the components are ready to be placed back in the active state.

Prior to describing the subject matter in detail an exemplary hardware device in which the subject matter may be implemented is first described. Then an exemplary hardware and software environment in which the exemplary hardware device operates will be described. Finally techniques for operating devices in the exemplary environment will be described. Those with ordinary skill in the art will appreciate that the elements and or components described may vary depending on the implementation.

Communication network may include many interconnected computer systems and communication links. Communication links may be hardwire links optical links satellite or other wireless communications links wave propagation links or any other mechanisms for communication of information and may be the same or different for the various hardware components that are coupled to the network . Various communication protocols may be used to facilitate communication between the various systems shown in including TCP IP HTTP protocols wireless application protocol WAP vendor specific protocols customized protocols and others. In one embodiment communication network is the Internet while in other embodiments any suitable communication network may be used including a local area network LAN a wide area network WAN a wireless network an intranet a private network a public network a switched network any combinations of these and the like.

Distributed computer network is merely one illustrative embodiment and is not intended to limit the scope of the disclosure. One of ordinary skill in the art would recognize many other variations modifications and alternatives in how to effectively arrange such components and systems.

In a typical client server arrangement as shown in one or more client systems may request information from the server system which responds to the client by providing the requested information. For this reason a server system will typically have more computing and storage capacity than client systems and indeed the server system may be a gateway and content manager for providing access to content storage and related repository services as further described below. However a particular computer system may act as either a client or a server depending on whether the computer system is requesting or providing information. Further although aspects of the subject matter disclosed herein are described as using a client server environment it should be apparent that the subject matter may be embodied in other ways for example as a stand alone computer system or part of a cloud computing environment.

Server system receives requests for information from one or more of client systems and performs processing in order to satisfy the requests then forwards the resultant information back to the requesting client system. The processing required to satisfy the request may be performed by server system or may alternatively be delegated to or obtained with the help of other servers connected to communication network or to server system .

Client systems enable users to access and query information stored or managed by server system . In one embodiment a web browser application executing on a client system enables users to select access retrieve and or query information stored or managed by server system . Examples of web browser programs include the Internet Explorer browser by Microsoft Corporation the Firefox browser by Mozilla Foundation and others.

Mass storage devices may include disk drives floppy disks magnetic disks optical disks magneto optical disks fixed disks hard disks CD ROMs recordable CDs DVDs recordable DVDs e.g. DVD R DVD R DVD RW DVD RW HD DVD or Blu ray Disc flash and other nonvolatile solid state storage e.g. USB flash drive battery backed up volatile memory tape storage reader and other similar media and combinations of these.

The subject matter described herein may be computer implemented in a suitable system by providing computer executable instructions stored on a non transitory computer readable medium. A computer readable medium may include any medium that participates in providing instructions to one or more processors for execution. Such a medium may take many forms including but not limited to nonvolatile volatile and transmission media. Nonvolatile media includes for example flash memory or optical or magnetic disks. Volatile media includes static or dynamic memory such as cache memory or RAM. Transmission media includes coaxial cables copper wire fiber optic lines and wires arranged in a bus. Transmission media can also take the form of electromagnetic energy radio frequency signals acoustic or light waves such as those generated during radio wave and infrared data communications.

For example a binary machine executable version of software instructions for providing the features described herein may be stored or reside in RAM or cache memory or on mass storage device . The source code of the software may also be stored or reside on mass storage device e.g. hard disk magnetic disk tape or CD ROM . As a further example software code may be transmitted via wires or radio waves or downloaded through a network such as the Internet.

A system block diagram of the computer system workstation is shown in . The display monitor keyboard and storage devices are as shown in . The CPU cabinet contains key components such as central processor system memory input output I O controller display adapter serial or universal serial bus USB port network interface and speaker . In other embodiments a computer system may include more or fewer components and or subsystems. For one example a computer system could include more than one processor i.e. a multiprocessor system or a system may include a cache memory.

The system bus of computer system are exemplary of an interconnection scheme serving to link the subsystems. For example speaker could be connected to the other subsystems through a port or have an internal direct connection to central processor . The processor may include multiple processors or a multi core processor which may permit parallel processing of information. Computer system is only one example of a suitable computer system. Other configurations of components and or subsystems suitable for use with the methods described herein will be readily apparent to one of ordinary skill in the art.

Computer software products may be written in any of various suitable programming languages such as C C C Pascal Fortran Perl Matlab from MathWorks SAS SPSS JavaScript AJAX Java SQL and XQuery. A computer software product may be an independent application with data input and data display modules. Alternatively computer software products may be classes that are instantiated as distributed objects or component software such as Java Beans or Enterprise Java Beans both by Oracle Corporation . In one embodiment the subject matter described herein is embodied as a computer program product which stores instructions such as computer code that when executed by a computer cause the computer to perform the processes and or techniques described below.

The computer system runs an operating system OS to manage hardware resources and provide common application services for application software. As an example the computer may run a Microsoft Windows operating system e.g. Windows NT Windows XP Windows Vista Windows 7 Windows CE Windows Mobile or Linux UNIX Sun OS Solaris Mac OS X Alpha OS AIX IRIX32 or IRIX64. Other operating systems may also be used.

The client applications originate from client devices such as devices which communicate through a network with an application server in order to use one or more applications hosted on the application server. In one embodiment the network is an Ethernet connection using conventional TCP IP communication methods with both client devices and server devices. However other types of network connection technologies are well known and may also be used to full advantage including local area network LAN wide area network WAN storage area network SAN the Internet etc. Client devices may be any type of processor based digital device such as desktop or laptop computer iPhone or other smart hand held device or other.

The application server hosts one or more applications running on a content management platform that provide access to repository for clients hosted on content server which is also accessible to clients via network . An HTTP server is also coupled to the network to provide an administrative terminal for system operators to perform system maintenance logging access control etc. as further described below. In particular the system operator may initiate a dormant state for server components to facilitate patches upgrades load balancing and other useful operations as further described below.

The repository is provided for use by client applications through the content server which is accessible to the client devices through a network . The repository may include a file store for storing content items a relational database for storing attributes metadata associated with the content items a full text index store for the content items and directory services .

A software platform runs on each of the various components such as the EMC Documentum Platform software and related EMC Enterprise Content Management software distributed by EMC Corporation Hopkington Mass. The Documentum Platform provides capabilities for managing enterprise content and is the foundation for related content management and case management product offerings.

For example shows one simplified embodiment of the application server which runs a content management framework having a foundation layer such as Documentum Foundation Classes DFC an interface layer such as Documentum Foundation Services DFS and one or more applications on application layer having integrated Documentum functionality through a Web Development Kit WDK or Webtop for example. The HTTP server runs a similar content management framework for applications such as System Administrator or Intranet Client.

DFC is the programming interface for accessing the functionality of the Documentum platform through Java and COM class libraries and underlies all Documentum platforms. DFS is an SOA development framework and application programming interface API based on web services and designed to support interoperable machine to machine interaction over a network. DFS is now the primary interface for most developers and users of the Documentum platform although use the terms DFC and DFS are frequently although incorrectly used interchangeably.

The Documentum platform also includes an extensible Business Objects Framework BOF which is built into DFC. BOF provides a useful framework and methodology for developing reusable business logic components called Business Objects that can be plugged into middle tier or client applications. More information about the Documentum Platform and related content management and case management product offerings can be found on the EMC website located at URL www.emc.com.

A faster route for content transfers is through an Accelerated Content Server ACS . ACS is installed with each content server installation including primary content server CS and remote content server RCS and provides direct access to content on the content server machine for synchronous or asynchronous transfer to a local cache . ACS is installed as a web application in the embedded application server as part of each content server and is run as a Java Method Server. The local cache is called a Branch Office Caching Server BOCS in the Documentum platform and is a light weight cache server that allows remote users to read and write content from to local servers. The Documentum Messaging Server receives and delivers messages between applications such as requests for action from DFC on the application server to the BOCS .

Note that the connection broker does not request information from the content server but relies on the server to regularly broadcast or project its status connection information to the connection broker. This feature i.e. which connection broker to project to is set in the configuration file config.ini on each server.

According to several embodiments described herein server components may be configured with a dormant state of operation wherein no new connections with clients are accepted and existing connections sessions are made read only. Any pending transactions in existing sessions are preferably completed prior to moving to read only status. When a server is in the dormant state its status at the connection broker will be updated and the connection broker will notify end users that new connections can be made to that server.

The dormant state will be invoked through program instructions executed in relevant computer implemented components for example using a remote procedure call RPC in the server and application programming interfaces APIs in other components having DFC and DFS frameworks. Examples of such instructions are included in the Appendix below. Instructions should also include status checks to see whether the selected components are in the dormant state or not.

The dormant server state may be useful to help avoid overloading issues. For example a server that appears to be failing or becoming overloaded may be moved to a dormant state so that it can avoid processing new tasks and simply complete processing of its existing load if possible. The server may then be taken offline for evaluation upgrade repair or replacement as necessary.

The dormant state may be used to provide system flexibility for example by being part of a scheme to balance loads across a system of multiple servers or to allocate the deployment of resources dynamically in a multiple server system.

The dormant state may also be useful to make component and or system upgrades such as a software patch service pack minor release or major release. For example in one embodiment described below the dormant state facilitates performing upgrades in a multiple server system by moving one server at a time to the dormant state upgrading the server then returning the server to active service.

The dormant state can only be set or reset by members of a privileged access group. For example a group called Data Center Managers dm datacenter managers can be established and maintained by a superuser and or group administrator to use and administer a server or server cluster resource with among other things the techniques described herein.

In one embodiment the dormant state may be implemented in a server through the process shown in . In step a request to change state to a dormant mode is received by the server for example as sent by a user such as Data Center Manager. In step the authorization of the user making the request is tested. If the user is not authorized for this operation i.e. a member of the Data Center Managers group then an error is generated in step . If the user is authorized in step then the server proceeds to process the state change request in step as further illustrated in . When the processing associated with the state change request is complete the server waits in step to be placed back into active service.

One embodiment for processing the state change request of step is illustrated in . In step the server is configured to not accept any new connections from regular users but see exception for privileged users below . The server then checks in step to see if there are any existing connections. If not then in step the server is changed to a read only state and other system components are notified accordingly as necessary in step . If there are existing connections then in step the server checks to see if there are open transactions pending for these sessions. If not then the server moves to the read only state in step . If there are open transactions in the existing connections in step then those transactions are allowed to commit or abort in step before the server is moved to the read only state in step .

The objectives of the dormant state for a content server are largely met by prohibiting new connections to the server and by allowing server content to be accessed in a read only mode. However an exception to the prohibition against new connections may be provided for the privileged user group to allow them to connect and perform regular content server and repository transactions as well as administrative tasks. However if these privileged users want to perform update operations they need to explicitly enable that feature in the configuration object.

In the context of the content management system described above in addition to providing notification of the changed server state there are other restrictions that may need to be enforced by the content server upon entering a dormant state. For example where the content server manages a repository the elements of the repository can also be made read only through the content server no changes can be made to content in the file system to metadata in the database or to the repository index. Further the job agent which normally schedules and processes jobs for the server is prohibited from processing jobs and methods are prohibited from launching through the Java Method Server by not sending any HTTP post instructions.

In addition to the content server other components may need to be made dormant or at least have their behaviors defined for the times when one or more content servers is dormant. For example when a content server is moved to a dormant state the ACS associated with that content server should also be moved to a dormant state. The dormant status of the ACS should be persisted for example in the ACS configuration object. When the ACS is moved to the dormant state no new read or write operations for content are allowed. However all read and write operations that are currently running are allowed to complete. Instructions to set the dormant state and check the dormant status of the ACS are implemented as APIs in the ACS.

The connection broker may also be set to a dormant state and that status persisted. When dormant the connection broker will not send a server map in response to a client request and may stop receiving status projections from other components like content server and ACS . Instructions to set the dormant state and check the dormant status of the connection broker are implemented as APIs which will be used by the DFS to check if it can pull information from the connection broker and by the ACS to see if it can project information to the connection broker.

The Java Method Server will generally not be moved to a dormant state largely because some instances of the JMS can be shared by multiple servers. This can be readily handled by having the server in its dormant state not post method execution requests to the JMS. If all servers using a particular JMS become dormant then the JMS will simply have no methods to execute.

These steps are more clearly illustrated in the sequence diagram for a state change in the content server and related components shown in . As noted above these changes may be implemented through suitable instructions formed in remote procedure calls RPCs in the content server and application programming interfaces APIs in the other components examples of which are provided in the Appendix below. In a Data Center Manager with suitable privileges makes a request for the state change typically through a client device or admin terminal located internally to the content management system for example at the HTTP server rather than externally through the client application layer . The request is sent to the DFC layer in step . The state change request triggers a RPC in the content server to requestDormancy in step . In step the content server registers the state change request. In step the result success or failure is reported backed to the DFC which likewise reports back to the Data Center Manager in step .

When the state change is registered with the content server in step the content server also projects the changed state to the connection broker in step and initiates a request for the ACS server to also change state in step . Step is a loop run in the ACS that checks for any state change requests from the content server e.g. in step . When a state change request is received by the ACS it changes state in step then either stops processing requests if changed to dormant state or allows requests if changed to active state in step . The status change is then projected to the connection broker in step .

In upon receiving a dormancy request the content server waits for current sessions to either commit or abort. For example the content server waits for open data collections to close step stops all post requests to the Java Method Server step waits for all open transactions to close step and makes any current sessions read only step .

Finally in step the content server is moved to the requested state. If the requested state is the active state then after the ACS changes state the content server is moved to the active state. If the requested state is the dormant state then after current sessions are committed or aborted the content server is moved to the dormant state.

These steps are more clearly illustrated in the sequence diagram for a state change in a server cluster as shown in . A Data Center Manager requests a state change which is sent to the DFC layer in step . The state change request triggers a RPC in the repository server to requestDormancyforRepository in step . In step the repository server marks the state change request and in step the changed record count is incremented.

This leads to a loop to check for a change is the record count with the Change Checker thread in step and when it has changed that result is returned to the repository in step . The Change Checker queries the content server to make that determination in step by running a loop in step until the serverList is not empty. In step the Change Checker issues an instruction to request a state change for the server and in step the result is returned.

Related sequence diagrams for checking the status of a single content server and a multi server cluster are shown in respectively. In the Data Center Manager requests a status check on the dormant status for the repository in step which causes the DFC to trigger a RPC in the content server to checkDormantStatus in step . The content server runs a routine to identify the non persistent state of the server in step and returns that result to the DFC in step which in turn delivers the result to the Data Center Manager in step . Similarly in the Data Center Manager requests a status check on the dormant status of the repository server in step which causes the DFC to trigger a RPC in the repository server to checkRepositoryStatus in step . The repository server retrieves the state of the server from its configuration file in step returns the status to the DFC in step which delivers the result to the Data Center Manager in step .

In a case where multiple servers a server cluster are connected to the same repository it is desirable to avoid taking the entire production system offline to make changes for example software upgrades patches and or releases. This can be avoided by providing a dormant state for the servers thereby allowing one server at a time to be taken offline changes made and the server returned to active service. The other servers in the cluster will handle new and existing sessions while one or more servers is dormant. This rolling upgrade procedure is illustrated in .

In with all content servers active the application server DFC seeks to create a new session on behalf of a client device and thus contacts the connection broker connection to refresh the current active server map. The connection broker provides a list of active servers back to the application server connection . The DFC then establishes a session with one of the active servers through one of the connections or .

In however the admin has selected an instance of the content server dashed box to move to a dormant state. Upon entering the dormant state the selected content server projects its changed status to the connection broker connection and the connection broker thereafter knows not to send any new sessions to that content server. Further existing sessions with content server connection are informed that the server has entered the dormant state and become read only.

In the selected content server can be maintained upgraded or replaced as necessary while in the dormant state and then returned to active service only when appropriate.

One process for performing a rolling upgrade of one server at a time is illustrated in . A server count x is initialized in step e.g. set equal to one. Other selection or indexing criteria could be used by the Data Center Manager to pick and choose servers. In step the Data Center Manager requests that the selected server be set to the dormant state. Before setting the server to the dormant state however the server checks to see if all pending sessions have been committed or aborted in step . If not then the process waits for a predefined interval step which is set in the configuration file for the server and checks again in step .

When all pending sessions have been committed or aborted in the check of step then the server is set to the dormant state in step . As described above the server will not allow any new connections while in the dormant state. The Data Center Manager makes changes in step for example software upgrades patches service packs and releases which may include shutting down the server before loading the new software. After loading the new software the server is restarted in step with a new binary dump. The server count is incremented n step and if the server count has not reached the maximum then the process returns to step to perform the upgrade on the next server. If the server count has reached its maximum the process ends in step .

An example of a service pack upgrade is illustrated in . In the production system is placed into the dormant mode as shown by the dashed box. Further the production system operates on read only snapshot of the file system taken at a discrete point in time. In a writable copy of the snapshot is created and upgrades are performed directly on the file system in the snapshot copy. If the upgrade is successful then users are moved to the upgraded copy of the production system .

A process for providing the service pack upgrade is illustrated in . Many servers regularly take a point in time snapshot image of the file systems and in step the Data Center Manager obtains a current point in time snapshot of the file system. In step the Data Center Manager requests that all servers in the file system be moved to the dormant state and in step that the file system be operated on a read only basis on the snapshot copy of the file system.

In step a writeable copy is created from the point in time snapshot which is used to perform the upgrade in step . If the upgrade is successful step then the servers are returned to the active state based on the upgraded copy step and all users are moved to the upgraded copy step . The read only snapshot is discarded in step and the process is done.

If the upgrade was unsuccessful in step then the writable snapshot is discarded step the point in time snapshot is placed into a writable mode step and the servers are returned to the active state based on the writable point in time snapshot copy step .

Use of the dormant state may also provide an effective means for load balancing in a server cluster. The server loads are distributed generally by the connection broker. By setting one or more servers into a dormant mode the connection broker can redistribute loads to other active servers. This would force reduced loading before it becomes problematic.

For example a simple process is shown in . In step a load threshold is set. In step each of the server loads in the cluster is monitored for example by a user in the Data Center Manager group or with a monitoring software routine in the server itself. In step monitored server loads are periodically compared to the threshold. If no server loads exceed the threshold step then the process continues to monitor in step and periodically make comparisons in step . If a server load does exceed the threshold in step then that server is handled by a load balancing module in step and the process returns to the monitoring step.

In the steps carried out by the load balancing module are shown. In step the overloaded server is placed into the dormant state. At this point no new connections are accepted from client users and the server status is projected to the connection broker i.e. changed state to dormant. In step pending transactions on existing connections are continued until complete or the server load has fallen to within acceptable limits. Step checks to see if all pending transactions are complete. If not return to step . If so the server is returned to the active state in step .

Of course one could also use the dormancy requested state described above rather than the dormant state since the dormancy requested state is provided specifically to complete or terminate pending transactions and connections. Such a process would simply comprise moving the server to the dormancy requested state waiting for pending transactions to complete or terminate then returning to the active state.

There are numerous ways to monitor performance and obtain performance metrics from the server system. For example machine resources such as shared memory CPU usage file handles are readily available from the operating system. Resources of the content server may also be monitored and evaluated such as internal cache usage response time for each RPC or each user transaction size of database tables configuration settings for workflow agents database usage and file system usage. Activity response times may be recorded and stored in shared memory or this information may be obtained through a query from DFC. Global cache and session cache are monitored for cache consumption.

The content server and other components provide an interface to return performance metrics data so that it may be aggregated and analyzed. A service may be called or run to collect relevant information.

Sometimes server deployments need to be scaled up or down to meet load requirements. Using the dormant mode can be an effective method of scaling down a deployment. Scaling up is simply a matter of adding another server to the server cluster.

For example shows a simple process for scaling up or scaling down a server deployment. In step the connection broker maintains information about ongoing load requirements and available server capacity. In step the connection broker distributes loads equally across all servers in the cluster. The connection broker periodically evaluates the load requirements and in step considers whether more capacity is needed based upon collected metrics. If so then one or more servers is added to the cluster in step . The connection broker is updated in step then returns to maintain and distribute loads in steps and . If more capacity was not called for in step then the question of whether less capacity is needed based upon collected metrics in considered in step . If not then the process returns to maintain and distribute loads in steps and . If so then one or more servers is moved to a dormant state in step then the connection broker is updated in step and returns to maintain and distribute loads in steps and . Any of the dormant state techniques previously described could be incorporated.

A status indicator called DormantStatus is provided to enumerate the present state for the relevant server or repository and has the state values of ACTIVE 1 DORMANT 2 or DORMANCY REQUESTED 3 .

The following new methods instructions are added as a method IDfSession to the API s in the DFC layer 

This instruction initiates a request to change the state of the server to which a session is connected to the dormant state. The dormant state is not persistent and the server will become active by default upon a restart or re initialization. The requestDormancy instruction will return a True result if the request succeeds False if not and will throw a DfException if an error occurs.

This instruction checks the status of the server to which this session is connected and returns DormantStatus as an enumeration representing the status of the requested entity. A value of ACTIVE means the entity is active a value of DORMANCY REQUESTED means that the entity has submitted a request to become dormant and a value of DORMANT means the entity is dormant. The instruction will throw a DfException if an error occurs while requesting status.

This instruction sends a request to move the server to which this session is connected to an active state. The instruction will return True if the request succeeds False if not and will throw a DfException if an error occurs while requesting dormancy.

This instruction sends a request to move the repository or server to a dormant state. When the parameter allServersForThisRepository is True dormancy is requested for this repository. This state is persistent for the repository and will have to be explicitly made active. When false dormancy is requested only for the server through which this session is connected. The instruction will return True if the request succeeds False if not and throws a DfException if an error occurs while requesting dormancy.

This instruction checks to see whether a server or repository is dormant or not. When the parameter allServersForThisRepository is true a status check is requested for this repository. When false a status check is requested only for the server through which this session is connected. The instruction will return a DormantStatus enumeration representing the status of the requested entity ACTIVE means that the entity is active DORMANCY REQUESTED means that the entity has submitted a request to become dormant DORMANT means the entity is dormant. The instruction will throw a DfException if an error occurs while requesting status.

This instruction sends a request to move the repository or server to an active state. When the parameter allServersForThisRepository is True the request is to make the entire repository active. When false the request is to make only the server to which this session is connected active. The instruction will return True if the request succeeds False otherwise and throws a DfException if an error occurs while requesting dormancy.

This instruction enables a save operation for dormant state. When a server or repository is dormant no save operations are allowed. A privileged user in the dm datacenter managers group has to explicitly enable save operation. This method serves that purpose and will return True if the save was enabled for the user of this session False otherwise and throws a DfException if an error occurs while enabling save.

This instruction disables save operation for the dormant state. When a privileged user from the dm datacenter managers group has enabled the save operation it can be disabled back again after performing necessary operation in the dormant state. This method allows the user of this session to disable save operations. The method will return True if the save was disabled for the user of this session False otherwise and throws a DfException if an error occurs while disabling save.

This instruction only projects to the connection broker that this server is dormant. The server could actually be active. After calling this method no new connections are made to that server. It will have no impact on existing connections or activities that do not require a new connection. The instruction will return True if projection to connection broker was successful False otherwise and throws a DfException if an error occurs while projecting dormant status to connection broker.

This instruction only projects to connection broker that this server is active. The server could actually be active. Ideally this instruction is called after a call to the method projectDormantStatus and will return True if the projection to connection broker was successful False if not a DfException will be thrown if an error occurs while projecting dormant status to connection broker or if the server is in DORMANT state and this method is called to make it ACTIVE.

A generic RPC called DATACENTER OPERATION is provided to support all datacenter related operations of which dormancy is one. The following are the dormancy related datacenter operations and parameters 

This checks the state of the server repository. The CHECK DORMANCY operation is different from other operations because it can be run by any user in the repository instead of being restricted to only privileged users like the Data Center Managers group.

This flag indicates whether dormancy needs to be applied to all servers serving a repository or just to the server that is connected for the current session 

This parameter reflects the state to which this server repository is being moved. This parameter is meaningful only when the value for DATACENTER OPERATION is REQUEST DORMANCY. Valid values are ACTIVE state change is going back to the normal state or DORMANT state change is going back to the dormant state.

This flag indicates to the server that it should only project its status i.e. dormant or active to the connection broker. This is used primarily when the server sees its load increasing and wants to reduce the load. For example if the OPERATION is REQUEST DORMANCY and the REQUEST STATE is DORMANT then if PROJECTION ONLY is set to TRUE then the server will project its status to the connection broker as dormant even though it is actually active. However if the OPERATION is REQUEST DORMANCY and the REQUEST STATE is ACTIVE then if PROJECTION ONLY is set to TRUE then the server will project its status to the connection broker as active. The server may be active but had previously informed the connection broker it was dormant. If the server is dormant and the PROJECTION ONLY flag is set to true while making the server active it will throw an error. Also marking a server as dormant with this flag set to true should stop the server projection to the connection broker until it is explicitly called to make the server active.

This is a Boolean flag when True the requested operation was successful when False the operation was unsuccessful.

This is an attribute that will be set when either REQUEST DORMANCY or CHECK DORMANCY is executed and provides more detail regarding the operation. If RESULT is False then this attribute could contain an error messaging with the details of the failure. If RESULT is True then this attribute could have the following values ACTIVE DORMANCY REQUESTED or DORMANCY.

