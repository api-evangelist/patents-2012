---

title: Method and system for providing coordinated checkpointing to a group of independent computer applications
abstract: A method and system of checkpointing single process application groups and multi-process application groups. In an exemplary embodiment, the method may include creating at least one full checkpoint for each application in an application group, and creating at least one incremental application checkpoint for each application in the application group. Further, each of the at least one incremental application checkpoint may be automatically merged against a corresponding full application checkpoint. Further, checkpointing may be synchronized across all applications in the application group. In the exemplary embodiment, each application may use both fork( ) and exec( ) in any combination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08645754&OS=08645754&RS=08645754
owner: Open Invention Network, LLC
number: 08645754
owner_city: Durham
owner_country: US
publication_date: 20121228
---
This application is a continuation of U.S. application Ser. No. 13 301 980 filed on Nov. 22 2011 entitled METHOD AND SYSTEM FOR PROVIDING COORDINATED CHECKPOINTING TO A GROUP OF INDEPENDENT COMPUTER APPLICATIONS now issued U.S. Pat. No. 8 347 140 issued on Jan. 1 2013 which in turn is a continuation of U.S. application Ser. No. 12 334 634 filed on Dec. 15 2008 entitled METHOD AND SYSTEM FOR PROVIDING COORDINATED CHECKPOINTING TO A GROUP OF INDEPENDENT COMPUTER APPLICATIONS now issued U.S. Pat. No. 8 078 910 issued on Dec. 13 2011 each of which are incorporated herein by reference in their entirety. This application is related to U.S. provisional application Ser. No. 60 797 219 filed on May 2 2006 U.S. patent application Ser. No. 11 213 678 filed on Aug. 26 2005 now issued U.S. Pat. No. 8 122 280 issued on Feb. 21 2012 and U.S. patent application Ser. No. 11 741 535 filed on Apr. 27 2007 now issued U.S. Pat. No. 7 681 075 issued on Mar. 16 2010 each of which are incorporated herein by reference in their entirety.

A portion of the material in this patent document is subject to copyright protection under the copyright laws of the United States and of other countries. The owner of the copyright rights has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the United States Patent and Trademark Office publicly available file or records but otherwise reserves all copyright rights whatsoever. The copyright owner does not hereby waive any of its rights to have this patent document maintained in secrecy including without limitation its rights pursuant to 37 C.F.R. 1.14.

This invention pertains generally to enterprise computer systems computer networks embedded computer systems wireless devices such as cell phones computer systems and more particularly with methods systems and procedures i.e. programming for providing high availability virtualization and checkpointing services for a group of computer applications

Enterprise and wireless systems operating today are subject to continuous program execution that is 24 hours a day and 7 days a week. There is no longer the concept of overnight or planned downtime . All programs and data must be available at any point during the day and night. Any outages or deteriorated service can result in loss of revenue as customers simply take their business elsewhere and the enterprise stops to function on a global scale. Traditionally achieving extremely high degrees of availability has been accomplished with customized applications running on custom hardware all of which is expensive and proprietary. Furthermore application services being utilized today are no longer run as single applications or processes instead they are built from a collection of individual programs jointly providing the service. Traditionally no mechanisms have existed for protecting such multi application services. This problem is compounded by the fact that the individual applications comprising the service are typically provided by different vendors and may get loaded at different times

Two references provide a background for understanding aspects of the current invention. The first reference is U.S. patent application Ser. No. 11 213 678 filed on Aug. 26 2005 now issued U.S. Pat. No. 8 122 280 issued on Feb. 21 2012 incorporated above in its entirety which describes how to provide transparent and automatic high availability for applications where all the application processes run on one node. The second reference is U.S. Pat. No. 7 293 200 filed on Aug. 26 2005 which describes how to transparently provide checkpointing of multi process applications where all processes are running on the same node and are launched from one binary. The present invention is related to applications comprised of one or more independent applications where the independent applications dynamically join and leave the application group over time.

A method system apparatus and or computer program are described for achieving checkpointing restoration virtualization and loss less migration of application groups. The invention provides transparent migration and fail over of application groups while ensuring that connected clients remain unaware of the migration. The client s connection and session are transparently transferred from the primary to the backup server without any client involvement.

The term checkpointing and checkpointing service is utilized herein interchangeably to designate a set of services which capture the entire state of an application group and stores all or some of the application group state locally or remotely. The checkpointing services run execute on all nodes where one or more the application group s applications run execute or can fail over to.

The term node is utilized herein to designate one or more processors running a single instance of an operating system. A virtual machine such as VMWare or XEN VM instance is also considered a node . Using VM technology it is possible to have multiple nodes on one physical server.

The term application group is utilized herein to describe a set of independent applications that jointly provide a service. The term independent is utilized herein to mean that the applications need no prior knowledge of each other. An application group is simply a logical grouping of one or more applications that together or independently provide some service. The independent applications do not need to be running at the same time. A member of the application group can also load perform work and exit essentially joining and leaving the group.

The terms application and independent application are utilized interchangeably to designate each of the applications in an application group. Each independent application can consist of one or more processes and be single threaded or multi threaded. Operating systems generally launch an application by creating the application s initial process and letting that initial process run execute. In the following teachings we often identify the application at launch time with that initial process and then describe how to handle creation of new processes via fork and or exec.

In the following we use commonly known terms including but not limited to process process ID PID thread thread ID TID disk CPU storage memory address space semaphore System V SysV and signal . These terms are well known in the art and thus will not be described in detail herein.

The term coordinator is utilized for designating a special control process running as an element of the invention. The coordinator is generally responsible for sending out coordination events managing application group registration and for coordinating activities across all applications in an application group. For the sake of simplicity the coordinator is often depicted as running on the same node as the application group however this is not a requirement as the coordinator can run on any node.

The term transport is utilized to designate the connection mechanism and or protocols used for communicating across the distributed application. Examples of transport include TCP IP Message Passing Interface MPI Myrinet FiberChannel ATM shared memory DMA RDMA system busses and custom backplanes. In the following the term transport driver is utilized to designate the implementation of the transport. By way of example the transport driver for TCP IP would be the local TCP IP stack running on the host.

The term fork is used to designate the operating system mechanism used to create a new running process. On Linux Solaris and other UNIX variants a family of fork calls are provided. On Windows one of the equivalent calls is CreateProcess . Throughout the rest of this document we use the term fork to designate the functionality across all operating systems not just on Linux Unix. In general fork makes a copy of the process making the fork call. This means that the newly created process has a copy of the entire address space including all variables I O etc of the parent process.

The term exec is used to designate the operating system mechanism used to overlay a new image on top of an already existing process. On Linux Solaris and other UNIX a family of exec calls are provided. On Windows the equivalent functionality is provided by e.g. CreateProcess via parameters. Throughout the rest of this document we use the term exec to designate the functionality across all operating systems not just Linux Unix. In general exec overwrites the entire address space of the process calling exec . A new process is not created and data heap and stacks of the calling process are replaced by those of the new process. A few elements are preserved including but not limited to process ID UID open file descriptors and user limits.

The term shell script and shell is used to designate the operating system mechanism to run a series of commands and applications. On Linux Solaris and other Unix variants a common shell is called bash . On Windows equivalent functionality is provided by cmd.exe and .bat files or Windows PowerShell. Examples of cross platform scripting technologies include JavaScript Perl Python and PHP. Throughout the rest of this document we use the term shell and shell script to designate the functionality across all operating systems and languages not just Linux Unix.

The term interception is used to designate the mechanism by which an application re directs a system call or library call to a new implementation. On Linux and other UNIX variants interception is generally achieved by a combination of LD PRELOAD wrapper functions identically named functions resolved earlier in the load process and changes to the kernel sys call table. On Windows interception can be achieved by modifying a process Import Address Table and creating Trampoline functions as documented by Detours Binary Interception of Win32 Functions by Galen Hunt and Doug Brubacher Microsoft Research July 1999 . Throughout the rest of this document we use the term to designate the functionality across all operating systems.

In the following descriptions the product name Duration is utilized in referring to a system as described in the first and second references cited previously. It should be appreciated however that the teachings herein are applicable to other similarly configured systems.

By way of example consider an e Commerce service consisting of a WebLogic AppServer and an Oracle Database. In this case WebLogic and Oracle would be the independent applications and the application group would consist of WebLogic and Oracle database.

By way of example consider a cell phone with an address book and built in navigation system. In this case the address book and the navigation would be the independent applications and the application group would consist of the address book and the navigation application.

By way of example consider a shell script running a series of applications and other scripts. In this case the script and all applications and scripts launched by the script comprise the application group and all the individual applications and other scripts called within the script are the independent applications.

The two references sited above cover the cases where the multi process applications are created starting with one binary. As described in U.S. Pat. No. 7 293 200 this is generally accomplished by the application using a series of fork calls to create new sub processes. The present invention broadens the checkpointing services to cover all types of multi process applications including those that exec .

In at least one embodiment a method of checkpointing single process application groups and multi process application groups is provided. The method may include

In at least one embodiment a special mechanism is provided to handle exec only calls. With exec essentially overwriting the entire address space of the calling process all registration and checkpointing information is lost. Special care needs to be taken to preserve this information across the exec call. One example embodiment of the present invention provides a mechanism to preserve such information using a combination of shared memory and environment variables.

In at least one embodiment checkpointing services are configured for automatically performing a number of application services including injecting registration code into all applications in the application group during launch registering the group s application as they launch detecting execution failures and executing from backup nodes in response to application group failure application failure or node failure. The services can be integrated transparently into the system in that they are implemented on the system without the need of modifying or recompiling the application program without the need of a custom loader or without the need for a custom operating system kernel. In another embodiment a custom loader is used.

In at least one embodiment the checkpointing services are configured to support fork and exec in any combination. Exec without an prior fork overwrites the entire address space of the application including all registration with the coordinator fault detectors etc. The present invention provides techniques to handle the fact that all memory and registration information is being overwritten during exec .

In at least one embodiment the checkpointing services supports shell scripts where the core shell script application launches using fork exec and overlays using exec new independent applications in any order.

The present invention comprises a set of checkpointing services for application groups. The checkpointing services run on every node where the group application can run. One embodiment of the invention generally functions as an extension of the operating system and runs on all nodes. A coordination mechanism is utilized to ensure that the execution of the independent applications are coordinated at certain points.

By way of example and not of limitation the present invention implements checkpointing services for stateless applications e.g. sendmail stateful applications e.g. Voice over IP VOIP multi tier enterprise applications e.g. Apache WebLogic and Oracle Database combined wireless devices such as cell phones pages and PDAs and large distributed applications for example those found in High Performance Computing HPC such as seismic exploration and financial modeling.

According to one aspect of the invention the application group runs on a node with one or more of the independent applications running at any point in time. Each independent application is running independently but is protected and checkpointed together with all other independent applications in the application group.

According to one aspect of the invention the application group has one or more backup nodes ready to execute the independent application in the place of the original in the event of a fault. The protection of the application group is thus coordinated and guaranteed to be consistent across fault recovery.

An application group can be configured according to the invention with any number of independent applications. Each independent application runs on the primary node while the backup node for the applications stands ready to take over in the event of a fault and subsequent recovery. The primary and backup can be different nodes or the primary and backup can be the same node in which case the fault recovery is local.

The invention provides layered checkpointing services for application groups with checkpointing services provided both at the application group level and at the individual independent application level. High availability including fault detection and recovery for the individual independent application is provided by Duration s existing stateful High Availability Services. The invention layers a distributed fault detection and recovery mechanism on top of the local fault detection and ensures that fault detection and recovery is consistent across the entire grid.

According to one aspect of the invention a coordinator provides general coordination and synchronization for the individual independent applications of the group applications. By way of example and not limitation the coordinator is shown running on the same node as the independent applications to simplify the following teachings. It should be appreciated however that this is not a requirement as the coordinator can run on any node in the system.

By way of example and not of limitation the invention implements stateless or stateful recovery of application groups by recovering each independent application and ensuring all independent applications are recovered in a consistent state. The recovery is automatic without any application group or independent application involvement.

According to an aspect of the invention there is a clean separation of the application logic from the checkpointing services code. This allows application programmers to focus on writing their application code rather than on writing checkpointing code. An administrator can make applications highly available by simply configuring the desired settings such as by using a graphical configuration tool implemented according to the invention. The result is that high availability applications are developed easily and deployed quickly without the necessity of custom coding.

According to another aspect of the invention protection is provided against node faults network faults and process faults. The present invention provides user controlled system management automatic availability management and publish subscribe event management including notification of faults and alarms.

In various embodiments of the invention features are provided that are useful for application groups that must be highly available including but not limited to the following 

The invention can be practiced according to various aspects and embodiments including but not limited to those described in the following aspects and embodiments which are described using phraseology which is generally similar to the claim language.

According to an aspect of the invention a method for achieving transparent integration of a application group program with a high availability protection program comprises a injecting registration code transparently and automatically into all independent applications when they launch without the need of modifying or recompiling the application program and without the need of a custom loader b registering the independent applications automatically with the high availability protection program c detecting a failure in the execution of the application group or any independent application within the group and d executing the application group with application group being executed from their respective backup servers automatically in response to the failure. The high availability protection program is preferably configured as an extension of the operating system wherein recovery of application groups can be performed without modifying programming within said application programs. The high availability protection can be configured for protecting against node faults network faults and process faults.

According to another aspect of the invention a method system improvement or computer program for performing loss less migration of an application group including loss less migration of all independent applications from their respective primary nodes to their backup nodes and while being transparent to a client connected to the primary node over a TCP IP MPI system bus or other transport. The transport i.e. TCP IP MPI or system bus will optionally be flushed and or halted during checkpointing.

According to another aspect of the invention a method system improvement or computer program performs loss less migration of an application group comprising a 

According to another aspect of the invention a method system improvement or computer program performs fault protection for applications distributed across multiple computer nodes comprising a providing high availability application services for transparently loading applications registering applications for protection detecting faults in applications and initiating recovery of applications b taking checkpoints of independent applications within applications groups c restoring the independent applications from the checkpoints in response to initiating recovery of one or more the applications d wherein said high availability application services are provided to the independent applications running on a primary node while at least one backup node stands ready in the event of a fault and subsequent recovery and e coordinating execution of individual independent applications within a coordinator program which is executed on a node accessible to the multiple computer nodes.

According to another aspect of the invention a method system improvement or computer program performs loss less migration of an application group comprising a a high availability services module configured for execution in conjunction with an operating system upon which at least one application can be executed on one or more computer nodes of a distributed system and b programming within the high availability services module executable on the computer nodes for loss less migration of independent applications b i checkpointing of all state in the transport connection b ii coordinating checkpointing of the state of the transport connection across the application group b iii restoring all states in the transport connection to the state they were in at the last checkpoint b iv coordinating recovery within a restore procedure that is coupled to the transport connection.

According to another aspect of the invention there is described a method system improvement and or computer program for maintaining all transport connection across a fault. Transport connections will be automatically restored using Duration s virtual IP addressing mechanisms.

Another aspect of the invention is a method system improvement and or computer program that provides a mechanism to ensure that the independent applications are launched in the proper order and with the proper timing constraints during recovery.

In one embodiment a mechanism is also provided to ensure that application programs are recovered in the proper order.

Another aspect of the invention is a method system computer program computer executable program or improvement wherein user controllable launch of independent applications for the application group is provided.

Another aspect of the invention is a method system computer program computer executable program or improvement wherein user controllable stop of independent applications and application group is provided.

Further aspects of the invention will be brought out in the following portions of the specification wherein the detailed description is for the purpose of fully disclosing preferred embodiments of the invention without placing limitations thereon.

Referring more specifically to the drawings for illustrative purposes the present invention will be described in relation to through . It will be appreciated that the system and apparatus of the invention may vary as to configuration and as to details of the constituent components and that the method may vary as to the specific steps and sequence without departing from the basic concepts as disclosed herein.

The context in which this invention is described is an application group consisting of any number of independent applications. Each independent application runs on the primary node and can be supported by one or more designated backup nodes. Without affecting the general case of multiple backups the following describes scenarios where each independent application has one primary node and one backup node. Multiple backups are handled in a similar manner as a single backup.

The mechanisms for transparently loading applications transparently registering applications for protection preloading libraries transparently detecting faults and transparently initiating recovery are described in the first reference above which was incorporated by reference. The mechanisms for taking checkpoints of multi process multi threaded processes including processes using fork and restoring from those checkpoints are described in the second reference above which was incorporated by reference. The mechanism for launching the coordinator which in turn launches the application is described in the first and second references which were incorporated by reference. The mechanism used by the Duration AM to launch any process including the coordinator is described in the first and second reference and incorporated by reference. All applications in this invention may be launched by the Duration AM through either a coordinator or directly.

The mechanisms for taking checkpoints of multi process multi threaded processes launched from one binary and restoring from those checkpoints are described in the second reference above which was incorporated by reference. illustrates by way of example embodiment how an application group that uses both fork exec and exec is incrementally checkpointed. The coordinator launched the application and then installs interceptors and registers the process as described previously. Upon completion of the initialization the application is ready and starts running . The first checkpoint is a full checkpoint as there are no prior checkpoints. The 2checkpoint is incremental and only contains the memory pages changed since the first checkpoint. The application now calls fork and creates a new process which registers and installs interceptors. The 3checkpoint is a bit more involved both the original process and the new process are checkpointed incrementally. Following fork both parent and child have identical address spaces page tables and identical lists of dirty pages. As each process resume running each become independent but still have incremental information against the same full checkpoint they can therefore both be checkpointed incrementally and merged against the pre fork full checkpoint. If the child process forks another process the same description applies. The 4checkpoint is incremental for both processes and . The process now calls exec and overlays a new image. Following the procedure described under and checkpointer infrastructure is preserved and the checkpointing continue to operate across the complete replacement of the address space. The 5checkpoint is now a full checkpoint for process while it continues to be incremental for 120. The 6checkpoint is incremental for both processes and . Upon termination of both processes the application terminates .

Up until now we ve described checkpointing of application groups where the independent applications are created using fork and exec from one application. We now turn to application groups consisting of multiple independent applications launched independently at different times. illustrates by way of an example embodiment how the coordinator first launches application and then installs interceptors and registers with the coordinator. Application is ready to run and proceeds to run . In the meantime the Duration AM launches a second independent application and provides passes the coordinator process ID and HA APPLICATION name in the environment. Using the Coordinator PID and the HA APPLICATION name the application registers with the coordinator . The second application is ready to run and proceeds to run . While looks similar to there is one very significant difference in the second application is created by fork from the first application while in the second application is launched independently from the first application . The mechanism by which application joins an already running coordinator and checkpoint barrier is described in . The first checkpoint is taken as a full checkpoint of application process . This is followed by an incremental checkpoint . The third checkpoint includes the second independent application and contains an incremental checkpoint for application and a full checkpoint of application process . The fourth checkpoint is incremental for both applications and . The embodiment in shows applications and without any use of fork and exec .

It is readily apparent to someone skilled in the art that application could use fork and or exec and combined with the teachings above application groups containing any number of independent application launched independently or via fork exec can be checkpointed using the present invention.

In order to let any independent application join an existing coordinator and application group that new application needs to be able to find and communicate with the coordinator. is an example embodiment of how that can be achieved. The coordinator launches the first application and as previously described takes it through registration and proceeds to let it run . At a later time the Duration AM launches a second application and passes the coordinator PID and HA APPLICATION name via the environment. As described in the second reference checkpointing is coordinated using a checkpointer semaphore. As described above the checkpointer semaphore is always stored in shared memory and can be accessed via the shared memory ID constructed from the coordinator PID and HA APPLICATION name both of were provided to the application via the environment. The coordinator is unaware of the second application until registration and could conceivably trigger a checkpoint during the registration process. To prevent checkpointing of partially launched applications the second application first acquires the checkpointer semaphore which prevents the coordinator from triggering checkpoints. This is followed by registration with the coordinator and followed by the release of the checkpointer semaphore . The mechanism for obtaining and releasing semaphores are well known in the art and will not be described further here. The new application is now ready to run .

The launch mechanism described here combines with the previous teaching and completes the support for coordinated checkpointing of application groups to include both programmatic creation of processes with fork and external loading of new processes with the AM. The teachings also support loading the applications at different times as just described above.

The mechanisms for restoring multi process multi threaded applications launched from one binary are described in the second reference above which was incorporated by reference. The checkpoints for the application groups contains all the process and thread tree hierarchy information the environmental information needed to register independent applications and checkpoint across exec. illustrates an example embodiment of restoring an application groups. As described in the second reference the coordinator is initially launched as a place holder for all processes to be restored. The coordinator reads the process tables from the checkpoint and creates the process hierarchy for the entire application group. For the first process the image is restored from the checkpoint and the environment variables . After the process hierarchy has been recreated each process exec its binary image the same number of times it previously exec ed using checkpoint and environment variables. The second process is similarly restored from checkpoint and environment variables and each process exec as described for the first process. Interceptors for both application processes and are also installed at this point. The independent applications are now ready to run and proceed to execute as of the restored checkpoints . Both independent applications now run and are checkpointed using the techniques previously taught.

The mechanism for checkpointing the storage associated with a multi process application is described in reference two and incorporated by reference. The mechanisms as taught works as described for each application in an application groups. Combining the above teaching of coordinated checkpointing of application groups with the storage checkpointing for individual applications the combined teachings fully covers storage checkpointing of application groups.

The mechanism for incremental checkpointing and how to mark clear dirty pages written from user space is described in reference two and incorporated by reference. The mechanism relies on interception of SIGSEGV signal as described. However attempts to write to read only use space pages in memory from kernel mode i.e. from a system call do not trigger SIGSEGV rather they return EFAULT as an error code. Systems calls in general return an EFAULT error in stead of triggering the SIGSEGV should they write to read only application memory. The present invention adds full support for EFAULT from system calls in addition to SIGSEGV. It should be noted that in the example embodiment system library functions can also return EFAULT. Since the system library EFAULTS originate outside kernel mode the previous teachings above apply here we re only concerned with pages written from kernel space i.e. system calls. illustrates an example embodiment of the coordinator initializes and launches the application or application group as previously described. In one embodiment of the invention a customized system library is used. The customized system library contains predefined pre system call and post system call function calls to the checkpointer library.

By way of example we consider the case where the application calls a system library call library callX located in the system library . Initially the entry point library callX is called. Before reaching the system call it executes the pre call callback and registers information with the checkpointer then the system call named system callA by way of example is run. The system call reaches the kernel and system callA runs and returns potentially with an EFAULT error condition. The post call callback processes the error codes if any and updates via the callbacks the page tables maintained by the checkpointer. Finally control returns to the application and execution continues.

In another embodiment the standard system library is used and the pre system call and post system call callbacks are installed dynamically by the coordinator as part of application initialization

As described in reference two and incorporated by reference processing a SIGSEGV fault is done by updating the page table and making the page writable. We now proceed to describe the handling of EFAULT is more detail. Continuing with the example embodiment in . If the system call system callA safely can be called again the pre post callbacks operate as follows 

1. the pre call callback marks memory pages belong to the calls arguments as dirty and disables write protection for the duration of the system call.

The terms call arguments memory pages and memory pages belonging to call argument is utilized to mean the following. By way of example a function might have a number of parameters some of which are pointers to memory locations. The aforementioned memory pages are the memory pages referenced or pointed to by pointers in argument list.

In another embodiment all EFAULT handling is done in a kernel module sitting under the system library.

Referring once again to for illustrative purposes the case of migrating the distributed application from one set of nodes to another set of nodes is considered. Migration of live applications is preferably utilized in responding to the anticipation of faults such as detecting that a CPU is overheating a server is running out of memory and the like when the administrator wants to re configure the servers or when the servers currently being used have to be freed up for some reason.

Building on the disclosures above a loss less migration is achieved by first checkpointing the application group including all independent applications and optionally the local transports then restoring all independent applications and optionally the local transports from the checkpoints on the backup nodes. The migration is loss less which means that no data or processing is lost.

Loss less migration of application groups can be viewed differently. The ability to checkpoint and migrate entire application groups makes the application location independent. The application groups can be moved started and stopped on any server at any point in time. The present teaching therefore shows how to de couple a live running instance of an application from the underlying operating system and hardware. The application execution has therefore been virtualized and enables live migration ie a migration of a running application without any application involvement or even knowledge.

In the embodiments described herein an example programming environment was described for which an embodiment of programming according to the invention was taught. It should be appreciated that the present invention can be implemented by one of ordinary skill in the art using different program organizations and structures different data structures and of course any desired naming conventions without departing from the teachings herein. In addition the invention can be ported or otherwise configured for use across a wide range of operating system environments.

Although the description above contains many details these should not be construed as limiting the scope of the invention but as merely providing illustrations of some of the exemplary embodiments of this invention. Therefore it will be appreciated that the scope of the present invention fully encompasses other embodiments which may become obvious to those skilled in the art and that the scope of the present invention is accordingly to be limited by nothing other than the appended claims in which reference to an element in the singular is not intended to mean one and only one unless explicitly so stated but rather one or more. All structural and functional equivalents to the elements of the above described preferred embodiment that are known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the present claims. Moreover it is not necessary for a device or method to address each and every problem sought to be solved by the present invention for it to be encompassed by the present claims. Furthermore no element component or method step in the present disclosure is intended to be dedicated to the public regardless of whether the element component or method step is explicitly recited in the claims. No claim element herein is to be construed under the provisions of 35 U.S.C. 112 sixth paragraph unless the element is expressly recited using the phrase means for. 

