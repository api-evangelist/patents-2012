---

title: Method for urgency-based preemption of a process
abstract: The desire to use an Accelerated Processing Device (APD) for general computation has increased due to the APD's exemplary performance characteristics. However, current systems incur high overhead when dispatching work to the APD because a process cannot be efficiently identified or preempted. The occupying of the APD by a rogue process for arbitrary amounts of time can prevent the effective utilization of the available system capacity and can reduce the processing progress of the system. Embodiments described herein can overcome this deficiency by enabling the system software to pre-empt a process executing on the APD for any reason. The APD provides an interface for initiating such a pre-emption. This interface exposes an urgency of the request which determines whether the process being preempted is allowed a grace period to complete its issued work before being forced off the hardware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08963933&OS=08963933&RS=08963933
owner: Advanced Micro Devices, Inc.
number: 08963933
owner_city: Sunnyvale
owner_country: US
publication_date: 20120723
---
The present invention is generally directed to computer systems. More particularly the present invention is directed to context switching.

The desire to use accelerated processors such as a graphics processing unit GPU for general computation has become much more pronounced recently due to the GPU s exemplary performance per unit power and or cost. The computational capabilities for GPUs generally have grown at a rate exceeding that of the corresponding central processing unit CPU platforms. This growth coupled with the explosion of the mobile computing market and its necessary supporting server enterprise systems has been used to provide a specified quality of desired user experience. Consequently the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology. As will be appreciated other specialized processors that accelerate particular functions of a convention CPU other than GPUs are known in the art.

However GPUs have traditionally operated in a constrained programming environment available only for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use therefore has been mostly limited to two dimensional 2D and three dimensional 3D graphics and a few leading edge multimedia applications which are already accustomed to dealing with graphics and video application programming interfaces APIs .

With the advent of multi vendor supported OpenCL and DirectCompute standard APIs and supporting tools the use of the GPUs in applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start there are many hurdles remaining to creating an environment and ecosystem that allows the combination of the CPU and GPU to be used as fluidly as the CPU for most programming tasks.

Existing computing systems often include multiple processing devices. For example some computing systems include both a CPU and a GPU on separate chips e.g. the CPU might be located on a motherboard and the GPU might be located on a graphics card or in a single chip package. Both of these arrangements however still include significant challenges associated with i separate memory systems ii efficient scheduling iii providing quality of service QoS guarantees between processes iv programming model and v compiling to multiple target instruction set architectures ISAs all while minimizing power consumption.

For example the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces e.g. chip to chip negatively affect memory latency and power consumption for cooperating heterogeneous processors the separate memory systems i.e. separate address spaces and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.

Both the discrete and single chip arrangements can limit the types of commands that can be sent to the GPU for execution. This performance based limitation exists because the CPU may relatively quickly require the results of the operations performed by these computational commands. However because of the high overhead of dispatching work to the GPU in current systems and the fact that these commands may have to wait in line for other previously issued commands to be executed first the latency incurred by sending computational commands to the GPU is often unacceptable.

For example since processes cannot be efficiently identified and or preempted a rogue process can occupy the GPU for arbitrary amounts of time. The occupying of the GPU by rogue processes for arbitrary amounts of time can prevent the effective utilization of the available system capacity and can prevent or significantly reduce the processing progress of the system. In other cases the ability to context switch off the hardware is severely constrained occurring at very coarse granularity and only at a very limited set of points in a program s execution.

What is needed therefore are methods and systems for efficiently preempting processes running in systems where the accelerated processor e.g. a GPU is managed as a resource by system software.

Although GPUs accelerated processing units APUs and general purpose use of the graphics processing unit GPGPU are commonly used terms in this field the expression accelerated processing device APD is considered to be a broader expression. For example APD refers to any cooperating collection of hardware and or software that performs those functions and computations associated with accelerating graphics processing tasks data parallel tasks or nested data parallel tasks in an accelerated manner with respect to resources such as conventional CPUs conventional GPUs and or combinations thereof.

Embodiments of the present invention provide mechanisms whereby the system software can pre empt a process executing on the APD for any reason. The APD provides an interface for initiating such a pre emption. Among other necessary information this interface exposes an urgency of the request which determines whether the process being preempted is allowed a grace period to complete its issued work before being forced off the hardware.

More specifically an embodiment of the present invention provides under certain circumstances a method including preempting a first process running on an APD based upon urgency of a second process.

Further features and advantages of the invention as well as the structure and operation of various embodiments of the invention are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art s based on the teachings contained herein.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit s in the corresponding reference number.

In the detailed description that follows references to one embodiment an embodiment an example embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to affect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

The term embodiments of the invention does not require that all embodiments of the invention include the discussed feature advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention and well known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example as used herein the singular forms a an and the are intended to include the plural forms as well unless the context clearly indicates otherwise. It will be further understood that the terms comprises comprising includes and or including when used herein specify the presence of stated features integers steps operations elements and or components but do not preclude the presence or addition of one or more other features integers steps operations elements components and or groups thereof.

In one example system also includes a memory an operating system and a communication infrastructure . The operating system and the communication infrastructure are discussed in greater detail below.

The system also includes a kernel mode driver KMD a software scheduler SWS and a memory management unit such as input output memory management unit IOMMU . Components of system can be implemented as hardware firmware software or any combination thereof. A person of ordinary skill in the art will appreciate that system may include one or more software hardware and firmware components in addition to or different from that shown in the embodiment shown in .

In one example a driver such as KMD typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver the driver issues commands to the device. Once the device sends data back to the driver the driver may invoke routines in the original calling program. In one example drivers are hardware dependent and operating system specific. They usually provide the interrupt handling required for any necessary asynchronous time dependent hardware interface. Device drivers particularly on modern Windows platforms can run in kernel mode Ring 0 or in user mode Ring 3 .

A benefit of running a driver in user mode is improved stability since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand user kernel mode transitions usually impose a considerable performance overhead thereby prohibiting user mode drivers for low latency and high throughput requirements. Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.

CPU can include not shown one or more of a control processor field programmable gate array FPGA application specific integrated circuit ASIC or digital signal processor DSP . CPU for example executes the control logic including the operating system KMD SWS and applications that control the operation of computing system . In this illustrative embodiment CPU according to one embodiment initiates and controls the execution of applications by for example distributing the processing associated with that application across the CPU and other processing resources such as the APD .

APD among other things executes commands and programs for selected functions such as graphics operations and other operations that may be for example particularly suited for parallel processing. In general APD can be frequently used for executing graphics pipeline operations such as pixel operations geometric computations and rendering an image to a display. In various embodiments of the present invention APD can also execute compute processing operations based on commands or instructions received from CPU .

For example commands can be considered a special instruction that is not defined in the instruction set architecture ISA and usually accomplished by a set of instructions in from a given ISA or a unique piece of hardware. A command may be executed by a special processor such a dispatch processor command processor or network controller. On the other hand instructions can be considered e.g. a single operation of a processor within a computer architecture. In one example when using two sets of ISAs some instructions are used to execute x86 programs and some instructions are used to execute kernels on APD GPU compute unit.

In an illustrative embodiment CPU transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands that can also include compute processing commands can be executed substantially independently from CPU .

APD can include its own compute units not shown such as but not limited to one or more single instruction multiple data SIMD processing cores. As referred to herein a SIMD is a math pipeline or programming model where a kernel is executed concurrently on multiple processing elements each with its own data work item and a shared program counter. All processing elements execute a strictly identical set of instructions. The use of predication enables work items to participate or not for each issued command.

In one example each APD compute unit can include one or more scalar and or vector floating point units and or arithmetic and logic units ALUs . The APD compute unit can also include special purpose processing units not shown such as inverse square root units and sine cosine units. In one example the APD compute units are referred to herein collectively as shader core .

Having one or more SIMDs in general makes APD ideally suited for execution of data parallel tasks such as are common in graphics processing.

Some graphics pipeline operations such as pixel processing and other parallel computation operations can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core in order to process such data elements in parallel. As referred to herein for example a compute kernel is a function containing instructions declared in a program and executed on an APD GPU compute unit. This function is also referred to as a kernel a shader a shader program or a program.

In one illustrative embodiment each compute unit e.g. SIMD processing core can execute a respective instantiation of a particular kernel to process incoming data. A work item is one of a collection of parallel executions of a kernel invoked on a device by a command. A plurality of work items can be executed by one or more processing elements as part of a work group executing on a compute unit.

A work item is distinguished from other executions within the collection by its global ID and local ID. In one example a subset of work items in a workgroup that execute simultaneously together on a single SIMD engine can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware SIMD engine. As referred to herein a workgroup is a collection of related work items that execute on a single compute unit. The work items in the group execute the same kernel and share local memory and work group barriers.

All wavefronts from a workgroup are processed on the same SIMD engine. Instructions across a wavefront are issued one at a time and when all work items follow the same control flow each work item executes the same program. An execution mask and work item predication are used to enable divergent control flow within a wavefront where each individual work item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work items is not available at wavefront start time. Wavefronts can also be referred to as warps vectors or threads. For example shader core can simultaneously execute a predetermined number of wavefronts each wavefront comprising a predetermined number of work items.

Within the system APD includes its own memory in some embodiments such as graphics memory . Graphics memory provides a local memory for use during computations in APD . Individual compute units not shown within shader core can have their own local data store not shown . In one embodiment APD includes access to local graphics memory as well as access to the memory . In another embodiment APD can include access to dynamic random access memory DRAM or other such memories not shown attached directly to the APD and separately from memory .

In the example shown APD also includes one or n number of command processors CPs . CP controls the processing within APD . CP also retrieves commands to be executed from command buffers in memory and coordinates the execution of those commands on APD .

In one example CPU inputs commands based on applications into appropriate command buffers . As referred to herein an application is the combination of the program parts that will execute on the compute units within the CPU and APD.

A plurality of command buffers can be maintained with each process scheduled for execution on the APD .

CP can be implemented in hardware firmware or software or a combination thereof. In one embodiment CP is implemented as a reduced instruction set computer RISC engine with microcode for implementing logic including scheduling logic.

APD also includes one or n number of dispatch controllers DCs . In the present application the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC includes logic to initiate workgroups in the shader core . In some embodiments DC can be implemented as part of CP .

In the example shown system also includes a hardware scheduler HWS for selecting a process from a run list for execution on APD . HWS can select processes from run list using round robin methodology priority level or based on other scheduling policies. The priority level for example can be dynamically determined. HWS can also include functionality to manage the run list for example by adding new processes and by deleting existing processes from run list . The run list management logic of HWS is sometimes referred to as a run list controller RLC .

In various embodiments of the present invention when HWS initiates the execution of a process from RLC CP begins retrieving and executing commands from the corresponding command buffer . In some instances CP can generate one or more commands to be executed within APD which correspond with commands received from CPU or previously generated by the APD itself. In one embodiment CP together with other components implements a prioritizing and scheduling of commands on APD in a manner that improves or maximizes the utilization of the resources of APD resources and or system .

APD can have access to or may include an interrupt generator . Interrupt generator can be configured by APD to interrupt the operating system when interrupt events such as page faults are encountered by APD . For example APD can rely on interrupt generation logic within IOMMU to create the page fault interrupts noted above.

APD can also include preemption and context switch logic for preempting a process currently running within shader core . Context switch logic for example includes functionality to stop the process and save its current state e.g. shader core state and CP state .

As referred to herein the term state can include an initial state an intermediate state and a final state. An initial state is a starting point for a machine to process an input data set according to a program in order to create an output set of data. There is an intermediate state for example that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set.

Preemption and context switch logic can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD may include instantiating the process for example through the CP and DC to run on APD restoring any previously saved state for that process and starting its execution.

Memory can include non persistent memory such as DRAM not shown . Memory can store e.g. processing logic instructions constant values and variable values during execution of portions of applications or other processing logic. For example in one embodiment parts of control logic to perform one or more operations on CPU can reside within memory during execution of the respective portions of the operation by CPU . The term processing logic or logic as used herein refers to control flow commands commands for performing computations and commands for associated access to resources.

During execution respective applications operating system functions processing logic commands and system software can reside in memory . Control logic commands fundamental to operating system will generally reside in memory during execution. Other software commands including for example kernel mode driver and software scheduler can also reside in memory during execution of system .

In this example memory includes command buffers that are used by CPU to send commands to APD . Memory also contains process lists and process information e.g. active list and process control blocks . These lists as well as the information are used by scheduling software executing on CPU to communicate scheduling information to APD and or related scheduling hardware. Access to memory can be managed by a memory controller which is coupled to memory . For example requests from CPU or from other devices for reading from or for writing to memory are managed by the memory controller .

As used herein context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context can include a set of devices the memory accessible to those devices the corresponding memory properties and one or more command queues used to schedule execution of a kernel s or operations on memory objects. On the other hand process can be considered the execution of a program for an application that runs on a computer. The operating system can create data records and virtual memory address spaces for the program to execute. The memory and current state of the execution of the program can be called a process. The operating system will schedule tasks for the process to operate on the memory from an initial to final state.

Referring back to the example shown in IOMMU includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU may also include logic to generate interrupts for example when a page access by a device such as APD results in a page fault. IOMMU may also include or have access to a translation lookaside buffer TLB . TLB as an example can be implemented in a content addressable memory CAM to accelerate translation of logical i.e. virtual memory addresses to physical memory addresses for requests made by APD for data in memory .

In the example shown communication infrastructure interconnects the components of system as needed. Communication infrastructure can include not shown one or more of a Peripheral Component Interconnect PCI bus extended PCI PCI E bus Advanced Microcontroller Bus Architecture AMBA bus Advanced Graphics Port AGP or such communication infrastructure. Communications infrastructure can also include an Ethernet or similar network or any suitable physical communications infrastructure that satisfies an application s data transfer rate requirements. Communication infrastructure includes the functionality to interconnect components including components of computing system .

In this example operating system includes functionality to manage the hardware components of system and to provide common services. In various embodiments operating system can execute on CPU and provide common services. These common services can include for example scheduling applications for execution within. CPU fault management interrupt service as well as processing the input and output of other applications.

In some embodiments based on interrupts generated by an interrupt controller such as interrupt controller operating system invokes an appropriate interrupt handling routine. For example upon detecting a page fault interrupt operating system may invoke an interrupt handler to initiate loading of the relevant page into memory and to update corresponding page tables.

Operating system may also include functionality to protect system by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect operating system ensures that applications such as applications run on CPU in user space. Operating system also ensures that applications invoke kernel functionality provided by the operating system to access hardware and or input output functionality.

By way of example applications include various programs or commands to perform user computations that are also executed on CPU . The unification concepts can allow CPU to seamlessly send selected commands for processing on the APD . Under this unified APD CPU framework input output requests from applications will be processed through corresponding operating system functionality.

In one example KMD implements an application program interface API through which CPU or applications executing on CPU or other logic can invoke APD functionality. For example KMD can enqueue commands from CPU to command buffers from which APD will subsequently retrieve the commands. Additionally KMD can together with SWS perform scheduling of processes to be executed on APD . SWS for example can include logic to maintain a prioritized list of processes to be executed on the APD.

In other embodiments of the present invention applications executing on CPU can entirely bypass KMD when enqueuing commands.

In some embodiments SWS maintains an active list in memory of processes to be executed on APD . SWS also selects a subset of the processes in active list to be managed by HWS in the hardware. Information relevant for running each process on APD is communicated from CPU to APD through process control blocks PCB .

Processing logic for applications operating system and system software can include commands specified in a programming language such as C and or in a hardware description language such as Verilog RTL or netlists to enable ultimately configuring a manufacturing process through the generation of maskworks photomasks to generate a hardware device embodying aspects of the invention described herein.

A person of skill in the art will understand upon reading this description that computing system can include more or fewer components than shown in . For example computing system can include one or more input interfaces non volatile storage one or more output interfaces network interfaces and one or more displays or display interfaces.

In graphics pipeline can include a set of blocks referred to herein as ordered pipeline . As an example ordered pipeline includes a vertex group translator VGT a primitive assembler PA a scan converter SC and a shader export render back unit SX RB . Each block within ordered pipeline may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline can be a fixed function hardware pipeline. Although other implementations that would be within the spirit and scope of the present invention can be used.

Although only a small amount of data may be provided as an input to graphics pipeline this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline also includes DC for counting through ranges within work item groups received from CP pipeline . Compute work submitted through DC is semi synchronous with graphics pipeline .

Compute pipeline includes shader DCs and . Each of the DCs are configured to count through compute ranges within work groups received from CP pipelines and

The DCs and illustrated in receive the input ranges break the ranges down into workgroups and then forward the workgroups to shader core .

Since graphics pipeline is generally a fixed function pipeline it is difficult to save and restore its state and as a result the graphics pipeline is difficult to context switch. Therefore in most cases context switching as discussed herein does not pertain to context switching among graphics processes. An exception is for graphics work in shader core which can be context switched.

Shader core can be shared by graphics pipeline and compute pipeline . Shader core can be a general processor configured to run wavefronts.

In one example all work within compute pipeline is processed within shader core . Shader core runs programmable software code and includes various forms of data such as state data. Compute pipeline however does not send work to graphics pipeline for processing. After processing of work within graphics pipeline has been completed the completed work is processed through a render back unit which does depth and color calculations and then writes its final results to graphics memory .

A disruption in the QoS occurs when all work items are unable to access APD resources. Embodiments of the present invention efficiently and simultaneously launch two or more tasks within an accelerated processing device enabling all work items to access to APD resources. In one embodiment an APD input scheme enables all work items to have access to the APD s resources in parallel by managing the APD s workload. When the APD s workload approaches maximum levels e.g. during attainment of maximum I O rates this APD input scheme ensures that otherwise unused processing resources can be simultaneously utilized. A serial input stream for example can be abstracted to appear as parallel simultaneous inputs to the APD.

By way of example each of the CPs can have one or more tasks to submit as inputs to the APD with each task can representing multiple wavefronts. After a first task is submitted as an input this task may be allowed to ramp up over a period of time to utilize all the APD resources necessary for completion of the task. By itself this first task may or may not teach a predetermined maximum APD utilization threshold. However as other tasks are enqueued and are waiting to be processed within the APD allocation of the APD resources can be managed to ensure that all of the tasks can simultaneously use the APD each achieving a percentage of the APD s maximum utilization. This simultaneous use of the APD by multiple tasks and their combined utilization percentages ensures that a predetermined maximum APD utilization threshold is achieved.

In step a time quanta or more particularly a maximum time interval during which any particular process can be running on the APD is configured. The time quanta can be configured as a single value which applies to any process that runs on the APD or as a plurality of values comprising respective values for each type or priority level of processes that run on the APD. The configuration can be received from the user or may be otherwise set. In another embodiment the time quanta can be determined by an OS or other application based on system considerations such as but not limited to the current or predicted system workload. The configuration of the time quanta value can be performed by or using an application executing on a CPU.

In step the CPU enqueues a process to be executed on the APD. More specifically the CPU transmits one or more commands to be executed on the APD. With respect to the enqueuing of the process can include for example CPU adding entries corresponding to the one or more transmitted commands to active list and process control blocks as well as inputting the commands to the corresponding command buffer . According to an embodiment when the CPU enqueues the process to the APD the CPU can also transmit to the APD the corresponding time quanta configuration. According to another embodiment the time quanta configuration is common to multiple processes that execute on the APD and is therefore unnecessary for the CPU to transmit the corresponding time quanta to the APD along with information of the process to be run. The transmitting of the process information from the CPU to the APD is further described below in relation to .

In step the APD starts running the process enqueued by the CPU. According to an example with respect to the running of the process on APD may involve the process being selected to run from the RLC the CP retrieving commands of the selected process from the corresponding command buffers the dispatch controller dispatching the retrieved commands to the appropriate processing pipeline of the APD e.g. compute pipeline graphics pipeline and the running of the process on shader core as one or more threads or wavefronts . Graphics processing utilizes the graphics pipeline of APD and the compute processes utilize the compute pipeline . Both types of processes utilize shader core of the APD for processing operations. The running of a process on the APD is further described below in relation to .

In step a timer corresponding to the selected APD process is started. According to an embodiment substantially concurrently with starting to run the selected process on the APD as described in relation to step above a corresponding process timer is initiated. The process timer for example process timer in is set to a maximum time interval that the selected process is allowed to run without preemption. The time interval is set to a time quanta threshold value that may have been preconfigured or dynamically determined.

According to an embodiment the time quanta value is configured by the user system software components or at the time of manufacture. According to another embodiment the time quanta value is dynamically determined based upon the current system workload. For example the system can select from among several threshold time quanta values based upon past workload or an estimation of the current and or future workload of the system as a whole or of the APD.

The setting for the maximum running time for the process such as process timer in may be determined based on one or more available configured time quanta values. According to another embodiment the time quanta applied to each process can be determined based on a characteristic of the process such as its type or priority. According to yet another embodiment a single time quanta value is applied to any process running on the APD.

In step an expiration of the timer associated with the process currently running on the APD i.e. the process started to run as described in step above is detected. For example with respect to the expiration of process timer that was started substantially at the same time process was started on shader core is detected. The expiration of the timer can be detected for example when the timer reaches a value of 0 i.e. counting down from the value set according to the corresponding time quanta . According to an embodiment with respect to the expiration of the timer can be notified to the CP or other part of APD by a message. According to an embodiment the communication may be based upon an interrupt that may be directly or indirectly trapped by the APD. In another embodiment the interrupt can be trapped by the operating system such as operating system . In another embodiment the interrupt is detected by APD or a hardware based scheduler such as HWS or preemption and context switch logic .

In step based upon the process timer expiry detected in step preemption of the currently running process is initiated. Preemption can for example with respect to be initiated by SWS upon being invoked by an interrupt service routine servicing the interrupt generated due to the timer expiration. In one embodiment SWS is invoked by API . In another embodiment SWS is invoked by OS . In yet another embodiment APD e.g. using HWS or preemption and context switch logic can detect the expiration of the timer and initiate the preemption of the current process. Preemption of the current process is further described in relation to below.

In step another process is context switched into running on the APD in place of the preempted process. The newly context switched process can be selected from the run list and can be started to run within its own interval defined by a time quanta. According to an embodiment a software based scheduler such as SWS initiates the context switch of the new process. According to another example a hardware based scheduler such as HWS or preemption and context switch logic can initiate the context switch of the new process. Initiating the context switch may involve selecting a new process and starting to run the selected new process on APD as described below in relation to .

Step can be performed upon for example an application executing on CPU transmitting one or more commands to be processed on APD . In step according to an embodiment the application calls KMD . KMD includes logic to analyze the command input by the application and invokes SWS if a process needs to be scheduled to be run on APD to process the input command. For example KMD can determine if the input command relates to a process already scheduled for execution on APD or if it relates to a command for which no process is currently scheduled. Already scheduled processes may have corresponding entries in the active list and or RLC . If the corresponding process is already scheduled for execution on the APD the input command is enqueued to the appropriate command ring . If the corresponding process if not already scheduled then KMD may invoke SWS to schedule the process. SWS can be implemented as part of KMD or separately. According to another embodiment the application can call a function other than KMD to enqueue commands to APD .

In step the process to be scheduled is added to a list of processes to be executed by the APD. According to an embodiment SWS adds the process to active list . As described above active list may be a list of entries corresponding to respective processes to be run on APD enqueued by a scheduler such as SWS . Adding a process to active list may also include adding process information to list of process control blocks . The entries corresponding to the process in active list and process control block may also include a pointer to one or more command buffers that hold or that are intended to hold commands associated with the process.

In step a time quanta value is associated with the process to be run on the APD. According to an embodiment SWS may associate a time quanta value selected from among one or more threshold values. The time quanta value may be based upon characteristics of the process such as process priority. The time quanta value can for example be associated with the entry in the process control blocks that corresponds to the process.

In step the process to be scheduled is sent to the APD. According to an embodiment SWS adds the process to a run list managed by the APD . According to an example SWS selects one or more entries from active list to be added to RLC . As described above APD subsequently selects processes to be run from RLC .

Step can be performed for example when a APD selects a process to be run next. For example step can be performed when APD or specifically a scheduler e.g. SWS HWS or preemption and context switch logic associated with APD selects a process from RLC to be run on shader core . According to an embodiment SWS selects a process from RLC and notifies CP to run the selected process. According to another embodiment a hardware based scheduler such as HWS or preemption and context switch logic selects the next process to be run from RLC . CP and dispatch controller dispatches commands from command buffers that correspond to the selected process to be executed.

In step it is determined whether the selected process has a saved state. For example CP may determine if the selected process has a saved state in memory or graphics memory from a previous run on shader core . The selected process may have previously been running on shader core and may have been preempted and its state saved. The address in memory or graphics memory at which the state is saved may be obtained from the corresponding entry in list of process control blocks .

If the selected process has a saved state as determined in step then in step the saved state is restored. Restoring of the saved state may involve the retrieving the state information from system memory or graphics memory and configuring the relevant registers and the like with the state of the selected process. Restoring of the saved state can include restoring the program counter constant values variable values and the like. Restoring the state can involve restoring wavefront state e.g. state common to all threads of a wavefront such as program counter and state of individual threads e.g. variables data . In general graphics processes or processes that occupy the graphics pipeline can have a larger amount of state than a process occupying the compute pipeline.

In step the time quanta to be configured for the current run of the process are determined. For example the value of the time quanta with which time quanta configuration is set to and from which timer is initiated is determined in step . In one example the time quanta value used is the threshold time quanta that is preconfigured for use with all processes or a group of one or more processes to which the selected process belongs. This for example is the case when the selected process has previously run for its fall time quanta and was preempted. In another example if the selected process was preempted in its previous run prior to the expiration of the time quanta then the new time quanta value can be configured as the time remaining when the previously used up time is subtracted from the full time quanta value. The determined value is configured in time quanta configuration .

In step the selected process is run on the shader core using the restored state. For example CP can start running of the selected process on the shader core . As described in relation to step of a timer can be started substantially at the same time that the selected process begins to run. Timer may expire when the configured time quanta is exceeded and the selected process has not yet completed running or has not otherwise been preempted from running on the APD .

If in step it is determined that the selected process has no previously stored state then processing proceeds to step . In step the value of the time quanta to be associated with the running time of the selected process is determined. The time quanta can be based upon a threshold value or as described above can be determined based on the system environment. In an example the SWS can configure a time quanta for the selected process which is then used by CP to configure time quanta configuration .

Subsequent to configuring the time quanta in for example time quanta configuration the selected process is run on shader core in step . For example CP can start running of the selected process on the shader core .

Embodiments of the present invention provide a mechanism whereby the system software can pre empt a process executing on the GPU for any reason. The GPU provides an interface for initiating such a pre emption. Among other necessary information this interface exposes the urgency of the request which determines whether the process being preempted is allowed a grace period to complete its issued work before being forced off the hardware.

In step an interrupt generation mechanism detects the expiration of a timer. For example interrupt generator may detect the expiration of timer when a process has been running on shader core for a time interval corresponding to time quanta configuration .

In step the interrupt generator generates an interrupt indicating the expiration of the timer . As described above interrupt generator can be implemented as part of APD as part of IOMMU or separately.

In step an interrupt handler in the OS receives the interrupt. For example interrupt controller can trap the interrupt generated by the APD associated interrupt generator . Interrupt controller may identify the interrupt as one due to time quanta expiration in the APD and would invoke an interrupt handling routine to handle the interrupt. In another example the interrupt may be received and handled by the HWS .

In step the OS or HWS initiates the preemption of the process currently running on the APD. According to an embodiment OS or OS scheduler can invoke SWS to initiate the preemption process. As described above SWS can be implemented as part of KMD or as a separate module.

In step SWS or HWS transmits a command to the APD to stop the current process. CP upon receiving the command to stop the current process can stop further dispatch of command for the process currently executing on the APD and then stop the execution of the process. According to an embodiment there may be a time interval that the CP waits for after the stop command before proceeding to the next steps.

In step the context for the current process i.e. process stopped in step is saved. Saving of the context can involve saving state that is common to a wavefront and also the state local to individual work items of that wavefront as well as additional control information regarding the process e.g. CP and dispatch controller state relevant to the process . The amount of state to be saved may differ between compute processes that occupy the compute pipeline and graphics processes that occupy the graphics pipeline.

Saving context may involve saving either or both the wavefront state of the process and the individual thread state of the process out to system memory. According to one embodiment the preemption of a compute process involves saving the wavefront state and thread state of the current compute process executing on shader core to a context save area in system memory . Context saving for a graphics process may involve only the wavefront state i.e. state common to all threads being saved to the context save area in system memory . Graphics processes for example can have very large amounts of thread level state which can be time consuming to save to system memory. The address in memory at which the context is to be saved can be provided by the OS or can be determined at runtime and can be recorded with process information in PCB .

In step SWS may optionally transmit a command to remove the current process from the run list. For example SWS may monitor the context save completion of the current process and upon determining that the context save is over transmit a command to remove the process from the RLC . Having completed the preemption of the current process from executing of the APD SWS can proceed to context switch in a new process to execute on the APD as described in relation to step of .

In step ready queues are selected from among the set of queues associated with each compute pipeline. By way of example the selection can be performed in parallel and independently by each compute pipeline. Each compute pipeline may have an arbitrary number of queues. The ready queues contain work that can be dispatched immediately for processing.

In one embodiment of the present invention the following register controls are provided for each queue 

6 . Ready A Ready indicates that the queue is active AND not empty OR dispatch pipe not empty AND queue not stalled .

In step the queue with the highest queue priority that is determined to be ready for processing is selected. In one example this selection is done by the HWS from among the entries in the runlist . In another example the section may be done by the SWS from among entries in the runlist or the active list . In yet another example the selection may be done cooperatively by the HWS and SWS . Once selected for example a queue remains selected until one of the following conditions occurs 

2 . a quantum is enabled and the processing duration allotted to the current queue is exceeded and another queue of the same priority is ready for processing 

3 . current queue wavefronts execute yield operations to relinquish the compute pipeline and schedules for example a smart wait on specific conditions such as timer expiration or completion of another task 

4 . a current queue and compute pipeline become empty and any other queue in the same compute pipeline is ready and

At step the API determines if the process running on the APD is to be preempted by another process. A process may be preempted based on one more conditions such as 

2 . the newly selected queue in step is of sufficiently high priority and the currently executing process corresponds to a queue of sufficiently low priority i.e. a very high priority queue may immediately preempt a low priority queue 

3 . the newly selected queue in step may have triggered real time considerations or other urgency requirements or

4 . the OS requests preemption of the current queue including due to termination of the current process by the OS .

In an embodiment the APD provides an interface for HWS SWS or OS to initiate preemption. Among other necessary information this interface exposes an urgency of the request which determines whether the process being preempted is allowed a grace period to complete its work before being forced off the hardware. The urgency of the request may be based on the absolute or relative priority of the queue selected in the reason for preemption as determined in or other system or OS considerations. If the process running on the APD is being preempted operations continue at step . Otherwise operations continue at step where the APD continues executing the current process.

At step the APD evaluates the urgency level of the preempting process. The urgency level reflects how critical it is to immediately execute the preempting process. The urgency level may be either high or low. However as would be apparent to persons skilled in the relevant arts there may be more than two urgency levels. If the urgency level is low operations continue at step . Otherwise if the urgency level is high operations continue at step .

At step the APD waits up a pre defined time limit for the currently dispatched process to finish. Giving the currently dispatched process a grace period is often preferable because if execution is completed during the pre defined time limit then the amount state information that must be saved is minimized.

In embodiments with more than two urgency levels the grace period may vary based on the urgency level with lower urgencies allowing for longer grace periods.

At step the currently executing process is preempted if it has not completed in any grace period that may have been given and the command processor signals the fetcher to stop fetching commands and the DC to stop dispatching wavefronts for the current queue and performs a context switching routine.

At step the switching compute pipeline s current state is stored in the respective memory queue descriptor MQD . An end of process EOP fence event can be inserted that targets a MQD with an end of pipe store final read address. In the event the queue is removed from the hardware while work is outstanding in the shader complex the final read address can be stored in the MQD.

At step the state of the previous queue is scheduled to be saved and pre fetched data is scheduled to be discarded. The CP can release the fetcher to select the next queue for processing. If the next queue has saved context state the fetcher will insert a load of the stored state from the MQD followed by the queue read write pointers setup for queue fetch.

The Summary and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor s and thus are not intended to limit the present invention and the appended claims in any way.

The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.

The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can by applying knowledge within the skill of the art readily modify and or adapt for various applications such specific embodiments without undue experimentation without departing from the general concept of the present invention. Therefore such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.

The breadth and scope of the present invention should not be limited by any of the above described exemplary embodiments but should be defined only in accordance with the following claims and their equivalents.

