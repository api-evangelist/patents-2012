---

title: Methods and systems for state synchronization over a non-reliable network using signature processing
abstract: Systems and methods for facilitating confirmation of completion of a transaction(s) for state synchronization over a non reliable network using signature processing are described. One of the methods includes receiving a read request from a first client, sending a last known signature with a context object to the first client in response to receiving the read request, and receiving an appended signature from the first client with a context object for a transaction at the first client. The appended signature includes the last known signature and an increment by the first client. The operation of receiving the appended signature occurs upon execution of the transaction at the first client. The method further includes updating the last known signature to the appended signature and sending the updated last known signature to the first client to facilitate marking of the transaction as complete resulting in a definitive state synchronization.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08812856&OS=08812856&RS=08812856
owner: Zynga Inc.
number: 08812856
owner_city: San Francisco
owner_country: US
publication_date: 20120210
---
The present invention relates to methods and systems for efficient and deterministic state synchronization over a non reliable network using signature processing.

With the advancement of Internet client devices such as cell phones and tablets have gained popularity. For example some households have multiple client devices. As another example some offices provide multiple client devices for their employees.

A user may use an application at one client device and use the application at another client device or re use the application at the same client device. Between uses of the application at the same or different client devices information regarding a state of the application should be communicated efficiently. Also a variety of fraudulent applications may try to gain access to the information that is stored within a network.

Embodiments of the present invention provide methods and systems for communicating signatures to improve efficiency within a network. In some embodiments an appended signature is communicated from a client to a server. The appended signature is communicated when a transaction occurs at the client. The occurrence of the transaction changes a state of the client. The server stores the appended signature as a last known signature at the server and communicates the last known signature to other clients that issue a read request to the server. The communication of the appended signature notifies the other clients regarding the client at which the transaction occurred. Moreover the appended signature that identifies the client that issues the read request also helps the server and the other clients determine whether the client is fraudulent.

In some embodiments a method for facilitating confirmation of completion of a transaction is described. The method includes receiving a read request from a first client sending a last known signature with a context object to the first client in response to receiving the read request and receiving an appended signature from the first client with a context object for a transaction at the first client. The appended signature includes the last known signature and an increment by the first client. The operation of receiving the appended signature occurs upon execution of the transaction at the first client. The method further includes updating the last known signature to the appended signature and sending the updated last known signature to the first client to facilitate marking of the transaction as complete.

In some embodiments a method for confirming completion of a transaction is described. The method includes sending a read request to a server receiving at a first client last known signature with a context object from the server in response to sending the read request and determining whether a transaction is performed. The method further includes sending an appended signature with a context object to the server in response to determining that the transaction is performed. The appended signature includes the last known signature and an increment by the first client. The method includes determining whether the appended signature is received from the server.

In one embodiment a method for confirming completion of a transaction is described. The method includes sending a read request to a server receiving a last known signature with a context object in response to sending the read request determining whether a transaction is complete at a first client and adding an increment signature to the last known signature in response to determining the transaction is complete. The operation of adding the increment is performed to generate an appended signature. The method further includes sending the appended signature with a context object to the server and sending a signature to the first client.

Other aspects of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings illustrating by way of example the principles of various embodiments of the present invention.

It should be noted that various embodiments of the present invention may be practiced without some or all of these specific details. In other instances well known process operations have not been described in detail in order not to unnecessarily obscure various embodiments of the present invention.

In one example embodiment each client is assigned an identifier such as a bit a bit pattern or a token upon registration of the client with a server or installation of the client at the server or at a client device. As one example this identifier may be a random generated number or can be a bit combination based on the number of clients registered with the server. A client is for example a game application that is executed to play a game. An example of the game includes an online game that is displayed on a display device of a client device where the client device connects to the server to play a game and the server maintains or tracks a user s progress through the game. Aspects of the defined methods and systems will therefore provide for efficient state synchronization over a non reliable network with the help of signatures. The non reliable network can be due to loss of connection or connection drops during mobile device processing as the device moves. A display device is described below. A server as used herein is a physical machine or a virtual machine.

Broadly speaking the progress can be thought of as a current game state. As can be appreciated maintaining correct synchronization of game state between the client device or client devices and the server ensures that the user does not lose his or her progress in a game during game play on one client device or when the user logs into the server with another client device.

In some embodiments the user logs in to a server and upon logging in a client such as client retrieves a server side object. The server side object includes a last known signature that is known to the server LKS s . The last known signature LKS s when received by a client becomes the LKS of the client LKS c which is saved internally within the client. If after occurrence of a transaction at the client the client attempts a write to the server the write includes sending a combination of the LKS c and an increment signature which is described below.

The server is written to but a failure occurs when the server sends the confirmation of the write. The client does not know that the server correctly handled the write. At a later point in time when client successfully connects to the server client issues a read request. In some embodiments a client sends an increment signature of the client in the read request to identify the client to the server. For example the client sends an increment signature having a value of 1 in a read request to the server. As another example a client sends an increment signature having a value of 2 in a read request to the server .

Upon receiving the read request from the client the server sends client the last known signature held by the server LKS s . In some embodiments before sending the last known signature LKS s to a client that issues a read request the server determines whether the increment signature received from the client is registered with the server. In these embodiments upon determining that the increment signature is not registered the server generates a warning such as issues a notification to other clients such as client regarding the client that issued the read request. On the other hand upon determining that the increment signature is registered the server sends the LKS s to the client that issued the read request.

If the combination of the LKS c and the increment signature sent from the client matches the LKS s obtained from the server the client knows that the server performed the requested write and updates its state confirming that the server committed the write. If the combination stored at client does not match the LKS s obtained from the server the client takes the LKS s as its current state and will proceed from that point forward.

When the user A creates one or more transactions within the game A via an input device of a client device a game state is created by a processor of the client device and maintained in the client device. A processor as used herein is a central processing unit CPU an application specific integrated circuit ASIC a programmable logic device PLD or a microprocessor. In one embodiment a game state of a game includes data or metadata that describes a state of one or more virtual parameters of the game. For example a game state of a game includes a physical position of a virtual user within a virtual world of the game. As another example a game state of a game includes a number of virtual points of the game. As yet another example a game state of a game includes a level of virtual energy of a virtual user of the game. Examples of an input device include a keyboard a mouse a stylus and a touchscreen. In some embodiments a game state of a game includes a state of a virtual parameter of the game.

A transaction is created within a game when the user A uses an input device of a client device to change a virtual parameter of the game. For example when the user A uses an input device of the client device A to change a physical position of a virtual user of the game A a transaction is created by a processor of the client device A. As another example when the user A uses an input device of the client device A to build a virtual structure of a game an energy level of a virtual user that builds the virtual structure decreases. In this example two transactions are created by a processor of the client device A. The first transaction includes building the virtual structure and the second transaction includes the decrease in the number of virtual energy level. As yet another example when the user A wins virtual points while playing the game A within an input device of the client device A a transaction is created by a processor of the client device. The transaction includes an increase in the number of virtual points.

A signature check module of a client device creates an increment signature upon an occurrence of a transaction. For example a signature check module of the client device A determines whether a transaction has occurred in the client device A. If so the signature check module generates one or more bits that represent that the transaction occurred at the client device A. A signature check module of a client device also compares a signature that is received from the server with an appended signature that is stored in the client device to determine whether there is a match between the two signatures. In some embodiments an appended signature is a combination of an increment signature and an LKS c .

A client as used herein includes a client device an external application running as a standalone platform an external application running on a software as a service SaaS platform or a combination thereof. As an example a client includes a game application that is executed by one or more processors of a client device to display a game on a display device of the client device. As another example a client includes a game application such as a game execution logic module of the server that is executed by one or more processors of the server . The game application is stored in a memory device of the server . When the game execution logic module is executed a game state is transferred via a game interface of the server in the form of a context object via a network to the client device A. In some embodiments the game interface includes a network interface card or a modem that allows the server to communicate with a network which is described below. For example the game interface implements a Transmission Control Protocol on top of an Internet Protocol TCP IP to communicate with the network . A graphical processing unit GPU of the client device A processes the game state to display such as render a game on a display device of the client device A. Examples of a display device include a liquid crystal display LCD a light emitting diode LED display a cathode ray tube CRT display and a plasma display.

A user plays a game at the client device A to generate a game state and an increment signature. Examples of a signature include a token a bit and a bit stream. The increment signature is appended to an LKS c to generate an appended signature that is maintained at the client device A. The appended signature is sent from the client device A to the server via the network . Moreover the game state is sent as a context object via the network to the server . Examples of the network include the Internet an Intranet and a combination of the Internet and the Intranet. Other examples of the network include a wired network and a combination of the wired network and a wireless network. Yet other examples of the network include a local area network LAN a wide area network WAN and a combination thereof.

The server receives the game state from the client device A and maintains the game state in a memory device of the server . A memory device as used herein includes a random access memory RAM a read only memory ROM or a combination thereof. As another example a memory device includes a hard disk or a flash memory. Moreover the server transfers a game state stored within the server via the game interface and the network in the form of a context object to a client device that sends a read request to the server . A read request is described below.

A signature manager module of the server updates an LKS s at the server based on an appended signature that is received from a client device via the network . For example the signature manager module updates the LKS s to match an appended signature that is received from the client device A via the network . An appended signature is described below.

A user quits playing on the client device A and after a while plays the game A on a client device B. For example a user discontinues playing the game A at a game state at the client device A and continues playing the game A from the game state at the client device B. During the play at the client device B a user uses an input device of the client device B to generate one or more transactions in the game A. The game state that was carried over from the client device A via the network and the server to the client device B changes when a user continues playing the game A at the client device B. The changed game state is transferred from the client device B via the network and the game interface of the server to a memory device of the server for updating a game state of the game A that was received from the client device A.

Moreover when one or more transactions occur at the client device B after receiving a game state from the client device A an appended signature is created by a signature check module of the client device B to indicate the occurrence of the one or more transactions. The appended signature that is created by the client device B is sent via the network and the game interface of the server to the signature manager module of the server . The signature manager module of the server changes the updated LKS s stored at the server based on the appended signature received from the client device B. For example the signature manager module changes the updated LKS s to match the appended signature that is received from the client device B via the network .

Similarly a user discontinues playing the game A at a game state that is maintained in the client device B and uses another client device C to continue playing the game A from the game state. There is back and forth interaction similar to that described above between the client device C and the server via the network when one or more transactions occur during the play of the game A at the client device C.

Moreover a user discontinues playing the game A at a game state that is maintained at the client device C and uses another client device D to continue playing the game A from the game state. There is interaction between the client device D and the server via the network when one or more transactions occur during the play of the game A at the client device D.

It should be noted that in various embodiments a user selects any client device randomly to play the game A. For example a user uses the client device A to play the game A until a game state is reached. Then the user uses the client device C to continue playing the game A until a further game state is reached. The user then uses the client device A to continue playing the game A until another game state is reached.

In some embodiments a module is a computer program that is executed by one or more processors to perform functions described in the module. For example the signature manager module and the game execution logic module are executed by a processor of the server to perform the functions described in the signature manager and game execution logic modules.

In one embodiment a user A provides log in information via an input device of a client device to access a client via the server . As an example the log in information includes a user name and or a password that is assigned to the user A. When log in information is authenticated by the server or another authentication server of the network the user A is allowed access to a client.

In some embodiments the user A is allowed access to a client without requiring authentication of log in information received from the user A. For example a client after being disconnected from the server tries to establish a session with the server by sending a message to the server . If the server responds to the message with another message there is an establishment of session between the client and the server and the user A is allowed access to the client.

Described below are various functions and communications performed by a client. Also described below are various functions and communications performed by the server . It should be noted that if the functions and communications performed by a client or server are described under a title Time Period X the functions and communications are performed during the time period where X is an integer greater than zero.

Upon allowance of access by the server to the client the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s having a value of 2 with a context object CO that is stored within the server to the client .

A processor associated with the client determines whether a transaction has occurred at the client . For example the processor associated with the client determines whether a virtual user has moved from a first physical position to a second physical position. As another example the processor associated with the client determines whether a number of points have changed from a first number to a second number. It should be noted that in the embodiments in which a client is a client device a processor is associated with a client when the processor is a part of the client device. Moreover in the embodiments in which a client is a game a processor is associated with a client when the processor is displaying the game.

When a transaction X occurs at the client the processor associated with the client appends an increment signature 2 to the LKS c that is stored within the client to generate an appended signature 22 . In some embodiments an increment signature identifies a client and a transaction. For example the client appends an increment signature to identify that the client appended the increment signature and that a transaction K occurred at the client . As another example the client appends an increment signature to identify that the client appended the increment signature and that the transaction X occurred at the client . In this example the increment signature added by the client is different than the increment signature added by the client .

Also when the transaction X occurs at the client the processor associated with the client generates a context object that includes a state of the client after occurrence of the transaction X. The client communicates the context object with the appended signature 22 to the server .

The server receives the appended signature 22 and a processor of the server updates the LKS s 2 in a memory device of the server to match a value of the appended signature 22 . When the LKS s having a value of 2 is updated to the value 22 the LKS s that is stored within the server becomes 22 .

The LKS s having the value of 22 is communicated from the server to the client via the network . Upon receiving the LKS s having the value of 22 a processor associated with the client compares the LKS s with the appended signature. Upon determining that the value of the LKS s of 22 matches the value 22 of the appended signature the client updates the value 2 of LKS c to the value of 22 and marks the transaction X as complete.

When a transaction Y occurs at the client the processor associated with the client appends an increment signature 2 to the LKS c having a value of 22 at the client to generate an appended signature 222 . Also when the transaction Y occurs at the client the processor associated with the client generates a context object that describes a state of the client after occurrence of the transactions X and Y. The client communicates the context object with the appended signature 222 to the server .

Upon receiving the context object the server updates in a memory device of the server the context object that was communicated during the time period with the context object received from the client during the time period . For example the updated context object includes information about the state of the client after occurrence of the transactions X and Y.

The server receives the appended signature 222 and a processor of the server updates the LKS s 22 in a memory device of the server to match a value of the appended signature 222 . When the LKS s having a value of 22 is updated to the value 222 the LKS s that is stored in a memory device of the server becomes 222 .

The LKS s having the value of 222 is communicated from the server to the client via the network . The LKS s having the value of 222 is not received by the client .

In some embodiments when there are hardware or software problems with the network a client and the server are disconnected and a signature communicated from the server is not received by a client or a signature communicated from a client is not received by the server . For example the LKS s is lost in the network a network connection between the client and the server malfunctions or stops functioning or a session between the client and the server accidentally ends. When a client and the server are disconnected access to the server is lost by the client.

After the lack of reception of the LKS s having the value of 222 by the client and upon regaining access by the client to the server the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s 222 with a context object CO to the client . The context object sent to the client is the same as the updated context object described above with reference to time period .

Upon receiving the LKS s having the value of 222 from the server a processor associated with the client compares the LKS s with the appended signature that was sent during the time period . Upon determining that the value of the LKS s of 222 matches the value 222 of the appended signature the client updates the value 22 of LKS c to the value of 222 and marks the transaction Y as complete.

When a transaction Z occurs at the client the processor associated with the client appends an increment signature 2 to the LKS c at the client to generate an appended signature 2222 . Also when the transaction Z occurs at the client the processor associated with the client generates a context object that describes a state of the client after occurrence of the transactions X Y and Z. The client communicates the context object with the appended signature 2222 to the server .

Upon receiving the context object the server updates in a memory device of the server the context object that was communicated during the time period with the context object received from the client during the time period . For example the updated context object includes information about the state of the client after occurrence of the transactions X Y and Z.

The server receives the appended signature 2222 and a processor of the server updates the LKS s 222 in a memory device of the server to match a value of the appended signature 2222 . When the LKS s having a value of 222 is updated to the value 2222 the LKS s becomes 2222 within a memory device of the server .

The LKS s having the value of 2222 is communicated from the server to the client via the network . Upon receiving the LKS s having the value of 2222 a processor associated with the client compares the LKS s with the appended signature. Upon determining that the value of the LKS s of 2222 matches the value 2222 of the appended signature the client updates the value 222 of LKS c to the value of 2222 and marks the transaction Z as complete.

Upon allowance of access by the server to client the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s 2222 with the context object CO to the client . The context object is the same as that communicated during the time period from the client to the server . Upon receipt of the signature 2222 the signature 2222 is stored in a memory device of the client by a processor of the client as LKS c . For example upon receipt of the signature 2222 any value of LKS c that is stored in a memory device of the client is updated by a processor associated with the client to the value 2222 .

When a transaction J occurs at the client the processor associated with the client appends an increment signature 2 to the LKS c at the client to generate an appended signature 22221 . Also when the transaction J occurs at the client the processor associated with the client generates a context object that includes a state of the client after occurrence of the transactions X Y Z and J. The client communicates the context object with the appended signature 22221 to the server .

Upon receiving the context object the server updates in a memory device of the server the context object that was communicated during the time period with the context object received from the client during the time period . For example the updated context object includes information about the state of the client after occurrence of the transactions X Y and Z and about the state of the client after occurrence of the transaction J.

The server receives the appended signature 22221 and a processor of the server updates the LKS s 2222 that is stored within a memory device of the server to match a value of the appended signature 22221 . When the LKS s having a value of 2222 is updated to the value 22221 within a memory device of the server the LKS s becomes 22221 .

The LKS s having the value of 22221 is communicated from the server to the client via the network . Upon receiving the LKS s having the value of 22221 a processor associated with the client compares the LKS s with the appended signature. Upon determining that the value of the LKS s of 22221 matches the value 22221 of the appended signature the client updates the value 2222 of LKS c to the value of 22221 and marks the transaction J as complete.

It should be noted that the time periods thru described above in are consecutive time periods. For example the time period follows the time period and the time period follows the time period .

It should further be noted that a context object and a signature are communicated between a network interface card or a modem of a client device and the game interface of the server via the network . For example a context object and or a signature are sent from a server by the game interface of the server. As another example a context object and or a signature are sent from a client device by a network interface card or modem of the client device. Moreover the communication of the read request the context object and the LKS s are performed during the time period as shown in . Upon receipt of the signature 2 the signature 2 is stored in a memory device of the client by a processor of the client as LKS c .

Upon allowance of access the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s 222 with the context object CO to the client . The context object is the same as that communicated during the time period from the client to the server . Upon receipt of the signature 222 the signature 222 is stored in a memory device of the client by a processor of the client as LKS c . For example upon receipt of the signature 222 any value of LKS c that is stored in a memory device of the client is updated by a processor associated with the client to the value 222 .

When the transaction K occurs at the client the processor associated with the client appends an increment signature 1 to the LKS c at the client to generate an appended signature 2221 . Also when the transaction K occurs at the client the processor associated with the client generates a context object that includes a state of the client after occurrence of the transactions X Y and K. The client communicates the context object with the appended signature 2221 to the server .

Upon receiving the context object the server updates in a memory device of the server the context object that was communicated during the time period with the context object received from the client during the time period . For example the updated context object includes information about the state of the client after occurrence of the transactions X and Y and about the state of the client after occurrence of the transaction K.

The server receives the appended signature 2221 and a processor of the server updates the LKS s 222 to match a value of the appended signature 2221 . When the LKS s having a value of 222 is updated to the value 2221 the LKS s becomes 2221 .

The LKS s having the value of 2221 is communicated from the server to the client via the network . Upon receiving the LKS s having the value of 2221 a processor associated with the client compares the LKS s with the appended signature. Upon determining that the value of the LKS s of 2221 matches the value 2221 of the appended signature the client updates the value of 222 of LKS c to the value of 2221 and marks the transaction K as complete.

After the lack of reception of the LKS s having the value of 222 by the client during the time period and upon regaining access to the server the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s 2221 with a context object CO to the client . The context object sent to the client is the same as the updated context object described above with reference to time period and that includes state of the client after occurrence of the transactions X and Y and state of the client after occurrence of the transaction K.

Upon receiving the LKS s having the value of 2221 a processor associated with the client compares the LKS s with the appended signature that was sent during the time period . Upon determining that the LKS s of 2221 lacks a match with the value 222 of the appended signature a processor of the client changes the value 22 of LKS c to match the value 2221 of LKS s and marks the transactions Y and K as complete. The portion 1 of the value 2221 of LKS c identifies the client and the transaction K.

In some embodiments the server sends a client identifier of a client to the remaining clients via the network before receiving a read request from the remaining clients. For example the server sends an identifier of the client to the client before receiving a read request from the client and sends an identifier of the client to the client before receiving a read request from the client . In these embodiments the remaining clients recognize a client at which a transaction occurred based on an identifier that is received from the server . In these embodiments when an inclusion of an identification of a client at which a transaction is performed in a communication between the remaining clients and the server the remaining clients are informed that the transaction was performed at the client.

When a transaction L occurs at the client the processor associated with the client appends an increment signature 1 to the LKS c having a value of 2221 at the client to generate an appended signature 22211 . Also when the transaction L occurs at the client the processor associated with the client generates a context object that describes a state of the client after occurrence of the transactions X Y K and L. The client communicates the context object with the appended signature 22211 to the server . The appended signature having the value of 22211 and the context object are not received by the server due to a loss of access to the server by the client .

After the lack of reception of the appended signature having the value of 22211 and the context object by the server and upon regaining access to the server the client sends a read request to the server to read the LKS s from the server . Upon receiving the read request the server sends the LKS s 2221 with a context object CO to the client . The context object sent to the client is the same as the context object that is described above with reference to time period of .

Upon receiving the LKS s having the value of 2221 a processor associated with the client compares the LKS s with the value 22211 of the appended signature that was sent during the time period of . Upon determining that the value of the LKS s of 2221 lacks a match with the value 22211 of the appended signature a processor of the client decides to resend the appended signature having the value 22211 to the server .

A processor associated with the client resends the context object and the appended signature having the value 22211 to the server . The context object is the same as that sent during the time period of .

Upon receiving the context object the server updates in a memory device of the server the context object that was communicated during the time period of with the context object received from the client during the time period . For example the updated context object includes information about the state of the client after occurrence of the transactions X and Y and about the state of the client after occurrence of the transactions K and L.

The server receives the appended signature 22211 and a processor of the server updates the LKS s 2221 to match a value of the appended signature 22211 . When the LKS s having a value of 2221 is updated to the value 22211 the LKS s becomes 22211 .

The LKS s having the value of 22211 is communicated from the server to the client via the network . Upon receiving the LKS s having the value of 22211 a processor associated with the client compares the LKS s with the value 22211 of the appended signature. Upon determining that the value of the LKS s of 22211 matches the value 22211 of the appended signature the client updates the value 2221 of LKS c to the value of 22211 and marks the transaction L as complete.

It should be noted that the time periods thru described above in are consecutive time periods. For example the time period follows the time period and the time period follows the time period .

It should further be noted that in some embodiments the server determines based on an identification of a client within an appended signature received from the client whether the client is registered with the server . If the client is not registered the server determines that the client is fraudulent and sends a notification to the remaining clients that the client is fraudulent.

It should be noted that the integers 1 2 and so on that are used as increment signatures are examples of increment signatures. For example any other identifier that identifies a client or a combination of a client and transaction is used as an increment signature. As another example an increment signature includes a bit a bit stream or a token.

During the time period t upon allowance of access to client A by the server a data signature AAABBBABC and a version 0 are received by the client A from the server . The data signature AAABBBABC is a last known signature at the server . The version 0 is a version of a context object that is stored in a memory device of the server .

Moreover during the time period t upon allowance of access to client B by the server the data signature AAABBBABC and the version 0 are received by the client B from the server .

Moreover during the time period t a transaction occurs at the client A. When the transaction occurs the data signature AAABBBABC received by the client A during the time period tis modified to a data signature AAABBBABCA by a processor associated with the client A and sent to the server . The server receives the data signature AAABBBABCA to update the last known signature from AAABBBABC to AAABBBABCA .

Moreover when the transaction occurs the version 0 that is stored at the client A is sent to the server . The server receives the version 0 to update the version 0 to a version 1 which is a version that indicates that the transaction occurred at the client A during the time period t.

During the time period t the server gets disconnected from the client A and the client A does not receive the updated last known signature of AAABBBABCA and the version 1 from the server .

During the time period t upon allowance of access to client B by the server the last known signature AAABBBABCA and the version 1 are received by the client B from the server .

Moreover during the time period t a first transaction occurs at the client B. When the first transaction occurs at the client B the data signature AAABBBABCA received by the client B during the time period tis modified to a data signature AAABBBABCAB by a processor associated with the client B and sent to the server . The server receives the data signature AAABBBABCAB to update the last known signature from AAABBBABCA to AAABBBABCAB .

Furthermore when the first transaction occurs at the client B the version 1 of the context object that is stored at the client B is sent to the server . The server receives the version 1 but does not update the version 1 to a version 2. It should be noted that a version number indicates a highest number of transactions occurring at a client among multiple clients that are coupled with the server rather than a cumulative number of transactions at the multiple clients. For example if two transactions occur at the client B and one transaction occurs at the client A the version number at the server is two. As another example if three transactions occur at the client A and one transaction occurs at the client B the version number at the server is three.

During the time period t upon allowance of access to client A by the server after the loss of connection with the server the last known signature AAABBBABCAB and the version 1 are received by the client A from the server . It should be noted that the version 1 is the same as that after reception during the time period t of the data signature AAABBBABCA from the client A. There is no change in the version number after the reception during the time period t of the data signature AAABBBABCA from the client A although client B sent the data signature AAABBBABCAB which indicated an occurrence of a transaction at the client B during the time period t.

During the time period t a second transaction occurs at the client B. When the second transaction occurs the last known signature at the server of AAABBBABCAB is modified to a data signature AAABBBABCABB by a processor associated with the client B and sent to the server . Moreover the version 1 that is received by the client B during the time period tis sent to the server .

When the data signature AAABBBABCABB and the version 1 are in transit between the client B and the server the client B looses access to the server and the data signature and the version 1 are not received by the server . The server does not update the last known signature from AAABBBABCAB to AAABBBABCABB and does not update the version 1 to a version 2. The update of the version 1 to version 2 indicates that the second transaction has occurred at the client B.

During the time period t the client B is allowed access to the server and the last known signature of AAABBBAB CAB and the version 1 are received from the server .

During the time period t the client B resends the signature AAABBBABCABB and the version 1 to the server .

Upon reception of the signature AAABBBABCABB the server updates the last known signature from AAABBBABCAB to AAABBBABCABB and the version 1 to a version 2 to indicate that a second transaction occurred at one of the clients A B and C which is the second transaction at the client B.

During the time period t the client A is allowed access to the server and the last known signature of AAABBBABCABB and the version 2 are received from the server by the client A.

During the time period t the client B is allowed access to the server and the last known signature of AAABBBABCABB and the version 2 are received from the server by the client B.

It should be noted that the time periods tthru tdescribed above in are consecutive time periods. For example the time period tfollows the time period tand the time period tfollows the time period t.

It should further be noted that various functions described herein as being performed by a client device are performed by one or more processors of the client device. Similarly in some embodiments various functions described herein as being performed by the server are performed by one or more processors of the server .

It should also be noted that the letters A B C and so on that are used as increment signatures are examples of increment signatures. For example any other identifier that identifies a client or a combination of a client and transaction is used as an increment signature. As another example an increment signature includes a bit a bit stream or a token.

The various embodiments described above are described with reference to the server . In other embodiments multiple servers instead of the server perform the same functions and communications with clients as that performed by the server . Moreover the various embodiments described above involve appending an increment signature to generate an appended signature. In some embodiments an increment signature is prepended to a last known signature LKS c to generate a prepended signature.

When a player provides an input into the player s client device the client device may in response send a message via the communications network to the social networking server. The social networking server may update the player profile save the message to a database send messages to other players etc. The social gaming network may include a social graph database which stores player relationships social player profiles player messages and player social data.

The gaming servers host one or more game applications and perform the computations necessary to provide gaming features to the players and client devices A thru F. One or more gaming realm databases store data related to the gaming services such as the game applications and modules virtual gaming environment realm data player gaming session data player scores player virtual gaming profiles game stage levels etc. The gaming servers may utilize the data from the gaming realm databases to perform the computations related to providing gaming services for the players . In some implementations a server load database stores gaming server load statistics such as computational load server responses times etc.

The social gaming network may include one or more load balancing servers and one or more live interaction servers . The live interaction servers monitor which players are online and determine if a player s neighbors are currently online This allows live interactions between players as described below in more detail with reference to . In one embodiment a social data cache stores some of the graph data related to player game links e.g. neighbors for fast access to the social data.

The gaming servers are used to execute the online games and hold the gaming data which can be shared with social networking servers and live interaction servers . The game data e.g. game updates may be sent periodically without responding to a request or might be sent in response to a request or might be sent in combination piggy backed with other information exchanged between the servers e.g. game progress or activities data . In one embodiment live interaction servers periodically poll gaming servers requesting the list of players that are online playing the game or the list of neighbors of a particular player that are currently online. In one embodiment polling is performed every 15 seconds and in another embodiment the polling interval is in the range between 5 seconds and 5 minutes although other values are also possible.

In one embodiment communications between the players are managed by the live interaction servers . A first player knows that a second player is online because the live interaction servers have notified the first player that the second player is online playing the game of course the first player and the second player are friends in the online game . When the first player sends a message to the second player the game of the first player sends the message to the live interaction servers which forward the message to the game of the second player. Similarly when the second player wants to send a message to the first player the message is sent through live interaction servers .

In another embodiment the game update information sent by the gaming servers includes information regarding the players playing a particular game as well as information regarding users that are playing other online games. This way a player may receive information about the neighbors that are playing the same online game or about the neighbors that are playing other online games. The game updates sent from the gaming servers include information regarding the status of the neighbor s game. The status may include score current activities requests for help recent progress made in the game sign on and sign off information etc.

Live interaction servers keep track of which neighbors are online at a given time. Live interaction servers analyze the game updates received from gaming servers and create social game data to inform users of neighbor s activities. These activities may include information on which neighbors are online neighbor s recent activities e.g. game progress news etc.

It should be noted that any of the social networking servers the gaming servers the live interaction servers and the load balancing servers are examples of the server . It is noted that the embodiments illustrated in are exemplary. Other embodiments may utilize different server configurations divide the tasks differently among the servers or exchange information between servers in different forms. The embodiments illustrated in should therefore not be interpreted to be exclusive or limiting but rather exemplary or illustrative.

Each game server has access to one or more game databases for storing game data. In addition a single database can store game data for one or more online games. Each game server may also include one or more levels of caching. Game data cache is a game data cache for the game data stored in game databases . For increased performance caching may be performed in several levels of caching. For instance data more frequently used is stored in a high priority cache while data requiring less access during a session will be cached and updated less frequently.

The number of game servers changes over time as the gaming platform is an extensible platform that changes the number of game servers according to the load on the gaming infrastructure. As a result the number of game servers will be higher during peak playing times and the number of game servers will be lower during off peak hours. In one embodiment the increase or decrease of bandwidth is executed automatically based on current line usage or based on historical data.

One or more social network management servers provide support for the social features incorporated into the online games. The social network management servers access social data from one or more social networks via Application Programming Interfaces API made available by the social network providers. Each social network includes social data and this social data or a fraction of the social data is made available via API . As in the case of the game servers the number of social network management servers that are active at a point in time changes according to the load on the infrastructure. As the demand for social data increases the number of social network management servers increases. Social network management servers cache user data in database and social data in database . The social data might include the social networks where a player is present the social relationships for the player the frequency of interaction of the player with the social network and with other players etc. Additionally the user data kept in database may include the player s name demographics e mail games played frequency of access to the game infrastructure etc.

It is noted that the embodiment illustrated in is an exemplary online gaming infrastructure. Other embodiments may utilize different types of servers databases APIs etc. and the functionality of several servers can be provided by a single server or the functionality can be spread across a plurality of distributed servers. The embodiment illustrated in should therefore not be interpreted to be exclusive or limiting but rather exemplary or illustrative.

One or more links couple a server or a client to network . In particular embodiments one or more links each includes one or more wireline wireless or optical links . In particular embodiments one or more links each includes an intranet an extranet a VPN a LAN a WLAN a WAN a MAN a portion of the Internet or another link or a combination of two or more such links .

Each server may be a stand alone server or may be a distributed server spanning multiple computers or multiple datacenters. Servers may be of various types such as for example and without limitation web server news server mail server message server advertising server file server application server exchange server database server or proxy server. Each server may include hardware software embedded logic components or a combination of two or more such components for carrying out the appropriate functionalities implemented or supported by server . For example a web server is generally capable of hosting websites containing web pages or particular elements of web pages. More specifically a web server may host hypertext markup language HTML files or other file types or may dynamically create or constitute files upon a request and communicate them to clients in response to HTTP or other requests from clients . A mail server is generally capable of providing electronic mail services to various clients . A database server is generally capable of providing an interface for managing data stored in one or more data stores.

In particular embodiments one or more data storages may be communicatively linked to one or more severs via one or more links . Data storages may be used to store various types of information. The information stored in data storages may be organized according to specific data structures. In particular embodiments each data storage may be a relational database. Particular embodiments may provide interfaces that enable servers or clients to manage e.g. retrieve modify add or delete the information stored in data storage .

In particular embodiments each client may be an electronic device including hardware software or embedded logic components or a combination of two or more such components and capable of carrying out the appropriate functionalities implemented or supported by client . For example and without limitation a client may be a desktop computer system a notebook computer system a netbook computer system a handheld electronic device or a mobile telephone. A client may enable a network player at client to access network . A client may enable a player to communicate with other players at other clients . Further each client may be a computing device such as a desktop computer or a work station or a mobile device such as a notebook computer a network computer or a smart telephone.

In particular embodiments a client may have a web browser and may have one or more add ons plug ins or other extensions. A player at client may enter a Uniform Resource Locator URL or other address directing the web browser to a server and the web browser may generate a Hyper Text Transfer Protocol HTTP request and communicate the HTTP request to server . Server may accept the HTTP request and communicate to client one or more Hyper Text Markup Language HTML files responsive to the HTTP request. Client may render a web page based on the HTML files from server for presentation to the user. The present disclosure contemplates any suitable web page files. As an example and not by way of limitation web pages may render from HTML files Extensible Hyper Text Markup Language XHTML files or Extensible Markup Language XML files according to particular needs. Such pages may also execute scripts such as for example and without limitation those written in JavaScript Java Microsoft Silverlight combinations of markup language and scripts such as AJAX Asynchronous JAVASCRIPT and XML and the like. Herein reference to a web page encompasses one or more corresponding web page files which a browser may use to render the web page and vice versa where appropriate.

Web browser may be adapted for the type of client where the web browser executes. For example a web browser residing on a desktop computer may differ e.g. in functionalities from a web browser residing on a mobile device. A user of a social networking system may access the website via web browser .

As example and not by way of limitation computer system may be an embedded computer system a system on chip SOC a single board computer system SBC such as for example a client device a computer on module COM or system on module SOM a desktop computer system a laptop or notebook computer system an interactive kiosk a mainframe a mesh of computer systems a mobile telephone a personal digital assistant PDA a server or a combination of two or more of these. Where appropriate computer system may include one or more computer systems be stand alone or distributed span multiple locations span multiple machines or reside in a cloud which may include one or more cloud components in one or more networks. The one or more computer systems may perform in real time or in batch mode one or more operations of one or more methods described or illustrated herein.

In particular embodiments computer system includes a processor memory storage an input output I O interface a communication interface and a bus . Although this disclosure describes and illustrates a particular computer system having a particular number of particular components in a particular arrangement embodiments of the invention may be implemented with any suitable computer system having any suitable number of any suitable components in any suitable arrangement.

In particular embodiments processor includes hardware for executing instructions such as those making up a computer program. As an example and not by way of limitation to execute instructions processor may retrieve or fetch the instructions from an internal register an internal cache memory or storage decode and execute them and then write one or more results to an internal register an internal cache memory or storage . The present disclosure contemplates processor including any suitable number of any suitable internal registers where appropriate. Where appropriate processor may include one or more arithmetic logic units ALUs be a multi core processor or include one or more processors . Although this disclosure describes and illustrates a particular processor this disclosure contemplates any suitable processor.

In particular embodiments memory includes main memory for storing instructions for processor to execute or data that can be manipulated by processor . As an example and not by way of limitation computer system may load instructions from storage or another source such as for example another computer system to memory . Processor may then load the instructions from memory to an internal register or internal cache. During or after execution of the instructions processor may write one or more results which may be intermediate or final results to the internal register or internal cache. Processor may then write one or more of those results to memory . One or more memory buses which may each include an address bus and a data bus may couple processor to memory . Bus may include one or more memory buses as described below. One or more memory management units MMUs reside between processor and memory and facilitate accesses to memory requested by processor . Memory includes random access memory RAM .

As an example and not by way of limitation storage may include a hard disk HD a floppy disk a flash memory an optical disc a magneto optical disc a magnetic tape or a combination of two or more of these. Storage may include removable or non removable or fixed media where appropriate. In particular embodiments storage includes a ROM. Where appropriate this ROM may be mask programmed ROM programmable ROM PROM erasable PROM EPROM electrically erasable PROM EEPROM electrically alterable ROM EAROM or flash memory or a combination of two or more of these.

In particular embodiments I O interface includes hardware software or both providing one or more interfaces for communication between computer system and one or more I O devices. One or more of these I O devices may enable communication between a user and computer system . As an example and not by way of limitation an I O device may include an input device an output device or a combination thereof. Examples of the I O device include a keyboard a keypad a microphone a monitor a mouse a printer a scanner a speaker a still camera a stylus a touch screen a trackball or a combination of two or more of these.

Communication interface includes hardware software or both providing one or more interfaces for communication between computer system and one or more other computer systems on one or more networks. As an example and not by way of limitation communication interface may include a network interface controller NIC or network adapter for communicating with an Ethernet or other wire based network or a wireless NIC WNIC or wireless adapter for communicating with a wireless network such as a Wi Fi network. As an example computer system may communicate with a wireless personal area network WPAN such as for example a Bluetooth WPAN a Wi Fi network a worldwide interoperability for microwave access WiMAX network a cellular telephone network such as for example a Global System for Mobile Communications GSM network or other suitable wireless network or a combination of two or more of these. As another example the communication interface includes a network interface card or a modem.

In particular embodiments bus includes hardware software or both coupling components of computer system to each other. As an example and not by way of limitation bus may include an Accelerated Graphics Port AGP or other graphics bus an Enhanced Industry Standard Architecture EISA bus a front side bus FSB a HyperTransport HT interconnect an Industry Standard Architecture ISA bus an Infiniband interconnect a low pin count LPC bus a memory bus a Micro Channel Architecture MCA bus a Peripheral Component Interconnect PCI bus a PCI Express PCI X bus a serial advanced technology attachment SATA bus a Video Electronics Standards Association local VLB bus or another suitable bus or a combination of two or more of these. Bus may include one or more buses where appropriate. Although this disclosure describes and illustrates a particular bus this disclosure contemplates any suitable bus or interconnect.

Herein reference to a computer readable storage medium encompasses one or more non transitory tangible computer readable storage media possessing structure that may store a computer program a module information bit stream identifier signature context object client state or data. As an example and not by way of limitation a computer readable storage medium may include a semiconductor based or other integrated circuit IC such as for example a field programmable gate array FPGA or an ASIC a hard disk an optical disc a magneto optical disc a floppy disk a magnetic tape a holographic storage medium a solid state disk SSD a RAM a Secure Digital card or another suitable computer readable storage medium or a combination of two or more of these where appropriate. In some embodiments any of the functions described herein are stored on one or more computer readable storage media that is accessed by one or more processors to perform the functions.

In one embodiment a module as used herein is embodied as computer readable code on a computer readable storage medium. The computer readable storage medium is any data storage device or a memory device that can store data which can be thereafter be read by a computer. Examples of the computer readable storage medium include hard drives network attached storage NAS ROM random access memory compact disc ROMs CD ROMs CD recordables CD Rs CD rewritables RWs magnetic tapes and other optical and non optical data storage devices. In some embodiments the computer readable storage medium can be distributed over a network coupled computer system so that the computer readable code is stored and executed in a distributed fashion.

Embodiments of the present invention may be practiced with various computer system configurations including hand held devices microprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like. The embodiments can also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a wire based or wireless network.

With the above embodiments in mind it should be understood that the embodiments can employ various computer implemented operations involving data stored in computer systems. These operations are those requiring physical manipulation of physical quantities. Any of the operations described herein that form part of the embodiments of the present invention are useful machine operations. The embodiments of the present invention also relate to a device or an apparatus for performing these operations. The apparatus can be specially constructed for a specific purpose. The apparatus is selectively activated or configured by a computer program stored in the computer.

Although the foregoing invention has been described in some detail for purposes of clarity of understanding it will be apparent that certain changes and modifications can be practiced within the scope of the appended claims. Accordingly the present embodiments are to be considered as illustrative and not restrictive and the invention is not to be limited to the details given herein but may be modified within the scope and equivalents of the appended claims.

