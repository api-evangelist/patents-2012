---

title: High throughput, reliable replication of transformed data in information systems
abstract: Provided are techniques for, in response to a source object being changed by a local transaction, generating log records, wherein each of the log records includes a sequence identifier, a source system entity modification timestamp, a target key, a target partition identifier, and values of source properties, wherein the source properties are identified using a target key indicator. The log records to process are selected based on a phase value of each log record, wherein the phase value is one of submitted, in-flight, and source system entity state change complete. One or more disjoint partitions are assigned to each of multiple processing instances. Under control of each of the multiple processing instances, it is determined whether to transmit a log record in the one or more disjoint partitions assigned to said processing instance and, in response to determining that the log record is to be transmitted, the log record is transmitted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09002802&OS=09002802&RS=09002802
owner: International Business Machines Corporation
number: 09002802
owner_city: Armonk
owner_country: US
publication_date: 20120712
---
This application is a continuation of U.S. patent application Ser. No. 12 631 641 filed on Dec. 4 2009 which application is incorporated herein by reference in its entirety.

Embodiments of the invention relate to high throughput reliable replication of transformed data in information systems.

Information often exists in multiple locations within an organization within an enterprise or even more globally across enterprises. Often this information is represented in an optimal way for local applications and usually not all applications within the organization within an enterprise or even more globally across enterprises require use or even want or are allowed to access all of the information that exists. However it is increasingly common that more and more of this information is shared and utilized in local applications. The sharing transformation and local use of that information is a root capability that allows a consistent view of data enables cross selling scenarios and enables significant business optimization and identification of new business opportunities.

Conventional systems result in high implementation costs which often are incurred on every deployment of trying to integrate one local source system executing the local applications to some other target system. The local target calls tend to be very specific to the target system and often times very specific to the configuration of that target system. Conventional systems used in replication and data transformation stop short of integrating with local target calls using parameter values derived from the data transformation. This results in a high cost to program the local target calls due to the cost of implementing and integrating the local target calls within the conventional systems. This high cost results in many of these types of projects not being able to be funded in the first place and taking significant time to implement test and deploy particularly at an enterprise level.

Conventional systems that require strong data integrity rely on traditional transaction serialization of the entire workload sometimes even using two phase commit between the two systems to insure data integrity. This serialization has serious performance consequences on both the source and target systems due to the latency that is introduced into the source system transactions which now become distributed transactions . This latency means that increased serialization occurs due to more locks being held for longer duration which reduces overall throughput. It also has high availability impacts since the overall system depends on the entire overall system being available all the time. Conventional systems rely on source transaction serialization to order the execution on the target system and hence are unable to be fully parallelized to take advantage of high performance clusters.

There is a need for high throughput replication due to the multiple locations transformation due to local representations of data and the applications that run against that data and the need for data integrity consistent trusted enterprise wide data . Thus there is a need for high throughput reliable replication of transformed data in information systems.

Provided are a method computer program product and system for in response to a source object being changed by a local transaction generating log records wherein each of the log records includes a sequence identifier a source system entity modification timestamp a target key a target partition identifier and values of source properties wherein the source properties are identified using a target key indicator. The log records to process are selected based on a phase value of each log record wherein the phase value is one of submitted in flight and source system entity state change complete. One or more disjoint partitions are assigned to each of multiple processing instances. Under control of each of the multiple processing instances it is determined whether to transmit a log record in the one or more disjoint partitions assigned to said processing instance and in response to determining that the log record is to be transmitted the log record is transmitted.

In the following description reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments of the invention. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of the invention.

Embodiments provide extensibility mechanisms maintain system integrity improve throughput by enabling high degrees of parallelism in how and when the local calls are made that preserve the overall data and transaction integrity.

The capabilities provided by embodiments are implemented in a framework that results in minimal programming for the user of the framework. The core design of the framework itself is also described herein to enable effective implementations and optimizations of this framework.

The source system receives a transaction e.g. tx tx tx . . . txn and routes the transaction to the computing device . Source local applications at the source system issue the transactions. The transactions change data e.g. source objects on the source system . The computing device performs high throughput reliable replication of transformed data between information systems as represented by source system labeled and target system labeled . The log generation component uses the changed data to generate data in a log as represented by log . The details of the structure definition of the log are described in . The log optimizations component processes and optimizes the log and generates additional data in the log . The target system transforms component performs data transformation and routes the transformed data to the target system which also generates additional data in the log . Transactions e.g. tx . . . txp may then use the transformed data. Thus data is changed by the source system and the changed data is transformed by the target system transforms component at the computing device .

In certain embodiments there is one source data change at a time. Each change is tagged with a source transaction identifier. Also each change is tagged with the operation code i.e. insert update or delete of the source transaction. In certain embodiments there are multiple rows in the source data change and each of the rows has multiple attributes.

Within a source transaction there may be multiple statements to be executed and there may be data changes for each of the multiple statements. Embodiments apply data transformations for the source transaction having a source transaction identifier. There may be one or more source data changes per transaction. In certain embodiments function execution order within a single data transformation is provided i.e. to avoid intermediate exceptions in establishing maintaining primary key foreign key relationships .

In certain embodiments the system illustrated in may be described as a replication pipeline starting from detecting deltas in the source system to extraction transformation and delivery to the target system in a reliable and correctly ordered way.

The source system entity instance has access to source document models e.g. D3 and proxy target flat models e.g. M3 . A proxy target flat model may be described as a flattened emulation of a target data model on the source system that has no real instance data. This is used for convenience of implementation and strong system metadata validation checks together with the contents of the map table. For example D3 may be a metadata document model for a scanned image representing an identity document such as a drivers license passport or birth certificate. This metadata document model is implemented in the data modeling capabilities of the source system. In ECM systems this may be an object based data model. For example M3 may be a flat relational representation of the same or similar information as stored in D3 in a DataBase Management System DBMS or D3 may be eXtensible Markup Language XML or some other data model representation supported by the target system. In certain embodiments the source document models are object models and the proxy target flat models are relational models. A D3 Instance is changed via a source transaction to D3 Instance . For a transaction the event handler accesses a document model state information for the transaction from state and a row from a map labeled map . The event handler forwards the document model the state information and the row to the log generator . The log generator accesses the map converts the source document model into an intermediate model using the row from the map and returns data to the event handler . The event handler writes to the log . The log processor processes the log. The target type handler uses the map to complete data transformation from intermediate to target . The target interface s I F s provide one or more interfaces for invoking appropriate Application Programming Interfaces APIs with appropriate parameters. The data values from the completed data transformation are used as parameters to the appropriate application programming interfaces.

In certain embodiments the functionality of the log generation component is implemented with the event handler the log generator state and map . In certain embodiments the functionality of log optimizations component is implemented in the log processor . In certain embodiments the functionality of the target system transformations component is implemented in the target type handler and the target I F s .

The structures create high data integrity without requiring two phase commit. Also target system entity table and source system entity link table reduce messages and code paths by recognizing duplicates early in the processing.

The target system entity table includes attributes for a target key a target handle a source system entity reference count and a source system entity modification timestamp.

The source system entity link table includes attributes for a link identifier a source key and a target key. The link identifier may be described as a unique number given to the link. A link is formed between the source data model abstract instances e.g. documents and the target data model abstract instances. With embodiments there is an association between the source data model abstract instances e.g. documents and the source system entity link table and there is a 1 to many associations between the target system entity table and the link table .

If the operation code for a log record is insert then a link is added i.e. a row is added to the source system entity link table and the source system entity reference count is incremented. If the operation code is delete then the link is removed i.e. by deleting a corresponding row from the source system entity link table and the source system entity reference count is decremented. If the operation code is update then no changes are needed to the source system entity link table or the source system entity reference count.

In certain embodiments the log is implemented as log table . The log table includes attributes for a sequence number which identifies the order in which transactions completed on the source system entity instance a transaction identifier operations code i.e. insert update or delete source system entity modification timestamp which indicates the last time the source object was modified target type target key target partition identifier intermediate form payload which has values to be transmitted in intermediate form phase value phase timestamp and disposition e.g. transmit successful transmit failed or not transmitted . In certain embodiments a monotonic atomic sequence number generator generates the sequence numbers. In certain embodiments the target type is a target data type instance for an M3 model. For example if the document is an identity document then certain properties such as name may be represented with a specific type in the target M3 model. This could be a simple string type a fixed length character string or a structure for first name middle name or middle initial and last name. The phase value reflects a phase in a log record lifecycle of submitted in flight source system entity state change complete and completed i.e. target system entity state change complete . After a system cold start processing can begin based on the phase identified by the phase value. In certain embodiments the log table also includes a source key that is obtained e.g. copied over from the source object and the source key indicator is used to determine which source properties should be used to generate the source key.

In certain embodiments the map is implemented as the map table . The map table includes attributes for a map identifier a source type a source properties identifier a source method identifier a source key indicator a target type a target properties identifier a target method identifier and a target key indicator. Each row of the map table represents a property transformation specification. In certain embodiments the map table is pre populated for a given instance of the system with a mapping either with or without using some a visualization tool that provides ease of selection and association of source entity properties with a target entity property and requisite methods to accomplish the system goals.

Embodiments perform entity function mapping. In certain embodiments the mapping is defined at system e.g. configuration time. The map defines the target functions and target parameters for those target functions. The map defines the source functions and transformed data instances e.g. type and schema . The map defines how a source function maps to a target function. The map defines how a transformed data instance maps to a target function parameter. The map defines the target function code to be executed through dynamic binding.

Embodiments map each source function value to a target function parameter. The target parameters for a given target function are grouped together so that one target function execution can be applied. Defaults nulls error generation or other techniques are used for any remaining unassigned parameters. In some embodiments typical Domain Integrity rules may be used for unassigned parameters.

In block the log generation component uses the target key indicator of each of the rows in the selected group of rows to identify source properties wherein the target key indicator indicates which source properties are to be used to generate a target key i.e. key source properties and which source properties are not used to generate the target key i.e. non key source properties . For example the target key indicator may provide a bit for each of a set of source properties and when the bit is set to TRUE the value of the associated source property is used to generate the target key.

In block the log generation component extracts values of the identified source properties from the source object and stores the extracted values in a buffer in an order specified by the map identifier in each of the rows in the selected group. Processing continues from block to block .

In block the log generation component hashes the values of the key source properties to generate a target key and adds the target key to the buffer. At this time the buffer stores the values of the key source properties the values of the non key source properties and the target key. In block the log generation component hashes the target key to generate a target partition identifier and adds the target partition identifier to the buffer. In certain embodiments the number of partitions is pre defined N and the hash used in block generates a target partition identifier in the range of 0 to N 1 .

In block the log generation component for each source property for which there exists a source method executes the source method and replaces the value of the source property in the buffer with the result value returned by the executed source method. That is a source method may not exist for a particular source property.

At this time the buffer stores the values of the key source properties the values of the non key source properties the target key and the target partition identifier. The values of the key source properties and the values of the non key source properties form the intermediate form payload. In block the log generation component generates a log record by writing the values stored in the buffer a sequence number a transaction identifier an operations code a source system entity modification timestamp a target type a phase value that indicates a phase value of submitted a phase timestamp and a disposition into the log record. In some embodiment the sequence number is generated in accordance with an atomic monotonic sequence number generator of sufficiently large precision.

In block the log generation component determines whether all groups have been selected. If so processing is done otherwise processing continues to block to select another group of rows having a same target type.

In certain embodiments for a given set of transactions the log consumer component finds transactions modifying the same key values in the source or finds transactions executing the same target with the same parameter values for one or more parameters. These identified transactions are executed serially in the original transaction order. Other transactions may be executed in any order.

In block the log optimizations component determines whether there are any new log records in the bucket. If so processing continues to block otherwise processing continues to block . In block the log optimizations component deletes the bucket from the dispatch table.

Thus once a bucket is deleted the log optimizations component selects another bucket for processing according to the logic of . In this manner the log optimizations component processes buckets one by one.

In block the log optimizations component determines whether the target key is in the target system entity table . If so processing continues to block otherwise processing continues to block . That is if the target key is in the target system entity table the log optimizations component performs additional processing to determine whether this log record should be transmitted or not. If the target key is not in the target system entity table the log optimizations component determines that this log record is to be transmitted.

In block the log optimizations component creates a new row with a target key in the target system entity table for the selected in memory log record. In block the log optimizations component creates a new row in the source system entity link table and increments a source system entity reference count in the target system entity table. From block processing continues to block .

In block the log optimizations component changes the phase value of the selected in memory log record to source system entity complete. In block the log optimizations component transmits the selected log record to the target system . Further details of the processing of block are described with reference to . In block the log optimizations component changes the phase value of the selected in memory log record to completed and changes the disposition of the selected in memory log record to transmit successful or transmit failed depending on whether the transmit was successful or failed. From block processing continues to block .

Returning to in block the log optimizations component determines whether the source system entity modification timestamp in the target system entity table is less than i.e. 

In block the log optimizations component determines whether there is a rule that indicates the selected in memory log record is to be transmitted. If so processing continues to block otherwise processing continues to block . In block the log optimizations component determines that the selected in memory log record is not to be transmitted to the target system . In block the log optimizations component changes the phase value of the selected in memory log record to completed and changes the disposition of the selected in memory log record to not transmitted .

As an example source local applications at the source system issue transactions that modify documents used for identification forms claims or some other artifact. For this example shows how data is collected from the source local applications that issue the transactions shows how correct ordering is maintained so integrity of source local documents for identity forms claims or other artifacts is maintained in the target system shows how even in system failure cases the data integrity is maintained and operations can be resumed after the failure has been corrected shows how optimizations work e.g. duplicate identity documents e.g. drivers license passport etc. while different in detail might all be treated the same and may not need to be transmitted and with reference to the target system may have APIs e.g. webservices based APIs around capabilities such as add a party that can be automatically invoked.

Thus the target system transforms component executes the generated linearized code with the identified parameters. The target system transforms component provides several extensibility points that are provided to ensure that not only data transformations are applied but also that the right local calls to the target system are invoked with the transformed data. Those local calls ensure that any additional semantics that are to be applied can be injected in to the overall flow correctly to maintain local integrity and local optimization.

By including the target interfaces i.e. the code blocks and plugging the transformed values into the parameters i.e. properties this minimizing programming that would otherwise have to done.

The dispatch table has a multiplicity of hash buckets each of which can be directly addressed with a key. The key used is the log record target key value. A hash bucket contains a single ordered queue. Each ordered queue in a bucket is associated with a specific target key. Each ordered queue can have a multiplicity of in memory log record entries all with the same target key. These entries are kept in order. Each in memory log record in this queue is a deliverable log row to the target system . The in memory log records in the queue are ordered by either sequence number or the source system entity modification timestamp. In certain embodiments the number of buckets fixed for the dispatch table is configurable The one or more queue worker threads consume the in memory records in order and in parallel from the hash buckets within the dispatch map and proceed to deliver the in memory log records to the target system using the flow described in and subsequently mark the log row as in completed phase with or without error.

In certain embodiments the log dispatch to the target system is single threaded in the order in which the target system is to process the transactions. The queue worker thread marks the log to completed phase when the target system type handler returns a handle.

Moreover the transaction reordering enables distributing the workload over more partitions than would otherwise normally occur and this leads to better parallelism.

Embodiments identify technology that enables an efficient and reliable way of achieving the root capability of sharing transformation and local use of information. Embodiments provide an ability to program an application or deployment specific extensibility in the data transformation to retain the local optimizations of how data is represented for local applications .

With embodiments data is transformed from a source system to a target system where it is assumed that each entity has an associated key. In certain embodiments the source key and the target key are the same. This can simplify type transformation or more sophisticated data model transformations. In certain embodiments it can be a combination of both type and data model transformations that are required due to the fundamental and non standard data models provided by certain systems. With embodiments the specific technique of transformation may include techniques available in the current art including Extensible Stylesheet Language Transformations XSLT . Embodiments assume that a design time technique of specifying one or more transformations is provided and a runtime execution technique of applying the transformation efficiently exists.

Embodiments provide an ability to optimize the order in which data transformations are applied that still results in strong data integrity while enabling efficient parallelism that is not available in conventional systems.

With embodiments new transactions with fully optimized parallelism are detected on the source system . This is a property built into the source system end and no special user customization is required to applications on the source system end. Embodiments recognize that transactions are to be applied in order of target key value not necessarily in order of original change order of the source system .

For example imagine a source system entity instance had two transactions S S executed in that temporal order where S updated a source system entity instance with property values P a P b and S updated the same source system instance with property values P b P d . If the target system entity instance uses a transformation for P that maps P to the primary key of the target system entity instance then in this case embodiments apply the target system transactions R and R in any target transaction order. This is allowed because although S S affected the same source system entity instance the target transactions would in essence affect independent target system entity instances. If however S and S both updated P a then the target system transactions R R are applied in the source system entity instance order since the target transaction is affecting the same target system instance .

In another example there are two transactions S and S occurring randomly on two independent source system entity instances where P a and P b in the first source system entity instance and P a and P c in the second source system entity instance then the target system transactions R and R follow the same natural order in which S and S actually occurred in the source system entity instances. This is because two source system entity instances have affected the same target system entity instance.

Embodiments provide are several techniques that are possible for ordering the target transactions and determining which ones are independent based on the high level design criteria. These techniques change depending on the throughput requirements required for the overall system demanding scaleup and scaleout approaches.

With embodiments transactions are applied using the transformed data obtained by executing extensible transformation procedures. Embodiments use a log which may be a data directed table to determine which function is appropriate to call. This function can be linked at runtime and can be application or deployment specific.

Embodiments are applicable to general information management e.g. DBMS scenarios where entity and model transformations in the context of replication and transactions are common. For example building a data warehouse or building a target system is another application of the embodiments disclosed herein.

Embodiments enable fewer servers to be required require less monitoring and management of those servers and enable more servers to be applied if needed.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The code implementing the described operations may further be implemented in hardware logic or circuitry e.g. an integrated circuit chip Programmable Gate Array PGA Application Specific Integrated Circuit ASIC etc.

Input Output I O devices including but not limited to keyboards displays pointing devices etc. may be coupled to the system either directly or through intervening I O controllers .

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modem and Ethernet cards are just a few of the currently available types of network adapters .

The system architecture may be coupled to storage e.g. a non volatile storage area such as magnetic disk drives optical disk drives a tape drive etc. . The storage may comprise an internal storage device or an attached or network accessible storage. Computer programs in storage may be loaded into the memory elements and executed by a processor in a manner known in the art.

The system architecture may include fewer components than illustrated additional components not illustrated herein or some combination of the components illustrated and additional components. The system architecture may comprise any computing device known in the art such as a mainframe server personal computer workstation laptop handheld computer telephony device network appliance virtualization device storage controller etc.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

The foregoing description of embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description but rather by the claims appended hereto. The above specification examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the embodiments the embodiments reside in the claims hereinafter appended or any subsequently filed claims and their equivalents.

