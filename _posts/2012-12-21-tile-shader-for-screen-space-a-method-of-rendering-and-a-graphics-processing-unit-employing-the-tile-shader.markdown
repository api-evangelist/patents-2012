---

title: Tile shader for screen space, a method of rendering and a graphics processing unit employing the tile shader
abstract: A tile shader for screen space of a graphics pipeline, a method of rendering graphics and a graphics processing unit are disclosed. In one embodiment, the tile shader includes: (1) an input interface configured to receive a tile of pixels for processing and (2) a tile processor configured to perform tile-level processing of the pixels.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09224227&OS=09224227&RS=09224227
owner: Nvidia Corporation
number: 09224227
owner_city: Santa Clara
owner_country: US
publication_date: 20121221
---
This application is directed in general to graphics processing units GPUs and more specifically to rendering in graphic pipelines of a GPU.

GPUs advantageously use parallel processing to efficiently perform select operations. Rendering is an example of such an operation. Rendering is the process of extracting data from world space and rendering it into a screen space. World space is three dimensional space that is often generated from a program run on a CPU. A GPU receives instructions from the CPU program generates the three dimensional world space based thereon and renders a two dimensional view for a display i.e. screen space from the world space. For example the CPU program can be a video game that sends instructions to the GPU for rendering a two dimensional view onto a display.

A GPU uses a graphics pipeline for the rendering process. Traditional graphics pipelines include fixed function units. In some conventional GPUs programmable function stages are solely used to form a graphics pipeline or are connected with fixed function units to form a graphics pipeline. Regardless of the type of graphics pipeline each stage modifies the input data and passes the modified data to the next stage of the pipeline for further modification to generate a view for the screen space.

Since a display view is usually a two dimensional view the rendering process considers depth and what a user would actually see on the display i.e. the user s view. Ztest is a function in graphics pipelines that is used to insure what a user sees on a display are the particular objects that are supposed to be seen. Ztest is used early and late early Z and late Z in the rendering process to determine if what is currently be drawn is either in front of or behind of what is already viewable on a display in screen space.

In one aspect the disclosure provides a tile shader for screen space of a graphics pipeline. In one embodiment the tile shader includes 1 an input interface configured to receive a tile of pixels for processing and 2 a tile processor configured to perform tile level processing of the pixels.

In another aspect a method of rendering in a graphics pipeline is disclosed. In one embodiment the method includes 1 receiving tiles of pixels for a screen space wherein the pixels were generated from a world space and 2 processing the tiles of the pixels for the screen space.

In yet another aspect a graphics processing unit is disclosed. In one embodiment the graphics processing unit includes 1 world space configured to generate screen space geometry data from three dimensional geometry data and 2 screen space coupled to the world space and including a raster stage configured to generate pixels from the screen space geometry data and a tile stage configured to perform screen space processing of the pixels at a tile level.

Current graphics pipelines typically support up to four shading stages either fixed function units or programmable shaders in the world space but only a single shading stage in screen space. The four world space shaders are for example a vertex shader a hull shader a domain shader and a geometry shader. The single screen space shader is a pixel shader. A pixel shader operates on every pixel covered by a particular object and returns the color of the pixel. Having just a shader stage that operates on individual pixels in the screen space of a graphics pipeline makes it difficult to efficiently perform operations on larger screen regions.

The disclosure therefore provides an additional shader stage for screen space. The additional shader stage referred to herein as a tile shader provides coarse screen space processing in a graphics pipeline by operating on tiles of pixels instead of individual pixels. A tile is a group or an array of pixels. In one embodiment a tile is an eight by eight 8 8 contiguous block of pixels. Thus the tile shader advantageously performs pixel processing at a tile level instead of just at the individual pixel level. As such a programmable tile shader can advantageously implement algorithms that perform screen space processing on larger screen regions instead of on individual pixels. Screen space processing is processing performed during the two dimensional processing portion of a graphics pipeline. In contrast to traditional graphics pipelines that perform screen space processing only on individual pixels the disclosure provides coarse screen space processing or screen space processing at a tile level in addition to processing at pixel level.

In one embodiment illustrated herein the tile shader is the first shader stage or programmable shader stage in the screen space of a graphics pipeline. Other fixed function stages such as raster and ZTest can precede the tile shader. The screen space or the screen space section is that portion or stages of a graphics pipeline that performs two dimensional operations such as rasterization and per pixel lighting. As defined herein a raster stage is considered the first stage of the screen space of a graphics pipeline. Similarly world space or the world space section is that portion of a graphics pipeline that performs three dimensional operations such as object transformations and projection. In one embodiment the tile shader is placed in the graphics pipeline between a depth test or Ztest and the pixel shader for early Z and between rasterization and pixel shader for late Z . In both late Z and early Z the pixel shader can be by passed for a Z only mode.

In contrast to conventional screen spaces that just include a pixel shader the disclosed screen space that includes a tile shader can assist in reducing pipeline computations. This can be seen when examining the operation of a GPU. A GPU can be fast and efficient based on the assumption that the same instructions can be executed for a large number of pixels at same time. This assumed the same steps of the program are followed for each of the pixels. If not the operating speed of the GPU is reduced.

The pixel kill option however kills pixel that do not need rendering. Killed pixels are not replaced by drawn pixels but are just dead. Thus the advantage of parallel processing is lost since there is an empty slot in GPU and the full compute power cannot be used.

With the tile shader a larger set of pixels can be examined and a determination made of what pixels will be killed and then killed at that point. As such the tile shader can then launch only those pixels to the pixel shader that will actually execute the whole program. The pixel shader can then more efficiently render since all pixels that are operated on by the pixel shader will actually generate results and will not get lost later.

The disclosed graphics pipeline can advantageously send all data through at one time to the tile shader for a coarse understanding of z axis issues. This then allows the tile shader to create a subset of pixels that actually need further processing. This pixel subset can then be reissued or launched by the tile shader for pixel processing. Thus in one embodiment the tile shader determines beforehand a subset of pixels that will need processing to prevent unnecessary work at the pixel stage and reduce computations in the graphics pipeline. This can prove beneficial since determining pixel color in a pixel shader is usually the most expensive mode of the rendering operations.

Before describing various embodiments of the novel graphics pipeline tile shader and methods of operating associated therewith a computing system within which each of these may be embodied or employed will be described.

As shown the system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and sends instructions and or data i.e. work or tasks to complete to a graphics processing unit to complete. The system memory typically includes dynamic random access memory DRAM used to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives the transmitted work from the CPU and processes the work employing a graphics processing unit GPU thereof. In this embodiment the GPU completes the work in order to render and display graphics images on the display devices . In other embodiments the GPU or the graphics processing subsystem as a whole can be used for non graphics processing.

As also shown the system memory includes an application program an application programming interface API and a graphics processing unit GPU driver . The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images.

The graphics processing subsystem includes the GPU an on chip GPU memory an on chip GPU data bus a GPU local memory and a GPU data bus . The GPU is configured to communicate with the on chip GPU memory via the on chip GPU data bus and with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions in order to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes a graphics pipeline that is configured to render a two dimensional view in screen space. The graphics pipeline includes world space and screen space . In one embodiment the world space includes four shading stages a vertex shader a hull shader a domain shader and a geometry shader. In each of the world space stages is a programmable shader stage. In other embodiments at least one of the world space stages is a fixed function stage. A fixed function stage or fixed function unit has circuitry configured to perform a dedicated function. A programmable processing stage or unit includes the necessary processors and memory to perform dedicated functions of a pipeline stage. In one embodiment the processors can be specifically configured for processing highly parallel code. In other embodiments general processing units with scalar cores can be implemented as programmable stages. The shader stages of the world space stages can be conventional components of a graphics pipeline.

The screen space includes a tile shader and a pixel shader. Thus in contrast to conventional graphics pipeline the graphics pipeline includes a tile shader in addition to a pixel shader. Instead of processing individual pixels the tile shader operates on tiles of pixels. More detail of a screen space portion of a graphics pipeline is illustrated and discussed with respect to and .

One skilled in the art will understand that the graphic pipeline can include additional components that are typically included in a graphics pipeline. For example the screen space can include a raster stage a Ztest stage and a composition stage. The GPU may be provided with any amount of on chip GPU memory and GPU local memory including none and may use on chip GPU memory GPU local memory and system memory in any combination for memory operations.

The on chip GPU memory is configured to include GPU programming code and on chip buffers . The GPU programming may be transmitted from the GPU driver to the on chip GPU memory via the system data bus .

The GPU local memory typically includes less expensive off chip dynamic random access memory DRAM and is also used to store data and programming used by the GPU . As shown the GPU local memory includes a frame buffer . The frame buffer stores data for at least one two dimensional surface that may be used to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is used to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

Having described a computing system within which the disclosed tile shader and methods may be embodied or carried out particular embodiments of graphics pipelines will be described in and .

The raster stage converts vector information composed of shapes or primitives into a raster image composed of pixels to provide a two dimensional view for a display. The raster stage typically generates covered pixels for further processing by the screen view. A covered pixel is a pixel that is covered by an object and needs coloring.

The Z test stage receives the covered pixels from the raster stage and performs a depth test to determine which pixels will actually be viewed in the two dimensional space. As such the Z test stage generates Z accepted pixels for further processing.

The tile shader receives the Z accepted pixels from the Z test stage and performs screen space processing on the pixels at a tile level. As such the tile shader advantageously processes multiple pixels together instead of operating on individual pixels. In one embodiment the screen space processing includes coverage computations redefining output positions multi layer rendering and variable resolution rendering. Additionally in some embodiments the tile shader is configured to determine a subset of the received pixels for further processing by the pixel shader . In one embodiment the pixel subset is of non killed pixels. After operating on the pixels at a tile level the tile shader launches the pixels to the pixel shader .

The pixel shader receives the pixels from the tile shader . As illustrated in the received pixels can be non killed pixels. As such the pixel shader can efficiently operate on all of the received pixels. The pixel shader determines the color for the received pixels and launches the colorized pixels to the composite stage .

The composite stage receives the colorized pixels from the pixel shader and composites the pixels to form a view that can be displayed via for example the display devices of . In one embodiment the raster stage the Z test stage the pixel shader and the composite stage are conventional stages typically found in a graphics pipeline. In some embodiments each of the stages of the screen space section is a programmable stage.

Each of the similarly named stages of the screen space section operates as described above with respect to the screen space section . The difference is due to the order of the pipelines and therefore the pixels that are received.

The input interface is configured to receive pixels for processing. As indicated from and the pixels can be covered pixels or Z accepted pixels depending on the placement of the tile shader in the graphics pipeline. In one embodiment the pixels are already formed into tiles when received. The interface can be a conventional interface employed in programmable function units to communicate with other stages of a graphics pipeline and receive processing inputs to employ when processing the pixels.

The processing inputs noted in are Mask Position RtArrayIdx and Attributes. Mask indicates the coverage mask for the fine raster transaction. Position indicates the position of the fine raster transaction. RtArrayIdx represents the render target array index. Attributes are the attributes of the primitives in a Fine Raster FRSTR transaction wherein a Fine Raster transaction consists of 8 8 pixels from the same primitive. The Mask Position RtArrayIdx can be accessed by the tile shader from the Pixel Load PIXLD which is an instruction specified in the DirectX API and Attributes can be accessed from the Interpolate Attribute IPA which is also an instruction specified in the DirectX API.

The output interface is configured to launch pixels for further processing by subsequent stages of a graphics pipeline. In multiple embodiments the subsequent stage is a pixel shader. The output interface can be a conventional interface employed in programmable function units to communicate with other stages of a graphics pipeline and provide processing outputs for other pipeline stages. The processing outputs can be placed in output registers as illustrated in . In four output registers of the output interface are specifically denoted and .

Similar to the processing inputs the processing outputs are Mask Position RtArrayIdx and level of detail LOD . Mask Position and RtArrayIdx are as noted above with respect to the processing inputs. A zero 0 value for Mask is defined to kill the fine raster transaction. LOD is used to indicate the level of detail for variable resolution rendering.

The tile processor is configured to perform screen space processing of the pixels at a tile level. In one embodiment the tile processor is configured to determine a subset of pixels received for further processing along the graphics pipeline. In some embodiments the tile processor can be a custom processor that has been configured for parallel processing such as a serial multiprocessor. In other embodiments the tile processor can be a scalar core.

In one embodiment the tile processor runs from 1 to N threads per fine raster transactions wherein each warp thereof can process multiple fine raster transactions. The tile processor can use texture instructions with LOD computations. In some embodiments the LOD computations are implicit if at least four threads are running per tile. Otherwise LODs have to be specified implicitly. The tile processor can be configured to add appropriate LOD bias to account for non unit screen distance between threads being processed.

The tile processor is configured to evaluate IPAs at the tile position for all threads. In one embodiment the tile processor is configured to appropriate per thread offsets. In one embodiment the tile shader when altering the output of a tile is configured to ensure that all writes to an output location are from the same input location i.e. 1 n relationship between input positions and output positions to guarantee that raster operator accesses to that tile occur in API order.

Following are examples how the tile shader can be employed to improve the operation of a graphics pipeline. Other advantages not disclosed herein can also be obtained from the tile level processing of the tile shader in the screen space.

A first use example relates to Foliage Stochastic Rasterization and Double Sided Z. Regimes that currently kill a lot of pixels early in the pixel shader such as foliage rendering and stochastic rasterization currently suffer from low warp utilization and out of order completion in the pixel shader. In addition the pixel shader may also be executed for Z killed pixels because depth test cannot often be done before the pixel shader.

If the coverage computations are performed in the tile shader instead a depth test can be performed before the pixel shader and the pixel shader is only executed for surviving pixels. This improves warp utilization and leads to more uniform execution times hence reducing out of order completion. and illustrate on the labeled arrows how the tile shader can be used to remove killed pixel from the pipeline before the pixel shader.

A second use example relates to Sparse Render Targets. The ability to change the output position can be used to render into a sparsely allocated render target. In one embodiment the tile shader is configured to use a software defined map to locate a memory for the virtual tile coordinates. Unlike the virtual memory based hardware scheme this allows mapping to easily be changed on the fly since system level access to redefine the mapping function is not required.

A third use example relates to Multi Layer Rendering. Beyond sparse rendering which maps each screen tile to 0 or 1 tiles in memory the tile shader can also be used to map the same screen coordinates to multiple different memory tiles. This allows the tile shader to render multiple layers at the same location to support high quality anti aliasing and order independent transparency.

Another use example is Variable Resolution Rendering. As a further extension to the sparse rendering the tile shader can be used to render different tiles at different resolutions based on the content or position on the screen.

In a step pixels are generated for the screen space. In one embodiment a raster operator generates the pixels from the world space data. As shown in in one embodiment the generated pixels are covered pixels.

In a step the pixels are formed into tiles. In one embodiment an external processor to the tile shader forms the tiles and then delivers the tiles of pixels to the tile shader for processing.

The pixels are received by a tile shader of the graphics pipeline in a step . In one embodiment the tile shader receives the pixels from the raster operator without an intervening processing stage of the graphics pipeline. In another embodiment the tile shader receives the pixels from a Z test stage after the raster stage.

The tiles of pixels are then screen space processed in a step by the tile shader. In one embodiment the tile shader determines a subset of the pixels for further processing along the graphics pipeline. In one embodiment the subset is non killed pixels. In other embodiments the screen space processing includes coverage computations for the pixels redefining output positions for the pixels multi layer rendering for the pixels and variable resolution rendering for the pixels.

In a step the pixels from the processed tiles are launched along the pipeline for the subsequent stage for further processing. In one embodiment the pixels that are launched are the subset of pixels. The received pixels are then processed by the subsequent stage in a step . In one embodiment the subsequent stage is a pixel shader of the graphics pipeline. In other embodiments the subsequent stage is another stage of the graphics pipeline e.g. a composite stage. The method then ends in a step .

While the method disclosed herein has been described and shown with reference to particular steps performed in a particular order it will be understood that these steps may be combined subdivided or reordered to form an equivalent method without departing from the teachings of the present disclosure. Accordingly unless specifically indicated herein the order or the grouping of the steps is not a limitation of the present disclosure.

The above described apparatuses and methods or at least a portion thereof may be embodied in or performed by various such as conventional digital data processors or computers wherein the computers are programmed or store executable programs of sequences of software instructions to perform one or more of the steps of the methods. The software instructions of such programs may represent algorithms and be encoded in machine executable form on non transitory digital data storage media e.g. magnetic or optical disks random access memory RAM magnetic hard disks flash memories and or read only memory ROM to enable various types of digital data processors or computers to perform one multiple or all of the steps of one or more of the above described methods e.g. one or more of the steps of the method or functions of the apparatuses described herein e.g. a tile shader. A programmable shader stage such as the tile shader can be implemented on a special purpose processor that is well suited for highly parallel code.

Certain embodiments of the invention further relate to computer storage products with a non transitory computer readable medium that have program code thereon for performing various computer implemented operations that embody the apparatuses the systems or carry out the steps of the methods set forth herein. Non transitory used herein refers to all computer readable media except for transitory propagating signals. Examples of non transitory computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROM disks magneto optical media such as floptical disks and hardware devices that are specially configured to store and execute program code such as ROM and RAM devices. Examples of program code include both machine code such as produced by a compiler and files containing higher level code that may be executed by the computer using an interpreter.

Those skilled in the art to which this application relates will appreciate that other and further additions deletions substitutions and modifications may be made to the described embodiments.

