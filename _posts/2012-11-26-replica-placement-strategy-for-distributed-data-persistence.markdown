---

title: Replica placement strategy for distributed data persistence
abstract: Methods and systems are described that involve replica placement strategy for distributed systems. At the time of index creation, initial index replica placement is decided. The first index replica is placed locally on the current processing server node. This server node operates as a master host for the first replica. The other index replicas are placed on different hosts depending on the index type, split index or non-split index, and a set of criteria. For non-split indexes, the set of criteria includes: a number of recently created replicas per host, resource usage per host, and a total number of replicas per host. For split indexes, the set of criteria includes: a number of replicas of any split index part per host and a number of local first replicas of split index parts. If all criteria re equal, the first host in alphanumeric ordering receives a next replica.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08862540&OS=08862540&RS=08862540
owner: SAP SE
number: 08862540
owner_city: Walldorf
owner_country: DE
publication_date: 20121126
---
This application is a continuation application of U.S. patent application Ser. No. 12 623 669 filed Nov. 23 2009 which is incorporated herein by reference.

Embodiments of the invention generally relate to the software arts and more specifically to methods and systems for storing index replicas in a distributed system.

Systems for online analytical processing OLAP need to handle growing volumes of critical data and in the same time to meet challenging user requirements for fast response time and flexible support for complex or ad hoc queries on application data. Typically the OLAP systems hold and process data in the main memory which enables fast queries to be executed over large volumes of structured data. The data can be compressed in the main memory to eliminate the runtime cost of disk access and the structures may be optimized for sequential read. Further the data may be indexed and stored in a persistence layer of the OLAP system. The persistence layer may provide storage of application data on local hard disks in a system network. However storing data on local hard disks in a network requires implementing high availability and failover techniques such as replication of the data so that the data is not lost.

Replication ensures consistency between redundant resources such as software or hardware components improves reliability fault tolerance or accessibility. The replication may be data replication if the same data is stored on multiple storage devices. The replication process should be transparent to an external user. Also in a failover scenario failover of replicas should be hidden as much as possible. When data is replicated the processes of handling incoming requests reply to read requests and apply updates. By ensuring that the replicas see the same events in equivalent orders they stay in consistent states and thus any replica can respond to queries. Besides consistency of replicas the server nodes in a distributed system should be evenly loaded with replicas so that optimal application performance and network traffic is achieved.

Methods and systems are described that involve replica placement strategies for distributed data persistence. In an embodiment the method includes detecting creation of a split index including a plurality of split index parts. A first replica of a part of the split index is stored on a local host in a plurality of hosts wherein the first replica is a local replica and the local host is a master host for the local replica of the split index part. A total number of replicas of any part of the split index that are stored on a first slave host is determined. If the total number of replicas stored on the first slave host is equal to the total number of replicas stored on a second slave host then a total number of local replicas stored on the first slave host and on the second slave host is determined. If the total number of local replicas stored on the first slave host is equal to the total number of local replicas stored on the second slave host then a second replica of the part of the split index is stored on the first slave host in alphanumeric order.

In an embodiment the system includes a distributed system with a plurality of server nodes wherein a server node from the plurality is designated as a master host for an index and rest of server nodes in the plurality are designated as slave hosts for the index. The system also includes a master unit that identifies most suitable hosts to place a set of replicas of the index storing a first index replica locally to the master host and a next index replica on a slave host according to a set of parameters. If the parameters are equal for the slave hosts the next index replica is stored on a first slave host in an alphanumeric order. Further the system includes a data server module in communication with the master unit that stores index structure data and performs data replication and garbage collection.

Embodiments of techniques for replica placement strategy for distributed data persistence are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiment.

When designing a replication strategy the following aspects should be taken into consideration what to replicate and where to put the replicas. The replication unit should be chosen according to the application s needs to achieve optimal performance of the system. To ensure efficient data placement in a distributed storage for an OLAP engine not only commonly used criteria such as disk utilization but also data semantics e.g. how data is linked together has to be considered.

Most OLAP engines handle data sets that are semantically bound together therefore data should be replicated at the level of a minimum logical unit of operations. The minimum logical unit of operation may be bigger than a common file system block or group of blocks. In an embodiment the minimum logical unit of operations is an index that is organized hierarchically in namespaces and may contain 1 content files transactional data 2 temporary files uncompressed data 3 attribute files data stored in columns 4 configuration files etc. Typically many midsize files 30 50 MB containing millions of documents are created and written at once. The only small files 2 5 KB are configuration files. Once written files may not be modified frequently. In an embodiment there are two types of modification indexing data is loaded into an index and optimization the index is compressed . During indexing the data is stored in temporary files. During optimization the data from the temporary files is read in parallel and written in attribute files.

Index processing depends on index size small indexes may be processed sequentially by one host and large indexes may be split horizontally since an index may represent a table of data e.g. a fact table and processed in parallel by all hosts in a system landscape. Indexes are semantic units and can be kept together wherever this is advantageous for their processing. Hence only the large indexes are split because the speedup benefit outweighs the logical complication caused by breaking up a semantic unit. Each portion of the attribute data may be handled by a different server but with even distribution of the data the servers may perform input output operations at the same time. Parallel processing consisting of large sequential read and write operations may lead to shortage of the storage resources. To process queries in memory the OLAP engines load the entire index into the main memory of the processing sever node. In addition parts of a large index table of column indexes can be loaded separately as required to reduce memory consumption. Query execution can proceed when only the relevant parts of the index are loaded in the memory. Thus all files of an index should be stored at one location even when distributed storage is used. Typically the main data structure of an OLAP system is the OLAP cube which contains numeric facts called measures that are categorized by dimensions. The cube metadata may be created from a star schema of tables in a relational database. The star schema is the simplest style of a data warehouse schema that consists of a few fact tables usually only one referencing a number of dimension tables. A data cube can be designed by selecting which measures and dimensions to be defined for each record in the cube. In an embodiment indexes such as business warehouse indexes are based on the star scheme. These indexes represent structures that each contains a logical index and several table indexes. When a business warehouse index is split the logical index and the smaller table indexes may advantageously remain unsplit only the fact table index and the largest dimension table index may be split.

In a distributed persistence two types of indexes may be distinguished 1 a split index a large index that is split into a plurality of parts and 2 a non split index any other index. In an embodiment a split index may be a fact table that contains most of the data in a cube index. The distribution of the split indexes may reflect the performance of the OLAP engine since the split parts are indexed in parallel. Split indexes are evenly distributed over a cluster of several server nodes by means of horizontal partitioning. All replicas of the parts of each split index have to be distributed evenly among all hosts to achieve needed system performance.

Data server stores and handles index structure data such as index directories rectory hierarchy and file data. Data server also performs background activity such as replication and garbage collection. If an index replica is stored locally on the host client reads the data of the index from the local file system via an application programming interface API . Application sends queries via a persistence layer API to the client to perform certain business logic that requires data from the stored index. Similarly server node N includes elements master unit N client N application N local file system N and data server N. The elements of server node N serve for managing any index replicas for which server node N is a master host and any index replicas for which server node N is a slave host.

During index creation or recovery the active master unit identities the most suitable hosts to place the replicas of the index. Replicas are placed on hosts with the lowest disk space utilization and with the lowest estimated workload. The estimation is based on including but not limited to the total number of indexes on a host the number of recently created replicas and the role of the host master or slave . n an embodiment the first replica primary replica is stored locally on the master host this ensures fast access to the index data and minimizes network traffic. The number of replicas may be defined according to the system s resources and needs for example the number of replicas can be equal to the number of server nodes in the system. Initial replica placement is performed at the time of index creation.

There is a set of criteria for managing the initial placement of replicas depending on the index type split or non split index . The first criterion for placement of all index replicas is locality to minimize the network traffic. In a distributed environment it is common to distinguish between active and passive server nodes i.e. master and slaves. A master index server handles all requests to an index replica for which it is responsible. For example server node is a master server for index replica . Therefore the master index server must always have a local replica. If there is no local replica the master host has to perform read write operations on a replica placed on a remote host which decrease the performance and increases the network traffic. The placement of the other replicas of the index apart from the first replica is determined based on a set of parameters e.g. total number of replicas for a host . In an embodiment the set of parameters is predetermined and stored in an object the parameters are collected compared and sorted for every host. Thus statistical information for all hosts may be available according to the set of parameters when applying a replica placement strategy.

For a non split index the set of parameters may include 1 a number of recently created replicas correlates to the volume of data which will be loaded in the fill process following the index creation 2 hard disk utilization needed for equalization of the disk space usage over the server nodes and 3 a total number of replicas corresponds to the potential number of input output requests to a host. These parameters serve as criteria for determining the host for storing the next replica so that best application performance is achieved. During replica placement the parameters are checked in a certain priority the number of recently created replicas parameter has the highest priority while the total number of replicas parameter has the lowest priority. A parameter with lower priority is checked only if the result of checking a parameter with higher priority does not affect the replica placement decision. For example hard disk utilization is checked if the number of recently created replicas is equal for all slave hosts and thus no replica placement decision can be taken.

At step the number of recently created non split index replicas of all slave hosts is checked. At decision step the lowest number has to be determined. If all numbers of recently created non split index replicas of all slave hosts are equal then the process continues at step . Otherwise the process continues at step . At step the resource usage e.g. disk usage parameter of all slave hosts is checked. At decision step the lowest number has to be determined. If all resource usage parameters have equal numbers then the process continues at step . Otherwise the process continues at step . At step the total number of replicas of the non split index for every host is checked. At decision step the lowest number has to be determined. If all total numbers of all slave hosts are equal then the process continues at step . Otherwise the process continues at step . At step the second non split index replica is stored on the host with the lowest number for a given parameter. For example if at step it is determined that number of recently created non split index replicas is not equal for all slave hosts then the process continues at step where the second replica is placed on the host with the lowest number of recently created non split index replicas. At step the second replica is stored on the first next host in the alphanumeric ordering. It should be noted that only the first replica is placed on the master host and steps are executed for every other replica of the non split index.

At step the first replica of each part of the split index is stored on host which is assigned as master for this particular part. Thus each first replica for a given part is local for the corresponding master host. Each host in the distributed system is assigned as master host for sonic parts of the split index and is a slave host for all other replicas of parts of the split index that are or will be stored on it.

Similarly to the non split index at the time of selecting the most appropriate hosts for the replicas the stored predetermined parameters are checked and considered. For a split index the set of parameters may include a number of replicas of any parts of the split index that have already been placed on a given host an approximately equal number of replicas of split index parts should be placed on each host. If some hosts have more replicas of the split index parts than others their local disk drives will need to write larger amounts of data which may lead to longer overall indexing time. Also the disk of a host with fewer replicas will not be fully utilized. The set of parameters includes also a number of replicas of parts of the split index local to a particular master host the next replica should be placed on the host with the most local replicas because in horizontal partitioning the split parts of the index are distributed evenly and the host with the least number of assigned parts will become the next master. By not placing the replica on this host when number of all replicas of split index parts is equal among all hosts overloading of the host is avoided because it will get a local first replica of the next split part.

At step the number of replicas of any parts of a split index placed on a given host is checked. The number is checked for all slave hosts in the system. At decision step the lowest number has to be determined. If the number of replicas of any parts of a split index is equal for all slave hosts then the process continues at step . Otherwise the process continues at step .

At step the second replica of the split index part is stored on the host with the lowest number. The second replica is placed and process ends. At step the number of replicas of the split index parts that are local to the master on a given host is checked. The number is checked for all slave hosts in the system. At decision step the highest number has to be determined i.e. the host that has the most local replicas. If the number of local replicas of any parts of a split index is equal for all slave hosts then the process continues at step . Otherwise the process continues at block step . At block step the second replica of the split index part is stored on the host with the highest number. At step the second replica is stored on the first next host in the alphanumeric ordering. Similarly steps are executed for every other replica of the split index part.

An index is considered as consistent if the application always sees the same data regardless from which replicas it reads. Index data consistency can be achieved by synchronous modification of all replicas. If an operation on a replica fails the replica is marked as corrupted and the application reads another replica Corrupted replicas are not operated on or replicated Replica recovery may be initiated as soon as the number of available replicas falls below a defined replica level. Then a new replica host may be chosen according to process and process . During index replication all write requests to that index are blocked until the replication is complete In an embodiment replica migration can be initiated asynchronously to ensure that data is stored on the hosts where it is needed. To ensure local access an additional data copy may be created on the target host. The active master unit later deletes the surplus replica on a slave host. The slave host for deleting the replica from is chosen by applying same criteria as for the initial placement but considering the least appropriate host for a replica e.g. most recent creations highest resource utilization etc. A garbage collection mechanism for recognizing and deleting obsolete replicas may be implemented. Every data server sends a list of local indexes both at startup and regularly thereafter to the active master unit if the replica is not listed on the master unit the data server deletes it.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first arid second computer systems cart be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable medium as instructions. The term computer readable medium should be taken to include a single medium or multiple media storing one or more sets of instructions. The term computer readable medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

A semantic layer is an abstraction overlying one or more data sources. It removes the need for a user to master the various subtleties of existing query languages when writing queries. The provided abstraction includes metadata description of the data sources. The metadata can include terms meaningful for a user in place of the logical or physical descriptions used by the data source. For example common business terms in place of table and column names. These terms can be localized and or domain specific. The layer may include logic associated with the underlying data allowing it to automatically formulate queries for execution against the underlying data sources. The logic includes connection to structure for and aspects of the data sources. Some semantic layers can be published so that it can be shared by many clients and users. Some semantic layers implement security at a granularity corresponding to the underlying data sources structure or at the semantic layer. The specific forms of semantic layers includes data model objects that describe the underlying data source and define dimensions attributes and measures with the underlying data. The objects can represent relationships between dimension members provides calculations associated with the underlying data.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

