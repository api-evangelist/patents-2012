---

title: Engine agnostic interface for communication between game engines and simulation systems
abstract: A software architecture is provided that has an agnostic interface mechanism coupled between a simulator and a game engine. The agnostic interface mechanism has an extension interface to translate simulator specific data objects to/from interface objects, a reflector interface to translate interface data objects to/from game specific objects, a launcher interface to translate interface control objects for controlling the game engine into game specific control objects, and a core control coupled between the extension interface and the reflector and launcher interfaces for controlling the communication of objects between the simulator and the game engine. The core control through the reflector and launcher interfaces provides game specific objects to the game engine through direct application programming interface (API) calls.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08475282&OS=08475282&RS=08475282
owner: 
number: 08475282
owner_city: 
owner_country: 
publication_date: 20120108
---
The present invention relates generally to simulation systems and more particularly to an engine agnostic interface for connecting game engines and training simulation systems.

The Department of Defense DoD has been examining the role of game technology for use with future training systems. Government funded research programs have sponsored the development of commercial software that attempts to bridge simulation protocols and the commercial game market. GameLink developed by MaK Technologies creates a network bridge between Epic Unreal Engine game content and HLA or DIS simulations. University of Pittsburgh researchers have developed a system which uses multi agent technology to interconnect otherwise incompatible systems Unreal Tournament Semi Automated Force . Overall the goal to bridge game and simulation technology has been disparate and no API specifications standards or software implementations have yet emerged.

Interoperability between simulators is an ongoing and complex problem that most distributed systems must deal with. Certain military protocols have tried to address this problem most notably at the network level with such protocols as the Distributed Interactive Simulation DIS High Level Architecture HLA or Test and Training Enabling Architecture TENA . Unfortunately a lack of stringent implementation specifications even with higher level features such as FOM definition and implementation is only applicable from one developer to another. Additionally the absence of any standardization has made it difficult to support complex feature sets such as models with many levels of matrix transformations. Furthermore simulation systems require high network performance to operate with complex data types within a distributed simulation environment. Unfortunately very complicated data such as skeletal articulations tend to create noticeable latency within a large federated system.

Applicant s U.S. App. Pub. No. US 2002 0082086 A1 Mission Control defines a system where the controlling application communicates with the game engine via a network client and server architecture. The game engine is required to create a network client in order to communicate with the controlling applications network server i.e. mission control . This mechanism only allows direct calls to be made to the network interface which limits data structure usage speed and has extremely complex maintenance. Moreover Mission Control utilizes a network protocol defined to communicate control of the game engine. Mission Control assumes that the game engine will connect via Mission Control s network protocol after the game engine s process is started. Mission Control has no method to interact with data of either the game engine or the simulator in sharp contrast to the present invention. The present invention has a defined interface for the control and data interaction of the game engine as well as an interface for the data interaction of the simulator. These interfaces of the present invention allow not only control the game engine but also act as a vehicle for data between game engines and simulators. Since Mission Control only has a control mechanism over a network protocol Mission Control cannot convey any data from a game engine to a simulator.

Although game technology is starting to gain credence as a valid training tool in the modeling and simulation industry a generic architecture designed to easily integrate current and future capable systems is yet to be developed. The present invention seeks to solve these problems by providing a mechanism that does not communicate with the game engine through a network protocol and thus allows for a much more flexible maintainable and fast method of data extraction and injection.

The following terms are utilized throughout the specification in accordance with the accompanying definitions.

Entity Controller Maintains all registered entity types and Sister Entity types. Creates Sister Entities and Entity Modules as well as updating those references in the Entity Modules.

Entity Controller Module Primary access for Extensions to interact with entity data. Maintains changes from Extensions and commits those changes to the EAI Core. One Entity Module is needed per Extension.

Interaction Controller Maintains all registered Interaction types and Sister Interaction types. Creates Sister Interactions and executes those interactions on all relevant Interaction Modules.

Entity A standard C object defined by the EAI Core to contain standard information that represents objects in the game engine from munitions to humans and vehicles. Entities can be interacted with by any system interfacing with an Entity Controller Module.

Sister Entity A standard C object defined by the game engine or Extension to translate information between EAI Core Entities.

Interaction A standard C object defined by the EAI Core to represent any event triggered in the system from either game engines or Extensions. Interactions can be executed and received from any system interfacing with an Interaction Controller Module.

Sister Interaction A standard C object defined by the game engine or Extension to execute or receive EAI Core Interactions.

Controlling Application Any application that uses the EAI Core on the API level or instantiates the EAI Core DLL.

Extension Any applications integrated with the Extension Controller Entity Controller Module and Interaction Controller Module that listen inject or modify Entities or Interactions within the EAI Core.

Launcher An interface that is implemented within the game engine to allow the Engine Controller to launch and maintain an instance of that game engine.

Reflector An interface that is implemented within the game engine to allow the Entity Controller and Interaction Controller to interact with the game engines Sister Entities and Interactions.

In today s environment system incompatibility issues often create complex maintenance problems. This coupled with the difficulty to interoperate with new and emerging standards usually causes the integrator to either work with outdated software code or ultimately to build new systems entirely from scratch with no reusability of previous development. The present invention redefines ways of creating and sustaining complex system of systems architectures used in most advanced simulation systems.

Many simulation companies fail to keep up with evolving technology and consequently have trouble sustaining new standards and protocols. The present invention provides architecture designed with future capabilities in mind without having any implementation knowledge. Additionally the architecture is backward compatible to support earlier design decisions and completely interoperable with other similarly based systems.

Almost all simulations systems use custom hardware solutions such as input output devices network and communication systems multi modal feedback devices and rendering displays audio visual . The present invention supports any number of devices using a layer of abstraction between the particular hardware system and the software. Additionally new devices are able to send receive or present data in a standardized way.

Interoperability between simulators is an ongoing and complex problem that most distributed systems must deal with. Certain military protocols have tried to address this problem most notably at the network level with such protocols as the Distributed Interactive Simulation DIS High Level Architecture HLA or Test and Training Enabling Architecture TENA . Unfortunately a lack of stringent implementation specifications even with higher level features such as FOM definition and implementation is only applicable from one developer to another. Additionally the absence of any standardization has made it difficult to support complex feature sets such as models with many levels of matrix transformations. Furthermore simulation systems require high network performance to operate with complex data types within a distributed simulation environment. Unfortunately very complicated data such as skeletal articulations tend to create noticeable latency within a large federated system. The present invention provides an architecture that manages low latency transmittal of complex data types within the network which is vital for supporting advanced modeling in a simulated environment.

One aspect of the present invention is to provide a collection of interfaces whose purpose is to mediate data and events between controlling applications and video game engines. Its overall design has several goals in mind 

In another aspect of the present invention a flexible and rapid representation of any training scenario is provided by use of a multi layered architecture consisting of abstract extensible interfaces. This design provides a platform independent reconfigurable model where any component can be removed augmented or replaced with no detriment to the system. Additionally any Module can provide real time feedback into the system so other Modules may easily adapt to the new state of the simulation architecture.

The aspects of the present invention are carried out in one embodiment by a system and corresponding method for communicating between a simulator and a game engine having an agnostic interface mechanism coupled between the simulator and the game engine. The elements of the system may be a computer program product comprising a computer usable medium having control logic stored therein.

The agnostic interface mechanism has an extension interface configured to receive a simulator specific object from the simulator via a specific protocol of the simulator and to translate the simulator specific object into a interface object a reflector interface configured to translate the interface object into a game specific object and to transmit the game specific object to the game engine and a core control made up of controllers and controller modules coupled between the extension interface and the reflector interface for controlling the communication of objects between the simulator and the game engine. The core control through the reflector interface provides the first game specific object to the game engine through a direct application programming interface API call.

The reflector interface is also configured to translate a game specific object generated by the game engine into an interface object and the extension interface is also configured to translate the second interface object into a simulator specific object in accordance with the simulator specific protocol and to provide the simulator specific object to the simulator.

The corresponding objects being originated by and being communicated between the simulator and the game engine are data objects. In addition control objects are generated by the core control for maintaining multiple instances of the game engine. The controls include creating starting stopping and destroying game engines. The control objects are translated from interface objects into game specific objects and transmitted to the game engine by a launcher interface.

Other objects and advantages which are set forth in the description of the Detailed Description. The features and advantages described in the specification however are not all inclusive and particularly many additional features and advantages will be apparent to one of ordinary skill in the art in view of the drawings and specification herein.

The engine agnostic interface EAI of the preferred embodiment is a software architecture utilizing an abstract engine application programming interface API that exposes only necessary components of EAI . EAI interfaces between Simulator such as military training simulator and Game Engine .

As depicted in the components of EAI are EAI Core which is comprised of Controllers and Modules Extensions Launchers and Reflectors . Controllers include Engine Controller A Entity Controller B Interaction Controller C and Extension Controller D. Modules include Entity Module A and Interaction Module B. There is one of each type of Module per each Extension . Through these components EAI has enough flexibility to generate a generic modular system that can interoperate with other EAI implementations. Although each controlling application needs its own set of Extensions the final implementation is available for any other EAI based system.

EAI further includes several data types Entities and Interactions along with their sisters as explained below with respect to . A data type is an object that represents a specific construct of information.

As shown in Game Engine is coupled to EAI Core via Engine Launcher and Reflectors . This connection represents the EAI s translation from the EAI Core domain into Game Engine domain. The data which is used in this translation is a combination of EAI Core Entities and Interactions with game engine Sister Entities and Sister Interactions . EAI Core is coupled to EAI Extensions via EAI Core Entities and Interactions that are available within the EAI domain. EAI Extensions which could represent many different Extensions based on their purpose is coupled with a Simulator via network and or environment data in the form of the network and or environment protocols needed to communicate with a specific Simulator . Whether the utilized protocols are network protocols A environment protocols B or both depends on which Extensions are active. Network protocol A is simply any protocol for network packets such as TCP IP or UDP. Environmental protocol B is based on Extension and the specific data needed by Simulator .

As shown in the components of EAI Core are depicted in detail. Game engine is coupled to Engine Controller A via Engine Launcher . This is the primary integration into Game Engine to provide control of instancing and destroying Game Engine which also represents the boundaries of EAI Core and that the Engine Launcher is implemented within Game Engine . This is the primary entry point into Game Engine which provides functions to create and destroy instances of Game Engine . This entry point also represents the boundaries of EAI Core and Engine Launcher which is implemented within Game Engine .

Game Engine is also coupled to Entity Controller B and Interaction Controller C through Entity Reflector A and Interaction Reflector B respectively. This connection is where EAI Core Entities and Interactions are translated into Game Engine Sister Entities and Sister Interactions . This connection also represents the boundaries of EAI Core and Entity Reflector A and Interaction Reflector B which are implemented within Game Engine . Entity Controller B and Interaction Controller C are coupled with their respective Modules Entity Module A and Interaction Module B. For each Extension that is maintained by EAI Core an Entity Module A and Interaction Module B must be created. This connection represents the flow of EAI Core Entities and Interactions . Entity Module A and Interaction Module B are coupled with Extension A A and Extension B B. This represents the access to EAI Core Entities and Interactions which enables Extensions to interact with available Entities and Interactions . Extension Controller D is also coupled with Extension A A and Extension B B. This connection represents the management of Extensions to the extent of starting and stopping Extensions .

The fundamental building blocks of EAI Controllers Modules and Extensions provide a framework for bridging the barrier between Game Engine and simulator . The overall design provides a platform independent reconfiguration model where any component can be removed augmented or replaced with no detriment to the system. EAI provides unique ways of supporting several concurrent systems and at multiple levels of integration. The benefits of a configurable training mission rehearsal mission planning and battlefield visualization systems are numerous. The layered architecture approach reduces development time and creates a bridging system between various technologies contained within the infrastructure. Additionally the Extension library and API give the developer added control over building new Extensions . The result is a comprehensive training system that can ultimately support an indefinite number of hardware and software components within the simulation.

EAI Core is the primary interface for creating internal components and connecting external components. EAI Core is responsible for executing high level commands within EAI from a controlling application. These commands range from creating Extensions to starting and stopping Game Engines . EAI Core acts a hub for all Controllers that interoperate with it and for Extensions that need to be connected to Modules .

EAI Core does not communicate with Game Engine through a network protocol rather it uses direct DLL entry points for communication since Game Engine is instantiated within the same process. The communication of EAI Core through DLL entry points allows Entities and Interactions to be passed back and forth through EAI Core and Game Engine . This mechanism allows for a much more flexible maintainable and fast method of data extraction and injection.

The domain of EAI lies between Simulators and Game Engines . Extensions provide the data that is needed by Simulators in order to facilitate interoperability with EAI integrated systems. Engine Launchers and Reflectors provide the bridge into Game Engine for communication of the basic types of data Entities and Interactions as shown in .

When integrated with EAI Core Game Engine operates nominally except that it communicates all Entities and Interactions created in Game Engine or EAI Core . These are in turn translated through Extensions managed by EAI Core to Simulator .

For example if the ONESAF military training simulator system is utilized as Simulator the ONESAF simulator would generate an object in its world and that would be sent via a specific protocol to an Extension developed specifically for ONESAF communication. The ONESAF Extension would in turn translate this data into EAI Core Entities and Interactions . Once that data is translated Engine Controller A then notifies Game Engine in this case the Unreal Engine so that it can properly represent that information. From the opposite side of the data flow the Unreal Engine could create an object that would then be translated into an EAI Core Entity or Interaction via Reflectors . This Entity or Interaction would then be sent to all Extensions through Controller Modules . After this update reaches the ONESAF Extension the ONESAF Extension then translates that data into the required Protocol for the ONESAF simulator.

Controller effects some change within EAI by translating information that is available within the simulation. For example Controller could be an initialization parameter of a display engine or any entity operating within that engine. Controllers are also the data source for Controller Modules as explained in more detail below.

The purpose of Engine Controller A is to create compliance and interoperability within the EAI system. Engine Controller A supports multiple engine implementations and has the capacity with additional EAIs to instantiate multiple engine instances during the running of the simulation. The basic level Engine Controller command starts and stops Game Engine as well as connects Entities and Interactions within Game Engine . Engine Controllers A are closely tied to Entity Controller B and Interaction Controller C where they expose the engine data generically to any Modules that need to use it as a data source.

Launchers execute functions invoked by Engine Controller A. This includes starting stopping engines and communicating references to Reflectors and Controllers. Launchers are the update function within any constructive or video game engine connected to EAI .

Launcher is an interface provided by EAI Core but not implemented. Each Game Engine will implement a specific Launcher to provide a DLL entry point into the engine instance. This means that the controlling application that runs EAI Core will also have the engine instance within the same process. This is the key mechanism that allows object data in the form of Entities and Interactions to flow freely from Extensions to Game Engine and back.

Reflectors have two main functions relaying generic entity interaction data to Controllers from Game Engines and relaying engine specific entity interaction data to Game Engines from Controllers . These functions provide the data that is represented within EAI Controllers .

Once Reflectors are implemented by Game Engine and connected through Launcher Entities and Interactions can be sent into EAI Core . Reflectors are different from Controller Modules that Extensions interface with due to the mentality that Game Engine is the authority on the objects in EAI Core .

Entity Controller B is the base controller class for Entities in the simulation. Entity Controller B communicates directly with Engine Controller A through a Reflector component and Reflector creates an intermediate format used by EAI . Any change that happens within Game Engine is recorded by Entity Controller B and conversely any change to Entity Controller B is propagated to Game Engine .

Extensions and Game Engines access entity data through Entity Controller B. Since all data needs to eventually become basic EAI entity types Sister Entities are created. This design pattern allows each Extension and Game Engine to define an object in their native environment while still maintaining a connection to the basic EAI Entity . Sister Entities identify which Entities are targeted for operations within Extensions and Game Engines . If there are no Sister Entities defined for a basic EAI Entity then those will be ignored for that respective Extension or Game Engine .

The relationship between EAI Core and Sister Entities are shown in . EAI Core has registered types of Entities and Interactions represented by the EaiEntity class and EaiInteraction class . Game Engines and Extensions define their Sister Entities and Sister Interactions represented by ExtensionASisterEntity A ExtensionASisterInteraction A ExtensionBSisterEntity B ExtensionBSisterInteraction B EngineSisterEntity and EngineSisterInteraction . When EAI Core is initialized all relevant Sister Entities and Sister Interactions are connected to their corresponding EAI Core Entities and Interactions . The Sister connection for Game Engine is made through Entity Controller B and Interaction Controller C respectively and is stored within EAI Core Entities and Interactions . The Sister connection for Extensions is made through Entity Controller Module A and Interaction Controller Module B respectively. shows that if an EaiEntity is created EAI Core will create an ExtensionASisterEntity A ExtensionBSisterEntity B and an EngineSisterEntity . Also if an EaiInteraction is created EAI Core will create an ExtensionASisterInteraction A ExtensionBSisterInteraction B and an EngineSisterInteraction .

Similar to the HLA model any event that occurs in Simulator is defined as an Interaction . Any Interaction occurring within Game Engine is recorded by Interaction Controller C and any Interaction sent to Interaction Controller C is executed within Game Engine .

With the same concept as Entity Controller B Interaction Controller C also requires Sister Interactions to be defined in each Extension or Game Engine that needs their information.

Extension Controller D manages any Extensions which have been loaded into EAI Core . Its role is to make sure that each Extension is maintained and has access to all Controllers within EAI Core .

Modules are objects that provide information needed by external Extensions and act as a data protection layer for Controllers . Modules also prioritize the execution of Extension operations. Modules are essential to EAI Core Entity Controller B and Interaction Controller C. Game Engine is considered to be the authority in EAI Core so Game Engine does not use a Module to send and receive data. Extensions are required to use Modules because of concurrent modification of Entities or potentially identical Interactions . Modules protect the data by identifying changes in identical Entities and propagating their delta combination.

Extensions are external objects that respond to generic information that are produced by EAI . Each Extension communicates with and manipulates data through its exposed Controller Modules . Extensions are simple and only communicate with Controller Modules . In contrast Launchers and Reflectors are exclusive to game engine integration. Extensions also have access to generic data which simplifies hardware and software integration. This generic data powers the capabilities to integrate new hardware and software interfaces while maintaining overall system compatibility. There are many different types of Extensions . Exemplary Extensions include a Generic Input Extension a Session Recorder Player Extension and a Statistical Processor Extension.

The Generic Input Extension addresses the problem of generic hardware input device compatibility. This Extension creates a standard interface for directing input and output from various devices. The EAI Generic Hardware Extension operates on the same concepts as DirectInput by abstracting hardware device inputs such as joysticks and other devices. However the Generic Input Extension goes further by abstracting more complex inputs such as orientation and rotation data X Y Z or Yaw Pitch Roll from spatial or inertial tracking systems. Furthermore skeletal structure orientation and movement data is also abstracted by the Generic Input Extension for use with more complex systems like a motion capture system or haptic devices such as gloves or vests.

The Session Recorder Player Extension collects entity and interaction data within EAI and also has the ability to replay that data as it was observed. This allows an intermediate recording format usable by any Game Engine to interface with EAI . EAI should be able to play back any session from any EAI implementation.

Similar to the Session Recorder Player Extension the Statistical Processor Extension saves raw statistical data to a remote database real time. Its purpose is to provide real time information to remote systems and rely on the external systems to translate the raw data.

This extension is designed to create a standard protocol for translating HLA DIS traffic into an internal EAI format. The Network Hub Extension s power is its ability to manage the sending and receiving of network traffic in a federation HLA DIS using an advanced priority scheme sending only important or relevant information to a federate that subscribes to that information. It is possible for example that a federate might subscribe to a particular type of data but not receive it in a brute force manner the way HLA normally sends network updates.

Developers can create EAI Extensions that access generic data in the EAI system. Extensions can be created from the Extension interfaces provided by EAI Core . With these interfaces developers can gain access to Entity Controller Module A and Interaction Controller Module B allowing them to communicate with all Entity and Interaction activity within EAI Core . This allows developers to integrate custom hardware or to support a new Protocol .

For application developers low level routines written to establish basic communication with EAI are not necessary.

The primary mechanisms for EAI integration are Entities and Interactions . These are the primary currency of Extensions and Game Engine connected to EAI Core . Combined with the design pattern of Sister objects see Entity and Interaction Controller EAI integration provides a more widely usable infrastructure to expose and inject game engine data.

Preferably the entirety of EAI Core and Extensions are built in C . This is preferred because almost all game engine cores are built around the same standards as C . The main challenge for integration with Game Engines revolves around the restriction of the interfaces of EAI . Preferably all entry points into EAI must not utilize STL Standard Template Library data structures. This preference is due to the various implementations and differences of Microsoft s CRT Common Runtime . For example EAI is compatible with Game Engines built with Visual Studio 2003 to Visual Studio 2008 because the interfaces of EAI Core Launchers and Reflectors use basic standard data structures to communicate with Game Engine .

Another large challenge of integrating EAI into Game Engines lies within the design choice to maintain all systems within the same logical process. This means that the Controlling Application i.e. ControlApp.exe would create an EAI Core . After the instantiation of EAI Core Engine Controller A would then create and instance of Game Engine . This would all show up on the system resources as a single process. i.e. still ControlApp.exe . This design allows for faster direct integration with Game Engine as opposed to more lengthy or complex interfaces such as memory sharing or network clients and servers. With Controlling Application EAI Core and Game Engine all in the same process this poses some unique problems.

First since Game Engine is the largest variable of any EAI integration the working directory has to be set to that of Game Engine . This in turn changes what and where Controlling Application and EAI Core load and search for components such as DLLs. Controlling Application EAI Core and Game Engine need to be modified to make sure that they are aware of their modified working directory.

Second DLL module management is needed in order to maintain the instances of EAI Core and Game Engine components. EAI Core is designed to be able to create and destroy a Game Engine all within the same process. Most Game Engines are not designed to be created and destroyed from within the same process. Due to this Engine Controller A needs to maintain the DLLs loaded by Game Engine and either unload them when Game Engine is destroyed or keep them alive for another instance of Game Engine .

Third since most Game Engines are not designed to be created and destroyed within the same process there is a need to modify some aspects of Game Engine to accommodate this. These accommodations include operating system handles i.e. window handles and rendering contexts global variables that might interfere with two instances of Game Engine running in the same memory space and any mutex which would be checking for a duplicate instance of specific DLLs.

The implementation depicted in illustrates that EAI Core can use an Extension to communicate over the network to a specific Simulator . More Extensions and Simulators can be added to the configuration. EAI Core itself does not communicate through any network channels all communications of EAI Core are direct API calls to and from Game Engine and Controlling Application .

From the above description it will be apparent that the invention disclosed herein provides a novel and advantageous engine agnostic interface. The foregoing discussion discloses and describes merely exemplary methods and embodiments of the present invention. One skilled in the art will readily recognize from such discussion that various changes modifications and variations may be made therein without departing from the spirit and scope of the invention.

