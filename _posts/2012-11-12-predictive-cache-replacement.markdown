---

title: Predictive cache replacement
abstract: Systems and methods for predictive cache replacement policies are provided. In particular, some embodiments dynamically capture and predict access patterns of data to determine which data should be evicted from the cache. A novel tree data structure can be dynamically built that allows for immediate use in the identification of developing patterns and the eviction determination. In some cases, the data can be dynamically organized into histograms, strings, and other representations allowing traditional analysis techniques to be applied. Data organized into histogram-like structures can also be converted into strings allowing for well-known string pattern recognition analysis. The pattern recognition and prediction techniques disclosed also have applications outside of caching.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323695&OS=09323695&RS=09323695
owner: FACEBOOK, INC.
number: 09323695
owner_city: Menlo Park
owner_country: US
publication_date: 20121112
---
Various embodiments of the present invention generally relate to caching policies. More specifically various embodiments of the present invention relate to systems and methods for predictive cache replacement polices.

Caching is a mechanism that accelerates access i.e. reduces latency to data on slower storage media by managing a subset of the data in a smaller faster and typically more expensive storage medium. As a result the average latency of the data access will be between the latency of the slower and faster storage. Caches come in many shapes and forms. For example caches can be embodied in hardware such as CPU caches and or software such as Memcached . In some cases caches can also be layered across several storage layers or tiers.

Typically data access is not uniformly random. Instead data access often has spatial and or temporal locality properties. Spatial locality refers to accessing data within a relatively close or similar location to other data that has previously been accessed. Temporal locality refers to the reuse of data that has previously been accessed within a relatively close time period. These locality properties give a measure of predictability to the data that will be accessed allowing only those data elements predicted to be recalled soon to be stored in the smaller cache.

The ratio of all data accesses that can be served by the cache is called the hit ratio and is one of the main metrics of success of a cache. Hit ratios can have a significant impact on performance and as a result have high economic implications. While there have been many efforts to come up with better ways to determine which items to store in the cache and which to evict to make room for more likely items the traditional caching policies have been typically based on coarse locality metrics e.g. oldest items are always evicted . Consequently data which is more likely to be accessed may be evicted. As such there are a number of challenges and inefficiencies found in traditional caching policies.

Systems and methods are described for predictive cache replacement policies. In some embodiments a method includes counting data access observations that fall into disjoint categories. The disjoint categories may be multi dimensional in some cases e.g. time of day and region . A prediction model can be dynamically built to predict future access patterns based on the data access observations. Using this prediction model a determination can be made as to which data should be evicted from a cache. In some embodiments building the prediction model includes dynamically building a tree data structure representing the data access observations. The tree data structure can include a plurality of nodes that are added at each time interval and include a cumulative distinct key count. The nodes added at the current time interval can include a current key count. When the current key count is zero a data access pattern associated with a key associated with the current key count of zero can be recorded.

In some embodiments the data access observations can be represented with a string pattern by assigning a distinct letter to each data access that corresponds to one of the disjoint categories. Then the string pattern can be analyzed using a compression algorithm. The string may preserve temporal relations of the data observations.

Some embodiments provide for a computer implemented method that includes generating a histogram of recorded data access observations that fall into disjoint categories representing time intervals e.g. uniform or non uniform intervals since insertion of data into a cache. A set of access patterns can be generated that can be used to predict a probability of accesses on future data stored in the cache. In some embodiments the set of access patterns are captured based on the disjoint categories and the histogram of recorded data access observations. By identifying the probability of access on the future data as being lower than any other data based on the set of access patterns a determination can be made as to which data should be evicted from the cache.

In some embodiments each element in a data set e.g. data representing access patterns of data within a cache can be mapped into one of a plurality of disjoint bins or categories. A string representing the data set can then be dynamically mapped by assigning one or more letters to each of the plurality of disjoint bins or categories. As a result each element in a data set is represented with the letter assigned to the disjoint bin or category each element was mapped into. A pattern matching analysis can then be performed based on the string. The pattern matching analysis can include a Markov Chain model and or partial pattern matching by using a pattern s prefix to predict a suffix.

Embodiments of the present invention also include computer readable storage media containing sets of instructions to cause one or more processors to perform the methods variations of the methods and other operations described herein.

Various embodiments of the present invention can include a system having a processor memory database cache observation engine prediction module eviction module histogram generator pattern generator string converter and or other modules or components. In some embodiments the cache can have data stored thereon. The observation engine can be configured to record data access observations regarding how the data is accessed within the cache. The prediction module can dynamically build a statistically aggregated prediction model to predict future access patterns based on the data access observations over time. The eviction module can be configured to evict data from the cache which has the lowest probability of future access as predicted by the statistically aggregated prediction model.

In some embodiments the histogram generator can be configured to generate a histogram based on the data access observations. The pattern generator can be configured to build a set of access patterns by creating a tree data structure that is updated over time by adding a new set of nodes having a current key count representing a number of data access observations recorded during a current time interval. Each node in the new set of nodes branch e.g. representing disjoint categories from previous nodes associated with the previous time interval having a cumulative key count. The string converter can be used to map the data access patterns to a string of characters. In some cases the string of characters preserves temporal relations of the data access patterns.

While multiple embodiments are disclosed still other embodiments of the present invention will become apparent to those skilled in the art from the following detailed description which shows and describes illustrative embodiments of the invention. As will be realized the invention is capable of modifications in various aspects all without departing from the scope of the present invention. Accordingly the drawings and detailed description are to be regarded as illustrative in nature and not restrictive.

The drawings have not necessarily been drawn to scale. For example the dimensions of some of the elements in the figures may be expanded or reduced to help improve the understanding of the embodiments of the present invention. Similarly some components and or operations may be separated into different blocks or combined into a single block for the purposes of discussion of some of the embodiments of the present invention. Moreover while the invention is amenable to various modifications and alternative forms specific embodiments have been shown by way of example in the drawings and are described in detail below. The intention however is not to limit the invention to the particular embodiments described. On the contrary the invention is intended to cover all modifications equivalents and alternatives falling within the scope of the invention as defined by the appended claims.

Various embodiments of the present invention relate to cache replacement policies. In particular some embodiments dynamically capture and predict access patterns of data to determine which data should be evicted from the cache. Cache replacement policies deal with the problem of selecting at the time of eviction which item in a cache is least likely to be required in the near future. Traditional cache replacement policies have been typically based on coarse locality metrics e.g. oldest items or least recently used items are evicted . As a result these traditional caching policies can result in poor eviction decisions being made.

In contrast the eviction techniques disclosed herein are not based on coarse locality metrics such as recency of use. Instead these techniques provide for predictive cache replacement policies based on fine grained metrics. For example some embodiments dynamically build a statistically aggregated model of access patterns in time and at the time of eviction try to predict future accesses based on the pattern each item appears to belong to. As a result various embodiments of the techniques disclosed can be advantageously applied to all temporal access patterns whether fast decaying or slow as long as data items can be meaningfully grouped by distinguishable temporal patterns. Certain implementations of these techniques can provide one or more of the following advantages 1 can be faster than queue based methods 2 can potentially use less memory 3 can scale better with the number of threads on multi core and multi chip machines and 4 can increase hit rates for certain workloads.

In some embodiments a novel tree data structure can be dynamically built that allows for immediate use in the identification of developing patterns and the eviction determination. In some cases the data can be dynamically organized into histograms strings and other representations allowing traditional analysis techniques to be applied. Data organized into histogram like structures can also be converted into strings allowing for well known string pattern recognition analysis.

While for convenience embodiments of the present invention are described with reference to cache replacement polices embodiments of the present invention are equally applicable to various other applications where patterns are used for making decisions. For example embodiments of the pattern recognition and prediction techniques disclosed have applications throughout all levels of caching and outside of caching in such fields as communications and machine learning. Moreover these techniques are equally applicable in a wide range of systems that exhibit well defined temporal patterns from end user devices to large network storage systems e.g. those used within a social networking system . Other examples include key value stores e.g. Memcached search engine query caches web page caches both in servers and clients disk block cache in operating systems page cache and translation lookaside buffer TLB in computer processors and countless more cache implementations virtually anywhere where temporal locality plays a role and enough memory is available to maintain the dynamic histogram data structures described below.

In addition the techniques introduced here can be embodied as special purpose hardware e.g. circuitry as programmable circuitry appropriately programmed with software and or firmware or as a combination of special purpose and programmable circuitry. Hence embodiments may include a machine readable medium having stored thereon instructions which may be used to program a computer or other electronic devices to perform a process. The machine readable medium may include but is not limited to floppy diskettes optical disks compact disc read only memories CD ROMs magneto optical disks read only memories ROMs random access memories RAMs erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs magnetic or optical cards flash memory or other type of media machine readable medium suitable for storing electronic instructions.

Brief definitions of terms abbreviations and phrases used throughout this application are given below.

The terms connected or coupled and related terms are used in an operational sense and are not necessarily limited to a direct physical connection or coupling. Thus for example two devices may be coupled directly or via one or more intermediary channels or devices. As another example devices may be coupled in such a way that information can be passed there between while not sharing any physical connection with one another. Based on the disclosure provided herein one of ordinary skill in the art will appreciate a variety of ways in which connection or coupling exists in accordance with the aforementioned definition.

The phrases in some embodiments according to various embodiments in the embodiments shown in other embodiments and the like generally mean the particular feature structure or characteristic following the phrase is included in at least one embodiment of the present invention and may be included in more than one embodiment of the present invention. In addition such phrases do not necessarily refer to the same embodiments or to different embodiments.

If the specification states a component or feature may can could or might be included or have a characteristic that particular component or feature is not required to be included or have the characteristic.

The term module refers broadly to software hardware or firmware or any combination thereof components. Modules are typically functional components that can generate useful data or other output using specified input s . A module may or may not be self contained. An application program also called an application may include one or more modules or a module can include one or more application programs.

The data can be submitted through various user devices mobile devices personal computers laptops and or other devices to allow the data to be stored on one or more databases and . As illustrated in these devices may use network to submit and retrieve information from the databases and . Various embodiments of the present use storage system to manage the data storage on databases and .

User device can be any computing device capable of receiving user input as well as transmitting and or receiving data via the network . In one embodiment user device is a conventional computer system such as a desktop or laptop computer . In another embodiment user device may be mobile device having computer functionality such as a personal digital assistant PDA mobile telephone smart phone or similar device.

User device is configured to communicate with storage system via the network . In one embodiment user device executes an application allowing a user of user device to interact with the storage system . For example user device can execute a browser application to enable interaction between the user device and storage system via the network . In another embodiment user device interacts with storage system through an application programming interface API that runs on the native operating system of the user device such as IOS or ANDROID .

User devices can be configured to communicate via the network which may comprise any combination of local area and or wide area networks using both wired and wireless communication systems. In one embodiment network uses standard communications technologies and or protocols. Thus network may include links using technologies such as Ethernet 802.11 worldwide interoperability for microwave access WiMAX 3G 4G CDMA digital subscriber line DSL etc. Similarly the networking protocols used on network may include multiprotocol label switching MPLS transmission control protocol Internet protocol TCP IP User Datagram Protocol UDP hypertext transport protocol HTTP simple mail transfer protocol SMTP and file transfer protocol FTP . Data exchanged over network may be represented using technologies and or formats including hypertext markup language HTML or extensible markup language XML . In addition all or some links can be encrypted using conventional encryption technologies such as secure sockets layer SSL transport layer security TLS and Internet Protocol security IPsec .

Memory can be any device mechanism or populated data structure used for storing information. In accordance with some embodiments of the present invention memory can encompass any type of but is not limited to volatile memory nonvolatile memory and dynamic memory. For example memory can be random access memory memory storage devices optical memory devices magnetic media floppy disks magnetic tapes hard drives SIMMs SDRAM DIMMs RDRAM DDR RAM SODIMMs erasable programmable read only memories EPROMs electrically erasable programmable read only memories EEPROMs compact disks DVDs and or the like. In accordance with some embodiments memory may include one or more disk drives flash drives one or more databases one or more tables one or more files local cache memories processor cache memories relational databases flat databases and or the like. In addition those of ordinary skill in the art will appreciate many additional devices and techniques for storing information which can be used as memory .

Memory may be used to store instructions for running one or more applications or modules on processor s . For example memory could be used in one or more embodiments to house all or some of the instructions needed to execute the functionality of observation engine prediction module eviction module histogram generator pattern generator string converter and graphical user interface GUI module .

Observation engine can be configured to record data access observations regarding how the data is accessed within the cache. In some embodiments observation engine counts data access observations that fall into disjoint categories. The disjoint categories may be multi dimensional in some cases. For example the multi dimensional categories could include time of day and region. Other examples of disjoint categories include but are not limited to daytime in North America daytime in Europe and daytime in Asia. In some embodiments the categories could be uniformly distributed disjoint time intervals or a set of disjoint non uniform time intervals. In accordance with various embodiments observation engine may record data access observations that fall into multiple sets of disjoint categories.

Prediction module can be configured to receive the data access observations from observation engine and build a prediction model. For example the prediction model may generate a statistical analysis of the data access observations. Using this information the prediction model can estimate the probability that each data item in the cache will be accessed in the future. In some embodiments the prediction model can generate a probability for each data item that indicates the likelihood the data item will be accessed within the next time unit at any time during the future during a specified time frame more than a specified number of times in the future and or other access predictions. In some embodiments one or more of these predictions can be weighted e.g. based on other factors such as importance of the data or the cost to retrieve it again i.e. miss penalty and or combined with other access predictions to generate an overall access score for each data item.

In many cases the prediction model does not need to be accurate or descriptive at all. For example for the purpose of determining which items should be evicted from the cache the prediction model only has to effectively compare two or more eviction candidates which is more likely to be required soon. As a result the prediction model does not necessarily accurately predict how likely future access will happen. The prediction model can compute a relative value not an absolute one in some embodiments. In some cases a relative value may be computed faster. For example the model may compute which of the two elements has a longer expected access history in time a wider expected history more discrete events or more expected events in the immediate time window to follow. The prediction model can also take into account miss penalty or other weight factors.

Eviction module can receive the access scores from prediction module and determine which data to evict from the cache. For example in one embodiment eviction module may evict a data item which has the lowest probability of future access as predicted by the prediction model. Eviction module may also have access to other information e.g. service level objectives and current system metrics which can be combined with the access scores and or access predictions in order to determine which data can be evicted.

Histogram generator can be used to generate a histogram based on the data access observations. In some embodiments access patterns are dynamically captured by collecting histograms of data accesses. The histograms can have user defined bins on the x axis that define units of time and user defined categories of accesses. The y axis on the histogram does not have to be continuous or even discrete it can represent ranges e.g. from 10 to 20 accesses . As a result different keys of different but sufficiently similar access patterns can be captured with the same histogram.

The histograms generated by histogram generator can then be used in various embodiments by prediction module to predict future data access patterns. For example suppose a key is currently on its fourth hour since insertion into the cache and the associated pattern matches the one in the first part of a histogram. Prediction module can then predict the probability or relativity of future accesses based on the associated pattern. In some embodiments eviction module can use this prediction by comparing the results to the prediction associated with a different key on a different histogram and or a different time location on the same histogram.

Pattern generator can be configured to build a set of access patterns by creating a tree data structure that is updated over time by adding a new set of nodes. The newly added nodes include a current key count for the last time interval and representing a number of data access observations recorded during a current time interval though the branches. The other tree nodes represent a cumulative distinct key count from the past time intervals. In some embodiments the depth in the tree can represent a time range or interval possibly logarithmic The breadth can represent an access count range possibly logarithmic .

String converter can be used to map the data access patterns to a string of characters. In some embodiments the data access patterns are mapped to a set of bins or categories that are assigned one or more letters. The letters associated with each bin or category can be concatenated to form the string e.g. as data access patterns are mapped to the bins or categories . This is illustrated in more detail below in .

In some embodiments the string of characters preserves temporal and or categorical relations of the data access patterns. String converter can be used to convert previously recorded patterns and or patterns that are still developing into strings. A pattern matching analysis or compression analysis can be used to match the strings. For example the pattern matching analysis can include a partial pattern matching by using a pattern s prefix to predict a suffix.

GUI module can be used to generate one or more graphical user interface screens. These screens can be used to display information e.g. histograms data access patterns and or strings to users. In some embodiments the graphical user interface screens can be used by the users to define or select the disjoint categories used by the other components e.g. observation engine .

Using the recorded access patterns modeling operation can dynamically build a statistically aggregated model of data access patterns. This can include building a histogram in some embodiments. Histograms however are just one way to model and predict recurring patterns. Other embodiments of the present invention use techniques from information theory and practical applications such as data compression. For example modeling operation can use dictionary based methods e.g. Lempel Ziv variants that build an efficient dictionary of pattern prefixes which can be represented compactly. Partial Pattern Matching PPM which uses a pattern s prefix to guess its suffix can be used in some embodiments. Still yet modeling operation can build some models that include Markov Chains.

In accordance with various embodiments modeling operation can be run off line on historical data and access patterns. By running modeling operation off line on historical data and access patterns a baseline model can be developed. Then by running modeling operation on a regular schedule in real time or nearly in real time the statistically aggregated model can be dynamically updated. As a result the statistically aggregated model generated in modeling operation can evolve over time as the access patterns change.

Prediction operation predicts future access patterns of current data within a cache based on the current version of the model. For example prediction operation can return a score or probability of future access over one or more time periods e.g. one hour two hours and anytime in the future . Using this information eviction operation determines which data is least likely to be accessed and should be evicted from the cache.

In some embodiments some data may be exempted from being evicted from the cache. For example in at least one embodiment data that has been inserted into the cache less than a preselected amount of time may be exempt from evictions. Some advantages of this technique include the reduction of processing churn ensuring each data item gets a fair chance at reuse and the reduction of memory use. For example eviction operation may not evict elements in the first hour since their insertion. As a result the system does not need to store any access pattern for that hour in the histogram which would likely require more processing and storage than future accesses in a typical decaying temporal access pattern. Note that the initial time window in which evictions are exempted cannot be overly long as this will not allow enough candidates for eviction.

The number of bins length of x axis generated by building operation can be capped. In some embodiments the last bin may represent accesses from a given point in time to infinity. Bounding the depth of the histogram allows the run time of operations on the histogram to be bounded. The number of possible branches per bin width of each bin can be capped to represent that X or more accesses at this time window occurred for some items. Conversion operation can convert the histogram into a tree data structure e.g. as described below in . Prediction operation can use the tree data structure to collect data patterns and to match collected data patterns to the current access patterns represented by the tree structure.

However suppose that these same data access patterns were previously identified from other data sets. Then the data access patterns could be used to predict future accesses based on the patterns previously identified. As a result Key 1 could be evicted at hour two since the data access patterns would indicate that that data would be the least likely to be accessed again in the near future.

Each tree node represents a cumulative distinct key count from the past. The breadth in the tree represents a time range and the depth represents an access count range. From the root node the first set of new nodes were added representing the key counts during the second hour t . In particular there were no keys with eight or more counts and for key counts zero to one two to three and four to seven there was one key count for each key. As such the first three nodes under tinitially had a current key count of one.

During the third hour illustrated in the first and second key had one key count and the third key had zero key counts. As a result when the nodes were added under t the only branches i.e. ranges of key counts that had a current key count were zero to one branches for Key 1 and Key 2. There were no current key counts for Key 3. As a result the first and second nodes under twere updated from a one to a two and the third and fourth nodes under twere left unchanged. From each of these nodes there was only a key count of one for the first and second key. In some embodiments the tree can be used to predict future accesses. For example assume that the data pattern developing is the same pattern as one detected before as determined by monitoring the counters at the end of tor t clearly preferring Key 1.

During the fourth hour illustrated in only Key 1 had any counts. In fact it only had one count. As a result the cumulative key count of the root node was updated. In addition the first node under tand twere updated to three and two while there were no key count updates to the other nodes. This can continue until a zero is reached in all newly added nodes. Since this may not happen for a while if at all the total amount of memory used by the histogram can be capped to avoid memory overruns. When the available memory is exhausted the system may stop updating the histogram altogether. The counts can still be updated but new bins may not be added.

In other embodiments the current histogram can be discarded before starting the process again with some cost for prediction accuracy for a while. Other embodiments may utilize some garbage collection mechanism to free up bins that have low usage count. While some embodiments update the cumulative key count with an increment of one for each count in some cases the cumulative key counts can be weighted. For example in some embodiments a factor weighted by the breadth i.e. the number of discrete accesses in the time window can be included.

In accordance with various embodiments the usage count is likely to be capped by an implementation dependent integer representation size for example if the count uses a 32 bit integer it can record no more than 2events without overflowing. The leftmost element in the histogram the root is the one likely to reach this cap first. At this point various embodiments can freeze all further updates to the histogram start fresh with an empty histogram and or employ some mechanism to lower counts in a way that preserves relative count weights among the bins. If the histogram data structure is to be accessed concurrently from many threads as is common in implementations such as Memcached accuracy in reads is not critical and writes can be protected without locks with hardware supported atomic variables such as exist on the x86 architecture.

To help illustrate mapping operation suppose that Key 2 from was received for analysis during receiving operation . Now suppose a set of bins were created or assigned such that the first bin represented one key count the second bin represented two key counts the third bin represent three key counts the fourth bin represent four to five key counts and the fifth bin represented six or more key counts. Now suppose that the letter A was assigned to the first bin the letter B was assigned to the second bin the letter C was assigned to the third bin the letter D was assigned to the fourth bin and the letter E was assigned to the fifth bin.

Then at hour 1 mapping operation would map the six key counts recorded in the first hour to the letter E . At hour 2 mapping operation would map the two key counts recorded at the second hour to the letter B and append B onto the string generated at hour 1 giving the string EB . At hour three mapping operation would map the one key count recorded at the third hour to the letter A and append A onto the string generated at hour two giving the string EBA. At hour four no key counts were recorded during the fourth hour so mapping operation ends.

In a similar fashion the strings can be generated for the other keys illustrated in . The following table illustrates the string generated at each time interval i.e. each hour for the case of the keys in with the bins as described above.

As mentioned above embodiments of the present invention can be utilized within a social networking system. Typically a social networking system includes one or more computing devices storing user profiles associated with users and or other objects as well as connections between users and other users and or objects. In use users join the social networking system and then add connections to other users or objects of the social networking system to which they desire to be connected. The users may be individuals or entities such as businesses organizations universities or manufacturers. The social networking system allows its users to interact with each other as well as with other objects maintained by the social networking system. In some embodiments the social networking system allows users to interact with third party websites and financial account providers.

Based on stored data about users objects and connections between users and or objects the social networking system can generate and maintain a social graph comprising a plurality of nodes interconnected by a plurality of edges. Each node in the social graph represents an object or user that can act on another node and or that can be acted on by another node. An edge between two nodes in the social graph represents a particular kind of connection between the two nodes which may result from an action that was performed by one of the nodes on the other node. For example when a user identifies an additional user as a friend an edge in the social graph is generated connecting a node representing the first user and an additional node representing the additional user. The generated edge has a connection type indicating that the users are friends. As various nodes interact with each other the social networking system can modify edges connecting the various nodes to reflect the interactions.

API request server allows other systems user devices or tools to access information from social networking system by calling APIs. The information provided by the social network may include user profile information or the connection information of users as determined by their individual privacy settings. For example a system user device or tools interested in accessing data connections within a social networking system may send an API request to social networking system via a network. The API request is received at social networking system by API request server . API request server processes the request by submitting the access request to storage system where access is determined and any data is communicated back to the requesting system user device or tools via a network.

Web server links social networking system via a network to one or more client devices the web server serves web pages as well as other web related content such as Java Flash XML and so forth. The web server may communicate with the message server that provides the functionality of receiving and routing messages between social networking system and client devices. The messages processed by message server can be instant messages queued messages e.g. email text and SMS short message service messages or any other suitable messaging technique. In some embodiments a message sent by a user to another can be viewed by other users of social networking system for example by the connections of the user receiving the message. An example of a type of message that can be viewed by other users of the social networking system besides the recipient of the message is a wall post. In some embodiments a user can send a private message to another user that can only be retrieved by the other user.

Each user of the social networking system is associated with a user profile which is stored in user profile store . A user profile includes declarative information about the user that was explicitly shared by the user and may also include profile information inferred by social networking system . In one embodiment a user profile includes multiple data fields each data field describing one or more attributes of the corresponding user of social networking system . The user profile information stored in user profile store describes the users of social networking system including biographic demographic and other types of descriptive information such as work experience educational history gender hobbies or preferences location and the like. A user profile may also store other information provided by the user for example images or videos. In certain embodiments images of users may be tagged with identification information of users of social networking system displayed in an image. A user profile in user profile store may also maintain references to actions by the corresponding user performed on content items in content store and stored in the edge store .

A user profile may be associated with one or more financial accounts allowing the user profile to include data retrieved from or derived from a financial account. A user may specify one or more privacy settings which are stored in the user profile that limit information from a financial account that social networking system is permitted to access. For example a privacy setting limits social networking system to accessing the transaction history of the financial account and not the current account balance. As another example a privacy setting limits social networking system to a subset of the transaction history of the financial account allowing social networking system to access transactions within a specified time range transactions involving less than a threshold transaction amount transactions associated with specified vendor identifiers transactions associated with vendor identifiers other than specified vendor identifiers or any suitable criteria limiting information from a financial account identified by a user that is accessible by social networking system . In one embodiment information from the financial account is stored in user profile store . In other embodiments it may be stored in financial account store .

Action logger receives communications about user actions on and or off social networking system populating action log with information about user actions. Such actions may include for example adding a connection to another user sending a message to another user uploading an image reading a message from another user viewing content associated with another user attending an event posted by another user among others. In some embodiments action logger receives subject to one or more privacy settings transaction information from a financial account associated with a user and identifies user actions from the transaction information. For example action logger retrieves vendor identifiers from the financial account s transaction history and identifies an object such as a page in social networking system associated with the vendor identifier. This allows action logger to identify a user s purchases of products or services that are associated with a page or another object in content store . In addition a number of actions described in connection with other objects are directed at particular users so these actions are associated with those users as well. These actions are stored in action log .

Action log may be used by social networking system to track user actions on social networking system as well as external websites that communicate information to social networking system . Users may interact with various objects on social networking system including commenting on posts sharing links and checking in to physical locations via a mobile device accessing content items in a sequence or other interactions Information describing these actions is stored in action log . Additional examples of interactions with objects on social networking system included in action log include commenting on a photo album communications between users becoming a fan of a musician adding an event to a calendar joining a group becoming a fan of a brand page creating an event authorizing an application using an application and engaging in a transaction. Additionally action log records a user s interactions with advertisements on social networking system as well as other applications operating on social networking system . In some embodiments data from action log is used to infer interests or preferences of the user augmenting the interests included in the user profile and allowing a more complete understanding of user preferences.

Action log may also store user actions taken on external websites and or determined from a financial account associated with the user. For example an e commerce website that primarily sells sporting equipment at bargain prices may recognize a user of social networking system through social plug ins that enable the e commerce website to identify the user of social networking system . Because users of social networking system are uniquely identifiable e commerce websites such as this sporting equipment retailer may use the information about these users as they visit their websites. Action log records data about these users including webpage viewing histories advertisements that were engaged purchases made and other patterns from shopping and buying. Actions identified by action logger from the transaction history of a financial account associated with the user allow action log to record further information about additional types of user actions.

In some embodiments social networking system further stores data describing one or more connections between different users in the connection store . The data describing one or more connections can include a list of connections a date each connection i.e. friendship was made etc. The connections may be further defined by users allowing users to specify their relationships with other users. For example the connections allow users to generate relationships with other users that parallel the users real life relationships such as friends co workers partners and so forth. In one embodiment the connection specifies a connection type based on the type of relationship. Examples of the type of relationship include family friend colleague etc. Users may select from predefined types of connections or define their own connection types as needed. Some or all of this information may also be stored as edge objects in edge store .

Content store stores content items associated with a user profile such as images videos or audio files. Content items from content store may be displayed when a user profile is viewed or when other content associated with the user profile is viewed. For example displayed content items may show images or video associated with a user profile or show text describing a user s status. Additionally other content items may facilitate user engagement by encouraging a user to expand his connections to other users to invite new users to the system or to increase interaction with the social network system by displaying content related to users objects activities or functionalities of social networking system . Examples of social networking content items include suggested connections or suggestions to perform other actions media provided to or maintained by social networking system e.g. pictures or videos status messages or links posted by users to the social networking system events groups pages e.g. representing an organization or commercial entity and any other content provided by or accessible via the social networking system.

Content store also includes one or more pages associated with entities having user profiles in user profile store . An entity is a non individual user of social networking system such as a business a vendor an organization or a university. A page includes content associated with an entity and instructions for presenting the content to a social networking system user. For example a page identifies content associated with the entity s user profile as well as information describing how to present the content to users viewing the brand page. Vendors may be associated with pages in content store allowing social networking system users to more easily interact with the vendor via social networking system . A vendor identifier is associated with a vendor s page allowing social networking system to identify the vendor and or to retrieve additional information about the vendor from user profile store action log or from any other suitable source using the vendor identifier. In some embodiments the content store may also store one or more targeting criteria associated with stored objects and identifying one or more characteristics of a user to which the object is eligible to be presented.

In one embodiment edge store stores the information describing connections between users and other objects on social networking system in edge objects. Some edges may be defined by users allowing users to specify their relationships with other users. For example users may generate edges with other users that parallel the users real life relationships such as friends co workers partners and so forth. Other edges are generated when users interact with objects in social networking system such as expressing interest in a page on the social networking system sharing a link with other users of the social networking system and commenting on posts made by other users of the social networking system. Edge store stores edge objects that include information about the edge such as affinity scores for objects interests and other users. Affinity scores may be computed by social networking system over time to approximate a user s affinity for an object interest and other users in social networking system based on the actions performed by the user. Multiple interactions between a user and a specific object may be stored in one edge object in edge store in one embodiment. In some embodiments connections between users may be stored in user profile store or user profile store may access edge store to determine connections between users.

Embodiments of the present invention include various steps and operations which have been described above. A variety of these steps and operations may be performed by hardware components or may be embodied in machine executable instructions which may be used to cause a general purpose or special purpose processor programmed with the instructions to perform the steps. Alternatively the steps may be performed by a combination of hardware software and or firmware. As such is an example of a computer system with which embodiments of the present invention may be utilized. According to the present example the computer system includes a bus at least one processor at least one communication port a main memory a removable storage media a read only memory and a mass storage .

Processor s can be any known processor such as but not limited to an Intel Itanium or Itanium 2 processor s AMD Opteron or Athlon MP processor s or Motorola lines of processors. Communication port s can be any of an RS 232 port for use with a modem based dialup connection a 10 100 Ethernet port or a Gigabit port using copper or fiber. Communication port s may be chosen depending on a network such as a Local Area Network LAN Wide Area Network WAN or any network to which the computer system connects.

Main memory can be Random Access Memory RAM or any other dynamic storage device s commonly known in the art. Read only memory can be any static storage device s such as Programmable Read Only Memory PROM chips for storing static information such as instructions for processor .

Mass storage can be used to store information and instructions. For example hard disks such as the Adaptec family of SCSI drives an optical disc an array of disks such as RAID such as the Adaptec family of RAID drives or any other mass storage devices may be used.

Bus communicatively couples processor s with the other memory storage and communication blocks. Bus can be a PCI PCI X or SCSI based system bus depending on the storage devices used.

Removable storage media can be any kind of external hard drives floppy drives IOMEGA Zip Drives Compact Disc Read Only Memory CD ROM Compact Disc Re Writable CD RW and or Digital Video Disk Read Only Memory DVD ROM .

The components described above are meant to exemplify some types of possibilities. In no way should the aforementioned examples limit the scope of the invention as they are only exemplary embodiments.

In conclusion the present invention provides novel systems methods and arrangements for predictive cache replacement policies. While detailed descriptions of one or more embodiments of the invention have been given above various alternatives modifications and equivalents will be apparent to those skilled in the art without varying from the spirit of the invention. For example while the embodiments described above refer to particular features the scope of this invention also includes embodiments having different combinations of features and embodiments that do not include all of the described features. Accordingly the scope of the present invention is intended to embrace all such alternatives modifications and variations that fall within the scope of the claims together with all equivalents thereof. Therefore the above description should not be taken as limiting the scope of the invention which is defined by the appended claims.

