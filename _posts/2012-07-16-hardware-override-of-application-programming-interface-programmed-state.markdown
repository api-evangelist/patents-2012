---

title: Hardware override of application programming interface programmed state
abstract: A method and system for overriding state information programmed into a processor using an application programming interface (API) avoids introducing error conditions in the processor. An override monitor unit within the processor stores the programmed state for any setting that is overridden so that the programmed state can be restored when the error condition no longer exists. The override monitor unit overrides the programmed state by forcing the setting to a legal value that does not cause an error condition. The processor is able to continue operating without notifying a device driver that an error condition has occurred since the error condition is avoided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08493395&OS=08493395&RS=08493395
owner: Nvidia Corporation
number: 08493395
owner_city: Santa Clara
owner_country: US
publication_date: 20120716
---
This application is a continuation of co pending U.S. patent application Ser. No. 11 625 136 filed Jan. 19 2007 which claims the benefit of U.S. Provisional Patent Application Ser. No. 60 864 374 filed Nov. 3 2006 which is herein incorporated by reference in its entirety.

Embodiments of the present invention relate generally to application programming interface and processor interactions and more specifically to a method and system for overriding programmed state in a processing pipeline.

Unless otherwise indicated herein the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section.

Graphics APIs are used to specify state controls used by a processor to process data and produce images. Ideally the various state controls are orthogonal and any possible setting of a particular state control is valid. Unfortunately certain state control combinations are illegal since they can produce an undefined result or cause an error condition that hangs the processor when the particular state control combination is used to process data. Examples of some illegal combinations include enabling both logic operations and alpha blending enabling dual source blending when the color target format is not blendable or setting the active render target layer number to a number that exceeds the number of available layers in the render target.

Conventionally a variety of schemes have been used to handle illegal state control combinations. One scheme is to simply program the processor without regard to whether or not the state control combinations are legal or illegal and have the processor detect and report any illegal state control combinations as errors and halt any processing. Unfortunately most graphics APIs do not provide a mechanism for indicating these errors to a user so there isn t an effective way to remedy the error and allow the processor to resume processing. Therefore that scheme is not useful in a production system.

Another scheme is to have the processor detect and report any illegal state control combinations as errors and halt any processing until a device driver intervenes and programs a legal state control combination. The device driver is burdened with maintaining the state control settings that were programmed by the API in order to determine a legal state control setting during error handling. The tracking of the programmed state controls and error handling performed by the device driver requires complex code and reduces the system processing performance since the processor is halted during the error handling.

Another scheme is to have the device driver detect and correct illegal state control combinations before sending them to the processor. This also requires the device driver to maintain the state control settings that were programmed by the API. In addition it burdens the device driver with tests to detect illegal state control combinations and then with the task of overriding illegal state control settings with legal ones. The tracking of the programmed state controls checking for illegal state combinations and checking to see if state controls have become legal again requires complex code and reduces the system processing performance because of the storage and testing overhead even if no error conditions are actually present.

As previously explained the error detection notification and handling reduces the data processing throughput of processing system . In particular device driver includes complex code for performing the detection and error handling. Execution of this code for error condition detection even when errors don t exist may also reduce the data processing throughput of processing system .

As the foregoing illustrates a mechanism is needed to detect and correct API programmed state control error conditions without requiring a processor to halt while the error condition is remedied and without requiring the device driver to validate state combinations and to maintain shadow copies of overridden state.

A method and system for overriding state information programmed into a processor using an application programming interface API avoids introducing error conditions in the processor. An override monitor unit within the processor stores the programmed state for any setting that is overridden so that the programmed state can be restored when the error condition no longer exists. The override monitor unit overrides the programmed state by forcing the setting to a legal value that does not cause an error condition. The processor is able to continue operating without notifying a device driver that an error condition has occurred since the error condition is avoided. Therefore the processing throughput of the system is not reduced when error conditions occur. Additionally a device driver is not burdened with maintaining a copy of the desired API programmed state detecting error conditions and remedying the error conditions.

Various embodiments of a method of the invention for detecting and overriding graphics API programmed state settings include receiving a first graphics API programmed state setting determining that an error condition will result from using the first graphics API programmed state setting in combination with other graphics API programmed state settings that are stored in a shadow state memory overriding the first graphics API programmed state setting with a first override value to avoid the error condition and producing a first unit state that includes the other graphics API programmed state settings and the first override value and processing data using functional logic that is configured as specified by the first unit state to produce processed data.

Various embodiments of the invention include a system for detecting and overriding graphics API programmed state settings. The system includes functional logic configured to process data according to state settings that include at least a portion of the graphics API programmed state settings and override values and an override monitor. The override monitor is coupled to the functional logic and configured to receive the graphics API programmed state settings and override a first graphics API programmed state setting with a first override value when a combination of the graphics API programmed state settings will cause an error condition.

A method and system for detecting and overriding API programmed state controls that produce error conditions in a processor is described. In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details.

In contrast with processing system where shadow state is stored and maintained by device driver shadow state is stored within and maintained by processor . Unlike device driver a device driver is not burdened with detecting and remedying error conditions or handling error notifications resulting from API programmed state controls received from processor . Therefore the processing throughput of processing system is improved compared with the processing throughput of processing system that is hindered by error notification handling.

Processor determines if a particular state control specified by a program instruction is illegal as defined by API and overrides the illegal state control with a legal state control. Processor may be configured to detect illegal individual state control settings and override each setting as it is received. Processor may also be configured to detect illegal combinations of state control settings before starting any data processing. Processor also preserves the desired state control that was provided by application program by saving a copy of the API programmed state controls as shadow state .

Shadow state may be stored in a centralized storage resource e.g. random access memory register file cache or the like within processor or shadow state may be stored in a distributed manner by specific processing units that use each portion of shadow state . Shadow state is used to detect illegal state control combinations and to determine legal state control settings during error handling. Shadow state is also used by processor to restore the API programmed state control settings when a subsequent state change removes the error condition.

A graphics device driver is stored in host memory and is configured to interface between applications such as application program and a graphics subsystem . Graphics device driver is executed by host processor to translate instructions for execution by graphics processor based on the specific capabilities of graphics processor . The instructions are specified by an API which may be a conventional graphics API such as Direct3D or OpenGL. Because graphics processor is configured to detect and override error conditions resulting from the API programmed state controls device driver does not need to maintain a copy of the desired state controls specified by the program instructions included in application program .

Graphics processor stores and maintains a shadow state that represents the API programmed state controls specified by application program . Graphics processor also determines and maintains an override state for state controls that have been overridden to avoid an error condition. In some embodiments of the present invention shadow state and or override state are stored in local memory . In addition to detecting and overriding illegal state conditions that are explicitly defined by API graphics processor may be configured to detect and override error conditions that are unique to graphics processor based on a particular hardware limitation. Furthermore graphics processor may be configured to detect different illegal state conditions or specify different overrides depending on the particular API that is used in computing system . Examples of conditions and override values that are used to avoid the possible error conditions are listed in TABLE 1.

Host computer communicates with graphics subsystem via system interface . Data received by graphics processor is processed according to the translated program instructions and the processed graphics data is written to a local memory or host memory . Graphics processor uses graphics memory to store graphics data and program instructions where graphics data is any data that is input to or output from units within graphics processor . Graphics memory can include portions of host memory local memory register files coupled to the components within graphics processor and the like. Graphics processor includes one or more processing units that may each read and or write graphics memory. In alternate embodiments host processor graphics processor system interface or any combination thereof may be integrated into a single processing unit. Further the functionality of graphics processor may be included in a chip set or in some other type of special purpose processing unit or co processor.

In a typical implementation graphics processor performs geometry computations rasterization pixel texture mapping and shading computations and raster operations. In some embodiments of the present invention graphics processor is optionally configured to deliver data to a display device network electronic control system other computing system other graphics subsystem or the like. Alternatively data is output to a film recording device or written to a peripheral device e.g. disk drive tape compact disc or the like.

In one embodiment Shadow state and override state are distributed within graphics processor and stored in portions within each pipeline unit A B and C rather than being stored in a single centralized location. Pipeline unit A receives stream that includes data packets and state bundles from the front end. Data packets contain rendering data to be processed by the graphics pipeline. State bundles are packets containing one more individual state settings that travel through the graphics pipeline in line with rendering data. State bundles may be identified with a flag which distinguishes them from rendering data. In one embodiment each state bundle has a state payload and an identifier tag address which indicates what state it contains and allows units to identify it and copy the state from the bundle when it is received. Pipeline unit A includes a shadow state A that includes the API programmed state control settings that are relevant for pipeline unit A. Pipeline unit A also includes an override state A that may store a flag for each state control setting that is relevant for pipeline unit A and may be overridden by pipeline unit A.

Pipeline unit A outputs a stream including data packets and state bundles to pipeline unit B. Stream may include all of the state bundles received by pipeline unit A or stream may include fewer state bundles. Override values that are generated by pipeline unit A are used within pipeline unit A and are not included in stream . Pipeline unit A may be configured to access graphics memory via memory interface to process the data.

Similarly pipeline unit B processes the data included in stream according to the state bundles that are also included in stream and outputs stream to pipeline unit C. Shadow state B and override state B may include some of the same state control settings and override flags that are stored in shadow state A and C and override state A and C respectively. Therefore the override values for a particular setting may vary for one or more of pipeline units A B and C based on how that particular setting is used within each pipeline unit.

Finally pipeline unit C processes the data included in stream according to the state bundles that are also included in stream and outputs the processed data to memory interface for storage in graphics memory. In other embodiments of the present invention pipeline unit C outputs the data to another device such as another processor or a device configured to display image data. Graphics processor may include other processing units and or additional or fewer pipeline units such as pipeline units A B and C.

In some embodiments of the present inventions pipeline units A B and C are configured to perform data assembly and vertex processing primitive assembly and rasterization and fragment processing and raster operations respectively. In particular pipeline unit A may be configured to collect vertex data for high order surfaces primitives and the like and transform the vertex data as specified by the state bundles included in bundles . For example pipeline unit A may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space.

Pipeline unit B may be configured to construct graphics primitives e.g. points lines triangles or the like and transform the graphics primitives as specified by the state bundles in stream . For example pipeline unit B may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. Pipeline unit B may also be configured to rasterize the new graphics primitives and output pixel fragments and coverage data to pipeline unit C as stream .

Pipeline unit C may be configured to execute fragment shader programs transforming pixel fragments received from Pipeline unit B. For example pipeline unit C may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded pixel fragments. Pipeline unit C may read texture map data that is stored in graphics memory through memory interface for use in processing the fragment data. Pipeline unit C may also be configured to perform near and far plane clipping and raster operations such as stencil z test and the like and output pixel data to memory interface for storage in graphics memory.

Override monitor receives decoded state bundles and detects any error conditions that may exist for the API programmed state controls. As previously described error conditions may be explicitly defined by API or may be based on a particular hardware limitation of functional logic . Override monitor also detects when an error condition that has been overridden no longer exists and restores the desired API programmed state control settings using shadow state or using the current decoded state bundle. Override monitor maintains shadow state and override state as described in conjunction with .

Override monitor provides functional logic with a unit state that is used to control the processing of data performed by functional logic . Unit state represents API programmed state control settings that do not cause error conditions and any override values for API programmed state control settings that do cause error conditions. At any point in time one or more API programmed state control settings may be overridden with override values determined by override monitor . As previously described the override values may be determined based on a particular API and they may be unique to each pipeline unit . Importantly the override values are determined by API behaviors and the override function is transparent to the API device driver and host processor .

If in step override monitor determines that an error condition will be caused by processing the decoded state bundle to update unit state then in step override monitor sets the override flag for the API programmed state setting that is overridden to avoid the error condition. In some instances the API programmed state setting that is overridden is the setting provided by the decoded state bundle in override state . In other instances the API programmed state setting that is overridden is a setting was provided by a previously received decoded state bundle. The override flag indicates that the API programmed state setting has been overridden and does not match the setting stored in shadow state .

In step override monitor overrides a bundle state setting by providing an override value for the setting that does not cause an error condition. Importantly the setting that is overridden corresponds to the override flag that was set in step . In some instances override monitor overrides the API programmed state setting provided by the decoded state bundle. In other instances override monitor overrides an API programmed state setting stored in shadow state that causes an error condition in combination with the API programmed state setting provided by the decoded state bundle. In step override monitor outputs the unit state to functional logic via unit state including the API programmed state stored in shadow state and any override values corresponding to override flags that are set in override state .

If in step override monitor determines that an error condition will not be caused by processing the decoded state bundle to update the bundle state then in step override monitor determines if an override flag is set that is related to the API programmed state setting provided by the decoded state bundle. Note that it is necessary to examine the override flag not just for the API programmed state setting provided by the decoded state bundle but also for any other setting that may have been overridden to avoid an error condition.

For example a first state bundle that sets blend enable true may not cause an error condition when logic operations are disabled. When a second state bundle is received that enables logic operations blend enable is overridden to false to avoid an error condition and the blend enable override flag is set. At a later time a third state bundle is received that disables logic operations eliminating the error condition that caused the blend enable setting to be overridden. When the third state bundle is received the blend enable setting should be restored and the override flag corresponding to the blend enable setting should be cleared. It is necessary to restore overridden settings in order to process the data as specified by the API used by the application program i.e. to process the data as specified by the decoded state bundles.

If in step override monitor determines that an override flag is not set that is related to the API programmed state setting provided by the decoded state bundle then in step override monitor outputs the bundle state. Otherwise in step override monitor determines if any setting that corresponds to an override flag identified in step can be restored to the setting stored in shadow state without causing an error condition. If no setting can be restored without causing an error condition then in step override monitor outputs the overridden state to functional logic via unit state . Otherwise in step override monitor restores one or more settings that each correspond to an override flag identified in step . In step override monitor clears the override flag for each setting that is restored.

In step override monitor determines whether the settings stored in shadow state will cause an error condition. If in step override monitor determines that the state settings stored in shadow state will cause an error condition then the method completes steps and . Steps and correspond to previously described steps and . If in step override monitor determines that the settings stored in shadow state will not cause an error condition then the method completes one or more of steps and before proceeding to step . Steps and correspond to previously described steps and .

Override monitor maintains shadow state as previously described and override logic intercepts the API programmed state output by shadow state and modifies any API programmed state controls included in bundle state that would result in an error condition. When the error condition no longer exists override logic effectively restores the API programmed state controls corresponding to the API programmed state that is stored in shadow state . Override logic may include one or more pipeline stages as needed to decode and modify the API programmed state controls. In particular override logic may include output registers that pipeline bundle state . Note that unit state produced by override monitor is the same as unit state produced by override monitor .

Override monitor provides functional logic with a unit state that represents the API programmed state control settings that do not cause error conditions and any override values for API programmed state control settings that do cause error conditions. As previously described the override values are determined by API behaviors and the override function is transparent to the API device driver and host processor .

If in step override monitor determines that an error condition will be caused by the API programmed state settings stored in shadow state then in step override monitor overrides the API programmed state setting output by shadow state to avoid the error condition. In some instances the API programmed state setting that is overridden is the setting provided by the current decoded state bundle. In other instances the API programmed state setting that is overridden is a setting was provided by a previously received decoded state bundle. In step override monitor outputs unit state to functional logic including the API programmed state stored in shadow state and any override values corresponding to API programmed state setting that are modified by override logic .

Distributing the detection and overriding of API programmed state settings that cause error conditions allows each pipeline unit to continue processing data while avoiding the error conditions. Offloading the detection and overriding tasks from a device driver may also improve the system processing throughput since the device driver does not need to track the shadow state does not need to check for incompatible state settings and does not need to handle error notifications generated by processor or graphics processor for each occurrence of an error condition. Although the detection and state override mechanisms have been described with specific reference to graphics API state settings the detection and state override mechanisms may be used to avoid error conditions in a processor for other types of programmed state. Persons skilled in the art will appreciate that any system configured to perform the method steps of or their equivalents are within the scope of the present invention.

In one implementation to verify the proper operation of the error condition detection and overriding mechanism used for each override monitor are first described in a configuration file. The bundles to be decoded by each bundle decoder may also be defined in a separate definition file. The definitions of the bundles for each bundle decoder may follow certain predefined naming conventions initialization values and default values to facilitate automatic generation of files for verification simulation and synthesis. A global build process can then take all the files mentioned above into account and generate a Verilog module for each bundle decoder and override monitor or in graphics processor . These Verilog modules may be verified and synthesized to produce a semiconductor device that is configured to override API programmed state to avoid error conditions. Specifically these Verilog modules may be used to produce the circuitry of override monitor or .

The invention has been described above with reference to specific embodiments. Persons skilled in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

