---

title: Middleware for multiprocessor software testing
abstract: An apparatus having a memory and multiple processors coupled to the memory is disclosed. The memory may be configured to store middleware. One or more processors may be configured to (a) generate initial test vectors to test one or more software modules executed on the processors and (b) generate modified test vectors by translating the initial test vectors in the middleware to a format that matches multiple hardware dependencies of the processors and multiple software dependencies of multiple operating systems. The test vectors generally have another format that is independent of (a) the hardware dependencies of the processors and (b) the software dependencies of the operating systems executed by the processors. The processors may be configured to generate a plurality of test results by exercising the software modules with the modified test vectors.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08850267&OS=08850267&RS=08850267
owner: Avago Technologies General IP (Singapore) Pte. Ltd.
number: 08850267
owner_city: Singapore
owner_country: SG
publication_date: 20120802
---
The present invention relates to software testing generally and more particularly to a method and or apparatus for implementing middleware for multiprocessor software testing.

Testing software that is executed on a multicore communications processor is complex due to dependencies of the processor hardware and configurations of the cores. Furthermore multiple different operating systems are commonly executed on the different cores resulting in software dependencies for the tests. Different modes of the operating systems can also impact the test procedures.

The present invention generally concerns an apparatus having a memory and multiple processors coupled to the memory. The memory may be configured to store middleware. One or more processors may be configured to a generate initial test vectors to test one or more software modules executed on the processors and b generate modified test vectors by translating the initial test vectors in the middleware to a format that matches multiple hardware dependencies of the processors and multiple software dependencies of multiple operating systems. The test vectors generally have another format that is independent of a the hardware dependencies of the processors and b the software dependencies of the operating systems executed by the processors. The processors may be configured to generate a plurality of test results by exercising the software modules with the modified test vectors.

The objects features and advantages of the present invention include providing middleware for multiprocessor software testing that may i operate in a symmetric multicore mode ii operate in an asymmetric multicore mode iii operate with heterogeneous CPU cores iv operate with homogeneous CPU cores iv abstract operating system dependencies v abstract processor hardware dependencies iv abstract operating system modes vii align test applications to test execution dimensions viii reduce turn around time for test execution and or ix execute on a multicore communication processor.

Some embodiments of the present invention generally concern middleware that simplifies test application execution on a multicore communication processor e.g. MCP based systems. The middleware may abstract the operating systems functioning in symmetric or asymmetric multicore modes on different processor architectures. The multicore communication processor may operate in a symmetric multicore mode and an asymmetric multicore mode using heterogeneous or homogeneous central processing unit e.g. CPU cores. The middleware generally abstracts the operating systems operating system modes and CPU core architectures to make the test application align to multiple dimensions of a test execution. As such the middleware generally provides for seamless test development and regression that may lead to multifold reduced turnaround time for test execution.

Referring to a block diagram of a system is shown. The system or apparatus or device or integrated circuit may be implemented as a multicore communication processor system. The apparatus generally comprises a block or circuit and a block or circuit . The circuits to may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations.

The circuit may implement a multicore processor circuit. The circuit is generally operational to execute software programs middleware and or firmware stored in the circuit . Execution of the software middleware firmware or instructions may provide multiple communications capabilities such as 3G 4G mobile access systems mobile broadband radio network controller applications and or enterprise gateways. Other processor technologies may be implemented to meet the criteria of a particular application. In some embodiments the circuit may be implemented or fabricated as one or more chips or die or integrated circuits .

The circuit may implement a memory circuit. The circuit is generally operational to i store the instructions and data consumed by the circuit and ii store the data created by the circuit . In some embodiments the circuit may implement one or more double data rate type three synchronous dynamic random access memories. Other memory technologies may be implemented to meet the criteria of a particular application. In some embodiments the circuit may be implemented or fabricated as one or more chips or die or integrated circuits separate from the circuit . In other embodiments the circuit may be implemented in on the same chips as the circuit .

Referring to a block diagram of an example implementation of the circuit is shown. The circuit generally comprises multiple blocks or circuits a block or circuit one or more blocks or circuits and one or more blocks or circuits . The circuits to may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations.

Each circuit may implement a CPU or processor core. The circuits are generally operational to execute the instructions received from the circuit to perform the various functions of the system .

The circuit may implement an internal communication circuit. The circuit is generally operational to provide communications among the circuits and . The circuit may include but is not limited to caching capabilities security processing scheduler operations and timer management operations.

The circuit may implement a memory interface circuit. The circuit is generally operational to exchange data and instructions between the circuit and the circuit . The circuit may communicate directly with the circuit .

Each circuit may implement an input output e.g. I O adaptor circuit. The circuits may be operational to exchange data between the circuit and other external circuitry through a variety of I O capabilities. The circuits may include but are not limited to a serialization deserialization e.g. SERDES interface an Ethernet interface a Universal Serial Bus 2 e.g. USB2 interface a dual universal asynchronous receiver transmitter e.g. DUART interface and I2C interface and or a general purpose input output e.g. GPIO Other I O adaptor may be implemented to meet the criteria of a particular application.

Referring to a block diagram of an example file storage within the circuit is shown. The circuit generally stores a module or file multiple modules or files a module or file and a module or file . The modules to may represent modules and or blocks that may be implemented as software firmware middleware a combination of software firmware and middleware or other implementations.

The module may implement a software under test module. The module may be executed on one or more of the circuits . Testing of the module may be performed by the module through the module .

Each module may implement one of multiple different operating systems. The modules may be executed by the circuits . Different combinations of the modules may be executed in parallel by different circuits . Each module may also be operated in several different modes a mode at a time. Each module generally has a corresponding set of software dependencies such as interfaces timing communication protocols resource allocations and the like. In some embodiments the module may be designed to account for the software dependencies of one or more of the modules . In other embodiments the module may be designed to a different set of dependencies than the software dependencies of the modules . In such situations the module and or other software may be created to link the module with one or more of the modules 

The module may be implemented as a test application module. The module is generally operational to generate a set of test vectors used to exercise or stimulate the module the modules and or hardware elements of the circuit to conduct each test. The module may also be operational to receive and analyze results generated during the tests.

The module may implement middleware. The module may be operational to abstract the software dependencies of the modules the modes of the modules and the hardware dependencies of the circuit to make the test application align to multiple dimensions of a test execution. The module may generate a plurality of modified test vectors by translating the test vectors received from the module to another format that matches the hardware dependencies and the software dependencies of the system .

The module is generally used to test the module the modules in the various modes and core specific software layers of the modules which may provide user level application programming interfaces e.g. API to program the hardware of the circuit . The module may provide interfaces for both one or more control planes and one or more data planes.

The module may work remotely if the target hardware is on a network. A layer in the module generally manages login and execution of tests in different test bench setups. The module may also take care of resource management tasks e.g. load balancing and scheduling test tasks in case multiple test suites are being executed on multiple hardware platforms.

Referring to a diagram of an example configuration of the hardware and software of the system is shown in accordance with a preferred embodiment of the present invention. The configuration generally comprises the module in communication with the module . The module may be in communication with the module and the circuit . The module generally comprises multiple modules or files multiple modules or files and a module or file . The configuration may include an optional module or file . The modules to may represent modules and or blocks that may be implemented as software firmware middleware a combination of software firmware and middleware or other implementations.

The modules may implement an operating system abstraction layer e.g. OSAL . The modules may be operational to abstract the operating system specific application dependencies leading to operating system independent code. The module may also enables users to execute test suites for different modes of the modules . The modes may include but are not limited to a symmetric multicore processing e.g. SMP mode and an asymmetric multicore processing e.g. AMP mode to test the software developed for circuit . The module may support VxWorks Linux and OSE forms of operating systems. Other operating systems may be implemented to meet the criteria of a particular application. Multiple instances of the modules may be provided to support each cluster of the modules 

The modules may implement a hardware abstraction layer e.g. HAL . The modules may be generally operational to provide the CPU core architecture independent functionalities used by the module . The functionalities may include but are not limited to providing the CPU core clock ticks and performance monitors for doing performance tests. The modules may provide support for both heterogeneous CPU cores and homogeneous CPU cores. Typical multicore systems may include specific CPU cores or processors for example PPC476 cores ARM A9 cores ARM A15 cores x86 cores MIPS cores and the like. Furthermore some circuits e.g. PCIe adaptors and or SRIO adaptors generally enables the circuits to connect with other CPU core types leading to a heterogeneous computing environment. Multiple instances of the modules may be provided to support each cluster of the circuits . The modules may also support the execution of a test suite on instruction set simulators.

The module may implement a traffic generation driver e.g. TGD . Many hardware accelerators may be provided within the circuit . The hardware accelerators may be used in different computing models such as complete off load a look aside model and similar operations. Some hardware accelerators may be configured as input output adaptors e.g. the circuits that inject traffic into the circuit . For example some circuits may be implemented as Ethernet interfaces XAUI XFI SGMII GMII etc. TDM interfaces SONET interfaces and the like. In order to test the setups of the circuits one or more modules may be used to observe the correct behavior.

The module may implement a traffic generator module. The module is generally operational to create additional test vectors. The test vectors may be inserted into the circuit through the circuits and the corresponding modules . An example implementation of the module may be an IXIA based traffic generator from the IXIA Corporation Calabasas Calif.

A file system mapping e.g. FSM of the system to the target hardware e.g. application specific integrated circuit or field programmable gate array or to an instruction set simulator e.g. ISS may be dependent on the operating systems and operating system modes. File mapping systems supported by the module generally include but are not limited to a network file system e.g. NFS based mapping a filter transfer protocol e.g. FTP based mapping and virtual file system based mapping. Other file mapping systems may be implemented to meet the criteria of a particular application.

Referring to a flow diagram of an example test execution method is shown. The method or process may utilize the module executing in the circuit e.g. executed by one or more of the circuits . The method generally comprises a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step and a block or step . The steps may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations. The method may be performed by the system .

A check may be performed in the step for an input validation. During the input validation test arguments passed to the module may be parsed. The module may rely on a user to specify the hardware platform and the software platform on which the module may be executed. In a case where the hardware platform does not exist and or the software platform is not supported the method may provide one or more notifications to the user in the step .

In the step the method may provide a set of menus to the user. The menus generally display all the test applications available to the user. A user may select one or more applications for execution. Application arguments are generally pre populated. The user may also specify any optional test arguments not already specified in the step . If the optional test arguments are not specified default values may be taken as the entries.

In the steps and the user generally specifies the hardware board and the software platform on which the test may be run. The hardware software selection information is generally provided by the user. The method may also check that the board is booting the same operating systems and correct mode e.g. the SMP mode or the AMP mode as specified in the software platform. If an error occurs the method may continue with the step where corresponding error notifications may be presented to the user and the method exits gracefully.

In the step a test suite may be built with a CPU core specific compiler tool chain and for the user specified operating systems and modes. The module may build or compile the applications for the specified hardware and software during the step . The module may generate appropriate test vectors in executable formats e.g. executable files based upon the operating systems operating system modes and CPU cores.

A check may be performed in the step to determine if the build was successful. If errors remain the method may continue with the step where error notifications are presented to the user. The method may subsequently terminate.

If the build was successful the module is generally responsible in the step for hardware and or instruction set simulator e.g. ISS initialization. The initialization may create the test environment as specified by the user. The step may include hardware and or ISS power cycling and operating system booting in the user specified mode e.g. the SMP mode or the AMP mode in the user defined clusters of CPU cores. Once the hardware initialization has completed a check may be performed at the step to verify that the hardware was properly initialized. If an error occurs during the hardware initialization the method may continue by reporting the error in the step .

Once the hardware has been initialized the tests specified by the user may be initialized in the step . In the step traffic injection e.g. test vector injection may be performed. In multicore communication processors the software generally provides i one or more control planes and ii one or more data plane capabilities. In order to test the module the test vectors may be generated by the module and or the module and transferred to the module on corresponding interfaces. The module may translate or modify the test vectors into a new set of test vectors appropriate for the software dependencies and the hardware dependencies. The new test vectors may be used to exercise the module to conduct the tests. In some situations the traffic generated by the module may override the user specified fields in a generic traffic generation configuration. For example the external traffic may override the virtual local area network e.g. VLAN identification and differentiated services code point e.g. DSCP settings.

In the step the module and or may analyze the results of the test. The module generally provides functionality to validate both the application programming interface level functionality and the data path functionality. The module may expect that all the packets sent from module were received back. In such a case the module may wait until all of the packets are processed. The module may subsequently display statistics for the packets such as a count of the sent packets and a count of the received packets. The module may also provide functionality to validate an integrity of the packets received from the multicore communication processor. In some embodiments the module may decrypt packets received in an encrypted form. In the step the module may generate a verdict for each test run.

The module generally provides functionality to generate multiple levels of test report generation. The test reports may be created in the step . The functionality provided by the module may include but is not limited to saving test logs and reports that span over multiple software release cycles and provide crawl charts that may illustrate a progress from the pass fail metric and from number of test suites.

Referring to a flow diagram of an example operation or method of the modules is shown. The method or process may execute in the circuit e.g. executed by one or more of the circuits . The method generally comprises a block or step a block or step a block or step a block or step a block or step a block or step a block or step and a block or step . The steps may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations. The method may be performed by the system .

The modules may be operational to abstract the operating system specific application dependencies. In particular the modules may select one or more operating systems to be used in the testing of the module in the step . If any of the selected operating systems are unsupported the method may continue with the step . In the step the modules may perform cleanup operations and subsequently end the tests.

If all of the selected operating systems are available the modules may log into the circuit using credentials appropriate for the selected operating systems. If the login fails the method may proceed to the step perform the cleanup and end. Otherwise the modules may set one or more operation specific build and execution environments in the step . If one or more errors occur the method may continue with the step .

In the step the modules may prepare the test bed for the user selected operating system e.g. prepare for the AMP mode or the SMP mode select a correct operating system kernel and bring up the circuits in the selected mode. In the step the modules may select operating system specific drivers for the selected operating systems from one or more files. The selections may be based on the user inputs received in the step . The drivers may be loaded on the circuit by the modules as part of the step . Should any driver fail to load the modules may perform one or more appropriate cleanup tasks in the step .

In the step the modules may select one or more of the executable files that have been previously complied step for the selected operating systems and stored in the circuit . The executable files may be the test applications that the user wants to verify on the circuit . If any of the executable files cannot be found the modules may continue with the cleanup in the step . Otherwise the modules may run the tests in the step by issuing appropriate commands for the selected operating systems. If one or more errors occur during the execution the step may be performed and the method ended. At the end of the test execution the method may end.

Referring to a flow diagram of an example operation or method of the modules is shown. The method or process may execute in the circuit e.g. executed by one or more of the circuits . The method generally comprises a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step a block or step and a block or step . The steps may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations. The method may be performed by the system .

The modules may be generally operational to provide the CPU core architecture independent functionalities used by the module . In the step the modules may select the hardware platform on which the test is to be conducted. The selections may be based on the user inputs received in the step . If the hardware is unsupported the modules may perform cleanup operations in the step . Once the cleanup operations have finished the modules may end the method .

If the selected hardware platform is available the modules may start a simulation load FPGA e.g. field programmable gate array images or access the ASIC e.g. application specific integrated circuit circuitry of the circuit in the step . If an error occurs during the step the modules may continue the method with the cleanup operations in the step and end the test.

In the step the modules may set up a compilation and execution environment for the hardware. If an error occurs during the setup the method may continue with the cleanup in the step . A check may be performed in the step to determine if the circuits are heterogenous or homogeneous. If the circuits are homogenous the method may continue with the step .

In the step the modules may select the appropriate driver files for the hardware platform. The drivers may be loaded on the circuit as part of the step . If one or more drivers fail to load the modules may continue with the cleanup step and end the test.

If the circuits were found to be heterogenous in the step the method may continue with the step . In the step the modules may boot up one or more routines for the heterogenous cores. After the step or the modules may setup performance monitors as appropriate in the step .

The modules may select the executable files compiled step to support the testing of the modules on the circuit in the step . The executable files are generally the test applications that the user wants to verify on the circuit and may be stored in the circuit . The executable files may be run by the modules in the step . If one or more executable files cannot be found and or any execution errors occur the modules may end the test and proceed to the cleanup in the step . Once the testing is complete the modules may end the method .

Referring to a flow diagram of an example operation or method of the module is shown. The method or process may execute in the circuit e.g. executed by one or more of the circuits . The method generally comprises a block or step a block or step a block or step a block or step a block or step a block or step a block or step and a block or step . The steps may represent modules and or blocks that may be implemented as hardware software a combination of hardware and software or other implementations. The method may be performed by the system .

In the step the module may determine which configurations of the operating systems and the hardware are being used in the test. The user may have an option to specify a path and name of one or more traffic files in the step . The user specified traffic files may be selected by the module from a directory in the step to account for the determined operating systems and the hardware platform. The directory is generally the same directory used for one or more test cases. The traffic files may include but are not limited to IXIA files and Adtech files Adtech Inc. Honolulu Hi. . If one or more of the traffic files are not specified the module may proceed to the step where cleanup operations may be performed. After the cleanup is complete the test may end.

In the step the module may determine one or more connection details for the circuit . If an error occurs the module may continue the method with the step for cleanup operations. If the connections are good the module may log into to the module in the step . Failure to log in may cause the module to continue with the cleanup tasks in the step .

In the step the module may update the traffic files for a proper connection to the module . The module may have multiple cards. Each card may have one or more unique numbers or addresses . The updating generally includes but is not limited to updating a virtual local area network e.g. VLAN identifications and aligning the traffic file for the card in use. The alignment may be performed based on a table. The table generally maintains a mapping as specified to the user test environment. If an error occurs during the updating the module may proceed to the step for the cleanup task.

During the test the module may verify that the intended traffic is being received from the module in the step . The module may also verify that the outgoing traffic generated by the module under test is correct in the step . The verification may continue until the test ends. The module generally keeps track of the packets sent and verify a packet count that has been received. Thus the module may verify that the expected number of packets has been received or not. If one or more errors arise in the received traffic during the test the module may continue the method with the cleanup tasks in the step .

The functions performed by the diagrams of may be implemented using one or more of a conventional general purpose processor digital computer microprocessor microcontroller RISC reduced instruction set computer processor CISC complex instruction set computer processor SIMD single instruction multiple data processor signal processor central processing unit CPU arithmetic logic unit ALU video digital signal processor VDSP and or similar computational machines programmed according to the teachings of the present specification as will be apparent to those skilled in the relevant art s . Appropriate software firmware coding routines instructions opcodes microcode and or program modules may readily be prepared by skilled programmers based on the teachings of the present disclosure as will also be apparent to those skilled in the relevant art s . The software is generally executed from a medium or several media by one or more of the processors of the machine implementation.

The present invention may also be implemented by the preparation of ASICs application specific integrated circuits Platform ASICs FPGAs field programmable gate arrays PLDs programmable logic devices CPLDs complex programmable logic devices sea of gates RFICs radio frequency integrated circuits ASSPs application specific standard products one or more monolithic integrated circuits one or more chips or die arranged as flip chip modules and or multi chip modules or by interconnecting an appropriate network of conventional component circuits as is described herein modifications of which will be readily apparent to those skilled in the art s .

The present invention thus may also include a computer product which may be a storage medium or media and or a transmission medium or media including instructions which may be used to program a machine to perform one or more processes or methods in accordance with the present invention. Execution of instructions contained in the computer product by the machine along with operations of surrounding circuitry may transform input data into one or more files on the storage medium and or one or more output signals representative of a physical object or substance such as an audio and or visual depiction. The storage medium may include but is not limited to any type of disk including floppy disk hard drive magnetic disk optical disk CD ROM DVD and magneto optical disks and circuits such as ROMs read only memories RAMS random access memories EPROMs erasable programmable ROMs EEPROMs electrically erasable programmable ROMs UVPROM ultra violet erasable programmable ROMs Flash memory magnetic cards optical cards and or any type of media suitable for storing electronic instructions.

The elements of the invention may form part or all of one or more devices units components systems machines and or apparatuses. The devices may include but are not limited to servers workstations storage array controllers storage systems personal computers laptop computers notebook computers palm computers personal digital assistants portable electronic devices battery powered devices set top boxes encoders decoders transcoders compressors decompressors pre processors post processors transmitters receivers transceivers cipher circuits cellular telephones digital cameras positioning and or navigation systems medical equipment heads up displays wireless devices audio recording audio storage and or audio playback devices video recording video storage and or video playback devices game platforms peripherals and or multi chip modules. Those skilled in the relevant art s would understand that the elements of the invention may be implemented in other types of devices to meet the criteria of a particular application.

The terms may and generally when used herein in conjunction with is are and verbs are meant to communicate the intention that the description is exemplary and believed to be broad enough to encompass both the specific examples presented in the disclosure as well as alternative examples that could be derived based on the disclosure. The terms may and generally as used herein should not be construed to necessarily imply the desirability or possibility of omitting a corresponding element.

While the invention has been particularly shown and described with reference to the preferred embodiments thereof it will be understood by those skilled in the art that various changes in form and details may be made without departing from the scope of the invention.

