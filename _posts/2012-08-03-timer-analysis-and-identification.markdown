---

title: Timer analysis and identification
abstract: In an embodiment, a technique for identifying a timer in a graphical block diagram environment. According to the technique, one or more variables associated with an executable model in a graphical diagram environment are identified. One or more characteristics associated with the identified one or more variables are identified and the timer is identified based on the one or more characteristics.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08868399&OS=08868399&RS=08868399
owner: The MathWorks, Inc.
number: 08868399
owner_city: Natick
owner_country: US
publication_date: 20120803
---
This application is a Continuation of U.S. Ser. No. 11 982 289 filed Nov. 1 2007 which claims the benefit of U.S. Provisional Patent Application Ser. No. 60 856 230 which was filed on Nov. 2 2006 and which is hereby incorporated by reference in its entirety.

Smooth operation of modern day software systems may often be ensured through rigorous verification processes. For a particular system these processes may involve performing multiple tests on the system which may include checking various system properties. The tests may be run without executing one or more portions of code in the software system. Regardless of how a software system may be verified one goal often associated with verification is to achieve good test and or analysis coverage. Here the term coverage may refer to those portions of a software system that are examined by e.g. analysis and or tests used in the verification process. Typically greater coverage often translates to more paths being tested in the software system. Usually the more paths that are tested in the software system the greater the assurance that the software system is operating as expected.

A software system may include a model that represents a system. The model may be textual and or graphical and may be executed to predict analyze verify and or examine the behavior of the system. At any stage in a design verification and or analysis process of a model it may be necessary to test and or statically analyze the model. Various tools may be used for such analysis and testing and one or more portions of the model may be provided to those tools via e.g. various Application Program Interfaces APIs . APIs used for testing and or analysis may be designed in compliance with industry standards and or may be custom designed for a particular application or a set of applications e.g. a proprietary design .

Analyzing a system may be a complex process. The success of the analysis may depend on the size and or complexity of the system under study. Simplification of the system may be helpful and may increase the likelihood that the analysis is successful. Simplification may involve replacing a part of the system with a functionally equivalent representation that is better suited for analysis. Choosing a satisfactory functionally equivalent representation may increase scalability simplify the analysis provide structure for analysis or provide other benefits. In addition the precision of the analysis may be maintained by ensuring that the behavior of the functionally equivalent representation is unchanged from the original representation or varies from the original representation only in ways that do not negatively affect the quality of the analysis.

Analysis may refer to static or dynamic analysis techniques such as for example formal analyses like model checking theorem proving and linear programming dynamic simulation Monte Carlo techniques etc. Analysis may also include other types of techniques that may be derived from the above techniques and or combinations of the above techniques. Static analysis of a system may relate to a type of analysis that may be performed for example without executing a model that represents the system. Dynamic analysis of a system may relate to a type of analysis that may be performed for example during and or after the execution of at least a portion of e.g. a model of the system.

A system may be represented via a system representation that may be implemented in source code a graphical modeling diagram a graph a model written in a Unified Modeling Language UML state diagram etc. The system representation may reflect functional aspects of the system its data flow its control flow its mathematical properties and so on. As part of static analysis of a system it may be useful to analyze the system representation to demonstrate certain properties of the system and to identify test patterns for the system based on these properties. The test patterns may include for example test inputs that assess and or improve test coverage of the system. In addition the test patterns may include for example test input that demonstrate different aspects of the system s design or to confirm that certain properties of the system are valid e.g. through mathematically based proofs .

Various techniques such as code proving or model proving may be used to analyze a representation of a system. However these techniques may be not efficient at handling system designs that incorporate one or more timers. The reason for this inefficiency may be that the complexity of the analysis may increase with the number of iterations and or execution steps of the design due to the presence of the timers. Timers by their nature often require a great number of iterations in order to test them well.

A system may contain one or more timers that are used to hold portions of the system in certain states for certain periods. The period may be measured in clock cycles time units event occurrences etc. e.g. other period measurements . Timers are sometimes referred to as counters and those terms are used interchangeably herein.

Timers may come in various types and may be expressed in textual graphical and or other forms. In addition timers may be explicit or implicit. A timer may include 1 a storage which may be configured to hold a value associated with the timer 2 an update operation e.g. increment decrement etc. which may be used to update the timer s value on a regular basis and 3 a test operation which may be used to test the timer s value to determine if it has reached a threshold value. The storage associated with the timer may implemented in hardware or software e.g. as a variable . The update operation may be an operation that updates the value contained in the storage on a periodic basis an event basis etc. The test operation may compare the value held by the storage to a predetermined threshold value to determine if a particular condition associated with the timer exists with respect to the threshold value e.g. the timer has reach a value that is greater than the threshold value less than the threshold value matches the threshold value etc. .

A timer may make one or more portions of a system unreachable or inactive until the timer reaches its threshold value. Such timers may complicate analysis and or testing of the system especially in cases where timers are not explicitly specified.

In an embodiment of the invention a timer in a particular representation may be replaced with a predefined representation. The predefined representation may be specific or may be generic. The predefined representation may be defined by an Application Programming Interface API . The API may be built into tools used to develop the model or code provided separately e.g. by a party providing the tools or a different party etc. Many different representations may be used to represent timers and in some embodiments of the invention it may be possible to change a representation to an alternative representation based on various preferences.

Embodiments of the present invention are not limited to particular types of timers. In general a timer may involve a notion of 1 something that can be reset 2 something that can be periodically updated e.g. incremented decremented etc. 3 something that can be tested and 4 something that after a certain number of updates or tests may return a value e.g. a logical TRUE a logical FALSE etc. .

The identification of timers in a system and their subsequent rewriting to a particular representation or conversion to a particular type may simplify the analysis and or testing of the system. For example as will be described further below a timer s representation may be rewritten into a different representation in order to e.g. make the representation more suitable for analysis and or testing. Likewise for example as will be also described further below a timer may be converted from an opaque type to a transparent type in order to e.g. make a value associated with the timer accessible for analysis and or testing.

It may be possible to specify formal parameters for a given timer that may be used during a static analysis and or testing of a system. In an alternative usage there may be a variety of tests available for a timer and those tests may be applied when a testing unit encounters a timer of a particular type or in a particular representation. Identification of the timers may also allow further optimizations of the system especially in situations where the timers temporarily disable or make unreachable one or more portions of the system.

Note that in the above example X is associated with an initialization operation line a test operation line and an update operation line . Since operations and may relate to a timer the operations may be considered timer related operations. Assuming X is not assigned a value in the PERFORM OPERATIONS section an analysis of X and its associated operations may determine that the pseudo code illustrated in contains a timer comprising the operations at lines and .

It should be noted that in the above example the while construct is used merely for illustrative purposes. Other language constructs may be used such as for example a for loop construct a foreach loop construct a goto construct or any other construct that allows for a repetition of a block of code.

Note that in the state diagram I is associated with an initialization operation i.e. I 0 an update operation i.e. I I 1 and a test operation i.e. I 500 . As noted above these operations may be considered timer related operations. Analysis of I and its associated operations in the state diagram may determine that the state diagram contains a timer.

The input port is configured to input a signal into the system. First constant generator is configured to output a constant value which in this example is represented by C1 . Likewise the second constant generator is configured to output a constant value which in this example is represented by C2 . The unit delay is configured to hold e.g. store a value that is input into the unit delay and after a predetermined delay output the value from the unit delay . The adder is configured to add the value outputted by the first constant generator to the value outputted by the unit delay to produce a sum. The sum is output by the adder and fed to the relational operator and the unit delay .

The relational operator is configured to determine if a value at its A input which in this example is the value that is output by the constant generator is less than or equal to the value at its B input which in this example is the value that is output by the adder . If so the relational operator outputs a logical TRUE signal. Otherwise the relational operator outputs a logical FALSE signal. The subsystem is configured to input a signal from the input port at the subsystem s IN1 input and to output a signal from the subsystem at its OUT1 output based on the inputted signal. The signal outputted from the subsystem is fed to a B input of the switch . Likewise the signal inputted into the system via input port is fed to an A input of switch . The switch is configured to output either a signal present at its A input or a signal present at its B input based on a control signal that is present at its C input. In this example the control signal is supplied by the relational operator .

Operationally the value held by the unit delay is initialized to some value e.g. zero . After a delay the unit delay outputs the value to the adder . The value is input into the adder which adds the value to C1 . The result of the addition is a sum that is transferred to the relational operator s B input and to the unit delay s input.

The relational operator compares the sum with C2 . If C2 is greater than the sum the relational operator outputs a logical FALSE signal which is fed to the control input C of the switch and causes the switch to output the signal that is present at its A input which in this example is the signal that is output by the input port . Otherwise if C2 is less than or equal to the sum the relational operator outputs a logical TRUE signal which causes the switch to output a signal that is present at its B input which in this example is the signal that is output by the subsystem . The outputted signal is output from the system at output port .

The sum that is fed to the unit delay is stored by the unit delay . After a delay the unit delay begins a next iteration that includes outputting the stored sum from its output to the adder . The adder adds C1 to the sum to produce a new sum. The new sum is fed to the relational operator and the unit delay which process the new sum as described above. This cycle repeats causing the sum to increase by C1 at each iteration.

Note that operations performed by the system include an initialization operation performed by the unit delay an update operation performed by adder and a test operation performed by the relational operator . Also note that these operations are associated with the value that is held by the unit delay . Thus analysis of this value and its associated operations may determine that the block diagram contains a timer.

It should be noted that while a few example timers are illustrated in timer representations or variations are not limited to those and may be simple or complex textual and or graphical and may be represented in any number of possible representations.

In an embodiment a separate record may be maintained for each variable that is analyzed for a system. As will be described further below the records may be processed to determine if 1 one or more timers are contained in the system 2 any of the timers should be rewritten and 3 any of the timers should be converted.

Various techniques may be used to identify variables that may be associated with timers. Such techniques may include static analysis techniques such as for example abstract interpretation partial evaluation control flow analysis optimizations etc. The use of static analysis techniques may help identify timers that may not be readily apparent to e.g. a user certain test and or analysis software etc. For example a system may contain a nearly timer which may not initially appear to be a timer but on closer inspection may be actually identified as a timer.

Referring to X C and Y are variables. X holds a value that is associated with the timer. C is assigned a value is used to periodically update X . Y is assigned the value of X at each iteration of a loop that begins at line and ends at line .

At line variable X is initialized to a value of zero. Likewise at line variable C is initialized to one. Within the loop at line a test is performed to determine if the value of X is greater than a threshold value which in this example is twenty. If so at line the loop is stopped. Otherwise at line Y is assigned the value of X . At line X is incremented by the value of C .

An analysis of the pseudo code illustrated in may employ various techniques e.g. partial evaluation that may determine that variable Y behaves as an indirection of variable X and that operations performed at line include a timer update operation associated with variable X . In addition the analysis of the pseudo code may determine that an initialization operation associated with X is performed at line and a test operation associated with X is performed at line . Moreover the analysis may determine that variable C is initialized to a particular value at line and that the value does not change i.e. it remains constant throughout the operation of the loop. The above determinations may be reflected in one or more fields contained in the records that are maintained for the variables X Y and C . In addition the fields may indicate that X is associated with an initialization operation line a test operation line and an increment operation line .

In after the variables have been analyzed their associated records may be analyzed to determine if the pseudo code contains a timer. This analysis may include determining whether one or more particular variables are associated with timer related operations. If so the analysis may determine that a timer is contained in the pseudo code.

Referring to a record for variable X may indicate that X is initialized updated tested and incremented after the test. These indications may be made as a result of the analysis of operations performed at lines and . The analysis of the operations may include a partial evaluation of expressions at those lines to determine the type of operations performed at those lines. For instance the analysis may include a partial evaluation of the expression at line which results in finding that the value of Y is equivalent to the value of X and that an equivalent expression to X Y C expression at line may be X X C . From this equivalent expression the analysis may further find that since the value of C does not change in the loop while in the loop X is being incremented by a constant and that the operation performed by the expression at line may be a timer update operation associated with a timer. Taking the above into consideration the above characteristics associated with X the analysis may determine that X may be associated with a timer and therefore the analysis may determine that the pseudo code illustrated in may contain a timer where X is a value associated with the timer.

In some instances it may be advantageous to rewrite a representation of a timer into a different representation in order to accommodate for example testing and or analysis of the timer. The rewriting may include rewriting one or more timer related operations into a notation that indicates functions performed by the timer related operations. The notations may be used by various test and or analysis techniques to readily identify the timer and its associated operations. For example one technique that may be used to test a timer may involve initializing the timer to a particular value in order to expedite the timer s expiration. A test that incorporates this technique may 1 examine the notated representation to locate a notation that identifies an initialization operation associated with the timer and 2 modify the located notation to initialize the timer to the particular value.

Referring now to line includes notations that indicate that the timer is reset and started. Specifically at line the notation TIMER RESET T 0 indicates that an initialization operation is performed on the timer which resets the timer to a value of zero. This notation may reflect functions performed by the initialization operation at line . In addition at line the notation TIMER START T indicates the timer is started.

At line variable C is initialized. This line is equivalent to line . Likewise line denotes the beginning of a loop. Line is equivalent to line . Line includes the notation TIMER TEST T 20 which indicates a test operation is performed on the timer. The notation at line may reflect functions performed by the test operation at line . At line the loop is stopped. This line is equivalent to line . At line Y is assigned the value of X . This line is equivalent to line .

Line includes the notation TIMER UPDATE T C which indicates that an update operation that involves updating the timer by the value of variable C is performed on the timer. The notation at line may reflect functions performed by the update operation at line . Line denotes the ending of the loop. Line is equivalent to line .

Note that the notation used in makes apparent operations performed by corresponding lines in as those operations relate to an operation of the timer. For example since analysis may show that X is associated with the timer describing the assignment made to X at line as TIMER RESET makes it readily apparent that the assignment relates to resetting the timer. Likewise describing the assignments made at lines and as TIMER UPDATE makes it readily apparent that the operations performed at these lines relate to updating the timer. Making operations associated with a timer more apparent may make analyzing and or testing the timer easier.

In an embodiment of the invention nearly timers may be identified and combined and or rewritten e.g. into the above described notation to generate a more generally accepted representation of the timers. The generally accepted representation may be more conducive to analyzing and or testing a system containing the nearly timer than if the nearly timer were not rewritten. Such rewriting may benefit from information derived through static analysis.

The above described analysis can be used with a number of representations that may represent processing activities. For example the above described analysis may be applied to control flow graphs to identify timers contained in the graphs. illustrates an example of a control flow graph that includes a nearly timer . The control flow graph may represent part of an executable model that may be executed in a graphical diagram environment. The executable model may in turn represent a system or a portion thereof.

Referring to variable X is associated with the nearly timer . At block the value of X is initialized to a value which in this example is one. At block the value of X is tested to determine if it is greater than zero. If not the flow of control proceeds to the rest of the system which is represented by block . Otherwise the flow of control proceeds to block where the value of X is tested to determine if it is less than ten. If so the flow of control proceeds to block where the value of X is incremented by one and the flow of control returns to block . Otherwise if the value of X is not less than ten the flow of control proceeds to block .

An analysis of the flow control graph in may be determine that the result of the test at block will always be true because the value of X was initialized to a value greater than zero and remains greater than zero throughout execution of the control graph . As such the analysis may determine that that branch of the control flow graph may be disregarded and analysis of the remaining branch may result in determining that the portion of the system represented in the control flow graph contains a timer.

Specifically analysis of X may show that X is associated with an initialization operation block a test operation block and an increment operation block . Analysis of these operations may determine that these operations are timer related. In addition analysis of the test operation at block and the increment operation at block may determine that these operations are involved in a loop that is controlled by the value of X . More specifically the analysis may determine that X is incremented until it reaches a threshold and after it reaches the threshold the loop is exited. From these conclusions the analysis may determine that X is associated with timer related operations and that the timer related operations in aggregate form a timer.

A rewritten version of control graph may exclude block and include notations as described above to identify various timer related operations associated with the timer. For example the initialization operation performed at block may be rewritten to include TIMER RESET T 0 where T represents the timer. Likewise the test operation performed at line and the update operation performed at line may be rewritten to include TIMER TEST T 10 and TIMER UPDATE T 1 respectively.

As discussed above various static analysis techniques may be used to identify timer resets or initial value assignments. In an embodiment a model may be rewritten in an intermediate form in order to simplify the analysis. The analysis may include partial evaluation techniques e.g. constant folding expression folding etc. . The analysis may rewrite expressions associated with the variables into a more manageable intermediate form for analysis. For example partial evaluation techniques may be used to rewrite the expression X 23 40 63 to an equivalent intermediate form that may be more manageable for analysis such as X 0 .

In an embodiment assignment expressions may be rewritten in an abstract format for analysis. Moreover compiler type optimizations may be performed before and or during the analysis to identify timers in order to simplify the analysis.

An embodiment may recognize multiple classes or types of timers. Those classes or types may have different properties and may be ranked in an order of their desirability . Desirability may be based on how well the classes or types simplify analysis and or rewriting of the timers. A more desirable class or type may be better structured in terms of constraints that may be applied and or enforced on the class or type.

Timers may be classified as being either opaque or transparent . An opaque timer relates to a timer whose value does not appear outside of the timer. The value may not be involved in operations other than those related to maintaining the timer. For example timers shown in may be considered opaque timers because the values of the timers do not appear outside the timers. A transparent timer on the other hand may make the timer s value available outside the timer. Exposing a timer value outside the timer may allow operations outside the timer to use the value.

Analysis may indicate that the unit delay the first constant generator the second constant generator the adder and the relational operator comprise a timer. The second output port is an output port configured to output a signal that represents a value of the timer. This signal enables the value associated with the timer to be made visible outside of the timer which in turn makes the timer transparent timer.

As noted above exposing a timer value outside the timer may allow operations outside the timer to use the value. For example a test may use the value to determine if the timer is operating properly. Here the test may include operations which 1 initialize the timer to a certain value 2 allow the timer to complete an update operation 3 read the timer value and 4 compare the read timer value to an expected value to determine if the timer is operating as expected.

An opaque timer may be converted to a transparent timer in order to make certain aspects of the timer visible outside the timer. For example the timer illustrated in may be converted to the timer illustrated in by adding the output port in order to make the value maintained in the timer visible outside the timer. As noted above making this value available outside the timer may make testing of the timer easier than if the value were not available.

In some situations it may be desirable to convert certain already existing transparent timers to opaque timers. For example if a timer value associated with a transparent timer is not used by an operation outside the timer the transparent timer may be a good candidate to be converted to an opaque timer. Likewise for example if the timer value s use by operations outside the timer does not significantly or adversely impact the operation of the system the transparent timer may be a good candidate to be converted to an opaque timer. Converting a transparent timer to an opaque timer may make analysis and or testing of the timer easier from the perspective that operations outside the timer may not need to be further analyzed and or tested.

Independent of their transparency or opaqueness timers may also be classified as ordered or unordered based on an order of operations within the timer. In an ordered timer any update operations e.g. increment decrement etc. may occur completely and consistently either before or after a test operation. In an unordered timer the update operations and test operations may be interleaved such that some update operations may occur before the test operation and other update operations occur after the test operations.

Referring to variable X is associated with the timer. Line indicates the beginning of a loop that ends at line . At line a test is performed to determine if the value of X is less than ten. If so at line the value of X is updated which in this example is incremented by one. If X is not less that ten at line operations associated with PERFORM OPERATIONS are performed. Note that in the increment operation at line is completely and consistently performed after the test operation at line . Therefore a timer comprising lines and may be considered an ordered timer.

Note that in the value of variable X is updated twice in the loop. The first update occurs at line before the test at line and the second update occurs at line after the test at line . This interleaving of different types of timer related operations makes the timer an unordered timer and may make the timer difficult to analyze and or test.

Certain unordered timers may be rewritten into a different representation in order to make them easier to analyze and or test. illustrates an example rewriting of an unordered timer as an ordered timer. The example pseudo code in may be used to rewrite the timer in .

Referring to the rewriting may involve combining the update operations at lines and into a single update operation such as the update operation at line . In addition the test operation at line may be modified to accommodate the rewritten update operations. Line illustrates an example of how line may be rewritten.

Note that if operations in the PERFORM OPERATIONS section of code were to assign new values to X those operations may also be modified in a manner similar to the way the above test operation was modified in order to reflect the changed value of variable X .

In an embodiment of the invention a section of a model may be identified as a timer after the section is converted to a different type. For example a section of a continuous time model may be converted to discrete time and afterwards may then be identified as a timer.

Upon analysis it may be determined that this section may be represented by a timer in a discrete time model where the timer counts to a time corresponding to the threshold value based on the function corresponding to the integrator. As such in one embodiment of the invention identification of the timers may be used to transform a model or a portion of a model from continuous time to discrete time.

In another embodiment of the invention a language in which a model is written may itself provide a timer expression. This may be identified in an implicit timer. illustrates an example of an implicit timer represented in a block diagram. Referring to the timer may be identified through identification of a clock being fed to a relational operator along with the output of a constant generator . This design may execute at a uniform update rate so that the output of the clock is multiple of the same period constant.

In yet another embodiment of the invention the language may provide some elements of a timer but not all and the analysis may be employed to analyze the model and locate timers by analyzing specifics of other uses of potential timer variables.

Various embodiments of the invention may apply to both imperative languages e.g. languages that describe computation as statements that change a program state and non imperative languages e.g. functional programming languages logical programming languages etc. . For example in an embodiment that uses state diagrams it may be possible to look for temporal logic operators in the diagrams that implicitly define counters. In yet another embodiment of the invention a language of the model may have elements of timer updates and timer initializations that are broader than can be handled by a particular analysis and so instead of just identifying that a particular section may be a timer it may be necessary to perform other analysis to identify whether a potential timer variable meets one or more preset restrictions.

Different embodiments may be used on various software and or hardware systems and are not limited to the embodiments described above. These systems may include textual systems graphical systems combinations of graphical and textual systems and any number of intermediate representations of systems such as bytecode compiler optimized code output of other optimizers machine code etc.

At step one or more characteristics associated with the variable are identified. As noted above these characteristics may include operations e.g. assignment operations etc. associated with the variables. Also as noted above records may be maintained for the variables that reflects the identified characteristics. Maintaining a record for a particular variable may include indicating in the record that the variable is associated with various characteristics as described above.

At step the timer is identified based on the one or more identified characteristics. As noted above the timer may be identified by examining the characteristics to determine if the characteristics include one or more timer related operations. The timer may be identified based on the timer related operations performed on a particular variable. For example if the variable is associated with an update operation e.g. increment decrement etc. a test operation and an initialization operation it may be determined that the variable is associated with a timer and that a timer exists in the system.

At step a check is performed to determine if the timer should be rewritten. Here the check may include determining if the timer in its current representation may be rewritten to better accommodate e.g. testing and or analysis as described above. In addition the check may include for example determining if certain timer related operations may be combined into a single operation. If so the check may determine the timer should be rewritten. Moreover the check may include for example determining if certain portions of code associated with timer related operations may be rewritten to make these operations more readily apparent in the code.

During timer identification certain variables may be eliminated from consideration as being associated with a timer due to characteristics associated with the variables. For example if one or more characteristics indicate that a variable is associated with an assignment operation in the body of a loop it may be determined that the variable is not associated with a timer and may therefore be eliminated from further consideration as a variable associated with a timer.

If it is determined that the timer should not be rewritten the sequence proceeds to step . Otherwise if it is determined that the timer should be rewritten the sequence proceeds to step where the timer is rewritten. The rewriting may include combining certain timer related operations e.g. update operations or rewriting the timer s representation into a notation that makes timer related operations associated with the timer more readily apparent. In addition the rewriting may include storing the rewritten timer in a memory of e.g. a computer system. The memory may include for example a primary storage device such as a main memory that is directly accessible to a processor in the computer system or a secondary memory such as a disk unit.

At step a check is performed to determine if the timer should be converted. This check may involve determining if the timer is for example an unordered timer that can be rewritten into an ordered timer. If at step it is determined that the timer should not be converted the sequence proceeds to step . Otherwise if it is determined that the timer should be converted the sequence proceeds to step where the timer is converted. The conversion may involve converting the timer to a different type. For example as noted above an unordered timer may be converted to an ordered timer in order to better accommodate e.g. analysis and or testing. In addition the conversion may include storing the converted timer in a memory of e.g. a computer system. The memory may include for example a primary storage device such as a main memory that is directly accessible to a processor in the computer system or a secondary memory such as a disk unit. The sequence ends at step .

It should be noted that various environments may be configured to practice embodiments of the invention. For example illustrates an example of a distributed environment that may be configured to practice an embodiment of the invention. Referring to environment may include a computer system network service provider target environment and cluster . Note that the distributed environment illustrated in is just one example of a distributed environment that may be used with the invention. Other distributed environments that may be used with the invention may include environments that contain additional devices fewer devices or devices in arrangements that differ from the arrangement of environment .

Computer system may include a device capable of sending and or receiving information e.g. data to and or from another device such as target environment respectively. Computer system may be for example a desktop computer a laptop computer a client computer a server computer a mainframe computer a personal digital assistant PDA a web enabled cellular telephone a smart phone smart sensor actuator or another computation or communication device that executes instructions that enable the computer system to perform one or more activities and or generate one or more results. Information as used herein may refer to any type of machine readable information having substantially any format that may be adapted for use e.g. in one or more networks and or with one or more devices. The information may include digital information and or analog information. The information may further be packetized and or non packetized.

In an embodiment computer system may include a technical computing environment TCE . The TCE may include a graphical block diagram environment that may be used to execute models and manipulate the models in accordance with techniques described herein. In other embodiments computer system may include other components applications etc. The TCE may contain computer executable instructions code and data that are configured to implement the TCE. The instructions may include instructions configured to implement modeling software and or graphical analysis software . The modeling software and the analysis software may be graphical textual or a hybrid that includes both textual and graphical capabilities features.

The modeling software may include computer executable instructions that allow e.g. a user to build and or execute a model. For example the modeling software may allow a user to build and execute a time based model a state based model an event based model a dataflow based model etc. In an exemplary embodiment the modeling software may be implemented using the Simulink software. Simulink software is available from The MathWorks Inc. Natick Mass.

The analysis software may include computer executable instructions that allow information in a model to be evaluated. Evaluating a model may include generating tests for the model that satisfy model coverage and various objectives that may be user defined. In addition evaluating a model may include proving various model properties and generating examples of violations of these properties. Moreover evaluating a model may include analyzing the model in accordance with techniques described herein to identify rewrite and or convert timers contained in the models. In an exemplary embodiment analysis software may comprise the Simulink Design Verifier software which is available from The MathWorks.

The network may include any network capable of exchanging information between entities associated with the network including for example the computer the service provider the target environment and the cluster . The information may include for example packet data and or non packet data. Implementations of the network may include local area networks LANs metropolitan area networks MANs wide area networks WANs etc. Information may be exchanged between entities using any network protocol such as but not limited to the Internet Protocol IP Asynchronous Transfer Mode ATM Synchronous Optical Network SONET the User Datagram Protocol UDP Institute of Electrical and Electronics Engineers IEEE 802.11 etc.

Network may comprise various network devices such as routers switches firewalls and or servers. Portions of network may be wired e.g. using wired conductors optical fibers etc. and or wireless e.g. using free space optical FSO radio frequency RF acoustic transmission paths etc. . Portions of network may include a substantially open public network such as the Internet. Portions of network may include a more restricted network such as a virtual private network VPN . It should be noted that implementations of networks and or devices operating on networks described herein are not limited with regards to information carried by the networks protocols used in the networks the architecture configuration of the networks etc.

The service provider may include logic e.g. software that makes a service available to another device in the distributed environment . The service provider may include a server operated by an entity e.g. an individual a corporation an educational institution a government agency etc. that provides one or more services to a destination such as computer . The services may include software containing computer executable instructions that may be executed in whole or in part by a destination by the service provider on behalf of the destination or some combination thereof.

For example in an embodiment service provider may provide one or more subscription based services that may be available to various customers. The services may be accessed by a customer via a network such as network . The customer may access the services using a computer such as computer . The service provider may limit access to certain services based on e.g. a customer service agreement between the customer and the service provider . The service agreement may allow the customer to access services that allow the customer to build and or execute a model. In addition the service agreement may allow the customer to further analyze models generate code from the models generate various reports access audit services that allow a customer s code to be audited etc. The service agreement may include other types of arrangements such as certain fee based arrangements or restricted access arrangements. For example a customer may pay a fee which provides the customer unlimited access to a given package of services for a given time period e.g. hourly daily monthly yearly etc. . For services not included in the package the customer may have to pay an additional fee in order to access the services. Still other arrangements may be resource usage based. For example the customer may be assessed a fee based on an amount of computing resources or network bandwidth used.

Cluster may include a number of units of execution UEs that may perform processing on behalf of computer and or another device such as service provider . For example in an embodiment cluster may parallel process graphical models created by e.g. a customer. This parallel processing may include performing analysis on the models. The UEs may reside on a single device or chip or on multiple devices or chips. For example the UEs may be implemented in a single application specific integrated circuit ASIC or in multiple ASICs. Likewise the UEs may be implemented in a single computer system or multiple computer systems. Other examples of UEs include field programmable gate arrays FPGAs complex programmable logic devices CPLDs application specific instruction set processors ASIPs microprocessors etc.

The UEs may be configured to perform operations on behalf of another entity. For example in an embodiment the UEs are configured to execute portions of code associated with the TCE . Here the TCE may dispatch certain activities pertaining to parallel processing activities to the UEs for execution. In another embodiment the service provider may configure cluster to provide interactive model design capabilities to computer on a subscription basis e.g. via a web service . For example one interactive design capability that may be provided in a subscription may include providing support to enable computer to perform model projections from one domain environment to another domain environment .

The input device may include logic configured to receive information for system from e.g. a user. Embodiments of input device may include keyboards touch sensitive displays biometric sensing devices computer mice trackballs pen based point devices etc. The output device may comprise logic configured to output information from system . Embodiments of output device may include cathode ray tubes CRTs plasma displays light emitting diode LED displays liquid crystal displays LCDs printers vacuum florescent displays VFDs surface conduction electron emitter displays SEDs field emission displays FEDs etc.

Network interface may comprise logic configured to interface computer system with network and enable computer system to exchange information with other entities connected to the network such as for example service provider target environment and cluster . Network interface may be implemented as a built in network adapter network interface card NIC Personal Computer Memory Card International Association PCMCIA network card card bus network adapter wireless network adapter Universal Serial Bus USB network adapter modem or any other device suitable for interfacing computer system to any type of network.

It should be noted that embodiments of the invention maybe implemented using some combination of hardware and or software. It should be further noted that a computer readable medium that comprises computer executable instructions for execution in a processor may be configured to store embodiments of the invention. The computer readable medium may include volatile memories non volatile memories flash memories removable discs non removable discs and so on. In addition it should be noted that various electromagnetic signals such as wireless signals electrical signals carried over a wire optical signals carried over optical fiber and the like may be encoded to carry computer executable instructions and or computer data that embodiments of the invention on e.g. a communication network.

The foregoing description of example embodiments of the invention provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention.

