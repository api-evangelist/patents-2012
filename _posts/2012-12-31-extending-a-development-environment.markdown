---

title: Extending a development environment
abstract: Concepts and technologies are described herein for extending the behavior of a software development tool. An extension can be accessed and consumed by a software development tool to configure the software development tool to perform an operation in an extended mode. In one example, an extension can extend a compiler based on the input source code. In one configuration, the compiler extension can provide a compiler with one or more runtime semantics of various source code elements for a particular programming language. The compiler can access an extensions list to determine if the compiler is to perform a compilation operation on a particular source code element or logical unit in an extended mode.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954939&OS=08954939&RS=08954939
owner: Microsoft Corporation
number: 08954939
owner_city: Redmond
owner_country: US
publication_date: 20121231
---
To develop a software application for performing a computing task a software developer typically writes source code for the software application that outlines the functionality of the software application. There are various types of languages available to the developer depending on the particular use of the software application the computing environment in which the software application will be executed and or personal preferences of the software developer. For example the language can be a statically typed programming language in which the variable types are determined typically at compile time. In another example the language can be a dynamically typed programming language that determines variable types at runtime.

Once the software developer writes the source code if the environment in which the source code is to be executed requires executable code the source code is compiled into executable code or can be interpreted at execution time depending on the system environment using a compiler. A compiler is used to convert the source code into machine code that is directly executable on the computer system. The computing environment executes the executable code to implement the functionality of the source code. Along with compiling source code into executable code conventional compilers can also help the software developer by outputting debug information. The software developer can use the debug information to fix potential problems in the source code that may lead to faults when executing the executable code during runtime.

Concepts and technologies are described herein for extending a development environment. An extension can be consumed by a development tool to modify the behavior of the development tool for delineated source code elements. In some embodiments the development tool can consume an extension to use extended behavior in various processes including but not limited to preprocessing lexical analysis syntactic analysis static analysis instruction scheduling code generation linkage assembly interpreting and JIT compiling. For example when extending the behavior of a compiler an extension can be consumed by the compiler during various stages of the compilation process including but not limited to syntactic analysis semantic analysis code generation and code optimization. In a configuration when used within a compiler development environment a compiler extension can provide a compiler with one or more runtime semantics of various source code elements for a particular programming language. In some configurations an extension can be used in various programming operations such as but not limited to static analyzers interpreters compilers linkers assemblers and emulators.

It should be appreciated that the above described subject matter may be implemented as a computer controlled apparatus a computer process a computing system or as an article of manufacture such as a computer readable storage medium. These and various other features will be apparent from a reading of the following Detailed Description and a review of the associated drawings.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended that this Summary be used to limit the scope of the claimed subject matter. Furthermore the claimed subject matter is not limited to implementations that solve any or all disadvantages noted in any part of this disclosure.

The following detailed description is directed to extending the behavior of a software development tool. In various configurations a software development tool is provided with an extension. The software development tool consumes the extension. The extension changes the behavior of the software development tool for delineated operations from a default mode to an extended mode. In some examples a software development tool can be used in extended mode for various reasons examples of which are described in more detail below.

While the subject matter described herein is presented in the general context of program modules that execute in conjunction with the execution of an operating system and application programs on a computer system those skilled in the art will recognize that other implementations may be performed in combination with other types of program modules. Generally program modules include routines programs components data structures and other types of structures that perform particular tasks or implement particular abstract data types. Moreover those skilled in the art will appreciate that the subject matter described herein may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics minicomputers mainframe computers and the like.

In the following detailed description references are made to the accompanying drawings that form a part hereof and in which are shown by way of illustration specific embodiments or examples. Referring now to the drawings in which like numerals represent like elements throughout the several figures aspects of a computing system computer readable storage medium and computer implemented methodologies for extending a source code development environment and other aspects will be presented.

Referring now to aspects of a source code development environment for the various embodiments presented herein will be described. The source code development environment shown in includes a computing device . In some embodiments the computing device can include a desktop computer a laptop computer a notebook computer an ultra portable computer a netbook computer or other type of computing device. An operating system is executing on the computing device . The operating system is an executable program for controlling various functions at the computing device .

The computing device can execute a software development tool . The software development tool can include programs or tools such as but not limited to static analyzers interpreters compilers linkers assemblers and emulators. The software development tool can receive an input file that includes source code expressed in a programming language. The software development tool can receive a command or instruction to perform various development operations on the source code in the input file .

It should be appreciated that the concepts and technologies described herein are not limited to any particular type of programming language. For example the source code programming file type in the input file can be expressed using a statically typed programming language a dynamically typed programming language or other types. Examples of statically typed programming languages include but are not limited to C Fortran Java and Pascal. Examples of dynamically typed programming languages include but are not limited to JavaScript Perl Lisp and VBScript. Other types include strong and weak types safe and unsafe types intersection types union types duck typing and dependent types. It should be appreciated that the concepts and technologies described herein are not limited to any specific type. It should also be appreciated that the concepts and technologies described herein are not limited to a programming language that is one specific type as some programming languages may be used as or may be considered to be various types.

In some configurations the development operation may be an operation on the source code in the input file that does not produce an output. In other configurations the development operation may generate an output illustrated in as a development tool output . For example if the software development tool is a compiler and the operation is code generation the development tool output can include one or more output logical units expressed in executable code. As used herein a logical unit includes a group of code blocks or statements that together form a logical cohesive whole. A logical unit can be a source code element or can include one or more source code elements to form a logical cohesive whole. The development tool output may also include but is not limited to a viewable message a query a rewrite of one of more components of the input file etc. The concepts and technologies described herein are not limited to any particular output.

In some instances the software development tool may not be configured or have the capability to understand the behavior of a source code element in the input file upon which the software development tool is performing a development operation. As used herein a source code element includes but is not limited to a definition or a use of a function class method variable macro template procedure closure type the source code file itself or referenced libraries. There may be various reasons why the software development tool may not recognize or understand the behavior of the source code element.

For example the software development tool may not understand the behavior of a source code element if the behavior of the element will be decided during runtime. The logical unit can include a function that the software development tool is not configured to recognize. In other instances the software development tool may be configured to perform an operation on a source code element that is insecure outdated or otherwise undesirable. In other instances the source code element or the logical unit can include a misspelling that prevents recognition by the software development tool . In a further example in a compiler environment the compiler may not understand the actual runtime semantics of various functions during compile time. It should be appreciated that these and other examples are merely exemplary. The concepts and technologies described herein are not limited to any specific limitation fault or undesired behavior of the software development tool .

To modify the behavior of the software development tool the software development tool may be configured to access and consume an extension that extends or modifies the behavior of the software development tool when performing various development operations. The software development tool operating in extended mode is illustrated in as a software development tool extended A. As used herein to extend means the software development tool consumes the extension to expand increase and or alter the capabilities of the source development tool . By extending the capabilities of the software development tool the software development tool can be configured to for example and not by way of limitation perform an operation it was not previously capable of performing. In other configurations the software development tool can be extended to the software development tool extended A to perform a modified operation on a source code element instead of performing a default operation in a non extended mode. In some examples the software development tool A can be extended to the software development tool extended A to perform an operation in extended mode in addition to an operation in a default or non extended mode. For example the extended mode may include additional operations on a source code element not performed in a default mode.

In some configurations the compiler may include an internal library which in some configurations can be a collection of programs or executable code that can be consumed by the compiler to perform various compilation operations. In some configurations the compiler can access a third party library such as an external library . In some configurations the external library can be a collection of programs or executable code not included in the internal library or the source code of the compiler that can be consumed by the compiler to perform various compilation operations. As used herein a library includes code in binary form that can be consumed by a software development tool such as the compiler . The internal library and the external library are illustrated in as a single library for illustrative purposes only and does not reflect an intent to limit the present disclosure to a single library. The internal library or the external library can include functions macros class templates depending on the particular compiler and executable code and other units of program code that can be consumed from the source program.

As describe above to handle certain compile time operations the compiler can have programming in its code may access the internal library and or may access the external library . For example the compiler can receive an instruction to perform a semantic analysis on Program Segment I 

In some configurations the compiler can perform the semantic analysis on Program Segment I using components of the compiler . In other configurations the compiler can access the internal library or the external library or both when compiling Program Segment I .

Although a conventional compiler may be able to perform a semantic analysis or other compile time operation on Program Segment I errors may occur during runtime due to various compile time conditions. If the behavior of a source code element is decided during runtime in a dynamically typed programming language an error can occur if the characteristics of the source code are not described statically during compile time. As an example the following JavaScript code includes a function called DefineNamespace which may be provided by various libraries including the internal library and or the external library 

The name Utilities.File will typically not be designated until runtime at which time DefineNamespace is executed. A compiler performing semantic analysis on the code set forth above may not know whether or not this code executes properly at runtime. To reduce the probability that an error may be introduced by functions that conventionally pass compile time analysis requirements but during runtime cause a program to run incorrectly the compiler can access extensions A N that can provide the compiler with runtime semantics of various logical units so the compiler can understand the logical units during compile time hereinafter the extensions A N are referred to collectively and or generically as extension . In various configurations providing the compiler with runtime semantics can help the compiler validate parameters associated with a logical unit.

The extension can be created by and or provided to the compiler from various sources. For example the extension can be part of a software development kit supplied to developers for a particular operating environment. In another example the extension can be generated by one or more developers for use by other developers. In another example a developer can author the extension on top of the internal library the external library or other third party libraries. In a further example the extension can be part of the internal library and or the external library .

The compiler can consume the extension during compile time to perform compilation operations on source code elements and or logical units. In the first example above the compiler can be configured to detect that the printf function is a function to be treated according to the extension . In that configuration the compiler can consume the extension to perform a compilation operation in extended mode rather than consuming an executable in the internal library to perform the compilation operation in a default or non extended mode. In the second example above by consuming the extension the compiler can be configured to understand the DefineNamespace function behavior during runtime and mimic or simulate the behavior during compile time by in one example creating an appropriate object.

The extension may also provide the compiler with the ability to recognize certain errors in the source code that may cause an error during runtime or may prevent a compilation operation from being completed. For example if a developer writes source code for the function DefineNamespace but does so in an erroneous way the compiler can consume the extension to create various objects and determine that the function would generate errors when executed. For example a developer may write a code segment in which the word open is misspelled to be oopen 

The compiler can consume the extension to perform a successful semantic analysis on the code segment above. For example the compiler can consume the extension to perform an operation in extended mode by populating a symbol table with one or more results of statically processing the code segment above. After creating the one or more results of the static processing the compiler can detect that the second line may cause a runtime error due to the misspelling of open . In this example if the compilation operation is a code generation operation the compiler can behave in extended mode after consuming the extension and generate operable executable code. Without operating in an extended mode the compiler may generate inoperable code in the non extended mode using default behavior. Some further examples are provided hereinbelow.

Traditionally static analysis has been associated with static languages. For example consider the following C code 

In the example above the compiler can flag semantic issues the name XomeFunction does not exist and aNumber is being assigned a string technically a pointer to an array of characters . The reason conventional C compilers can do this is because C is a static language. In a static language the names and types of all language constructs are known during compile time. Even for static languages certain checks usually cannot be performed until runtime even if the names and types for all elements are known during compile time. For instance consider the following C function 

This function is considered static. The function itself all its parameters and their types and its return type are all known during compile time. However certain class of errors can still happen during runtime. Consider the following examples of a consumer of the code above 

Both calls to the create date function above are considered valid the function exists the number of arguments is correct the types of the arguments are correct the supplied values are within the expected range for the types and the expected return type by the consumer matches the one declared by the function. However only one of these dates is valid. Constructing date1 is going to work but date2 is not. The behavior of the create date function for date2 depends on how the function is implemented. For example a runtime exception could be thrown a special instance of date t that signifies an error could be returned and or a valid instance of date t that contains invalid data could be created.

As shown above there are certain classes of checks that are traditionally performed during runtime even for static languages. Testing software can be error prone and expensive. Ideally as many errors as possible should be caught during compile time or build time. If the create date function is built in the compiler or part of the language s standard library then the compiler can perform checks raising an error for date2 above. The standard library is a set of pre built libraries that ship with the compiler. Therefore the compiler can be programmed to know about it.

However if the create date function above is not part of the standard library then the compiler cannot perform any checks specific to that function. If a development team wants to perform checks specific to that function additional tools would have to be written or consumed for such purpose. These tools could operate on source code object code debug symbol files or a combination of the aforementioned. These tools could be standalone binaries rules written for a semantic analyzer tools such as FxCop Lint etc. others or a combination of the aforementioned. But these tools can have several drawbacks. For example they may need to be opted in i.e. the developer will need to turn on the tool rule etc. for each compilation location in their code base . Since they are not part of the compiler they can fall out of sync with it e.g. these tools can break if a new version of the compiler changes the layout of object file for example . In other instances they often need to duplicate functionality in the compiler e.g. parsing semantic analysis etc. in order to provide meaningful analysis.

To extend the behavior and or functionality of the compiler a plug in model can be implemented. In the example above consider that the imported declaration of the create date function is changed to look like the following 

In the example above date.dll is a library that contains one or more plug ins to the compiler i.e. compiler extensions . Specifically it can include a plug in that would extend the semantic analysis of the compiler as follows 

By running the extension i.e. plug in that is associated with the semantic analysis of calls to create date the compiler can perform checks that would otherwise not have been possible during compile time.

In some configurations for the semantic analysis phase this can have the following advantages over the external tools mentioned above. The check can be relatively cheap the cost of tool chaining other programs constructing models etc. is spared. The check can be performed by the compiler there s no need to opt in it s going to be there whenever the compiler is used. There s no duplicate functionality with the compiler . And the extension is not out of sync with the compiler .

In the example above the C language syntax has been augmented with keywords that can be used to specify the extension . Alternative implementations include but are not limited to the file containing the extensions needs to be declared explicitly using language syntax external files mapping source elements to extensions well formatted comments in the source code source code annotations source attributes and others. Other examples include but are not limited to the compiler can look for a DLL with the same file prefix as the file that contains the reference e.g. for date.h date.c or date.obj the compiler would look for date.dll the compiler could look for a script with the same base name e.g. date.lua or date.js a type library e.g. COM registered in the system where the type library is specified a type library e.g. COM registered in the system where the type library is implicit and the extensions could be located in the same unit as the reference eg date.h date.c or date.obj . It should be understood that the concepts and technologies described herein are not limited to the implementations described above.

Continuing with the example above the full path to the DLL has not been specified. Alternative implementations include but are not limited to the extension path could be explicit the extension path could be implicit where the compiler could search the current working directory the source file directory a predefined directory a predefined system folder the extension path could be implicit with the search path explicitly provided by the user vis vis a command line option with a list of directories to be searched in order or an in source list of directories to be searched e.g. by using pragma directives or the extension path could be a global setting in the system such as the system registry or an environment variable. A further implementation may be to acquire the extension dynamically across a network via and or via a web service. The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

In the example above a separate DLL with binary code has been provided for the extension . Alternative implementations include but are not limited to scripting languages such as JavaScript Lua etc. can be used the extension can be the function itself written as part of the source program or the extension can be a comment in the source program. The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

In the example above the name of the entry point in the extension DLL has not been provided. Alternative implementations include but are not limited to functions with the same name as the reference construct where overloads are used to disambiguate different extensions for the same construct functions with the same name as the reference construct where name affixes are used to disambiguate different extensions for the same construct the explicit name of the entry point needs to be provided the offset in a v table of the extension function or the exported index of an exported function. The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

In the example above the implicit name matching is case sensitive. Alternative implementations include but are not limited to case sensitive case insensitive or specific capitalization rules e.g. for affixes etc. . The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

In the example above the compiler behavior has been extended for function calls during the semantic analysis. Alternative source constructs that can be extended during semantic analysis include but are not limited to calls to overloaded operators function references type instantiation variable reference variable assignment or pointer dereference. The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

The example above raises errors for specific values passed to the function. Other actions available to the extension include but are not limited to adding modifying or deleting symbols in the symbol table operating on the syntax tree of the input document raising errors and warnings changing the suppression state of errors and warnings creating modifying and deleting source elements such as types enums constant values macros or namespaces or performing file operations. The concepts and technologies are not limited to the implementations explicitly described herein as other implementations may be used and are considered to be within the scope of the present disclosure.

The example above shows an extension that is provided with a library. This is not the only way to author and distribute extensions. Other ways to author and distribute extensions include but are not limited to extensions for libraries that are distributed alongside the libraries themselves such standard library extensions that are distributed with the compiler extensions developed by a different vendor than the library for the standard library or extensions developed by the consumer of a library to enforce specific usage defined by the team architect or to help migrate to a new version of the library.

The example above does not show the license for extensions. Some licenses include but are not limited to same license as the library license to use the library conditional to license to use the extension an open source license a closed source but free to use license or a proprietary paid for license. The example above also does not show the compiler behavior if the extension is not found or has an error. Some approaches include but are not limited to raise an error raise a warning log the failure and proceed log the failure and abort do nothing and ignore the failure provide in source directives for specifying what to do or provide mechanisms for specifying what to do alongside the extension declaration.

The example above shows how extensions can be used by a compiler of a static language. Extensions can used for dynamic languages as well. Consider the following JavaScript example 

In the example above a call to a library function WinJS.Namespace.define will create the name Utilities.File.open. In a dynamic type language the name creation does not happen until runtime. Statically the example above does not contain the name Utilities.File.open. Utilities.File is merely a string being passed to a function. Traditionally since programs written in dynamic languages such as JavaScript can create and delete names during runtime as in the example above static analyzers for such languages are not be able to raise issues regarding non existing names. Extensions can be used to increase the quality of semantic analysis of dynamic programs. In the example above an extension can be provided to the WinJS.Namespace.define function which can perform the following steps check the first parameter if it is not a string exit extension parse the string parameter and or create all the necessary symbols if they do not exist

By running the extension described above on calls to WinJS.Namespace.define a static analyzer can have knowledge of the names to be created during runtime. The semantic analyzer described above would then be able to flag violations. For instance consider the following program similar to the previous one but with a typo 

A semantic analyzer can be configured to flag the typo since the requested name oopen cannot be found in the symbol table. The compiler can be triggered to access the extension when compiling the source code in the input file using various mechanisms. For example the compiler can be configured to check for the extension when performing a compilation operation on each logical unit of the source code in the input file . In another configuration the compiler can be configured to access the extension based on a compile time instruction set including an extension input that designates the logical units to be extended. For example the compiler can be instructed at compile time to process only specified or pre determined logical units with the extension . The pre determined logical units or source code elements to be treated according to the extension can be stored in a list accessible to the compiler . It should be appreciated that other logical units or source code elements may be treated using the extension . The concepts and technologies disclosed herein are not limited to any particular element or logical unit.

Other triggers for retrieving and consuming the extension can include but are not limited to the association of the extension with the appearance of any identifier such as foo . In conventional JS runtimes for example some keywords that were previously legal might no longer be legal as they have been reserved for use in the language . The concepts and technologies described herein can implement an algorithm for consistently rewriting these identifiers so that they are consistent no longer collide with reserved keywords. Another trigger may be that the extension has been associated with a call site to a specific function or routine. On encountering a call site that resolves to a specific uniquely identified symbol a function a properly a specific variable invoke the extension. The extension might alter rewrite or even remove the call site. Or it might simply examine the call site in order to create some in memory information that can itself be used for further diagnostics code emit etc. The namespace construction example falls into this scenario. For this the call site to the API that produces an in memory class at runtime may not be modified in any way. Instead symbols can be created for the types members that would be produced at runtime so that subsequent references to them can be verified in code.

Another trigger may be to associate the extension with the construction of a specific class. For example on any occurrence of new Foo the extension is invoked. This implementation may also be used to drop in a replacement class or to halt compilation due to attempt to take a dependency on a forbidden type. A further trigger may be to associate the extension with a reference to a specific library binary external reference. For example if a program links to an obsoleted version of a library v that is insecure various configurations of the extension can alter compilation to force this program to link to an updated more secure version. In one example the extension for a logical unit can force a reference to a logical unit to a reference to a functional equivalent. A still further trigger may be to associate the extension with an abstract syntax tree node kind An additional configuration may be to associate the extension with a lexical token kind.

The compiler can also be configured to retrieve and consume the extension for source code elements or logical units that are not explicitly designated but rather are implicitly designated. For example the compiler can be configured to consume the extension for logical units or source code elements having the same name as other logical units or source code elements in the source code. In another example the compiler can be configured to consume the extension for logical units or source code elements that have the same spelling but disregard any differences in capitalization. In another example the extension can be provided for logical units or source code elements having commonly misspelled names. In that example the compiler can be configured to consume the extension corresponding to the misspelled logical units or source code element. The extension may be configured to correct the misspelling. In another configuration the extension may be associated with every type that implements a specific interface. In a further configuration the extension may be associated with all types that extend a specific base type.

The compiler can be configured to determine if the compiler is to operate in extended mode for a particular logical unit of the logical units . It should be understood that the compiler can be configured to check for an extension using various trigger mechanisms such as those described herein. For example the compiler can determine if the extension is to be consumed for a development operation by checking an extensions file for the extension looking for the extension by computing an extension file name based on a name or identifier associated with an input inspecting a metadata inlined with compilation units looking for a DLL with a same file prefix as a file that contains a reference and looking for a script with a same base name. The compiler can receive an instruction to perform a compilation operation on the input file A and the input file B. In response to receiving the instruction the compiler can execute a compilation operation on the logical units .

In one configuration the compiler can execute a compilation operation on the logical units to create executable code code generation in the development tool output illustrated in as logical units A N hereinafter referred to collectively and or generically as logical units . It should be appreciated that the logical units in the development tool output may include logical units that do not directly correspond in a 1 1 relationship to the logical units in the input file. For example during a code generation compilation operation the logical units may be generated from one or more of the logical units or may be generated by the compiler as a logical unit unrelated to any particular logical unit of the logical units .

The compiler can be configured to detect that a logical unit D is to be compiled by consuming the extension . As described above the extension can be consumed during various compilation operations such as but not limited to syntactic analysis semantic analysis optimization and code generation. In the configuration illustrated in the compiler can commence a code generation operation on the logical unit D. The compiler consumes the extension code generation A of the extension to perform a code generation operation on the logical unit D in an extended mode. The compiler can generate an output logical unit which is illustrated as logical unit extended D in the logical units of the development tool output . It should be understood that the designation of extended for the logical unit extended B means that the logical unit was generated using an extended compiler mode after the compiler consumes the extension code generation A.

If performing another compiler operation the compiler may be configured to use other extensions based on the operation. For example extension semantics B can be consumed by the compiler during a semantic analysis operation for the logical unit D. In another example extension optimization C can be consumed by the compiler during an optimization operation for the logical unit D. In a further example extension syntax D can be consumed by the compiler during a syntactic analysis operation for the logical unit D.

It should be appreciated that the concepts and technologies described herein are not limited to any specific operation of the compiler . It should further be understood that it is not necessary to consume an extension for all logical units or source code elements in a source code file. For example an extension might be consumed by the compiler for an element of the source code such as logical unit D for certain compilation operations and not consumed in other compilation operations. Further as described above it should be appreciated that the compiler can be configured to consume extensions for source code elements or logical units other than functions. For example and not by way of limitation the compiler can be configured to consume an extension for functions classes methods or variables or other elements. The concepts and technologies disclosed herein are not limited to the execution of an extension of any particular logical unit or source code element.

Various embodiments of the concepts and technologies described herein can give a developer certain degree of flexibility with regard to writing source code. Some examples are described above. An additional example of an implementation of the concepts and technologies described herein is the transformation of a legacy programming language or legacy version into an updated version of the programming language a different programming language or an updated version of a consumed library. As used herein legacy means source code or a programming language that has been replaced with another source code or programming language. For example legacy source code can be a version of source code that predates a currently used version of source code. In another example legacy source code can be source code in a programming language that predates a currently used programming language. In a further example an input can be source code targeting a legacy version of a library or a system where the output can be a computer program that can operate on a new version of the library or the system.

In the configuration illustrated in if the compiler uses the external library during a code generation operation the logical units that are generated when the code generation operation is complete may not function properly or as desired in the new environment. This may occur for various reasons. For example the logical units may include a logical unit that is not used in the environment that executes the executable code in the development tool output which can include legacy code. In another example the logical units may include a function with variables that are no longer used in the environment that executes the development tool output .

To provide the developer with the capability to update the logical units when the compiler compiles the logical units the extension can include a extension legacy E. The extension legacy E can be consumed by the compiler to extend the behavior of the compiler . In one configuration the extension legacy E can be consumed by the compiler during a code generation operation to generate code written in a first version of a programming language to a second version of the programming language. For example the legacy extension E can be consumed by the compiler to generate executable code for logical unit extended B of logical units A N hereinafter referred to collectively and or generically as logical units which can include source code logical units compatible with the new environment. It should be understood that the use of the term legacy associated with the extension legacy E means in this configuration that the extension is an active or currently used extension associated with a legacy version of a library source code element environment etc.

Turning now to aspects for extending a software development tool are provided according to an illustrative embodiment. It should be understood that the operations of the methods disclosed herein are not necessarily presented in any particular order and that performance of some or all of the operations in an alternative order s is possible and is contemplated. The operations have been presented in the demonstrated order for ease of description and illustration. Operations may be added omitted and or performed simultaneously without departing from the scope of the appended claims.

It also should be understood that the illustrated methods can be ended at any time and need not be performed in its entirety. Some or all operations of the methods and or substantially equivalent operations can be performed by execution of computer readable instructions included on a computer storage media as defined herein. The term computer readable instructions and variants thereof as used in the description and claims is used expansively herein to include routines applications application modules program modules programs components data structures algorithms and the like. Computer readable instructions can be implemented on various system configurations including single processor or multiprocessor systems minicomputers mainframe computers personal computers hand held computing devices microprocessor based programmable consumer electronics combinations thereof and the like.

Thus it should be appreciated that the logical operations described herein are implemented 1 as a sequence of computer implemented acts or program modules running on a computing system and or 2 as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly the logical operations described herein are referred to variously as states operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. The operations of the methods are described herein below as being implemented at least in part by the software development tool the compiler the internal library the external library the extension or combinations thereof.

Turning to the method begins at operation and proceeds to operation where the software development tool receives an instruction to perform a development operation. As described above a development operation can include but is not limited to preprocessing lexical analysis syntactic analysis static analysis instruction scheduling code generation linkage assembly interpreting emulating and JIT compiling.

From operation the method proceeds to operation where the software development tool determines if an extension is available for the operation. As described above the operation can be various operations on various source code elements or logical units. For example the software development tool can receive an instruction to generate code for a particular logical unit. The software development tool can determine if an extension is available for generating code for the particular logical unit. If no extension is available for the operation the method proceeds to operation where the software development tool performs the operation in a default or non extended mode. The method then ends at operation .

If an extension is available for the operation the method proceeds to operation where the software development tool accesses the extension . The extension may be accessible to the software development tool from various sources. For example the extension may be a separate file that includes executable code provided by a third party developer. In another example the extension may be loaded into the internal library of the software development tool .

From operation the method proceeds to operation where the software development tool consumes the extension . By consuming the extension the software development tool is configured to perform the operation in an extended mode rather than a default or any other mode. It should be understood that the extension is not limited to operations that are performed on a source code element or logical unit. For example the extension may configure the software development tool to perform an operation on the external library the internal library or the software development tool . The concepts and technologies described herein are not limited to operations on input files.

From operation the method proceeds to operation where the software development tool performs the operation in the extended mode. The extended mode for the software development tool extended A can be initiated or abated depending on the particular configuration of the software development tool . For example a developer may want the software development tool to operate in a default mode during one period of time and operate in an extended mode A in other periods of time. For example a system may experience security issues when a program calls certain application programming interfaces. The extension may be made available for consumption by the software development tool to cause the software development tool to generate code that causes the program to call a secure API. When the security issue is finalized the software development tool can be reprogrammed to generate the necessary code. Thus in this example the extension is temporary. The method then ends at operation .

The computer architecture illustrated in includes a central processing unit CPU a system memory including a random access memory RAM and a read only memory ROM and a system bus that couples the memory to the CPU . A basic input output system containing the basic routines that help to transfer information between elements within the computer architecture such as during startup is stored in the ROM . The computer architecture further includes a mass storage device for storing the operating system from and one or more application programs or files including but not limited to the software development tool the internal library and the extension .

The mass storage device is connected to the CPU through a mass storage controller not shown connected to the bus . The mass storage device and its associated computer readable media provide non volatile storage for the computer architecture . Although the description of computer readable media contained herein refers to a mass storage device such as a hard disk or CD ROM drive it should be appreciated by those skilled in the art that computer readable media can be any available computer storage media or communication media that can be accessed by the computer architecture .

Communication media includes computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any delivery media. The term modulated data signal means a signal that has one or more of its characteristics changed or set in a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer readable media.

By way of example and not limitation computer storage media may include volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. For example computer media includes but is not limited to RAM ROM EPROM EEPROM flash memory or other solid state memory technology CD ROM digital versatile disks DVD HD DVD BLU RAY or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium that can be used to store the desired information and which can be accessed by the computer architecture . For purposes of the claims the phrase computer storage medium and variations thereof does not include waves or signals per se and or communication media.

According to various embodiments the computer architecture may operate in a networked environment using logical connections to remote computers through a network such as the network . The computer architecture may connect to the network through a network interface unit connected to the bus . It should be appreciated that the network interface unit also may be utilized to connect to other types of networks and remote computer systems. The computer architecture also may include an input output controller for receiving and processing input from a number of other devices including a keyboard mouse or electronic stylus. Similarly the input output controller may provide an output to a display screen a printer or other type of output device.

It should be appreciated that the software components described herein may when loaded into the CPU and executed transform the CPU and the overall computer architecture from a general purpose computing system into a special purpose computing system customized to facilitate the functionality presented herein. The CPU may be constructed from any number of transistors or other discrete circuit elements which may individually or collectively assume any number of states. More specifically the CPU may operate as a finite state machine in response to executable instructions contained within the software modules disclosed herein. These computer executable instructions may transform the CPU by specifying how the CPU transitions between states thereby transforming the transistors or other discrete hardware elements constituting the CPU .

Encoding the software modules presented herein also may transform the physical structure of the computer readable media presented herein. The specific transformation of physical structure may depend on various factors in different implementations of this description. Examples of such factors may include but are not limited to the technology used to implement the computer readable media whether the computer readable media is characterized as primary or secondary storage and the like. For example if the computer readable media is implemented as semiconductor based memory the software disclosed herein may be encoded on the computer readable media by transforming the physical state of the semiconductor memory. For example the software may transform the state of transistors capacitors or other discrete circuit elements constituting the semiconductor memory. The software also may transform the physical state of such components in order to store data thereupon.

As another example the computer readable media disclosed herein may be implemented using magnetic or optical technology. In such implementations the software presented herein may transform the physical state of magnetic or optical media when the software is encoded therein. These transformations may include altering the magnetic characteristics of particular locations within given magnetic media. These transformations also may include altering the physical features or characteristics of particular locations within given optical media to change the optical characteristics of those locations. Other transformations of physical media are possible without departing from the scope and spirit of the present description with the foregoing examples provided only to facilitate this description.

In light of the above it should be appreciated that many types of physical transformations take place in the computer architecture in order to store and execute the software components presented herein. It also should be appreciated that the computer architecture may include other types of computing devices including hand held computers embedded computer systems personal digital assistants and other types of computing devices known to those skilled in the art. It is also contemplated that the computer architecture may not include all of the components shown in may include other components that are not explicitly shown in or may utilize an architecture that is different in some manner than that shown in .

Based on the foregoing it should be appreciated that concepts and technologies for extending the behavior of a software development tool have been disclosed herein. Although the subject matter presented herein has been described in language specific to computer structural features methodological and transformative acts specific computing machinery and computer readable media it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features acts or media described herein. Rather the specific features acts and mediums are disclosed as example forms of implementing the claims.

The subject matter described above is provided by way of illustration only and should not be construed as limiting. Various modifications and changes may be made to the subject matter described herein without following the example embodiments and applications illustrated and described and without departing from the true spirit and scope of the present invention which is set forth in the following claims.

