---

title: Optimization of resource usage in a multi-environment computing system
abstract: A method and apparatus for modifying resource usage by a computing system including a first environment and a second environment is disclosed. A status signal is received and applications executed by the first environment and by the second environment are monitored. The status signal may indicate whether the computing system is coupled to an external device. It is determined whether a first application is executed by the first environment and by the second environment. Responsive to determining the first application is executed by the first environment and by the second environment, an amount of resources allocated to the first application by each of the environments is calculated. Based on the first amount of resources allocated by the different environments, execution of the first application by the first environment or by the second environment is halted.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09396041&OS=09396041&RS=09396041
owner: Google Technology Holdings LLC
number: 09396041
owner_city: Mountain View
owner_country: US
publication_date: 20120201
---
The present disclosure relates generally to mobile device systems and more particularly to optimizing resource usage by a mobile device system including multiple environments.

Computing devices use operating systems to manage physical resources applications and perform additional functions. Typically operating systems are designed and optimized based on specific applications and user desired performance. Additionally operating systems may also be customized to improve the performance of a specific hardware configuration or configurations. While different operating systems may operate better with different types of computing devices it is desirable to have applications used by one operating system accessible to a different operating system.

Operating systems such as LINUX or WINDOWS configured for use by general purpose computing devices also referred to as a general purpose operating systems have an extensive set of features such as file systems device drivers applications libraries etc. General purpose operating systems allow concurrent execution of multiple programs and attempt to optimize the response time also referred to as latency time and or processor usage or load associated with the concurrently executing programs. However operating systems configured for use by general purpose computing devices are typically unsuitable for embedded real time applications such as use in mobile computing devices such as smartphones or tablet computers. In certain circumstances however it is desirable for a mobile computing device to combine the performance associated with a mobile computing device specific embedded operating system and one or more features of a general purpose operating system.

For example LINUX is a commonly used general purpose operating system with many features that would also benefit mobile computing devices. However LINUX was not designed to be used as an embedded or real time operating system for use by mobile computing devices. Currently many devices such as set top boxes mobile phones and car navigation systems require features of a general purpose operating system such as LINUX as well as features of an embedded or real time operating system including real time performance.

Given that general purpose operating systems offer certain benefits while embedded operating system offer other benefits particularly when used by certain types of devices such as mobile computing devices implementing multiple operating systems on a single device allows a device to take advantage of benefits from different types of operating systems. Conventional methods for running multiple operating systems on a single device rely on virtualization techniques. However because virtualization emulates a complete computing device the emulated computing device implements and operates one or more software stacks. Additionally emulation of a computing device introduces significant overhead making conventional virtualization techniques impractical for certain types of devices such as mobile devices.

Additionally certain applications or services may be operable by multiple operating systems. In conventional approaches an application or service may be concurrently executing in different operating systems increasing the resources used by the application which may impair overall performance For example executing the same application in multiple operating systems decreases the memory available for other applications.

Skilled artisans will appreciate that elements in the figures are illustrated for simplicity and clarity and have not necessarily been drawn to scale. For example the dimensions of some of the elements in the figures may be exaggerated relative to other elements to help to improve understanding of embodiments of the present invention.

The apparatus and method components have been represented where appropriate by conventional symbols in the drawings showing only those specific details that are pertinent to understanding the embodiments of the present invention so as not to obscure the disclosure with details that will be readily apparent to those of ordinary skill in the art having the benefit of the description herein.

A method for modifying resource usage by a computing system including a first environment and a second environment is disclosed herein. A status signal is received and applications executed by the first environment and by the second environment are monitored. For example the status signal indicates whether the computing system is coupled to an external device such as a dock. It is determined whether a first application is executed by both the first environment and the second environment. Responsive to determining the first application is executed by the first environment and by the second environment a first amount of resources allocated to the first application by the first environment is calculated and a second amount of resources allocated to the first application by the second environment is calculated. Based on the first amount of resources and the second amount of resources execution of the first application by the first environment or by the second environment is halted. The first application continues to be executed by the other environment. In one embodiment the first application is halted from being executed by the first environment responsive to the first amount of resources exceeding the second amount of resources. Alternatively the first amount of resources and the second amount of resources are displayed and execution of the first application by the first environment is halted responsive to receiving a selection of the first amount of resources.

In the following description for purposes of explanation numerous specific details are set forth to provide a thorough understanding of the invention. However it will be apparent to one skilled in the art that the invention can be practiced without these specific details. In other instances structures and devices are shown in block diagram form in order to avoid obscuring the invention.

The host user component includes a first environment and a second environment . Both the first environment and the second environment communicate with the host kernel . Hence a single host kernel is used by the first environment and the second environment . In the example shown by the first environment communicates with the host kernel via communication link and the second environment communicates with the host kernel via communication link . In one embodiment the host kernel is a LINUX kernel the first environment is an embedded environment such as an environment used by mobile devices while the second environment is a general purpose operating system. For example the host kernel is a LINUX kernel the first environment is an ANDROID environment and the second environment is a GNU Linux environment. However in other embodiments the first environment and the second environment may be any suitable operating environment. Either real time or non real time environments or operating systems may be employed by the first environment or the second environment . While shows an embodiment including a first environment and a second environment in other embodiments a greater number of operating environments may be included in the host user component thus more than two environments may operate and coexist independently of each other using a single host kernel as further described below. Additionally the first environment and the second environment communicate with each other via communication link .

In one embodiment the first environment and the second environment operate and coexist independently of each other. In certain embodiments the first environment and the second environment are interdependent in at least some aspects of operation. For example the first environment and the second environment interact with the host kernel and compete for resources of the host kernel . As another example the first environment and the second environment communicate data with each other using communication link so the first environment and the second environment may operate in conjunction with one another for at least some operations or actions. The host kernel allocates resources of the mobile computing system by connecting and managing interaction between the device hardware and the first middleware and or the second middleware .

However for purposes of explanation the first environment and the second environment are considered independent in that each of the environments is capable of operating by itself if the other environment is not present or is not operational. For example the first environment may operate if the second environment is not present. As another example one of the environments is operationally independent before the other environment is implemented using the host kernel . In some embodiments the first environment and the second environment are independent in that each of the environments is a different type of environment serving different operations and functions performed via the host kernel the device hardware and other components such as users or additional devices. For example the first environment implements functions or operations commonly associated with an embedded operating system such as an operating system used by a mobile computing device while the second environment implements functions or operations commonly associated with a general purpose operating system such as an operating system used by a desktop or laptop computer.

In the embodiment shown by the first middleware includes a first application framework and a first runtime environment . However in other embodiments the first middleware may include different and or additional components such as a radio interface module a global positioning system GPS module or any other suitable component. The first environment applications are managed by the first application framework and interpreted by the first runtime environment . For example the first runtime environment includes an interpreter that translates an application from the first environment applications during run time of the application.

In an embodiment where the first environment is an ANDROID environment the first runtime environment is a Dalvik register based virtual machine VM that communicates with Dalvik libraries and or tools in addition to additional components such as the host kernel . The Dalvik libraries and or tools are implemented on top of the host kernel and implement functionality sufficient to execute the Dalvik register based VM. In one embodiment the Dalvik libraries are a subset of libraries supported by a GNU Linux based operating system and provide functionality optimized for implementation in mobile computing devices. This allows development of applications for execution by devices subject to more resource constraints than a desktop or laptop computer. A register based virtual machine such as the Dalvik register based VM is easier to optimize on a particular device hardware configuration than a virtual machine using a stack based architecture e.g. a virtual machine based on JAVA . Further an environment using a Dalvik or similar implementation replicates a complete middleware layer rather than merely replicating a byte code interpreter such as a virtual machine. Additionally a Dalvik based or similar implementation allows developers to design first environment applications using a familiar syntax such as a JAVA syntax. Thus in an embodiment where the first environment includes first environment applications prepared in Dalvik or a similar configuration the first environment applications are byte code interpreted applications.

In one embodiment the second environment includes second environment applications and second middleware which communicates with the second environment applications . In the embodiment shown by the second middleware includes a second application framework and a second environment libraries and or tools module . The second environment libraries and or tools module includes libraries for displaying data using a graphical user interface GUI and or additional libraries or tools. However in other embodiments the second middleware may include different and or additional components such as a desktop environment a multimedia framework component a window manager component or any other suitable component.

In one embodiment the second environment applications include one or more native applications that are comprised of instructions corresponding to the instruction set architecture of the host kernel or the device hardware . One or more of the second environment applications include a stack and or additional components separate from other second environment applications . The second environment applications are managed by the second application framework and may use data and or instructions from the second environment libraries and or tools module and or other components included in the second middleware . An application included in the second environment applications comprises instructions that are recognizable by the second middleware which operates in conjunction with a processor to execute the instructions to provide one or more functions. For example if the second environment is a GNU Linux environment the second environment applications may be native applications using the instruction set of the host kernel which may be implemented using GNU Linux.

The first middleware and the second middleware are logically positioned between the first environment applications and the second environment applications respectively. The first middleware and the second middleware orchestrate interaction between the device hardware and the first environment applications and the second environment applications respectively.

In the example shown by the second environment includes a plurality of logical memory partitions while the first environment comprises a single memory partition as well as system components. Further in one embodiment the second environment and the host kernel share a common instruction set. For example the second environment is a UBUNTU stack or a similar LINUX stack. In an embodiment where the second environment comprises a UBUNTU stack the host kernel may also be implemented using UBUNTU . However in additional embodiments the second environment may alternatively comprise a different type of LINUX environment a SYMBAIN environment a WINDOWS environment or another other suitable operating environment. For example the second environment may be a WINDOWS environment and the host kernel is also implemented using WINDOWS . However in other embodiments the second environment may comprise a single memory partition. Additionally one or more additional environments may be included and may support one or multiple memory partitions. In additional embodiments greater than two environments having a variety of different configurations independently coexist using the same host kernel .

In the embodiment shown by the device hardware comprises a processor and a display device however in other embodiments the device hardware includes different and or additional components. In one embodiment the device hardware includes a computer readable storage medium coupled to the processor . The computer readable storage medium includes instructions that when executed by the processor execute one or more functions. Additionally the device hardware may include a communication device such as a transceiver for wireless communication and or a port for wired communication. In other embodiments the device hardware includes an audio output device one or more input devices and or any other suitable components.

The processor processes data or instructions and may comprise various computing architectures. For example the processor may process data or instructions using a complex instruction set computer CISC architecture a reduced instruction set computer RISC architecture an architecture implementing a combination of instruction sets or any other suitable instruction set. Although shows a single processor in other embodiments the mobile computing system may include multiple processors. The processor transmits processes and or retrieves data from the first environment and or from the second environment and or from additional components.

The display device is a device displaying electronic images and or data. For example the display device comprises an organic light emitting diode display OLED a liquid crystal display LCD or any other device such as a monitor. In one embodiment the display device includes a touch sensitive transparent panel for receiving data or allowing other interaction with the images and or data displayed by the display device .

Also shows components included in the second environment in addition to those components further described above in conjunction with . In the embodiment shown by the second environment includes a window manager a first environment viewer a resource manager and a second environment services module in addition to the second environment applications . In one embodiment one or more of the second environment services module the window manager the first environment viewer and the resource manager are included in the second middleware further described above in conjunction with . In another embodiment the first environment viewer is included in the second environment applications .

The first environment viewer displays a window including data and or an application from the first environment on an interface displayed on a display device when the second environment is the primary environment. For example the first environment viewer displays a window showing one or more applications executed by the first environment in a graphical user interface displayed when the second environment is the primary environment. This allows a user to view and interact with the first environment via the displayed window while the second environment is the primary environment.

The first environment event module communicates with the first environment viewer and receives coordinate events keyboard events or other events received by the first environment viewer . The received invents are communicated by the first environment event module to an event hub. For example the first environment event module receives absolute coordinate and or keyboard events from the first environment viewer . In one embodiment the event hub communicates the received events to the first environment or to one or more first environment applications .

The window manager comprises instructions that when executed by the processor display data from the first environment and or the second environment using the display device . The window manager generates one or more windows in which data and or an application is displayed. Additionally the window manager receives input from a user to modify the size shape or location of a window displayed using the display device . For example the window manager receives input from a user to resize a window such as an input repositioning a border of the window to increase or decrease the size of the displayed window.

The first environment application manager comprises one or more instructions that when executed by the processor identify applications and or services executed by the first environment . In one embodiment the first environment application manager also determines the amount of resources used by the applications and or services executed by the first environment . For example the first environment application manager includes application identifiers associated with applications executed by the first environment and associates an amount of resources used by the application corresponding to an application identifier. Examples of resource usage that is measured include memory or processor time.

In one embodiment the first environment application manager also communicates with the host kernel drivers and receives data indicating whether the mobile computing system is coupled to an external device via the device hardware . For example the first environment application manager receives data from the host kernel drivers and generates a status signal indicating whether the mobile computing system is coupled to a dock or another external device. In one embodiment the first environment application manager receives data from the host kernel drivers and analyzes the received data to generate the status signal. For example the status signal has a first value responsive to the device hardware being coupled to a dock and a second value responsive to the device hardware not being coupled to a dock.

The portal services module comprises one or more instructions that when executed by a processor enable one or more services for the first environment and or manage communication with the resource manager included in the second environment . In an embodiment where the first environment is executed by a mobile computing device the portal services module is executed while the mobile computing device is operating. The portal services module is also coupled to the portal activity module and also receives broadcast events associated with the first environment .

The portal activity module comprises computer readable instructions that when executed by the processor represent one or more applications included in the second environment . For example if the second environment is a UBUNTU environment the portal activity module represents a specific UBUNTU application. When the portal activity module is accessed the application included in the second environment is displayed on a display device allowing the application included in the second environment to be viewed and or accessed from the first environment .

Generally multiple applications in an environment are capable of executing simultaneously in what is commonly referred to as a stack of executing applications. As discussed herein the topmost application in a stack is deemed to have focus. Where multiple applications are available for access by a user the application currently receiving input commands or data from a user is considered to be the application having focus. For example if multiple windows corresponding to different applications are displayed on a display device the application associated with the window currently receiving input from the user is the application having focus. In an embodiment the second environment enables display of multiple applications at a given time while the first environment enables display of a single application at a time. For example the second environment allows multiple windows associated with different applications to be displayed at one time while the first environment allows display of a single window associated with an application at one time. However in alternative embodiments the first environment and the second environment display different numbers of applications at a given time.

As further described above in conjunction with the first environment and the second environment communicate with each other and also communicate with a single host kernel . In one embodiment as described above in conjunction with the first environment includes a Dalvik register based virtual machine replicating a complete middleware layer rather than merely replicating a byte code interpreter creating a possibility of conflict in the operation of the first middleware and the second middleware allocating resources through the host kernel without appropriate steps. To avoid potential conflicts in resource allocation by the host kernel the resource manager included in the second environment communicates directly with the portal services module included in the first environment and vice versa.

The resource manager included in the second environment comprises instructions that when executed by the processor manage resources shared by the first environment and the second environment . For example the resource manager manages use of resources such as the display device one or more input devices a power supply additional output devices and other suitable resources by the first environment and the second environment . Further the resource manager maintains state information associated with the mobile computing system . The resource manager also controls access to the device hardware by the first environment and the second environment . For example the resource manager identifies and or modifies whether a user interface associated with the first environment or with the second environment is displayed using the display device .

In the embodiment shown by the resource manager includes a docking manager which comprises instructions that when executed by the processor determines whether the mobile computing system is coupled to dock or to another external device. For example the docking manager receives a status signal from the first environment application manager and analyzes the status signal to determine whether the mobile computing system is coupled to an external device. In one embodiment the status signal is a binary value having a first value when the mobile computing system is coupled to an external device and having a second value when the mobile computing system is not coupled to an external device. Alternatively the status signal has multiple values associated with different external devices and the docking manager compares a value of the status signal to stored values to identify the external device to which the mobile computing system is coupled.

Responsive to the docking manager receiving a status signal from the first environment application manager indicating the mobile computing system is coupled to a dock the resource manager monitors applications executed by the first environment and by the second environment . The resource manager determines whether a first application is being executed by both the first environment and by the second environment . For example the resource manager determines whether an application identifier or application name is identified as being executed by the first environment and by the second environment . If the resource manager determines that the first application is being executed by both the first environment and by the second environment the resource manager determines the amount of resources allocated to the first application by the second environment and communicates with the first environment application manager to determine the amount of resources allocated to the first application by the first environment . For example the resource manager determines an amount of memory allocated to the first application by the first environment and an amount of memory allocated to the first application by the second environment .

In one embodiment the resource manager compares the amount of resources allocated to the first application by the first environment to the amount of resources allocated to the first application by the second environment and halts execution of the first application by the environment that allocates the largest amount of resources to the first application. For example if the first environment allocates more resources to the first application than the second environment the resource manager halts execution of the first application by the first environment while continuing execution of the first application by the second environment . Alternatively the resource manager generates a message identifying the resources allocated to the first application by the different environments and receives an input selecting the environment to halt execution of the first application. For example responsive to a selection of the second environment the resource manager halts execution of the first application by the second environment .

When the resource manager halts execution of the first application in an environment the resource manager also transfers data and or context associated with the first application from the environment in which execution of the first application is halted to the environment in which execution of the first application continues. For example if a web browser is halted in the first environment form data and or uniform resource indicators URIs currently used by the web browser in the first environment are transferred to the web browser executed in the second environment . As an additional example if a video viewing application is halted in the second environment the video being viewed and the current location within the video is transferred to the video viewing application executing in the first environment . This allows users to preserve data when the environment in which an application is changed while also conserving resources by executing an application in a single environment.

In one embodiment the portal services module receives data for communication from the first environment to the resource manager included in the second environment . Further the portal services module receives data from the resource manager that is communicated to the first environment from the second environment . In one embodiment the resource manager also includes a status discoverable application programming interface API to the portal services module . The status discoverable API may be called by the resource manager at anytime. Additionally the resource manager obtains and processes run time status to maintain a state machine. In one embodiment for the first environment the portal services module provides run time status to processes. Similarly the portal services module requests and receives status updates from processes that provide status information. In one embodiment the portal services module is included in the first runtime environment .

The resource manager provides run time status to processes in the second environment requesting and or requiring run time status. In one embodiment the host kernel drivers communicate with the resource manager as well as processes providing run time status information. For example the status discoverable API of the resource manager arbitrates access to user interface devices such as the display device a touch screen a graphical user interface or a similar user interface device. As another example the status discoverable API arbitrates access to power supplies such as a battery or another power source.

As discussed above in conjunction with the first environment and the second environment are independent form each other and co exist with respect to each other. Each of the first environment and the second environment is a fully functioning environment that does not rely upon the other environment to function. Unlike conventional configurations the first environment and the second environment do not co exist in a virtualization or emulation scheme. Rather the first environment and the second environment both operate on a single shared host kernel . The first environment and the second environment have run time coexistence in which both the first environment and the second environment are run as stand alone native environments. Neither the first environment nor the second environment is recompiled as a common run time environment such as a C run time environment is not leveraged for both environments. Because of the first environment and the second environment a user is capable of accessing an application that is configured for operation on one of the environments without interrupting an interaction with another environment.

In the embodiment shown by first environment processes and first environment libraries access a Bionic C library which is optimized and modified for the first environment . In one embodiment the first environment libraries and the Bionic C library are included in the first runtime environment . Also in the embodiment shown by second environment processes and second environment libraries communicate with a GNU C library . In one embodiment the second environment libraries and the GNU C library are included in the second environment libraries and or tools module . Thus the first environment and the second environment each operate using its respective C library without conflicting with the library used by the other environment .

The method includes environment specific steps and steps performed by different environments. However the boot sequence may be modified based on rules associated with a predetermined device state of the mobile computing system dictating the booting sequence. For example if the mobile computing system is coupled to a peripheral device such as a monitor the mobile computing system operates in a second mode where the second environment is the default primary environment. Alternatively if the mobile computing system is not coupled to a peripheral device the mobile computing system operates in a first mode where the first environment is the default primary environment.

While one of the first environment or the second environment acts as a primary environment both environments are launched simultaneously or nearly simultaneously. Additionally once the first environment and the second environment are launched and one of the environments serves as the primary environment the secondary environment operates in the background relative to the primary environment in case the state changes and the secondary environment becomes the primary environment. For example when the mobile computing system is in the second mode and the peripheral is unplugged there is an automatic transition to the first mode resulting in the secondary environment becoming the primary environment and vice versa.

In the embodiment shown by the host kernel is initialized . For example a bootloader program is launched or initialized. After initialization the host kernel launches initialization scripts and launches the resource manager . After launching the resource manager the mode state is identified and a reference library is accessed to determine criteria associated with the identified mode or criteria dictated by the identified mode.

Services common to the first environment and the second environment are then launched and the identified mode state is determined . Responsive to determining that a first mode is identified initialization scripts associated with the first environment are launched and then initialization scripts associated with the second environment are launched . Hence in the first mode the first environment operates as the primary environment while the second environment operates as the secondary environment.

Responsive to determining that a second mode is identified initialization scripts associated with the second environment are launched then initialization scripts associated with the first environment are launched . Thus in the second mode the second environment operates as the primary environment while the first environment operates as the secondary environment.

However regardless of which environment is the primary environment both the first environment and the second environment are launched and become operational before the mobile computing system is operational. Further because services common to the first environment and the second environment are launched prior to the environment specific initialization scripts the primary and secondary environments are essentially launched in parallel. However primary environment specific services are launched before services specific to the secondary environment. By separating launching of common services from environment specific initialization scripts the mobile computing system is able to quickly become operational with multiple co existing and independent environments. While both the primary environment and secondary environment are executing when the mobile computing system is operational the secondary environment operates in the background relative to the primary environment. Either the first environment or the second environment may be the primary environment additionally the primary environment may be switched to the secondary environment automatically or responsive to user commands.

In the embodiment shown by a docking manager included in a resource manager executing in the second environment receives a status signal from the first environment application manager and analyzes the status signal to determine whether the mobile computing system is coupled to an external device. In one embodiment the status signal is a binary value having a first value when the mobile computing system is coupled to an external device and having a second value when the mobile computing system is not coupled to an external device. Alternatively the status signal has multiple values associated with different external devices and the docking manager compares a value of the status signal to stored values to identify the external device to which the mobile computing system is coupled.

Responsive to the docking manager receiving a status signal from the first environment application manager indicating the mobile computing system is coupled to a dock the resource manager monitors applications executed by the first environment and by the second environment . The resource manager determines applications being executed by the second environment and the resources used by execution of the applications being executed by the second environment . Also the resource manager exchanges data with the first environment application manager to determine applications being executed by the first environment and the resources used by execution of the applications being executed by the first environment .

The resource manager determines whether a first application is being executed by both the first environment and by the second environment . For example the resource manager determines whether an application identifier or application name is identified as being executed by the first environment and by the second environment . Responsive to determining the first application is not executed by both the first environment and the second environment the resource manager continues to monitor the applications and or services executed by the first environment and by the second environment . However responsive to determining the first application is being executed by both the first environment and by the second environment the resource manager calculates the amount of resources allocated to the first application by the second environment and communicates with the first environment application manager to calculate the amount of resources allocated to the first application by the first environment . For example the resource manager calculates an amount of memory allocated to the first application by the first environment and an amount of memory allocated to the first application by the second environment .

Responsive to the first application being executed by both the first environment and by the second environment the resource manager halts execution of the first application by either the first environment or by the second environment based on resource usage by the different environments. In one embodiment the resource manager compares the amount of resources allocated to the first application by the first environment to the amount of resources allocated to the first application by the second environment and halts execution of the first application by the environment allocating the largest amount of resources to the first application. For example if the first environment allocates more resources to the first application than the second environment the resource manager halts execution of the first application by the first environment while continuing execution of the first application by the second environment . Alternatively the resource manager generates a message identifying the resources allocated to the first application by the different environments and receives an input selecting the environment to halt execution of the first application. For example responsive to a selection of the second environment the resource manager halts execution of the first application by the second environment .

When the resource manager halts execution of the first application in an environment the resource manager also transfers data and or context associated with the first application from the environment in which execution of the first application is halted to the environment in which execution of the first application continues. For example if a web browser is halted in the first environment form data and or uniform resource indicators URIs currently used by the web browser in the first environment are transferred to the web browser executed in the second environment . As an additional example if a video viewing application is halted in the second environment the video being viewed and the current location within the video is transferred to the video viewing application executing in the first environment . This allows users to preserve data when the environment in which an application is changed while also conserving resources by executing an application in a single environment.

The benefits advantages solutions to problems and any element s that may cause any benefit advantage or solution to occur or become more pronounced are not to be construed as a critical required or essential features or elements of any or all the claims. The invention is defined solely by the appended claims including any amendments made during the pendency of this application and all equivalents of those claims as issued.

Moreover in this document relational terms such as first and second top and bottom and the like may be used solely to distinguish one entity or action from another entity or action without necessarily requiring or implying any actual such relationship or order between such entities or actions. The terms comprises comprising has having includes including contains containing or any other variation thereof are intended to cover a non exclusive inclusion such that a process method article or apparatus that comprises has includes contains a list of elements does not include only those elements but may include other elements not expressly listed or inherent to such process method article or apparatus. An element proceeded by comprises . . . a ha . . . a includes . . . a or contains . . . a does not without more constraints preclude the existence of additional identical elements in the process method article or apparatus that comprises has includes contains the element. The terms a and an are defined as one or more unless explicitly stated otherwise herein. The terms substantially essentially approximately about or any other version thereof are defined as being close to as understood by one of ordinary skill in the art and in one non limiting embodiment the term is defined to be within 10 in another embodiment within 5 in another embodiment within 1 and in another embodiment within 0.5 . The term coupled as used herein is defined as connected although not necessarily directly and not necessarily mechanically. A device or structure that is configured in a certain way is configured in at least that way but may also be configured in ways that are not listed.

It will be appreciated that some embodiments may be comprised of one or more generic or specialized processors or processing devices such as microprocessors digital signal processors customized processors and field programmable gate arrays FPGAs and unique stored program instructions including both software and firmware that control the one or more processors to implement in conjunction with certain non processor circuits some most or all of the functions of the method and or apparatus described herein. Alternatively some or all functions could be implemented by a state machine that has no stored program instructions or in one or more application specific integrated circuits ASICs in which each function or some combinations of certain of the functions are implemented as custom logic. In some embodiments a combination of the two approaches may be used.

Moreover an embodiment can be implemented as a computer readable storage medium having computer readable code stored thereon for programming a computer e.g. comprising a processor to perform a method as described and claimed herein. Examples of such computer readable storage mediums include but are not limited to a hard disk a CD ROM an optical storage device a magnetic storage device a ROM Read Only Memory a PROM Programmable Read Only Memory an EPROM Erasable Programmable Read Only Memory an EEPROM Electrically Erasable Programmable Read Only Memory and a Flash memory. Further it is expected that one of ordinary skill notwithstanding possibly significant effort and many design choices motivated by for example available time current technology and economic considerations when guided by the concepts and principles disclosed herein will be readily capable of generating such software instructions programs and or integrated circuits with minimal experimentation.

The Abstract of the Disclosure is provided to allow the reader to quickly ascertain the nature of the technical disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. In addition in the foregoing Detailed Description it can be seen that various features are grouped together in various embodiments for the purpose of streamlining the disclosure. This method of disclosure is not to be interpreted as reflecting an intention that the claimed embodiments require more features than are expressly recited in each claim. Rather as the following claims reflect inventive subject matter lies in less than all features of a single disclosed embodiment. Thus the following claims are hereby incorporated into the Detailed Description with each claim standing on its own as a separately claimed subject matter.

