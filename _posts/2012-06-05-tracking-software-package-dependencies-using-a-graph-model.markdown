---

title: Tracking software package dependencies using a graph model
abstract: Methods and systems for generating a graph model associated with a software release. The methods and systems are configured to receive a software release including a set of software packages. The software release is parsed to identify modeling information including package information, package dependency information, and function dependency information associated with each software package in the set of software packages. A graph model is generated and stored which represents the modeling information, wherein the graph model comprises a package node for each software package in the set of software packages and a function node for each function in the set of software packages.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09235410&OS=09235410&RS=09235410
owner: Red Hat, Inc.
number: 09235410
owner_city: Raleigh
owner_country: US
publication_date: 20120605
---
Embodiments of the present invention relate to a computing system and more specifically relate to a system and method for managing and tracking software package dependencies.

Typical software installation and maintenance involves the import and integration of new software releases including multiple inter dependent software packages into an existing system. To facilitate the integration of a software release it is important for a developer or administrator to understand and identify the dependencies among the multiple software packages and the potential impact the software packages of the new release will have on the underlying system. When a new software release is introduced determining the underlying software dependencies is important to detect and identify potential incompatibilities with existing Application Programming Interfaces APIs or an Application Binary Interfaces ABIs collectively referred to as API ABI breakages across release cycles.

Conventional package managers are configured to determine software dependencies and incompatibilities relating to new software releases by reviewing the source code of the software release maintained in files in a directory. However the review of the source code is time intensive and inefficient.

Furthermore conventional systems utilize a relational database model or plain text files to store software package dependency information. In such systems the system is forced to make recursive calls in the relational database model or plain text files in order to retrieve information about the package dependencies and identify changes in package dependencies across multiple software releases.

Moreover typical software dependency monitoring is conducted at the package level e.g. for each package release . In this regard conventional methods fail to provide an efficient means for the retrieval of information relating to software package dependencies to enable a developer to understand the impact of software changes to an existing system.

Methods and systems for generating a graph model associated with a software release including multiple software packages received from a package source. The generated graph model is a graphical representation of modeling information derived from a review e.g. a parsing of the software release. In an embodiment the modeling information includes package information e.g. information relating to and or identifying a package package properties etc. and function information e.g. information relating to and or identifying a function function properties etc. for each of the packages in the software release. A package may include a piece of software which may be installed on a computing system such as a collection of files relating to a software upgrade. A function may be any operation action step process or task performed by a software package.

The modeling information also includes the dependency information determined based on a review of the software release. The dependency information includes the identification of any relationship associated with a software package also referred to as a package dependency or package dependencies . For example a package dependency may represent a relationship between multiple software packages e.g. a depends relationship between Package A and Package B and or a relationship between a software package and a function e.g. a provides relationship between Package A and Function X .

In an embodiment the dependency information includes the identification of relationships between multiple functions in the software release also referred to as a function dependency or function dependencies . For example a function dependency may be identified which represents a depends relationship between Function X and Function Y.

The graph model includes a node for each software package identified in the software release also referred to as a package node and a node for each function identified in the software release also referred to as a function node . A package node may include the package properties associated with the package represented by the node e.g. a package name identifier a version number a release number etc. . A function node may include the function properties associated with the function represented by the node e.g. a function name identifier a function type etc. .

In an embodiment the package nodes and function nodes of the graph model that have a relationship with one another are connected in accordance with the identified dependency information. In an embodiment the relationships or connections between the nodes of the graph model may be graphically represented by indicators e.g. lines or arrows including information defining the type of relationship e.g. a label indicating a depends relationship or a provides relationship . Advantageously the graph model associated with a software release may be stored searched reviewed and or analyzed in order to enable a user or appropriate searching algorithm to identify and or track the package information and dependency information.

In an embodiment graph models relating to multiple software releases e.g. a first release and a second release may be generated and stored. The multiple graph models may then be compared to one another in order to identify and or track any changes and or differences between the multiple software releases. Advantageously the multiple graph models may be traversed or reviewed in order to efficiently identify and or track the delta between the multiple software releases. The comparison of the multiple graph models and identification of any changes enables the system to identify and or track any potential Application Programming Interface API breakages and or Application Binary Interface ABI breakages. In this regard the graph models may be employed to track monitor and manage software package dependencies and API ABI breakages across software release cycles.

In an embodiment the methods and systems provide a tool for use by a user e.g. a developer or system administrator to retrieve dependency information associated with a software release and consider the potential impact a software change between the two releases may have on the operation of the underlying system. Furthermore the representation of a software release and its associated packages and functions as nodes in a graph model enables the performance of fast and efficient searching of the graph to identify and or track dependency information.

In an embodiment the graph model generator is a software component or application e.g. a set of instructions residing in memory executable by a processing device e.g. processor configured to generate a graph model e.g. graph model A and graph model B including modeling information for each of software releases e.g. software release A software release B received from the one or more package sources .

In an embodiment the graph model generator may be hosted by a computing device e.g. a server a desktop computer a portable digital assistant a mobile phone a laptop computer a portable media player a tablet computer a netbook a notebook or a personal computer.

The graph model generator is configured to store the generated graph model in a graph model data store . The graph model data store may be any suitable memory or data storage location including a non transitory computer readable storage medium such as but not limited to any type of database disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions. According to embodiments of the present invention the graph model data store may reside in any suitable location accessible by the graph model generator including for example in a network or cloud environment as illustrated by dashed cloud representation in .

In an embodiment the computing device executing the graph model generator may include a user interface configured to allow a user e.g. a developer access to the graph model generator and the one or more graph models stored in the graph model data store . In an embodiment the user may access the graph model generator using a user device not shown via a network not shown such as for example a public network such as the Internet a private network such as a local area network LAN or a virtual private network VPN . The user device may be employed by a user to access the user interface associated with the graph model generator to retrieve and review graph models stored in the graph model data store .

In an embodiment the processor and memory may be the local processing device and memory of the graph model generator . In another embodiment the graph model generator may be installed on a computing device e.g. user device from any suitable non transitory computer readable storage medium or via network e.g. by a download . It is noted that any suitable arrangement may be employed such that the graph model generator may perform the functions described in detail below in connection with .

Referring to in one embodiment the method begins when a software release is received from a source in block . In an embodiment the software release includes multiple packages and dependency information e.g. information identifying the various relationships between the packages in the software release . According to embodiments of the present invention the software release may be in any suitable format and may be of any suitable type e.g. a RHEL release . The software release and associated packages may be imported from any suitable source s such as for example one or more SRPMs.

In block the software release is parsed in order to identify modeling information associated with the software release. According to embodiments of the present invention the modeling information derived via the parsing of the software release includes package information package dependencies and function dependencies associated with each of the multiple packages of the software release. The package information may include any information used to identify a package such as for example a package name identifier. The package dependencies include information identifying any relationship associated with a software package. For example a package dependency may represent a relationship between multiple software packages e.g. a depends relationship between Package A and Package B and or a relationship between a software package and a function e.g. a provides relationship between Package A and Function X . The function dependencies include information identifying relationships between multiple functions in the software release. For example a function dependency may be identified which represents a depends relationship between Function X and Function Y.

In block a graph model is generated which represents the modeling information. The graph model associated with the software release is stored in a data store e.g. graph model data store in in block . In an embodiment the graph model includes a node for each package e.g. a package node and a node for each function e.g. a function node of the software release. According to embodiments of the present invention the nodes e.g. package and function nodes may include properties relating to and or defining the underlying package or function represented by the node.

According to embodiments of the present invention the nodes of the graph model may be connected to each other by indicators representing the relationship between and among the nodes. For example the indicators may be lines or arrows including a label identifying the type of relationship as shown in the examples illustrated in . In one example a package nodes may be connected to another package node using an indicator e.g. an arrow denoting a depends relationship between the two package nodes. In another example a package node may be connected to a function node using an indicator denoting a provides relationship between the package node and the function node.

In the example shown an indicator e.g. an arrow represents a depends relationship between the libxml package node and the glibc package node. As shown the libxml package node includes a package identifier of libxml and has a version property with a value of 1.0 . As shown the glibc package node includes a package identifier of glibc and has a version property with a value of 2.6 . In the example shown in a provides relationship is shown between the glibc package node and the strcpy function node. As shown the strcpy function node has a function property of 0xd815d1bc .

Referring to in one embodiment the method begins with the generation of a first graph model associated with a first software release and a second graph model associated with a second software release in block . According to an embodiment of the present invention the first graph model and the second graph model may be generated in accordance with method described above with respect to .

In block the first graph model and the second graph model are compared in order to identify any changes in the new release e.g. the second release relative to the existing software e.g. the first release . In block the graph models are reviewed in accordance with an appropriate search algorithm to identify the one or more changes in the respective modeling information e.g. the package information the dependency information the package properties the function properties etc. . In an embodiment the search algorithms may be used to query the graph models for dependency information.

In an embodiment the graph model may be searched at the package node level also referred to as a breadth review the function node level also referred to as a depth review or in accordance with any other suitable searching algorithm scheme or approach.

According to an embodiment of the present invention in block A a breadth first search may be performed wherein the graph model is first reviewed at the package node level e.g. until all relevant package nodes have been reviewed followed by a depth review wherein the graph model is reviewed at the function node level. According to another embodiment of the present invention in block B a depth first search may be performed wherein the graph model is first reviewed at a function node level e.g. until all relevant function nodes have been reviewed followed by a breadth review wherein the graph model is reviewed at the package node level.

Advantageously the graph modeling approach according to embodiments of the present invention enables a user to perform a quick and efficient breadth first or depth first search of a graph model to determine the desired dependency information e.g. package dependencies and function dependencies . For example a developer may want to ensure that a particular dependency relationship that is required for proper operation of the system is in place in a second graph model. In this example the user may wish to confirm that the glibc package node is in a provides dependency relationship with a strcpy function node having an argument or value of 0xd815d1bc . To do so the user may perform a depth first search for the glibc package node in second graph model and review the dependencies associated with that package node.

In an embodiment a separate delta graph model may be generated which represents the changes between the first graph model and the second graph model. For example the delta graph model may provide a side by side comparison of the first graph model and the second graph model and highlight or otherwise graphically represent any changes to the modeling information in the second graph model as compared to the first graph model e.g. presenting any nodes or node information that is different in the second graph model with a graphical indicator to illustrate to a user that there has been a change .

In block based on the review and comparison of the two graph models one or more potential breakages e.g. incompatibilities may be identified such as for example potential API ABI breakages. According to an embodiment of the present invention one or more breakage policies may be maintained by the system and used to determine a potential impact of the one or more of the identified changes. For example if a change to a particular function in a second graph model is detected the system may refer to the breakage policies to determine if that change produces a breakage which violates or fails to comply with the one or more breakage policies. Advantageously a user e.g. a developer may submit a request for a comparison of two graph models and review any changes in the new software release would result in an API ABI breakage.

The exemplary computer system includes a processing device processor a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM a static memory e.g. flash memory static random access memory SRAM and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor or a processor implementing other instruction sets or processors implementing a combination of instruction sets. The processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The graph model generator in may comprise processing device configured to perform the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

A drive unit may include a computer readable medium on which is stored one or more sets of instructions e.g. instructions of the graph model generator embodying any one or more of the methodologies or functions described herein. The instructions of the graph model generator may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting computer readable media. The instructions of the graph model generator may further be transmitted or received over a network via the network interface device .

While the computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single non transitory medium or multiple non transitory media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories optical media and magnetic media.

In the above description numerous details are set forth. It will be apparent however to one of ordinary skill in the art having the benefit of this disclosure that embodiments of the invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the description.

Some portions of the detailed description are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the above discussion it is appreciated that throughout the description discussions utilizing terms such as receiving parsing generating storing identifying or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Embodiments of the invention also relate to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct a more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

