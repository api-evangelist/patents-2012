---

title: System and method for managing resources and threshsold events of a multicore portable computing device
abstract: A method and system for managing resources of a portable computing device is disclosed. The method includes receiving node structure data for forming a node, in which the node structure data includes a unique name assigned to each resource of the node. A node has at least one resource and it may have multiple resources. Each resource may be a hardware or software element. The system includes a framework manger which handles the communications between existing nodes within a node architecture. The framework manager also logs activity of each resource by using its unique name. The framework manager may send this logged activity to an output device, such as a printer or a display screen. The method and system may help reduce or eliminate a need for customized APIs when a new hardware or software element (or both) are added to a portable computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09098521&OS=09098521&RS=09098521
owner: QUALCOMM Incorporated
number: 09098521
owner_city: San Diego
owner_country: US
publication_date: 20120112
---
This application claims priority under 35 U.S.C. 120 and is a continuation in part of U.S. patent application Ser. No. 12 882 395 filed Sep. 15 2010 entitled SYSTEM AND METHOD FOR MANAGING RESOURCES OF A PORTABLE COMPUTING DEVICE the specification of which is incorporated herein in its entirety by reference. This patent application also claims priority under 35 U.S.C. 119 e to U.S. Provisional Patent Application Ser. No. 61 530 770 filed on Sep. 2 2011 entitled SYSTEM AND METHOD FOR MANAGING RESOURCES OF A PORTABLE COMPUTING DEVICE the entire contents of which are also hereby incorporated by reference.

Portable computing devices PCDs are becoming personal necessities for people on personal and professional levels. These devices may include cellular telephones portable digital assistants PDAs portable game consoles palmtop computers and other portable electronic devices. Each of these devices may include a primary function. For example a cellular telephone generally has the primary function of receiving and transmitting telephone calls.

In addition to the primary function of these devices many include peripheral functions. For example a cellular telephone may include the primary function of making cellular telephone calls as described above and the peripheral functions of a still camera a video camera global positioning system GPS navigation web browsing sending and receiving emails sending and receiving text messages push to talk capabilities etc. As the functionality of such a device increases the computing or processing power required to support such functionality also increases. Further as the computing power increases there exists a greater need to effectively manage the processor or processors that provide the computing power.

In the past as each peripheral function supported by hardware or software or both was introduced to a device such as a cellular telephone a specific application programming interface API was introduced for each peripheral function. For example there may be a separate API for the video camera and a separate API for the GPS navigation application software. Each API generally logged its actions independently and each API generally has its own data structure which would need to cross reference the existing hardware or software of the cellular telephone that was in existence prior to the introduction of the new peripheral function.

The introduction of separate APIs for each peripheral function is very cumbersome and time consuming because of the cross reference to different hardware and software elements. Each hardware or software element supporting the base functions of the cellular telephone may have been provided with a nomenclature established by the original equipment manufacturer OEM of the cellular telephone and or the OEM of the underlying electronic supporting the base functions of the cellular telephone. The logging and debugging of new features or functions associated with software or hardware or both has long been recognized by those of ordinary skill in this portable computing device art as a significant problem in providing new products or features or both .

What is needed is a system and method that may overcome the problems associated with introducing new features or functions supported by new software or hardware or both that are added to systems built by original equipment manufacturers OEMs .

A method and system for managing resources of a portable computing device are described and include receiving node structure data for forming a node the node structure data comprising a unique name for each resource that is part of the node. Next the node structure data may be reviewed for one or more dependencies. It is then determined if each resource associated with a dependency for an uninstantiated node exists within a node framework.

The method and system may also include determining if each resource of an uninstantiated node is available to support a request . If a resource of an uninstantiated node is unavailable to support any requests a value may be set to prevent instantiation of a node that includes the unavailable resource. An unavailable resource may include hardware that is pluggable and which can be removed from a PCD.

If a resource associated with a dependency does not exist altogether then the node structure data may be stored in a temporary storage. If each resource for each dependency within the node structure data exists and is available then the node with its one or more resources may be created or instantiated. If the node is created instantiated then the node may be published within the node framework using the one or more unique names corresponding node s one or more resources in a state ready for processing communications.

The method and system may further include determining if each resource of an instantiated node is available to support a request. If a resource of an instantiated node is unavailable to support any requests then the instantiated node may be locked from access by other resources.

The method and system may further include receiving data for forming a stub resource which functions as a placeholder in the node framework. After receiving the stub data the method and system may receive data for replacing a stub resource with a functional resource so that a node framework may be completed to include only functional nodes.

The method and system may further include determining if a client request managed within the node framework is suppressible for delayed execution in order to improve power and or performance. The method and system may further include determining if one or more conditions have been achieved for delaying execution for suppressible requests.

The method and system may further include receiving one or more threshold events for managing by a resource. Each threshold event may have at least one condition that is tracked by the resource.

The word exemplary is used herein to mean serving as an example instance or illustration. Any aspect described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects.

In this description the term application may also include files having executable content such as object code scripts byte code markup language files and patches. In addition an application referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

The term content may also include files having executable content such as object code scripts byte code markup language files and patches. In addition content referred to herein may also include files that are not executable in nature such as documents that may need to be opened or other data files that need to be accessed.

As used in this description the terms component database module system and the like are intended to refer to a computer related entity either hardware firmware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and the computing device may be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers. In addition these components may execute from various computer readable media having various data structures stored thereon. The components may communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

In this description the terms communication device wireless device wireless telephone wireless communication device and wireless handset are used interchangeably. With the advent of third generation 3G wireless technology and fourth generation 4G wireless technology greater bandwidth availability has enabled more portable computing devices with a greater variety of wireless capabilities. Therefore a portable computing device may be a cellular telephone a pager a PDA a smartphone a navigation device or a hand held computer with a wireless connection or link.

Referring initially to and an exemplary portable computing device PCD is shown and is generally designated . As shown the PCD may include a housing . The housing may include an upper housing portion and a lower housing portion . shows that the upper housing portion may include a display . In a particular aspect the display may be a touch screen display. The upper housing portion may also include a trackball input device . Further as shown in the upper housing portion may include a power on button and a power off button . As shown in the upper housing portion of the PCD may include a plurality of indicator lights and a speaker . Each indicator light may be a light emitting diode LED .

In a particular aspect as depicted in the upper housing portion is movable relative to the lower housing portion . Specifically the upper housing portion may be slidable relative to the lower housing portion . As shown in the lower housing portion may include a multi button keyboard . In a particular aspect the multi button keyboard may be a standard QWERTY keyboard. The multi button keyboard may be revealed when the upper housing portion is moved relative to the lower housing portion . further illustrates that the PCD may include a reset button on the lower housing portion .

Referring to an exemplary non limiting aspect of a portable computing device PCD is shown and is generally designated . As shown the PCD includes an on chip system that includes a multicore CPU . The multicore CPU may include a zeroth core a first core and an Nth core .

As illustrated in a display controller and a touch screen controller are coupled to the multicore CPU . In turn a touch screen display external to the on chip system is coupled to the display controller and the touch screen controller .

As further illustrated in a stereo audio CODEC may be coupled to the multicore CPU . Moreover an audio amplifier may coupled to the stereo audio CODEC . In an exemplary aspect a first stereo speaker and a second stereo speaker are coupled to the audio amplifier . shows that a microphone amplifier may be also coupled to the stereo audio CODEC . Additionally a microphone may be coupled to the microphone amplifier . In a particular aspect a frequency modulation FM radio tuner may be coupled to the stereo audio CODEC . Also an FM antenna is coupled to the FM radio tuner . Further stereo headphones may be coupled to the stereo audio CODEC .

As depicted in the touch screen display the video port the USB port the camera the first stereo speaker the second stereo speaker the microphone the FM antenna the stereo headphones the RF switch the RF antenna the keypad the mono headset the vibrator and the power supply are external to the on chip system .

In a particular aspect one or more of the method steps described herein may be stored in the memory as computer program instructions. These instructions may be executed by the multicore CPU in order to perform the methods described herein. Further the multicore CPU the memory or a combination thereof may serve as a means for executing one or more of the method steps described herein in order to sample data within a central processing unit .

Referring to a processing system is shown and is generally designated . In a particular aspect the processing system may be incorporated into the PCD described above in conjunction with . As shown the processing system may include a multicore central processing unit CPU and a memory connected to the multicore CPU . The multicore CPU may include a zeroth core a first core and an Nth core . The zeroth core may include a zeroth dynamic clock and voltage scaling DCVS algorithm executing thereon. The first core may include a first DCVS algorithm executing thereon. Further the Nth core may include an Nth DCVS algorithm executing thereon. In a particular aspect each DCVS algorithm may be independently executed on a respective core .

Moreover as illustrated the memory may include an operating system stored thereon. The operating system may include a bus arbiter or scheduler and the scheduler may include a first run queue a second run queue and an Nth run queue . The memory may also include a first application a second application and an Nth application stored thereon.

In a particular aspect the applications may send one or more tasks to the operating system to be processed at the cores within the multicore CPU . The tasks may be processed or executed as single tasks threads or a combination thereof. Further the scheduler may schedule the tasks threads or a combination thereof for execution within the multicore CPU . Additionally the scheduler may place the tasks threads or a combination thereof in the run queues . The cores may retrieve the tasks threads or a combination thereof from the run queues as instructed e.g. by the operating system for processing or execution of those task and threads at the cores .

In a particular aspect the framework manager may be a software program. However in an alternative aspect the framework manager may be a hardware controller that is external to the memory . In either case the framework manager the memory the cores or any combination thereof may serve as a means for executing one or more of the method steps described herein in order to sample data from the cores .

An example of a legacy software element may include but is not limited to a Dynamic Environment Manager DEM . This is a software module that handles interprocessor notification of processor sleep events. For example a first processor A uses the DEM to receive a notification that a second processor B has gone idle come back from idle. On newer hardware this software functionality has been subsumed into the route processor module RPM subsystem communication protocol. Other legacy software elements exist and are included within the scope of the invention.

An example of a legacy hardware element may include but is not limited to an AMBA Advanced Microcontroller Bus Architecture High performance Bus AHB . On older PCDs the AHB may comprise the primary system bus whereas on newer PCDs the system bus fabric is completely different and the AHB bus is only used for special applications to communicate with modules that have not yet been updated to communicate via the new system bus fabric. Other legacy hardware elements exist and are included within the scope of the invention.

The framework manager may comprise a library of computer instructions that manages data structures such as nodes described below which communicate with each of the aforementioned hardware and software elements. The framework manager may be responsible for creating one or more resources that may form nodes and as illustrated on the right side of the dashed line A of . The framework manager may comprise a library of code. Portions of the library may reside on each hardware element of the PCD .

Meanwhile each node and that is established and instantiated by the framework manager is a representation or model of each software or hardware element on the left hand side of the dashed line A of . For the remainder of this disclosure a general or non specific node will be designated with reference numeral as illustrated in .

As noted previously each exemplary node and of may comprise one or more resources. A resource may comprise a software element or hardware element or both. For example a first node comprises a single resource that generally corresponds with the first hardware element or central processing unit . With the inventive software architecture described in this disclosure each resource of a node may be provided with a unique name comprising one or more alphanumeric characters. In the exemplary embodiment illustrated in the resource of the first node has been assigned the resource name of core cpu. This exemplary resource name generally corresponds to conventional file naming structures known to one of ordinary skill in the art. However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alpha numeric characters and or symbols are well within the scope of the invention.

In the exemplary embodiment of the second node comprises a plurality of resources. Specifically in this particular exemplary embodiment the second node has a first resource comprising a single hardware element corresponding to the bus arbiter or scheduler . The second resource of the second node comprises a software element generally corresponding to the first software element of the bus program A A. The third resource of the second node comprises another software element generally corresponding to the second software element of the bus program B B. One of ordinary skill the art recognizes that any combination and any number of resources and resource types for a given node are well within the scope of the invention.

Other relationships displayed in include dependencies illustrated with dashed lines . Dependencies are relationships between respective resources of another node . A dependency relationship usually indicates that a first resource A is reliant upon a second resource B that may provide the first resource A with information. This information may be a result of an operation performed by a second resource B or it may simply comprise status information that is needed by the first resource A or any combination thereof. The first resource A and second resource B may be part of the same node or they may be part of different nodes .

In the first node is dependent upon the second node as indicated by the dependency arrow B which originates with the first node and extends to the second at . also illustrates that the first node is also dependent upon the third node as illustrated by the dependency arrow A. also illustrates that the second node is dependent upon the fourth node as illustrated by the dependency arrow C. One of ordinary skill in the art recognizes that the dependencies illustrated with the dashed arrows of are only exemplary in nature and that other combinations of dependencies between respective nodes are within the scope of the invention.

The architecture or framework manager is responsible for maintaining the relationships described above that include but are not limited to the client requests and the dependencies illustrated in . The framework manager will try to instantiate or create as many nodes as it can as long as the dependencies for any given node are complete. A dependency is complete when a resource which supports a dependency is in existence or is in a ready state for handling information that relates to the dependency .

For example the first node comprising the single resource core cpu may not be created or established by the framework manager if the third node comprising the single resource clk cpu has not been created because of the dependency relationship A that exist between the first node in the third node . Once the third node has been created by the framework manager then the framework manager may create the second node because of the dependency relationship A.

If the framework manager is unable to create or instantiate a particular node because one or more of its dependencies are incomplete the framework manager will continue running or executing steps corresponding to those nodes that were created successfully by the framework manager . The framework manger will usually skip over a call for a particular node which may not exist due to incomplete dependencies in which dependent resources have not been created and return messages to that call which reflect that incomplete status.

In a multicore environment such as illustrated in the framework manager may create or instantiate nodes on separate cores like the first second and Nth cores and of . Nodes may generally be created in a multicore environment on separate cores and in parallel as long as the nodes are not dependent on one another and if all of a particular node s corresponding dependencies as described below are complete.

Calls within the node architecture illustrated in may be made to an alias or an actual resource name of a resource within a node . For example the first node A has a dependency arrow A to indicate that the first node A is dependent upon the two resources resources and of the second node B. also illustrates how a client of the first node A may issue a client request to the first node A. After these client requests are issued the second node B may trigger an event or provide a response to a query in which messages corresponding to the event and the query flow back to the client .

For example the first node has a dependency arrow B to indicate that the first node is dependent upon the three resources of the second node . Similarly the third resource bus ahb sysB comprising the second software element B and generally designated with the reference letter C in has a dependency arrow C that indicates this third resource C is dependent upon the single clk sys ahb resource of the fourth node .

The query function is generally not externally identified and generally it does not have a state. The query function may be used to determine the state of a particular resource of a node . The query function and the events may have relationships with established clients and these relationships are represented by directional arrows to indicate that information from respective event and query function are passed to a particular client .

The node or resource graphs B of represent relationships that exist in memory such as memory of and which are managed by the framework manager and related data structures that may comprise the nodes . The node or resource graph B can be automatically generated by the framework manager as a useful tool for identifying relationships between respective elements managed by the framework manager and for troubleshooting by a software team.

Threshold events usually include one or more triggering conditions. In the example illustrated in the triggering conditions may comprise one or more temperatures that may be measured with the PCD . In the example of three threshold temperatures have been selected A eighty degrees Celsius which may represent a high thermal state for the PCD B sixty five degrees Celsius which may represent a nominal thermal state for the PCD and C fifty degrees Celsius which may represent a low thermal state for the PCD .

A first threshold event A has been created to track a thermal condition when the temperature is at fifty degrees Celsius or below. A second threshold event B has been created to track a thermal condition when the temperature is fifty degrees Celsius or below or when the temperature is eighty degrees Celsius or above. A third threshold event C has been created to track a thermal condition when the temperature is sixty five degrees Celsius or below. And a fourth threshold event D has been created to track a thermal condition when the temperature is fifty degrees Celsius or below or when sixty five degrees Celsius has been reached or when eighty degrees Celsius has been reached.

Each of these four different threshold events A B C D may be assigned to the same different or various combinations of resources of the PCD as will be described below in further detail in connection with . Any user of software architecture supported by the framework manager may set up a threshold event against a resource. A user of the software architecture that creates threshold events may include a resource author a node author a resource or a thread of execution. The resources assigned to a threshold event may be instructed to report the status of a threshold event to one or more different resources.

The first resource RESOURCE of has been assigned two temperature threshold events the first temperature threshold event A and second temperature threshold event B of . The first resource will transmit its threshold status to a single resource a fourth resource. The second resource RESOURCE of has been assigned two temperature threshold events the first temperature threshold event A and the third temperature threshold event C of . The second resource will report its threshold status to a single resource a fifth resource. And the third resource RESOURCE of has been assigned a single temperature threshold event the fourth threshold temperature event D of . The third resource will report its threshold status to two resources the fourth resource and a sixth resource.

The chart of illustrates the flexibility and scalability of how threshold events may be assigned to resources and how these events may be reported . The framework manager is responsible for monitoring and supporting the communications between the resources listed in chart . A method or process for creating threshold events will be described below in connection with . The method for creating threshold events may be executed after the method A for creating a software architecture and for managing resource s of a PCD has been executed.

Next in block the framework manager may review the dependency data that is part of the node structure data received in block . In decision block the framework manager may determine if the node structure data defines a leaf node . A leaf node generally means that the node to be created based on the node structure data does not have any dependencies. If the inquiry to decision block is positive meaning that the node structure data for creating the current node does not have any dependencies then the framework manager continues to routine block .

If the inquiry to decision block is negative then the No branch is followed to decision block in which the framework manager determines if all of the hard dependencies within the node structure data exist. A hard dependency may comprise one in which a resource cannot exist without. Meanwhile a soft dependency may comprise one in which a resource may use the dependent resource as an optional step. A soft dependency means that a node or resource of the node which has a soft dependency may be created or instantiated when the within the node architecture even when the soft dependency does not exist.

An example of a soft dependency may comprise an optimization feature that is not critical to the operation for a resource oriented node containing multiple resources. The framework manager may create or instantiate a node or a resource for all hard dependencies that are present and even when a soft is dependency is not present for those nodes or resources which have soft dependencies that are not created. A call back feature may be used to reference the soft dependency so that when the soft dependency becomes available to the framework manager the framework manager will inform each callback referencing the soft dependency that the soft dependencies are now available.

If the inquiry to decision block is negative then the No branch is followed to block in which the node structure data is stored by the framework manager in temporary storage such as memory. The framework manager creates a call back feature associated with this un instantiated node. Before block and after either the negative condition or positive condition for decision block an optional method C for managing un instantiated nodes that become unavailable may be executed. This optional method C has been illustrated with dashed lines in between block and block . Further details of optional method C will be described below in connection with .

If the inquiry to decision block is positive then the Yes branch is followed to routine in which a node is created or instantiated based on the node structure data received in routine block . Further details of routine block will be described below in connection with . Next in block the framework manager publishes the newly created node using its unique resource name s so that other nodes may send information to or receive information from the newly created node .

Referring now to which is a continuation flow chart of in block the framework manager notifies other nodes which are dependent on the newly created node that the newly created node has been instantiated and is ready to receive or transmit information.

According to one exemplary aspect notifications are triggered immediately when a dependent node like node B of is created i.e the notifications are performed recursively. So if node B of is constructed node A is immediately notified. This notification may allow node A to be constructed since node B was node A s final dependency . Construction of node B may causes other nodes to be notified and so on and so on. Node B does not get completed until the final resource dependent on node B is completed.

A second slightly more complex implementation is to put all of the notifications onto a separate notification queue and then run through the queue at a single point in time i.e. the notifications are performed iteratively. So when node B of is constructed the notification to node A is pushed onto a list. Then that list is executed and node A gets notified. This causes the notification to other additional nodes besides node A not illustrated in to be put on the same list and that notification is then sent after the notification to node A is sent. The notifications to other nodes besides the notification to node A doesn t happen until after all the work associated with node B and node A has been completed.

Logically these two implementations are exactly equivalent but they have different memory consumption properties when implemented. The recursive realization is simple but can consume an arbitrary amount of stack space with the stack consumption being a function of the depth of the dependency graph. The iterative implementation is slightly more complex and requires a bit more static memory the notification list but stack usage is constant irrespective of the depth of a dependency graph such as illustrated in .

Also notification of node creation in block is not limited to other nodes. It may also used internally for alias construction. Any arbitrary element in the system can use the same mechanism to request for notification when a node or marker becomes available not just other nodes. Both nodes and non nodes may use the same notification mechanism.

In decision block the framework manager determines if other nodes or soft dependencies are now released for creation or instantiation based on the creation of the current node . Decision block is generally determining if resources may now be created because certain dependency relationships have been fulfilled by the current node which has recently undergone creation or instantiation.

If the inquiry to decision block is positive then the Yes branch is followed back to routine block in which the released node may now be created or instantiated because of the fulfillment of a dependency by the node that was just created.

If the inquiry to decision block is negative then the No branch is followed to block in which the frame work manager may manage communications between elements of the software architecture as illustrated in . Between block and block an optional method D for managing suppressible requests may be executed by the framework manager and a resource. Further details of optional method D will be described below in connection with .

Next in block and after optional method D the framework manager may continue to log or record actions taken by resources by using the resource names associated with a particular resource. Block may be executed by the framework manager after any action taken by the framework manager or any of the elements managed by the framework manager such as the resources nodes clients events and query functions . Block is yet one important aspect of the invention in which the framework manager may maintain a running log of activity that lists actions performed by each element according to their unique identifier or name provided by the authors who created a particular element such as a resource of a node .

Compared to the prior art this logging of activity in block that lists unique names assigned to each resource of a system is unique and may provide significant advantages such as used in debugging and error troubleshooting. Another aspect of many that makes the system unique is that separate teams may work on different hardware and or software elements independently of one another in which each team will be able to use resource names that are unique and easy to track without the need for creating tables to translate less meaningful and usually confusing resource names assigned by other teams and or the original equipment manufacturer OEM .

Next in decision block the framework manager determines if a log of activity recorded by the framework manager has been requested. If the inquiry to decision block is negative then the No branch is followed to the end of the process in which the process returns back to routine . If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager sends the activity log comprising meaningful resource names and respective actions performed by the resource names to an output device such as a printer or a display screen and or both. An optional method E for managing instantiated nodes that become unavailable may be executed after block . Further details of method E will be described below in connection with . After block the process B may then return to routine block described above.

This optional method C may be well suited for pluggable un pluggable type resources that may be coupled to the PCD . This optional method C is also tailored for nodes that have not been instantiated or created in routine block of . In other words optional method C manages node structure data for nodes that have not been created by the framework manager where such creation instantiation usually occurs in routine block of . Optional method C prevents nodes from being created when the resources corresponding to a node are unavailable because they are either unplugged from the system or because they are experiencing one or more fault conditions.

Decision block is the first step of the optional method C. In this decision block the framework manager of may be monitoring messages that it may receive from the device drivers for the pluggable resources available to the system . As noted previously in addition to managing pluggable resources available to the system the optional method C may also manage those resources which have experienced a fault condition and which prevents a resource from taking or acting on any requests sent to it by the framework manager . The device driver of a resource may inform the framework manager in decision block if a particular resource of a node has experienced a fault condition that requires the framework manager take the resource and its corresponding node off line.

If the inquiry to decision block is negative then the NO branch is followed to block in which the process returns to either to block of if the NO branch was followed from decision block or the process returns to routine block if the Yes branch was followed from decision block . If the inquiry to decision block of is positive then the YES branch is followed to block .

In block the framework manager locks the un instantiated node from access by one or more other resource s as a dependent node . In other words the framework manager prevents other nodes from referencing the un instantiated node when its one or more resources are unavailable to the system for processing requests issued by other nodes threads clients etc.

In block the framework manager disables the un instantiated node to prevent its later instantiation or creation by the framework manager . In other words in this block the framework manager may set a flag or value tracked by the framework manager which prevents the un instantiated node to become part of the framework or resource graph B of until the resources that form the un instantiated node become available for taking request from the system .

In decision block the framework manager checks with the one or more device drivers of the resources for the un instantiated node to determine if the one or more resources which are unavailable have changed state to become available to the system . If the inquiry to decision block is negative then the NO branch is followed to block in which the process returns to block of .

If the inquiry to decision block is positive then the YES branch is followed to block in which the framework manager enables the un instantiated node so that it can be instantiated or created when routine of has started. In this block the framework manager may clear or reset a flag associated with the un instantiated node so that the un instantiated node may be processed by the framework manager during the instantiation routine of .

In decision block the framework manager may determine if the dependencies of the re enabled yet un instantiated node are also enabled. This decision block allows the framework manager make sure that nodes or resources of nodes on which the re enabled yet un instantiated node may be dependent have been enabled themselves. If the inquiry to decision block is negative then the NO branch may be followed back to block in which the process returns to block of if the NO branch was followed from decision block to decision block or the process returns to routine block if the Yes branch was followed from decision block to decision block .

If the inquiry to decision block of is positive then the YES branch is followed to block in which the re enabled un instantiated node is unlocked by the framework manager . The re enabled un instantiated node is unlocked for access by other resources when the resource graph B of is generated after the execution of the instantiation routine of . The optional method C then returns to block if the NO branch was followed from decision block to decision block or the process returns to routine block if the Yes branch was followed from decision block to decision block .

Suppressible requests may be identified using a flag or a variable that is set by a client during creation of a request. A resource may choose to take advantage of the suppressible requests feature in managing its requests or it may choose to ignore whether a request is suppressible or not.

Suppressible requests are advantageous for resources when a resource determines that suspending or putting a request on hold may result in greater efficiency for a PCD under a given scenario. For example suppose a resource is responsible for managing a bus. The resource may also learn of conditions when a CPU coupled to the bus desires to enter into an idle state.

The resource may receive a request to increase the bandwidth being supported by the bus. Meanwhile the resource may have just received a message that the CPU is about to enter into an idle state. If the resource has knowledge that the bus request for the increase in bandwidth is a suppressible request then the resource may be able to suppress the bus request until the CPU exits its idle state. This ability for the resource managing the bus to suppress a bus request while the CPU is in an idle state affords a significant efficiency for the PCD in order to conserve power. Other exemplary scenarios for increasing efficiency of managing resources with suppressible requests are readily understood by one of ordinary skill the art in view of this example.

Decision block is the first step of the method D for managing suppressible requests. In decision block a resource of a node may determine if it currently is handling one or more suppressed requests. If the inquiry to decision step is negative then the NO branch is followed to decision block .

If the inquiry to decision block is positive then the YES branch is followed to decision block . In decision block a resource determines if one or more conditions exist for executing previously suppressed one or more requests. For example in the exemplary scenario noted above with respect to a CPU entering into an idle state the resource may determine if the CPU has left its idle state as being a condition. If this condition is true meaning that the CPU has left its idle state then the resource may execute previously suppressed requests. In other words if the inquiry to decision block is positive then the YES branch may be followed to block in which the resource executes previously suppressed one or more requests. Essentially the code at this point computes what the new state should be when the suppressing condition becomes true i.e. if the CPU goes idle and stores that away. Then when that condition becomes true it applies the other state. This is a form of delayed execution as understood by one of ordinary skill in the art.

If the inquiry to decision block is negative then the NO branch is followed to decision block . In decision block a resource may determine if one or more conditions exist for suppressing those requests which have been identified as suppressible. Decision block may correspond with the previous example in which a CPU is about to enter into an idle state. If the inquiry to decision block is positive then the YES branch may be followed to block in which the resource may aggregate one or more suppressible requests for later execution by the resource. If the inquiry to decision block is negative then the NO branch may be followed to block in which the method D returns to block of .

As noted previously a node may be characterized as unavailable when a resource of a node is taken off line or has experienced a fault condition. According to one exemplary aspect a resource may become unavailable if it is hardware that may be removed from the PCD such as a USB port type of device. The driver of the hardware may inform the framework manager of when the resource has been removed from the PCD and is unavailable for processing any requests that may be managed by the framework manager .

This optional method E like optional method C may be well suited for pluggable un pluggable type resources that may be coupled to the PCD . This optional method D is tailored for nodes that have been instantiated or created in routine block of . In other words optional method E nodes that have been created by the framework manager and which already exist in a resource graph such as resource graph B of .

Decision block like block of is the first step of the optional method D. In decision block the framework manager may determine if a particular node as illustrated in the exemplary node resource graph B of should be taken off line. In this decision block the framework manager of may be monitoring messages that it may receive from the device drivers for the pluggable resources available to the system . As noted previously in addition to managing pluggable resources available to the system the optional method E may also manage those resources which have experienced a fault condition and which prevents a resource from taking or acting on any requests sent to it by the framework manager . The device driver of a resource may inform the framework manager in decision block if a particular resource of a node has experienced a fault condition that requires the framework manager take the resource and its corresponding node off line.

If the inquiry to decision block is negative then the NO branch is followed back to block of . If the inquiry to decision block is positive then the YES branch is followed to block .

In block the framework manager records the current state of the resource of a node before the node is taken off line. The framework manager may then take the resource and its corresponding node off line.

In block the framework manager locks the existing node from access by one or more other resource s as a dependent node . In other words the framework manager prevents other nodes from referencing the node when its one or more resources are unavailable to the system for processing requests issued by other nodes threads clients etc.

In block the framework manager disables the node and its current state. In decision block the framework manager checks with the one or more device drivers of the resources for the disabled node to determine if the one or more resources which are unavailable have changed state to become available to the system .

If the inquiry to decision block is negative then the NO branch is followed back to block of . If the inquiry to decision block is positive then the YES branch is followed to block in which the framework manager enables the node so that it can be available again to the system . In block the existing node is reinitialized so that it is brought back to its prior state. In other words the existing node is reinitialized in order to place the node in the state that it was in just prior to being taken off line by the framework manager .

In decision block the framework manager may determine if the dependencies of the re enabled node are also enabled. This decision block allows the framework manager make sure that nodes or resources of nodes on which the re enabled existing node may be dependent have been enabled themselves. If the inquiry to decision block is negative then the NO branch may be followed back to block of .

If the inquiry to decision block is positive then the YES branch is followed to block in which the re enabled existing node is unlocked by the framework manager . The re enabled existing node is unlocked for access by other resources as illustrated in the resource graph B of . The optional method E then returns to block of .

In decision block the framework manager determines if the node structure data contains a request for creating a stub resource. A stub resource is a software development tool that allows a resource author to create a placeholder in the framework or resource graph B of . A stub resource is a placeholder that may allow other resources to be formed and on which other resources may be dependent. In this way other resources and ultimately nodes and clients may be created by the framework manager during instantiation routine when a particular resource is not available or has not been developed yet.

Other resources of nodes may register events against stub resources. However stub resources will never return a value for an event since the stub resource will not contain any active functions or features that may support an event. Stub resources may be replaced with actual or running resources at a later stage. Further details about how stub resources may be replaced with actual resources will be described below in connection with .

If the inquiry to decision block is negative then the NO branch is followed to block . If the inquiry to decision block is positive then the YES branch is followed to block in which the framework manager may receive a detailed name and data for the creation of a stub resource. The process then returns to block of .

In block the framework manager may receive a unique name for a software or hardware element such as the CPU and the clock of . As discussed previously a node must reference at least one resource. Each resource has a name and that name must be unique in the system . All elements within the system may be identified with unique names. Each element has unique name from a character perspective. In other words generally there are no two elements within the system which have the same name.

According to exemplary aspects of the system resources of nodes may generally have unique names across the system but it is not required that client or event names be unique though they may be unique as desired.

For convenience a conventional tree file naming structure or file naming metaphor that employs forward slash characters for creating unique names may be employed such as but not limited to core cpu for CPU and clk cpu for clock . However as recognized by one of ordinary skill the art other types of resource names containing any other combination of alpha numeric characters and or symbols are well within the scope of the invention.

Next in block the framework manager may receive data for one or more driver functions associated with one or more resources of the node being created. A driver function generally comprises the action to be completed by one or more resources for a particular node . For example For example in the driver function for the resource core cpu of node may request the amount of bus bandwidth and the CPU clock frequency it requires in order to provide the requested amount of processing that has been requested. These requests would be made via clients not illustrated of the resources in nodes and node . The driver function for clk cpu in node would usually be responsible for actually setting the physical clock

In block the framework manager may receive node attribute data. The node attribute data generally comprises data that defines the node policies such as security can the node be accessed via user space applications remotability can the node be accessed from other processors in the system and accessibility can the resource support multiple concurrent clients . The framework manager may also define attributes that allow a resource to override default framework behavior such as request evaluation or logging policy.

Subsequently in block the framework manager may receive customized user data for the particular node being created. The user data may comprise a void star field as understood by one of ordinary skill in the art with respect to the C programming language. User data is also known to one of ordinary skill in the art as a trust me field. Exemplary customized user data may include but is not limited to tables such as frequency tables register maps etc. The user data received in block is not referenced by the system but allows for customization of a resource if the customization is not recognized or fully supported by the framework manager . This user data structure is a base class in the C programming language intended to be extended for particular or specific uses.

One of ordinary skill the art recognizes that other kinds of data structures for extending specific uses of a particular class are within the scope of the invention. For example in the programming language of C C plus plus an equivalent structure may comprise the key word public which would become an extension mechanism for a resource within a node .

Next in block the framework manager may receive dependency array data. The dependency array data may comprise the unique and specific names of one or more resources on which the node being created is dependent. For example if the first node of was being created then in this block the dependency array data may comprise the resource names of the three resources of the second node and the single resource name of the third node on which the first node is dependent.

Subsequently in block the framework manager may receive resource array data. The resource array data may comprise parameters for the current node being created such as parameters relevant to the first node of if this first node was being created. The resource array data may comprise one or more of the following data the names of other resources unit maximum value resource attributes plug in data and any customized resource data similar to the customize user data of block . The plug in data generally identifies functions retrieved from a software library and usually lists the client types that may be supported by the particular node or plurality of nodes being created. The plugin data also allows for customization of client creation and destruction. After block the process returns to block of .

In the attribute data block customize user data block and the dependency array data block have been illustrated with dashed lines to indicate that these particular steps are optional and not required for any given node . Meanwhile the unique name block a driver function block and resource array data block have been illustrated with solid lines to indicate that these steps of routine are generally mandatory for creating a node .

In block the framework manager may create or instantiate the one or more resources corresponding to the node structure data of block . Next in block the framework manager may activate the driver functions received in routine block of routine block using the maximum values received in the resource array data block of routine block . According to one exemplary aspect the driver functions may be activated using the maximum values received in the resource array data block of routine block . According to another preferred exemplary aspect each driver function may be activated with an optional initial value that is passed along with the node structure data from routine . If initial data is not provided the driver function is initialized at 0 the minimum value. The driver function is also usually activated in manner such that it is known that it is being initialized. This enables the resource to perform any operations that are specific to initialization but do not need to be performed during normal or routine operation. The process then returns to step of .

The name table allows a first design team such as an original equipment manufacturer OEM for software drivers focused on certain hardware and or software elements to provide unique names internal relative to the first design team working on the particular piece of hardware or software. With the name table second and third or more outside design teams may be able to reference the hardware or software elements of the first design team of the OEM in this example by using aliases preferred by those of the second and third outside design teams.

For example an OEM may assign the name cpu to the central processing unit of as illustrated in the first row and second column of the table in . Meanwhile a second team of professionals relative to the OEM may desire to assign a different name or alias to the same central processing unit . The second team may assign the alias of main processor which corresponds to the resource name of cpu as illustrated in the first row and first column of the table of .

If the inquiry to decision block is negative then the No branch is followed to block in which the alias is stored in temporary storage until the resource is created. Specifically when an alias to an undefined name is created this alias is stored in memory and the process goes back to waiting for more aliases to be defined . When an alias is instantiated the alias name is stored in memory along with a callback against the as yet undefined name alias . When that undefined name alias is published that notifies the alias which then causes it to be published. This behavior is essentially the same as the resource creation process when there is a missing dependency.

The process then proceeds back to block . If the inquiry to decision block is positive then the Yes branch is followed to block in which the alias is published by the framework manager so that other resources may access the resource corresponding to the alias that has just been created. The process then returns.

Next in block customized user data may be received by the framework manager if there are any particular customizations for this client being created. Block has been illustrated with dashed lines to indicate that the step is optional. The customized user data of block is similar to the customized user data discussed above in connection with the creation of resources for nodes .

In block the framework manager receives the client type category assigned to the particular client being created. The client type category as of this writing may comprise one of four types a required b impulse c vector and d isochronous. The client type category list may be expanded depending upon the resources being managed by the system and upon the application programs relying upon the resources of the nodes .

The required category generally corresponds with the processing of a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . Meanwhile the impulse category generally corresponds with the processing of a request to complete some activity within a certain period of time without any designation of a start time or stop time.

An isochronous category generally corresponds with a request for an action that is typically reoccurring and has a well defined start time and a well defined end time. A vector category generally corresponds with an array of data that usually is part of multiple actions that are required in series or in parallel.

Subsequently in block the framework manager receives data that indicates whether the client has been designated as synchronous or asynchronous. A synchronous client is one that typically requires the framework manager lock a resource of a node until the resource returns data and an indication that the resource has finished completing the requested task from the synchronous client .

On the other hand an asynchronous client may be handled by one or more threads See in parallel which are accessed by the framework manager . The framework may create a callback to a thread and may return a value when the callback has been executed by a respective thread . One of ordinary skill the art recognizes that the asynchronous client does not lock up a resource like a synchronous client does when the task of the synchronous client is being executed.

After block in decision block the framework manager determines if the resource identified by the client are available. If the inquiry to decision block is negative then the No branch is followed to block in which a null value or message is returned to a user indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to decision block in which the framework manager determines if each resource identified by the client supports the client type provided in block . If the inquiry to decision block is negative then the No branch is followed back to block in which a null value or message is returned indicating that the client cannot be created at this time.

If the inquiry to decision block is positive then the Yes branch is followed to block in which the framework manager creates or instantiates the client in memory. Next in block if any customized user data is received in block such as optional arguments then these optional arguments may be mapped with their respective resources a particular nodes . Next in block the newly created client is coupled to its corresponding one or more resources in an idle state or on requested state as illustrated in described above. The process then returns to block of .

In block the framework manager may receive the data associated with a particular client request such as one of the three mentioned above a required b impulse and c vector. The data associated with a required request generally comprises a scalar value that is passed from the required client to a particular resource . For example a required request may comprise a certain number of millions of instructions per second MIPs . Meanwhile an impulse request comprises a request to complete some activity within a certain period of time without any designation of a start time or stop time. Data for a vector request generally comprises an array of multiple actions that are required to be completed in series or in parallel. A vector request may comprise an arbitrary length of values. A vector request usually has a size value and an array of values. Each resource of a node may be extended to have a pointer field in order to support a vector request. In the C programming language the pointer field is supported by the union function as understood by one of ordinary skill in the art.

The client request data may also indicate whether the request is suppressible or not. Suppressible requests may be handled differently by a resource according to a resource s own choosing as described above in connection with method D of .

Next in block the framework manager issues the request through the client that was created by the method described above in connection with . Subsequently in block the framework manager double buffers the request data being passed through the client if the request is a required type or a vector type. If the request is an impulse type then block is skipped by the framework manager .

For required requests in this block values from a prior request are maintained in memory so that the framework manager can determine if there is any difference between the previous requested values in the current set of requested values. For vector requests prior requests are usually not maintained in memory although a resource of a node may maintain it as desired for a particular implementation. Therefore block is optional for vector types of requests.

In block the framework manager calculates the delta or difference between the previous set of requested values in the current set of requested values. In decision block the framework manager determines if the current set of requested values is identical to the previous set of requested values. In other words the framework manager determines if a difference exists between the current set of requested values and the previous set of requested values. If there is no difference between the current set and previous set of requested values then the Yes branch is followed which skips blocks through block to block in which the process ends.

If the inquiry to decision block is negative meaning that the set of requested values are different relative to the set of pre previous requested values then the No branch is followed to decision block .

In decision block the framework manager determines if the current request is an asynchronous request. If the inquiry to decision block is negative then the No branch is followed to block in which the resource corresponding to the client request is locked by the framework manager . If the inquiry to decision block is positive meaning that the current request is asynchronous request type then the Yes branch is followed to block in which the request may be pushed onto another thread and may be executed by another core if a multicore system like that of is currently managed by the framework manager . Block has been illustrated with dashed lines to indicate that this step may be optional if the PCD is a single core central processing system.

Subsequently in block the resources corresponding to the request is locked by the framework manager . Next in block the resource executes the update function which generally corresponds to the plug in data of the resource array data received in block of . The update function generally comprises a function responsible for the new resource state in light of a new client request. The update function compares its previous state with the requested state in the client request. If the requested state is greater than the previous state then the update function will perform the client request. However if the requested state is equal to or less than the current state and which the resource is operating at then the client request will not be performed in order to increase the efficiency since the old state achieves or satisfies the requested state. An update function takes a new request from the client and aggregates it with all the other active requests to determine the new state for the resource.

update function for the bus clock would usually take the maximum of all the client requests and use that as the new desired state for the bus clock. It is not the case that all resources will use the same update function although there are some update functions that will be used by multiple resources. Some common update functions are to take the maximum of client requests to take the minimum of client requests and to sum the client request. Or resources may define their own custom update function if their resource needs to aggregate requests in some unique way.

Next in block the framework manager passes the data to the resource corresponding to the client request so that the resource may execute the driver function which is specific to the resource of a node . A driver function applies the resource state as computed by the update function. This may entail updating hardware settings issuing requests to dependent resources calling legacy functions or some combination of the above.

In the previous example the update function computed the requested bus clock frequency. The driver function may receive that requested frequency and it may update the clock frequency control HW to run at that frequency. Note that sometimes it is not possible for the driver function to meet the exact requested state that update function has computed. In this case the driver function may choose the frequency that best meets the request. For example the bus clock HW may only be able to run at 128 MHz and 160 MHz but the requested state might be 150 MHz. In this case the driver function should run at 160 MHz as that exceeds the requested state.

resource which have executed the driver function in block . Subsequently in block if defined against the resource events may be triggered so that data is passed back to the client which corresponds to the event . Events may be processed in another thread. This may minimize the amount of time spent with the resources locked and allows for more parallel operation in a multicore system as illustrated in . One or more events may be defined against a resource in a manner similar to how a request may be defined against a resource as described in this method . In other words the event creation process may largely parallel the client creation process. One thing that is different with the events is that it is possible to define events that only get triggered when certain thresholds are crossed.

This defining of events that only get triggered based on thresholds allows for notification of when a resource is getting oversubscribed it has more concurrent users than it can support which is indicative of a system overloading condition or when a resource goes low off which may allow other things to be shut off restore functionality that was disabled when the system became oversubcscribed etc. Because the event registration may be done with thresholds it reduces the amount of work the system has to do on event notification to only happen when there is something really necessary. It is also possible to register for an event on every state change.

Next in optional block if the request being processed is a vector request then this optional block is usually performed. Optional block generally comprises a check or determination to assess whether the vector pointer is still positioned on the same data that the user passed into the vector. If the inquiry to this optional block is positive meaning that the pointer is still pointing to the same data which was passed by the user into the vector then the pointer is cleared out so that references to old data is not maintained. This optional block is generally performed to account for the double buffering block described above when a vector request is being processed compared to an impulse request and a required request.

Subsequently in block the framework unlocks the requested resource so that other client requests may be handled by the current but now released requested resource of a particular node . The process then returns to the first block for receiving the next client request.

Block is the first step of the sub method or routine for processing isochronous requests . Block occurs after block and before block of . In block the framework manager may receive the deadline data such as deadline C as discussed above in connection with .

Next in block the framework manager may calculate a difference between the current time and the deadline provided in block . Subsequently in block which occurs after block but before block of the framework manager compares the start time A and finish time B with the deadline C See . In block because the framework manager was provided with the amount of activity requested and because the framework manager tracks the start time A and finish time B then in block the framework manager may calculate the amount of work that was performed by the resource of a particular node .

Next in block which occurs after block and before block of an optimization process may be executed. Block has been illustrated with dashed lines to indicate that the step is optional or that this step may be performed off line and off device relative to the PCD . The optimization process may attempt to determine how the work may be best completed between the start time in the deadline while taking into account many different variables such as power consumption and responsiveness. In some exemplary embodiments this block may be entirely skipped altogether without departing from the scope of the invention. The process then returns to block of for processing the next client request .

For example other threshold events include but are not limited to those that relate to power consumption battery charge status state sleep or low power conditions specific hardware conditions such as good fair and poor radio frequency RF reception operating conditions that may relate to loads like millions of instructions per second MIPs clock frequency bus frequency voltage DCVS conditions and algorithms etc. Threshold events usually include one or more triggering conditions. In the example illustrated in the triggering conditions related to specific temperature values.

Referring now back to block is the first step of method for creating one or more threshold events . Method is generally carried out or executed after method for managing resources of a PCD as illustrated in . In block the framework manager of may receive one or more requests to create a threshold event against a resource of a node .

As noted above any user of software architecture supported by the framework manager may set up a threshold event against a resource. A user of the software architecture that creates threshold events may include a resource author a node author a resource or a thread of execution. The resources assigned to a threshold event may be instructed to report the status of a threshold event to one or more different resources.

Next in block the framework manager for A receive one or more functions that track events conditions against the one or more resources of a node . This block generally corresponds with the threshold events illustrated in . In block the framework manager would receive the one or more thresholds or conditions being tracked by the one or more functions. Specifically for blocks and the framework manager would receive one of the threshold events A D illustrated in . Each threshold events illustrated in has a temperature monitoring function and a specific temperature being tracked by that function.

Next in block the framework manager would receive the one or more names of one or more resources that will receive notices of the threshold events. Block generally corresponds with the chart illustrated in . Chart lists in the third column the recipient resources for the threshold events listed in the second column.

Next at block the one or more threshold events against a resource are registered with the framework manager . Then in block each resource begins its monitoring of its threshold events defined in method . The method then returns.

Other resources of nodes may register events against stub resources. However stub resources will never return a value for an event since the stub resource will not contain any active functions or features that may support an event. Stub resources may be replaced with actual or running resources as set for the in .

Block is the first step in method for replacing a stub resource with a new actual functioning resource. In block the framework manager for may receive the identity of the one or more resources on which the stub resource is dependent. Next in block the framework manager for may lock the one or more resources on which the stub resources is dependent so that these other resources may not issue any further requests.

Next in block each client that is listed in the data structure for the stub resource may be added to the list of the new functioning resource that will be replacing the stub resource. In block the pointer of each client of the stub resource is adjusted so that it points to the new functioning resource that is replacing the stub resource.

In block the framework manager may be issue one or more active requests for each resource that is dependent on the old stub resource. Next in block the framework manager may re aggregate the new state of the new resource which is replacing the old stub resource. Next in block in block the framework manager may activate the driver functions received in routine block of routine block using the maximum values received in the resource array data block of routine block .

According to one exemplary aspect the driver functions may be activated using the maximum values received in the resource array data block of routine block . According to another preferred exemplary aspect each driver function may be activated with an optional initial value that is passed along with the node structure data from routine . If initial data is not provided the driver function is initialized at 0 the minimum value. The driver function is also usually activated in manner such that it is known that it is being initialized. This enables the resource to perform any operations that are specific to initialization but do not need to be performed during normal or routine operation.

Next in block the framework manager may re issue the one or more events that were previously registered for the stub resource against the new and functional resource replacing the stub resource. The process then returns.

Certain steps in the processes or process flows described in this specification naturally precede others for the invention to function as described. However the invention is not limited to the order of the steps described if such order or sequence does not alter the functionality of the invention. That is it is recognized that some steps may performed before after or parallel substantially simultaneously with other steps without departing from the scope and spirit of the invention. In some instances certain steps may be omitted or not performed without departing from the invention. Further words such as thereafter then next etc. are not intended to limit the order of the steps. These words are simply used to guide the reader through the description of the exemplary method.

Additionally one of ordinary skill in programming is able to write computer code or identify appropriate hardware and or circuits to implement the disclosed invention without difficulty based on the flow charts and associated description in this specification for example.

Therefore disclosure of a particular set of program code instructions or detailed hardware devices is not considered necessary for an adequate understanding of how to make and use the invention. The inventive functionality of the claimed computer implemented processes is explained in more detail in the above description and in conjunction with the Figures which may illustrate various process flows.

In one or more exemplary aspects the functions described may be implemented in hardware software firmware or any combination thereof. If implemented in software the functions may be stored on or transmitted as one or more instructions or code on a computer readable medium. Computer readable media include both computer storage media and communication media including any medium that facilitates transfer of a computer program from one place to another. A storage media may be any available media that may be accessed by a computer. By way of example and not limitation such computer readable media may comprise RAM ROM EEPROM CD ROM or other optical disk storage magnetic disk storage or other magnetic storage devices or any other medium that may be used to carry or store desired program code in the form of instructions or data structures and that may be accessed by a computer.

Also any connection is properly termed a computer readable medium. For example if the software is transmitted from a website server or other remote source using a coaxial cable fiber optic cable twisted pair digital subscriber line DSL or wireless technologies such as infrared radio and microwave then the coaxial cable fiber optic cable twisted pair DSL or wireless technologies such as infrared radio and microwave are included in the definition of medium.

Disk and disc as used herein includes compact disc CD laser disc optical disc digital versatile disc DVD floppy disk and blu ray disc where disks usually reproduce data magnetically while discs reproduce data optically with lasers. Combinations of the above should also be included within the scope of computer readable media.

Although selected aspects have been illustrated and described in detail it will be understood that various substitutions and alterations may be made therein without departing from the spirit and scope of the present invention as defined by the following claims.

