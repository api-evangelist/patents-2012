---

title: Dynamic creation and use of software testing stubs
abstract: A software testing tool providing dynamic testing stubs. The tool comprises, comprising a processor, a non-transitory memory coupled to the processor, and an application stored in the memory. When executed by the processor in a single execution session, the application receives a definition of a test stub as a mapping from a stub handle to a reply message content, stores the test stub in a data store as an entry comprising the stub handle and the reply content, receives an invocation of an application programming interface, where the invocation comprises an argument, searches the data store for a test stub having a stub handle that matches at least in part to the argument received in the invocation of the application programming interface, and transmits a reply message defined by the test stub.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09038028&OS=09038028&RS=09038028
owner: Sprint Communications Company L.P.
number: 09038028
owner_city: Overland Park
owner_country: US
publication_date: 20120315
---
Computer software often interacts with a variety of other software. For example a first software component relies upon a second software component to perform services for it and may send a request to the second software component including parameters that are to be processed or may otherwise provide instructions to the second software component. The second software component may complete the requested processing and return a message with results to the first software component. Testing a software component or application for example when the component or application is first developed or is later modified typically involves performing a plurality of representative activities of the software component or application. This may be referred to as exercising the software executing the software or testing the software. The separate scenarios of execution may be referred to as test cases.

It may be desirable in some stages of software testing for example when the software under test is not yet ready for deployment to a production environment and or when the supporting second software component is not yet ready for deployment to the production environment to substitute a dummy or simulated interface in the place of the second software component or the support software. This substitute interface may define a number of different loop back actions or testing stubs such that when a request for service is sent by the software under test an appropriate loop back action or testing stub is selected and returned to the software under test for example a plausible response in the appropriate response message format is returned to the software under test. This stubbing practice well known to those skilled in the software development art promotes testing of in progress software.

In an embodiment a software testing tool providing dynamic testing stubs is disclosed. The tool comprises a processor a non transitory memory coupled to the processor and an application stored in the memory. When executed by the processor in a single execution session the application receives a definition of a test stub as a mapping from a stub handle to a reply message content stores the test stub in a data store as an entry comprising the stub handle and the reply content receives an invocation of an application programming interface where the invocation comprises an argument searches the data store for a test stub having a stub handle that matches at least in part to the argument received in the invocation of the application programming interface and transmits a reply message defined by the test stub.

In an embodiment a method of software testing is disclosed. In an embodiment the method comprises receiving a definition of a software test stub the definition comprising a stub handle storing the test stub in a data store receiving a request to execute a function of an application programming interface API from an application under test wherein the request comprises at least one argument searching the data store based on the at least one argument and when the at least one argument comprises the stub handle returning the test stub to the application under test. In an embodiment each of the steps of the method may be performed in a single execution session of a software testing tool.

In an embodiment a method of software testing is disclosed. The method comprises receiving a request message directed to an application programming interface API from an application under test searching a data store based on the request message wherein the data store comprises a plurality of software test stubs when the search of the data store does not access a software test stub that has a stub handle that matches a sub string of the request message formatting a second request message based in part on the request message that contains information not present in the request message and transmitting the second request message to a static software stubbing application.

These and other features will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings and claims.

It should be understood at the outset that although illustrative implementations of one or more embodiments are illustrated below the disclosed systems and methods may be implemented using any number of techniques whether currently known or not yet in existence. The disclosure should in no way be limited to the illustrative implementations drawings and techniques illustrated below but may be modified within the scope of the appended claims along with their full scope of equivalents.

While engaged in testing software components and or applications software developers and or testers may identify new test cases that they would like to apply to testing a software component and or software application at that time. It may be that immersion in the testing activity stimulates the tester to think of useful test cases he or she had not thought of before. It may be that the behavior of the software component and or the software application elicited by other test cases suggests useful additional test cases that it is desired to execute at that time while the subject software behavior is fresh in mind. A static software test environment for example a statically structured and or defined software test stubbing tool may not promote such flexible and opportunistic testing procedures.

The present disclosure teaches a dynamic software stubbing tool that promotes on the fly definition and or creation of testing stubs which support such adaptive efficient software testing. After a test stub has been defined it is nearly immediately available for use in testing. The dynamic software stubbing tool contemplated by the present disclosure provides an intuitive user friendly interface that a tester or developer can use with minimal time investment in learning to use the dynamic software stubbing tool. This characteristic makes it possible for software developers and or testers to create their own software test stubs without having to hire an expensive specialist for example a contractor associated with a vendor of the static software stubbing tool.

In an embodiment the dynamic software stubbing tool provides a graphical user interface that guides the user through the steps of defining a test stub. The tool promotes defining a class of application programming interface that is targeted by the test request for example a hypertext markup language transport protocol HTTP request or a message queue manager request. The tool promotes the user designating a portion of an application programming interface request or function call argument list as a stub handle to associate with the new stub. Before creating the stub in a data store the tool first confirms that the stub handle is unique in the data store. If unique the stub is saved into the data store and is then available for use during testing. In some contexts the stubs defined using the dynamic software stubbing tool may be referred to as dynamic testing stubs or dynamic stubs.

When an application programming interface request is transmitted by the software unit under test for example a software component being tested or a software application being tested the request is received by the tool. The tool searches the data store for a stub that has a stub handle that matches a sub string of the subject request. If a matching stub is found the tool returns the matching stub to the software unit under test and the software unit under test consumes the software stub e.g. receives and processes the response message provided by the software stub.

In an embodiment the software stubs defined using the dynamic software stubbing tool may have a state that is one of active or inactive. If the subject stub has not been used recently the state of the stub may be changed to inactive. By searching only stubs that have an active state the dynamic software stubbing tool may respond more rapidly to application programming interface requests. By retaining inactive stubs in the data store the dynamic software stubbing tool promotes the recovery and reuse of selected stubs through a user operation. Additionally stubs created using the dynamic software stubbing tool may be designated as reserved for private use of the user who created the stub for group use of any user belonging to the same work group as the user who created the stub or for public use by anyone having access to the dynamic software stubbing tool.

In an embodiment the dynamic software stubbing tool is configured to hand off application programming interface requests to a static software stubbing tool for handling when no match to the request is found in the data store. In this case if the static software stubbing tool finds a matching stub in the statically defined stubs the static tool returns the statically defined stub to the software under test. In an embodiment the static software stubbing tool may impose a requirement that application programming interface requests presented to it comply with complicated format and or protocol criteria. It is contemplated that the dynamic software stubbing tool mediates between the request input by the user and the request presented to the static software stubbing tool by mapping the relatively simple argument list input by the user for example using a user interface provided by the dynamic software stubbing tool to the specific format and argument list required by the static software stubbing tool thereby preserving the user friendliness and convenience of the interface presented to the tester.

Turning now to a software testing system is described. In an embodiment the system comprises a software unit under test a test user interface a communication network an ad hoc stubbing tool a data store and a static stubbing tool . The network may comprise any combination of private and public networks. In an embodiment the system may not comprise the static stubbing tool . In some contexts the ad hoc stubbing tool may be referred to as a dynamic stubbing tool or as a dynamic software stubbing tool. The software unit under test the test user interface the ad hoc stubbing tool the data store and the static stubbing tool may execute on one or more computers. One or more of the software unit under test the test user interface the ad hoc stubbing tool the data store and the static stubbing tool may execute on the same computer. Computers are described in detail hereinafter.

The data store may be implemented in a variety of ways. The data store may be implemented as a database or as a server computer executing database management software coupled to a memory storage peripheral. The data store may be implemented as a directory store for example a light weight directory access protocol LDAP store. The data store may be implemented in a flat file format or other file format. The data store may be implemented in a different kind of data structure or architecture.

In an embodiment the test user interface may be used to define test stubs to bring the software unit under test into execution and to execute test cases that may involve the software unit under test being exercised and making calls to and or invoking methods on an application programming interface API where the API is simulated or stubbed by the ad hoc stubbing tool . In an embodiment a user may use the test user interface to define test stubs and to execute test cases at nearly the same time for example to define a stub and then shortly thereafter possibly fifteen seconds later to execute a test case that relies on the recently defined stub. In an embodiment a user may use the test user interface to perform administrative actions related to testing for example recording failed test cases in a software defect management tool data base to perform statistical analysis of various kinds on the results of testing a plurality of test cases and other like administrative actions that may be involved in testing software.

In some contexts the newly defined test stub may be said to be immediately available or instantly available for use in testing. For the purposes of the present disclosure the newly defined test stub may be considered to be immediately available if it can be used for testing in less than five minutes after definition if it can be used in less than one minute after definition or if it can be used in less than fifteen seconds after definition. As would be appreciated by one skilled in the art often a first tool is used to define and store test stubs and a second tool is used to perform testing that interacts with the stored test stubs. In an embodiment of the disclosure a single execution session of the ad hoc stubbing tool may promote defining a test stub storing the test stub executing a test case that results in returning the test stub to the software unit under test. As used herein a single execution session may comprise the processing performed by the ad hoc stubbing tool from the point that it has completed boot up and or initialization to the point at which it is shut down or terminated for example when one or more processes that provide the processing of the ad hoc stubbing tool are killed or otherwise discontinued.

The software unit under test may be any software application or component or any plurality of software applications or components. The software unit under test may be subjected to testing during various stages of development and or maintenance of the subject software. The software unit under test during the course of its execution may send request messages directed to an API of a specific supporting application such as a messaging system or other application. The software unit under test may typically expect a reply to the request message that conforms to a specific reply message format for example a reply message format defined by the API of the specific supporting application. The inventors believe that the concept of a software test stub or stub is well understood by those of ordinary skill in the art but generally a stub is understood to provide a modest and limited simulation of the supporting application. The stub may be considered to provide a dummy response message that carries merely plausible content or perhaps fixed and invariable content.

It is contemplated that the system is compatible with testing software units under test that may make calls to a variety of APIs and the specific examples of APIs described below are not meant to suggest that the system is unsuitable for use with other APIs. During testing the software unit under test may be configured to send request messages to and to receive reply messages from the ad hoc stubbing tool . The ad hoc stubbing tool may be considered to simulate the absent API and or support application. In response to receiving the request message from the software unit under test the ad hoc stubbing tool may return a reply message to the software unit under test that is consistent with the reply message format of the subject API. The reply message that the ad hoc stubbing tool sends to the software unit under test may be referred to as a test stub or simply a stub. Alternatively the combination of the request message and the returned reply message may be referred to as a test stub or stub.

The test user interface may present a graphical user interface GUI for the user to define stubs. After creation the stub may be stored in a data store comprising a plurality of stubs for example a first stub a second stub and a third stub . The test user interface may present windows into which the user may enter information for defining the stub including a unique stub handle that may be used to uniquely identify the subject stub among a plurality of other stubs. The test user interface may present a window in which to select an application programming interface type for example a message transport API for example the IBM Message Queue message transport API or a hypertext markup language transport protocol HTTP .

The test user interface may present a window for defining a sharing type. For example the test user interface may promote defining a sharing type and or a sharing level as one of a private level a group level or a public level. If the private level of sharing is selected the stub may only be accessed and used by the user who defined the subject stub. If the group level of sharing is selected the stub may be accessed by any user who is a member of the same work group to which the defining user belongs. If the public level of sharing is selected the stub may be accessed by any user. Work groups may be defined in a configuration file that the ad hoc stubbing tool reads during initiation e.g. when the ad hoc stubbing tool starts executing.

The test user interface may present buttons to promote the user activating the stub or deactivating the stub. For example after a predefined time period during which the third stub is not used the third stub may be marked as having an inactive status. If the user wishes to return the third stub to an active status the user may display the third stub and select it to active status. The test user interface may promote the user indicating to which application the stub is associated for example an identity of the software unit under test . When defining a new stub the test user interface may promote creating a stub initially by copying an existing stub and then allowing the user to modify this stub thereby saving time in creating new stubs. It will be appreciated that the test user interface may present yet other features for creating and defining new stubs .

In an embodiment the ad hoc stubbing tool may comprise a stub creation application and an application programming interface request handling application . The API request handling application may comprise a stub handle matching component and an API request reformatter component . One skilled in the art will appreciate that the ad hoc stubbing tool may take other forms and or architectures.

The stub creation application may receive the definition of a stub from the test user interface and process this definition. The stub creation application may search the data store using the stub handle provided in the stub definition. If the stub handle is found associated with another stub in the data store the stub creation application sends an exception message or other error message to the test user interface indicating that the stub handle provided is not unique in the data store . If the stub handle is not found in the data store the stub creation application may write the stub definition as a stub into the data store . The stub definition may comprise a variety of information in addition to the stub handle.

The API request handling application receives request messages from the software unit under test . The API request handling application searches for a stub in the data store that has a stub handle that matches the request message. For example the stub handle matcher component may analyze stubs one after the other to determine whether there is a match between the stub handle defined for the stub and a portion of the content of the request message for example to determine if there is a match between the stub handle and a substring of the request message. When a stub is found whose stub handle matches a substring of the request message the API request handling application may stop searching in the data store and return the stub as the response message to the software unit under test . In an embodiment the API request handling application may format the content of the selected stub appropriately for example formatting the content in the format defined by the subject application programming interface for example according to a message queue reply message format.

In an embodiment the stub handle matcher and or the API request handling application may only analyze stubs that have an active status and disregards any stub that has an inactive status thereby speeding the process of finding a matching stub. Likewise the stub handle matcher and or the API request handling application may only analyze stubs that have a public share level that have a group share level and the user is a member of the subject group or that have a private share level and the user is the user associated with this stub thereby speeding up the search process by omitting the substring search using the subject stub handle. In an embodiment a tester may configure the stub handle matcher to search the data store only among the stubs that are associated with a specific private level e.g. a specific user or with a specific work group. This functionality may speed searching for stubs when the user knows which category of stubs their request message is expected to match to.

When a stub match is not found in the data store the API request reformatter may format an API request message based on the content of the request message provided by the software unit under test and send the formatted request message to the static stubbing tool . The static stubbing tool may expect to receive additional parameters or request messages formatted in a specialized format that a user may be unknowledgeable about. In an embodiment the API request reformatter may be considered to provide a kind of mediation role. The static stubbing tool may return a reply message directly to the software unit under test . Alternatively the static stubbing tool may return a reply message to the API request reformatter and the API request reformatter may create a reply message according to a format preferred by the software unit under test based on the content in the reply message provided by the static stubbing tool and send this created reply message to the software unit under test . Alternatively when the static stubbing tool is not part of the system the API request handling component may return an exception reply message or a default response message to the software unit under test . In an embodiment the static stubbing tool may be provided by a vendor or third party and may be referred to in some contexts as a third party application.

Turning now to a method is described. At block a definition of a software test stub is received the definition comprising a stub handle. A stub handle may comprise a string of characters and or numbers. The stub handle may be defined by highlighting a portion of a stub definition for example using the test user interface . At block it is determined whether the stub handle is unique in a data store for example in the data store . In an embodiment the data store may be partitioned according to individual users groups of users and all users. A stub that has a private sharing status defined may be stored in a partition of the data store associated only with that particular defining user. Thus the private partition of a first user may have a stub defined having a stub handle that is identical to a stub defined in in the private partition associated with a second user. The private partition of the first user may not have a stub defined having a stub handle that is identical to a stub handle of a stub defined in the group partition associated with the first user or to a stub handle of a stub defined in the public partition. Alternatively in an embodiment every stub handle in the data store may be required to be unique across the entire data store across all private levels and group levels of sharing. If the stub handle is found to be non unique according to the optional tests of uniqueness described above the method exits. In an embodiment an exception message may be conveyed to the user attempting to define the stub having a non unique stub handle identifying the partition that includes a predefined stub using the same stub handle. If the stub handle is determined to be unique as described above the processing proceeds to block where the defined test stub is stored in the data store for example in data store .

Turning now to method is described. At block a request to execute a function or method of an application programming interface is received from an application under test for example the software unit under test wherein the request comprises at least one argument. At block the data store is searched based on the at least one argument. For example the data store is searched based on the content of the request to see if any stub handle associated with an active stub in the data store matches any substring of the argument list of the method or function call.

The search may check or touch only those stubs in the data store that have a status of active passing over without analysis those stubs that have an inactive status. In an embodiment when an active stub has been determined to not have a stub handle that matches a substring of the argument list of the function or method request a last used date and time field of the subject stub may be compared to the current date and time. If the difference between the last used date and time and the current time exceeds a predefined threshold time interval the stub may be marked as inactive. In an embodiment the predefined threshold of time interval may be about one month. In another embodiment however a different predefined threshold of time interval may be used for example about two months about two weeks about one week or some other predefined threshold of time interval. In an embodiment the search may also pass over with analysis those stubs that are not defined to have the share level that has been configured for the present testing. For example the tester may have configured the stub handle matcher for example when initializing the ad hoc stubbing tool to only search among stubs having public level share access defined.

At block if there is no match between the argument list and any stub handle of an active stub in the data store the processing proceeds to block . At block the arguments of the request are reformatted in accordance with the expectations of a static stubbing tool for example the static stubbing tool . At block the reformatted request is send to the static stubbing tool . In an embodiment the static stubbing tool responds to the reformatted request and returns a reply message to the application under test.

At block if there is a match between a stub handle of a stub in the data store and a substring of the argument list of the method or function call the processing proceeds to block . At block the matching stub is returned to the application under test for example to the software unit under test . At block optionally a use date associated with the matching stub is refreshed. For example a use date and time field associated with the stub in the data store is updated to reflect the current time and date. It is understood that in an embodiment the processing of method and of method may be performed during a single execution session of the ad hoc stubbing tool .

It is understood that by programming and or loading executable instructions onto the computer system at least one of the CPU the RAM and the ROM are changed transforming the computer system in part into a particular machine or apparatus having the novel functionality taught by the present disclosure. It is fundamental to the electrical engineering and software engineering arts that functionality that can be implemented by loading executable software into a computer can be converted to a hardware implementation by well known design rules. Decisions between implementing a concept in software versus hardware typically hinge on considerations of stability of the design and numbers of units to be produced rather than any issues involved in translating from the software domain to the hardware domain. Generally a design that is still subject to frequent change may be preferred to be implemented in software because re spinning a hardware implementation is more expensive than re spinning a software design. Generally a design that is stable that will be produced in large volume may be preferred to be implemented in hardware for example in an application specific integrated circuit ASIC because for large production runs the hardware implementation may be less expensive than the software implementation. Often a design may be developed and tested in a software form and later transformed by well known design rules to an equivalent hardware implementation in an application specific integrated circuit that hardwires the instructions of the software. In the same manner as a machine controlled by a new ASIC is a particular machine or apparatus likewise a computer that has been programmed and or loaded with executable instructions may be viewed as a particular machine or apparatus.

The secondary storage is typically comprised of one or more disk drives or tape drives and is used for non volatile storage of data and as an over flow data storage device if RAM is not large enough to hold all working data. Secondary storage may be used to store programs which are loaded into RAM when such programs are selected for execution. The ROM is used to store instructions and perhaps data which are read during program execution. ROM is a non volatile memory device which typically has a small memory capacity relative to the larger memory capacity of secondary storage . The RAM is used to store volatile data and perhaps to store instructions. Access to both ROM and RAM is typically faster than to secondary storage . The secondary storage the RAM and or the ROM may be referred to in some contexts as computer readable storage media and or non transitory computer readable media.

I O devices may include printers video monitors liquid crystal displays LCDs touch screen displays keyboards keypads switches dials mice track balls voice recognizers card readers paper tape readers or other well known input devices.

The network connectivity devices may take the form of modems modem banks Ethernet cards universal serial bus USB interface cards serial interfaces token ring cards fiber distributed data interface FDDI cards wireless local area network WLAN cards radio transceiver cards such as code division multiple access CDMA global system for mobile communications GSM long term evolution LTE worldwide interoperability for microwave access WiMAX and or other air interface protocol radio transceiver cards and other well known network devices. These network connectivity devices may enable the processor to communicate with the Internet or one or more intranets. With such a network connection it is contemplated that the processor might receive information from the network or might output information to the network in the course of performing the above described method steps. Such information which is often represented as a sequence of instructions to be executed using processor may be received from and outputted to the network for example in the form of a computer data signal embodied in a carrier wave.

Such information which may include data or instructions to be executed using processor for example may be received from and outputted to the network for example in the form of a computer data baseband signal or signal embodied in a carrier wave. The baseband signal or signal embedded in the carrier wave or other types of signals currently used or hereafter developed may be generated according to several methods well known to one skilled in the art. The baseband signal and or signal embedded in the carrier wave may be referred to in some contexts as a transitory signal.

The processor executes instructions codes computer programs scripts which it accesses from hard disk floppy disk optical disk these various disk based systems may all be considered secondary storage ROM RAM or the network connectivity devices . While only one processor is shown multiple processors may be present. Thus while instructions may be discussed as executed by a processor the instructions may be executed simultaneously serially or otherwise executed by one or multiple processors. Instructions codes computer programs scripts and or data that may be accessed from the secondary storage for example hard drives floppy disks optical disks and or other device the ROM and or the RAM may be referred to in some contexts as non transitory instructions and or non transitory information.

In an embodiment the computer system may comprise two or more computers in communication with each other that collaborate to perform a task. For example but not by way of limitation an application may be partitioned in such a way as to permit concurrent and or parallel processing of the instructions of the application. Alternatively the data processed by the application may be partitioned in such a way as to permit concurrent and or parallel processing of different portions of a data set by the two or more computers. In an embodiment virtualization software may be employed by the computer system to provide the functionality of a number of servers that is not directly bound to the number of computers in the computer system . For example virtualization software may provide twenty virtual servers on four physical computers. In an embodiment the functionality disclosed above may be provided by executing the application and or applications in a cloud computing environment. Cloud computing may comprise providing computing services via a network connection using dynamically scalable computing resources. Cloud computing may be supported at least in part by virtualization software. A cloud computing environment may be established by an enterprise and or may be hired on an as needed basis from a third party provider. Some cloud computing environments may comprise cloud computing resources owned and operated by the enterprise as well as cloud computing resources hired and or leased from a third party provider.

In an embodiment some or all of the functionality disclosed above may be provided as a computer program product. The computer program product may comprise one or more computer readable storage medium having computer usable program code embodied therein to implement the functionality disclosed above. The computer program product may comprise data structures executable instructions and other computer usable program code. The computer program product may be embodied in removable computer storage media and or non removable computer storage media. The removable computer readable storage medium may comprise without limitation a paper tape a magnetic tape magnetic disk an optical disk a solid state memory chip for example analog magnetic tape compact disk read only memory CD ROM disks floppy disks jump drives digital cards multimedia cards and others. The computer program product may be suitable for loading by the computer system at least portions of the contents of the computer program product to the secondary storage to the ROM to the RAM and or to other non volatile memory and volatile memory of the computer system . The processor may process the executable instructions and or data structures in part by directly accessing the computer program product for example by reading from a CD ROM disk inserted into a disk drive peripheral of the computer system . Alternatively the processor may process the executable instructions and or data structures by remotely accessing the computer program product for example by downloading the executable instructions and or data structures from a remote server through the network connectivity devices . The computer program product may comprise instructions that promote the loading and or copying of data data structures files and or executable instructions to the secondary storage to the ROM to the RAM and or to other non volatile memory and volatile memory of the computer system .

In some contexts the secondary storage the ROM and the RAM may be referred to as a non transitory computer readable medium or a computer readable storage media. A dynamic RAM embodiment of the RAM likewise may be referred to as a non transitory computer readable medium in that while the dynamic RAM receives electrical power and is operated in accordance with its design for example during a period of time during which the computer is turned on and operational the dynamic RAM stores information that is written to it. Similarly the processor may comprise an internal RAM an internal ROM a cache memory and or other internal non transitory storage blocks sections or components that may be referred to in some contexts as non transitory computer readable media or computer readable storage media.

While several embodiments have been provided in the present disclosure it should be understood that the disclosed systems and methods may be embodied in many other specific forms without departing from the spirit or scope of the present disclosure. The present examples are to be considered as illustrative and not restrictive and the intention is not to be limited to the details given herein. For example the various elements or components may be combined or integrated in another system or certain features may be omitted or not implemented.

Also techniques systems subsystems and methods described and illustrated in the various embodiments as discrete or separate may be combined or integrated with other systems modules techniques or methods without departing from the scope of the present disclosure. Other items shown or discussed as directly coupled or communicating with each other may be indirectly coupled or communicating through some interface device or intermediate component whether electrically mechanically or otherwise. Other examples of changes substitutions and alterations are ascertainable by one skilled in the art and could be made without departing from the spirit and scope disclosed herein.

