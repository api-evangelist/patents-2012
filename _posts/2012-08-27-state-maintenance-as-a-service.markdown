---

title: State maintenance as a service
abstract: When a stateful service is implemented in a cloud architecture, a state service system receives a user interface definition for a service and generates a client proxy and optionally a storage proxy. The stateful service implements service instances to service requests from clients. The client proxy receives and logs messages from a client in a state service component and a storage proxy logs interactions with a data store. When a service instance serving existing clients is changed, the proxies replay the logged information to the new service instance to recover or maintain state for individual client sessions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09110844&OS=09110844&RS=09110844
owner: Microsoft Technology Licensing, LLC
number: 09110844
owner_city: Redmond
owner_country: US
publication_date: 20120827
---
Some current cloud computing environments provide an architecture in which infrastructure platforms and software are provided as services. In this context infrastructure often refers to computing communication and storage resources. The term platform includes enabling resources that themselves include operating systems and application development as well as deployment services. Software as a service extends service oriented architectures from fine grained operations to richer applications. In general one common trait among cloud layers is that they provide utility computing. That is resources are made available and scaled on demand allowing a pay per use billing model.

One mechanism that many cloud computing architectures use to employ scalability enables scaling out whereby multiple instances of a service each running on its own virtual machine process client requests. In some particular connectionless scenarios affinity between a specific client and a specific server instance for the duration of the session referred to as session affinity is not guaranteed.

One reason that the cloud computing architecture does not always guarantee session affinity such as in connectionless scenarios is that it can generate new service instances when required to service a given workload in a load balanced fashion. It can also remove service instances when the number of service instances can be reduced given the current workload. Therefore when the client is interacting with one service instance and it is taken away and the client requests are forwarded to another service instance the new service instance has no idea of the session state. A similar problem surfaces when requests from a given client are spread across multiple servers for the purpose of load balancing.

This lack of session affinity and session migration can present a problem in attempting to deploy certain applications or services to a cloud environment. In particular where a hosted application or service is a stateful service lack of session affinity can be problematic. By way of one specific example assume that a client is interacting with a flight reservation service in order to book a flight reservation on an airline. This particular task requires several interactions between the client and the service. Those tasks might include identifying a destination city an origination city an airline a flight time etc. In this type of stateful application either the client application on the client s machine or the service instance which the client is interacting with must remember who the client is the state of the application and the state of the session. Application state refers to data maintained by the application for the application. Some such data includes configuration settings policies etc. Application state is normally disassociated from all entities and has a lone binding to the application itself and is thus maintained on the server side. Session state is the state of a particular client server interaction or session . Session state can refer to the state of the service i.e. the state of server objects and or the state of the client i.e. the state of client objects . Session state can be persisted as current values or as a history of modifications to relevant objects. In any case the session state can be stored either at the client at the server that is providing the service or distributed among the two.

Because the cloud computing architecture does not ensure session affinity and or session migration of a given session between a client and a given service instance it can be difficult to migrate stateful applications to a cloud computing architecture. Some have attempted to address this problem by substantially rewriting applications or services to make them stateless. That is the applications or services are rewritten so that the clients maintain state so the server instance need not maintain state. However this often requires a great deal of development and time and is inefficient and error prone.

The discussion above is merely provided for general background information and is not intended to be used as an aid in determining the scope of the claimed subject matter.

When a stateful service is implemented in a cloud architecture a state service system receives a service interface definition for the stateful service and generates a client proxy and an optional storage proxy. The stateful service implements service instances to service requests from clients. The client proxy receives and logs messages from a client in a state service component and a storage proxy logs service interactions with a data store in the state service component as well. When the service instance associated with an existing client changes the proxies replay the logged information to the new service instance to recover or maintain state.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The claimed subject matter is not limited to implementations that solve any or all disadvantages noted in the background.

Processor is illustratively a computer processor with associated memory and timing circuitry not shown . Processor illustratively performs a functional part of system and is activated by and facilitates the functionality of other components and proxies of system . In addition there can be multiple processors in the various components of system or a single processor as shown. Only one processor is shown for system for the sake of simplicity.

In one embodiment system is implemented in a cloud architecture which is described in greater detail below with respect to . In system hosted stateful service is illustratively accessed by client and state service system provides state service component to maintain the session state of various sessions conducted through various service instances for different clients including client . In doing so system facilities the function of client proxy and storage proxy . The detailed operation of system is described in greater detail below. However for the sake of better understanding a brief overview will now be provided.

The client or administrator who wishes to migrate stateful service to system first provides a service interface definition of stateful service to system . Based on that definition system generates client proxy that intercepts messages from client to service and logs them using state service component . During operation of service storage proxy illustratively logs data access operations that are performed against data store . This is also illustratively logged using state service component . Then if a particular service instance such as service instance that client is using becomes unavailable such as if it either fails or is de allocated client proxy and storage proxy replay the stored logged session messages to a new service instance such as service instance that client will next interact with. This enables the new service instance to know the state that the old service instance was in before it failed or before it was shutdown .

In addition the client or administrator can provide monitor component with performance parameters that indicate how the client or administrator wishes to meet the needs of various clients who will be accessing the hosted stateful service . These needs can be described in a service level agreement in terms of Service Level Objectives by way of example. The performance parameters are monitored by monitor component and the parameter levels or a forecast based on the parameter levels is reported to actuator component which decides upon allocating new service instances and in de allocating or retiring service instances based on load and other features for example. That is when monitor component compares the performance of service against the performance parameters and determines that a new service instance likely needs to be generated in the future monitor component sends a signal to actuator component notifying of the extent of change in the performance so the actuator component may invoke adaptation mechanism to generate a new service instance when appropriate. In addition when monitor component compares the performance of service against performance parameters and determines that one of the service instances can likely be shutdown or retired monitor component provides a signal to actuator component informing actuator of the degree of change in performance prompting the actuator component to invoke adaptation mechanism to shutdown a service instance when feasible. Client is illustratively a user agent or program such as a browser a mobile phone application or any other application or program that sends messages to hosted stateful service . Client is on a client device which can be any of a wide variety of different devices such as a cell phone smart phone laptop computer tablet computer desktop computer other mobile device etc.

When a particular client session such as the session with client is being migrated from one instance to another as a result of the monitor component having detected the failure of the associated service instance monitor component provides a signal to client proxy and optionally to the storage proxy to initiate a session state recovery process on the new instance. When the recovery process is complete the new instance knows the state that the old instance was in before the session for client was migrated to the new instance.

In response to receiving the interface definition state service system generates client proxy to implement the interface according to that interface definition. This is indicated by block in . During operation and as discussed in greater detail below client proxy also performs steps such as logging messages from client to state service component .

State service system also optionally generates storage proxy . This is indicated by dashed block in . Storage proxy logs with state service component a history of interactions between an instance of stateful service and data store . Therefore storage proxy is only needed if the stateful service interacts with a data store .

Monitor component then receives selection or other identification of a plurality of different performance parameters of interest from the manager setting up service . This is indicated by block in . For instance the manager may set up monitor component to monitor CPU usage and send notification signals to the actuator component when the CPU usage increases or decreases. The actuator component may then calculate whether a new service instance is needed or whether one can be shut down and invokes adaptation mechanism to generate new service instances of service or shut down service instances of service based on the CPU usage. Receiving CPU usage as a performance parameter is indicated by block in .

Monitor component may also receive memory usage or memory availability and respectively as performance parameters . That is monitor component can report to actuator component memory usage or availability or forecasted memory usage or availability that can be used by actuator component to generate new service instances or de allocate or retire service instances based upon the memory usage or memory availability as described in the previous paragraph.

Another parameter that can be set is monitor sensitivity . That is monitor component illustratively intermittently or periodically monitors or measures the various parameters and reports their values or changes relative to target or threshold values or forecasts based on the values. If the period between measurements is set to be longer then monitor component and the system as a whole is less sensitive to changes in the performance parameters. If the period is set to be shorter then monitor component and the system as a whole is more sensitive to those changes. This parameter the time between measurements of the performance parameters can illustratively be set as well.

Once the manager has selected or otherwise identified which performance parameter are desired for consideration in service the manger or administrator can then provide values for those performance parameters to specify control objectives. For instance if the manager indicates that CPU usage is a performance parameter that should be considered by monitor component then the manager can specify a usage level for CPU usage as a threshold upon which actuator component can take action such as invoke adaptation mechanism to create a new service instance or retire a service instance etc. . Receiving values for acting on performance parameters of interest is indicate by block in .

By way of example the manager or administrator can set usage levels for CPU usage parameter and memory usage parameter . This is indicated by block in . The manager or administrator can also set availability levels for memory availability parameter . This is indicated by block . The administrator or manager can set other values as well and this is indicated by block .

System then configures actuator component and adaptation mechanism and finally monitor component based upon the received performance parameters and their corresponding values. This is indicated by blocks and in . This can be done in a wide variety of different ways. When configuring adaptation mechanism the manager can set preempted allocation and or delayed de allocation and respectively as characteristics of the adaptation mechanism of resource allocation and de allocation. These characteristics can be used so that actuator component allocates or de allocates service instances in a timely manner. For instance if monitor component detects change in any of the performance parameters monitor component can send a signal to actuator component . If pre emptive allocation is used then the actuator component will attempt to invoke adaptation mechanism to create a new instance before all the associated performance parameters have changed. By way of example even if only the CPU usage increases to levels that warrant a new instance even though memory usage might still be acceptable a new instance will be created nonetheless. If pre emptive allocation is not used then new instances are created only when all or some subset of associated performance parameters have reached threshold levels. Since actuator component cannot create a new service instance instantaneously. It may happen that before actuator component and adaptation mechanism create a new service instance monitor component sends another signal to actuator component requesting a parameter value that would indicate that another service instance should be created. However the actuator component will check to determine when monitor last requested actuator component to create a new service instance. If the last request was within a threshold time period e.g. a deferment indicator specifying the minimum allocation time window required to create a new instance actuator component will not create a new service instance. This helps actuator component to avoid creating additional service instances that are not really needed.

By way of example the allocation time window can be set in terms of CPU cycles time etc. If monitor component reports a value to actuator component indicating that actuator should create a new service instance within a certain number of CPU cycles or time actuator component can ignore the second report because it assumes that the service instance that is currently being created will help to eliminate the need for yet another service instance.

The same is true for delayed de allocation of service instances. In one embodiment actuator component keeps track of when it created the last service instance and it does not de allocate a service too quickly thereafter. By way of example if actuator component just created the last new service instance within the last say five minutes and monitor component is now asking actuator component to de allocate one of the service instances actuator component can delay de allocation or retirement of that service instance and can wait a specified amount of time such as an hour or another amount of time between creating or allocating a service instance and de allocating that service instance. This can be done if the delayed de allocation policy or characteristic is set as a characteristic of the adaptation mechanism . Of course other ways of preempting resource allocation and delaying resource de allocation or retirement can be used as well. This builds a certain type of hysteresis into the system so that the system is not over sensitive to performance parameters . Setting the preemption or delay threshold in terms of CPU cycles time or other values where preemptive allocation and delayed de allocation are used is indicated by block in .

In accordance with one embodiment monitor component sets up a table Performance Counters with the structure indicated below in Table 1.

This table records the performance counters of interest for instances of service and optionally proxy components and . As shown in Table 1 the table stores the current value as well as the previous value for each performance counter. It identifies the particular component the instance and the counter type corresponding to those values. The monitor component intermittently e.g. periodically assigns a load based ranking of all instances and that ranking can be written to the instance rank log . One embodiment for actually calculating the rank is described below with respect to .

In addition each of the user input mechanisms can illustratively be a wide variety of user input mechanisms such as text boxes check boxes dropdown menus etc. In addition the user input mechanisms can be actuated in a wide variety of different ways. For instance where the display screen on which display is generated is a touch sensitive screen the user input mechanisms can be actuated by touch gestures using the user s finger a stylus or another touch mechanism. Similarly the mechanisms can be actuated by a point and click device such as a mouse or track ball by a keyboard either a hardware keyboard or a soft keyboard by a key pad by voice inputs or by other user input devices. Those listed are for the sake of example only.

In response in one embodiment of system upon the client initiating contact with client proxy client proxy queries monitor component to obtain the identity of a specific service instance that client proxy should use. Alternatively client proxy can simply read the instance ranking from log to obtain the identity of the best service instance to service a client request. This is indicated by block in .

Before proceeding with the present discussion it should be noted that system includes redundancy in case monitor component or the instance rank log becomes inoperational for any reason. Monitor component periodically logs a ranking of the available service instances in an instance rank log . Therefore should monitor component be inoperational client proxy can simply access instance rank log to identify the most suitable service instance as last ranked by monitor component . It may be likely that that particular service instance is still the most suitable service instance. In an alternate embodiment of the system the client proxy always queries the instance rank log directly. Further if the instance rank log becomes unavailable then client proxy can query monitor component for the best service instance. The step of accessing the instance rank log or monitor component in the event of some type of failure is indicated by block in .

Receiving at client proxy the identity of the most suitable service instance either from monitor component or instance rank log is indicated by block in .

Client proxy also illustratively stores itself the identity of the service instance it has paired a given client with. This is indicated by block . That is there can be a many to one relation between clients i.e. client sessions and client proxy . There can be a one to one relation between the client i.e. client session and a service instance. Client proxy can store a mapping between different clients i.e. distinct client sessions it has paired to available service instances. Therefore when subsequent client requests are received for a given session client proxy uses the same service instance for the given session.

Client proxy can also optionally store a mapping that shows which client session is associated with which service instance in affinity log . In that case if client proxy fails or if another proxy wishes to service client for any other reason the other client proxy that begins conducting the session can access affinity log and continue sending client requests for the given session to the same service instance that was being used by client proxy . This is indicated by block in .

In order to determine which specific service instance is the most suitable monitor component illustratively relies at least in part on performance parameters counters . Therefore the fact that client proxy queries the monitor component or the instance rank log to identify the most suitable service instance for client requests received by client proxy means that client proxy acts as a load balancing router for routing client requests to the most suitable service instance at any given time. By way of example the most suitable service instance may have the least CPU usage and the most available memory. Table 2 illustrates pseudo code for an algorithm where CPU usage and available memory are the two performance parameters that are considered by monitor component .

It can be seen that the service instances are ranked based on those performance parameters and the query set out in Table 3 returns a particular service instance with the lowest rank value for all the performance parameters of interest. One embodiment of a specific algorithm for ranking the service instances is indicated below in Table 3.

In any case once the most suitable service instance has been identified to client proxy client proxy sends requests from client to the identified service instance. This is indicated by block in .

After having received a response for the forwarded request client proxy logs the client requests and optionally the service response in the state data store using state service component . This is done so that these requests can be played back to a new service instance should the current service instance fail or be retired. After having logged the request and response pair the client proxy relays the service response to client . Logging the client requests with state service component is indicated by block in and relaying the response back to client is indicated by client . This preserves the session state for the current session as a message log of the request response interaction between client and the service instance of service . One embodiment for logging the session interactions is indicated in Table 4 below.

Storage proxy intercepts and stores interaction between the identified service instance and the persistent data store in the state data store using state service component . This is indicated by block in . This is done so that should the current service instance fail or be retired storage proxy can replay this interaction to the new service instance so that no database requests to data store are duplicated from the previous instance.

It will be noted that the current service instance that is being used can also store in memory session state information with the state service component . Therefore not only can proxies and store logs in state service component but the service instance currently being used can do that as well. This is indicated by block and that block is shown in phantom because it is optional.

In one embodiment as discussed above resource acquisition is preempted and only enacted after receiving a sufficient number of demands for any resource type such as processor or memory . Resource release or retirement can be delayed and actuated only when necessary scale down signals have been accumulated for all resource types. This helps to ensure prompt scaling up and eventual scaling down in a gradual fashion such as one instance at a time .

Table 5 shows one example of an algorithm for provisioning or allocating resources to achieve timely elasticity in the system.

It can be seen that the algorithm in Table 5 is a rate based calculation. It calculates the sum of current performance counter values and the difference between current and old values of a performance counter computed over all instances. The averaged sum of these two values is set as a demand forecast or prediction . Resource adjustments may happen when the monitor component performs this calculation. For instance monitor component can ask for resource adjustments if the forecast reaches a desired value such as one set by a control objective . The value can be set as a value range with known upper and lower bounds whose width is defined by an applicable service level objective. The nature of the elasticity signal sent to actuator component e.g. either allocate a resource or retire one is determined by the particular upper or lower bound that has been violated. Table 5 shows the algorithm for the available memory and processor time counter types.

Actuator component waits to receive an elasticity signal from monitor component to either add an instance or resource or release or retire an instance or resource . Table 6 shows one algorithm for doing that.

Both the action of acquiring a resource and releasing a resource are accumulative. Therefore resources are acquired or released only after sufficient invocations from monitor component that would amount to the minimum unit of a given resource type. As discussed above resource acquisition can be preempted and enacted for sufficient demand for any resource type such as processor or memory resources and resource release can be delayed and actuated when the necessary scale down signals have been accumulated for all resource types.

It will be noted that service instances themselves can also free up space taken by session objects when feasible. This step is indicated by block in .

In addition client proxy can detect termination of a session and free space occupied by the message logs stored by client proxy in state service component . Storage proxy can also be notified of the termination of a session by the client proxy and free space occupied by database results for the terminated session. This is indicated by block in .

It will be noted that message logs can optionally be kept or even archived long after the associated session has terminated. This can be done for use in debugging or for other purposes.

In any case either client proxy or monitor component detects that the old service instance is no longer available. This is indicated by block in and this can happen in a variety of ways as well. For instance when client proxy attempts to forward a message or request to service instance client proxy can detect at that point that service instance is no longer available. This is indicated by block . Further monitor component can detect this during performance monitoring. This is indicated by block in . Of course there are other ways of detecting that the service instance is no longer available and this is indicated by block in .

In the event that client proxy detects that service instance is no longer available client proxy queries monitor component or instance rank log for a healthy service instance. This is indicated by block in . Monitor component or instance rank log then illustratively identifies a healthy service instance and the most suitable one based on the monitored performance and client proxy in turn notifies storage proxy of a recovery process at the newly identified healthy service instance e.g. service instance . This is indicated by block in . Client proxy accesses state service component and plays logged messages from the session to the healthy service instance . This is indicated by block . Storage proxy if it is being used in the session returns saved database results from the state service component to the new service instance . This is indicated by block in . This places the healthy service instance into the state that service instance was in before it became unavailable. This is indicated by block in .

Once service instance is in the proper state client proxy forwards the client message or request to the healthy service instance . This is indicated by block .

The algorithm shown in TABLE 7 retrieves the session log for the current session obtains a healthy service instance from monitor component establishes session affinity with the healthy service instance and relays the current request to the healthy service instance. A similar algorithm applies to the storage proxy .

If instead of client proxy monitor component detects that the old service instance is no longer available processing proceeds from block in to block . Monitor component sends a recovery signal to all client proxies such as client proxy using the failed service instance . This is indicated by block in . In one embodiment monitor component also sends the recovery signal to storage proxy of the healthy service instance. This is optional and is indicated by block in . In another embodiment of system the monitor component only sends a recovery signal to client proxy which itself later forwards the signal to storage proxy . Once this has been done processing proceeds with respect to blocks discussed above.

The description is intended to include both public cloud computing and private cloud computing. Cloud computing both public and private provides substantially seamless pooling of resources as well as a reduced need to manage and configure underlying hardware infrastructure.

A public cloud is managed by a vendor and typically supports multiple consumers using the same infrastructure. Also a public cloud as opposed to a private cloud can free up the end users from managing the hardware. A private cloud may be managed by the organization itself and the infrastructure is typically not shared with other organizations. The organization still maintains the hardware to some extent such as installations and repairs etc.

The embodiment shown in specifically shows that system is located in cloud which can be public private or a combination where portions are public while others are private . Therefore user uses a client device to access those systems through cloud . Client device can correspond to client shown in or another client.

It will also be noted that system or portions of it can be disposed on a wide variety of different devices. Some of those devices include servers desktop computers laptop computers tablet computers or other mobile devices such as palm top computers cell phones smart phones multimedia players personal digital assistants etc.

Under other embodiments applications or systems like system are received on a removable Secure Digital SD card that is connected to a SD card interface . SD card interface and communication links communicate with a processor which can also embody processors from along a bus that is also connected to memory and input output I O components as well as clock and location system .

I O components in one embodiment are provided to facilitate input and output operations. I O components for various embodiments of the device can include input components such as buttons touch sensors multi touch sensors optical or video sensors voice sensors touch screens proximity sensors microphones tilt sensors and gravity switches and output components such as a display device a speaker and or a printer port. Other I O components can be used as well.

Clock illustratively comprises a real time clock component that outputs a time and date. It can also illustratively provide timing functions for processor .

Location system illustratively includes a component that outputs a current geographical location of device . This can include for instance a global positioning system GPS receiver a LORAN system a dead reckoning system a cellular triangulation system or other positioning system. It can also include for example mapping software or navigation software that generates desired maps navigation routes and other geographic functions.

Memory stores operating system network settings applications application configuration settings data store communication drivers and communication configuration settings . Memory can include all types of tangible volatile and non volatile computer readable memory devices. It can also include computer storage media described below . Memory stores computer readable instructions that when executed by processor cause the processor to perform computer implemented steps or functions according to the instructions. System or the items in data store or data store for example can reside in memory . Similarly device can have a client business system which can run various business applications or embody parts or all of system . Processor can be activated by other components to facilitate their functionality as well.

Examples of the network settings include things such as proxy information Internet connection information and mappings. Application configuration settings include settings that tailor the application for a specific enterprise or user. Communication configuration settings provide parameters for communicating with other computers and include items such as GPRS parameters SMS parameters connection user names and passwords.

Applications can be applications that have previously been stored on the device or applications that are installed during use although these can be part of operating system or hosted external to device as well.

The mobile device of is a personal digital assistant PDA or a multimedia player or a tablet computing device etc. hereinafter referred to as PDA . PDA includes an inductive screen that senses the position of a stylus or other pointers such as a user s finger when the stylus is positioned over the screen. This allows the user to select highlight and move items on the screen as well as draw and write. PDA also includes a number of user input keys or buttons such as button which allow the user to scroll through menu options or other display options which are displayed on display and allow the user to change applications or select user input functions without contacting display . Although not shown PDA can include an internal antenna and an infrared transmitter receiver that allow for wireless communication with other computers as well as connection ports that allow for hardware connections to other computing devices. Such hardware connections are typically made through a cradle that connects to the other computer through a serial or USB port. As such these connections are non network connections. In one embodiment mobile device also includes a SD card slot that accepts a SD card .

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media is different from and does not include a modulated data signal or carrier wave. It includes hardware storage media including both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A visual display or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

