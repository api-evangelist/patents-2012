---

title: Handling breakpoints in an asynchronous debug model
abstract: Breakpoints are handled in an asynchronous debug model by building a queue of basic operations to run a debug application program interface (API). User commands are each broken down into a simple command and placed on the queue. In response to a debug event, a new simple command is generated. If, when a first command on the queue is processed, a thread is not stopped at a location with an installed breakpoint, an operation corresponding to the first command is started, the operation is removed from the queue, and a next operation is started. If the thread is stopped at the location with the breakpoint, the thread performs a hop. When the hop terminates, the first command is removed from the queue. If the first command is a run command, and there is no cause to stop the thread, the run command is moved to the end of the queue.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08898645&OS=08898645&RS=08898645
owner: International Business Machines Corporation
number: 08898645
owner_city: Armonk
owner_country: US
publication_date: 20120405
---
This application is a continuation of U.S. patent application Ser. No. 12 206 771 filed Sep. 9 2008 now U.S. Pat. No. 8 423 970 the disclosure of which is incorporated by reference herein in its entirety.

This invention relates to the field of debugging compiled computer languages and in particular to methods computer program products and hardware products for handling breakpoints in an asynchronous debug model.

In a debugger for compiled languages it is common to implement a location breakpoint such as a source line a code address or a function entry point by substituting a machine instruction that causes a trap for the machine instruction at the breakpoint location. Modern architectures usually make the process of implementing a location breakpoint quite simple by providing an instruction specifically for this purpose. When an application being debugged reaches the trap instruction the debugger receives a signal. If the debugger needs to restart the application the debugger must perform the following sequence of operations herein referred to as a hop 1 replace an original instruction 2 make the application step one instruction machine step and 3 replace the trap instruction.

The foregoing procedure works well if the application has only one thread of execution. If the application has multiple threads the simple implementation of this procedure could result in another thread running through the location while the breakpoint is removed. One possible solution is to prevent the other threads from executing while the trap is removed. However a problem occurs when the debugger is run in an asynchronous debug mode. In a synchronous debugger all threads are stopped when any thread stops. By contrast in an asynchronous debugger only the thread that has the debug event stops. Various solutions exist for addressing the problems of preventing threads from executing and of restarting only a subset of the threads of the application after a debug event occurs. These problems must be solved if one is to construct a debugger for multithreaded applications. A significant problem may occur if many threads are stopped at locations that contain breakpoints and the debugger needs to restart two or more of these threads. This scenario is common in situations where one is attempting to debug the parallel code in an application that uses a technology such as Open Multi Processing OpenMP . OpenMP discussed herein solely for purposes of illustration is an application programming interface API that supports multi platform shared memory multiprocessing programming in C C and Fortran on many architectures including Unix and Microsoft Windows platforms. OpenMP includes a set of compiler directives library routines and environment variables that influence run time behavior. Another illustrative environment is Unified Parallel C UPC .

If the breakpoint is in a loop it is undesirable for the debugger to cause any of the threads in the application to hog the CPU. If one simply hops off the breakpoint and then allows the thread to run it is very likely that the same thread will return to the breakpoint before any of the other threads can be started.

A method for handling breakpoints in an asynchronous debug model builds a queue of basic operations to run a debug application program interface API . Each of a plurality of user commands is broken down into a simple command comprising one of a run command or a machine step and placed on the queue. In response to an occurrence of a debug event the debug event is provided to a user command processing mechanism to generate a new simple command. If when a first command on the queue is processed a thread is not stopped at a location with a first installed breakpoint then an operation corresponding to the first command is started the operation is removed from the queue and a next operation on the queue is started. Otherwise if the thread is stopped at the location with the first installed breakpoint then the thread is given a command to perform a hop operation such that any other threads are frozen. When the hop operation terminates the command is removed from the queue. If the command is a run command and the thread has not been stopped for another reason such as a second installed breakpoint the run command is moved to the end of the queue such that the thread associated with the hop operation cannot block a next thread to be run. The next operation on the queue corresponding to a next simple command is then processed.

Computer program products and hardware products corresponding to the above summarized methods are also described and claimed herein. Other methods hardware products and or computer program products according to embodiments will be or become apparent to one with skill in the art upon review of the following drawings and detailed description. It is intended that all such additional methods hardware products and or computer program products be included within this description be within the scope of the present invention and be protected by the accompanying claims.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

The detailed description explains the preferred embodiments of the invention together with advantages and features by way of example with reference to the drawings.

Next a command on the queue is processed at block . At block a test is performed to ascertain whether or not a thread is stopped at a location with an installed breakpoint. If the thread is not stopped at a location with an installed breakpoint the command is processed according to a sequence of operations commencing at block . Otherwise if the thread is stopped at a location with an installed breakpoint the command is processed according to a sequence of operations commencing at block . From block the procedure advances to block where an operation corresponding to the command is started the operation is removed from the queue block and a next operation on the queue is started block . The procedure loops back to block .

If the thread is stopped at a location with an installed breakpoint block the thread is given a command to perform a hop operation block such that any other threads are frozen. The hop operation may include the following sequence of operations 1 replace an original instruction 2 make the API step one instruction machine step and 3 replace a trap instruction. When the hop operation terminates the command is removed from the queue block . If the command is a run command and the thread is not stopped i.e. there is no cause to stop the thread the run command is moved to the end of the queue such that the thread associated with the hop operation cannot block the next thread to run block . Illustratively the breakpoint referred to previously may be a location breakpoint such as a source line a code address or a function entry point. The program continues to block to start the next operation on the queue and the program then loops back to block .

The computer includes a processor that processes information for handling breakpoints in an asynchronous debug model by building a queue of basic operations to run a debug API wherein the information is represented e.g. on the signal bearing medium and communicated to the computer via the I O wherein the processor saves information as appropriate into a memory . This information may also be saved into the memory e.g. via communication with the I O and the signal bearing medium .

The processor executes a program comprising instructions for handling breakpoints in an asynchronous debug model by building a queue of basic operations to run a debug API. The instructions build the queue by breaking down each of a plurality of user commands into a simple command comprising one of a run command or a machine step and placed on the queue. In response to an occurrence of a debug event the debug event is given back to a user command processing mechanism to generate a new simple command. If when a first command on the queue is processed a thread is not stopped at a location with an installed breakpoint then an operation corresponding to the first command is started the operation is removed from the queue and a next operation on the queue is started. Otherwise if the thread is stopped at the location with the installed breakpoint then the thread is given a command to perform a hop operation such that any other threads are frozen. When the hop operation terminates the first command is removed from the queue. If the first command is a run command and there is no cause to stop the thread the run command is moved to the end of the queue such that the thread associated with the hop operation cannot block a next thread to be run. The next operation on the queue corresponding to a next simple command is then processed. The foregoing steps may be implemented as a program or sequence of instructions within the memory or on a signal bearing medium such as the medium and executed by the processor .

The capabilities of the present invention can be implemented in software firmware hardware or some combination thereof. As one example one or more aspects of the present invention can be included in an article of manufacture e.g. one or more computer program products having for instance computer usable media. The media has embodied therein for instance computer readable program code means for providing and facilitating the capabilities of the present invention. The article of manufacture can be included as a part of a computer system or sold separately. Additionally at least one program storage device readable by a machine tangibly embodying at least one program of instructions executable by the machine to perform the capabilities of the present invention can be provided.

The flow diagrams depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention

The foregoing exemplary embodiments may be provided in the form of computer implemented processes and apparatuses for practicing those processes. The exemplary embodiments can also be provided in the form of computer program code containing instructions embodied in tangible media such as floppy diskettes CD ROMs hard drives or any other computer readable storage medium wherein when the computer program code is loaded into and executed by a computer the computer becomes an apparatus for practicing the exemplary embodiments. The exemplary embodiments can also be provided in the form of computer program code for example whether stored in a storage medium loaded into and or executed by a computer or transmitted over some transmission medium loaded into and or executed by a computer or transmitted over some transmission medium such as over electrical wiring or cabling through fiber optics or via electromagnetic radiation wherein when the computer program code is loaded into and executed by a computer the computer becomes an apparatus for practicing the exemplary embodiments. When implemented on a general purpose microprocessor the computer program code segments execute specific microprocessor machine instructions. The computer program code could be implemented using electronic logic circuits or a microchip.

While the invention has been described with reference to exemplary embodiments it will be understood by those skilled in the art that various changes may be made and equivalents may be substituted for elements thereof without departing from the scope of the invention. In addition many modifications may be made to adapt a particular situation or material to the teachings of the invention without departing from the essential scope thereof. Therefore it is intended that the invention not be limited to the particular embodiments disclosed for carrying out this invention but that the invention will include all embodiments falling within the scope of the claims. Moreover the use of the terms first second etc. do not denote any order or importance but rather the terms first second etc. are used to distinguish one element from another. Furthermore the use of the terms a an etc. do not denote a limitation of quantity but rather denote the presence of at least one of the referenced item.

