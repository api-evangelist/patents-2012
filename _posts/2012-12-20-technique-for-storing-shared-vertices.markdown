---

title: Technique for storing shared vertices
abstract: A graphics processing unit includes a set of geometry processing units each configured to process graphics primitives in parallel with one another. A given geometry processing unit generates one or more graphics primitives or geometry objects and buffers the associated vertex data locally. The geometry processing unit also buffers different sets of indices to those vertices, where each such set represents a different graphics primitive or geometry object. The geometry processing units may then stream the buffered vertices and indices to global buffers in parallel with one another. A stream output synchronization unit coordinates the parallel streaming of vertices and indices by providing each geometry processing unit with a different base address within a global vertex buffer where vertices may be written. The stream output synchronization unit also provides each geometry processing unit with a different base address within a global index buffer where indices may be written.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09418616&OS=09418616&RS=09418616
owner: NVIDIA CORPORATION
number: 09418616
owner_city: Santa Clara
owner_country: US
publication_date: 20121220
---
The present invention generally relates to processing graphics data and more specifically to a technique for storing shared vertices.

A conventional graphics processing unit GPU typically implements a graphics processing pipeline that includes a sequence of graphics processing stages. At each stage in the graphics processing pipeline the GPU may perform one or more different graphics oriented processing operations. For example at one stage the GPU could assemble a set of primitives that represent a graphics scene and at a subsequent stage the GPU could perform shading operations with vertices associated with that set of primitives. Finally the GPU could rasterize those vertices into pixels that represent the graphics scene.

A GPU that implements a conventional graphics processing pipeline such as that described in the above example typically includes a geometry shading unit configured to perform shading operations with vertices and geometry based information and to then output one or more graphics primitives or one or more geometry objects of relatively greater complexity to a subsequent unit for rasterization. For each generated graphics primitive or geometry object the geometry shading unit outputs vertex data corresponding to each vertex associated with that graphics primitive or geometry object. For example when processing a triangle the geometry shading unit would output vertex data for each of the three vertices of that triangle. Vertex data for a given vertex could describe the position of the vertex within the scene coverage data associated with the vertex or a set of attributes associated with the vertex among other things. When generating graphics primitives or geometry objects the geometry shading unit typically stores each generated graphics primitive or each graphics primitive making up all or a portion of a generated geometry object as the set of vertices associated with that primitive and the vertex data corresponding to each vertex in that set.

Again in some situations the geometry shading unit may generate a geometry object that includes a collection of interconnected graphics primitives that share vertices. The geometry object could be e.g. a fan a strip or a mesh type of geometry object. For example a given graphics scene could include numerous individual graphics primitives interconnected in a fan a strip or a mesh to create the appearance of a surface having an arbitrary shape. Each graphics primitive within the surface could be connected to a neighboring graphics primitive by one or more vertices shared between the two graphics primitives. In other situations multiple geometry objects such as triangles or strips that share one or more common vertices may be generated by the geometry shading unit.

In these different situations the geometry shading unit typically stores redundant copies of the vertex data associated with each vertex shared between graphics primitives or geometry objects. However this approach is problematic because a typical graphics scene may include millions of shared vertices. Consequently a conventional geometry shading unit may store millions of copies of redundant data. Processing this redundant data consumes GPU resources inefficiently and may reduce the speed with which a graphics scene may be rendered.

Accordingly what is needed in the art is an improved technique for processing vertices shared between graphics primitives or geometry objects within a graphics scene.

One embodiment of the present invention sets forth a computer implemented method for buffering data associated with geometry objects. The method includes receiving a first geometry object generating a first set of vertices associated with the first geometry object and storing a first set of indices within a first entry in a local index buffer where each index in the first set of indices references a different vertex in the first set of vertices and where the first entry corresponds to a graphics primitive or a geometry object associated with the first set of vertices.

One advantage of the disclosed approach is that redundant copies of vertex data are not stored in either the vertex buffers local to the different geometry shading units or the global vertex buffer since the vertex data is indexed thereby conserving processing unit resources and increasing overall processing efficiency.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

A switch provides connections between I O bridge and other components such as a network adapter and various add in cards and . Other components not explicitly shown including universal serial bus USB or other port connections compact disc CD drives digital versatile disc DVD drives film recording devices and the like may also be connected to I O bridge . The various communication paths shown in including the specifically named communication paths and may be implemented using any suitable protocols such as PCI Express AGP Accelerated Graphics Port HyperTransport or any other bus or point to point communication protocol s and connections between different devices may use different protocols as is known in the art.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements in a single subsystem such as joining the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip instead of existing as one or more discrete devices. Large embodiments may include two or more CPUs and two or more parallel processing subsystems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to as well as in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various operations related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and the second communication path interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have one or more dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs in parallel processing subsystem may output data to display device or each PPU in parallel processing subsystem may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a data structure not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . A pointer to each data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from one or more pushbuffers and then executes commands asynchronously relative to the operation of CPU . Execution priorities may be specified for each pushbuffer by an application program via the device driver to control scheduling of the different pushbuffers.

Referring back now to as well as each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI Express link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the command stream stored in the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed from a work distribution unit within a task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in the command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices of data to be processed as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule execution of the processing task. Processing tasks can also be received from the processing cluster array . Optionally the TMD can include a parameter that controls whether the TMD is added to the head or the tail for a list of processing tasks or list of pointers to the processing tasks thereby providing another level of control over priority.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of dynamic random access memory DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons of ordinary skill in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI Express connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Multiple processing tasks may be executed concurrently on the GPCs and a processing task may generate one or more child processing tasks during execution. The task work unit receives the tasks and dynamically schedules the processing tasks and child processing tasks for execution by the GPCs .

Operation of GPC is advantageously controlled via a pipeline manager not shown that distributes processing tasks to one or more streaming multiprocessors SMs where each SM configured to process one or more thread groups. Each SM includes an instruction L1 cache that is configured to receive instructions and constants from memory via an L1.5 cache not shown within the GPC . A warp scheduler and instruction unit receives instructions and constants from the instruction L1 cache and controls local register file and SM functional units according to the instructions and constants. The SM functional units include N exec execution or processing units and P load store units LSU . The SM functional units may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SM . A thread group may include fewer threads than the number of processing engines within the SM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SM in which case processing will take place over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that a system that in a GPC that includes M streaming multiprocessors up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SM and m is the number of thread groups simultaneously active within the SM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during the thread s execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAS the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each thread s position. In one embodiment special registers include one register per thread or per exec unit within SM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all threads that execute the same processing task represented by a TMD or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs or queue position if the TMD encodes a queue task instead of a grid task and an identifier of the TMD to which the CTA is assigned.

If the TMD is a grid TMD execution of the TMD causes a fixed number of CTAS to be launched and executed to process the fixed amount of data stored in the queue . The number of CTAS is specified as the product of the grid width height and depth. The fixed amount of data may be stored in the TMD or the TMD may store a pointer to the data that will be processed by the CTAS. The TMD also stores a starting address of the program that is executed by the CTAS.

If the TMD is a queue TMD then a queue feature of the TMD is used meaning that the amount of data to be processed is not necessarily fixed. Queue entries store data for processing by the CTAS assigned to the TMD . The queue entries may also represent a child task that is generated by another TMD during execution of a thread thereby providing nested parallelism. Typically execution of the thread or CTA that includes the thread is suspended until execution of the child task completes. The queue may be stored in the TMD or separately from the TMD in which case the TMD stores a queue pointer to the queue. Advantageously data generated by the child task may be written to the queue while the TMD representing the child task is executing. The queue may be implemented as a circular queue so that the total amount of data is not limited to the size of the queue.

CTAS that belong to a grid have implicit grid width height and depth parameters indicating the position of the respective CTA within the grid. Special registers are written during initialization in response to commands received via front end from device driver and do not change during execution of a processing task. The front end schedules each processing task for execution. Each CTA is associated with a specific TMD for concurrent execution of one or more tasks. Additionally a single GPC may execute multiple tasks concurrently.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any thread within the same CTA or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SM to begin execution of a task that uses these parameters. Any thread within any CTA or any exec unit within SM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the thread to which the register is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers. Additionally a uniform L1 cache stores uniform or constant values for each lane of the N exec units and P load store units LSU .

Shared memory is accessible to threads within a single CTA in other words any location in shared memory is accessible to any thread within the same CTA or to any processing engine within SM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and task ID as well as CTA and grid dimensions or queue position implementing portions of the special registers. Each LSU in SM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 cache in each SM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to the shared memory and the L1 cache via a memory and cache interconnect .

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SMs may be included within a GPC . Further as shown in a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches to execute tasks for one or more application programs.

Persons of ordinary skill in the art will understand that the architecture described in in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

Data assembler processing unit collects vertex data for high order surfaces primitives and the like and outputs the vertex data including the vertex attributes to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in L1 cache parallel processing memory or system memory by data assembler for use in processing the vertex data.

Primitive assembler receives vertex attributes from vertex processing unit reading stored vertex attributes as needed and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles line segments points and the like. Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. Geometry processing unit also may be programmed to generate additional graphics primitives or one or more geometry objects made up of one or more graphics primitives based on the graphics primitives received from primitive assembler .

In some embodiments geometry processing unit may also add or delete elements in the geometry stream. Geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit . Geometry processing unit may read data that is stored in parallel processing memory or system memory for use in processing the geometry data. Viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a rasterizer .

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally rasterizer may be configured to perform z culling and other z based optimizations.

Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to raster operations unit . Fragment processing unit may read data that is stored in parallel processing memory or system memory for use in processing the fragment data. Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

Raster operations unit is a processing unit that performs raster operations such as stencil z test blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory e.g. parallel processing memory and or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In some embodiments of the present invention raster operations unit is configured to compress z or color data that is written to memory and decompress z or color data that is read from memory.

As is shown geometry shading unit includes geometry shading unit buffer that includes local index buffer and local vertex buffer and stream output unit . Likewise geometry shading unit includes geometry shading unit buffer that includes local index buffer and local vertex buffer and stream output unit and geometry shading unit N includes geometry shading unit N buffer N that includes local index buffer N and local vertex buffer and stream output unit N. In the following description multiple instances of like objects are denoted with reference numbers identifying the object and hyphenated reference numbers identifying the instance where needed.

Geometry processing unit is configured to process graphics primitives or geometry objects and to generate one or more graphics primitives or one or more graphic objects made up of one or more graphics primitives. Graphics processing unit is further configured to then stream vertex data and index information associated with the generated graphics primitives or geometry objects to global vertex buffer and global index buffer respectively. SSYNC unit is configured to coordinate the streaming of this data across the different geometry processing units .

Geometry processing unit may be implemented by SM shown in and may represent a processing stage within graphics processing pipeline shown in . In one embodiment geometry processing unit is similar to geometry processing unit shown in . Geometry shading unit within geometry processing unit is configured to receive graphics primitives or geometry objects from an upstream processing unit such as e.g. primitive assembler shown in . Graphics primitives may represent e.g. triangles rectangles line segments points or other types of graphics primitives. Geometry objects may represent higher level graphics constructs that can be comprised of a single graphics primitive or can be broken down into a collection of graphics primitives where that collection could represent a strip fan or mesh type geometry object. In various embodiments graphics primitives or geometry objects may represent a portion of a graphics scene or may correspond to a particular region of a display screen associated with geometry processing unit .

When geometry processing unit receives a graphics primitive or geometry object geometry shading unit is configured to perform one or more geometry shading operations on vertices and other information associated with that graphics primitive or geometry object . The vertices and other information associated with a given graphics primitive or geometry object could represent e.g. the corners of a triangle or other polygon. Those vertices and other information may also include vertex attributes associated with the graphics primitive or geometry object as well as other types of vertex data. Geometry shading unit is configured to store the vertex data associated with the one or more graphics primitives or one or more geometry objects generated by geometry shading unit within local vertex buffer .

In situations where geometry shading unit generates different graphics primitives or geometry objects that share a given vertex such as when subdividing a geometry object into smaller graphics primitives geometry shading unit is configured to buffer the shared vertex and associated vertex data just once within local vertex buffer . With this approach geometry shading unit advantageously avoids buffering redundant copies of vertices and the associated vertex data. For example geometry shading unit could receive a single graphics primitive and then generate a collection of graphics primitives based on the graphics primitive that share vertices with one another. The collection of graphics primitives generated could be a strip fan or mesh construct. In this situation geometry shading unit stores each unique vertex just one time within local vertex buffer .

Geometry shading unit is also configured to maintain connectivity information for a graphics primitive by generating a set of indices into the local vertex buffer that references the vertices associated with the graphics primitives or graphics objects generated by geometry shading unit . In one embodiment geometry shading unit may determine that a given vertex already resides within local vertex buffer and may then generate the set of indices to include an index that references the given vertex i.e. without re storing that vertex within local vertex buffer . Geometry shading unit is configured to store the set of indices for each generated graphics primitive or geometry object within an entry in local index buffer . In general each index within an entry in local index buffer may correspond to a different vertex stored in local vertex buffer and a set of indices stored within an entry in local index buffer may correspond to a particular graphics primitive a particular geometry object or any collection of vertices that represent an object within the graphics scene. For example geometry shading unit may also store sets of indices that represent higher level geometry objects such as large polygons that can be broken down into multiple interconnected graphics primitives including strip fan and mesh type objects.

A set of indices within local index buffer may reference different vertices within local vertex buffer directly i.e. by specifying various addresses within local vertex buffer . Alternatively the set of indices may also reference the different vertices by specifying a local offset within local vertex buffer or a local index within local vertex buffer .

At various times stream output unit that is coupled to buffer may stream the vertices stored within local vertex buffer and the indices stored within local index buffer to global vertex buffer and to global index buffer respectively. Before doing so however stream output unit is configured to first determine the number of vertices stored in local vertex buffer as well as the number of indices stored in local index buffer . Stream output unit then communicates these numbers to SSYNC unit .

SSYNC unit responds to stream output unit with a base address within global vertex buffer and a base address within global index buffer . The base address within global vertex buffer represents a position within that buffer where stream output unit may safely write the number of vertices communicated to SSYNC unit by stream output unit . Likewise the base address within global index buffer represents a position within that buffer where stream output unit may safely write the number of indices communicated to SSYNC unit by stream output unit .

SSYNC unit is configured to generate these base addresses using a technique described in greater detail below. Upon receiving the base address within global vertex buffer stream output unit may then copy the vertices within local vertex buffer to global vertex buffer starting at that base address. Further upon receiving the base address within global index buffer stream output unit may then copy the indices within local index buffer to global index buffer starting at that base address.

When copying indices from local index buffer to global index buffer stream output unit is configured to update those indices to reflect the new positions of the referenced vertices within global vertex buffer . In one embodiment stream output unit increments each index by a value equal to the base address within global vertex buffer .

With the above approach each of geometry processing units to N is configured to process graphics primitives or geometry objects in parallel with one another and to then buffer the results of that processing as well as the associated indices within local buffers. The locally buffered vertices and indices data may then be streamed to global buffers.

As mentioned above SSYNC unit is configured to coordinate the streaming of vertices and indices to global vertex buffer and global index buffer respectively between different geometry processing units . In practice SSYNC unit is configured to service each of stream output units to N according to a sequence. In doing so SSYNC unit communicates a base address within global vertex buffer and a base address within global index buffer to each stream output unit to N according to that sequence. In one embodiment the sequence is an application programming interface API order. In a further embodiment the sequence is defined by a software application executing on geometry processing unit and a programmer of that software application determines the sequence.

SSYNC unit is configured to provide a different base address within global index buffer and a different base address within local index buffer to each stream output unit when sequentially servicing those stream output units . Accordingly each different stream output unit is capable of writing vertices and indices to a different portion of global vertex buffer and global index buffer respectively. In one embodiment each stream output unit is capable of writing vertices and indices to global vertex buffer and global index buffer respectively in parallel with other stream output units writing vertices and indices to those buffers.

SSYNC unit determines a base address within global vertex buffer for a given stream output unit in the sequence based on the number of vertices written to global vertex buffer by a previous stream output unit in the sequence. More specifically SSYNC unit maintains a current base address within global vertex buffer that indicates a location within global vertex buffer where vertices may be safely written. Upon receiving data indicating the number of vertices to be written by a particular stream output unit to global vertex buffer SSYNC unit transmits the current base address within global vertex buffer to that stream output unit for use when writing vertices. SSYNC unit then updates the current base address within global vertex buffer based on that number of vertices and based on the size of those vertices. Subsequently the updated base address within global vertex buffer represents a position within that buffer where a subsequent stream output unit in the sequence of stream output units may safely write vertex data.

SSYNC unit also determines a base address within global index buffer for a given stream output unit in the sequence based on the number of indices written to global index buffer by a previous stream output unit in the sequence. More specifically SSYNC unit maintains a current base address within global index buffer that indicates a location within global index buffer where indices may be safely written. Upon receiving data indicating the number of indices to be written by a particular stream output unit to global index buffer SSYNC unit transmits the current base address within global index buffer to that stream output unit for use when writing indices. SSYNC unit then updates the current base address within global index buffer based on that number of indices and based on the size of those indices. Subsequently the updated base address within global index buffer represents a position within that buffer where a subsequent stream output unit in the sequence of stream output units may safely write index data.

By implementing the approach described above SSYNC unit is configured to maintain a current base address within global vertex buffer and a current base address within global index buffer that can be provided to a given stream output unit . SSYNC unit is also configured to then update those current base addresses in order to accommodate a subsequent stream output unit attempting to stream vertices and indices to global vertex buffer and global index buffer .

Various approaches for implementing the functionality described herein are described in greater detail below in conjunction with with reference to different flow diagrams. The functionality described herein is also illustrated below by way of example in conjunction with .

As shown a method begins at step where geometry processing unit receives a graphics primitive or geometry object . At step geometry shading unit within geometry processing unit performs one or more geometry shading operations on the graphics primitive or geometry object . In so doing geometry shading unit may be programmed to generate additional graphics primitives or one or more geometry objects made up of one or more graphics primitives based on the received graphics primitive or geometry object . In one embodiment for example geometry processing unit may receive a geometry object and then generate multiple graphics primitives by subdividing the geometry object into a collection of interconnected graphics primitives that share one or more vertices with one another.

At step geometry shading unit stores the vertices associated with graphics primitives or geometry objects generated by geometry shading unit within local vertex buffer . In situations where a particular generated graphics primitive or geometry object is associated with a vertex already stored within local vertex buffer e.g. that vertex is shared with another generated graphics primitive or geometry object geometry shading unit may skip step with respect to that vertex. With this approach geometry shading unit advantageously avoids buffering redundant copies of the generated vertices and their associated vertex data.

At step geometry shading unit stores indices within local index buffer that reference vertices within local vertex buffer . The indices within local index buffer may reference different vertices within local vertex buffer directly i.e. by specifying various addresses within local vertex buffer . Alternatively the indices may also reference the different vertices by specifying a local offset within local vertex buffer or a local index within local vertex buffer . In general the indices stored within local index buffer at step represent the vertices corresponding to the graphics primitives or geometry objects generated at step . The method then ends.

By implementing the approach described above vertices generated by a geometry processing unit that are associated with generated primitives or geometry objects can be buffered locally and indexed locally thereby preventing a situation where multiple copies of vertices and associated vertex data are stored redundantly. In addition when a system includes multiple geometry processing unit each of those geometry processing units can generate graphics primitives or geometry objects and then buffer the vertices and indices associated with those graphics primitives or geometry objects locally in parallel with other geometry processing units . Persons skilled in the art will recognize that the method could also be applied to processing a geometry object or any other higher level graphics construct that includes a collection of vertices. For example the method could be applied to store vertices and associated indices for a polygon where that polygon could be broken down into a collection of interconnected graphics primitives that share one or more vertices.

Each of geometry processing units is also configured to communicate with SSYNC unit in order to coordinate the streaming of vertices and indices to global vertex buffer and global index buffer respectively as discussed in greater detail below in conjunction with .

As shown a method begins at step where stream output unit within geometry processing unit determines the number of vertices within local vertex buffer and the number of indices within local index buffer . The vertices and indices within local vertex buffer and local index buffer respectively could be introduced into those buffers by implementing the method discussed above in conjunction with .

At step stream output unit communicates the number of vertices within local vertex buffer and the number of indices within local index buffer to SSYNC unit . At step stream output unit receives a base address within global vertex buffer and a base address within global index buffer from SSYNC unit . The base address within global vertex buffer represents a position within that buffer where stream output unit may safely write the number of vertices communicated to SSYNC unit by stream output unit . Likewise the base address within global index buffer represents a position within that buffer where stream output unit may safely write the number of indices communicated to SSYNC unit by stream output unit . SSYNC unit is configured to generate these base addresses by implementing the technique described above in conjunction with also described below in conjunction with .

At step stream output unit streams vertices from local vertex buffer to global vertex buffer starting at the base address within global vertex buffer provided by SSYNC unit . At step stream output unit streams indices from local index buffer to global index buffer starting at the base address within global index buffer provided by SSYNC unit . In doing so stream output unit is configured to update those indices to reflect the new positions of the referenced vertices within global vertex buffer . In one embodiment stream output unit increments each index by a value equal to the base address within global vertex buffer provided by SSYNC unit at step . The method then ends.

By implementing the approach described above each of geometry processing units to N is configured to stream locally buffered vertices and indices to global vertex buffer and global index buffer respectively. In addition each such geometry processing unit may stream vertices and indices to global vertex buffer and global index buffer respectively in parallel within other geometry processing units . A technique that may be implemented by SSYNC unit to provide base addresses within those buffers to geometry processing units is described below in conjunction with .

As shown a method begins at step where SSYNC unit receives data from stream output unit within geometry processing unit that specifies the number of vertices stored within local vertex buffer and the number of indices stored within local index buffer . At step SSYNC unit transmits the current base address within global vertex buffer and the current base address within global index buffer to stream output unit . The base address within global vertex buffer represents a position within that buffer where stream output unit may safely write the number of vertices communicated to SSYNC unit by stream output unit . Likewise the base address within global index buffer represents a position within that buffer where stream output unit may safely write the number of indices communicated to SSYNC unit by stream output unit .

At step SSYNC unit updates the current base address within global vertex buffer based on the number of vertices specified by stream output unit . SSYNC unit may also update the current base address within global vertex buffer based on the size of those vertices. At step SSYNC unit updates the current base address within global index buffer based on the number of indices specified by stream output unit . SSYNC unit may also update the current base address within global index buffer based on the size of those indices. The method then ends.

By implementing the approach described above SSYNC unit is capable of maintaining base addresses within global vertex buffer and global index buffer that represent addresses within those buffers where data may be safely written. When servicing geometry processing units sequentially SSYNC unit is thus capable of providing different base addresses within those buffers to each geometry processing unit in the sequence.

The various techniques described above in conjunction with are illustrated by way of example in conjunction with .

Geometry processing unit is configured to receive vertex data and related geometry information associated with a graphics primitive or geometry object . Geometry shading unit then generates geometry object that represents a strip of triangles where vertices A B C D and E are vertices associated with those triangles. Geometry shading unit is further configured to then store those vertices and associated vertex data within local vertex buffer . Since different triangles associated with geometry object share vertices those shared vertices may only be included within local vertex buffer just once. Geometry shading unit is also configured to store indices that reference those vertices within local index buffer as is shown. In situations where a given vertex already resides within local vertex buffer geometry shading unit may introduce an index to that vertex into local index buffer without re storing that vertex in local vertex buffer thereby avoiding redundant copies of vertex data. In the exemplary scenario discussed herein geometry shading unit generates triangles from geometry object based on a clockwise or counter clockwise winding direction. Those skilled in the art will recognize that geometry shading unit could generate triangles and or other graphics primitives using any particular winding direction or combination of winding directions.

In addition geometry shading unit may also introduce a set of indices that represent a triangle not included within geometry object e.g. triangle ACD corresponding to indices 0 2 and 3 . In one embodiment geometry shading unit is configured to generate the different triangles formed by vertices A B C D and E by subdividing a complex geometry object into those different triangles. In another embodiment geometry shading unit may be configured to generate the different triangles formed by vertices A B C D and E by replicating a simple geometry object such as a single triangle. Geometry shading unit may also store indices within local index buffer that represent geometry object as a whole i.e. indices that represent all of vertices A B C D and E.

Like geometry processing unit geometry processing unit is configured to receive vertex data and related geometry information associated with a graphics primitive or geometry object . Geometry shading unit then generates geometry object that represent a strip of triangles where vertices J K L M N and O are vertices associated with those triangles. Geometry shading unit is further configured to then store those vertices and associated vertex data within local vertex buffer . Since different triangles associated with geometry object share vertices those shared vertices may only be included within local vertex buffer just once. Geometry shading unit is also configured to store indices that reference those vertices within local index buffer as is shown. In situations where a given vertex already resides within local vertex buffer geometry shading unit may introduce an index to that vertex into local index buffer without re storing that vertex in local vertex buffer thereby avoiding redundant copies of vertex data. In the exemplary scenario discussed herein geometry shading unit generates triangles from geometry object based on a clockwise or counter clockwise winding direction. Those skilled in the art will recognize that geometry shading unit could generate triangles and or other graphics primitives using any particular winding direction or combination of winding directions.

In one embodiment geometry shading unit is configured to generate the different triangles formed by vertices J K L M N and O by subdividing a complex geometry object into those different triangles. In another embodiment geometry shading unit may be configured to generate the different triangles formed by vertices J K L M N and O by replicating a simple geometry object such as a single triangle. Geometry shading unit may also store indices within local index buffer that represent geometry object as a whole i.e. indices that represent all of vertices J K L M N and O.

Stream output units and shown in may then stream the vertices and indices stored in the respective local vertex buffer and local index buffer to global vertex buffer and global index buffer respectively based on base addresses provided by SSYNC unit . An exemplary global vertex buffer and an exemplary global index buffer are shown in .

As shown global vertex buffer includes each different vertex associated with graphics primitives and shown in . Specifically global vertex buffer includes vertices A B C D E corresponding to graphics primitives as well as vertices J K L M N and O corresponding to graphics primitives . Geometry processing unit is configured to write vertices A E to global index buffer based on a base address received from SSYNC unit . Likewise geometry processing unit is configured to write vertices J O to global index buffer based on a different base address received from SSYNC unit . As also shown global index buffer includes indices to the vertices stored within global vertex buffer . Geometry processing units and are configured to write these indices to global index buffer based on the indices stored within local index buffers and respectively and based on base addresses received from SSYNC unit .

In this example SSYNC unit services geometry processing units and sequentially starting with geometry processing unit . SSYNC unit receives data from geometry processing unit that indicates the number of vertices A E to be written to global vertex buffer that number being 5 in this example . SSYNC unit responds to geometry processing unit with the current base address within global vertex buffer . Initially SSYNC unit maintains an initial base address within global vertex buffer of 0. SSYNC unit then updates that current base address based on the number of vertices geometry processing unit will write to global vertex buffer in order to reflect a new base address within global vertex buffer where additional vertices and associated data may be safely written in this example a base address of 5 .

After receiving the data from geometry processing unit indicating the number of vertices A E SSYNC unit may then receive additional data from geometry processing unit that indicates the number of different sets of indices to be written to global index buffer that number being 4 in this example . Again each set of indices may correspond to a different triangle within graphics primitives . SSYNC unit responds to geometry processing unit with the current base address within global index buffer . Initially SSYNC unit maintains an initial base address within global index buffer of 0. SSYNC unit then updates that current base address based on the number of indices geometry processing unit will write to global index buffer in order to reflect a new base address within global index buffer where additional indices may be safely written in this example a base address of 4 .

Subsequently SSYNC unit may service geometry processing unit . SSYNC unit receives data from geometry processing unit that indicates the number of vertices J O to be written to global vertex buffer that number being 6 in this example . SSYNC unit responds to geometry processing unit with the current base address within global vertex buffer of 6. SSYNC unit then updates that current base address based on the number of vertices geometry processing unit will write to global vertex buffer in order to reflect a new base address within global vertex buffer where vertices and associated data may be safely written in this example a base address of 11 .

After receiving the data from geometry processing unit indicating the number of vertices J O SSYNC unit may then receive additional data from geometry processing unit that indicates the number of different sets of indices to be written to global index buffer that number being 4 in this example . Again each set of indices may correspond to a different triangle within graphics primitives . SSYNC unit responds to geometry processing unit with the current base address within global index buffer of 4. SSYNC unit then updates that current base address based on the number of indices geometry processing unit will write to global index buffer in order to reflect a new base address within global index buffer where additional indices may be safely written in this example a base address of 8 .

When geometry processing units or write indices to global index buffer according to the technique described above each of those geometry processing units is configured to update the indices based on the base address within global vertex buffer received from SSYNC unit . Accordingly geometry processing unit may increment each index by 0 the base address within global vertex buffer provided by SSYNC unit when servicing geometry processing unit . Likewise geometry processing unit may increment each index by 5 the base address within global vertex buffer provided by SSYNC unit when servicing geometry processing unit . With this approach each geometry processing unit updates indices streamed to global index buffer to reflect correct vertices stored within global vertex buffer .

Persons skilled in the art will understand that the example described in conjunction with represents just one possible situations in which the functionality of the present invention may be implemented that the present invention may also be implemented in a wide variety of other situations.

In sum a graphics processing unit includes a set of geometry processing units each configured to process graphics primitives or geometry objects in parallel with one another. A given geometry processing unit generates one or more graphics primitives or one or more geometry objects and buffers vertex data related to the graphics primitive s or geometry object s locally. The geometry processing unit also buffers different sets of indices to those vertices where each such set represents a different graphics primitive or geometry object. The geometry processing units may then stream the buffered vertices and indices to global buffers. A stream output synchronization unit coordinates the streaming of vertices and indices across the different geometry processing units by providing each geometry processing unit with a different base address within a global vertex buffer where vertices may be written. The stream output synchronization unit also provides each geometry processing unit with a different base address within a global index buffer where indices may be written.

Advantageously with the disclosed approach the geometry processing unit does not store redundant copies of vertex data since the vertex data may be indexed locally thereby conserving GPU resources. In addition each such geometry processing unit may store locally generated vertex data in a global vertex buffer that also is indexed. The indices for the global index buffer are rationalized across all geometry processing units so that the size of the vertex buffer may be optimized for the overall system. Because the indexed global vertex buffer is indexed that buffer may be substantially smaller than conventional non indexed global vertex buffers. Consequently with a smaller global vertex buffer feeding the global vertex buffer back to stages of the graphics processing pipeline upstream of the geometry processing units becomes a far more efficient exercise relative to prior art architectures thereby increasing overall system processing efficiency.

One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as compact disc read only memory CD ROM disks readable by a CD ROM drive flash memory read only memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

