---

title: Content-based isolation for computing device security
abstract: The subject disclosure is directed towards securing a computing device using content-based isolation. When the computing device requests content data having different ownership, a monitor component identifies and groups trusted portions of the content data into one or more isolation containers such that only trusted programs are permitted access. Other programs are, therefore, untrusted and can be denied access in order to prevent malicious activity, unless access is approved by the content owner.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069766&OS=09069766&RS=09069766
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09069766
owner_city: Redmond
owner_country: US
publication_date: 20121102
---
People operate a variety of software based technologies when performing business and or personal tasks. It has become increasingly important for software program developers e.g. hardware software application and or operating system component developers to ensure security and integrity for computing tasks involving critical or sensitive data particularly in the face of threats e.g. malicious software code . Software vulnerabilities whether benign software code defects e.g. bugs or exploitable software code e.g. buffer overflows format string vulnerabilities and or the like may be exploited by such threats causing a number of problems for valued customers.

Software programs or simply programs often execute code and access resources via an operating system running on a computing device such as a mobile phone a desktop laptop computer a tablet device a smartphone and or the like. Conventional operating systems implement at least some isolation policy for securing data such as a per user isolation policy where users are isolated but each user s software programs run in a same isolation container or an application isolation policy where different software programs are isolated from one another. These isolation policies and other known isolation policies however are insufficient for protecting the computing devices from modern security challenges. Mutually distrusting content may interfere with one another especially when processed by a single software program. To illustrate one example attacker crafted image data can compromise a photo editor program and misappropriate all images processed by that editor program. Furthermore such isolation policies rely upon the user to make important security decisions which places an unnecessary burden on the user and often results in failure when the user makes an incorrect decision. The isolation policy is a critical operating system security feature and notwithstanding perfect isolation mechanism containers an ill designed isolation policy renders the computing device insecure.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards isolating content based upon content ownership. In one aspect an isolation container secures content data from malicious activity when the content data corresponds to different yet trusted content owners. The isolation container may maintain the content data as an execution instance in order to achieve content based isolation. In one aspect an isolation policy is designed to determine based upon content ownership which execution instance s if any can access specific portions of the content data. A principal labeling schema for the isolation policy may define content owner identifiers for individual content in order to distinguish trusted content from other untrusted content.

Enforcing the isolation policy involves using the principal labeling schema to group trusted content into an appropriate isolation container. The principal labeling schema enables content based isolation for a computing device. The principal labeling schema is used to generate content owner information and identify the content data corresponding to some user activity at the computing device. By implementing any compatible principal labeling schema for the isolation policy a monitor component of the computing device prevents untrusted programs from accessing secure content and permits only trusted programs to process store and or modify such content.

In one aspect a new isolation container is generated to secure the content data to which the monitor component assigns a principal label in accordance with the content based isolation policy. In another aspect the content data is admitted to an existing isolation container that comprises one or more trusted programs for processing the content data. The existing isolation container also may include other trust content.

Other advantages may become apparent from the following detailed description when taken in conjunction with the drawings.

Various aspects of the technology described herein are generally directed towards a monitor component configured to secure a computing device comprising content data from malicious activity and or misappropriation. The content data for example may store personal or sensitive information regarding a content owner or another entity such as a user.

Each portion of the content data refers to a particular type of data which may include image data audio video data executable software code e.g. a plug in text data and or the like. The content data also may include documents such as web documents e.g. web pages word processing documents spreadsheet documents photos and or the like. The monitor component does not distinguish between static content e.g. data such as a word processing document and dynamic content e.g. executed code when enforcing a content based isolation policy since maliciously engineered static file data can be converted into malicious code by exploiting memory errors in native software applications. The content data may be stored locally at a local resource and or hosted by a remote recourse and two or more portions of the content data may be assigned a same principal or a different principal according to a principal labeling schema.

The principal labeling schema enables isolation policy design for arbitrary granularities of addressable content e.g. a file hosted by a server located at the URL . The most fine grained principal includes for example a single document. The principal labeling schema may be configured to separate content ownership from content hosting such that content may be hosted anywhere and still be treated as belonging to a same principal. The isolation policy is configured to be suitable for all software programs including traditional applications e.g. word processing applications . Enforcing content based isolation policies consolidates content isolation logic in the operating system which reduces an isolation container s trusted computing base from trusting a substantial number of software applications to trusting the operating system.

The monitor component may support the operating system running at the computing device by implementing the principal labeling schema as described herein identifying portions of the content data as trusted content and isolating an execution instance of the trusted content within an isolation container. Such an execution instance may be configured to prevent other untrusted content from gaining access and or prevent malicious portions of the trusted content from accessing content data at a remote resource. One example implementation represents the execution instance as a content processing stack comprising a top layer and one or more lower layers that correspond to one or more trusted programs for content at the top layer. The one or more trusted programs may be referred to herein as content processors. While such a content processing stack constitutes one example embodiment of the execution instance it is appreciated that the execution instance may be expressed in other ways.

The monitor component enforces content based isolation in which principal labels may identify content owners. In one example implementation the monitor component enables a fine grained content based isolation policy for securing the content data at the computing device. Based upon such a policy the monitor component may identify a set of content having different content owners yet sharing mutual trust. The monitor component may maintain the set of content in an isolation container to block untrusted programs from accessing the content data and permit only the trusted programs. The monitor component also may delete isolation containers using such a policy.

According to another example implementation the monitor component may provide a flexible approach to the content based isolation policy enforcement by permitting cross principal communication between disparate content that resolve to different principal labels. Some documents may not be mutually distrusting and may have intimate cross document interactions requiring substantially equal treatment as if these documents resolve to a same principal label. One example of an intimate cross document interactions refers to a word processing document referencing or embedding a spreadsheet document. The word processing document and the spreadsheet document may have different origins but it is desirable that these documents run in a same isolation container.

The principal labeling schema may define public keys for identifying content owners. A public key may be stored in a HTTP header attribute as a content owner identifier. Although the public key provides both arbitrary isolation granularity and independence from host servers the monitor component may use the public key to customize a same origin policy or an adapted version thereof when assigning principal labels to the content data.

It should be understood that any of the examples herein are non limiting. As such the present invention is not limited to any particular embodiments aspects concepts structures functionalities or examples described herein. Rather any of the embodiments aspects concepts structures functionalities or examples described herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing and computing device security in general.

Various software components support the operating system and facilitate program execution and data processing storage for the client device . As described herein a monitor component may be configured to secure the client device from unsafe or malicious threats. It is appreciated that the operating system also may utilize one or more other components for various purposes including an interface component configured to access data stored locally and or remotely. One example of the interface component includes a storage component configured to access a local resource such as a local software program e.g. a traditional word processor or spreadsheet application a local cache memory a local storage device and or the like. Another example includes a browser component configured to retrieve content data from remote resources over the Internet. Yet another example includes a component for accessing remote resources over an Intranet.

As the user opens creates and or modifies various types of content the monitor component isolates such content within execution instances using content owner information according to one example implementation. The monitor component may group different content into a same execution instance if each piece of content belongs to a same content owner and or if each content owner is trusted by at least all pieces of content currently in the same execution instance. The monitor component may use any compatible isolation mechanism to encapsulate trusted content from content owners within each execution instance and generate an isolation container to secure the trusted content.

The content owner information may record a principal label that maps to an example portion of content data e.g. an electronic document distinguishing that content from other content produced by other content owners. The monitor component generates an execution instance for example to isolate the example portion of content data from untrusted content having a different principal label such as an untrusted program. Only trusted content produced by a same content owner or a different but trusted content owner may access the execution instance . By preventing untrusted programs from accessing the example portion of content data and or permitting admission into the execution instance to only trusted programs the monitor component secures the example portion of content data from misappropriation due to malicious activity.

Based upon a principal labeling schema the monitor component determines a principal label for each portion of the content data. The principal labeling schema generally defines trusted content groupings by which different portions of the content data are identified by content owner and isolated. If two or more content owners resolve to a same principal label any content associated with these content owners may be maintained in the execution instance or alternatively in different execution instances whereby access to each other s content is permitted. Within the execution instance content may be processed by other trusted content such as a trusted program. The principal label therefore separates content ownership from content hosting. Accordingly a resource may remotely host content on behalf of a considerable number of content owners without risking such data from being compromised.

The principal labeling schema may be configured to support traditional software applications where content owners often create content locally and then separately upload the content to a host server where content is updated remotely. Consider an example in which a content owner alice.com created a number of word processing documents or photos to be uploaded onto various online storage services e.g. Microsoft SkyDrive or photo sharing services. The principal labeling schema assigns each individual document photo to a same owner identifier of alice.com regardless of which service actually hosts that document photo. A program running on the computing device which may be operated by the content owner alice.com may access a document photo hosted by one of the above online services if there is a trust relationship between the content owner identifier of alice.com and the program s principal label as described further below.

One example implementation defines each principal label as an appropriate content owner identifier. The monitor component assigns content owner identifiers to secure content data isolated within execution instances. Alternatively the monitor component stores a trust list for each portion of the secure content data. The execution instance may be generated when the user via a software program opens a document tax.doc on a computing display. Communicating a request for another document photo.jpg from the resource may either place the other document photo.jpg into the execution instance or depending upon the content owner cause another execution instance to be generated.

In one example implementation the resource may help achieve content based isolation by modifying header information within access request responses to include the content owner information such that the monitor component can more easily identify content owners and possibly determine appropriate principal labels. The resource for instance may store a public key in the header information to function as a content owner identifier. As another example the remote resource may include a related trust list with every response being returned to the computing device .

To illustrate an example execution instance that corresponds to content from different owners provides the isolation container in which a document photo.jpg is rendered on a computing display by an editor program editor.app running on a Virtual Machine which in turn is a Microsoft Win32 program running on Microsoft Windows . The document photo.jpg may be addressed as alice.com photojpg and downloaded from a corresponding location within a remote resource. Each individual piece of content the document photo.jpg the editor program editor.app and the virtual machine vm.exe corresponds to a different owner. For example the document photo.jpg the editor program editor.app and the virtual machine vm.exe correspond to alice.com This is one example execution instance. Another example execution instance will be illustrated below.

To illustrate another example execution instance that corresponds to content from different owners provides the isolation container in which a video file video.wmv is rendered by a rich Internet application RIA runtime environment Silverlight.exe and presented to the user of the computing device . Although depicts origin information CntServer.com video.wmv and Microsoft.com Silverlight.exe as principal labels for the video file video.wmv and the RIA runtime environment Silverlight.exe respectively it is appreciated that other embodiments may employ alternative principal labeling schemas to content maintained within the isolation container . Protocol schemes e.g. HTTP HTTPS and or the like in the origin information were omitted but may be part of the principal label.

For embodiments where content data is requested and distributed over a HTTP protocol some trusted programs e.g. tradition software application may indicate the content data s MIME type using a Content Type header in all HTTP responses. Other trusted programs may implement a Trust or Owner HTTP header attribute to allow content servers to specify desired or default content processors by a URL or an identifier. For example a web server hosting photo.jpg could send header information comprising Content Processor http www.PhotoSrvce.com editor.app establishing a trusted program to process the photo.jpg as directed by the content owner. The web server may sign a portion of the header information with the content owner s private key. The monitor component may store a content to processor mapping between photo.jpg and editor.app in the content owner information.

According to one example implementation the monitor component issues Application Programming Interface API calls invoking isolation mechanism functions in response to user activity e.g. user click command and or the like . Some of these calls may result in the generation of an isolation container configured to secure content data from malicious software code. For instance the monitor component configures the isolation container to maintain an execution instance in the form of a content processing stack comprising a web document and executed code from webpage SearchPage.com and or a browser component Microsoft.com IE.exe respectively as depicted in . When the user opens the browser component IE.exe from Microsoft.com and navigates to the web page SearchPage.com the monitor component isolates executed software code associated with the browser component and webpage data downloaded from an appropriated web server which prevents untrusted programs from achieving access.

By way of example in order to block untrusted programs and permit only trusted programs to access content maintained within an execution instance one example implementation of the monitor component defines a number of principal labels distinguishing the trusted programs from the untrusted programs. Each execution instance may be assigned a principal label comprising each webpage origin e.g. an origin stack . The monitor component for example may express an example principal label for the execution instance as follows 

The user may access a remote resource corresponding to content owner EntityABC.com execute software code for a different browser component EntityABC.com brwsrComp.exe and then use this browser component to communicate information to another remote resource for webpage Bing.com requesting web content. In response to such user activity the monitor component generates an execution instance within the isolation container and secures the web content and the executed software code from untrusted programs according to one example implementation.

Another principal labeling implementation provides a public key to identify a particular entity as a content owner. The monitor component may couple the public key to for example URL addressable content by tagging such content with an appropriate content owner s public key and a corresponding host URL s signature. The signature indicates that the corresponding host URL maps to a remote resource owned by the entity associated with the public key. A content processing stack for example is labeled with a stack of public key based principals e.g. referred to as an owner stack . The monitor component considers content processing stacks with a same owner stack as having a same principal. A HTTP response header for an example embodiment employing the public key includes Owner publicKey hostURLSig signed responseURL . 

In one optional implementation the monitor component processes a resource access request augmented with a trust list associated with content data at any URL addressed resource e.g. a content server . Such content data may trust other content data located at remote resources in a unilateral one way trust relationship or a bidirectional trust relationship in which both sets of content data share mutual trust.

Mutually trusted content from different resources reside in a same execution instance. The isolation container for example comprises an execution instance of mutually trusted content corresponding to Microsoft.com and alice.com as illustrated in . The monitor component may admit content into the isolation container if and only if the documents alice.com tax.docx and Microsoft.com word.exe trust such content and vice versa. The trust list may record a set of URLs hosting trusted content with which the content data may access and or coexist in the same execution instance. Trust lists may be employed in computing devices that isolate content using a same origin policy.

In one example implementation the monitor component specifies a trust list within a HTTP header attribute e.g. a Trust HTTP header attribute which may comprise the trust list itself or alternatively a resource locator e.g. a URL pointing to the trust list. The trust list includes URLs which refers to a path address representing a specific location or locations within a resource where content is stored. The monitor component may optionally enable a wildcard operator at the end of the URL when enumerating all content at that path address. When the HTTP header attribute is missing the monitor component reverts to a principal labeling schema that assigns content server origin information to returned content. For content communicating over non HTTP technology the monitor component may resort to a same origin policy SOP principal labeling schema in which all content from an origin corresponds to a trust list comprising the origin URL followed by a wildcard operator. For example when content associated with CntServer.com and content associated with bing.com resolve to a same principal label independent content servers for bing.com and CntServer.com provides HTTP responses storing HTTP header attributes Trust list http CntServer.com and Trust list http bing.com respectively.

Consider the following example of using a HTTP header attribute to achieve a fine grained principal labeling schema. After receiving HTTP responses comprising content data from URL http blog.com alice index.html and a HTTP header attribute set to Trust list http blog.com alice the monitor component permits access to any data from path address http blog.com alice such that the content data shares an isolation container with such data. To achieve path based principal isolation the monitor component does not trust content addressed from URL http blog.com because such a path does not identify the alice subdirectory. Alternatively the HTTP header attribute identifies individual document URLs to achieve document level granularity of isolation.

If the user activity did not cause the execution of any software program step proceeds to step . Step refers to modifying or deleting an execution instance in response to the user activity. If the user updated existing content and or requested additional content the execution instance is modified such that other trusted content within the execution instance may access either the updated content or the additional content. The execution instance may be deleted if the user closes or deletes the existing content.

If the user activity caused the execution of a software program step proceeds to step . This occurs for example when the user opens a document e.g. a word processing document or a spreadsheet through a software application or downloads a web page through a browser component. Program execution also may occur when the software application or the browser component causes the execution of another software program e.g. a plug in . Step refers to generating one or more execution instances of content data corresponding to the user activity and creating one or more isolation containers to maintain the one or more execution instances. Step refers to assigning a principal label and updating content owner information. Step is directed to modifying or deleting the one or more execution instances when the user updates and or closes the content. Step terminates the example steps described in .

Step is directed to communicating a request access request for content data. According to one example implementation the monitor component receives request data via an operating system component and transforms the request data into the request access request as described herein. After extracting header information from the request data the monitor component may modify the header information to include a principal label corresponding to the requestor and generates the resource access request with the modified header information. For instance the API function call may include an HTTP request that is generated by a browser component. The monitor component may be configured to modify a HTTP header attribute such as an Owner or Trust HTTP header attribute for a HTTP request response.

The monitor component stores the requester principal label in an Origin header attribute of the resource access request in order to inform the responder as to the requestor content owner identity. The responder may implement a proprietary request authorization protocol configured to verify the requester principal label. The responder specifies dispatch data e.g. a dispatch bit within the access request response in order to differentiate between different types of acceptable cross principal communication. Example acceptable forms of cross principal communication may include 1 Data communication where a requester wants some data from a responder server 2 Spawning a new principal where the requester wants to spawn a new execution instance corresponding to the responder principal label 3 acknowledging prior dispatch data and or the like. Spawning a new principal may occur when a user clicks on a hyperlink to open a new document or a document corresponding to the requester principal label embeds content corresponding to the responder principal label.

Step represents access request response processing. According to one example implementation the monitor component receives the access request response from the responder as a response to the resource access request. The access request response may include the requested content data as well as header information comprising a trust list and or content owner information. Based upon the header information the monitor component dispatches the content data to an execution instance corresponding to a requestor principal label or a responder principal label.

Herein describes step to step representing content based isolation policy enforcement according to one or more example implementations. Step determines whether the content data and the execution instance corresponding to the resource access request resolve to a same principal. If it is determined that the content data and the execution instance do not resolve to the same principal step proceeds to step which determines whether the execution instance may access the returned content data despite such content data resolving to a different principal. For instance if the returned content data and the execution instance resolve to different principal labels the returned content and or the content data in the execution instance may include malicious software code. On the other hand respective content owners may still trust each other enough to permit cross principal access at step based upon the cross principal analysis performed at step . and represent example implementations for the cross principal analysis and related policy enforcement as described for step and step . If the returned content data and the execution instance resolve to the same principal step proceeds to step .

Content based isolation policy enforcement may involve enforcing an Owner or Trust header attribute for a HTTP request response. One example embodiment enforces the Trust header attribute by maintaining a stack C of effective principal labels to represent an execution instance within in an isolation container according to one example implementation. An effective principal label for example of layer L may include a set of URLs aggregated from content data corresponding to each layer L of all execution instances. The following represents one example embodiment of step where the effective label stack C requests access to content at a resource having a URL u.

By implementing the above code given an HTTP response comprising addressable content associated with a URL u and a related trust list the monitor component determines whether to admit this content into the isolation container. As one example if the URL u trust list and the stack C indicate mutual trust the monitor component isolates the addressable content corresponding to the URL u in accordance with a content processor mapping for the stack C. The IsSamePrincipal C u function iterates over the URL u and any lower content processor layers and determines that each layer mutually trusts each corresponding layer of the effective label stack C. Accordingly the monitor component updates the stack C with the URL u and effective labels for the lower content processors.

If the IsSamePrincipal C u function returns false the monitor component may perform a cross principal analysis at step and then given the results of the cross principal analysis determine whether to permit the isolation container access to the returned content data at step . Some example embodiments specify a dispatch bit within the HTTP request or the HTTP response as described for and respectively in which the dispatch bit instructs the monitor component to either discard the addressable content associated with URL u as described for step or nevertheless admit the addressable content as described for step into the isolation instance for stack C or a new isolation instance labeled u. If the HTTP request and the HTTP response lack such dispatch data the monitoring component also discards the addressable content. The example steps described for terminate at step .

In one example implementation an origin corresponding to the requestor is used as a principal label. The monitor component assigns to the requestor the principal label of alice.com tax.doc as illustrated in denoting a document having a content owner associated with alice.com. When requesting addressable content data from the responder the requestor invokes an API function call of the monitor component . A Fetch API Call for instance requests the content data corresponding to bank.com tax.macro from the responder . The monitor component transforms the Fetch API Call into a HTTP request with modified header information as depicted in and communicates the HTTP request to the responder .

Within one example embodiment of the HTTP request the monitor component sets a dispatch bit to data communication indicating to the responder that any returned content is to be admitted into the execution instance corresponding to the requestor . The dispatch bit enables the responder to optimize HTTP responses that are expected to be dropped and possibly return errors instead of content. According to one alternative embodiment of the HTTP request the requestor sets the dispatch bit to spawn new principal indicating that any returned content is to be admitted into a different execution instance corresponding to the responder .

The responder performs a decision as to whether principal label content owner alice.com is authorized to access tax.macro. If related content data for tax.macro can be accessed by content within the isolation container for the requestor or alternatively by content within an isolation container for the responder the monitor component returns the related content data to an appropriate isolation container. If for instance it is determined that alice.com can access the related content data the responder returns a HTTP response with attribute dispatch bit understood set to true in response to the HTTP request . The monitor component communicates the related content data returned from the responder to the requestor . If the responder determines that alice.com cannot access the related content data a HTTP error is returned to the monitor component which relays the HTTP error to the requestor .

In one example implementation the requestor invokes a Fetch API call requesting content data at address bank.com tax.macro of which the monitor component transforms into a HTTP request . The monitor component adds a header attribute to the HTTP request and stores a principal label for the requestor into the header attribute. As an example the requestor may be assigned a principal label of alice.com tax.doc in order to identify an appropriate content owner and or content origin.

The HTTP request may prompt the responder to render a decision as to whether content data having an origin address alice.com can access content data corresponding to tax.macro even through the responder and the requestor resolve to different principal labels. If the responder permits content data owned by alice.com to access the content data corresponding to tax.macro the responder communicates a HTTP response to the monitor component returning the content data corresponding to tax.macro to the requestor . The monitor component may admit the returned content data into the execution instance for the requestor if a dispatch bit is set to data communication indicating that alice.com tax.doc is deemed trusted content. The monitor component may relay the HTTP response to a browser component having a same principal label and or within the same execution instance as the requestor . The advantage of putting the bit in the HTTP response is that it can be statically configured for each URL rather than having the server perform access control checks for each request and reduce network overhead. When the dispatch bit from the HTTP response differs from that of a HTTP request e.g. the HTTP request or the HTTP request the response s dispatch bit takes precedence.

If the responder determines that content data corresponding to alice.com cannot access the content data corresponding to tax.macro the responder proceeds to decision and determines whether the requestor can spawn a new execution instance in which bank.com forms at least a portion of an assigned principal label. If so the responder communicates a HTTP response with a dispatch bit set to spawn new principal indicating that a new execution instance for a responder principal label is to be generated. In turn the monitor component performs a decision to determine whether a destination execution instance resolves to the responder principal label. If the monitor component determines that the destination execution instance resolves to the responder principal label the monitor component admits the content data corresponding to tax.macro into the destination execution instance. Otherwise the monitor component returns an error. If the content data owned by alice.com is not permitted to access the content data corresponding to tax.macro and or cannot spawn a new execution instance for the responder principal label the responder communicates a HTTP error is returned to the monitor component which returns an error to the requestor .

One of ordinary skill in the art can appreciate that the various embodiments and methods described herein can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment and can be connected to any kind of data store or stores. In this regard the various embodiments described herein can be implemented in any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units. This includes but is not limited to an environment with server computers and client computers deployed in a network environment or a distributed computing environment having remote or local storage.

Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for objects such as files. These resources and services also include the sharing of processing power across multiple processing units for load balancing expansion of resources specialization of processing and the like. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may participate in the resource management mechanisms as described for various embodiments of the subject disclosure.

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in communications network may comprise other computing objects and computing devices that provide services to the system of and or may represent multiple interconnected networks which are not shown. Each computing object etc. or computing object or device etc. can also contain an application such as applications that might make use of an API or other object software firmware and or hardware suitable for communication with or implementation of the application provided in accordance with various embodiments of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for example communications made incident to the systems as described in various embodiments.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client is a member of a class or group that uses the services of another class or group to which it is not related. A client can be a process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. The client process utilizes the requested service without having to know any working details about the other program or the service itself.

In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. acting as servers provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances.

A server is typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server.

In a network environment in which the communications network or bus is the Internet for example the computing objects etc. can be Web servers with which other computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Computing objects etc. acting as servers may also serve as clients e.g. computing objects or devices etc. as may be characteristic of a distributed computing environment.

As mentioned advantageously the techniques described herein can be applied to any device. It can be understood therefore that handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments. Accordingly the below general purpose remote computer described below in is but one example of a computing device.

Embodiments can partly be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is considered limiting.

With reference to an example remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation system memory may also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices . A monitor or other type of display device is also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which may be connected through output interface .

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

As mentioned above while example embodiments have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to improve efficiency of resource usage.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques provided herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more embodiments as described herein. Thus various embodiments described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

The word exemplary is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements when employed in a claim.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component module system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the example systems described herein methodologies that may be implemented in accordance with the described subject matter can also be appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the various embodiments are not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover some illustrated blocks are optional in implementing the methodologies described hereinafter.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

In addition to the various embodiments described herein it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating therefrom. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be effected across a plurality of devices. Accordingly the invention is not to be limited to any single embodiment but rather is to be construed in breadth spirit and scope in accordance with the appended claims.

