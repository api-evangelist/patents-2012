---

title: Debugger connection
abstract: The subject matter of this specification can be embodied in, among other things, a method that includes establishing a connection with one or more virtual machines using a debugger protocol configured to communicate debug commands to applications executed by the one or more virtual machines. The method also includes transmitting a request for a current state of the one or more virtual machines using the connection. Information associated with the current state includes state variables not controlled by an application receiving debug commands. The method includes outputting the current state of the one or more virtual machines for display to a user.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08843895&OS=08843895&RS=08843895
owner: Google Inc.
number: 08843895
owner_city: Mountain View
owner_country: US
publication_date: 20120912
---
This application is a continuation of co pending U.S. application Ser. No. 11 936 969 filed on Nov. 8 2007 the entire contents of which are incorporated herein by reference.

Debugging an application includes eliminating unexpected behavior exhibited by the application. An application developer can connect a device running the application to a workstation that includes a debugger. The developer can then use the debugger to communicate debugging commands to the application over the connection. For example the debugger can stop the application and display the application s source code at a particular moment the application stopped in order to identify and eliminate unexpected behavior.

In general this document describes using a debug connection with a virtual machine to perform multiple functions that include requesting state information from virtual machines as well as debugging processes executing on the virtual machines.

In a first general aspect a computer implemented method is described. The method includes establishing a connection with one or more virtual machines using a debugger protocol configured to communicate debug commands to applications executed by the one or more virtual machines. The method also includes transmitting a request for a current state of the one or more virtual machines using the connection. Information associated with the current state includes state variables not controlled by an application receiving debug commands. The method includes outputting the current state of the one or more virtual machines for display to a user.

In a second general aspect a system is described. The system includes a connection manager interface to establish a connection with one or more virtual machines using a debugger protocol configured to communicate debug commands to applications executed by the one or more virtual machines. The system also includes means for transmitting a request for a current state the one or more virtual machines using the debugger protocol. The current state includes data not controlled by an application receiving the debug commands. The system also includes an interface to output the current state of the one or more virtual machines for display to a user.

The systems and techniques described here may provide one or more of the following advantages. First a single connection with a virtual machine can facilitate both debugging processes executed by the virtual machine as well as requesting current state information from the virtual machines. In another example a described system can make debugging multiple applications easier for an application developer by providing a more convenient way to connect multiple debuggers to multiple virtual machines. A system to query the states of virtual machines can be provided in a way that is easy to integrate into existing software infrastructures that use existing debug protocols. In yet another example a system is described where state information for multiple virtual machines can be monitored simultaneously.

The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features and advantages will be apparent from the description and drawings and from the claims.

The debugger connection can use for example a Java Debug Wire Protocol JDWP or any other suitable debugger protocol. For the JDWP virtual machine state queries can be transmitted using unreserved bits within the protocol according to some implementations.

Queries transmitted via the debugger connection can be used to request current or live state information for the virtual machines such as Java virtual machines JVMs . For example live or current state information can include the identification of threads e.g. separate applications processes that each virtual machine is running memory usage for each thread memory usage for the entire device CPU usage stack information resource utilization configuration metrics performance statistics etc.

The CPU information can be used for example to determine which applications use more CPU time than other applications concurrently running on the same virtual machine. Such CPU usage information can help to determine processes that are computationally expensive e.g. due to erroneously executing in an infinite loop or which processes are in a wait mode. In another example a user can determine processes that inefficiently use memory e.g. due to excessive page faults based on the memory usage information.

Current or live state information can be used to compare status and resource information for several threads at once. For example a user debugging one application on a portable device e.g. a cell phone can use live state information to view information associated with other processes e.g. applications that perhaps are not currently being debugged to identify possible conflicts problems or issues.

In some implementations the multiple purpose debugging connection can monitor state information for multiple threads. For example a virtual machine or virtual machines can simultaneously execute more than one thread or application. The multiple purpose debugging connection can permit a user to request information for threads and applications simultaneously executed by the virtual machine s . The user can use such information for example to determine why an application is executing slowly e.g. which may occur if concurrent processes on the same virtual machine are competing for CPU cycles or memory .

In some implementations communications between debuggers and virtual machines can be interleaved within a single debugger connection so that multiple simultaneous communications can occur between multiple debuggers and multiple virtual machines.

In some implementations a user can debug applications hosted by different virtual machines on a single device. For example in some implementations a cell phone can execute several JVMs each of which is running different applications such as a phone function application a device settings application a device content application e.g. an application that manages data stored on a device web applications e.g. browsers etc. device drivers embedded systems etc.

In some implementations applications on virtual machines are written in different programming languages e.g. Java C C etc. and as such the corresponding debuggers may be different. A debug monitor can negotiate connections between multiple debuggers and virtual machines which in some implementations can make debugging the multiple applications easier for a user.

For example the debug monitor can automatically detect the ports that virtual machines are using and connect a corresponding debugger to the appropriate port. Doing so can eliminate the need for the user to manually determine a port number for a virtual machine such as by searching for the port number in log files that are output by the virtual machines and then specifying that port number as the output port for the appropriate debugger.

The debug monitor can also notify the user when new threads are created and when existing ones end. In some implementations the debug monitor can automatically select the debugger that is appropriate for an application such as by parsing an executable s file name for the suffix.

Referring to a debugging session can exist between any of one or more debuggers and one or more virtual machines running on a portable device e.g. a cell phone PDA etc. . For instance the debugger can execute on a server that is coupled with a workstation . The portable device includes the one or more virtual machines and an operating system or platform .

Each of the virtual machines can execute one or more applications that a user can debug using the debuggers . For example the user can employ displays and controls of the debugger to debug applications such as Java applications on the portable device . Such a debugging session can use a debugger protocol such as the Java Debug Wire Protocol. In general debugger protocols can be transmitted via a wired connection e.g. a USB connection or a wireless connection e.g. a Bluetooth or a Wimax that can be direct from the workstation to the portable device or remote through a network such as a local or wide area network.

During a debugging session the user can employ the workstation to enter debug commands such as debug queries for an application executed by virtual machine A . In particular virtual machine A can be one of several virtual machines hosted by the portable device . In one example the debug commands entered by the user are commands to step through lines of code for a particular cell phone application. Other debug commands can include for example user commands or queries that can examine specific variables in the application set variable watches to let the user know when a variable s value changes set stop line conditions e.g. execute the application until a particular numbered line is reached set the number of iterations to execute in a loop e.g. a DO WHILE UNTIL REPEAT etc. or any other commands or queries a user can issue to debug a program or application.

The debugger protocol can transmit the queries e.g. via a USB connection to the corresponding virtual machine s associated with the debugging session. In response to the queries one of the virtual machines can send one or more responses to the debugger s . For example the responses can include the values of variables being examined or the notification that the value of a watched variable has changed. Other responses can be a notification that the virtual machine has executed the application up to the point of the stop line specified by the user and as such the user can determine other information at the current state of the application s execution.

In addition to handling debug commands and responses the debugger protocol can be used to provide live state information for the virtual machines . For example while using the workstation to debug a phone application executing on one of the virtual machines e.g. virtual machine A the user may also be interested in obtaining live state information for virtual machine A. Specifically the user may want to obtain information regarding CPU usage memory usage or other information that may not be accessible using debug commands .

For example the user may desire to know virtual machine state information at a specific time in a phone application s execution such as at a stop line point. As such the user can enter one or more commands using the workstation which transmits the commands to virtual machine A. For example a user can enter queries to obtain CPU or memory use information. The commands can be sent via the debugger protocol as a set of virtual machine A state queries

In response to the state queries the corresponding virtual machine e.g. virtual machine A can respond with current virtual machine state information . For example if the purpose of the user s command is to obtain CPU and memory usage information the state information can include the percentage of CPU and memory usage of processes running on virtual machine A. Such information can be transmitted via the debugger protocol to a debug monitor and the user can view the information for example on the workstation .

In some implementations such live state information can remain displayed for example as the user continues to debug the selected application. As a result the user can compare the CPU and memory usage of the debugged application with that of other processes running on virtual machine A or other virtual machines executed by the portable device .

The debug monitor can be used to negotiate connections between one or more debuggers and virtual machines hosted on the portable device. For example the user can simultaneously use multiple debuggers to debug multiple applications where the applications executed by a single virtual machine or multiple virtual machines .

In some implementations the debug monitor interleaves multiple distinct communications sent and received by the individual debuggers so that the correct transmissions are associated with the corresponding debugger virtual machine pairs. This may permit the debug monitor to support multiple debugger connections simultaneously. For example separate debugger connections can exist for applications running on multiple virtual machines such as virtual machines A B and C. Queries such as debug query can originate from different debuggers and the debug monitor can manage routing the responses to the appropriate debugger . This is discussed in more detail below.

The debug monitor can display on a device monitor GUI debug and machine state information for the virtual machines to which the server or workstation is connected. For example the device monitor GUI can display information on the workstation for the debugging sessions established for one or more portable devices .

The device monitor GUI can serve as the user interface for the debug monitor and as such can provide several real time displays on the user s workstation . For example a virtual machines list can identify the names and port information associated with the virtual machines e.g. virtual machines A B and C which are connected to the server and to which the user may have access.

A state information area can display live state information such as to provide a real time summary and status of virtual machines on the portable device. Such state information can include a memory information area a processing information area and other areas for displaying specific live state information for virtual machines .

A screen capture area can also provide the user with a graphical display for example of screenshots taken from the portable device . In certain implementations the screen capture area displays information currently displayed by the portable device s screen. In another implementation the information displayed in the state information area and the screen capture area and other such areas can correspond to the particular virtual machine that the user has selected or highlighted in the virtual machines list . For example virtual machine A is depicted as shaded or highlighted so the information displayed in areas and can correspond to virtual machine A. The captured screen shots can be used to document bugs for bug reports.

In one example the user can employ the device monitor GUI while one or more debuggers are running in order to have additional live state information available while debugging applications the portable device . For example the user can have separate windows e.g. for individual debuggers etc. open on the workstation simultaneously. While debugging one application e.g. a cell phone application running on virtual machine A the user can have a window devoted to issuing debug commands and receiving responses . Such a window can be a specialized GUI for the debugger for example specific to the language e.g. JAVA of the application being debugged. At various times during the debugging session the user can also display the device monitor GUI to show live state information for the corresponding virtual machine.

In some implementations the debug monitor can automatically issue state queries in order to maintain up to date information that is displayed in the virtual machines list and areas and . Similarly the responses received from the queries can populate portions of the screen included in the device monitor GUI . The debug monitor can intercept the debug commands from the debuggers and originate the virtual machine state queries and package them together into a single message using the debugger protocol . The debug monitor can then transmit the message to the portable device.

In addition the debug monitor can also receive the responses and received via the debugger protocol from the portable device . The debug monitor can pass the debug responses to the appropriate debugger and can display the current virtual machine state information using the device monitor GUI .

In some implementations the current virtual machine state information is transmitted sua sponte. For example the debug monitor receives additional information that is not query driven such as threads that may have started on any of the virtual machines or other information indicating a change in state for a virtual machine. This information can be displayed within the device monitor GUI .

The workstation includes one or more debuggers that can be used to debug applications that execute on virtual machines . For example the debugger can be a Java debugger that is being used to debug a Java application executing on virtual machine

The workstation can include a connection manager interface for interfacing with the portable device . Specifically the connection manager interface is responsible for connecting to the specific virtual machine that executes the application to be debugged by a particular debugger . Communications to the portable device can include debug queries e.g. stepping instructions variable examinations variable watches etc. as well as queries that the user can enter in the user interface module or can be generated automatically to obtain live state information of virtual machines . The connection manager interface can also receive information sent by the portable device to the workstation or more specifically sent by the virtual machines to the debuggers . For example the information received from the portable devices can be responses to debug commands and or responses to queries for live state information of virtual machines .

In many cases the connection manager interface can establish the debugging session directly with a given virtual machine such as by USB wireless firewall serial parallel etc. In a USB implementation for example a USB cable can be used to physically attach the workstation directly to the portable device .

In other implementations the workstation can include an emulator that simulates functions of a device e.g. for testing purposes . For example a portable device emulator can simulate the functions of a cell phone. The connection manager interface can establish a connection with the portable device emulator as if the emulator were a physical device.

The workstation can include a debug monitor that is used to monitor and manage the connections between multiple debuggers e.g. debuggers and multiple portable devices . Using the debug monitor the user can track thread states e.g. thread creation exit busy idle status etc. and receive view information regarding overall heap status which can be used to for example generate a heap bitmap display or a fragmentation analysis. Also the debug monitor can provide a GUI for the user to view state information corresponding to one or more virtual machines 

The debug monitor can receive commands entered by the user via debuggers and can communicate with the virtual machines . Responses e.g. based on the commands queries received from the virtual machines can also be handled by the debug monitor which can for example reformat the responses into formats that the individual debuggers can understand. Alternatively the debug monitor can simply identify the correct debugger for a received response and transmit the response to the identified debugger without additional reformatting.

The debug monitor can include a user interface module . A user can for example enter commands in the user interface module in order to receive live state information from the virtual machines . In some implementations requests for live state information include requests for information about CPU usage memory usage etc. The user can use the live state information with other debug responses in order to debug applications and determine virtual machine states that affect or are affected by the applications.

The debug monitor can include a communication manager which can be used by the debug monitor to manage communications with one or more portable devices . For example the communication manager can use commands queries entered by the user e.g. commands to obtain live state information from a particular virtual machine to generate a message to be sent to the corresponding virtual machine. The communication manager can include a message generator and a message interpreter .

The message generator can generate messages based on the commands that the communication manager receives from the user interface module . In some implementations the commands issued can be generated automatically based on selections from the GUI of the debug monitor or based on commands entered for example into text entry elements of the GUI. For example a user may select a particular virtual machine to monitor from a list of virtual machines displayed on the GUI. Once the particular virtual machine is selected the message generator can create a series of messages that request different state information from the virtual machines. For instance one message created by the message generator may be a total VM memory message that requests the total memory used by the particular virtual machine.

Similarly the message interpreter can be used to interpret messages received from portable devices and provide the messages in a format that is readable by a user of the GUI of the debug monitor .

The debug monitor can include interfaces and for interfacing with components outside of the debug monitor . The interface can include port listeners for listening for inputs from debuggers . For example the port listener can listen for inputs from the debugger the port listener for the debugger and so on. Such port listeners can listen for specific debug queries that the user can request using a particular debugger. For example a user can enter a debug query to examine the value of a particular variable such as a variable that is part of an application running on the virtual machine . The debug monitor can identify the appropriate virtual machine to receive the debug query and initiate a transmission of the query to that virtual machine. The process of identifying the appropriate virtual machine is described in more detail in association with .

The interface can handle communications between the debug monitor and the connection manager interface . As such the interface can include port listeners for listening for responses received from virtual machines on the portable device . One example type of response can correspond to a particular debug query originally entered on one of the debuggers or to a live state information query entered in the user interface module . For example if the user entered a debug query on the debugger to examine the value of a particular program variable the response received via the port listener can include the variable s value at that time in the program s execution. In another example if the user is displaying CPU and or memory statistics for threads executing on virtual machine the response received via port listener can include the CPU and memory percentages allocated for example by thread.

The debug monitor can request different kinds of state information from the virtual machine . For example some types of information can include CPU and memory usage. Other types of information can relate to the thread states such as running sleeping blocked waiting initializing starting native executing native code waiting on a virtual machine resource suspended etc. The user who is debugging the application can use such information for example in combination with debugger commands responses in order to diagnose a specific problem with the application s execution.

The debug monitor can request heap information from the virtual machine . Such heap information received can be represented for example by a color coded bitmap sent to the debug monitor . The bitmap can indicate which stretches or blocks of memory are free and which are in use. For compactness the bitmap can be run length encoded and based on multi byte allocation units rather than byte counts. In some implementations the debug monitor can correlate the bitmap with more detailed object data such as to associate bitmap data with virtual addresses.

Requests for heap and other state information can be made for example in a series of function calls. For example heap information can be broken into segments within the virtual machine and due to memory constraints it may be desirable to send the bitmap in smaller pieces or chunks. To avoid ambiguity the chunks can be marked and or grouped with explicit start and end messages such as when one heap information chunk is sent or when several chunks are sent over time.

Messages used to send heap information can include a heap ID that can be used to differentiate between multiple independent heaps e.g. Java Virtual Machine heaps or perhaps a native heap. Information about different heaps can be sent simultaneously so all heap specific information can be tagged with the heap ID .

In order to communicate with the debug monitor each of the virtual machines can have one or more pieces of debug manager code to interpret messages sent by the debug monitor . For example the debug manager code can include logic and or data e.g. look up tables etc. that allow the virtual machines to differential the commands queries that are received such as debugger queries and various debug monitor queries for live state information e.g. CPU memory heap requests etc. . If a particular virtual machine does not have a piece of debug manager code it can view the debug monitor as a debugger. By treating the debug monitor as debugger the virtual machines can still receive debug commands without crashing or experiencing an error.

In some implementations the debug monitor can be a plug in such as a component that can be used with other tools in an open development platform or an integrated development environment IDE e.g. Eclipse etc. . In this way the debug monitor can be integrated with other tools and can provide live state information of virtual machines in addition to handling debug queries and responses normally associated with a standard debugger.

The debug monitor can have access to other components of the portable device such as a logs module . For example the logs module can provide information about logs that are maintained on the portable device. Log information can include historical data such as event information that can be used to detect problems on the portable device that may have occurred before the debug monitor was attached to the portable device for debug purposes. For instance a particular line in an event log can indicate the occurrence of an error or a specific event e.g. user actions or inputs on a cell phone a bad chip etc. . Such log information can be used to diagnose and or reconstruct a problem with the portable device. In a sense log information can serve as a black box making it possible for the debug monitor to determine the cause for a software and or hardware failure long after the event occurred. For example a technician may be able to debug a problem by viewing log information displayed in the debug monitor without ever using the debugger to step through code.

The virtual machines to which the debug monitor communicates can include Java virtual machines JVMs . Depending on the type of the virtual machine being used e.g. JVM or other different types of debug protocols can be used for communicating with the virtual machines. When a Java Debug Wire Protocol JDWP is used for example unused bytes in the protocol can be used to insert vendor specific packets that communicate state information queries to the JVMs.

In some implementations the debuggers the debug monitor and the virtual machines can be on the same portable device. For example a portable device such as a cell phone or PDA can include one or more debuggers and a debug monitor in addition to the virtual machines e.g. JVMs that comprise the cell phone. This configuration can be useful for example in debugging a cell phone without having to connect to a front end debugging device such as the workstation .

To interface with debuggers the debug monitor can include an port that can receive debug commands entered on the debugger A . The port can include a port listener which can be for example assigned to the debugger A . Such assignment can occur for example when the debugger A first connects to the debug monitor . The debug monitor can use the port listener to listen for query commands entered on the debugger A that the debug monitor is to forward to the appropriate one of the virtual machines . Other debuggers such as debuggers and can have their own port listeners similar to port listener . Alternatively the debuggers can each share the port as a default communications port as well as broadcasting to other debugger specific ports as well. For example the port may be a default port number typically used for debuggers.

The debug monitor can also use ports for the interface it uses to communicate with the portable device . Separate ports can exist for each of the virtual machines . These ports can be determined via a query of logs output by the virtual machines using a log query process previously described. After the determination of ports used by the virtual machines the port listeners can be assigned to the ports. The port listeners can facilitate communication with the corresponding virtual machines . For example port listener can correspond to the port used for communicating with the virtual machine A . Similarly port listeners and can be used for virtual machines and respectively. Correlations between port listeners and virtual machines are depicted in using numeric port numbers in the range . For example port listener and the virtual machine A both reference the same numeric port number indicating this port is used for communication between the virtual machine A and the debug monitor .

The debug monitor can include a selected virtual machine component that connects a debugger to a virtual machine. In certain implementations once a connection is established between the debug monitor and the debugger a user is free to select a different virtual machine without disturbing a debug connection established between the debug monitor and the portable device. For example if the selected virtual machine component is used to select a virtual machine corresponding to port connecting a debugger to port or will have the same effect namely establishment of communication between the debugger and the virtual machine. If the virtual machine component is used to select a virtual machine corresponding to port connecting the debugger to port or will have the same effect. In this way a debugger communicating via port can communicate with different virtual machines without changing ports because the selected virtual machine component can monitor debug communications on for example port and can pass them to the selected virtual machine regardless of the virtual machine s current port. The selected virtual machine component can access port virtual machine assignments from a data table or other data structure for look up when messages e.g. debug commands and responses are sent through the debug monitor .

For example when a debug command e.g. tell me the value of variable XYZ at this moment is issued at a debugger e.g. the debugger A the debug monitor can receive the debug command. Specifically the debug command can be received by the debug monitor via the port listener that is a default port that is monitored for debug communications. The user can select a virtual machine to debug using the user interface module of the debug monitor . The selected virtual machine component can determine the port number for the selected virtual machine using information such as a port look up table. In the example of the port number for the selected virtual machine is . As such the debug query can be routed directly to the virtual machine A for which the debug command was intended. In response the virtual machine A can respond to the query e.g. the value of variable XYZ is 29.0 . The response can be routed through the same port that handled the query and then passed to the debugger currently connected via the port .

The process optionally begins when a remote client device e.g. a cell phone PDA etc. is connected . As was described with reference to the connection can be between the workstation coupled with the server and the portable device . Using such a connection the debugger can be connected to an application executing on one of the virtual machines . Such a connection can occur when a user using the workstation selects an application to be debugged. For example the user may be preparing to debug a Web application on a PDA after connecting the workstation to the portable device e.g. the PDA .

The connection to the remote client device can be optional. For example referring to the debug monitor can instead connect to the portable device emulator that is installed on the workstation .

A debug monitor is then started . For example referring to the debug monitor on the workstation can be started.

A device is selected from which to scan for virtual machines . For example a user can select that the debug monitor scan the portable device which can include one or more virtual machines that are being executed by the device . The scan detects the virtual machines executing on the portable device . In another implementations the scan can also detect the virtual machines installed on the device regardless of whether the virtual machines are being executed by the device or not.

In another example the user selects the local workstation to scan. The debug monitor can scan the workstation for virtual machines executed by an emulator or multiple emulators that are currently running on the workstations. Additionally the scan may also detect virtual machines that are installed regardless of whether they are currently executed by the emulator s .

In yet another example both the local workstation and a portable device can be selected. For example a user can select that a scan for virtual machines be initiated on both the local workstation and a portable device.

A virtual machine is selected from the selected device . For example once the virtual machines are detected a user can select one of the virtual machines using a user interface such as the user interface module .

It is determined whether state information about the selected virtual machine is requested . For example the debug monitor can issue messages requesting state information about the selected virtual machine. If these messages are generated the method can proceed to step where the state information is received by the debug monitor.

If no further information about the selected virtual machine is to be requested then the method can proceed to step . For example a message requesting state information may have been previously transmitted to the virtual machine and may not need updating.

After receiving the state information it can be displayed to the user using the device monitor GUI . Some state information can be constantly updated by the debug monitor which would require repeating the steps . For example information that can be provided and updated automatically can include memory information and processing information . In other implementations some state information may be requested by the user. For example information that can be requested through direct user interaction can include a screen capture from the device . For instance the user can enter a command using the device monitor GUI to capture the current screen display of the portable device running the application being debugged.

In step it is determined whether to connect a debugger to a selected virtual machine. For example a user may start a debugger in order to debug an application or process executing on a selected virtual machine. In some implementations the debug monitor can automatically detect when a debugger is executed and can monitor a port assigned to the debugger. In another implementation the debug monitor simply monitors a default port that all or most debuggers use to communicate.

Communications are passed between the debugger and the selected virtual machine . For example the communications can include debug commands e.g. debug queries for virtual machine A and responses e.g. debug responses for virtual machine A .

A determination can be made to connect additional debuggers . If a new debugger is connected step can be performed. For example a user may start a different debugger to debug a different application or process that is executed by a different virtual machine. In this case a user selects the different virtual machine and steps starting with step can be repeated. Alternatively although not shown in the flow chart the method can proceed directly to step if a new virtual machine is not selected e.g. if the new debugger to connect is executed by the currently selected virtual machine .

In either case when step is executed again the debug monitor can detect the execution of the new debugger and monitor a communications port assigned to the debugger or the debug monitor can simply monitor a default communications port. A user may select the different application or process to debug. The method can then proceed again to step where the debug monitor can pass communications between the newly selected application or process and the newly connected debugger.

The screenshot can include several sections or display areas such as a virtual machines display area a selected virtual machine display area an image capture display area and a log display area . The information displayed in these areas can change dynamically. For example the information in the areas can change as new live state information is received from the portable device from which the data is derived. Moreover selections in one area can affect data displayed in another area. For example the threads displayed in the selected virtual machine display area can depend on the virtual machine selected in the virtual machines display area .

In another example the log information displayed in the log display area can also depend on the virtual machine selected in the virtual machines display area .

The virtual machines display area can identify all of the virtual machines and the ports associated with them. Each entry or line in the virtual machines display area can represent a separate virtual machine. A client name column can identify the name of the virtual machine. For example if the virtual machine is associated with cell phone functions the client name column can contain com.google.android.phone for the device s entry in the virtual machines display area .

A debug port column can identify a numeric port ID of each virtual machine. The debug port column entry for the system process virtual machine indicates that the debugger for this virtual machine is communicating with the debug monitor via port . The virtual machine installed on a portable device however is communicating using port . The debug monitor receives the commands from the debugger on the port and transmits then to the virtual machine using the port as described for example in association with .

The selected virtual machine display area can summarize information about a selected virtual machine such as the active threads and other information corresponding to the virtual machine selected from the virtual machines display area . For example as depicted the selected virtual machine display area shows information for the system process virtual machine entry . The selected virtual machine display area includes a control for selecting the type of information e.g. threads heaps etc. that the user can display for a selected virtual machine. For example as depicted the Threads tab is selected from the control and as such thread information is displayed in the selected virtual machine display area .

When thread information is displayed each of the rows or entries in the selected virtual machine display area can correspond to a particular thread executing on the selected virtual machine. For example a thread entry can list information for a thread named android.server.ServerThread that is running on the system process virtual machine entry . Other columns in the selected virtual machine display area can include an ID a thread ID a thread status a user time and a system time . As depicted for the thread entry the ID is 11 the thread ID is 636 the thread status is wait the user time is 2177 e.g. 2177 milliseconds and the system time is 157. IDs and thread IDs can be assigned sequentially as new threads are started and the thread ID can serve as the primary sort of information in the selected virtual machine display area . Statuses that can be displayed in the thread status can include various thread states such as running sleeping blocked waiting initializing starting native executing native code waiting on a virtual machine resource suspended etc.

The image capture display area can be used to display images captured from devices that are connected to the debug monitor . For example if the user is debugging the photo capture function of a cell phone e.g. to determine problems with resolution or cropping image capture display area can display the captured image from the cell phone. In some implementations the image capture display area can continually display the image of a display area on a portable device.

The log display area can be used to display log information for the currently selected virtual machine. Each row in the log display area can represent a specific event. In some cases when larger amounts of information are to be written to a log the information can span several lines or rows. The log information can be organized chronologically such as by ascending order of the value in a time column . The time value in the time column can include a date and a time. Time values can be represented to a fraction of a second e.g. thousandths of a second .

Additional columns representing log information can include a process ID column a priority column a tag column and a message column . The process ID column can identify the numeric ID e.g. etc. corresponding to a thread in the selected virtual machine display area . The priority column can identify a priority or type for a corresponding log message. Possible priorities can include Verbose V Debug D Information I Warning W or Error E . For example as shown in the displayed messages are classified as Information and Debug log messages.

The tag column can be used to display a descriptive tag or name associated with a log entry such as Battery Service when the log entry corresponds to servicing the battery in the device or dalvikvm gc when the Dalvikvm garbage collection system performs a function or any other tag that can be associated with a thread that updates the log. The message column can identify the actual message can that provide the rationale for the log entry in the first place. Such a message column can contain messages for current events and statistics. For example a two line entry in the log file can have a header line that reads Current GC heap utilization . . . and a second line that provides statistical information e.g. Grow heap from 2.5 to . . . .

In some implementations controls can exist for performing operations on the log information. For example a search function can allow the user to search the log information for specific search terms. In some implementations previously executed search terms can be saved and reused such as in a Search Favorites area. The process of searching can highlight the specified search terms in the located entry. The log display area can include sorting controls which can be used for example to sort the log information by specific columns such as by the tag column effectively grouping log events by the entities that caused them. Other controls in the log display area can include controls operable to for example sort log information. For example a log control panel includes V D I W and E buttons that allow a user to sort by the log message types previously described.

The screenshot can include other controls such as a control that can include options for updating the threads displayed updating heap information that is displayed halting the execution of a thread performing garbage collection etc. The screenshot can also include a registry area which can be used to display the ID and serial number of the portable device that is connected to the debug monitor. If more than one portable device or emulator is connected to the debug monitor a user can select a desired device or emulator from the registry area .

Referring now to the exterior appearance of an exemplary device that implements the multiple use debug connection is illustrated. Briefly and among other things the device includes a processor configured to establish a connection with one or more virtual machines e.g. using a debugger protocol configured to communicate debug commands to an application executed by the virtual machine transmit a request for a current state of the one or more virtual machines using the debugger protocol and output the current state information of the one or more virtual machines for display to a user upon request of a user of the mobile device.

In more detail the hardware environment of the device includes a display for displaying text images and video to a user a keyboard for entering text data and user commands into the device a pointing device for pointing selecting and adjusting objects displayed on the display an antenna a network connection a camera a microphone and a speaker . Although the device shows an external antenna it is anticipated that the device can instead or additionally include an internal antenna which is not visible to the user.

The display can display video graphics images and text that make up the user interface for the software applications used by the device and the operating system programs used to operate the device . Among the possible elements that may be displayed on the display are a new mail indicator that alerts a user to the presence of a new message an active call indicator that indicates that a telephone call is being received placed or is occurring a data standard indicator that indicates the data standard currently being used by the device to transmit and receive data a signal strength indicator that indicates a measurement of the strength of a signal received by via the antenna such as by using signal strength bars a battery life indicator that indicates a measurement of the remaining battery life or a clock that outputs the current time.

The display may also show application icons representing various applications available to the user such as a web browser application icon a phone application icon a search application icon a contacts application icon a mapping application icon an email application icon or other application icons. In one example implementation the display is a quarter video graphics array QVGA thin film transistor TFT liquid crystal display LCD capable of 16 bit or better color.

A user uses the keyboard or keypad to enter commands and data to operate and control the operating system and applications that can be debugged using the multiple use debug connection. The keyboard includes standard keyboard buttons or keys associated with alphanumeric characters such as keys and that are associated with the alphanumeric characters Q and W when selected alone or are associated with the characters and 1 when pressed in combination with key . A single key may also be associated with special characters or functions including unlabeled functions based upon the state of the operating system or applications invoked by the operating system. For example when an application calls for the input of a numeric character a selection of the key alone may cause a 1 to be input.

In addition to keys traditionally associated with an alphanumeric keypad the keyboard also includes other special function keys such as an establish call key that causes a received call to be answered or a new call to be originated a terminate call key that causes the termination of an active call a drop down menu key that causes a menu to appear within the display a backwards navigation key that causes a previously accessed network address to be accessed again a favorites key that causes an active web page to be placed in a bookmarks folder of favorite sites or causes a bookmarks folder to appear a home page key that causes an application invoked on the device to navigate to a predetermined network address or other keys that provide for multiple way navigation application selection and power and volume control.

The user uses the pointing device to select and adjust graphics and text objects displayed on the display as part of the interaction with and control of the device and the applications invoked on the device . The pointing device is any appropriate type of pointing device and may be a joystick a trackball a touch pad a camera a voice input device a touch screen device implemented in combination with the display or any other input device.

The antenna which can be an external antenna or an internal antenna is a directional or omni directional antenna used for the transmission and reception of radiofrequency RF signals that implement point to point radio communication wireless local area network LAN communication or location determination. The antenna may facilitate point to point radio communication using the Specialized Mobile Radio SMR cellular or Personal Communication Service PCS frequency bands and may implement the transmission of data using any number or data standards. For example the antenna may allow data to be transmitted between the device and a base station using technologies such as Wireless Broadband WiBro Worldwide Interoperability for Microwave ACCess WiMAX Long Term Evolution LTE Ultra Mobile Broadband UMB High Performance Radio Metropolitan Network HIPERMAN iBurst or High Capacity Spatial Division Multiple Access HC SDMA High Speed OFDM Packet Access HSOPA High Speed Packet Access HSPA HSPA Evolution HSPA High Speed Upload Packet Access HSUPA High Speed Downlink Packet Access HSDPA Generic Access Network GAN Time Division Synchronous Code Division Multiple Access TD SCDMA Evolution Data Optimized or Evolution Data Only EVDO Time Division Code Division Multiple Access TD CDMA Freedom Of Mobile Multimedia Access FOMA Universal Mobile Telecommunications System UMTS Wideband Code Division Multiple Access W CDMA Enhanced Data rates for GSM Evolution EDGE Enhanced GPRS EGPRS Code Division Multiple Access 2000 CDMA2000 Wideband Integrated Dispatch Enhanced Network WiDEN High Speed Circuit Switched Data HSCSD General Packet Radio Service GPRS Personal Handy Phone System PHS Circuit Switched Data CSD Personal Digital Cellular PDC CDMAone Digital Advanced Mobile Phone System D AMPS Integrated Digital Enhanced Network IDEN Global System for Mobile communications GSM DataTAC Mobitex Cellular Digital Packet Data CDPD Hicap Advanced Mobile Phone System AMPS Nordic Mobile Phone NMP Autoradiopuhelin ARP Autotel or Public Automated Land Mobile PALM Mobiltelefonisystem D MTD Offentlig Landmobil Telefoni OLT Advanced Mobile Telephone System AMTS Improved Mobile Telephone Service IMTS Mobile Telephone System MTS Push To Talk PTT or other technologies. Communication via W CDMA HSUPA GSM GPRS and EDGE networks may occur for example using a QUALCOMM MSM7200A chipset with an QUALCOMM RTR6285 transceiver and PM7540 power management circuit.

The wireless or wireline computer network connection may be a modem connection a local area network LAN connection including the Ethernet or a broadband wide area network WAN connection such as a digital subscriber line DSL cable high speed internet connection dial up connection T 1 line T 3 line fiber optic connection or satellite connection. The network connection may connect to a LAN network a corporate or government WAN network the Internet a telephone network or other network. The network connection uses a wireline or wireless connector. Example wireless connectors include for example an INFRARED DATA ASSOCIATION IrDA wireless connector a Wi Fi wireless connector an optical wireless connector an INSTITUTE OF ELECTRICAL AND ELECTRONICS ENGINEERS IEEE Standard 802.11 wireless connector a BLUETOOTH wireless connector such as a BLUETOOTH version 1.2 or 3.0 connector a near field communications NFC connector an orthogonal frequency division multiplexing OFDM ultra wide band UWB wireless connector a time modulated ultra wide band TM UWB wireless connector or other wireless connector. Example wireline connectors include for example a IEEE 1394 FIREWIRE connector a Universal Serial Bus USB connector including a mini B USB interface connector a serial port connector a parallel port connector or other wireline connector. In another implementation the functions of the network connection and the antenna are integrated into a single component.

The camera allows the device to capture digital images and may be a scanner a digital still camera a digital video camera other digital input device. In one example implementation the camera is a 3 mega pixel MP camera that utilizes a complementary metal oxide semiconductor CMOS .

The microphone allows the device to capture sound and may be an omni directional microphone a unidirectional microphone a bi directional microphone a shotgun microphone or other type of apparatus that converts sound to an electrical signal. The microphone may be used to capture sound generated by a user for example when the user is speaking to another user during a telephone call via the device . Conversely the speaker allows the device to convert an electrical signal into sound such as a voice from another user generated by a telephone application program or a ring tone generated from a ring tone application program. Furthermore although the device is illustrated in as a handheld device in further implementations the device may be a laptop a workstation a midrange computer a mainframe an embedded system telephone desktop PC a tablet computer a PDA or other type of computing device.

The CPU can be one of a number of computer processors including microprocessors microcontrollers and other types of integrated circuit controller chips. In one arrangement the computer CPU is more than one processing unit. The RAM interfaces with the computer bus so as to provide quick RAM storage to the CPU during the execution of software programs such as the operating system application programs and device drivers. More specifically the CPU loads computer executable process steps from the storage medium or other media into a field of the RAM in order to execute software programs. Data is stored in the RAM where the data is accessed by the computer CPU during execution. In one example configuration the device includes at least 128 MB of RAM and 256 MB of flash memory.

The storage medium itself may include a number of physical drive units such as a redundant array of independent disks RAID a floppy disk drive a flash memory a USB flash drive an external or internal hard disk drive thumb drive pen drive key drive a High Density Digital Versatile Disc HD DVD optical disc drive an internal hard disk drive a Blu Ray optical disc drive or a Holographic Digital Data Storage HDDS optical disc drive an external mini dual in line memory module DIMM synchronous dynamic random access memory SDRAM or an external micro DIMM SDRAM. Such computer readable storage media allow the device to access computer executable process steps application programs and the like stored on removable and non removable memory media to off load data from the device or to upload data onto the device .

A computer program product is tangibly embodied in storage medium a machine readable storage medium. The computer program product includes instructions that when read by a machine operate to cause a data processing apparatus to establish a multiple use debug connection with the mobile device. In some embodiments the computer program product includes instructions that establish a connection with one or more virtual machines e.g. using a debugger protocol configured to communicate debug commands to an application executed by the virtual machine transmit a request for a current state of the one or more virtual machines using the debugger protocol and output the current state information of the one or more virtual machines for display to a user.

The operating system may be a LINUX based operating system such as the GOOGLE mobile device platform operating system APPLE MAC OS X MICROSOFT WINDOWS NT WINDOWS 2000 WINDOWS XP WINDOWS MOBILE a variety of UNIX flavored operating systems or a proprietary operating system for computers or embedded systems. The application development platform or framework for the operating system may be BINARY RUNTIME ENVIRONMENT FOR WIRELESS BREW JAVA Platform Micro Edition JAVA ME or JAVA 2 Platform Micro Edition J2ME using the SUN MICROSYSTEMS JAVASCRIPT programming language PYTHON FLASH LITE or MICROSOFT .NET Compact or another appropriate environment.

The device stores computer executable code for the operating system and the application programs such as an email instant messaging a video service application a mapping application word processing spreadsheet presentation gaming mapping web browsing JAVASCRIPT engine or other applications. For example one implementation may allow a user to access the GOOGLE GMAIL email application the GOOGLE TALK instant messaging application a YOUTUBE video service application a GOOGLE MAPS or GOOGLE EARTH mapping application or a GOOGLE PICASA imaging editing and presentation application. The application programs may also include a widget or gadget engine such as a TAFRI widget engine a MICROSOFT gadget engine such as the WINDOWS SIDEBAR gadget engine or the KAPSULES gadget engine a YAHOO widget engine such as the KONFABULTOR widget engine the APPLE DASHBOARD widget engine the GOOGLE gadget engine the KLIPFOLIO widget engine an OPERA widget engine the WIDSETS widget engine a proprietary widget or gadget engine or other widget or gadget engine the provides host system software for a physically inspired applet on a desktop.

Although it is possible to provide for the multiple use debug connection using the above described implementation it is also possible to implement the functions according to the present disclosure as a dynamic link library DLL or as a plug in to other application programs such as an Internet web browser such as the FOXFIRE web browser the APPLE SAFARI web browser or the MICROSOFT INTERNET EXPLORER web browser.

The navigation module may determine an absolute or relative position of the device such as by using the Global Positioning System GPS signals the GLObal NAvigation Satellite System GLONASS the Galileo positioning system the Beidou Satellite Navigation and Positioning System an inertial navigation system a dead reckoning system or by accessing address internet protocol IP address or location information in a database. The navigation module may also be used to measure angular displacement orientation or velocity of the device such as by using one or more accelerometers.

The operating system can generally be organized into six components a kernel libraries an operating system runtime application libraries system services and applications . The kernel includes a display driver that allows software such as the operating system and the application programs to interact with the display via the display interface a camera driver that allows the software to interact with the camera via the camera interface a BLUETOOTH driver an M Systems driver a binder IPC driver a USB driver a keypad driver that allows the software to interact with the keyboard via the keyboard interface a WiFi driver audio drivers that allow the software to interact with the microphone and the speaker via the sound interface and a power management component that allows the software to interact with and manage the power source .

The BLUETOOTH driver which in one implementation is based on the BlueZ BLUETOOTH stack for LIN WC based operating systems provides profile support for headsets and hands free devices dial up networking personal area networking PAN or audio streaming such as by Advance Audio Distribution Profile A2DP or Audio Video Remote Control Profile AVRCP . The BLUETOOTH driver provides JAVA bindings for scanning pairing and unpairing and service queries.

The libraries include a media framework that supports standard video audio and still frame formats such as Moving Picture Experts Group MPEG 4 H.264 MPEG 1 Audio Layer 3 MP3 Advanced Audio Coding AAC Adaptive Multi Rate AMR Joint Photographic Experts Group JPEG and others using an efficient JAVA Application Programming Interface API layer a surface manager a simple graphics library SGL for two dimensional application drawing an Open Graphics Library for Embedded Systems OpenGL ES for gaming and three dimensional rendering a C standard library LIBC a LIBWEBCORE library a FreeType library an SSL and an SQLite library .

The operating system runtime includes core JAVA libraries and a Dalvik virtual machine . The Dalvik virtual machine is a virtual machine that runs a customized file format .DEX . The virtual machine can include debug connection code used to recognize state queries and other information requested by the debug monitor.

The operating system can also include Mobile Information Device Profile MIDP components such as the MIDP JAVA Specification Requests JSRs components MIDP runtime and MIDP applications as shown in . The MIDP components can support MIDP applications running on the device .

With regard to graphics rendering a system wide composer manages surfaces and a frame buffer and handles window transitions using the OpenGL ES and two dimensional hardware accelerators for its compositions.

The Dalvik virtual machine may be used with an embedded environment since it uses runtime memory very efficiently implements a CPU optimized bytecode interpreter and supports multiple virtual machine processes per device. The custom file format .DEX is designed for runtime efficiency using a shared constant pool to reduce memory read only structures to improve cross process sharing concise and fixed width instructions to reduce parse time thereby allowing installed applications to be translated into the custom file formal at build time. The associated bytecodes are designed for quick interpretation since register based instead of stack based instructions reduce memory and dispatch overhead since using fixed width instructions simplifies parsing and since the 16 bit code units minimize reads.

The application libraries include a view system a resource manager and content providers . The system services includes a status bar an application launcher a package manager that maintains information for all installed applications a telephony manager that provides an application level JAVA interface to the telephony subsystem a notification manager that allows all applications access to the status bar and on screen notifications a window manager that allows multiple applications with multiple windows to share the display and an activity manager that runs each application in a separate process manages an application life cycle and maintains a cross application history.

The applications include a home application a dialer application a contacts application and a browser application .

The telephony manager provides event notifications such as phone state network state Subscriber Identity Module SIM status or voicemail status allows access to state information such as network information SIM information or voicemail presence initiates calls and queries and controls the call state. The browser application renders web pages in a full desktop like manager including navigation functions. Furthermore the browser application allows single column small screen rendering and provides for the embedding of HTML views into other applications.

Some processes can be persistent. For example processes associated with core system components such as the surface manager the window manager or the activity manager can be continuously executed while the device is powered. Additionally some application specific process can also be persistent. For example processes associated with the dialer application may also be persistent.

The processes implemented by the operating system kernel may generally be categorized as system services processes dialer processes browser processes and maps processes . The system services processes include status bar processes associated with the status bar application launcher processes associated with the application launcher package manager processes associated with the package manager activity manager processes associated with the activity manager resource manager processes associated with a resource manager that provides access to graphics localized strings and XML layout descriptions notification manger processes associated with the notification manager window manager processes associated with the window manager core JAVA libraries processes associated with the core JAVA libraries surface manager processes associated with the surface manager LIBC processes associated with the LIBC library and Dalvik virtual machine processes associated with the Dalvik virtual machine . As described previously the virtual machine can include debugger connection code that permits the virtual machine to receive and respond to queries from the debug monitor. Although not shown in the this code can be included in the other virtual machines as well.

The dialer processes include dialer application processes associated with the dialer application telephony manager processes associated with the telephony manager core JAVA libraries processes associated with the core JAVA libraries Dalvik virtual machine processes associated with the Dalvik Virtual machine and LIBC processes associated with the LIBC library . The browser processes include browser application processes associated with the browser application core JAVA libraries processes associated with the core JAVA libraries Dalvik virtual machine processes associated with the Dalvik virtual machine LIBWEBCORE processes associated with the LIBWEBCORE library and LIBC processes associated with the LIBC library .

The maps processes include maps application processes core JAVA libraries processes Dalvik virtual machine processes and LIBC processes . Notably some processes such as the Dalvik virtual machine processes may exist within one or more of the systems services processes the dialer processes the browser processes and the maps processes .

Computing device includes a processor memory a storage device a high speed interface connecting to memory and high speed expansion ports and a low speed interface connecting to low speed bus and storage device . Each of the components and are interconnected using various busses and may be mounted on a common motherboard or in other manners as appropriate. The processor can process instructions for execution within the computing device including instructions stored in the memory or on the storage device to display graphical information for a GUI on an external input output device such as display coupled to high speed interface . In other implementations multiple processors and or multiple buses may be used as appropriate along with multiple memories and types of memory. Also multiple computing devices may be connected with each device providing portions of the necessary operations e.g. as a server bank a group of blade servers or a multi processor system .

The memory stores information within the computing device . In one implementation the memory is a volatile memory unit or units. In another implementation the memory is a non volatile memory unit or units. The memory may also be another form of computer readable medium such as a magnetic or optical disk.

The storage device is capable of providing mass storage for the computing device . In one implementation the storage device may be or contain a computer readable medium such as a floppy disk device a hard disk device an optical disk device or a tape device a flash memory or other similar solid state memory device or an array of devices including devices in a storage area network or other configurations. A computer program product can be tangibly embodied in an information carrier. The computer program product may also contain instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory the storage device memory on processor or a propagated signal.

The high speed controller manages bandwidth intensive operations for the computing device while the low speed controller manages lower bandwidth intensive operations. Such allocation of functions is exemplary only. In one implementation the high speed controller is coupled to memory display e.g. through a graphics processor or accelerator and to high speed expansion ports which may accept various expansion cards not shown . In the implementation low speed controller is coupled to storage device and low speed expansion port . The low speed expansion port which may include various communication ports e.g. USB Bluetooth Ethernet wireless Ethernet may be coupled to one or more input output devices such as a keyboard a pointing device a scanner or a networking device such as a switch or router e.g. through a network adapter.

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a standard server or multiple times in a group of such servers. It may also be implemented as part of a rack server system . In addition it may be implemented in a personal computer such as a laptop computer . Alternatively components from computing device may be combined with other components in a mobile device not shown such as device . Each of such devices may contain one or more of computing device and an entire system may be made up of multiple computing devices communicating with each other.

Computing device includes a processor memory an input output device such as a display a communication interface and a transceiver among other components. The device may also be provided with a storage device such as a microdrive or other device to provide additional storage. Each of the components and are interconnected using various buses and several of the components may be mounted on a common motherboard or in other manners as appropriate.

The processor can execute instructions within the computing device including instructions stored in the memory . The processor may be implemented as a chipset of chips that include separate and multiple analog and digital processors. The processor may provide for example for coordination of the other components of the device such as control of user interfaces applications run by device and wireless communication by device .

Processor may communicate with a user through control interface and display interface coupled to a display . The display may be for example a TFT LCD Thin Film Transistor Liquid Crystal Display or an OLED Organic Light Emitting Diode display or other appropriate display technology. The display interface may comprise appropriate circuitry for driving the display to present graphical and other information to a user. The control interface may receive commands from a user and convert them for submission to the processor . In addition an external interface may be provide in communication with processor so as to enable near area communication of device with other devices. External interface may provide for example for wired communication in some implementations or for wireless communication in other implementations and multiple interfaces may also be used.

The memory stores information within the computing device . The memory can be implemented as one or more of a computer readable medium or media a volatile memory unit or units or a non volatile memory unit or units. Expansion memory may also be provided and connected to device through expansion interface which may include for example a SIMM Single In Line Memory Module card interface. Such expansion memory may provide extra storage space for device or may also store applications or other information for device . Specifically expansion memory may include instructions to carry out or supplement the processes described above and may include secure information also. Thus for example expansion memory may be provide as a security module for device and may be programmed with instructions that permit secure use of device . In addition secure applications may be provided via the SIMM cards along with additional information such as placing identifying information on the SIMM card in a non hackable manner.

The memory may include for example flash memory and or NVRAM memory as discussed below. In one implementation a computer program product is tangibly embodied in an information carrier. The computer program product contains instructions that when executed perform one or more methods such as those described above. The information carrier is a computer or machine readable medium such as the memory expansion memory memory on processor or a propagated signal that may be received for example over transceiver or external interface .

Device may communicate wirelessly through communication interface which may include digital signal processing circuitry where necessary. Communication interface may provide for communications under various modes or protocols such as GSM voice calls SMS EMS or MMS messaging CDMA TDMA PDC WCDMA CDMA2000 or GPRS among others. Such communication may occur for example through radio frequency transceiver . In addition short range communication may occur such as using a Bluetooth WiFi or other such transceiver not shown . In addition GPS Global Positioning System receiver module may provide additional navigation and location related wireless data to device which may be used as appropriate by applications running on device .

Device may also communicate audibly using audio codec which may receive spoken information from a user and convert it to usable digital information. Audio codec may likewise generate audible sound for a user such as through a speaker e.g. in a handset of device . Such sound may include sound from voice telephone calls may include recorded sound e.g. voice messages music files etc. and may also include sound generated by applications operating on device .

The computing device may be implemented in a number of different forms as shown in the figure. For example it may be implemented as a cellular telephone . It may also be implemented as part of a smartphone personal digital assistant or other similar mobile device.

Various implementations of the systems and techniques described here can be realized in digital electronic circuitry integrated circuitry specially designed ASICs application specific integrated circuits computer hardware firmware software and or combinations thereof. These various implementations can include implementation in one or more computer programs that are executable and or interpretable on a programmable system including at least one programmable processor which may be special or general purpose coupled to receive data and instructions from and to transmit data and instructions to a storage system at least one input device and at least one output device.

These computer programs also known as programs software software applications or code include machine instructions for a programmable processor and can be implemented in a high level procedural and or object oriented programming language and or in assembly machine language. As used herein the terms machine readable medium computer readable medium refers to any computer program product apparatus and or device e.g. magnetic discs optical disks memory Programmable Logic Devices PLDs used to provide machine instructions and or data to a programmable processor including a machine readable medium that receives machine instructions as a machine readable signal. The term machine readable signal refers to any signal used to provide machine instructions and or data to a programmable processor.

To provide for interaction with a user the systems and techniques described here can be implemented on a computer having a display device e.g. a CRT cathode ray tube or LCD liquid crystal display monitor for displaying information to the user and a keyboard and a pointing device e.g. a mouse or a trackball by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well for example feedback provided to the user can be any form of sensory feedback e.g. visual feedback auditory feedback or tactile feedback and input from the user can be received in any form including acoustic speech or tactile input.

The systems and techniques described here can be implemented in a computing system that includes a back end component e.g. as a data server or that includes a middleware component e.g. an application server or that includes a front end component e.g. a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the systems and techniques described here or any combination of such back end middleware or front end components. The components of the system can be interconnected by any form or medium of digital data communication e.g. a communication network . Examples of communication networks include a local area network LAN a wide area network WAN and the Internet.

The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client server relationship to each other.

Although a few implementations have been described in detail above other modifications are possible. For example the debug monitor can also serve as an interface between the various debuggers and the debugger protocol such as by converting debugger commands into a format used by the debugger protocol e.g. as queries and . Moreover the debug monitor can transform the query responses and into the format used by the debuggers .

In addition the logic flows depicted in the figures do not require the particular order shown or sequential order to achieve desirable results. In addition other steps may be provided or steps may be eliminated from the described flows and other components may be added to or removed from the described systems. Accordingly other implementations are within the scope of the following claims.

