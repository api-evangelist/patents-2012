---

title: Graph query processing using plurality of engines
abstract: Graph queries are processed using a plurality of independent query execution engines. A graph query submitted to a graph database which is modeled by an attributed graph is received. The graph query is decomposed into a plurality of query components. For each of the query components, a one of the query execution engines that is available to process the query component is identified, a sub-query representing the query component is generated, the sub-query is sent to the identified query execution engine for processing, and results for the sub-query are received from the identified query execution engine. The results received are then combined to generate a response to the graph query.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09053210&OS=09053210&RS=09053210
owner: MICROSOFT TECHNOLOGY LICENSING, LLC
number: 09053210
owner_city: Redmond
owner_country: US
publication_date: 20121214
---
A graph database is a type of data structure where one or more graphs are used to model the structural relationships between data objects in a data set. Each of the graphs employs nodes also known as vertices edges and attributes also known as properties to represent and store the data objects. Generally speaking the nodes in a given graph represent entity instances such as people businesses accounts or any other item of interest. The edges in the graph represent the connections that exist between pairs of nodes. The attributes in the graph are pertinent data that relates to the nodes. Depending on the particular type of graph e.g. the particular type of data model being implemented the attributes in the graph may also be pertinent data that relates to the edges. It is becoming increasingly popular to use graph databases to model complicated large data sets in a variety of application domains such as bioinformatics applications cheminformatics applications repositories of business process models social network applications bibliographic network applications and knowledge base applications.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described hereafter in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter.

Graph query processing technique embodiments described herein generally involve responding to graph queries. In an exemplary embodiment a graph query submitted to a graph database which is modeled by an attributed graph is received. The graph query is then decomposed into a plurality of query components. Then for each of the query components a one of a plurality of independent query execution engines that is available to process the query component is identified a sub query representing the query component is generated the sub query is sent to the identified query execution engine for processing and results for the sub query are received from the identified query execution engine. The results received are then combined to generate a response to the graph query.

In the following description of graph query processing technique embodiments reference is made to the accompanying drawings which form a part hereof and in which are shown by way of illustration specific embodiments in which the graph query processing technique can be practiced. It is understood that other embodiments can be utilized and structural changes can be made without departing from the scope of the graph query processing technique embodiments.

It is also noted that for the sake of clarity specific terminology will be resorted to in describing the graph query processing technique embodiments described herein and it is not intended for these embodiments to be limited to the specific terms so chosen. Furthermore it is to be understood that each specific term includes all its technical equivalents that operate in a broadly similar manner to achieve a similar purpose. Reference herein to one embodiment or another embodiment or an exemplary embodiment or an alternate embodiment or one implementation or another implementation or an exemplary implementation or an alternate implementation means that a particular feature a particular structure or particular characteristics described in connection with the embodiment or implementation can be included in at least one embodiment of the graph query processing technique. The appearances of the phrases in one embodiment in another embodiment in an exemplary embodiment in an alternate embodiment in one implementation in another implementation in an exemplary implementation and in an alternate implementation in various places in the specification are not necessarily all referring to the same embodiment or implementation nor are separate or alternative embodiments implementations mutually exclusive of other embodiments implementations. Yet furthermore the order of process flow representing one or more embodiments or implementations of the graph query processing technique does not inherently indicate any particular order not imply any limitations of the graph query processing technique.

The term path is used herein to refer to a sequence of edges in a graph which are interconnected by nodes. The term attributed graph data model herein sometimes simply referred to as an attributed graph is used herein to refer to a particular type of graph that can include one or more attributes for each of the nodes in the graph and can also include one or more attributes for each of the edges in the graph. The term secondary storage device is used herein to refer to a storage device such as one or more hard disk drives or the like.

Generally speaking the graph query processing technique embodiments described herein involve responding to e.g. evaluating and answering herein sometimes also referred to as executing queries that are submitted by an entity to a graph database which is modeled by an attributed graph such queries are herein sometimes simply referred to as graph queries . This entity can be either an end user or a computing device among other things.

The graph query processing technique embodiments described herein are advantageous for various reasons including but not limited to the following. As will be appreciated from the more detailed description that follows the graph query processing technique embodiments provide a scalable indexing mechanism for attributed graphs which optimizes the efficiency of searching analyzing large attributed graphs. The graph query processing technique embodiments also accelerate the processing of many different types of graph queries without having to build and maintain different types of indices of the graph database which would consume a large amount of memory . In other words the graph query processing technique embodiments optimize the performance of graph query processing and minimize the amount of memory that is consumed during graph query processing. This memory consumption minimization allows the graph query processing technique embodiments to scale and support the querying of larger and more complex graph databases that are modeled by larger and more complex attributed graphs using a given fixed size of memory.

The graph query processing technique embodiments described herein also support querying both the topology of the attributed graph and data objects in the graph e.g. the attributes of the nodes and edges in the graph . As such the graph query processing technique embodiments can efficiently evaluate and answer a graph query that combines both predicates which are based on the topology of the attributed graph and predicates which are based on the attributes of the nodes and edges in the graph. Accordingly the graph query processing technique embodiments support the processing of a complex graph query that can include a combination of two or more different types of graph query components such as a pattern match component a reachability component and a shortest path component among others. The graph query processing technique embodiments also support interactive online graph query processing e.g. these embodiments are not limited to working in just a batch mode .

The graph query processing technique embodiments described herein also make use of the following heuristics. Due to the powerful indexing and sophisticated query optimization techniques that exist for relational database systems relational database systems are generally very efficient for executing graph queries and query components thereof that represent structural predicates or value based predicates on the attributes of nodes and or edges in an attributed graph. Additionally relational database systems are generally very efficient for finding graph query execution plans that perform well since they support the consideration of different possible execution plan variants such as different join implementations and different join orderings. In contrast relational database systems are generally inefficient for executing graph queries and query components thereof that involve operations of a recursive nature e.g. traversal operations over the topology of the attributed graph . However and as will be appreciated from the more detailed description that follows various graph engines exist which are efficient for executing such recursive operations.

Graph databases can be classified in various ways. By way of example but not limitation graph databases can be classified according to the number and size of the graphs that are used therein. More particularly graph databases that are made up of a large number of small graphs can be assigned to a first category of graph databases. Graph databases that fall into this first category are sometimes referred to as transactional graph databases and are commonly used to model the aforementioned data sets associated with bioinformatics applications cheminformatics applications and repositories of business process models among others. Graph databases that are made up of either just a single large graph or a very small number of large graphs can be assigned to a second category of graph databases. Graph databases that fall into this second category are commonly used to model the aforementioned data sets associated with social network applications bibliographic network applications and knowledge base applications among others.

There are three common types of graph queries that are commonly used to query the second category of graph databases namely a pattern match graph query a reachability graph query and a shortest path graph query. The pattern match graph query tries to find the existence s of a graph pattern e.g. either a path or a star or a sub graph among others in the large graph s . The reachability graph query verifies if a connection path exists between any two nodes in the large graph s . The shortest path graph query is a variant of the reachability graph query that returns the shortest path distance in terms of the number of edges between any two nodes which are connected in the large graph s . Both the reachability and shortest path queries may return the queried connections paths. A given complex graph query that is submitted by an entity to the second category of graph databases can include a plurality of different types of query components. More particularly and by way of example but not limitation the complex graph query can include either one or more pattern match components or one or more reachability components or one or more shortest path components. The complex graph query can also generally include any combination of these different components. More particularly the complex graph query can include one or more of one or more pattern match components or one or more reachability components or one or more shortest path components.

In many real world applications each of the nodes in the graph s can be labeled with one or more attributes that specify pertinent data relating to the node. Depending on the particular type of graph database that is being implemented each of the edges in the graph s can also be labeled with one or more attributes that specify the type of relationship that exists between the two nodes which are connected by the edge. By way of example but not limitation in a graph that is used to model a social network a given node in the graph can represent a given person in the network this node can be labeled with an attribute that specifies the age of the person and the topology of the graph can represent different types of relationships sometime referred to as directed edges that exist between the person and other people in the network. In the case where the graph is implemented as an attributed graph each of these relationships can be labeled with a start date attribute. Such a graph that can include attributes for the nodes in the graph as well as attributes for the edges in the graph is referred to herein as an attributed graph. It will be appreciated that both the topology of an attributed graph and the attributes of the nodes and edges therein represent valuable information.

An attributed graph can be formally denoted as V E L L F F A A where V is a set of the nodes in the graph EV V is a set of the edges in the graph that join two distinct nodes Lis a set of the labels for V Lis a set of the labels for E Fis a function V Lthat assigns labels to each of the nodes and Fis a function E Lthat assigns labels to each of the edges. A a a . . . a is a set of m attributes that can be associated with any node in V. Each of the nodes v V can be labeled with an attribute vector a v . . . a v where a v is the attribute value of node v on attribute a. A b b . . . b is a set of n attributes that can be associated with any edge in E. Similarly each of the edges e E can be labeled with an attribute vector b e . . . b e where b e is the attribute value of edge e on attribute b.

Referring again to a user may submit a graph query that seeks to find the names of two authors X and Y where X and Y are connected by a path of any length e.g. any number of edges the author X is affiliated at the University of New South Wales UNSW the author Y is affiliated at Microsoft and both of the authors has published a paper at the Very Large Databases 2012 conference VLDB 12 . It will be appreciated that this particular graph query includes both a pattern match component and a reachability component. A user may also submit a graph query that seeks to find the names of two authors X and Y where X and Y are connected by a path of any length the author X is affiliated at UNSW the author Y is affiliated at Microsoft both of the authors has published a paper at VLDB 12 as a first author e.g. and both of the authors has an age which is greater than or equal to 35. It will be appreciated that this particular graph query includes both a pattern match component and a reachability component where the pattern match component has conditions on the attributes of the nodes and edges in the graph snippet .

Referring again to a user may also submit a graph query that seeks to find the names of two authors X and Y and the connecting path s there between where X and Y are connected by a path having a length which is less than or equal to three edges the author X is affiliated at UNSW the author Y is affiliated at Microsoft and both of the authors has published a paper at VLDB 12 as a first author e.g. . It will be appreciated that this particular graph query includes both a pattern match component and a reachability component where the reachability component is constrained by a path filtering condition and returns data specifying the connecting path s as part of the graph query results.

Referring again to a user may also submit a graph query that seeks to find the names and the ages of two authors X and Y and the shortest path there between where the author X is affiliated at UNSW the author Y is affiliated at Microsoft and both of the authors has published a paper at VLDB 12. It will be appreciated that this particular graph query includes both a pattern match component and a shortest path component. A user may also submit a graph query that seeks to find the titles of two papers P1 and P2 and the path there between where each of the edges in the path represents a cited by relationship the maximum path length is three edges the first author of P1 is affiliated at UNSW and the first author of P2 is affiliated at Microsoft. It will be appreciated that this particular graph query includes both a pattern match component and a constrained reachability component where the pattern match component has conditions on the attributes of the edges in the graph snippet .

It will be appreciated that the foregoing graph query scenarios are exemplary and various other scenarios are also possible.

This section describes an exemplary embodiment of a graph query language herein referred to as graph SPARQL G SPARQL for querying an attributed graph. G SPARQL is advantageous for various reasons including but not limited to the following. As will be appreciated from the more detailed description that follows G SPARQL supports a declarative query programming interface which allows for optimizing the efficiency of graph query processing in situations where the programmer has little or no knowledge about the characteristics of the underlying attributed graphs. G SPARQL is also able to express graph queries about arbitrary path structures in the attributed graph. As such and as described heretofore G SPARQL supports complex graph queries that include a plurality of different types of query components such as the pattern match component the reachability component and the shortest path component among others and any combination thereof. G SPARQL is also sufficiently expressive to satisfy a wide variety of user query needs. The syntax expressions in G SPARQL are also clear and concise.

As is appreciated in the art of graph databases the conventional Resource Description Framework RDF is a family of World Wide Web Consortium W3C specifications that define a data format for modeling data objects that are implemented in web resources. In the RDF data model herein sometimes simply referred to as an RDF graph an expression that specifies a subject a predicate and an object can be used to make statements about resources in an RDF graph. Such an expression is known as a triple or triple pattern in RDF terminology and will be described in more detail hereafter.

Generally speaking the RDF graph data model can be considered to be a variant of the attributed graph data model. One difference between the RDF and attributed graph data models is the following. In an RDF graph the edges in the graph cannot be labeled with attributes that describe the edges just the nodes in an RDF graph can be labeled with attributes . In contrast and as described heretofore in an attributed graph both the nodes and the edges in the graph can be labeled with an arbitrary set of attributes. Another difference between the RDF and attributed graph data models is the following. In an RDF graph the edges in the graph are used to represent both the data in the graph e.g. the attributes of the nodes in the RDF graph and the structural relationships that exist between the nodes in the graph e.g. the topology of the RDF graph . The edges in an RDF graph represent the data in the graph by connecting the nodes to their attributes. Thus the data in an RDF graph is represented as part of the graph topology which results in a significant increase in the size of the graph topology. In contrast and as described heretofore in an attributed graph the data in the graph e.g. the attributes of the nodes and edges in the graph is represented separately from the topology of the graph.

As is appreciated in the art of database query languages SPARQL a recursive acronym for SPARQL Protocol and RDF Query Language is an industry standard query language for querying graph databases that are modeled by one or more RDF graphs. SPARQL was made an industry standard by the W3C.

SPARQL employs powerful graph pattern matching facilities that allow the binding of variables to components in the RDF graph that is being queried. A given SPARQL query defines a graph pattern P that is matched against an RDF graph G where each of the variables in P is replaced by the matching elements of G such that the resulting graph pattern is included in G e.g. graph pattern matching . The main construct of building P is known as a triple pattern in the art of graph databases. A triple pattern represents the aforementioned RDF triple subject predicate object . The subject of the triple pattern represents an entity instance e.g. a node in G. The predicate in the triple pattern represents a connection e.g. an edge to an object in G where this object can represent either another entity instance e.g. another node in G or an attribute in G. The subject predicate and object can each represent either a constant value or a variable herein denoted as var . Hence a set of different triple patterns concatenated by an AND . operator can be used to represent a desired graph pattern of a SPARQL query. The following is an exemplary SPARQL query that seeks to find all persons who are affiliated at UNSW and are at least 42 years old 

G SPARQL is a SPARQL like graph query language that can be used to query attributed graphs. G SPARQL employs the general graph pattern matching facilities of SPARQL but also enhances SPARQL in various ways including but not limited to the following. As will be appreciated from the more detailed description that follows G SPARQL introduces new constructs that also query the just described differences between the RDF and attributed graph data models. G SPARQL supports querying for a defined structural pattern in an attributed graph and allows filtering conditions to be specified on the attributes of the nodes and or edges that are part of this pattern. G SPARQL also supports querying for a defined path that connects the nodes in an attributed graph where this defined path can have an unknown length. More particularly G SPARQL allows for the expression of reachability and shortest path graph queries between the nodes where such queries can include filtering conditions on the defined path e.g. such queries can place constraints on the path length or on the types and properties of edges and nodes . G SPARQL employs a powerful algebraic compilation and re writing framework for logical query plans which serve to optimize the graph query processing. As such G SPARQL can be efficiently implemented and is able to efficiently query attributed graphs.

G SPARQL is able to differentiate between the representations of two different types of query predicates namely structural predicates and value based predicates. As will be described in more detail hereafter a structural predicate specifies a condition on the structural relationship between the nodes in an attributed graph where the subject and object of the triple pattern specify nodes and the predicate of the triple pattern specifies an edge. A value based predicate specifies a condition on the value of an attribute in the attributed graph where the subject of the triple pattern specifies either a node or an edge the predicate of the triple pattern specifies an attribute name and the object of the triple pattern specifies an attribute value.

The syntax of G SPARQL differentiates value based predicates from structural predicates in the following manner. G SPARQL prepends the predicate part of the triple pattern with the symbol when it represents a value based predicate structural predicates are not prepended with this symbol . The following are two exemplary triple patterns that illustrate this differentiation between value based and structural predicates 

Unlike the RDF graph data model the attributed graph data model allows each of the edges in an attributed graph to be labeled with an arbitrary set of one or more attributes. Therefore G SPARQL is able to differentiate between the representations of two different types of value based predicates namely node predicates and edge predicates. A node predicate specifies a condition on the attributes of a node in an attributed graph. An edge predicate specifies a condition on the attributes of an edge in the attributed graph. G SPARQL uses the standard triple pattern to represent value based predicates. G SPARQL can assign a variable to an edge which is to be qualified with more predicates. The following are two exemplary triple patterns that show predicates on node and edge attributes 

G SPARQL supports the ability to express arbitrary length paths and path patterns in two main ways. The first way is by using explicit relationships. The following are two exemplary triple patterns that illustrate this use of explicit relationships 

The second way G SPARQL supports the ability to express arbitrary length paths and path patterns is by allowing path variables in the predicate part of a triple pattern. More particularly G SPARQL supports various options for binding path variables in a path pattern. The following are four exemplary triple patterns that illustrate these options 

Generally speaking it will be appreciated that any two nodes in an attributed graph can be connected by a plurality of different paths. Accordingly G SPARQL allows for the expression of filtering conditions that can specify Boolean predicates on the nodes and edges of the matching paths which are bound to the path variable. More particularly G SPARQL supports various filtering conditions on the nodes and edges of the matching paths including but not limited to a Length PV P filtering condition an AtLeastNode PV N P filtering condition an AtMostNode PV N P filtering condition an AllNodes PV P filtering condition an AtLeastEdge PV N P filtering condition an AtMostEdge PV N P filtering condition and an AllEdges PV P filtering condition. Each of these filtering conditions will now be described in more detail.

The Length PV P filtering condition verifies that the length e.g. the number of edges of each of the matching paths which is bound to the variable PV satisfies the predicate P and filters out those paths which do not satisfy the predicate P. By way of example but not limitation the path filtering condition FilterPath Length X 

The AtLeastNode PV N P filtering condition verifies if at least N number of nodes on each of the paths which is bound to the variable PV satisfies the predicate P and filters out those paths which do not satisfy the predicate P. It is noted that this predicate can be either a structural predicate or a value based predicate. By way of example but not limitation the AtLeastNode X 2 livesIn Sydney filtering condition ensures that at least two nodes of each of the paths which is bound to the variable X satisfy the structural predicate of being connected by the livesIn relationship to a node that is labeled with an attribute having a value of Sydney. The AtLeastNode X 1 affiliated UNSW filtering condition ensures that at least one node of each of the paths which is bound to the variable X satisfies the value based predicate of the affiliated attribute having a value of UNSW.

The AtLeastEdge PV N P filtering condition ensures that at least N number of edges on each of the paths which is bound to the variable PV satisfy the value based predicate P it is noted that structural predicates may not be represented for edges . The AtMostEdge PV N P filtering condition ensures that at most N number of edges on each of the paths which is bound to the variable PV satisfy the value based predicate P. The AllEdges PV P filtering condition ensures that at every edge of each of the paths which is bound to the variable PV satisfies the value based predicate P.

It will be appreciated that the foregoing filtering conditions are exemplary and various other filtering conditions are also possible.

As is appreciated in the art of database systems relational database systems are generally efficient in executing queries that benefit from indexing e.g. B tree and query optimization techniques e.g. selectivity estimation and join ordering . By way of example but not limitation by applying predicates relational indices can limit the data that needs to be accessed to just those rows that satisfy the predicates. Additionally index only access can be used to evaluate and answer relational database queries thus eliminating the need to access the data pages by providing all the columns that are involved in the query processing. However relational database systems are inefficient in processing queries that involve looping or recursive access to a large number of records by executing a plurality of performance expensive join operators which may yield a large intermediate result. Hence executing traversal operations over a graph or a portion thereof that is stored in a relational database system can be time inefficient due to the large number of potential joins and the performance cost of having to retrieve the target nodes from the secondary storage device on which the graph or the portion thereof is stored.

Generally speaking and as is appreciated in the arts of graph databases and graph query processing various types of engines exist for executing graph queries where each different type of engine can be used to execute a certain class of graph queries. By way of example but not limitation various relational database engines also known as relational database management systems exist which can be used to execute pattern matching graph queries. Such relational database engines are commonly implemented in the form of an SQL Structured Query Language server. Exemplary relational database engines include the conventional SPARQL engines Microsoft SQL Server a registered trademark of Microsoft Corporation International Business Machines DB2 and Oracle database systems among others. Various graph engines also exist which can be used to execute reachability and shortest path graph queries. Exemplary graph engines include the conventional Neo4j graph database HyperGraphDB Virtuoso DEX and AllegroGraph among others.

As will be described in more detail hereafter the graph query processing technique embodiments described herein can use a plurality of independent query execution engines to respond to a given graph query that is submitted by an entity to a graph database which is modeled by an attributed graph. These query execution engines can include either one or more relational database engines or one or more graph engines or one or more hybrid engines which will be described in more detail hereafter . The query execution engines can also include any combination of relational database engines graph engines and hybrid engines. More particularly and by way of example but not limitation the query execution engines can include one or more relational database engines and one or more graph engines. The query execution engines can also include one or more relational database engines and one or more hybrid engines. The query execution engines can also include one or more graph engines and one or more hybrid engines. Generally speaking different parts of the graph query are sent to different ones of the query execution engines for processing. More particularly and by way of example but not limitation in an exemplary embodiment of the graph query processing technique embodiments graph query components that involve relationships in the attributed graph e.g. pattern match components are sent to either a relational database engine or a relational database component of a hybrid engine for processing and graph query components that involve the topology of the attributed graph e.g. reachability and shortest path components are sent to either a graph engine or a memory based component of a hybrid engine for processing.

Referring again to and as is appreciated in the art of database systems various approaches can be used to relationally store the attributed graph or the portion thereof in the relational database component . By way of example but not limitation the conventional fully decomposed storage model DSM can be used to store the attributed graph or the portion thereof in the relational database component . This is advantageous for various reasons including but not limited to the following. DSM is agnostic to the attributed graph schema and thus can be applied to any attributed graph having any schema. DSM also permits efficient attribute retrieval during the graph query processing by significantly reducing the relational database accesses since just the records of the tables of the particular attributes relationships that are involved in the graph query will be processed.

Referring again to an edge identifier eID is assigned to each of the edges in the snippet of the attributed graph that is illustrated in . The attributes of the edges are stored in N two column tables where N is the number of different attributes of the edges in the graph snippet N is three in the illustrated case . The first column eID of a given two column edge attribute table stores the identifiers of each of the edges that is labeled with the associated attribute and the second column Value of this table stores the value of this attribute for each of these edges. By way of example but not limitation and as exemplified in the edge in the graph snippet labeled affiliated that connects the node labeled John to the node labeled Microsoft is assigned an eID of 3 and the title attribute for this edge is stored in row 3 Senior Researcher of a title table . The edges that are not labeled with a particular attribute will simply not have a representative record in the edge attribute table which is associated with this attribute. An edge attribute that has a plurality of values will be represented with a plurality of rows each having the same eID value in the edge attribute table which is associated with this attribute. Each of the N two column tables can be sorted as a clustered index on the eID column which enables fast execution for merge joins when more than one attribute of the same edge has to be retrieved. Additionally a secondary partitioned B tree index on the Value column can be created for each of the N two column tables which enables fast execution for value based predicates on the attributes by minimizing the performance cost of accessing the relational database to retrieve those nodes that satisfy a predicate condition.

Referring again to the edges in the snippet of the attributed graph that is illustrated in are stored in P three column tables where P is the number of different relationships that exist between the nodes in the graph snippet P is six in the illustrated case . These P three column tables store the topology of the graph snippet e.g. data representing the structure of the nodes and edges in the graph snippet in the following manner. Each of the P three column tables groups the data of all the edges that represent a particular relationship. Each of the edges is described by three pieces of data namely the edge identifier eID the identifier of the source node sID that the edge is connected to and the identifier of the destination node dID that the edge is connected to.

Referring again to it will be appreciated that the memory based representation of the topology of the attributed graph can be implemented in various ways. By way of example but not limitation a native pointer based data structure can be employed to represent the topology of the attributed graph in memory . More particularly the memory based representation of the topology of the attributed graph can encode the data in the P three column tables which in principle represents the data that is used during the processing of the reachability and shortest path components of a graph query which can involve heavy transversal operations on the topology of the graph. As will be described in more detail hereafter such traversal operations can be performed using various methods such as the conventional Dijkstra method for obtaining the shortest path between two nodes and the conventional breadth first search BFS method among others.

Given the foregoing it will be appreciated that the hybrid relational representation of an attributed graph that is provided for by the hybrid engine substantially reduces main memory consumption in the following ways. First the attributes of the nodes and edges in the attributed graph and the data values of these attributes do not have to be loaded into the memory unless needed in a query. Second extra memory indices for these attributes do not have to be built outside the hybrid engine s relational database component since the graph query processing technique embodiments described herein send the evaluation of the graph query predicates to the relational database component for processing and the relational database component chooses to build its efficient indexes to accelerate the query evaluation.

Referring again to it will be appreciated that the query compiler can be implemented in various ways. By way of example but not limitation and as exemplified in the query compiler can include a front end compiler and a back end compiler . Generally speaking and as will be described in more detail hereafter the front end compiler translates the G SPARQL query into an algebraic query plan that includes a plurality of algebraic operators such as relational operators and reachability operators among others and serves as an abstract intermediate language which represents the G SPARQL query. The front end compiler uses a dialect of tuple based algebra to perform this translation. This tuple based algebra includes a set of algebraic operators each of which considers tuples as the main unit of information and each of which manipulates collections of tuples. The set of algebraic operators that is employed by the front end compiler includes a collection of different conventional relational operators e.g. selection projection join and also includes a collection of different non conventional graph operators that are capable of expressing complex graph query operations that cannot be matched with the semantics of the relational operators e.g. cannot be expressed by the relational operators .

Referring again to the back end compiler generally translates the algebraic query plan into a plurality of sub queries that represent the query components of the G SPARQL query. More particularly and as will be described in more detail hereafter the back end compiler analyzes the algebraic operators of the algebraic query plan and translates these algebraic operators into either SQL sub queries or non relational sub queries. The back end compiler generates SQL sub queries for the algebraic operators of the algebraic query plan that are associated with relational operations in the attributed graph e.g. the algebraic operators that are associated with the aforementioned pattern match component of the G SPARQL query . The back end compiler generates non relational sub queries for the algebraic operators of the algebraic query plan that are associated with traversal operations in the attributed graph e.g. the algebraic operators that are associated with the aforementioned reachability and shortest path components of the G SPARQL query . Since the algebraic query plan is based on tuples the back end compiler is able to leverage various conventional and well established relational query planning and optimization methods during the sub query generation.

Generally speaking and referring again to the query execution manager serves to abstract the independent query execution engines . More particularly and as will be described in more detail hereafter the query execution manager uses a knowledge of which of the plurality of independent query execution engines are currently available and the characteristics of each of the available query execution engines e.g. its application programming interface API the type s of query it can efficiently execute the cost to use it and data availability among other things along with one or more engine selection rules to identify a one of the query execution engines that is to be used to process each of the query components e.g. the sub query that represents each of the query components . In one embodiment of the graph query processing technique described herein for each of the query components the query execution manager then sends the sub query that represents the query component to the identified query execution engine for processing and receives corresponding results from this identified engine. Assuming the results received are sufficient to answer the graph query the query execution manager then combines the results received and sends them to the query results presenter . The query results presenter then uses the combined results received to generate a response to the graph query and presents the response to the entity that submitted the graph query. A situation where the results for a one or more of the sub queries are needed to execute another one or more of the sub queries is described in more detail hereafter.

Generally speaking and referring again to the architectural framework can be either implemented on a single computing device or implemented on a plurality of different computing devices. More particularly and by way of example but not limitation in a unified embodiment of the graph query processing technique described herein the entire framework can be implemented on a single computing device. In a distributed embodiment of the graph query processing technique each of the different elements of the framework can be implemented on a different computing device and these different computing devices can be interconnected via a data communication network. As such it will be appreciated that the graph query processing technique embodiments support the querying of a large attributed graph where different parts or components of the attributed graph are stored on different computing devices each of which has its own independent query execution engine that processes queries sub queries which are sent thereto.

A more detailed description of the set of algebraic operators the front end compiler that uses these operators the back end compiler and the query execution manager will be provided hereafter. As will be appreciated from the more detailed description that follows the set of algebraic operators the front end compiler the back end compiler and the query execution manager are advantageous since they are independent of the specific representation of the attributed graph that is employed in each of the query execution engines.

Referring again to the NgetAttVal operator is a unary operator that is used to retrieve the values of a specific attribute for a given set of nodes in an attributed graph. The NgetAttVal operator receives a set of tuples ID attName ID value where the ID column of the input relation identifies the nodes in the attributed graph and also identifies the name attName of the attribute in the graph to be accessed. The schema of the output tuples extends the schema of the input tuples with the value column that represents the values of the accessed attribute. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the NgetAttVal operator when it retrieves the values of a location attribute for an input relation having a three node ID of John Alice Smith . As exemplified in the output relation includes just one record for the Alice node that has the location attribute and this attribute has a value of Sydney . The John and Smith nodes are filtered out because they do not have values for the location attribute.

The EgetAttVal operator is another unary operator that is used to retrieve the values of a specific attribute for a given set of edges in an attributed graph. The EgetAttVal operator receives a set of tuples eID attName eID value where the eID column of the input relation identifies the edges in the attributed graph and also identifies the name attName of the attribute in the graph to be accessed. The schema of the output tuples extends the schema of the input tuples with the value column that represents the values of the accessed attribute. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the EgetAttVal operator when it retrieves the values of a title attribute for an input relation having an eID of two edges. As exemplified in the schema of the output relation extends the schema of the input relation with an attribute that stores the value of the accessed attribute.

It is noted that the conventional relational selection operator can be used for representing value based predicates p over the values of the attributes of nodes or edges in an attributed graph. When used in this manner selects just the tuples of an input relation for which the value based predicate p over a specific column holds. It will thus be appreciated that using in this manner is advantageous in that it represents the right match for reflecting the expressivity of the SPARQL FILTER expression. illustrates an exemplary embodiment in simplified form of an extension of the behavior exemplified in where is used to filter the input edges based on the predicate title Professor for the retrieved values of the title attribute.

Referring again to the getEdgeNodes operator is another unary operator that is used to retrieve a set of adjacent nodes in an attributed graph. The getEdgeNodes operator receives a set of tuples sID eLabel sID eID dID where the sID column of the input relation identifies the nodes in the attributed graph and can optionally also identify a specified relation for accessing the adjacent nodes eLabel . The schema of the output tuples extends the schema of the input tuples with the two columns that represent the identifier eID of the connecting edges of the specified relation and the identifier dID of the adjacent node. In the case where the getEdgeNodes operator receives the eLabel parameter then the getEdgeNodes operator filters out the nodes that do not have adjacent nodes connected with the specified relationship. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the getEdgeNodes operator when it retrieves the adjacent nodes that are connected through a know relationship for an input relation having a two node sID of John Alice . As exemplified in the output relation filters out the Alice node since it is not connected to any other node through the know relationship. illustrates an exemplary embodiment in simplified form of the behavior of the getEdgeNodes operator when it retrieves all the adjacent nodes for an input relation having a two node sID of John Alice .

Referring again to the strucPred operator is a unary operator that is used to filter a given set of nodes in an attributed graph based on a specific structural predicate. The strucPred operator receives a set of tuples sID eLabel dNLabel sID eID where the sID column of the input relation identifies the nodes in the attributed graph and also identifies a structural predicate that is described by the label of the connecting relation eLabel and also identifies a label for the adjacent node dNLabel that is to be accessed through this relation. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the strucPred operator when it applies a structural predicate that filters out the nodes that are not connected to an adjacent node having the label Smith through a know relationship. illustrates an exemplary embodiment in simplified form of the behavior of the strucPred operator when it projects the data of the connecting edges that represent the structural predicate. In this particular embodiment the schema of the output relation is extended with an additional column that stores the eID of the connecting edges.

Referring again to the edgeJoin operator is a binary join operator that receives two relations S and D where the two columns sID and dID identify the nodes of S and D respectively in an attributed graph. For each of the pairs of nodes in the attributed graph the edgeJoin operator checks whether the pair is connected with any edge in the attributed graph filters out the unconnected pairs of nodes and returns the tuples of the connected pairs of nodes as a result. The output of the edgeJoin operator is a single relation where the schema of the output tuples concatenates the columns of S and D. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the edgeJoin operator when it receives two sets of nodes namely John Alice Smith and Paper 2 Paper 1 and returns the pairs of nodes that are connected through any relationship.

As exemplified in the edgeJoin operator can also receive an optional parameter eLabel which imposes a specific relationship condition on the connecting edge between each of the pairs of nodes in an attributed graph. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the edgeJoin operator when it receives two sets of nodes namely John Alice Smith and Microsoft and returns the pairs of nodes that are connected through an affiliated relationship. The edgeJoin operator can also optionally project the data of the connecting edge s where it extends the schema of the output relation by an additional column eID that represents the identifiers of the connecting edges between each of the pairs of nodes in the output tuples according to the specified input parameters. illustrate exemplary embodiments in simplified form of this projection feature of the edgeJoin operator. More particularly illustrates an exemplary embodiment of the behavior of the edgeJoin operator which is similar to the embodiment illustrated in except for the fact that the output relations exemplified in include the eID of the connecting edges between each of the output pairs of nodes. Similarly illustrates an exemplary embodiment of the behavior of the edgeJoin operator which is similar to the embodiment illustrated in except for the fact that the output relations in include the eID of the connecting edges between each of the output pairs of nodes.

Referring again to the pathJoin operator is another binary join operator that receives two relations S and D where the two columns sID and dID identify the nodes of S and D respectively in an attributed graph. For each of the pairs of nodes in the attributed graph the pathJoin operator checks whether the pair is connected by a sequence of edges in the attributed graph where this sequence can be of any length filters out the unconnected pairs of nodes and returns the tuples of the connected pairs of nodes as a result. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the pathJoin operator when it receives two sets of nodes namely John Alice Smith and John Alice Smith and returns the pairs of nodes that are connected through a sequence of relationships of any length. The pathJoin operator can also receive an optional parameter eLabel which imposes a specific relationship condition on the edge of the connecting path between each of the pairs of nodes. illustrates an exemplary embodiment of the pathJoin operator when it receives two sets of nodes namely John Alice Smith and John Alice Smith and returns the pairs of nodes that are connected through a sequence of know relationships of any length.

As exemplified in the pathJoin operator can also optionally project the data of the connecting path s as follows. First the pathJoin operator can extend the schema of the input relation by an additional column pID that represents an assigned identifier for the connecting path between each of the pairs of nodes specified in operator input. It is noted that each of the pairs of nodes can be connected with a plurality of different paths and as such each of the input pairs of nodes can have a plurality of different representing tuples which describe the data of the bound paths. Second the pathJoin operator can return another output relation pRel that describes the data of the resulting paths where each of the resulting paths is described by a sequence of tuples which represent the nodes and edges that make up the path in an orderly manner and each of the tuples in this sequence can be described by a plurality of fields including but not limited to a pID field that represents the path identifier a type field that represents whether the tuple describes a node or an edge an order field that represents the order of the node or edge that participates in the path an ID field that represents the identifier of the node or edge and a label field that represents the Label data of the node or edge. In an exemplary embodiment of the graph query processing technique described herein if the tuple describes a node then the type field has a value of N and if the tuple describes an edge then the type field has a value of E . Additionally the order of each of the paths starts with an edge ordered as one followed by a node ordered as two and then the order of the path alternates until the last edge of the path is reached. The value of a given path variable in the query output is represented by a serialization of the Label data of the tuples that are associated with the path variable where this Label data is serialized in ascending order.

Referring again to the sPathJoin operator works in the same way as the pathJoin operator except for the fact that the sPathJoin operator returns the paths that represent the shortest connection between each of the pairs of nodes in an attributed graph assuming such connections exist.

As exemplified in the filterPath operator is a binary operator that receives two relations R and pRel where the pID column of the relation R represents the path identifiers that have their associated description data represented by the relation pRel. The filterPath operator returns the relation R where the tuples that have paths pID with data pRel which does not fulfill a condition cond are filtered out. The cond parameter represents one of the aforementioned path filtering conditions. Based on the snippet of the attributed graph that is illustrated in and its corresponding relational representation that is illustrated in illustrates an exemplary embodiment in simplified form of the behavior of the filterPath operator when it filters a set of paths based on a Length e.g. number of edges condition that returns the paths having lengths greater than one and filters out the rest of the paths.

As indicated in some of the algebraic operators described heretofore cannot be represented by conventional relational operators. Based on the aforementioned hybrid relational representation of an attributed graph that can be employed by the graph query processing technique embodiments described herein illustrates exemplary embodiments of mappings for the algebraic operators that can be translated into a pattern of conventional relational operators. By way of example but not limitation and as exemplified in the NgetAttVal operator can be mapped to a join operation between the nodeID column of the input relation R and the ID column of the relation that represents the specified node attribute attName . The NgetAttVal operator extends the schema of the input tuples R. with the value column for the relation of the specified attribute attName . Since the semantics of the getEdgeNodes and edgeJoin operators can be not restricted by a specified relationship eLabel applying these operators using the standard relational operators requires joining the input relation s with each of the relation tables separately and then performing a union of all the results. Stated more simply a materialized view allEdges can be created that represents a union of all the relation tables.

This section provides a more detailed description of the aforementioned exemplary front end compiler.

Referring again to once the triple patterns of the G SPARQL query have been mapped onto the set of algebraic operators block a set of query re writing rules is applied in order to reduce the execution time of the G SPARQL query evaluation block where these re writing rules are specific to the G SPARQL constructs described herein. Additionally the triple patterns of the G SPARQL query are reordered according to their restrictiveness where this reordering is performed using the following set of triple pattern precedence rules block . Given that t1 t2 Triple q denotes two triple patterns of a given G SPARQL query q triple pattern t1 is defined as being less restrictive than triple pattern t2 e.g. t1 t2 whenever t1 has more path variables or than t2. Triple pattern t1 is defined as being more restrictive than triple pattern t2 e.g. t1

As exemplified in in an exemplary embodiment of the graph query processing technique described herein the algebraic query plan that is generated by the front end compiler can be formed as a directed acyclic graph. As such the back end compiler can translate the algebraic query plan into sub queries by traversing the algebraic query plan in a bottom up manner e.g. starting from the leaves and then climbing the different paths back to the root using a conventional set of defined pattern based translation rules. This climbing of a given path will stop if it reaches an algebraic operator that does not have a conventional relational representation for its semantics or if it reaches the root . By way of example but not limitation all of the algebraic operators shown in can be translated into SQL sub queries except the pathJoin operator. More particularly and as indicated by the dashed boxes in two SQL sub queries namely SQLand SQL are generated by the back end compiler where the following results of these SQL sub queries can then be sent to either a graph engine or the memory based component of a hybrid engine using the pathJoin operator 

This section provides a more detailed description of several of the aforementioned features of the query execution manager.

As described heretofore the query execution manager uses a knowledge of which of a plurality of independent query execution engines are currently available and the characteristics of each of the available query execution engines along with one or more engine selection rules to identify a one of the query execution engines that is to be used to process each of the query components e.g. the sub query that represents each of the query components . In one embodiment of the graph query processing technique described herein performance based engine selection rules can be used to perform this identification where these rules specify that a pattern match component of the G SPARQL query e.g. the SQL sub query that represents this component is to be executed by either a relational database engine or the relational database component of a hybrid engine. The performance based engine selection rules also specify that a reachability component of the G SPARQL query e.g. the non relational sub query that represents this component is to be executed by either a graph engine or the memory based component of a hybrid engine. The performance based engine selection rules also specify that a shortest path component of the G SPARQL query e.g. the non relational sub query that represents this component is to be executed by either a graph engine or the memory based component of a hybrid engine.

In another embodiment of the graph query processing technique described herein at least a monetary cost based engine selection rule can be used to identify a one of the plurality of independent query execution engines that is to be used to process each of the query components where this rule specifies that each of the query components is to be executed by a one of the plurality of independent query execution engines that is the least expensive to use. In yet another embodiment of the graph query processing technique a combination of the performance based engine selection rules and the monetary cost based engine selection rule can be used to identify a one of the plurality of independent query execution engines that is to be used to process each of the query components.

While the graph query processing technique has been described by specific reference to embodiments thereof it is understood that variations and modifications thereof can be made without departing from the true spirit and scope of the graph query processing technique. It is also noted that any or all of the aforementioned embodiments can be used in any combination desired to form additional hybrid embodiments or distributed embodiments. Although the graph query processing technique embodiments have been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described heretofore. Rather the specific features and acts described heretofore are disclosed as example forms of implementing the claims.

The graph query processing technique embodiments described herein are operational within numerous types of general purpose or special purpose computing system environments or configurations. illustrates a simplified example of a general purpose computer system on which various embodiments and elements of the graph query processing technique as described herein may be implemented. It is noted that any boxes that are represented by broken or dashed lines in represent alternate embodiments of the simplified computing device and that any or all of these alternate embodiments as described below may be used in combination with other alternate embodiments that are described throughout this document.

For example shows a general system diagram showing a simplified computing device . Such computing devices can be typically be found in devices having at least some minimum computational capability including but not limited to personal computers PCs server computers handheld computing devices laptop or mobile computers communications devices such as cell phones and personal digital assistants PDAs multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers audio or video media players and computing resources in a cloud computing environment.

To allow a device to implement the graph query processing technique embodiments described herein the device should have a sufficient computational capability and system memory to enable basic computational operations. In particular as illustrated by the computational capability is generally illustrated by one or more processing unit s and may also include one or more graphics processing units GPUs either or both in communication with system memory . Note that that the processing unit s of the simplified computing device may be specialized microprocessors such as a digital signal processor DSP a very long instruction word VLIW processor a field programmable gate array FPGA or other micro controller or can be conventional central processing units CPUs having one or more processing cores including but not limited to specialized GPU based cores in a multi core CPU.

In addition the simplified computing device of may also include other components such as for example a communications interface . The simplified computing device of may also include one or more conventional computer input devices e.g. pointing devices keyboards audio e.g. voice input devices video input devices haptic input devices gesture recognition devices devices for receiving wired or wireless data transmissions and the like . The simplified computing device of may also include other optional components such as for example one or more conventional computer output devices e.g. display device s audio output devices video output devices devices for transmitting wired or wireless data transmissions and the like . Note that typical communications interfaces input devices output devices and storage devices for general purpose computers are well known to those skilled in the art and will not be described in detail herein.

The simplified computing device of may also include a variety of computer readable media. Computer readable media can be any available media that can be accessed by the computer via storage devices and can include both volatile and nonvolatile media that is either removable and or non removable for storage of information such as computer readable or computer executable instructions data structures program modules or other data. By way of example but not limitation computer readable media may include computer storage media and communication media. Computer storage media refers to tangible computer readable or machine readable media or storage devices such as digital versatile disks DVDs compact discs CDs floppy disks tape drives hard disk drives optical disk drives solid state memory devices random access memory RAM read only memory ROM electrically erasable programmable read only memory EEPROM flash memory or other memory technology magnetic cassettes magnetic tapes magnetic disk storage or other magnetic storage devices or any other device which can be used to store the desired information and which can be accessed by one or more computing devices.

Retention of information such as computer readable or computer executable instructions data structures program modules and the like can also be accomplished by using any of a variety of the aforementioned communication media to encode one or more modulated data signals or carrier waves or other transport mechanisms or communications protocols and can include any wired or wireless information delivery mechanism. Note that the terms modulated data signal or carrier wave generally refer to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. For example communication media can include wired media such as a wired network or direct wired connection carrying one or more modulated data signals and wireless media such as acoustic radio frequency RF infrared laser and other wireless media for transmitting and or receiving one or more modulated data signals or carrier waves. Combinations of any of the above should also be included within the scope of communication media.

Furthermore software programs and or computer program products embodying some or all of the various graph query processing technique embodiments described herein or portions thereof may be stored received transmitted or read from any desired combination of computer readable or machine readable media or storage devices and communication media in the form of computer executable instructions or other data structures.

Finally the graph query processing technique embodiments described herein may be further described in the general context of computer executable instructions such as program modules being executed by a computing device. Generally program modules include routines programs objects components data structures and the like that perform particular tasks or implement particular abstract data types. The graph query processing technique embodiments may also be practiced in distributed computing environments where tasks are performed by one or more remote processing devices or within a cloud of one or more devices that are linked through one or more communications networks. In a distributed computing environment program modules may be located in both local and remote computer storage media including media storage devices. Additionally the aforementioned instructions may be implemented in part or in whole as hardware logic circuits which may or may not include a processor.

