---

title: Efficient data transmission between computing devices
abstract: The subject disclosure is directed towards technology by which data transmission sizes are reduced when uploading files over a network. By processing hash values corresponding to a plurality of data blocks of a file to potentially be uploaded to a server, the server identifies any already known data block or blocks of the file. The server performs a server-local copy operation that writes the known data block into a server-local copy of the file. If applicable, the server returns hash values corresponding to unknown data blocks to a client, by which the client responds by uploading copies of the unknown data blocks. Accordingly, the client and the server maintain the server-local copy of the file by transferring only unknown data blocks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09398053&OS=09398053&RS=09398053
owner: Microsoft Technology Licensing, LLC
number: 09398053
owner_city: Redmond
owner_country: US
publication_date: 20121202
---
A number of organizations employ a local area network to facilitate data communications between various devices e.g. computing devices peripheral devices storage devices and or the like . Within a typical local area network a server computer often simply referred to as a server performs various data processing storage tasks often at the direction of a client computer often simply referred to as a client . To illustrate one example the client initiates a file upload process by transmitting a whole file to the server for storage in network accessible memory.

Uploading files having substantially large data sizes to a server in a traditional client server network environment is costly in terms of total time consumed dollars spent and or computing resources required including network bandwidth and or storage capacity. Uploading substantially similar or the same files whether from various clients or repeatedly from a same client also incurs significant costs and or delays. In particular poor or inadequate network connectivity exacerbates the cost associated with completing a file upload process. A file upload process also may be hindered or restricted by a current network environment. Servers running on certain networks such as a cloud resource are designed to timeout file upload requests after a pre determined threshold time period elapses. Other networks prohibit file uploads that exceed a pre determined payload size.

Previous solutions prescribe performing file uploads in piecemeal by splitting a file into chunks and uploading each chunk separately. Such solutions however are impractical when uploading files of considerable sizes. To demonstrate one such impracticality if a single chunk upload fails the entire file upload process is restarted. A more efficient solution for uploading files is desired.

This Summary is provided to introduce a selection of representative concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used in any way that would limit the scope of the claimed subject matter.

Briefly various aspects of the subject matter described herein are directed towards efficient data transmissions over a network when uploading files. In one aspect while preparing a file for uploading a computing device referred to as a client removes certain data blocks including any data block that is without uploading any portion thereof reconstructible at the server. Some of the certain data blocks have been initialized to particular default data and do not need to be transmitted because the server recreates these data blocks using one or more server default storage values. In another aspect the client excludes extraneous copies of redundant data blocks. Eliminating these blocks from the file upload process reduces a total length of time to complete the transfer of remaining data blocks.

In one aspect a server coupled to the client processes hash value data corresponding to each data block of the file and identifies one or more locally stored data blocks. In another aspect the server returns hash value data for any data block that is unknown to the server and or not found in the server s data store which allows the client to reduce file upload related traffic by uploading unknown data blocks. In yet another aspect the server employs a library comprising reconstructible and or reusable data blocks to determine which data blocks of the file are known and which data blocks are unknown. The storage logic uses the library to identify reusable and re constructible data blocks within the same file or between similar instances of a same type of file. Accordingly the file upload size reduction approaches described herein are applicable to any file type.

Other advantages may become apparent from the following detailed description when taken in conjunction with the drawings.

Various aspects of the technology described herein are generally directed towards more efficient file uploads to a server through file upload size reduction. The technology described herein exemplifies a number of approaches for achieving such a reduction. Various software hardware components initiate and execute file upload processes from one or more computing device to one or more stores. In one example implementation using a storage logic coupled to a server a computing device referred to as a client determines whether a particular file includes one or more data blocks that are already stored on the server and if possible which data blocks are not found on the server and therefore considered to be unknown data blocks.

One example implementation utilizes a server stored common data block library comprising reusable and re constructible data blocks. The volume of data being transferred from the client to the server during each upload process may be significantly reduced by constructing at least part of the file on the server from the data blocks stored in the block library. Accordingly only those data blocks not found in the library are actually transferred over the network. The client only uploads the unknown blocks because the any known data block can be locally copied from the library instead of over the network.

It should be understood that any of the examples herein are non limiting. For instance one example describes uploading virtual machine files such as Virtual Hard Disk VHD files to Microsoft Windows Azure Based Storage which represents one example embodiment where the file upload optimization approaches described herein improve a total time to upload a given VHD file over traditional client server network environments. With a common data block library residing in Microsoft Windows Azure Based Storage and populated with data blocks representing a virtual hard disk containing a clean Microsoft Windows Operating System installation uploading a portion of a VHD is more efficient as compared to uploading the entire VHD file. However this is only one example and other file types environments and the like may similarly benefit from the technology described herein. As such the present invention is not limited to any particular embodiments aspects concepts structures functionalities or examples described herein. Rather any of the embodiments aspects concepts structures functionalities or examples described herein are non limiting and the present invention may be used various ways that provide benefits and advantages in computing and data communication in general.

The client may refer to a computing device comprising various software and or hardware components. Although some embodiments of the client include a desktop computer a laptop computer a mobile device and or the like it is appreciated that additional embodiments are envisioned by the present disclosure.

According to one example implementation that achieves file upload size reduction because certain file structure patterns are recognizable the client may filter data blocks having such patterns from the file data . For instance when storage space associated with the server is allocated data within such storage space is initialized to a particular default value e.g. referred to as a server default storage value . The client may reduce a data transmission size when uploading the file data by removing any data block comprising the particular value and only transmitting those data blocks not equal to that particular value. To illustrate an example if a data block is initialized to a default value of zero 0 upon allocation the client does not upload that data block to the server .

The server may be configured to provide the client with various computing resources services such as storage logic configured to handle file upload requests from the client . In order to complete these file upload requests the storage logic may use a library associated with common data blocks located within one or more stores including locally attached data stores. As an example for each common data block the library may include a corresponding hash value and a copy of reference to each redundant memory location within a store . In one example implementation the storage logic regulates a size of the library by culling out seldom accessed data blocks. The storage logic may maintain the library at a pre determined maximum size.

According to one example implementation the client initiates an upload process by partitioning the file data into a plurality of data blocks and computing hash value data and offset information for each data block. The client may remove redundant data blocks and record each file offset in the offset information such that a data block of the plurality of data blocks may map to more than one file offset. Before transmitting any of the plurality of data blocks to the server the client issues at least one file upload request comprising the hash value data that corresponds to at least a portion of the plurality of data blocks. In response to the at least one file upload request the storage logic searches the library for matching hash values indicating at least a portion of the file data to be known and or retrievable via a local network copy operation. For each hash value in the library that substantially exactly matches a hash value in the hash value data the storage logic identifies a corresponding common data block and labels that data block to be a known data block of the plurality of data blocks.

Proceeding with the upload process for the file data the storage logic retrieves a copy of each known data block from the store and or one or more other stores via the network . Using the offset information provided by the client the storage logic constructs a server local copy comprising at least a portion of the file data . The storage logic creates a file to store the server local copy and represent a reconstruction of the file data at the store . According to one example implementation the storage logic writes each known data block to corresponding file offsets within the server local copy. Alternatively the storage logic may include a reference within the server local file copy to a memory location in the library the store and or another store corresponding to a known data block instead of creating a copy.

The storage logic may initially seed the library with a set of commonly used data blocks. Optionally the storage logic uses other data stores besides the store to identify commonly used data blocks. The storage logic may search a store for new data blocks to record in the library and add to the store . The store may be located on a same local area network as the client and the server or alternatively the store may be located on a cloud based server in a private or public cloud environment.

A client which may be any computing device desires to upload various files for storage on a cloud resource . depicts example implementations of the example architecture in which the client initiates a request to upload a single file for example a large virtual machine file such as a virtual hard disk VHD . Optionally the client may communicate a plurality of file upload requests in parallel such that each upload request corresponds to a specific portion of the virtual hard disk . Each request queues a set of hash values for a function call or the like to the cloud resource . A storage logic running within the cloud resource processes the request and after determining which data blocks are known unknown responds to the client with a file upload complete status or information identifying each unknown data block. Alternatively the response to the client may identify each known data block. Using known data blocks from a library comprising common data blocks the storage logic creates a copy of at least a portion of the virtual hard disk . The client if necessary responds with data transmissions of unknown data blocks in order to complete the file upload process.

In one example implementation the cloud resource generally exposes an application programming interface API such as a REST based API enabling functionality over a block library comprising common data blocks operation with a cloud based file system and or access to other higher level language code packages. The cloud resource may be configured to provide file uploading downloading services to a plurality of clients including the client by utilizing one or more file types to store data from these clients. Because some cloud computing environments involve pricing plans that charge on the basis of total data uploaded the client may benefit from the savings attributed to smaller file upload sizes. Various example embodiments of the cloud resource employ a file type referred to as a BLOB Binary Large Object and a container file type for storing one or more BLOBs. Microsoft Windows Azure Based Storage represents one example cloud resource in which block based BLOBs typically store streaming data e.g. images videos documents and so forth .

Residing within the cloud resource the library may include a BLOB based file system through which data block reads writes are completed. According to one or more example implementations the library comprises a plurality of data blocks that when arranged at appropriate offsets form a plurality of BLOBs. The library may store the plurality of data blocks in a contiguous address space where each data block s hash value maps to a particular block identifier or alternatively in random locations such that each data block s hash value forms at least a portion of that data block s address.

The library may be referred to herein as a data block library or simply a block library. At least a portion of the library includes data blocks that are common to the cloud resource e.g. commonly used selected data blocks . It is appreciated that the library also may include data blocks from other libraries and or stores. For example the storage logic may scan local and or network accessible data stores and identify data blocks to add to the library . According to another example implementation where data blocks are added to the library the storage logic may access a different library comprising common data blocks that is located on another server configuration such as another cloud resource e.g. a public cloud or a private cloud or an on premises server with respect to the client . Furthermore when the client uploads new data blocks that are not found in the library the new data blocks also are added to the library which benefits other users involved in uploads of similar files to the cloud resource .

To upload the virtual hard disk or a portion of the virtual hard disk the client may call a function e.g. a PUT function in BLOB based storage to initiate an upload process in accordance with the API. The storage logic in turn may add the virtual hard disk to cloud based file system such as a BLOB based system by constructing a BLOB to maintain a copy e.g. a local copy of at least one portion the virtual hard disk and providing the client with access to the BLOB . Hence the virtual hard disk is reconstructed on the cloud resource in the form of the copy which may be herein referred to as the virtual hard disk copy while avoiding uploading of unnecessary data blocks.

In compliance with the example architecture the client partitions the virtual hard disk into a plurality of data blocks of fixed size e.g. five hundred and twelve 512 KB in one example implementation. According to other example implementations the example architecture may be adaptable to different data block sizes in order to maximize data block reuse in a block library and or minimize a number of data block transmissions during file uploads. For each data block in to the virtual hard disk the client may assign an identifier e.g. a Base64 encoded string value referred to as a block identifier or BlockId .

The client communicates the block identifiers to the storage logic in order to determine which data blocks are known in the library and which data blocks are unknown and or not found in the library . The storage logic performs local copying of the known data blocks from the library to corresponding file offsets in the virtual hard disk copy . Once all unknown new data blocks are uploaded successfully the client calls another function e.g. a PUT Block List function instructing the storage logic to commit and or write the uploaded data blocks to corresponding file offsets in the virtual hard disk copy .

The following illustrates file upload size reduction where at least one example implementation of the client scans the virtual hard disk in order to identify data blocks comprised substantially or entirely of default data e.g. server default storage values . If the cloud resource is configured to initialize storage space to a value of zero 0 the client identifies any data block within the virtual hard disk comprising only zeros and precludes that data block from being uploaded to the cloud resource .

For each remaining data block the client computes an identifying hash value and a set of file offsets corresponding to one or more addresses locations within the file. Because a data block may be used at multiple locations within the virtual hard disk the set of file offsets includes a corresponding file offset for each redundant location. In one example implementation the client produces the set of file offsets by aggregating data blocks having a same hash value which enables the client to transmit only one copy of a redundant data block instead of multiple copies. When applied to uploading the virtual hard disk such an aggregation reduces a data transmission size since there is no need for the client to upload numerous copies of the same redundant data block.

According to one example implementation as the client aggregates the hash values and builds offset information the client arranges the hash values into N groups of M hash values where N and M are configurable values used to throttle the number of calls made to the server during the upload process. Once there is a group of M hash values that group is queued for a function call directed towards the storage logic .

In one example implementation the storage logic exposes at least two functions to the client including a first function configured to identify one or more known data blocks within the library and a second function configured to upload new unknown data blocks to the cloud resource . depicts the first function and the second function as IdentifyUnknownBlocks and UploadUnknownBlocks respectively.

Executing the function call IdentifyUnknownBlocks may entail the storage logic to generate the virtual hard disk copy and or if applicable to copy known data blocks to the BLOB as depicted by Operation Two in . The storage logic may compare the list of hash values with the library to determine whether any hash value resolves to a common data block. If for instance the library includes at least one matching hash value the storage logic performs a local copy operation for at least one common data block that corresponds to the at least one matching hash value such that the at least one common data block is stored at corresponding file offsets in the virtual hard disk copy .

At Operation Three the storage logic is instructed to return one or more hash values to the client that are not found in the library as depicted in . For every hash value returned the client reads a data block from the virtual hard disk starting at one of the corresponding file offsets. Optionally the client applies a compression algorithm to reduce a number of bytes uploaded. Before adding a compressed data block to the library the storage logic performs a complementary decompression operation by which the compressed data block reverts back to an uncompressed data block.

After generating a copy of each and every unknown block of the virtual hard disk the client performs Operation Four as depicted in and proceeds to call UploadUnknownBlocks with the unknown data block copies as parameters. At Operation Five the storage logic may add the unknown data blocks into the library along with identifying hash values including the returned hash values to the function call IdentifyUnknownBlocks at Operation Three . As an alternative the storage logic uses other authentication data e.g. a corresponding hash string as a block identifier for each unknown data block. illustrates Operation Six with the storage logic proceeding to store the unknown data blocks at corresponding file offsets in the virtual hard disk copy .

In yet another example implementation involving uploading files to the cloud resource the client updates the virtual hard disk copy as new data and or modified data is written to the virtual hard disk . As described herein the client uploads at least a portion of the virtual hard disk corresponding to a particular point in time and in turn the storage logic uses the uploaded portion s to generate the virtual hard disk copy of the virtual hard disk .

As the virtual hard disk changes e.g. by installing a software component or creating a new document the client may refresh the virtual hard disk copy with differential data for example by updating certain data blocks within modified data removing deleted data blocks and or adding new data blocks. Once completed the virtual hard disk copy becomes transformed into a virtual hard disk associated with a more current point in time. By using the storage logic to e.g. periodically update the virtual hard disk copy the client realizes costs savings with each upload.

The client may instruct the storage logic to identify each and every known data block within the differential data. The storage logic using hash values associated with the modified and or new data blocks searches the library for data blocks having matching hash values. If such a data block is found the storage logic performs a local copy operation that writes the found known data block to the virtual hard disk copy . With respect to any modified and or new data block not found in the library and thus deemed unknown the client uploads each such data block to the cloud resource as described herein. The storage logic in turn stores each unknown data block at corresponding file offsets in the virtual hard disk copy .

Thus instead of replacing unchanged data blocks of the virtual hard disk copy the client uploads only the modified and or new data blocks that are also not found in the library . The client may alternatively update the virtual hard disk copy by transmitting the modified and or new data blocks regardless of whether a data block is known or unknown. This alternative implementation may be applied in order to avoid latencies resulting from querying the library if such latencies negate the savings in reducing data transmission sizes.

In one example implementation the virtual hard disk refers to a virtual machine template. In another example implementation the virtual hard disk includes a stateful virtual machine where stateful generally refers to a virtual machine that has been customized with installation user specific data and hardware software components. Upon generating the virtual hard disk copy the storage logic may complete a virtual machine migration that moves the stateful virtual machine to the cloud resource .

Example embodiments of the example architecture include computer networks that provide data recovery services such as backup restore functionality snapshot creation and or the like. Components of the example architecture enhance performance of these data recovery services. To illustrate one example of such enhancement the example architecture enables efficient snapshot creation modification by providing access to known common data blocks such that only unknown data blocks if any need to be uploaded to complete the snapshot creation modification. With respect to the virtual hard disk the example architecture may improve an initial snapshot creation phase by decreasing a total time to create a virtual hard disk snapshot prior to a data recovery service assuming control. Accordingly the example architecture provides the data recovery service such as Microsoft Hyper V Replica with an initial virtual hard disk snapshot while avoiding delays caused by uploading known data blocks.

In addition to the network topologies discussed herein e.g. cloud computing client server over a LAN and or the like file upload optimization may be realized in hybrid cloud computing environments where substantially large file transfers between clients and on premises servers or between on premises servers and cloud based servers are executed. In one example hybrid cloud computing environment an on premises server may seed a cloud based block library with local block libraries being used for on premises file upload operations.

Computer networks employing hardware assisted or software assisted copying and or de duplication systems such as Storage Area Networks and Network Attached Storage can implement the example architecture and achieve a reduction in the data traffic volume necessary to complete file upload move and copy operations. Reducing an overall storage capacity of the cloud resource may also be achieved by implementing the example architecture. Accordingly the cloud resource can handle a same number of users with less storage space.

Step commences the example steps and proceeds to step where hash values are processed that correspond to data blocks of the file to be uploaded. Based upon these hash values and other indicia step determines whether any data block of the file can also be found locally with respect to the at least one computing device. The client communicates at least one file upload request comprising the hash values to which the storage logic compares a plurality of known common data blocks. If the storage logic identifies one or more of these data blocks that resolve to one or more substantially equivalent hash values from the client each identified data block is determined to be a known data block of the file and step proceeds to step . If the storage logic fails to identify any such data block no known data block exists and step proceeds to step .

Step refers to copying at least one known data block from one or more stores to corresponding file offsets in a local copy of the file. The storage logic may execute a local copy operation to retrieve the at least one known data block from the one or more stores including local data stores cloud based stores and or network attached stores. Step which may be omitted in some example implementations is directed towards referencing other known data blocks at corresponding file offsets in the local copy of the file. Some known data blocks are likely not to be used but can be retrieved if necessary from each respective data store. Accordingly including a reference to a memory location corresponding to a known data block in a local or remote store may further optimize file uploads.

Step returns a hash value corresponding to each unknown data block. The client processes each hash value and transmit one or more unknown data blocks to the server. Step receives the one or more unknown data block s from the client and stores each unknown data block at corresponding file offsets in the local file copy. Some example implementations omit step and step if all of the data blocks of the file are known. Step terminates the example steps depicted in .

Step represents a determination as to which ones of the plurality of data blocks include default data. Examples of default data as described herein include server default storage values e.g. zero 0 . If any data block substantially comprises the default data e.g. only zero 0 values step proceeds to step where the client excludes at least one data block from the plurality of data blocks such that the client is precluded from transmitting the at least one data block when completing the virtual hard disk upload. If no data block comprises the default data step skips step and continues to step .

Step is directed towards generating offset information and hash value data for remaining data blocks of the virtual hard disk. Step queries a common data block library residing on a cloud resource using the hash value data to determine which one s of the remaining data blocks need s to be uploaded to the cloud resource. In one example implementation the client calls a function requesting that the virtual hard disk file be uploaded with the hash value data as a parameter. A server running on the cloud resource may respond to the client by returning one or more hash values corresponding to one or more data blocks that the server did not find in the common data block library. In one or more example implementations the client prepares to upload the one or more data blocks to the cloud resource.

In other example implementations some of the one or more data blocks may not be found in the common data block library but may be found in other block libraries rendering such data blocks to be no longer unknown. Accordingly step queries another library for additional known data blocks using the hash value data. The other library may include a block library in a local area network or in another cloud resource such as a private cloud resource or a public cloud resource. If the other library does not contribute towards file upload optimization step can be omitted.

Step refers to communicating each unknown data block of the virtual hard disk to the cloud resource. The client may arrange the unknown data blocks into groups comprising one or more data blocks and upload each group in parallel to the cloud resource. Using the approaches described herein if one group upload fails the client may retry uploading just that group. Instead of uploading the file in piecemeal fashion for instance the client uploads only unknown data blocks reducing a total time to complete the file upload process. Step instructs the cloud resource to add the virtual machine file to a cloud based file system. In one example implementation the client instructs the storage logic to create the virtual machine file in a BLOB based file system by allocating storage space in a BLOB storing the at least one unknown block in the virtual machine file and performing a local copy of at least one known data block into the virtual machine file from the block library or alternatively from the other library. The client as an alternative may include at corresponding file offsets in the virtual machine file stored in the BLOB a reference to each known data block. Step terminates the example steps depicted in .

One of ordinary skill in the art can appreciate that the various embodiments and methods described herein can be implemented in connection with any computer or other client or server device which can be deployed as part of a computer network or in a distributed computing environment and can be connected to any kind of data store or stores. In this regard the various embodiments described herein can be implemented in any computer system or environment having any number of memory or storage units and any number of applications and processes occurring across any number of storage units. This includes but is not limited to an environment with server computers and client computers deployed in a network environment or a distributed computing environment having remote or local storage.

Distributed computing provides sharing of computer resources and services by communicative exchange among computing devices and systems. These resources and services include the exchange of information cache storage and disk storage for objects such as files. These resources and services also include the sharing of processing power across multiple processing units for load balancing expansion of resources specialization of processing and the like. Distributed computing takes advantage of network connectivity allowing clients to leverage their collective power to benefit the entire enterprise. In this regard a variety of devices may have applications objects or resources that may participate in the resource management mechanisms as described for various embodiments of the subject disclosure.

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in communications network may comprise other computing objects and computing devices that provide services to the system of and or may represent multiple interconnected networks which are not shown. Each computing object etc. or computing object or device etc. can also contain an application such as applications that might make use of an API or other object software firmware and or hardware suitable for communication with or implementation of the application provided in accordance with various embodiments of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for example communications made incident to the systems as described in various embodiments.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client is a member of a class or group that uses the services of another class or group to which it is not related. A client can be a process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. The client process utilizes the requested service without having to know any working details about the other program or the service itself.

In a client server architecture particularly a networked system a client is usually a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. acting as servers provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances.

A server is typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process may be active in a first computer system and the server process may be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server.

In a network environment in which the communications network or bus is the Internet for example the computing objects etc. can be Web servers with which other computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Computing objects etc. acting as servers may also serve as clients e.g. computing objects or devices etc. as may be characteristic of a distributed computing environment.

As mentioned advantageously the techniques described herein can be applied to any device. It can be understood therefore that handheld portable and other computing devices and computing objects of all kinds are contemplated for use in connection with the various embodiments. Accordingly the below general purpose remote computer described below in is but one example of a computing device.

Embodiments can partly be implemented via an operating system for use by a developer of services for a device or object and or included within application software that operates to perform one or more functional aspects of the various embodiments described herein. Software may be described in the general context of computer executable instructions such as program modules being executed by one or more computers such as client workstations servers or other devices. Those skilled in the art will appreciate that computer systems have a variety of configurations and protocols that can be used to communicate data and thus no particular configuration or protocol is considered limiting.

With reference to an example remote device for implementing one or more embodiments includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit .

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The system memory may include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation system memory may also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices . A monitor or other type of display device is also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which may be connected through output interface .

The computer may operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer may be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and may include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but may also include other networks buses. Such networking environments are commonplace in homes offices enterprise wide computer networks intranets and the Internet.

As mentioned above while example embodiments have been described in connection with various computing devices and network architectures the underlying concepts may be applied to any network system and any computing device or system in which it is desirable to improve efficiency of resource usage.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques provided herein. Thus embodiments herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more embodiments as described herein. Thus various embodiments described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

The word exemplary is used herein to mean serving as an example instance or illustration. For the avoidance of doubt the subject matter disclosed herein is not limited by such examples. In addition any aspect or design described herein as exemplary is not necessarily to be construed as preferred or advantageous over other aspects or designs nor is it meant to preclude equivalent exemplary structures and techniques known to those of ordinary skill in the art. Furthermore to the extent that the terms includes has contains and other similar words are used for the avoidance of doubt such terms are intended to be inclusive in a manner similar to the term comprising as an open transition word without precluding any additional or other elements when employed in a claim.

As mentioned the various techniques described herein may be implemented in connection with hardware or software or where appropriate with a combination of both. As used herein the terms component module system and the like are likewise intended to refer to a computer related entity either hardware a combination of hardware and software software or software in execution. For example a component may be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on computer and the computer can be a component. One or more components may reside within a process and or thread of execution and a component may be localized on one computer and or distributed between two or more computers.

The aforementioned systems have been described with respect to interaction between several components. It can be appreciated that such systems and components can include those components or specified sub components some of the specified components or sub components and or additional components and according to various permutations and combinations of the foregoing. Sub components can also be implemented as components communicatively coupled to other components rather than included within parent components hierarchical . Additionally it can be noted that one or more components may be combined into a single component providing aggregate functionality or divided into several separate sub components and that any one or more middle layers such as a management layer may be provided to communicatively couple to such sub components in order to provide integrated functionality. Any components described herein may also interact with one or more other components not specifically described herein but generally known by those of skill in the art.

In view of the example systems described herein methodologies that may be implemented in accordance with the described subject matter can also be appreciated with reference to the flowcharts of the various figures. While for purposes of simplicity of explanation the methodologies are shown and described as a series of blocks it is to be understood and appreciated that the various embodiments are not limited by the order of the blocks as some blocks may occur in different orders and or concurrently with other blocks from what is depicted and described herein. Where non sequential or branched flow is illustrated via flowchart it can be appreciated that various other branches flow paths and orders of the blocks may be implemented which achieve the same or a similar result. Moreover some illustrated blocks are optional in implementing the methodologies described hereinafter.

While the invention is susceptible to various modifications and alternative constructions certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood however that there is no intention to limit the invention to the specific forms disclosed but on the contrary the intention is to cover all modifications alternative constructions and equivalents falling within the spirit and scope of the invention.

In addition to the various embodiments described herein it is to be understood that other similar embodiments can be used or modifications and additions can be made to the described embodiment s for performing the same or equivalent function of the corresponding embodiment s without deviating therefrom. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be effected across a plurality of devices. Accordingly the invention is not to be limited to any single embodiment but rather is to be construed in breadth spirit and scope in accordance with the appended claims.

