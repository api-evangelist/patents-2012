---

title: Continuous evaluation of program code and saving state information associated with program code
abstract: A device receives a program code being created or edited, executes a first portion of the program code to generate a first result, and executes a second portion of the program code to generate a second result. The device stores the first result and the second result, and compares the first result and the second result to determine a difference between the first result and the second result. The device utilizes the difference to identify an error in the program code, and provides information, associated with the difference and the error, for display.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09645915&OS=09645915&RS=09645915
owner: The Mathworks, Inc.
number: 09645915
owner_city: Natick
owner_country: US
publication_date: 20120928
---
The accompanying drawings which are incorporated in and constitute a part of this specification illustrate one or more implementations and together with the description explain these implementations. In the drawings 

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements.

Programmers can use a programming language to build functions modules applications etc. by writing text files containing code in the programming language. The programmer may utilize an editor of a computing environment to create the program code. Once the program code is written the programmer may test the program code. Some programmers use a debugger to understand and test the behavior of the program code and to spot errors in the program code. If an error is detected the programmer usually returns to the editor to modify the program code. After modifying the program code the programmer may utilize the debugger again to see if the error is corrected. This process may continue until the program code is determined to be free of errors.

The programmer may learn about an execution or runtime state of the program code by adding statements to the program code and executing the statements e.g. print statements by copying portions of the program code into a command window and executing the code portions by utilizing a debugger etc. Debugging may include the programmer adding breakpoints at different parts of the program code and utilizing the breakpoints to investigate the different parts of the program code. The programmer needs to understand what debugging is and how debugging works before the programmer can use the information obtained from debugging the program code. This may present a challenge for novice programmers.

Systems and or methods described herein may enable program code to be continuously evaluated while the program code is being created and or edited. The systems and or methods may enable state information associated with one or more portions of the program code to be saved and utilized to determine differences between the portion s of the program code. The systems and or methods may continuously execute the program code in the background and may provide a live view or workspace of results of the code execution at each line of the program code. The results may include information associated with a line of the program code such as variable values inputs outputs errors etc.

As further shown in the TCE via the continuous evaluation component and the saving state component may provide a user interface that enables a user e.g. a programmer to create and or edit the program code while simultaneously viewing results of the continuous evaluation of the program code. For example the user interface may include an editor section e.g. a window that enables the user to create view edit etc. the program code. The user interface may include a workspace section e.g. a window that displays information associated with variables e.g. inputs outputs intermediate variables of the program code provided in the editor section. The information displayed in the workspace section may change when the user selects different portions of the program code. The user interface may include a variable editor section e.g. a window that displays information associated with the variables of the program code. For example the variable editor section may display a graph generated by the program code.

The user interface may include a mechanism that when selected permits the user to playback lines of the program code. In one example the playback mechanism may enable the user to step though the lines of the program code and see what effect each line has on the variables of the program code. As further shown in the variable editor section may display a plot of a temperature variable of the program code. The plot may include an error e.g. a break in the plotted line . The workspace section may display an error e.g. a not a number NaN indication associated with the temperature variable which may cause the error in the plot. The user may use a cursor or some other selection mechanism to select the portion of the program code that includes the temperature variable. When the temperature variable is selected the variable editor section may display data associated with the temperature variable e.g. instead of the plot . The data may include a data issue e.g. a NaN indication that may be corrected by the user.

Such an arrangement may enable a programmer to see errors associated with particular lines of the program code as the particular lines are written rather than after the entire program is written. Writing program code may involve maintaining concentration. If the programmer needs to stop writing the program code in order to execute the code e.g. in a debugger the programmer may lose the entire context of where the programmer is in writing the program code. It may be costly for the programmer to return to the correct portion of the program code. The user interface depicted in keeps the programmer in the program code while allowing the programmer to see how each line of the program code affects the entire program code.

The terms code and program code as used herein are to be used interchangeably and are to be broadly interpreted to include text based code that may require further processing to execute e.g. C code Hardware Description Language HDL code very high speed integrated circuits VHSIC HDL VHDL code Verilog Java and or other types of hardware or software based code that may be compiled and or synthesized binary code that may be executed e.g. executable files that may directly be executed by an operating system bitstream files that can be used to configure a field programmable gate array FPGA Java byte code object files combined together with linker directives source code makefiles etc. text files that may be executed in conjunction with other executables e.g. Python text files a collection of dynamic link library DLL files with text based combining configuration information that connects pre compiled modules an extensible markup language XML file describing module linkage etc. etc. In one example code may include different combinations of the above identified classes e.g. text based code binary code text files etc. . Alternatively or additionally code may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations. Alternatively or additionally code may be of any type such as function script object etc. and a portion of code may include one or more characters lines etc. of the code.

Client device may include one or more devices that are capable of communicating with server device via network . For example client device may include a laptop computer a personal computer a tablet computer a desktop computer a workstation computer a smart phone a personal digital assistant PDA and or other computation and communication devices.

Server device may include one or more server devices or other types of computation and communication devices that gather process and or provide information in a manner described herein. Server device may include a device that is capable of communicating with client device e.g. via network . In one example server device may include one or more laptop computers personal computers workstation computers servers central processing units CPUs graphical processing units GPUs application specific integrated circuits ASICs field programmable gate arrays FPGAs etc. and or software e.g. a simulator executing on the aforementioned devices. In one example server device may include TCE and may perform some or all of the functionality described herein for client device . Alternatively server device may be omitted and client device may perform all of the functionality described herein for client device .

Network may include a network such as a local area network LAN a wide area network WAN a metropolitan area network MAN a telephone network such as the Public Switched Telephone Network PSTN an intranet the Internet or a combination of networks.

TCE may be provided within a computer readable medium of client device . Alternatively or additionally TCE may be provided in another device e.g. server device that is accessible by client device . TCE may include hardware or a combination of hardware and software that provides a computing environment that allows users to perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. more efficiently than if the tasks were performed in another type of computing environment such as an environment that required the user to develop code in a conventional programming language such as C C Fortran Pascal etc. In one implementation TCE may include a dynamically typed programming language e.g. the M language a MATLAB language a MATLAB compatible language a MATLAB like language etc. that can be used to express problems and or solutions in mathematical notations.

For example TCE may use an array as a basic element where the array may not require dimensioning. These arrays may be used to support array based programming where an operation may apply to an entire set of values included in the arrays. Array based programming may allow array based operations to be treated as high level programming that may allow for example operations to be performed on entire aggregations of data without having to resort to explicit loops of individual non array operations. In addition TCE may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development etc. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design etc.

TCE may further provide mathematical functions and or graphical tools e.g. for creating plots surfaces images volumetric representations etc. . In one implementation TCE may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . Alternatively or additionally TCE may provide these functions as block sets or in another way such as via a library etc.

TCE may be implemented as a text based environment e.g. MATLAB software Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence Modelica or Dymola from Dynasim etc. a graphically based environment e.g. Simulink software Stateflow software SimEvents software Simscape software etc. by The MathWorks Inc. VisSim by Visual Solutions LabView by National Instruments Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhopsody or Tau from Telelogic Ptolemy from the University of California at Berkeley aspects of a Unified Modeling Language UML or SysML environment etc. or another type of environment such as a hybrid environment that includes one or more of the above referenced text based environments and one or more of the above referenced graphically based environments.

TCE may include a programming language e.g. the MATLAB language that may be used to express problems and or solutions in mathematical notations. The programming language may be dynamically typed and or array based. In a dynamically typed array based computing language data may be contained in arrays and data types of the data may be determined e.g. assigned at program execution time.

For example suppose a program written in a dynamically typed array based computing language includes the following statements 

Now suppose the program is executed for example in a TCE such as TCE . During run time when the statement A hello is executed the data type of variable A may be a string data type. Later when the statement A int32 1 2 is executed the data type of variable A may be a 1 by 2 array containing elements whose data type are 32 bit integers. Later when the statement A 1.1 2.2 3.3 is executed since the language is dynamically typed the data type of variable A may be changed from the above 1 by 2 array to a 1 by 3 array containing elements whose data types are floating point. As can be seen by this example data in a program written in a dynamically typed array based computing language may be contained in an array. Moreover the data type of the data may be determined during execution of the program. Thus in a dynamically type array based computing language data may be represented by arrays and data types of data may be determined at run time.

TCE may provide mathematical routines and a high level programming language suitable for non professional programmers and may provide graphical tools that may be used for creating plots surfaces images volumetric representations or other representations. TCE may provide these routines and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . TCE may also provide these routines in other ways such as for example via a library local or remote database e.g. a database operating in a computing cloud remote procedure calls RPCs and or an application programming interface API . TCE may be configured to improve runtime performance when performing computing operations. For example TCE may include a just in time JIT compiler.

Although shows example components of environment in other implementations environment may include fewer components different components differently arranged components and or additional components than those depicted in . Alternatively or additionally one or more components of environment may perform one or more other tasks described as being performed by one or more other components of environment .

Processing unit may include one or more processors microprocessors or other types of processing units that may interpret and execute instructions. Main memory may include one or more random access memories RAMs or other types of dynamic storage devices that may store information and or instructions for execution by processing unit . ROM may include one or more ROM devices or other types of static storage devices that may store static information and or instructions for use by processing unit . Storage device may include a magnetic and or optical recording medium and its corresponding drive.

Input device may include a mechanism that permits a user to input information to device such as a keyboard a camera an accelerometer a gyroscope a mouse a pen a microphone voice recognition and or biometric mechanisms a remote control a touch screen a neural interface etc. Output device may include a mechanism that outputs information to the user including a display a printer a speaker etc. Communication interface may include any transceiver like mechanism that enables device to communicate with other devices networks and or systems. For example communication interface may include mechanisms for communicating with another device or system via a network.

As described herein device may perform certain operations in response to processing unit executing software instructions contained in a computer readable medium such as main memory . A computer readable medium may be defined as a non transitory memory device. A memory device may include space within a single physical memory device or spread across multiple physical memory devices. The software instructions may be read into main memory from another computer readable medium such as storage device or from another device via communication interface . The software instructions contained in main memory may cause processing unit to perform processes described herein. Alternatively hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus implementations described herein are not limited to any specific combination of hardware circuitry and software.

Although shows example components of device in other implementations device may include fewer components different components differently arranged components and or additional components than depicted in . Alternatively or additionally one or more components of device may perform one or more other tasks described as being performed by one or more other components of device .

Block diagram editor may include hardware or a combination of hardware and software that may be used to graphically specify models of dynamic systems. In one implementation block diagram editor may permit a user to perform actions such as construct edit display annotate save and or print a graphical model e.g. a block diagram that visually and or pictorially represents a dynamic system . In another implementation block diagram editor may permit a user to create and or store data relating to graphical entities .

A textual interface may be provided to permit interaction with block diagram editor . A user may write scripts that perform automatic editing operations on a model using the textual interface. For example the textual interface may provide a set of windows that may act as a canvas for the model and may permit user interaction with the model. A model may include one or more windows depending on whether the model is partitioned into multiple hierarchical levels.

Graphical entities may include hardware or a combination of hardware and software that may provide entities e.g. signal lines buses etc. that represent how data may be communicated between functional and or non functional units and blocks of a model. Blocks may include fundamental mathematical elements of a block diagram model.

Execution engine may include hardware or a combination of hardware and software that may process a graphical model to produce simulation results may convert the graphical model into executable code and or may perform other analyses and or related tasks. In one implementation for a block diagram graphical model execution engine may translate the block diagram into executable entities e.g. units of execution following the layout of the block diagram. The executable entities may be compiled and or executed on a device e.g. client device to implement the functionality specified by the model.

Graphical models may include entities with relationships between the entities and the relationships and or the entities may have attributes associated with them. The entities my include model elements such as blocks and ports. The relationships may include model elements such as lines e.g. connector lines and references. The attributes may include model elements such as value information and meta information for the model element associated with the attributes. Graphical models may be associated with configuration information. The configuration information may include information for the graphical model such as model execution information e.g. numerical integration schemes fundamental execution period etc. model diagnostic information e.g. whether an algebraic loop should be considered an error or result in a warning model optimization information e.g. whether model elements should share memory during execution model processing information e.g. whether common functionality should be shared in code that is generated for a model etc.

Additionally or alternatively a graphical model may have executable semantics and or may be executable. An executable graphical model may be a time based block diagram. A time based block diagram may consist for example of blocks e.g. blocks connected by lines e.g. connector lines . The blocks may consist of elemental dynamic systems such as a differential equation system e.g. to specify continuous time behavior a difference equation system e.g. to specify discrete time behavior an algebraic equation system e.g. to specify constraints a state transition system e.g. to specify finite state machine behavior an event based system e.g. to specify discrete event behavior etc. The lines may represent signals e.g. to specify input output relations between blocks or to specify execution dependencies between blocks variables e.g. to specify information shared between blocks physical connections e.g. to specify electrical wires pipes with volume flow rigid mechanical connections etc. etc. The attributes may consist of meta information such as sample times dimensions complexity whether there is an imaginary component to a value data type etc. associated with the model elements.

In a time based block diagram ports may be associated with blocks e.g. blocks . A relationship between two ports may be created by connecting a line e.g. a connector line between the two ports. Lines may also or alternatively be connected to other lines for example by creating branch points. For instance three or more ports can be connected by connecting a line to each of the ports and by connecting each of the lines to a common branch point for all of the lines. A common branch point for the lines that represent physical connections may be a dynamic system e.g. by summing all variables of a certain type to 0 or by equating all variables of a certain type . A port may be an input port an output port an enable port a trigger port a function call port a publish port a subscribe port an exception port an error port a physics port an entity flow port a data flow port a control flow port etc.

Relationships between blocks e.g. blocks may be causal and or non causal. For example a model may include a block that represents a continuous time integration block that may be causally related to a data logging block by using a line e.g. a connector line to connect an output port of the continuous time integration block to an input port of the data logging block. Further during execution of the model the value stored by the continuous time integrator may change as the current time of the execution progresses. The value of the state of the continuous time integrator may be available on the output port and the connection with the input port of the data logging block may make this value available to the data logging block.

A sample time may be associated with the elements of a graphical model. For example a graphical model may include a block e.g. block with a continuous sample time such as a continuous time integration block that may integrate an input value as time of execution progresses. This integration may be specified by a differential equation. During execution the continuous time behavior may be approximated by a numerical integration scheme that is part of a numerical solver. The numerical solver may take discrete steps to advance the execution time and these discrete steps may be constant during an execution e.g. fixed step integration or may be variable during an execution e.g. variable step integration .

Alternatively or additionally a graphical model may include a block e.g. block with a discrete sample time such as a unit delay block that may output values of a corresponding input after a specific delay. This delay may be a time interval and this interval may determine a sample time of the block. During execution the unit delay block may be evaluated each time the execution time has reached a point in time where an output of the unit delay block may change. These points in time may be statically determined based on a scheduling analysis of the graphical model before starting execution.

Alternatively or additionally a graphical model may include a block e.g. block with an asynchronous sample time such as a function call generator block that may schedule a connected block to be evaluated at a non periodic time. During execution a function call generator block may evaluate an input and when the input attains a specific value when the execution time has reached a point in time the function call generator block may schedule a connected block to be evaluated at this point in time and before advancing execution time.

Further the values of attributes of a graphical model may be inferred from other elements of the graphical model or attributes of the graphical model. For example the graphical model may include a block e.g. block such as a unit delay block that may have an attribute that specifies a sample time of the block. When a graphical model has an execution attribute that specifies a fundamental execution period the sample time of the unit delay block may be inferred from this fundamental execution period.

As another example the graphical model may include two unit delay blocks e.g. blocks where the output of the first of the two unit delay blocks is connected to the input of the second of the two unit delay block. The sample time of the first unit delay block may be inferred from the sample time of the second unit delay block. This inference may be performed by propagation of model element attributes such that after evaluating the sample time attribute of the second unit delay block a graph search proceeds by evaluating the sample time attribute of the first unit delay block since it is directly connected to the second unit delay block.

The values of attributes of a graphical model may be set to characteristics settings such as one or more inherited settings one or more default settings etc. For example the data type of a variable that is associated with a block e.g. block may be set to a default such as a double. Because of the default setting an alternate data type e.g. a single an integer a fixed point etc. may be inferred based on attributes of elements that the graphical model comprises e.g. the data type of a variable associated with a connected block and or attributes of the graphical model. As another example the sample time of a block may be set to be inherited. In case of an inherited sample time a specific sample time may be inferred based on attributes of elements that the graphical model comprises and or attributes of the graphical model e.g. a fundamental execution period .

Although shows example functional components of TCE in other implementations TCE may include fewer functional components different functional components differently arranged functional components and or additional functional components than depicted in . Alternatively or additionally one or more functional components of TCE may perform one or more other tasks described as being performed by one or more other functional components of TCE .

Continuous evaluation component may enable a program code to be evaluated while the program code is being created and or edited. In one example implementation continuous evaluation component may receive an input associated with program code currently being created by a user e.g. a programmer . The input may include typing one or more characters in the program code typing a word in the program code typing a semicolon in the program code executing a test on the program code pausing of typing in the program code executing a static analysis engine on the program code expiration of a period of time that the programmer is working on the program code etc.

Continuous evaluation component may determine whether to perform an evaluation on the program code based on the received input. For example if the input includes typing a single character continuous evaluation component may determine not to perform the evaluation. Alternatively or additionally if the input includes typing a word in the program code continuous evaluation component may determine to perform the evaluation. The evaluation may include executing one or more portions of the program code executing the entire program code executing a statistical analysis on the program code e.g. code coverage statistics executing a static analysis on the program code executing other tools e.g. a profiler that determines time and computer resources utilized for execution on the program code etc.

If continuous evaluation component determines not to perform the evaluation continuous evaluation component may do nothing and wait for another input from the programmer. If continuous evaluation component determines to perform the evaluation continuous evaluation component may perform the evaluation of the program code to generate results. The results may include information associated with variables e.g. inputs outputs intermediate variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc.

Continuous evaluation component may determine whether to display the results. For example if the results indicate an error in the program code an unexecuted portion e.g. a line of the program code an inefficient portion e.g. a line of the program code etc. continuous evaluation component may determine to display the results. Alternatively or additionally if the results indicate that the program code contains no errors continuous evaluation component may determine to not display the results. If continuous evaluation component determines to not display the results continuous evaluation component may do nothing and wait for another input from the programmer. If continuous evaluation component determines to display the results continuous evaluation component may provide the results for display e.g. to the programmer .

Alternatively or additionally continuous evaluation component may determine whether one or more errors are present in the results and whether to display the error s . For example continuous evaluation component may determine an error is present in the program code when the program code contains unrecognized syntax a line that will not execute a line that requires an inordinate amount of time to execute e.g. greater than a threshold etc. Continuous evaluation component may determine to display an error when the error includes a line that will not execute a line that requires an inordinate amount of time to execute etc. Alternatively or additionally continuous evaluation component may determine to not display an error when the error is due to the programmer typing a character of syntax e.g. a command but not finishing the syntax prior to the evaluation.

If continuous evaluation component determines error s in the results and determines to not display the error s continuous evaluation component may do nothing and wait for another input from the programmer. Alternatively continuous evaluation component may do nothing and wait for another input from the programmer if continuous evaluation component determines no errors in the results. If continuous evaluation component determines error s in the results and to display the error s continuous evaluation component may provide the error s for display.

Saving state component may enable state information associated with one or more portions of the program code to be saved and utilized to determine differences between the one or more portions of the program code. In one example implementation saving state component may receive program code currently being created by a user e.g. a programmer and may execute a first portion e.g. one or more lines of the program code to generate first results. Saving state component may execute a second portion e.g. the one or more lines and or one or more additional lines of the program code to generate second results and may store the first results and the second results.

The first results and or the second results may include information associated with a state of the program code variables e.g. inputs outputs intermediate variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc. The state of the program code may include information contained in a workspace outputs generated by each line of the program code errors generated by the program code time information live updates of each variable on each line of the program code e.g. a variable value may change at each line of the code etc.

Saving state component may compare the first results and the second results to determine one or more differences between the first results and the second results. For example the first results may provide outputs that are expected for the program code and the second results may provide outputs that are unexpected for the program code. Saving state component may utilize the determined difference s between the first results and the second results to identify one or more errors in the program code. Returning to the previous example since the second results provide outputs that are unexpected for the program code saving state component may determine that the second portion of the program code contains an error. Saving state component may further analyze e.g. execute additional tests on the second portion of the program code to further determine the reason for the error. Saving state component may provide the difference s and or the error s for display to the programmer.

As further shown in TCE via continuous evaluation component and saving state component may provide a user interface that enables a user e.g. a programmer to create and or edit the program code while simultaneously viewing results of the continuous evaluation of the program code. For example user interface may include an editor section e.g. a window that enables the user to create view edit etc. the program code. User interface may include a workspace section e.g. a window that displays information associated with variables e.g. inputs outputs intermediate variables of the program code provided in the editor section. The information displayed in the workspace section may change when the user selects different portions of the program code. User interface may include a variable editor section e.g. a window that displays information associated with the variables of the program code. For example the variable editor section may display a graph generated by the program code.

User interface may include a mechanism that when selected permits the user to playback lines of the program code. In one example the playback mechanism may enable the user to step though the lines of the program code and see what effect each line has on the variables of the program code. As further shown in the variable editor section may display a plot of a temperature variable of the program code. The plot may include an error such as for example a break in the plotted line. The workspace section may display an error e.g. a NaN indication associated with the temperature variable which may cause error in the plot. The user may use a cursor or some other selection mechanism to select the portion of the program code that includes the temperature variable. When the temperature variable is selected with cursor the variable editor section may display data associated with the temperature variable e.g. instead of the plot . The data may include a data issue e.g. a NaN indication that may be corrected by the user.

Such an arrangement may enable a programmer to see errors associated with particular lines of the program code as the particular lines are written rather than after the entire program is written. Writing program code may involve maintaining concentration. If the programmer needs to stop writing the program code in order to execute the code e.g. in a debugger the programmer may lose the entire context of where the programmer is in writing the program code. It may be costly for the programmer to return to the correct portion of the program code. User interface may keep the programmer in the program code while allowing the programmer to see how each line of the program code affects the entire program code.

In one example implementation if the programmer changes a line of the program code contained in the editor section continuous evaluation component may not need to re execute the lines of the program code provided before the changed line of the program code. This may be due to saving state component storing information e.g. variables associated with execution of the lines of the program code provided before the changed line of the program code. Such an arrangement may save time and computational resources especially if the lines of the program code that are not re executed require an inordinate amount of time to execute.

Although shows example operations capable of being performed by TCE in other implementations TCE may perform fewer operations different operations and or additional operations than depicted in . Alternatively or additionally one or more components of may perform one or more other tasks described as being performed by one or more other components of .

Trigger evaluation component may receive inputs associated with program code currently being created by a user e.g. a programmer . Inputs may include typing one or more characters in the program code typing a word in the program code typing a semicolon in the program code executing a test on the program code pausing of typing in the program code executing a static analysis engine on the program code expiration of a period of time that the programmer is working on the program code etc. Trigger evaluation component may determine whether to perform an evaluation on the program code based on inputs . For example if inputs include typing a single character trigger evaluation component may determine not to perform the evaluation. Alternatively or additionally if inputs include typing a word in the program code trigger evaluation component may determine to perform the evaluation. If the evaluation is to be performed trigger evaluation component may provide to code evaluation component a request to perform the evaluation.

If code evaluation component receives request code evaluation component may perform the evaluation of the program code as provided in request . The evaluation may include executing one or more portions of the program code executing the entire program code executing a statistical analysis on the program code executing a static analysis on the program code executing other tools e.g. a profiler on the program code etc. Code evaluation component may perform the evaluation of the program code to generate results . Results may include information associated with variables e.g. inputs outputs intermediate variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc. Code evaluation component may provide results to results analysis component .

Results analysis component may receive results and may determine whether to display results . For example if results indicate an error in the program code an unexecuted portion of the program code an inefficient portion of the program code etc. results analysis component may provide results for display as indicated by reference number . Alternatively or additionally if results indicate that the program code contains no errors results analysis component may not display results as further indicated by reference number .

Results analysis component may determine whether one or more errors are present in results . For example results analysis component may determine an error is present in results when the program code contains unrecognized syntax a line that will not execute a line that requires an inordinate amount of time to execute etc. If errors are found in results results analysis component may provide errors to error analysis component .

Error analysis component may receive errors and may determine whether or not to display errors . Error analysis component may determine to display errors when errors include a line that will not execute a line that requires an inordinate amount of time to execute etc. Alternatively or additionally error analysis component may determine to not display errors when errors are due to the programmer typing a character of syntax e.g. a command but not finishing the syntax prior to the evaluation. If error analysis component determines to not display errors error analysis component may not display errors as indicated by reference number . If error analysis component determines to display errors error analysis component may provide errors for display as further indicated by reference number .

Although shows example functional components of continuous evaluation component in other implementations continuous evaluation component may contain fewer functional components different functional components differently arranged functional components and or additional functional components than those depicted in . Alternatively or additionally one or more functional components of continuous evaluation component may perform one or more other tasks described as being performed by one or more other functional components of continuous evaluation component .

Code execution components may receive portions through N of program code collectively referred to herein as code portions and in some instances singularly as code portion currently being created by a user such as a programmer. Code portions may include one or more lines of the program code. Code execution components may execute corresponding code portions to generate corresponding results through N collectively referred to herein as results and in some instances singularly as result .

Results may include information associated with a state of the program code variables e.g. inputs outputs intermediate variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc. The state of the program code may include information contained in a workspace outputs generated by each line of the program code errors generated by the program code time information live updates of each variable on each line of the program code e.g. a variable value may change at each line of the code etc. As further shown in code execution components may provide results to state storage component .

State storage component may include one or more memory devices that receive and store results . If the programmer changes a line of the program code code execution components may not need to re execute the lines of the program code provided before the changed line of the program code. This may be due to state storage component storing results . Such an arrangement may save time and computational resources especially if the lines of the program code that are not re executed require an inordinate amount of time to execute. As further shown in state storage component may provide results to results comparison component .

Results comparison component may receive results and may compare results to determine one or more differences between results . For example results may provide outputs that are expected for the program code and results N may provide outputs that are unexpected for the program code. Results comparison component may utilize differences between results to identify one or more errors in the program code. Returning to the previous example since results N provide outputs that are unexpected for the program code results comparison component may determine that code portion N contains an error. Results comparison component may further analyze e.g. execute additional tests on code portion N to further determine the reason for the error. Results comparison component may provide differences and or the error s for display to the programmer.

Although shows example functional components of saving state component in other implementations saving state component may contain fewer functional components different functional components differently arranged functional components and or additional functional components than those depicted in . Alternatively or additionally one or more functional components of saving state component may perform one or more other tasks described as being performed by one or more other functional components of saving state component .

With reference to user interface may enable a user e.g. a programmer to create and or edit the program code while simultaneously viewing results of the continuous evaluation of the program code. In one example user interface may include an editor section that enables the user to create view edit etc. the program code. User interface may include a workspace section that displays information associated with variables e.g. inputs outputs intermediate variables of the program code provided in editor section . The information displayed in workspace section may change when the user selects different portions of the program code in editor section . User interface may include a variable editor section that displays information associated with the variables of the program code.

In one example workspace section and variable editor section may not display information until the programmer enters syntax in editor section that is recognizable as program code. As shown in once the programmer enters the syntax data TCE may recognize the syntax and may evaluate the syntax with continuous evaluation component . TCE via user interface may display results of the syntax evaluation in workspace section and variable editor section . For example workspace section may display information associated with data e.g. a maximum value and a minimum value and variable editor section may display a spreadsheet with values associated with data. 

As shown in the programmer may continue to enter syntax in the program code of editor section and may enter the syntax data xlsload weather.xlsx on the second line of the program code. TCE may evaluate the syntax on the second line of the program code with continuous evaluation component . Continuous evaluation component may determine based on the evaluation that the second line of the program code includes incorrect code . For example continuous evaluation component may determine that incorrect code includes an undefined function e.g. xlsload for character type input arguments. TCE via user interface may display information associated with incorrect code in variable editor section . For example variable editor section may display an error notification that indicates that the syntax data xlsload weather.xlsx includes an undefined function e.g. xlsload for character type input arguments.

The programmer may see error notification and may correct the second line of the program code. For example the programmer may utilize editor section to change incorrect code e.g. data xlsload weather.xlsx to correct code e.g. data xlsread weather.xlsx as shown in . After correct code is entered by the programmer TCE may evaluate correct code with continuous evaluation component . TCE via user interface may display results of the evaluation of correct code in workspace section and variable editor section . For example workspace section may display information associated with data e.g. a maximum value and a minimum value and variable editor section may display a spreadsheet with values associated with data. 

The programmer may continue to enter additional lines into the program code of editor section and continuous evaluation component may continuously evaluate the additional lines of the program code as described above in connection with . Saving state component may store the state information generated by the evaluation of the lines of the program code as described above in connection with . As shown in editor section of the programmer may enter program code associated with a first step e.g. bringing in data a second step e.g. creating separate variables and a third step e.g. creating plots .

As further shown in the programmer may enter the syntax plot temperature on the eleventh line of the program code. TCE may evaluate the syntax on the eleventh line of the program code with continuous evaluation component . TCE via user interface may display results of the syntax evaluation in workspace section and variable editor section . For example workspace section may display information associated with data variables e.g. humidity pressure and temperature and variable editor section may display a plot associated with the temperature variable. As further shown in the plot in variable editor section may include an error such as for example a break in the plotted line. Workspace section may display an error e.g. a NaN indication associated with the temperature variable which may cause error in the plot.

As shown in the programmer may use a cursor or some other selection mechanism to select the portion of the program code e.g. the fifth line that includes the temperature variable. When the temperature variable is selected with cursor variable editor section may display data associated with the temperature variable e.g. instead of the plot . The data associated with the temperature variable may include an issue e.g. a NaN indication that may be corrected by the programmer.

The programmer may correct issue e.g. by providing a value where the NaN indication is provided in variable editor section and may utilize cursor to select a portion of the program code e.g. the twelfth line after the syntax plot temperature as shown in . TCE may evaluate the syntax of the program code with continuous evaluation component . TCE via user interface may display results of the syntax evaluation in workspace section and variable editor section . For example workspace section may display information associated with the data variables e.g. humidity pressure and temperature and variable editor section may display a fixed plot associated with the temperature variable. As further shown in fixed plot in variable editor section may not include the break in the plotted line since the programmer corrected issue . Workspace section may display values e.g. a minimum value and a maximum value associated with the temperature variable.

Although user interface depicts a variety of information in other implementations user interface may depict less information different information differently arranged information and or additional information than depicted in . In one example implementation a microphone may be utilized by the user of TCE to provide voice commands to TCE . The voice commands may be used in place of and or in addition to the user inputs described above in connection with .

As further shown in editor section may not display an indicator next to lines of the program code where the state is known as indicated by reference number . The state of a line of the program code may be known when continuous evaluation component of TCE evaluates the line of the program code and results of the evaluation are stored by saving state component of TCE . Alternatively or additionally the state of a line of the program code may be known when saving state component executes the line of the program code and stores results of the execution e.g. in state storage .

Editor section may display an indicator e.g. a flag or some other type of indicator next to lines of the program code where the state is not known. The state of a line of the program code may not be known when continuous evaluation component of TCE has not evaluated the line of the program code. Alternatively or additionally the state of a line of the program code may not be known when saving state component has not executed the line of the program code. Alternatively or additionally the state of a line of the program code may not be known when continuous evaluation component evaluates the line of the program code but the programmer changes syntax in the line of the program code. Alternatively or additionally the state of a line of the program code may not be known when saving state component executes the line of the program code but the programmer changes syntax in the line of the program code.

Indicator may alert the programmer of a need to evaluate and or execute the lines of the program code where the state is not known. For example the programmer may utilize playback mechanism to evaluate and or execute one or more lines of the program code where the state is not known. Such an arrangement may enable a state of the program code to be current and known while the programmer is creating and or editing the program code.

Although user interface depicts a variety of information in other implementations user interface may depict less information different information differently arranged information and or additional information than depicted in . In one example implementation a microphone may be utilized by the user of TCE to provide voice commands to TCE . The voice commands may be used in place of and or in addition to the user inputs described above in connection with .

As shown in editor section may display three lines of program code that include the variables x and y. A programmer may utilize a cursor or some other selection mechanism to select or hover over a line of the program code. For example the programmer may utilize cursor to select or hover over the first line of the program code or a variable contained in the first line. When the first line of the program code is selected or hovered over TCE e.g. via continuous evaluation component and or saving state component may cause user interface to display a value of a variable e.g. x contained the first line of the program code in variable editor section as indicated by reference number . For example variable editor section may display a value of 3 for the variable x. 

As shown in the programmer may utilize a cursor or some other selection mechanism to select or hover over another line of the program code. For example the programmer may utilize cursor to select or hover over the third line of the program code or a variable contained in the third line. When the third line of the program code is selected or hovered over TCE e.g. via continuous evaluation component and or saving state component may cause user interface to display a value of a variable e.g. x contained the third line of the program code in variable editor section as indicated by reference number . For example variable editor section may display a value of 4 for the variable x. The programmer may select or hover over any variable at a particular point in the program code and TCE may cause user interface to display a value of the selected variable at the particular point in the program code. As shown in a value of a variable may change at different locations of the program code.

Although user interface depicts a variety of information in other implementations user interface may depict less information different information differently arranged information and or additional information than depicted in . In one example implementation a microphone may be utilized by the user of TCE to provide voice commands to TCE . The voice commands may be used in place of and or in addition to the user inputs described above in connection with .

As shown in editor section may display five lines of program code that include various variables. Continuous evaluation component may perform an evaluation of the program code to generate results. Based on the results of the evaluation continuous evaluation component may determine errors in the program code. For example continuous evaluation component may determine that the third line of the program code will never execute and that the fourth and fifth lines of the program code result in an endless loop. Because errors were found in the program code continuous evaluation component may provide the results for display to the programmer. For example continuous evaluation component may cause variable editor section to display an indication that the third line of the program code will never execute and another indication that the fourth and fifth lines of the program code result in an endless loop.

Although user interface depicts a variety of information in other implementations user interface may depict less information different information differently arranged information and or additional information than depicted in . In one example implementation a microphone may be utilized by the user of TCE to provide voice commands to TCE . The voice commands may be used in place of and or in addition to the user inputs described above in connection with .

In one example implementation user interfaces may be arranged to display thumbnail images of editor section workspace section variable editor section and or other sections. If the programmer selects or hovers over one of the thumbnail images user interfaces may display a larger view of the section associated with the selected thumbnail image. This may enable the programmer to easily navigate between the different sections.

As shown in process may include receiving an input associated with a program code currently being created block and determining whether to perform an evaluation of the program code based on the input block . For example in an implementation described above in connection with continuous evaluation component may receive an input associated with program code currently being created by a user e.g. a programmer . The input may include typing one or more characters in the program code typing a word in the program code typing a semicolon in the program code executing a test on the program code etc. Continuous evaluation component may determine whether to perform an evaluation on the program code based on the received input. The evaluation may include executing one or more portions of the program code executing the entire program code executing a statistical analysis on the program code e.g. code coverage statistics etc.

As further shown in if the evaluation is not to be performed block DO NOT PERFORM process may stop. If the evaluation is to be performed block PERFORM process may include performing an evaluation of the program code to generate results block . For example in an implementation described above in connection with if continuous evaluation component determines not to perform the evaluation continuous evaluation component may do nothing and wait for another input from the programmer. If continuous evaluation component determines to perform the evaluation continuous evaluation component may perform the evaluation of the program code to generate results. The results may include information associated with variables e.g. inputs outputs intermediate variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc.

Returning to process may include determining whether to display the results block . If the results are not to be displayed block NO process may stop. If the results are to be displayed block YES process may include providing the results for display block . For example in an implementation described above in connection with continuous evaluation component may determine whether to display the results. If continuous evaluation component determines to not display the results continuous evaluation component may do nothing and wait for another input from the programmer. If continuous evaluation component determines to display the results continuous evaluation component may provide the results for display e.g. to the programmer .

As further shown in process may include determining whether error s are present in the results and or whether to display the error s block . If there are no error s to display or the error s are not to be displayed block NO ERROR S DO NOT DISPLAY process may stop. If there are error s to display block ERROR S DISPLAY process may include providing the error s for display block . For example in an implementation described above in connection with continuous evaluation component may determine whether one or more errors are present in the result and whether to display the error s . If continuous evaluation component determines error s in the results and determines to not display the error s continuous evaluation component may do nothing and wait for another input from the programmer. Alternatively continuous evaluation component may do nothing and wait for another input from the programmer if continuous evaluation component determines no errors in the results. If continuous evaluation component determines error s in the results and to display the error s continuous evaluation component may provide the error s for display.

As shown in process may include receiving program code currently being created block executing a first portion of the program code to generate first results block and executing a second portion of the program code to generate second results block . For example in an implementation described above in connection with saving state component may receive program code currently being created by a user e.g. a programmer and may execute a first portion e.g. one or more characters lines etc. of the program code to generate first results. Saving state component may execute a second portion e.g. the one or more characters lines etc. and or one or more additional characters lines etc. of the program code to generate second results. The first results and or the second results may include information associated with a state of the program code variables of the program code information associated with errors discovered in the program code information associated with tests and or analyses performed on the program code etc.

As further shown in process may include storing the first results and the second results block and comparing the first results and the second results to determine differences between the first results and the second results block . For example in an implementation described above in connection with saving state component may store the first results and the second results. Saving state component may compare the first results and the second results to determine one or more differences between the first results and the second results. In one example the first results may provide outputs that are expected for the program code and the second results may provide outputs that are unexpected for the program code.

Returning to process may include utilizing the differences to identify one or more errors in the program code block and providing the differences and the error s for display block . For example in an implementation described above in connection with saving state component may utilize the determined difference s between the first results and the second results to identify one or more errors in the program code. In one example if the second results provide outputs that are unexpected for the program code saving state component may determine that the second portion of the program code contains an error. Saving state component may further analyze e.g. execute additional tests on the second portion of the program code to further determine the reason for the error. Saving state component may provide the difference s and or the error s for display to the programmer.

Systems and or methods described herein may enable program code to be continuously evaluated while the program code is being created and or edited. The systems and or methods may enable state information associated with one or more portions of the program code to be saved and utilized to determine differences between the portion s of the program code. The systems and or methods may continuously execute the program code in the background and may provide a live view or workspace of results of the code execution at each line of the program code. The results may include information associated with a line of the program code such as variable values inputs outputs errors etc.

The foregoing description of implementations provides illustration and description but is not intended to be exhaustive or to limit the implementations to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the implementations.

For example while series of blocks have been described with regard to the order of the blocks may be modified in other implementations. Further non dependent blocks may be performed in parallel.

It will be apparent that example aspects as described above may be implemented in many different forms of software firmware and hardware in the implementations illustrated in the figures. The actual software code or specialized control hardware used to implement these aspects should not be construed as limiting. Thus the operation and behavior of the aspects were described without reference to the specific software code it being understood that software and control hardware could be designed to implement the aspects based on the description herein.

Further certain portions of the implementations may be implemented as a component that performs one or more functions. This component may include hardware such as a processor an application specific integrated circuit ASIC or a field programmable gate array FPGA or a combination of hardware and software.

Even though particular combinations of features are recited in the claims and or disclosed in the specification these combinations are not intended to limit the disclosure of the specification. In fact many of these features may be combined in ways not specifically recited in the claims and or disclosed in the specification. Although each dependent claim listed below may directly depend on only one other claim the disclosure of the specification includes each dependent claim in combination with every other claim in the claim set.

No element act or instruction used in the present application should be construed as critical or essential unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

