---

title: Efficient and expansive conversions between reference and primitive
abstract: A tool, such as a compiler or an interpreter, receives program source code and determines that the code includes an operation for which type conversion is permitted on an operand. The tool determines a source type of the operand, and a target type to which the operand is to be converted. In response to determining that the source type is a reference type and the target type is a primitive type, the tool generates a set of instructions to (a) determine whether, at run time, in accordance with a class definition of the reference type, a value of the target primitive type can be obtained via one or more method invocations on the operand (b) if such a value can be obtained, obtain the value and assign the value to a result of the operation and (c) if such a value cannot be obtained, generate an error indication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08863079&OS=08863079&RS=08863079
owner: Oracle International Corporation
number: 08863079
owner_city: Redwood City
owner_country: US
publication_date: 20120731
---
For performance and other reasons object oriented computer programming languages such as Java may support a set of primitive data types in addition to reference data types. In general a variable s data type determines the values it may contain and the operations that may be performed on it. The terms primitive types and reference types may be used herein to refer to primitive data types and reference data types respectively. Primitive types may be predefined by the language specification and may be named using reserved keywords such as int or float . In some environments the value of a primitive type may be stored in a location of a fixed size on the stack such as a four byte 32 bit location for int variables and may not share state with other primitive values. In contrast a data type for which when an object of that data type is instantiated a reference in effect a pointer to a heap location storing the value of the instantiated object is created is called a reference type. In other environments the stack versus heap distinction between primitive and reference types may not always apply. For example virtual machines with escape analysis optimization may be able to stack allocate certain objects of reference types. In general a small number of primitive types may be supported by the language while arbitrary numbers of reference types e.g. classes interfaces or arrays in the case of Java may be defined and created by users of the language. It is noted that the distinction between primitive and reference types may be affected somewhat by language features like value types which may allow user defined types to behave more like primitives than reference types. For example objects of values types would not be comparable for identity only for value.

Some language constructs or frameworks such as various classes defined in the Java Collections framework for representing aggregates like sets lists and maps may be provided strictly for reference types in object oriented languages. That is it may not be legal in the language to set up an aggregate of primitive values or use aggregate features such as iterators directly on primitive values. However a number of special reference types called wrapper types may also be supported in some languages to manually or automatically encapsulate primitive values as objects e.g. an int value may be encapsulated using the Integer wrapper reference type in Java effectively converting a primitive value to a reference to an object with the same numerical value so that the functionality provided by the frameworks may be extended to primitive values which are suitably wrapped.

The object oriented programming language may support implicit and explicit data type conversion operations in which for example the value of an expression of a source data type S may be stored in a variable of a target data type T. The following code may represent an example explicit casting conversion operation 

Several different kinds of type conversion operations may be supported in a given programming language. For example exhaustive primitive to primitive conversions may be supported for numerical primitives such as a conversion of an int to a short or a short to an int. However in many cases there may be limitations and irregularities in the extent to which conversions from primitive types to reference types or from reference types to primitive types are supported in a given version of a programming language. For example even though it may appear to a programmer that it would be reasonable and meaningful to be able to convert from a reference type R to a primitive type P e.g. Long to int on the grounds that it is meaningful to convert from the unwrapped form of R to P i.e. long to int the language may not permit such a transformation i.e. a compile time error or a run time error may be thrown .

A system and method is disclosed for efficient and expansive conversions between primitive and reference types. A tool capable of generating executable instructions such as a compiler or an interpreter for a programming language that supports primitive data types and reference data types is configured to receive source code for a program. For an operation included in the source code for which type conversion is permitted for at least one operand the tool determines a source type of the operand and a target type to which the operand is to be converted. In response to determining that the source type is a reference type and the target type is a primitive type the tool generates a set of instructions to a determine at run time in accordance with a class definition of the reference type whether a value of the target primitive type can be obtained via one or more method invocations on the operand b if such a value can be obtained obtain the value and assign the value to the result of the operation and c if such a value cannot be obtained generate an error indication. In embodiments where the tool comprises a compiler the generated instructions are stored in an executable version of the program in embodiments where an interpreter is used the instructions may be executed upon generation without being stored in a persistent executable version of the program. In some embodiments to determine whether the value of the target primitive value can be obtained the tool may generate instructions to determine whether the run time class of the operand is a wrapper class designed to encapsulate a primitive value.

In one embodiment if the tool determines that the source type is a primitive type and the target type is a reference type the compiler may generate a set of instructions to a obtain at run time using the operand as a parameter an object of a wrapper class corresponding to the primitive type b perform a numeric conversion operation supported by the wrapper class to obtain an intermediate primitive value of a different primitive type encapsulated by the target type and c perform a boxing operation to obtain an object of the target type from the intermediate primitive value.

According to some embodiments if the tool determines that the source type is a reference type and the target type is also a reference type the tool may generate a set of instructions to implement a sequence of operations to obtain an object of the target type from the operand wherein the sequence comprises one or more of a reference to primitive conversion an unboxing operation a primitive to reference conversion a boxing operation or a numeric value extraction operation.

While the invention is described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description hereto are not intended to limit the invention to the particular form disclosed but on the contrary the invention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. Any headings used herein are for organizational purposes only and are not meant to limit the scope of the description or the claims. As used herein the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to.

It is noted that while much of the following description refers to the use of a compiler for various type conversion operations similar operations may be performed in some embodiments by a different tool such as an interpreter. For example an interpreter may consume source code as input just as a compiler does and generate executable instructions implementing similar logic as described below with respect to a compiler. In cases where an interpreter is being used the generated instructions may be executed forthwith and may not be stored in a persistent form e.g. as an executable version of the source program as they typically would be if a compiler were used. The kinds of errors thrown when conditions such as an attempt to perform an unsupported conversion are encountered and the error messages provided may differ in some cases between the compiler and the interpreter. In various embodiments the kinds of type conversions described below may be considered as functions on a the static type of a source expression b the static type of a target variable and c the dynamic type of the source expression. In embodiments where a compiler is used the term static may be translated as known at compile time however in embodiments where a different tool is being used the term static can be generalized to mean known prior to execution . The involvement of a dynamic type implies that conversion can only be effected by a tool emitting operations that are to be performed at runtime. An interpreter e.g. for Java source code may actually have an advantage over a compiler in some cases since it not only knows the static source and target types but also the dynamic type of the source expression. Such an interpreter may perform at runtime the same operations to effect conversion which a compiler would have emitted.

According to the illustrated embodiment the workflow begins when a compiler implementing type conversion functionality such as compiler receives source code for a computer program such as files . In various embodiments source code may be specified in various high level and or object oriented programming languages such as Java and or other languages. Source code may be provided as a set of .java files in embodiments where Java is being used. In some embodiments source code may be specified using a combination of languages which may include one or more low level and or intermediate languages e.g. assembly . In some embodiments at least some of the source code may initially be written in a dynamically typed high level language such as Python or Ruby while in other embodiments all of the source code may be in a statically typed language such as Java .

The compiler may analyze the source code to produce an executable version of the program such as bytecode files e.g. .class files or .jar files in the case of Java in the depicted embodiment. Different types of executable code formats may be used in various embodiments for example binary machine language may be used instead of bytecodes. In some scenarios parts of the executable code may be in bytecode while others are in a native binary machine language. As part of compiling program source code into executable code the compiler may perform a sequence of analysis operations and generate various intermediate data structures before generating the executable version as described below in further detail with reference to . The compiler may for example identify various data type conversion operations such as cast operations determine the source and target types of the conversions and decide based on the static source and target types that can be determined at compile time whether a compile time error should be generated. If a given conversion operation is determined to be acceptable for compilation appropriate code may be generated for it. Depending on the run time behavior of the program i.e. exactly which objects of which types are instantiated during execution even if a conversion is successfully compiled a run time exception may still be generated in some cases as described below in further detail.

As illustrated in executable code may be passed to an execution environment such as run time environment which executes the code on an execution platform thereby creating various output data and or behavior. In various embodiments the run time environment may include a virtual machine e.g. a Java Virtual Machine or JVM . The virtual machine may in turn comprise a number of different components such as a memory manager which may include a garbage collector a bytecode verifier to check the validity of the executable code an interpreter and or a just in time JIT compiler such as the HotSpot compiler. The JIT compiler may in some embodiments be responsible for translating some or all of the bytecode for example heavily used portions of bytecode into platform specific machine code to improve performance of the program execution. A run time environment such as the Java Runtime Environment or JRE may also include code to implement a number of application programming interface API libraries in some embodiments. The run time environment may run on top of lower level software such as an operating system in some embodiments. In embodiments where virtualized compute resources are being used as the execution platform virtualization software such as a hypervisor may be used to configure the execution platform for the operating system i.e. the operating system may run as an application on top of the hypervisor .

In different embodiments the output or behavior produced as a result of the execution of the compiled code may include data stored in various levels of system memory e.g. in memory objects and or data structures on persistent storage e.g. files on a file system etc. The behavior may also include various program functionalities such as displaying output on a screen sending messages over a network and or otherwise interacting with various users and or components.

According to the illustrated embodiment compiler may include lexical analyzer which may be configured to break the input source code into tokens such as tokens . Each token may correspond to a single atomic unit of the given language such as keywords identifiers etc. In various embodiments the token syntax may be represented as a regular language. Compiler may include preprocessor in the depicted embodiment which may be used to support macro substitution in some languages. In some embodiments preprocessor may modify various ones of tokens which may result in a set of modified tokens such as .

Compiler may also include a syntactic analyzer in some embodiments which may be configured to parse the modified tokens to identify syntactic structure of the input program. The syntactic analyzer may be configured to build a parse tree such as parse tree which may organize the tokens into a tree structure according to the formal grammar of the programming language of the source code.

In the depicted embodiment the compiler may further include a semantic analyzer which may be configured to add semantic information to parse tree to create an annotated internal representation of the program such as intermediate representation . In some embodiments a code generator such as code generator may convert the intermediate representation into an executable program such as . Executable program may be encoded in binary and or bytecode and may correspond to executable code in .

In some embodiments semantic analyzer may also build and or maintain a symbol table such as symbol table which maps various symbols in the source code to associated information such as the location scope and or type. The semantic analyzer may also include a type checker such as type checker to perform type checking functions e.g. to determine whether a conversion operation between a particular source type and target type is acceptable. If the type checker determines that a conversion operation is unacceptable a compile time error may be generated and at least in some embodiments the compilation may fail. In some instances warnings may be generated for certain types of operations instead of or in addition to compile time errors. For example in some implementations if a conversion is attempted that may result in some loss of precision of a numeric value a warning may be generated even though the operation may be permitted and the program compiled. In some embodiments the compiler may support special flags such as Xlint to enable the generation of a larger set of warnings than would otherwise be generated. In various embodiments different components of compiler shown in may be combined or further deconstructed into multiple components. The compiler may also implement various additional types of functions such as optimization line reconstruction and the like not shown explicitly in in some embodiments.

In the embodiment depicted in the supported primitive types include boolean byte short int long float double and char. Other primitive types may be supported in different embodiments and or some of the depicted primitive types may not be supported. A boolean primitive may use just one bit and the possible range of its values may be limited to true and false . Four primitives to store integral i.e. non fractional numeric values may be supported byte short int and long taking up one two four and eight bytes respectively. As indicated by the range shown in for each integral primitive type the larger primitive integral types may logically include the smaller ones. For example every possible int value may be represented as a long value every short value may be represented by an int or a long and so on. Accordingly as described below it may be fairly straightforward for a compiler or an interpreter to convert or cast an int to a long in some embodiments using what may be termed a widening conversion herein such a conversion or cast may simply involve setting some of the bits of the larger primitive value to zero. Narrowing conversions on the other hand where a source primitive value such as a long is converted into a target primitive value that uses less space such as an int may involve some loss of precision or information as also described below. Floats four bytes or doubles eight bytes may be used for numerical values that are not whole integers i.e. contain some fractional components . Char primitives may use two byes to store character values defined in some character encoding set such as UTF 16 the 16 bit Unicode Transformation Format character encoding standard .

A widening primitive conversion may be defined as a conversion in which in general the target type has a wider range of supported values than the source type. For example short s . . . int i s is a widening primitive conversion from a 16 bit short value to a 32 bit int value. . In widening conversions between the integral primitive types byte short int or long no information may be lost i.e. the numeric value of the source may be preserved exactly. Some other widening primitive conversions such as int to float may result in loss of precision i.e. the result may lose some of the least significant bits of the value and the result may be rounded according to some standard such as the IEEE 754 floating point standard.

A narrowing primitive conversion such as conversion of an int to a short may be defined as a conversion in which in general the source type has a wider range of supported values than the target and less space is available for the target value than was available for the source value. As a result a narrowing conversion may result in a loss of information about the magnitude of the numeric value of the source loss of precision of the numeric value a reduction in range of supported values or some combination of these effects.

It is noted that some non standard rules may apply in the case of a few primitive to primitive conversions especially for char primitives based on the language specification e.g. the conversion from a byte to a char may involve a widening of the byte to an int followed by a narrowing of the int to a char as indicated by the notation w n in and conversions between short values and char values may be defined as narrowing conversions in both directions despite the fact that both primitive types use two bytes. The kinds of primitive to primitive conversions illustrated in may serve as building blocks for other kinds of conversions involving reference types as described below in further detail.

In at least some embodiments the instruction set of the bytecode or machine code generated from the source code may include instructions for direct conversions between some or all of the primitive types e.g. an i2b instruction usable to convert an int to a byte or a d2i instruction usable to convert a double to an int . Such direct conversion instructions may be used to generate the code for various types of conversion operations not just primitive to primitive conversions in some embodiments. In other embodiments the instruction set may not include direct conversion instructions and the compiler or interpreter may have to generate code for type conversion operations using more basic instructions supported by the instruction set such as various arithmetic and logic instructions.

Some object oriented languages may define a set of wrapper reference types to encapsulate primitive values as class objects e.g. to allow the use of language features that are typically available only for objects like various types of Collection functionality . For example the Java language defines the following wrapper classes i.e. wrapper reference types defined as classes in the java.lang package Byte Short Character Integer Long Float and Double for the primitive types byte short char int long float and double respectively. The wrapper class Boolean is also defined for primitive type boolean however conversions to or from these two types are not explicitly discussed below. The following two statements illustrate the difference between a primitive data type and an object of a wrapper class 

The statement in line 1 declares an int variable named x and initializes it with the value 25. The second statement instantiates an Integer object on the heap initialized with the value 33. A reference or pointer to that heap object is assigned to the object variable y. Conversion of a primitive value to an object of the corresponding wrapper type may be referred to as boxing the primitive value and the extraction of the primitive value from an object of the corresponding wrapper class may be referred to as unboxing the wrapper. One or more unboxing class methods may be supported for a given wrapper class in some embodiments e.g. the intValue method for an Integer may return an int representing the numerical value of an Integer object. For numeric wrapper types i.e. wrapper types other than Boolean or Character unboxing class methods may be available to obtain primitive values for all the other numeric primitive types in some embodiments e.g. the Integer class may support byte Value shortValue long Valued floatValue and doubleValue methods in addition to intValue . These methods may be used for reference to primitive conversions in some embodiments as described below with reference to and may be referred to collectively as value extraction methods or as the Value methods herein.

To help simplify programming and reduce the potential program clutter induced by explicit boxing and unboxing operations in some embodiments the object oriented language may support automating the process of boxing and unboxing. Such autoboxing auto unboxing support may for example result in the following being considered legal statements int y 3 Integer z y or Integer k new Integer 56 int l k . Some of the kinds of reference to primitive or primitive to reference conversions described below may use boxing and or unboxing operations in various embodiments. As noted above data type conversions may be supported in several different contexts in various programming languages. Some kinds of conversions may be considered safer than others e.g. with respect to possible loss of information and may be supported in more different contexts than other conversions that are deemed less safe . For example because a widening primitive to primitive conversion like byte to int does not as long as it is implemented correctly involve possible information loss it may be permitted in several contexts and may not be limited to casting operations. Similarly the techniques described below for implementing widening primitive to reference conversions such as byte to Integer conversions may allow such conversions to be supported in several different contexts in some embodiments. In contrast a narrowing primitive to primitive conversion such as int to byte may be considered unsafe due to the possibility of information loss and as a result may be limited to contexts such as explicit casting operations where the programmer has to acknowledge the danger of possible loss if information. Similar logic may also restrict the contexts in which narrowing primitive to reference conversions such as Integer to byte conversions described below are allowed in some embodiments.

The following symbols are used in to indicate the different types of conversions u for an unboxing conversion NN for narrowing reference to primitive conversion WW for a widening reference to primitive conversion w for a widening primitive to primitive conversion and r for a narrowing reference reference conversion. With respect to reference to primitive conversions a conversion may be termed narrowing if in general the unboxed primitive type corresponding to the source has a wider range of supported values than the target and less space is used for the target than would be used for the unboxed primitive value of the source such as in the case of a Long to int conversion. Similarly a reference to primitive conversion may be termed widening if in general the unboxed primitive type corresponding to the source has a narrower range of supported values than the target and more space is used for the target than would be used for the unboxed primitive value of the source such as in the case of an Integer to long conversion. The Character to short conversion and the Short to character conversions may be deemed narrowing even though the values of both of the corresponding primitives may be stored using two bytes. A narrowing reference to reference conversion may for example represent a conversion from a supertype to a subtype. In the illustrated embodiment the NN conversions may preserve the numeric value of the reference source object when possible.

In order to implement the NN conversions shown in efficiently in some embodiments the compiler or interpreter may take advantage of support provided in the language to determine whether a particular expression with static type Object represents a runtime object of one of the wrapper types discussed above and if so whether it represents a Character wrapper type or a numeric wrapper type. Consider the following source code as a generic example of a reference to primitive conversion that may require an NN conversion 

In at least some such embodiments the bytecode or machine code generated for the above reference to primitive conversion or for similar conversions in other contexts than casts such as method invocation or assignment may be logically equivalent to the following high level code 

In the above example the compiler or interpreter may first determine whether the source type is a reference type i.e. that the source type is not a primitive type and then generate code to determine more details about exactly what types of values can be extracted from the source. As indicated in the high level code snippet above the compiler or interpreter may generate code to determine whether a primitive value of the target data type can be obtained using one of the other supported conversion operators such as in the case of the numeric wrapper source types the intValue shortValue and other Value or value extraction methods available and in the case of a Character reference type the char to primitive conversions shown in . Common bytecode implementing the logic shown in the above code may be shared for a plurality of the NN conversions shown in in some embodiments instead of using different logic specific to each of the wrapper types. As shown in lines 20 and 23 the generated code may still throw an exception if it is determined at run time that a meaningful primitive value cannot be extracted from the source expression of the conversion operation. It is noted that although the source code snippet shown above uses the Number superclass of the numeric wrapper classes the use of such a superclass is not a requirement e.g. in some embodiments instead of generating code for the Number based if clause in lines 10 and 13 code for separate if clauses for each of the numeric wrapper classes could be generated such as if o.instanceOf javalang.Integer target Integer o.PValue else if o.instanceOf java.lang.Long target Long o.PValue and so on. It is also noted that although the value extraction methods in the example are shown as being offered by the wrapper classes in lines 13 and 18 such value extraction methods do not necessarily have to be offered by the wrapper classes themselves e.g. value extraction methods provided by a utility class and not by a wrapper class may be used in some embodiments.

The u w conversions shown above the diagonal in may be easier to implement than the NN conversions in that once a primitive value is obtained by unboxing it may straightforward to then use the w conversions of to obtain the desired target primitive value. The WW NN Byte to char conversion may be analogous to the special case w n byte to char conversion of .

The bottom row of represents four possibilities for conversions from expressions of static e.g. compile time in environments where a compiler is being used type Object to a primitive target type for some embodiments. It is noted that especially in cases where source code is in a dynamically typed language such as Ruby or Python the static or compile time type of a substantial number of the objects being dealt with may default to general object types that is the type of the objects may only become clear at run time. If the run time type of the source is numeric or Character and exactly matches the primitive target type e.g. in a case similar to byte new Byte 42 a narrowing reference conversion may be followed by unboxing. If the run time type of the source object is numeric or Character and does not match the primitive target types exactly such as in the examples byte new Integer 42 the NN conversion may be implemented using the logic described above in the example code that uses isPrimitive and instanceOfjava.lang.Number . In the special case of a conversion from Byte to char a WW NN conversion involving both widening and narrowing may be used. Finally if the run time type of the source object is not numeric or Character a ClassCastException or some other run time error may result. It is noted that Boolean reference to primitive conversions may also be supported in some embodiments although Boolean is not listed among the wrapper types of .

Consider as an example the following primitive to reference cast operation the nn case since this is a conversion from an int to a Short 

To implement the requested conversion from the int primitive to the Short reference type a compiler or an interpreter could in some embodiments generate code to do the following a converting the int to an Integer b extracting the short primitive value of the Integer e.g. using the shortValue class method available for Integers and then c boxing the short value to a Short object. E.g. code to perform the logical equivalent of the following may be generated 

It is noted that the three conversion operations illustrated separately above may also be accomplished by a single line of high level code such as Short s Short.shortValue Integer.valueOf i .shortValue . A similar three step approach boxing to obtain a wrapper corresponding to the source primitive operand followed by value extraction of the primitive type that can be wrapped by the target reference type followed by boxing to the target reference type may be used for ww widening conversions in some embodiments.

Given support for the different primitive to reference conversions illustrated in and support for the different reference to primitive conversions illustrated in numerous reference to reference conversions may be enabled in some embodiments. For example a cast from a Short to an Integer may be accomplished using any of the following approaches a Short to int conversion as in followed by int to Integer boxing b Short to short unboxing followed by short to Integer conversion as in c Short to short unboxing followed by short to int conversion as in followed by int to Integer boxing or d integer value extraction using the Short.intValue method followed by int to Integer boxing. The specific choice as to which combination of operators among these types of choices is used by the compiler or interpreter for reference to reference conversions may differ from one implementation to another. The set of composite conversions between various reference types may be represented as commutative diagrams in some embodiments in which the vertices represent the types and the edges represent the conversions. Some of the conversion paths in such a diagram may have alternative implementations of the same functionality from which one may be selected in a given embodiment or implementation the conversion function in a mathematical sense may be separated from its implementation. It is also noted that in various embodiments the different conversion tables shown in and may not have some of the illustrated structural properties such as symmetry around the diagonal of a given table or a 1 1 correspondence between the reference to primitive conversion table of and the primitive to reference conversion table or . That is in some embodiments only a subset of the conversions illustrated may be supported.

In the source reference target primitive case as detected in element the tool may generate code for the conversions illustrated in . Executable code e.g. in the bytecode for the language in which the program is written and or in machine code may be generated for the high level operations illustrated in in some embodiments as shown in element of . In the source primitive target reference case as detected in element code may be generated for the conversions illustrated in corresponding to the high level operations illustrated in in the depicted embodiment as indicated in element .

If the conversion is a reference to reference conversion between source type S and target type T of one of the supported kinds indicated above as determined in element code may be generated in a number of different ways involving different combinations of unboxing boxing value extractions using the Value value extraction methods and so on as discussed above. Examples of the high level operations for these choices for which corresponding executable code may be generated are shown in as indicated in element of . If the conversion is primitive to primitive code may be generated corresponding to the different operations illustrated in element . In embodiments where a compiler is being used the generated code may be stored in an executable file as shown in element and may be executed at an execution platform as described above with reference to .

If code generated for isPrimitive or its equivalent returns a true result there may be three further possibilities regarding the type of the source. If the source is an instance of one of the numeric wrapper types such as Byte Short Integer Long Float or Double as determined in code generated for element the target primitive value may simply be extracted using code for the appropriate value extraction method e.g. intValue for int shortValue for short and so on element . If the source is an instance of the Character wrapper type as detected in code generated corresponding to element code may be generated to first extract the char value of the source e.g. using the equivalent of a charValue method as shown in element of . The char value may then be converted to the target primitive type using code generated for the appropriate primitive to primitive conversion e.g. one of the conversions shown in the char row of as indicated in element . The third and final scenario if isPrimitive or its equivalent returns true is that the source is of type Boolean in which case a run time error or exception may be generated element reached from No branch out of element . It is noted that depending on the tool being used the generated code for the operations shown may either be stored for later execution e.g. if a compiler is being used or may be executed immediately e.g. if an interpreter or just in time compiler is being used .

If the target type is one of the wrapper types code may be generated to obtain a wrapped object from the primitive source value e.g. an Integer if the source is an int a Short if the source is a short and so on element . If the source is int i for example the wrapped object may be obtained using the code for the equivalent of Integer tempinteger Integer.valueOf i . Then using code for the appropriate Value value extraction method for the wrapper object so obtained an intermediate primitive value of a primitive type that can be wrapped to obtain an object of the target type may be obtained element . For example if the target reference type is Short code may be generated in the above example for the following short tempShort tempInteger.shortValue . Finally code may be generated to box the primitive obtained from the Value method to the target type of the conversion e.g. code for Short s Short.shortValue tempShort may be generated in the example scenario of converting an int to a Short.

In the embodiment depicted in a tool such as a compiler or interpreter may choose one of the four approaches Ref prim box Unbox prim prim box Unbox prim ref and GetValue box and generate code according to the chosen approach. It is noted that in some embodiments the tool may be configured to support just one of the approaches i.e. the tool may not need to explicitly choose among more than one approach and that in other embodiments a subset of the four approaches may be implemented.

If the Ref prim box approach is taken element code may be generated to first convert the source of type S to a primitive value of type t e.g. using the reference to primitive conversion techniques described earlier element and then to box the primitive value t to the target reference type T element . If the Unbox prim prim box approach is taken element code may be generated to first unbox the source of type S to a primitive value of type s element followed by a primitive to primitive conversion to type t element followed by a box to type T element .

If the Unbox prim ref approach is taken element code may be generated to first unbox the source of type S to a primitive value of type s element followed by a primitive to reference conversion to type T element . If the GetValue box approach is taken the code may be generated to first use the equivalent of a value extraction method to obtain a primitive value of type t element followed by a boxing of the primitive value to type T element .

At least in some embodiments more or different approaches may be feasible for reference to reference conversions than those shown in using various combinations of the primitive to primitive primitive to reference and reference to primitive conversion techniques described earlier. In some embodiments the instruction set for the bytecode or machine code to which the source code is compiled may include instructions for direct conversions of some or all of the primitive types e.g. an i2b instruction usable to convert an int to a byte or a d2i instruction usable to convert a double to an int which may be used by a compiler or an interpreter to generate the code for various types of conversion operations included in the source code. In at least one embodiment new bytecode instructions may be added to the bytecode instruction set specifically for the purpose of facilitating the different types of conversions described herein.

In various embodiments computing device may be a uniprocessor system including one processor or a multiprocessor system including several cores or processors e.g. two four eight or another suitable number . Processors may be any suitable processors capable of executing instructions. For example in various embodiments processors may be general purpose or embedded processors implementing any of a variety of instruction set architectures ISAs such as the SPARC x86 PowerPC or MIPS ISAs or any other suitable ISA. In multiprocessor systems each of processors may commonly but not necessarily implement the same ISA.

System memory may be configured to store program instructions implementing a compiler an interpreter source code of various programs to be compiled executable code generated by the compiler or other compilers and an execution environment similar to runtime environment of . System memory may also include program instructions and or data for various other applications. Program instructions may be encoded in platform native binary any interpreted language such as Java bytecode or in any other language such as C C Java etc. or in any combination thereof. In various embodiments system memory may be implemented using any suitable memory technology such as static random access memory SRAM synchronous dynamic RAM SDRAM nonvolatile Flash type memory or any other type of memory.

In one embodiment I O interface may be configured to coordinate I O traffic between processor system memory and any peripheral devices in the device including network interface or other peripheral interfaces. In some embodiments I O interface may perform any necessary protocol timing or other data transformations to convert data signals from one component e.g. system memory into a format suitable for use by another component e.g. processor . In some embodiments I O interface may include support for devices attached through various types of peripheral buses such as a variant of the Peripheral Component Interconnect PCI bus standard or the Universal Serial Bus USB standard for example. In some embodiments the function of I O interface may be split into two or more separate components such as a north bridge and a south bridge for example. Also in some embodiments some or all of the functionality of I O interface such as an interface to system memory may be incorporated directly into processor .

Network interface may be configured to allow data to be exchanged between computing device and other devices attached to a network or networks for example. In various embodiments network interface may support communication via any suitable wired or wireless general data networks such as types of Ethernet network for example. Additionally network interface may support communication via telecommunications telephony networks such as analog voice networks or digital fiber communications networks via storage area networks such as Fibre Channel SANs or via any other suitable type of network and or protocol.

In some embodiments system memory may be one embodiment of a computer accessible medium configured to store program instructions and data as described above for for implementing embodiments of the corresponding methods and apparatus. However in other embodiments program instructions and or data may be received sent or stored upon different types of computer accessible media. Generally speaking a computer accessible medium may include non transitory storage media or memory media such as magnetic or optical media e.g. disk or DVD CD coupled to computing device via I O interface . A non transitory computer accessible storage medium may also include any volatile or non volatile media such as RAM e.g. SDRAM DDR SDRAM RDRAM SRAM etc. ROM etc. that may be included in some embodiments of computing device as system memory or another type of memory. Further a computer accessible medium may include transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as a network and or a wireless link such as may be implemented via network interface . Portions or all of multiple computing devices such as that illustrated in may be used to implement the described functionality in various embodiments for example software components running on a variety of different devices and servers may collaborate to provide the functionality. In some embodiments portions of the described functionality may be implemented using storage devices network devices or special purpose computer systems in addition to or instead of being implemented using general purpose computer systems. The term computing device as used herein refers to at least all these types of devices and is not limited to these types of devices.

Various embodiments may further include receiving sending or storing instructions and or data implemented in accordance with the foregoing description upon a computer accessible medium. Generally speaking a computer accessible medium may include storage media or memory media such as magnetic or optical media e.g. disk or DVD CD ROM volatile or non volatile media such as RAM e.g. SDRAM DDR RDRAM SRAM etc. ROM etc. as well as transmission media or signals such as electrical electromagnetic or digital signals conveyed via a communication medium such as network and or a wireless link.

The various methods as illustrated in the Figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software hardware or a combination thereof The order of method may be changed and various elements may be added reordered combined omitted modified etc.

Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended to embrace all such modifications and changes and accordingly the above description to be regarded in an illustrative rather than a restrictive sense.

