---

title: Application programming interface tracing mechanism
abstract: Example systems and methods of providing an application programming interface tracing mechanism are presented. In one example, an application programming interface for an application is provided, the interface including an interface object. A proxy object is created for the interlace object. At the proxy object, method calls from the application for the interface object are received, recorded, and passed to the interface object. An execution trace including the recorded method calls is generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09489179&OS=09489179&RS=09489179
owner: Business Objects Software Ltd.
number: 09489179
owner_city: Dublin
owner_country: IE
publication_date: 20120308
---
Software developers typically invest many hours testing each section or module of software they develop to help ensure that the software will operate as expected without generating errors faults or other execution maladies. Such testing may include tests executed at the object module and application level within a development environment such as that provided by way of an integrated development environment facilitating the writing testing debugging and revision of software.

However despite attempts to deliver error free software to the user untested or unanticipated uses of the software may cause problems to occur. To detect sources of errors in such cases some software provides a tracing mode in which the execution path of the software is recorded for subsequent perusal by software developers or maintenance personnel. By reviewing the resulting trace which is often provided in a log file or similar data structure the developer may determine the cause of the error and revise the software to eliminate it. In some cases parameters and return values associated with methods or functions may be added to the log file to provide useful information to the developer.

To provide the tracing information developers typically add instructions to each method or function of interest to store the data to the tracing log file. In addition these additional instructions may be executed only under the condition that tracing functionality is enabled. In many implementations a user of the software may enable the tracing functionality by way of an additional input when the user initiates execution of the software.

One alternative to the typical tracing implementation described above is the use of aspect oriented programming by which a special compiler may inject additional code into the software to provide instructions for the tracing function. Some implementations of such an alternative however may be difficult to implement in large professional production software suites that are compiled using standard compilers. Also allowing a user to enable or disable tracing functionality at runtime and applying such tracing to only specific user sessions may not be possible with some compilers.

The description that follows includes illustrative systems methods techniques instruction sequences and computing machine program products that embody illustrative embodiments. In the following description for purposes of explanation numerous specific details are set forth in order to provide an understanding of various embodiments of the inventive subject matter. It will be evident however to those skilled in the art that embodiments of the inventive subject matter may be practiced without these specific details. In general well known instruction instances protocols structures and techniques have not been shown in detail.

At least some of the embodiments described herein provide various techniques for tracing an object oriented application programming interface API being accessed by an application. Examples of object oriented languages employable for producing the API and the tracing mechanism include ABAP Advanced Business Application Programming by SAP AG Java by Sun Microsystems Inc. and others. In general the tracing is facilitated by the creation and use of one or more proxy objects that encapsulate or otherwise hide one or more objects of the API. The proxy objects facilitate tracing by for example recording method calls for later analysis and testing of the API and or application. Described below are two different techniques for generating the proxy objects named temporary encapsulation and permanent encapsulation. Any particular tracing mechanism according to the embodiments discussed herein may employ temporary encapsulation permanent encapsulation or some combination thereof depending on the structure of the API the needs of the software developers of the API or application and other factors. Other aspects of the embodiments discussed herein may be ascertained from the following detailed description.

Turning specifically to the enterprise application platform web servers and application program interface servers are coupled to and provide web and programmatic interfaces to application servers . The application servers are in turn shown to be coupled to one or more database servers that may facilitate access to one or more databases . The web servers application program interface servers application servers and database servers may host cross functional services . The application servers may further host domain applications .

The cross functional services may provide user services and processes that utilize the enterprise application platform . For example the cross functional services may provide portal services e.g. web services database services and connectivity to the domain applications for users that operate the client machine the client server machine and the small device client machine . In addition the cross functional services may provide an environment for delivering enhancements to existing applications and for integrating third party and legacy applications with existing cross functional services and domain applications . Further while the system shown in employs a client server architecture the present disclosure is of course not limited to such an architecture and could equally well find application in a distributed or peer to peer architecture system.

The portal modules may enable a single point of access to other cross functional services and domain applications for the client machine the small device client machine and the client server machine of . The portal modules may be utilized to process author and maintain web pages that present content e.g. user interface elements and navigational controls to the user. In addition the portal modules may enable user roles a construct that associates a role with a specialized environment that is utilized by a user to execute tasks utilize services and exchange information with other users and within a defined scope. For example the role may determine the content that is available to the user and the activities that the user may perform. The portal modules may include in one implementation a generation module a communication module a receiving module and a regenerating module. In addition the portal modules may comply with web services standards and or utilize a variety of Internet technologies including but not limited to Java J2EE SAP s Advanced Business Application Programming ABAP Language and Web Dynpro XML JCA JAAS X.509 LDAP WSDL WSRR SOAP UDDI and Microsoft .NET.

The relational database modules may provide support services for access to the database that includes a user interface library. The relational database modules may provide support for object relational mapping database independence and distributed computing. The relational database modules may be utilized to add delete update and manage database elements. In addition the relational database modules may comply with database standards and or utilize a variety of database technologies including but not limited to SQL SQLDBC Oracle MySQL Unicode and JDBC.

The connector and messaging modules may enable communication across different types of messaging systems that are utilized by the cross functional services and the domain applications by providing a common messaging application processing interface. The connector and messaging modules may enable asynchronous communication on the enterprise application platform .

The application program interface API modules may enable the development of service based applications by exposing an interface to existing and new applications as services. Repositories may be included in the platform as a central place to find available services when building applications.

The development modules may provide a development environment for the addition integration updating and extension of software components on the enterprise application platform without impacting existing cross functional services and domain applications .

Turning to the domain applications customer relationship management applications may enable access to and facilitate collecting and storing of relevant personalized information from multiple data sources and business processes. Enterprise personnel that are tasked with developing a buyer into a long term customer may utilize the customer relationship management applications to provide assistance to the buyer throughout a customer engagement cycle.

Enterprise personnel may utilize financial applications and business processes to track and control financial transactions within the enterprise application platform . The financial applications may facilitate the execution of operational analytical and collaborative tasks that are associated with financial management. Specifically the financial applications may enable the performance of tasks related to financial accountability planning forecasting and managing the cost of finance.

Human resources applications may be utilized by enterprise personnel and business processes to manage deploy and track enterprise personnel. Specifically the human resources applications may enable the analysis of human resource issues and facilitate human resource decisions based on real time information.

Product life cycle management applications may enable the management of a product throughout the life cycle of the product. For example the product life cycle management applications may enable collaborative engineering custom product development project management asset management and quality management among business partners.

Supply chain management applications may enable monitoring of performances that are observed in supply chains. The supply chain management applications may facilitate adherence to production plans and on time delivery of products and services.

Third party applications as well as legacy applications may be integrated with domain applications and utilize cross functional services on the enterprise application platform .

Additionally collaborative applications may facilitate joint creation and modification of documents and other work product by multiple users and data management applications may enable data organization and other management functions to be performed on data generated by one or more other domain applications .

The API library may define one or more object oriented classes by which objects of the API may be created. The created API objects may include methods available for use by an external application to access the various domain applications provided in the enterprise application platform . As described more fully below the use of the API objects by the external application may be traced to allow analysis of the functioning of the API and the use of the API by the external application. The API objects may be structured such that the external application need only access one or a few root API objects directly to perform its desired functions. In this example the external application may access other API objects via the root API objects. In other cases a significant number of API objects may be accessible to the application directly. Also some API libraries may be designed to allow only one way calls of API methods from the external application while other API libraries may include objects that call methods of the external application thus facilitating a two way calling environment. Such an environment facilitates eventing in which the API may asynchronously alert the external application to an event detected by the API. In some implementations the design or structure of the API may be considered in determining how the tracing of the API is best implemented.

The proxy object generation module may generate or create the one or more proxy objects responsible for recording method calls and other information involving the use of the API. In one example the API library may include or make reference to the proxy object generation module to facilitate the creation of the proxy objects in response to the creation of one or more of the API objects. In another example the functionality of the proxy object generation module may be incorporated into one or more of the API classes such that a call to a constructor method for an API object may result in the creation of the both the intended API object and its corresponding proxy object. Other implementations of the proxy object generation module are also possible.

The execution trace generation module may receive the recorded method calls and other related information from the one or more proxy objects created via the proxy object generation module and generate a trace data structure such as the trace file . In one example the trace file may be a human readable e.g. textual sequential listing of the various method calls made to the API possibly along with parameters and return values associated with those calls. Other information that may be recorded by the proxy objects may also be included. In another example the execution trace generation module may generate a trace file that includes machine executable or machine interpretable information such as a sequence of method calls and associated data that may be executed by the test execution module to recreate the recorded execution of the API.

For each of the at least one of the interface objects provided a proxy object is created operation such as via the proxy object generation module . Each of the proxy objects is configured to receive one or more method calls for the interface object corresponding to the proxy object record the received method calls and pass the received method calls to the corresponding interface object. As is described in greater detail below the generation of the proxy objects as well as how the proxy objects are employed may depend on the nature of the API library the preferences of the software developer and other factors.

Continuing with the method the execution trace generation module may generate an execution trace operation such as the trace file also . The text execution module may then perform a test of the API using the execution trace operation .

While the operations through of the method of are shown in a specific order other orders of operation including possibly concurrent execution of at least portions of one or more operations may be possible in some implementations. For example the interface objects and their associated proxy objects may be created concurrently in some implementations. Further the generation of the execution trace may occur concurrently with the recording of the method calls performed by the proxy objects.

Also application code in using the API library may also create one or more interface API objects such as by way of a call to a constructor method associated with the interface object . Such an API object that is directly accessed by the application code may be considered an API root object . In response to the API root object being accessed in the application code such as by being provided as a return object to the application code a proxy object is created to encapsulate and reference the root API object . In addition other API objects that leave the API library such as by being a return value to the application code may each have a proxy object created for that API object . In one example these other API objects are accessed via a root API object in which case the proxy object for the root API object may be responsible for causing the creation of the proxy object for the other API objects leaving the API library via the root API object . Accordingly other API objects not accessed by or passed to the application code may not cause another proxy object to be created. As a result only root API objects and other API objects that are passed to the application code may be encapsulated by proxy objects . Any initialization and subsequent usage of the root API objects by the application code is then carried out through the proxy object .

After its creation each root API object and other API objects that may be passed to the application code may cause the generation of a corresponding session unique identifier object that identifies the API object . Further these API objects may be configured to reference both the session identifier object and its session unique identifier object . These two identifier objects and allow the API object as well as parameters provided to the API object to be identified for trace generation. The API object is chosen to reference the identifier objects and since the encapsulation of the API object by its proxy object is temporary in nature.

While the API object is being accessed in the application code all method calls including the provision of parameters to the API object and the receiving of a result from the API object are carried out through the proxy object . When the API object leaves the application code the proxy object may be removed and placed in a separate proxy object storage area such as a memory cache in case the proxy object for the API object is needed at a later time such as when the API object is again returned to the application code . In one example a cached proxy object may be retrieved using the session unique identifier for the associated API object . In some implementations the storage and retrieval of previously created proxy objects may be performed by a central cache manager. In one example the central cache manager functionality may be incorporated into the proxy object generation module . The use of a proxy object cache may facilitate faster processing of the proxy objects and reduced memory fragmentation due to the reduced amount of allocating and freeing of storage for the proxy objects .

In one implementation when the application code makes a method call through a proxy object when the proxy object is used as a parameter in a method call to a root API object or when the proxy object is otherwise being returned to the API library the corresponding API object replaces its proxy object . When the API object is then to be returned to the application code the session unique identifier object may be checked to determine if the session unique identifier object is registered as a proxy. If so the API object is replaced with its corresponding proxy object from the cache so that the proxy object is returned to the application code instead of the API object . If instead the session unique identifier object is not registered as a proxy a new proxy object is created for the API object and the new proxy object is returned to the application code .

As with the application code associated with the temporary encapsulation model the application code of the permanent encapsulation model generates a session identifier object . However in contrast to the temporary encapsulation mechanism of in which each root API object creates its own session unique identifier object each proxy object of the permanent encapsulation environment creates and references a session unique identifier object for its corresponding interface object . Each proxy object may then reference the session identifier object and its session unique identifier object directly since the proxy object remains throughout the existence of its corresponding interface object .

In both temporary encapsulation and permanent encapsulation each of the proxy objects and is created to record method calls from the application code and to the API object and corresponding to the proxy object and to generate an execution trace of the API. However given their basic differences temporary encapsulation and permanent encapsulation each exhibits its own strengths and weaknesses in terms of applicability and ease of use with respect to the structure of the API library being utilized. For example the use of temporary encapsulation may facilitate the generation of a relatively few proxy objects as only those API objects that are passed or returned to the application code are associated with proxy objects thus restricting the impact of tracing on the code development of the API library to those classes associated with API objects that may be accessed in the application code . Accordingly the proxy objects are not employed within the API library but only within the application code thus reducing the impact on performance while in tracing mode.

These positive aspects of temporary encapsulation may compare favorably to permanent encapsulation in which each created API object is encapsulated within its own proxy object with each proxy object being used throughout the lifetime of its corresponding API object . Thus permanent encapsulation may generally require more development time and impact performance more significantly than temporary encapsulation .

However permanent encapsulation is generally more robust than temporary encapsulation by providing greater protection against tracing fragmentation and program errors. As is described more completely below temporary encapsulation captures all method calls for an API with a clear internal external boundary with one or only a few gateways e.g. root API objects and in which method calls are only made from the application code to the root API objects . For example if the API library is configured to allow for callbacks from one or more of the API objects to the application code in addition to the calls from the application code to the API objects such calls may not pass through a proxy object and thus may not be recorded for tracing purposes. Permanent encapsulation helps protect against such problems by employing a proxy object for each API object thus reducing the possibility of an untraced callback from an API object to the application code .

Overall the choice between temporary encapsulation and permanent encapsulation affects several different aspects of program operation. One such aspect is object creation as mentioned above. In permanent encapsulation a proxy object is created in order to encapsulate each created API object and maintained throughout the lifetime of that object. In temporary encapsulation proxy objects are created only to encapsulate one or more root API objects directly accessible by the application code as well as other API objects passed to the application code via the root API objects thus reducing the number of proxy objects that are to be created. As a result such encapsulation automatically encapsulates all child API objects accessed via the one or more root API objects .

Another area impacted by the decision of temporary encapsulation or permanent encapsulation is the casting of objects by which a receiver of an object may cast the object to a different or more specific object type than that indicated by the object class. In permanent encapsulation all casts to more specific implementations between API objects are replaced with internal interfaces due to the presence of the proxy objects for every API object . Oppositely due to the lack of proxy objects between API objects in temporary encapsulation object casting does not cause significant problems.

Object comparison is another area which may be affected by the choice of encapsulation. In some examples object comparison in which one object may be compared to another for equality may be performed by way of pointers to the objects being compared or by way of a semantic equals comparison of the objects via their constituent members. In a one way API call environment in which the application code makes method calls into the API but the API is not making callbacks into the application code temporary encapsulation does not cause significant problems as every parameter object is replaced with its original API object as opposed to the proxy object associated with the API object . As a result the results of object comparison in the one way call environment are as expected when temporary encapsulation is employed. Using permanent encapsulation however the use of a proxy object for each API object causes problems with pointer based object comparisons since the pointer to the proxy object does not equal the pointer to its corresponding API object . One way to address this potential problem is to replace direct pointer comparisons in the API objects with the equals comparison method in the associated class and by replacing the parameters of the proxy object with its corresponding API object in the code implementing the equals comparison method.

A two way API call environment in which the API objects and may generate callbacks into the application code and such as for event propagation complicates the issue of equals comparisons. In permanent encapsulation each class of the API library capable of performing a callback to a method outside the API library may provide a method in which the corresponding proxy object can be set instead of using a pointer such as the this pointer of Java . In this example the proxy object may be set to its corresponding API object immediately after creation of the proxy object . As a result the API object is then using either the pointer during normal non tracing execution mode or its proxy object in tracing mode. For temporary encapsulation the application code may be rewritten to use the equals comparison method instead of the direct object pointer comparison method. Also the API library classes may be written to use overloaded comparison and hash methods used in classes to implement the equals comparison method using the object identifiers.

Regarding the object identifiers to be recorded for tracing purposes in permanent encapsulation the session unique identifier object and the session identifier object are referenced by the proxy object for its corresponding API object . As a result no additional information is needed for the proxy object as the proxy object is available throughout the lifetime of its API object . Accordingly the proxy object may also be employed to trace API objects from classes residing external to the API library . For temporary encapsulation the API object may directly provide its session unique identifier object and the session identifier object for tracing purposes since the API object is configured to reference those objects and due to the temporary nature of its associated proxy object . However facilitating this functionality may be costly to add at design time as well as memory intensive at runtime. In an alternative a mapping that maps string like identifiers to session unique identifier objects may reduce the amount of storage used to write read and maintain the session unique identifier objects . In one example the mapping may be performed by way of a fingerprint algorithm such as MD5 Message Digest Algorithm 5 or SHA 1 Secure Hash Algorithm 1 as a hash to generate the string like identifiers albeit with some possible performance penalty.

With respect to method invocation of the API object and the corresponding proxy object and may record the session unique identifier object and of the API object and the identity of the method being invoked possibly including a canonical name of the method in addition to the interface and associated signature and the parameter and return value involved either as atomic values or as references to other objects . For permanent encapsulation the proxy object routes the parameters and return value between the object invoking the method and the object executing the method. One possible exception to this rule is the equals comparison method in which the proxy object is replaced with its corresponding API object prior to the comparison being executed. For temporary encapsulation the return value from an API object is assigned a proxy object before being returned to the application code . Such a proxy object may either be newly created if the API object has not been previously assigned or be assigned the same proxy object to which it was previously assigned. In one example the previously assigned proxy object may be identified by the identifier of the API object and retrieved from a proxy object storage area of memory such as a cache. If the API object cannot be determined the tracing information associated with the method call may be marked as unresolved.

Given the various benefits and challenges associated with temporary encapsulation and permanent encapsulation and that these positive and negative aspects are dependent at least in part on the structure of the API library some implementations may employ a hybrid approach combining both temporary encapsulation and permanent encapsulation . For example most API objects and of the API library may be sufficiently traced by use of temporary encapsulation . However for those API objects and which are more important or that may provide a callback path to the application code and permanent encapsulation may be employed specifically for those API objects and . Other factors such as the amount of development time to be expended and the robustness of the tracing scheme desired may also be considered when determining whether to implement temporary encapsulation permanent encapsulation or some combination thereof.

As a result of the recording of the API method calls and associated data by the proxy elements and the execution trace generation module may use the recorded information to generate the trace file also . The trace file represents a reconstruction of the program flow associated with the application code and . Such a reconstruction may aid a developer in detecting and correcting problems with the software. In one example the trace file includes a standalone class having a method that defines the complete API calling sequence based on the recorded method call information. In this implementation the test execution module also may call the standalone method representing the trace to recreate the original program execution thus providing the developer with a way to recreate any problems that may have occurred during the original execution.

In many examples the recorded trace is extremely long and may include one or more gaps in the execution stream. In some cases one or more objects may not be trace enabled due to an error in the software. For example a parameter input for a called method may be missing or invalid causing the return value for that method to also be invalid thereby causing methods that use the invalid return value as a parameter to also be invalid all of which may complicate the ability to trace the execution flow correctly. In other instances optimization of code such as the removal of getter and similar methods providing return values that are ultimately not used may also cause problems in trace recording. In yet other cases parameters for some methods may be hidden in set or list containers which may also be copied in other containers and so on making object reconstruction for a trace difficult.

To address potential gaps in a trace a rescue point for each of one or more API objects and may be recorded when the API object and is created in one embodiment. In one example the rescue point may be a traced description of how the object of interest is to be reconstructed when a parent object of the object of interest is available. In one embodiment the reconstruction may be performed by calling a getter method provided by the parent object possibly using some constant parameter value to reconstruct the object of interest. By placing such a rescue point in the trace file for each object the execution trace generation module may use the rescue points to reduce or eliminate missing incomplete or unknown parameter objects that would otherwise cause gaps in the execution trace file .

In at least some embodiments discussed herein an API tracing mechanism that employs proxy objects for the recording of method calls and associated information is supported. One of two different techniques or some combination thereof of implementing the proxy objects may be employed to provide the most cost effective tracing capability for the particular API library structure involved. The addition of rescue points in the recorded information may also help prevent gaps that often occur in tracing information. Overall these techniques support multiple session environments and facilitate customer enabled tracing in a virtual machine executing on a production platform.

While the above discussion focuses on enterprise applications and platforms and their associated client systems any device executing software or firmware may benefit from application of the various principles described herein. For example the tracing techniques discussed above may be implemented in general purpose computing systems as well as in special purpose embedded systems such as cellular phones personal digital assistants PDAs computer tablets entertainment system components smart appliances gaming systems and so on.

The machine is capable of executing a set of instructions sequential or otherwise that specify actions to be taken by that machine. Further while only a single machine is illustrated the term machine shall also be taken to include any collection of machines that individually or jointly execute a set or multiple sets of instructions to perform any one or more of the methodologies discussed herein.

The example of the processing system includes a processor e.g. a central processing unit CPU a graphics processing unit GPU or both a main memory e.g. random access memory and static memory e.g. static random access memory which communicate with each other via bus . The processing system may further include video display unit e.g. a plasma display a liquid crystal display LCD or a cathode ray tube CRT . The processing system also includes an alphanumeric input device e.g. a keyboard a user interface UI navigation device e.g. a mouse a disk drive unit a signal generation device e.g. a speaker and a network interface device .

The disk drive unit a type of non volatile memory storage includes a machine readable medium on which is stored one or more sets of data structures and instructions e.g. software embodying or utilized by any one or more of the methodologies or functions described herein. The data structures and instructions may also reside completely or at least partially within the main memory the static memory and or within the processor during execution thereof by processing system with the main memory and processor also constituting machine readable tangible media.

The data structures and instructions may further be transmitted or received over a computer network via network interface device utilizing any one of a number of well known transfer protocols e.g. HyperText Transfer Protocol HTTP .

Certain embodiments are described herein as including logic or a number of components modules or mechanisms. Modules may constitute either software modules e.g. code embodied on a machine readable medium or in a transmission signal or hardware modules. A hardware module is a tangible unit capable of performing certain operations and may be configured or arranged in a certain manner. In example embodiments one or more computer systems e.g. the processing system or one or more hardware modules of a computer system e.g. a processor or a group of processors may be configured by software e.g. an application or application portion as a hardware module that operates to perform certain operations as described herein.

In various embodiments a hardware module may be implemented mechanically or electronically. For example a hardware module may include dedicated circuitry or logic that is permanently configured for example as a special purpose processor such as a field programmable gate array FPGA or an application specific integrated circuit ASIC to perform certain operations. A hardware module may also include programmable logic or circuitry for example as encompassed within a general purpose processor or other programmable processor that is temporarily configured by software to perform certain operations. It will be appreciated that the decision to implement a hardware module mechanically in dedicated and permanently configured circuitry or in temporarily configured circuitry for example configured by software may be driven by cost and time considerations.

Accordingly the term hardware module should be understood to encompass a tangible entity be that an entity that is physically constructed permanently configured e.g. hardwired or temporarily configured e.g. programmed to operate in a certain manner and or to perform certain operations described herein. Considering embodiments in which hardware modules are temporarily configured e.g. programmed each of the hardware modules need not be configured or instantiated at any one instance in time. For example where the hardware modules include a general purpose processor that is configured using software the general purpose processor may be configured as respective different hardware modules at different times. Software may accordingly configure a processor for example to constitute a particular hardware module at one instance of time and to constitute a different hardware module at a different instance of time.

Modules can provide information to and receive information from other modules. For example the described modules may be regarded as being communicatively coupled. Where multiples of such hardware modules exist contemporaneously communications may be achieved through signal transmissions such as for example over appropriate circuits and buses that connect the modules. In embodiments in which multiple modules are configured or instantiated at different times communications between such modules may be achieved for example through the storage and retrieval of information in memory structures to which the multiple modules have access. For example one module may perform an operation and store the output of that operation in a memory device to which it is communicatively coupled. A further module may then at a later time access the memory device to retrieve and process the stored output. Modules may also initiate communications with input or output devices and can operate on a resource for example a collection of information .

The various operations of example methods described herein may be performed at least partially by one or more processors that are temporarily configured e.g. by software or permanently configured to perform the relevant operations. Whether temporarily or permanently configured such processors may constitute processor implemented modules that operate to perform one or more operations or functions. The modules referred to herein may in some example embodiments include processor implemented modules.

Similarly the methods described herein may be at least partially processor implemented. For example at least some of the operations of a method may be performed by one or more processors or processor implemented modules. The performance of certain of the operations may be distributed among the one or more processors not only residing within a single machine but deployed across a number of machines. In some example embodiments the processors may be located in a single location e.g. within a home environment within an office environment or as a server farm while in other embodiments the processors may be distributed across a number of locations.

While the embodiments are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of claims provided below is not limited to the embodiments described herein. In general the techniques described herein may be implemented with facilities consistent with any hardware system or hardware systems defined herein. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the claims. In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements fail within the scope of the claims and their equivalents.

