---

title: Frequency reduction of mobile device cores based on application processing requirements
abstract: This disclosure describes systems, methods, and apparatus for reducing power consumption of an application processor in a user equipment. State information of applications that indicate an expected load requirement that the applications will likely place on the application processor, can be used to control power management features of the application processor. For instance, an operating frequency of the application processor, or online cores of the application processor, can be reduced. The number of online cores (those that are not idled) can also be changed to tailor performance and power consumption to the load requirement. Other power management techniques such as adjusting core operational voltage can also be implemented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08904211&OS=08904211&RS=08904211
owner: Qualcomm Innovation Center, Inc.
number: 08904211
owner_city: San Diego
owner_country: US
publication_date: 20120427
---
The present disclosed embodiments relate generally to wireless mobile computing devices and more specifically to power conservation in such devices via varying an operating frequency or online state of one or more cores of an application processor.

Mobile communication devices including devices such as smartphones tablet computers gaming devices and laptop computers are now ubiquitous. A common and ongoing issue with these types of devices is power management. Although advances continue to be made in the areas of battery technology and hardware efficiency current mobile device power management techniques are not adequate to meet user expectations and will almost certainly not be satisfactory in the future.

The application processor or app processor in many mobile wireless communication devices or user equipment UE has a variable operating frequency which can be lowered to conserve power. App processors are also starting to see multiple cores thus allowing one or more cores to be idled or put into an offline state to save power. Both of these power saving techniques save power at the expense of processing power an acceptable tradeoff when the app processor is not being fully utilized anyway. Traditional UE have the ability to tailor the number of online cores and or tailor the operating frequency to the app processor s utilizing or load requirement .

For instance when a user visits a website the browser typically downloads a root html document from a remote server. In doing so the browser resolves the domain name server DNS and establishes a communication connection with the remote server. This process can take 2.5 to 3 seconds on a 3G network because the modem has to be switched on and brought back up. During this 2.5 to 3 seconds the browser typically does not perform any processing but rather waits for a response from the remote server. As a result the app processor is lightly loaded. Yet the app processor typically continues to operate at the same frequency which is higher frequency than necessary to handle this light processing load.

The operating frequency and number of online cores versus those in idle mode can be reduced in order to better match power consumption to the app processor load requirement but current methods of doing so are reactive they occur in reaction to processor loading. For instance a core controller e.g. mpdecision algorithm typically decides which cores to put into an online or offline state or idled mode and a governor e.g. DCVS typically controls the operating frequency of each online core e.g. clock scaling . The core controller and governor monitor a load on the app processor and in response modify the number of online offline cores and operating frequency of online cores to minimize power consumption. The trouble with this scheme is that the core controller and governor react to the app processor load and thus entail some delay before power consumption is reduced to a minimum level needed to meet the app processor load requirement.

Although the applications e.g. browser can communicate with the kernel via traditional interfaces or APIs in the form of system calls there is no way to communicate a load requirement of the applications to the kernel .

Exemplary embodiments of the present invention that are shown in the drawings are summarized below. These and other embodiments are more fully described in the Detailed Description section. It is to be understood however that there is no intention to limit the invention to the forms described in this Summary of the Invention or in the Detailed Description. One skilled in the art can recognize that there are numerous modifications equivalents and alternative constructions that fall within the spirit and scope of the invention as expressed in the claims.

One aspect of the disclosure describes a system for reducing power consumption on a mobile communication device where the system has an application processor one or more applications a scheduling interface and a kernel or a kernel layer. The application processor can have a plurality of cores each core operating at one or more operating frequencies. The one or more applications can perform user initiated and automated tasks and run on at least one or the plurality of cores and provide state information indicating a predicted load that the one or more applications are expected to place on the application processor. The scheduling interface can run on the application processor and be configured to facilitate communication of the state information from the one or more applications. Finally the kernel can run on the application processor and control the one or more operating frequencies. The kernel can also be configured to 1 receive the state information from the one or more applications via the scheduling interface and 2 decrease the one or more operating frequencies of the plurality of cores to new operating frequencies that are cumulatively high enough to meet the predicted load thereby reducing power consumed by the application.

Another aspect of the disclosure describes a method of operating a user equipment so as to conserve power via use of knowledge of application state information. The method includes operating an application processor of a user equipment where the application processor comprises one or more cores. Each of the one or more cores operates at one or more operating frequencies. The method further includes monitoring state information of one or more applications performing tasks and running on at least one of plurality of cores where the state information represents a predicted load that the one or more applications are expected to place on the application processor. Lastly the method includes adjusting a number of the one or more cores that are operating in an idle state in order to meet the predicted load indicated by the state information.

Another aspect of the disclosure is a non transitory tangible computer readable storage medium encoded with processor readable instruction to perform a method for conserving power in a user equipment by using knowledge of application state information to manage power usage of an application processor. The method includes operating an application processor of a user equipment where the application processor comprises one or more cores. Each of the one or more cores operates at one or more operating frequencies. The method further includes monitoring state information of one or more applications performing tasks and running on at least one of plurality of cores where the state information represents a predicted load that the one or more applications are expected to place on the application processor. Lastly the method includes adjusting a number of the one or more cores that are operating in an idle state in order to meet the predicted load indicated by the state information.

The word exemplary is used herein to mean serving as an example instance or illustration. Any embodiment described herein as exemplary is not necessarily to be construed as preferred or advantageous over other embodiments.

The aforementioned challenges in the prior art see can be overcome by enabling the kernel to adjust a number of app processor cores that are online or offline and predictably adjust an operating frequency of the online cores based on a load requirement of running applications rather than basing this on the app processor load. In other words rather than monitoring an effect of applications on the app processor this disclosure extracts a load requirement directly from the applications that are running and can even receive predicted future load requirements from the applications. Such an approach allows faster reactions to changes in application usage of the app processor and thus lower overall power consumption than the reactive systems and methods of the art.

This is achieved in one instance by the system illustrated in . The system enables the above described functionality by monitoring a state of one or more applications running on a UE where different states of an application are known to correspond to an app processor load requirement a load that an application places on the app processor . Traditionally such a state was not passed to a kernel . However by adding a new interface or API called a scheduling interface a state of an application can be passed to the kernel such that the kernel can adjust the number of online cores and the operating frequency of the app processor accordingly. As seen this approach is proactive rather than reactive thus providing substantial power savings over systems and methods known in the art. An API can refer to a complete interface a single new function or even a set of APIs provided by a single developer.

In one embodiment one of the applications e.g. a browser can make a system call to the kernel via the traditional interface s . A call can mean invoking a function or loading it into the stack and then computing instructions associated with the function. As this occurs state information regarding the application can be passed to the kernel via the scheduling interface . The core controller and governor can use the state information and optionally load information regarding the app processor to generate instructions for the app processor e.g. increase decrease frequency and or increase decrease a number of idle cores . The instructions can be passed to the kernel scheduling module which then controls aspects of the app processor . In one case this means reducing power consumption of the app processor while maintaining a user experience. Maintaining the user experience is achieved by keeping the app processor running at a level just sufficient to meet the calls of the one or more applications and to do so such that the user does not experience any slowing of the user equipment degradation in graphics or audio or any other degradation in performance that is humanly noticeable.

Applications e.g. browser are illustrated at the highest level of abstraction and hardware such as the app processor is illustrated at the lowest level. The kernel along with interfaces and enable communication between the applications and the app processor . A scheduling interface monitors a state of the applications where each state corresponds to a known app processor load requirement. The scheduling interface passes the state information for one or more applications or a known or predicted load requirement to the kernel . The core controller and governor then uses this state information to determine an operating frequency for the app processor . In particular the operating frequency can be selected as a minimum operating frequency configured to meet the known or predicted load requirement of the applications without diminishing a user experience level. In other words the operating frequency of online cores can be based on state information provided by one or more applications . The kernel scheduling module then instructs the app processor to operate its online cores at a decreased operating frequency e.g. a minimum operating frequency or to decrease a number of cores that are operating online .

The one or more applications may be realized by a variety of applications that operate via or run on the app processor . For example the one or more applications may include a web browser and associated plug ins entertainment applications e.g. video games video players productivity applications e.g. word processing spread sheet publishing applications video editing photo editing applications core applications e.g. phone contacts and augmented reality applications.

Each application of the one or more applications can have states. Each state corresponds to or describes a load requirement that can be expected to be applied on the app processor by the running of application processes or by an application call. The one or more applications can pass a state for each application to the kernel which uses the state to control the app processor operating frequency and a number of online cores thus enabling control of these aspects without having to monitor a load on the app processor . Each application can have one or more states for instance five states.

This is also advantageous in a predictive sense since it may be known that an application will enter a given state sometime in the future or that a current state will require a certain load on the app processor at a future time. State information can thus describe a predicted load that an application expects to place on the app processor as a result of an application call that has yet to occur. As a result the core controller and governor can modify the number of online cores and or the operating frequency of the online cores at the same time or slightly before the load on the app processor changes. In this way operation of the app processor can be more quickly adjusted to account for changes in load requirements of the one or more applications than has been achieved in the art. For instance where an application knows that a call will be made in approximately two seconds that will required half the resources of the app processor currently being used then this state can be passed to the kernel scheduling module where the core controller and governor can then instruct the app processor to decrease a number of cores that are operating or a frequency of the online cores at or slightly before the expected decrease in required processor resources.

Exemplary states or state information include a browser in a scrolling state or a browser performing a DNS resolution of a root domain. A browser in a scrolling state where the user is scrolling a web page after the page has loaded may put varying loads on the app processor depending on the resource requirements of the page being scrolled. In comparison during a DNS resolution of a root domain the app processor has little to no load and is thus ideally suited for operating at a lower frequency and or with more idle cores. In one embodiment the browser can be downloading content such that no processing is required. During such a period the app processor or portions thereof can be idled or the operating frequency can be decreased since little to no load will be placed on the app processor . In particular the browser can be downloading root HTML or JAVASCRIPT to name two examples. In another example the browser could be waiting for a response from a DNS server after making a DNS request here again there is little need for the app processor to be running at maximum so state information can be provided to the kernel indicating that the browser does not need as much processing resources.

In an embodiment the relationship between a state and a load requirement can be determined via empirical data gathered via testing. For instance one of the applications can be operated and the load on the app processor can be monitored for various calls that the application makes. These loads can be correlated with the application calls thus generating states that can be stored for later use. When the kernel receives state information from one or more applications it can determine what load is likely or expected to be placed on the app processor based on the empirically derived state information and can adjust the app processor to minimize power consumption while still maintaining an acceptable user experience e.g. the same user experience as before the app processor adjustment .

The one or more applications can automatically notify the kernel via the scheduling interface when a state change occurs or is going to occur. Alternatively the scheduling interface can monitor or periodically sample application states and report the same to the kernel . In an alternative embodiment the scheduling interface can report a load requirement to the kernel in addition to or rather than reporting an application state.

While a traditional interface s enables the applications to make system calls to the kernel they do not indicate an application s state to the kernel . Thus the kernel typically does not use or react to a state of the one or more applications . However here the scheduling interface enables state information of an application of the one or more applications to be passed to or made available to the kernel and in particular to the core controller and governor . The core controller and governor via the kernel scheduling module can then modify a number of online cores or a frequency of the online cores based on the state s of the one or more applications .

The one or more applications can be part of a user space while the scheduling interface traditional interfaces kernel and core controller and governor can be part of a kernel space . The kernel can be monolithic or a microkernel although other alternatives are also possible.

This solution was not previously possible because stack developers optimizing the kernel typically see the applications and other higher level functions in the stack as a black box. They are often unaware that applications even have state information. It thus would not occur to one of skill in the art to look to the application states for information that could be used to modify scheduling of the kernel . However the inventors who are applications specialists realized that state information about the applications existed and could be used to advantageously schedule the kernel . They thus sought a way to pass this state information to the kernel to improve scheduling.

It should be understood that the kernel scheduling module and the core controller and governor can either reduce the operating frequency of cores that are online reduce a number of cores that are online or both. The kernel scheduling module and the core controller and governor can also increase the operating frequency of online cores increase the number of cores that are online or both. The kernel scheduling module and the core controller and governor can also increase the operating frequency while decreasing the number of online cores or decrease the operating frequency and increase the number of online cores .

In some embodiments the cores may not all be equal. For instance one core may have a maximum operating frequency that is lower than that of the other cores yet uses less power. To save power this low power core may be online given low load requirements and idled in favor of more powerful cores during high loading periods. In another embodiment some cores may have their operating frequencies lowered to a greater extent than others. When this happens the frequencies should be lowered so that they cumulatively produce an effect that meets the predicted load.

When scheduling the app processor the kernel scheduling module and the core controller and governor may take into account variable rates of change that the operating frequency of online cores can undergo e.g. increasing frequency may take longer than decreasing it . As such the kernel scheduling module and the core controller and governor may provide a little more lead time when instructing the app processor to increase online core frequencies than when instructing it to decrease those frequencies.

As one of ordinary skill in the art will appreciate the user space and kernel space components depicted in may be realized by computer code stored in a non transitory tangible computer readable medium such as nonvolatile memory and can be executed by app processor . Numerous variations on the embodiments herein disclosed are also possible. For instance the governor of the core controller and governor can be selected from the following non exclusive list interactive smoothass conservative ondemand userspace powersave performance smartass and always max

While the systems and methods herein disclosed have been described in terms of modifying the number of online cores and the operating frequency of the online cores other power conservation techniques can also be applied to the application state based decisions of this disclosure. For instance in addition to or instead of modifying the number of online cores or the operating frequency of online cores dynamic voltage scaling and various idle states can also be used. In particular in addition to decreasing the operating frequency when the application state indicates a low load requirement a voltage of the app processor and or other components can be decreased undervolting to save power. Undervolting not only saves power via use of lower voltage but it also saves power by lowering cooling requirements. In other instances idle states that involve partial shutdown of one or more cores can be used e.g. C0 C1 C1E C3 C6 etc. . In some cases a combination of these techniques can be used for instance P states where both operating frequency and core voltage are modified.

APIs in the API layer can include activities views animation telephony content providers OpenGL camera and SQLite to name a few. The libraries can include ones for media OpenGL Free Type SQLite Web Kit and Graphics to name a few. The libraries can be based off the core library of the OS or can replace portions of the core libraries.

The LINUX kernel layer can include various aspects such as display drivers USB drivers camera drivers keypad drivers Bluetooth drivers WIFI drivers flash memory drivers audio drivers binder IPC drivers and power management drivers to name a few. The kernel interfaces higher layers of the stack with the hardware layer and hardware such as the app processor baseband processor memory and user input output to name a few. The LINUX kernel layer also receives state information about one or more applications in the applications layer and controls characteristics of the app processor based on the state information. Such characteristics can include but are not limited to a number of online processor cores an operating frequency of online processor cores and an operating voltage of online processor cores.

If there is no change in state information or no substantial change in state information or if the state information does not indicate that a change in idle cores operating frequency or other power management parameters is desired then the method can return to the monitor state information operation . If a change has occurred then the method can also return to the monitor state information operation .

Optionally the method can also monitor app processor load information in a second monitor operation . This information can then be passed to the kernel of the stack in a second pass app processor load information operation . The power management decision and the adjustment operations can then be based on a combination of state information from the applications and app processor load information from the app processor. It should be understood that the monitoring and passing operations need not operate simultaneously or at the same rates or have any other equivalency that one might read from the illustration. Rather a variety of timing schemes is envisioned. For instance the adjustment operations may be based on recent state information combined in a weighted fashion with an ongoing stream of app processor load information.

The systems and methods described herein can be implemented in a machine such as a computer system in addition to the specific physical devices described herein. shows a diagrammatic representation of one embodiment of a machine in the exemplary form of a computer system within which a set of instructions can execute for causing a device to perform or execute any one or more of the aspects and or methodologies of the present disclosure. The components in are examples only and do not limit the scope of use or functionality of any hardware software embedded logic component or a combination of two or more such components implementing particular embodiments.

Computer system may include a processor a memory and a storage that communicate with each other and with other components via a bus . The bus may also link a display one or more input devices which may for example include a keypad a keyboard a mouse a stylus etc. one or more output devices one or more storage devices and various tangible storage media . All of these elements may interface directly or via one or more interfaces or adaptors to the bus . For instance the various tangible storage media can interface with the bus via storage medium interface . Computer system may have any suitable physical form including but not limited to one or more integrated circuits ICs printed circuit boards PCBs mobile handheld devices such as mobile telephones or PDAs laptop or notebook computers distributed computer systems computing grids or servers.

Processor s or central processing unit s CPU s optionally contains a cache memory unit for temporary local storage of instructions data or computer addresses. Processor s are configured to assist in execution of computer readable instructions. Computer system may provide functionality as a result of the processor s executing software embodied in one or more tangible computer readable storage media such as memory storage storage devices and or storage medium . The computer readable media may store software that implements particular embodiments and processor s may execute the software. Memory may read the software from one or more other computer readable media such as mass storage device s or from one or more other sources through a suitable interface such as network interface . The software may cause processor s to carry out one or more processes or one or more steps of one or more processes described or illustrated herein. Carrying out such processes or steps may include defining data structures stored in memory and modifying the data structures as directed by the software.

The memory may include various components e.g. machine readable media including but not limited to a random access memory component e.g. RAM e.g. a static RAM SRAM a dynamic RAM DRAM etc. a read only component e.g. ROM and any combinations thereof. ROM may act to communicate data and instructions unidirectionally to processor s and RAM may act to communicate data and instructions bidirectionally with processor s . ROM and RAM may include any suitable tangible computer readable media described below. In one example a basic input output system BIOS including basic routines that help to transfer information between elements within computer system such as during start up may be stored in the memory .

Fixed storage is connected bidirectionally to processor s optionally through storage control unit . Fixed storage provides additional data storage capacity and may also include any suitable tangible computer readable media described herein. Storage may be used to store operating system EXECs executables data APV applications application programs and the like. Often although not always storage is a secondary storage medium such as a hard disk that is slower than primary storage e.g. memory . Storage can also include an optical disk drive a solid state memory device e.g. flash based systems or a combination of any of the above. Information in storage may in appropriate cases be incorporated as virtual memory in memory .

In one example storage device s may be removably interfaced with computer system e.g. via an external port connector not shown via a storage device interface . Particularly storage device s and an associated machine readable medium may provide nonvolatile and or volatile storage of machine readable instructions data structures program modules and or other data for the computer system . In one example software may reside completely or partially within a machine readable medium on storage device s . In another example software may reside completely or partially within processor s .

Bus connects a wide variety of subsystems. Herein reference to a bus may encompass one or more digital signal lines serving a common function where appropriate. Bus may be any of several types of bus structures including but not limited to a memory bus a memory controller a peripheral bus a local bus and any combinations thereof using any of a variety of bus architectures. As an example and not by way of limitation such architectures include an Industry Standard Architecture ISA bus an Enhanced ISA EISA bus a Micro Channel Architecture MCA bus a Video Electronics Standards Association local bus VLB a Peripheral Component Interconnect PCI bus a PCI Express PCI X bus an Accelerated Graphics Port AGP bus HyperTransport HTX bus serial advanced technology attachment SATA bus and any combinations thereof.

Computer system may also include an input device . In one example a user of computer system may enter commands and or other information into computer system via input device s . Examples of an input device s include but are not limited to an alpha numeric input device e.g. a keyboard a pointing device e.g. a mouse or touchpad a touchpad a joystick a gamepad an audio input device e.g. a microphone a voice response system etc. an optical scanner a video or still image capture device e.g. a camera and any combinations thereof. Input device s may be interfaced to bus via any of a variety of input interfaces e.g. input interface including but not limited to serial parallel game port USB FIREWIRE THUNDERBOLT or any combination of the above.

In particular embodiments when computer system is connected to network computer system may communicate with other devices specifically mobile devices and enterprise systems connected to network . Communications to and from computer system may be sent through network interface . For example network interface may receive incoming communications such as requests or responses from other devices in the form of one or more packets such as Internet Protocol IP packets from network and computer system may store the incoming communications in memory for processing. Computer system may similarly store outgoing communications such as requests or responses to other devices in the form of one or more packets in memory and communicated to network from network interface . Processor s may access these communication packets stored in memory for processing.

Examples of the network interface include but are not limited to a network interface card a modem and any combination thereof. Examples of a network or network segment include but are not limited to a wide area network WAN e.g. the Internet an enterprise network a local area network LAN e.g. a network associated with an office a building a campus or other relatively small geographic space a telephone network a direct connection between two computing devices and any combinations thereof. A network such as network may employ a wired and or a wireless mode of communication. In general any network topology may be used.

Information and data can be displayed through a display . Examples of a display include but are not limited to a liquid crystal display LCD an organic liquid crystal display OLED a cathode ray tube CRT a plasma display and any combinations thereof. The display can interface to the processor s memory and fixed storage as well as other devices such as input device s via the bus . The display is linked to the bus via a video interface and transport of data between the display and the bus can be controlled via the graphics control .

In addition to a display computer system may include one or more other peripheral output devices including but not limited to an audio speaker a printer and any combinations thereof. Such peripheral output devices may be connected to the bus via an output interface . Examples of an output interface include but are not limited to a serial port a parallel connection a USB port a FIREWIRE port a THUNDERBOLT port and any combinations thereof.

In addition or as an alternative computer system may provide functionality as a result of logic hardwired or otherwise embodied in a circuit which may operate in place of or together with software to execute one or more processes or one or more steps of one or more processes described or illustrated herein. Reference to software in this disclosure may encompass logic and reference to logic may encompass software. Moreover reference to a computer readable medium may encompass a circuit such as an IC storing software for execution a circuit embodying logic for execution or both where appropriate. The present disclosure encompasses any suitable combination of hardware software or both.

Those of skill in the art would understand that information and signals may be represented using any of a variety of different technologies and techniques. For example data instructions commands information signals bits symbols and chips that may be referenced throughout the above description may be represented by voltages currents electromagnetic waves magnetic fields or particles optical fields or particles or any combination thereof.

Those of skill would further appreciate that the various illustrative logical blocks modules circuits and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware computer software or combinations of both. To clearly illustrate this interchangeability of hardware and software various illustrative components blocks modules circuits and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.

The various illustrative logical blocks modules and circuits described in connection with the embodiments disclosed herein may be implemented or performed with a general purpose processor a digital signal processor DSP an application specific integrated circuit ASIC a field programmable gate array FPGA or other programmable logic device discrete gate or transistor logic discrete hardware components or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor but in the alternative the processor may be any conventional processor controller microcontroller or state machine. A processor may also be implemented as a combination of computing devices e.g. a combination of a DSP and a microprocessor a plurality of microprocessors one or more microprocessors in conjunction with a DSP core or any other such configuration.

The steps of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware in a software module executed by a processor or in a combination of the two. A software module may reside in RAM memory flash memory ROM memory EPROM memory EEPROM memory registers hard disk a removable disk a CD ROM or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such the processor can read information from and write information to the storage medium. In the alternative the storage medium may be integral to the processor. The processor and the storage medium may reside in an ASIC. The ASIC may reside in a user terminal. In the alternative the processor and the storage medium may reside as discrete components in a user terminal.

The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.

