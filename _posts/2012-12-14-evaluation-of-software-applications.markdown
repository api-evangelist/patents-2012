---

title: Evaluation of software applications
abstract: Software applications receive input data, perform processing of the received data and generate output. In one aspect the output is modification of data structures. The software application is tested with instances of input data that lead to various data modifications in the data structures. In another aspect, patterns are found in the modifications of the data structures, which are evaluated and analyzed for software vulnerabilities.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09471788&OS=09471788&RS=09471788
owner: SAP SE
number: 09471788
owner_city: WALLDORF
owner_country: DE
publication_date: 20121214
---
Enterprise software applications are typically complex and may consist of several abstraction layers and many different frameworks. An abstraction layer is a way of presenting a complex functionality by hiding implementations details. A software framework is another abstraction which is a software platform used to develop applications. An advanced generation of software applications may utilize open source solutions with various levels of security. An open source solution is computer software that is available with source code. The source code and copyright are provided under a license that permits users to study change improve and eventually distribute the software. However often the security aspect is neglected which causes unauthorized accesses or other performance problems such as error situations and application crashes. Tools for detecting potential security and performance vulnerabilities have become a crucial part in testing software applications.

Brute force algorithm is a general problem solving technique which includes identifying and systematically checking all possible candidates for solving a problem. Using a brute force algorithm to discover security and performance vulnerabilities of software applications is practically useless since the amount of time needed to analyze a software application it too much even using the newest generation of computers. There is a need to apply some logic to analyze software application behavior in an optimized way.

Embodiments of techniques for evaluation of software applications are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

A software application may be considered as a complex entity that has incoming and outgoing data flows. represents such an application with input data and output data . The incoming data flow which is input data influences the internal state of the software application while at some point the software application generates an outgoing data flow such as the output data . Thus the process may be defined to include at least three major steps receiving of incoming data data processing and generating outgoing data. During this process the software application may use some internal data structures to store interim data. The content of the internal data structures may depend on the input data and software application logic. Data structures that are modified during the software application execution may be determined and then used to evaluate the software application steps using these data structures. The point where the execution of a request to the software application has reached i.e. the breakpoint together with variables i.e. the data structures that are changed during the software application execution define a program snapshot. A breakpoint identifies from an object and an instruction position within the bytecode of that object. Variables are mapped to data structures e.g. a byte .

Some of the data structures may be data wrappers. Data wrappers are thus mapped to an input pattern. Referring to by analyzing the changes within the internal data structures it may be possible to define evaluation snapshots that direct the software application to essentially different states. An evaluation snapshot is a program snapshot. Because there is a direct dependency between the input data and the internal data structures the derived evaluation snapshots for the internal data structures may also be applied to the input data . The evaluation snapshots defined in this way may be linked with parent child relationship and an ordered graph tree of evaluation snapshots can be built. The ordered graph may be expanded with additional patterns e.g. both input patterns and resulting internal data structures patterns that lead the software application to different states. Some of these software application states may be of interest and by following a simple traverse algorithm applied to the tree such program a software application state may be reached. If an evaluation framework such as evaluation framework is used to analyze the internal data structures and create an evaluation snapshot tree for the software application then data structure patterns and input data patterns may be identified. The input data patterns are dependent on the data structure patterns . The identified data structure patterns may be evaluated based on predefined rules that aim to discover critical scenarios for the software application .

Following the algorithm mentioned above for evaluation of a program in reference to an oriented graph of evaluation snapshots for the software application can be built. The edges of the graph may be executed software application steps and the nodes may be classified based on variables that are modified. The evaluation engine includes evaluation snapshots and controls an evaluation snapshots loop. The evaluation engine also creates an evaluation snapshot graph. The modified variables may contain abstract data structures and when these data structures are accessed on some step evaluation of some of the parent snapshots may be needed in order to determine the resulting snapshots.

The evaluation hook is a module responsible for interacting with the evaluated software application . The evaluation hook may also monitor the one step behavior of the evaluated software application and could process steps in both directions. The evaluation hook may also participate in building software application snapshots.

The evaluated software application may include software application code software application runtime data structures and data structure wrappers . The software application code may include bytecode and source code . The bytecode may be used by the evaluation engine . The source code may be used by the IDE by means of an evaluation plug in . In one embodiment the source code increases usability of the IDE and a potential problem may be visualized in the source code . The software application runtime may include all loaded classes and may communicate with the data structures containing static and local variables. Data structure wrappers may be used for data structures that are mapped to patterns in evaluation snapshots .

The in flow data engine may simulate input data for the evaluated software application . In one embodiment the in flow data engine may generate test application examples based on an evaluation snapshot.

The IDE and the evaluation plugin may provide visual representation and management tools for the whole evaluation process.

The management module may provide management activities such as suspend resume against different instances of the evaluated software application . In one embodiment the management module is also operable to provide a visualization of the evaluation process.

The evaluation runtime loop may create an evaluation snapshot graph from evaluation snapshots . The evaluation runtime loop in connection with the evaluation hook may be operable to monitor the behavior of the evaluated software application . The evaluation runtime loop in communication with the input data engine may be operable to simulate input data for the evaluated software application . The evaluation runtime loop may use the file system for performing backups of the evaluation snapshots storing progress reports and extracting configuration data such as evaluation configuration . In one embodiment the progress reports are human readable. In one embodiment the evaluation configuration includes configuration rules. In one embodiment the configuration rules may define prioritization of the evaluation snapshots. In yet another embodiment the configuration rules may define evaluation snapshots to be excluded from the evaluation runtime loop which may be based on rules that define certain evaluation snapshots not being of interest for the evaluation process.

At block patterns of the generated data structures are determined. There may be a direct dependency between the generated data structures and the input data and the patterns of the generated data structures may indicate these dependencies.

The input data for a software application may be a countable set. For example the input data may be a sequence of bytes that go through one communication channel connected with the software application. In some embodiments the input data may be more complex but it remains a countable set and the same algorithm may be used. In one embodiment the bytes from the input data are enumerated with the number of their position within the sequence 1 2 . . . n. By having bytes B B . . . Bn for each such byte being a part from given input data the following states S Bn may be defined 

free data the byte Bn is read by the software application but there is still no branching based on its value which means there is no data structure changed or program operations performed based on this data 

value set the byte Bn or some sequence of bytes Bn . . . Bn m has a predefined value set e.g. ab ac ad that directs the program to an exact branch and

strict value the same as the value set but containing a single value. In one embodiment an input state Sn may be defined as a union of all state of bytes that are part from the input Sn S B S B . . . . An evaluation snapshot can be mapped to such input state. Similarly to the input data a countable set from all attributes variables within the evaluated software application may be built. Attributes variables are all places where some data could be stored for example static variable of classes thread locals instances of loaded classes attributes of these instances local variables of called methods etc. All attributes are given unique names which may be done using one or more initial points and then mentioning all attributes as a reference according to this initial point e.g. root classloader all classloders app classX classXYZ attributeABC . The attributes within a given snapshot could have the following states 

changed with constant attribute An has been changed to a constant the value of the constant does not contain the value of an input byte here a boundary case may be when the value depends on the count of processed input bytes.

changed with formula attribute An has been changed to value of a computable formula that contains input bytes 

data structure wrapper data structure wrappers may be used when there is a repeatable data structure pattern e.g. within the input data with a defined list of data structures and no need to have different snapshots one for one data structure another with list of two data structures etc it is enough to have one snapshot with a data structure wrapper. There is also a need to detect such repeatable data structures during the execution of the software application.

Turning back to at block the determined patterns are evaluated based on predefined rules. In one embodiment the patterns are checked for critical scenarios for the software application and critical instances of input data leading to the critical scenarios are defined. Critical scenarios for a software application include undesired situations and states of the executed software application. Undesired states may be error states while undesired situation may be an unauthorized access to some data or resources. In one embodiment the patterns are checked for possible system crashes and security faults.

At block critical instances of input data causing critical errors in the software application may be reported.

Then at block a program step of the software application is executed. Only program steps that modify some data structures or evaluate a data structure are of interest. These are operations that change value e.g. x 1 and operations that branch based on a value e.g. if x 0 . . . . At block a resulting evaluation snapshot is collected. The resulting evaluation snapshot results from the executed program step at block .

At decision block a check is performed to determine whether the resulting evaluation snapshot includes predefined exclusive patterns. The predefined exclusive patterns may be defined in configuration data such as evaluation configuration . If a predefined exclusive pattern is identified in the resulting evaluation snapshot then the method returns to block to execute another program step. If a predefined exclusive pattern is not found in the resulting evaluation snapshot then the method continues to decision block to perform another check. At decision block the attributes execution breakpoint changed variables and input patterns of the resulting evaluation snapshot are checked to determine if they coincide with those of an existing snapshot from a set of existing evaluation snapshots. If these attributes do not coincide with those of an existing evaluation snapshot then at block the resulting evaluation snapshot is added to the set of existing evaluation snapshots and the method returns to block to execute another program step. If the attributes execution breakpoint changed variables and input patterns of the resulting evaluation snapshot do coincide with those of an existing evaluation snapshot then the method continues to block to map the resulting evaluation snapshot to the existing evaluation snapshot and the method returns to block to execute another program step.

An example of a simple software application that receives as an input text and generates as an output a word that repeats most in the text follows. The software application caches the output in order to analyze the searches later. The software application code may be in Java as presented in Table 1 

Other snapshots are also generated but they are not of interest for the checks performed below. There may be a predefined set of rules checks that are executed against that snapshot. Two possible checks may be 

Check 1 If OBJECT INSTANCES contain some VARIABLE with VALUE having UNRESTRICTED SIZE then this is an indicator for possible out of memory problem. This rule may be used to discover a situation when there is no limitation for buffering the data coming from the input data stream within the memory. In that situation a variable with unrestricted size is sought.

In the example above the check discovers variable line Then any lone enough input data stream that does not contain n causes an out of memory problem for the software application see restrictions on variable s value .

Check 2 If STATIC STRUCTURES contain some VALUE from type RESTRICTED INPUT STREAM that is an indicator for possible out of memory problem.

This rule may be used to discover a situation when data coming from the input data stream is stored within the memory in static objects. This situation could lead to an out of memory problem as the incoming data request could be repeated many times and each time the memory used by the program increases.

In the example above the check discovers variable mostRepeatedWords . Then any call to the software application causes an increase of the used memory. After multiple calls the out of memory problem appears.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is located remotely from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. A computer readable storage medium may be a non transitory computer readable storage medium. Examples of non transitory computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. in other instances well known operations or structures are not shown or described in details.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

