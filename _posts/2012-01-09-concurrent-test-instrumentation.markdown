---

title: Concurrent test instrumentation
abstract: A program can be instrumented to test the program. The test instruments are classified, and concurrency constraints applied based on the classifications. A testing tool determines classifications of a plurality of test instruments in the instrumented program. The testing tool prevents concurrent instantiation of multiple of the plurality of test instruments in a first classification of the classifications. Multiple of the plurality of test instruments in a second classification of the classifications are concurrently instantiated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09103874&OS=09103874&RS=09103874
owner: International Business Machines Corporation
number: 09103874
owner_city: Armonk
owner_country: US
publication_date: 20120109
---
Embodiments of the inventive subject matter generally relate to the field of code instrumentation and more particularly to use of ensuring concurrent test instrument constraint compliance.

Test instrumentation involves inserting test instruments or instruments into a program for testing. An instrument can be a single program instruction or a sequence of program instructions. An instrument may invoke a testing program instructions via an application programming interface.

Embodiments include a method that determines classifications of a plurality of test instruments in the instrumented program. Concurrent instantiation of multiple of the plurality of test instruments in a first classification of the classifications is prevented. Multiple of the plurality of test instruments in a second classification of the classifications are concurrently instantiated.

The description that follows includes exemplary systems methods techniques instruction sequences and computer program products that embody techniques of the present inventive subject matter. However it is understood that the described embodiments may be practiced without these specific details. In other instances well known instruction instances protocols structures and techniques have not been shown in detail in order not to obfuscate the description.

Test instruments in a program can vary in functionality. Some instruments perform program profiling profiling instruments . A few examples of program profiling include analyzing memory use by a program measuring the frequency of a function call measuring the duration of an invoked function determining execution path and determining call context. Some instruments modify the testing environment. Examples of modifying the test environment include limiting available memory for a program and running the program multiple times. Some instruments modify a program s behavior. Although some instruments such as profiling instruments can be run concurrently those instruments that modify program behavior should not or cannot be run concurrently. These instructions should not or cannot be run concurrently because the instruments interfere with each other by modifying program behavior.

A testing system can classify the test instruments based on whether their functionality affects or interferes with other instruments. The testing system defines concurrency constraints for each classification of instrument. The system classifies instruments that modify behavior of a program and or interfere with another instrument as Exclusive Instruments. The system enforces a concurrency constraint for Exclusive Instruments that prevents concurrent execution of Exclusive Instruments. The testing system classifies instruments that do not interfere with other instruments as Passive Instruments. The system allows Passive Instruments to be concurrently executed. The testing system classifies instruments that do not that are neither exclusive nor passive as Active Instruments. Developers define sub classes for the Active Instrument class to be mutually exclusive. The testing system will prevent instruments in the same sub class of the Active Instrument class from executing concurrently.

In the program is depicted with code fragments A B and C. These code fragments are presented merely for illustrative purposes. Instrumentation of the program yields an instrument program . The instrumented program is depicted with instruments EI.fxn AI.OPTION.fxn PI.fxn1 PI.fxn2 and AI.CMD.fxn. The test interface inserted the instrument PI.fxn1 before the code fragment A. The test interface inserted the instrument AI.CMD.fxn before the code fragment B. The test interface inserted the instrument PI.fxn2 before the code fragment C. The EI instrument is classified as an Exclusive Instrument. The PI instruments are classified as Passive Instruments. The AI instruments are classified as Active Instruments. The AI instruments are further classified into sub classes CMD and OPTION. The CMD sub class encompasses instruments that set commands for a testing system when testing a program. The OPTION sub class encompasses instruments that set options for the testing system when testing a program. This example depicts instruments that invoke instrument program instructions defined separately from the testing system although embodiments are not so limited. The EI.fxn instrument invokes a test module or test program instructions referred to as EI.fxn. The AI.OPTION.fxn instrument invokes a test module referred to as AI.OPTION.fxn. The AI.CMD.fxn instrument invokes a test module referred to as AI.CMD.fxn. The PI.fxn1 instrument invokes a test module referred to as PI.fxn1. The PI.fxn2 instrument invokes a test module referred to as PI.fxn2. 

At stage B the concurrent instrument test environment evaluates the instrumented program for conformance to concurrent instrument constraints before allowing access to the instrument program instructions or test modules. The concurrent instrument test environment evaluates the instrumented program for compliance with the current instrument constraints before testing the instrumented program . In some embodiments the concurrent instrument test environment ensures compliance before testing begins. In some embodiments the concurrent instrument test environment ensures constraint compliance while testing. Some embodiments implement the concurrent instrument test environment as an abstract constructor or a factory object for the instruments. The factory object defines methods for creating each class of instrument. For the Active Instrument class another abstract constructor can be defined with concrete constructors for each of the sub classes.

At block the testing tool selects a code unit to interpret in accordance with program execution. The testing tool selects a next line of code or next function to be interpreted.

At block the testing tool determines whether the code unit is a test instrument. For example the testing unit determines whether the code unit begins with or includes a string that corresponds to an instrument classification. In some embodiments the testing tool can check comments for a flag that indicates the code unit is an instrument. In some embodiments instruments are distinguished from the program with markers or delimiters. If the code unit is a test instrument then control flows to block . Otherwise control flows to block .

At block the testing tool determines a classification of the instrument. The testing tool can perform string compares against names of the classes. The operation of determining the classification may be incorporated within determining whether the code unit is an instrument in block . For example if the code unit did not indicate one of the classifications then the code unit was determined not to be an instrument. When determining that the code unit is an instrument the testing tool may at the same time determine the classification.

At block the testing tool determines whether the instrument is an exclusive instrument. If the instrument is an exclusive instrument then control flows to block . If the instrument is not an exclusive instrument then control flows to block .

At block the testing tool determines whether another exclusive instrument is currently instantiated. The testing tool tracks instantiation of instruments. For example the testing tool increments a counter when an exclusive instrument is instantiated and decrements the counter when the exclusive instrument is terminated. In some embodiments the testing tool instantiates an exclusive instrument with a specific process identifier and or in a specific execution space. If the process identifier is active or the execution space is not empty then another exclusive instrument is currently instantiated or running. If another exclusive instrument is currently instantiated then control flows to block . If another exclusive instrument is not currently instantiated then control flows to block .

At block the testing tool records an indication of the instrument and instantiates the instrument. Recording an indication of the instrument can take different forms examples of which include incrementing an exclusive instrument counter and recording location of the instrument and name of the instrument. Control flows back to block from block .

At block the testing tool generates a copy of the program under test with the currently instantiated exclusive instrument removed. Since instantiation of the currently selected exclusive instrument would violate the concurrent instrument constraint for exclusive instruments the testing tool generates a different version of the instrumented program that would allow the currently selected exclusive instrument to be instantiated. The different version removes the currently instantiated exclusive instrument. Hence testing results can be generated for both exclusive instruments. In some embodiments the testing tool generates a notification of the conflict and conditions creation of the different instrumented program on a response from the developer. In some embodiments the testing tool can be configured to generate different versions of the instrumented program when a constraint violation is detected remove the violating instrument and or generate a notification or log event. The testing tool can also be configured to run the different version of the instrumented program upon completion of running the current instrumented program.

At block the instrument is removed from the program. The testing tool deletes or comments out the exclusive instrument of the currently selected code unit. Embodiments do not necessarily remove the instrument. Embodiments can move on to the next code unit. Control flows from block back to block .

If the currently selected instrument was determined not to be classified as an exclusive instrument at block then the testing tool determines whether the currently selected instrument is classified as an active instrument at block . If the instrument is classified as an active instrument then control flows to block . If the instrument is not classified as an active instrument then control flows to block .

At block the testing tool determines whether the currently selected instrument is classified in a sub class of another instrument that is already instantiated. For example an instrument that commands the testing tool to run the instrumented program twice is classified as an Active Instrument and within a sub class for instruments that set execution commands which will be referred to as the ExecCommand sub class. The testing tool tracks instantiation of the different sub classes of the Active Instrument class. The testing tool checks a counter for instantiated ExecCommand intruments. If the currently selected instrument is within the ExecCommand sub class and the counter for the ExecComand sub class indicates that another ExecCommand instrument has been instantiated and not terminated e.g. the counter is 1 then the testing tool determines that another instrument within the same sub class has been instantiated and control flows to block . If the currently selected instrument is in a different sub class then control flows to block .

At block the testing tool records an indication of the instrument and instantiates the currently selected instrument. An example of recording an indication of the instrument includes recording the sub class name associating a counter with the sub class name and incrementing the counter. Recording an indication of the instrument can also include recording location of the instrument. In some embodiments the testing tool does not maintain a counter but records an identifier of the sub class when an instrument of the sub class is instantiated. Control flows back to block from block .

At block the testing tool generates a copy of the program under test with the currently instantiated same sub class instrument removed. Since instantiation of the currently selected active instrument would violate the concurrent instrument constraint for active instruments in a same sub class the testing tool generates a different version of the instrumented program that would allow the currently selected active instrument to be instantiated. The different version removes the currently instantiated same sub class active instrument. As with the exclusive instrument testing results can be generated for both active instruments in the same sub class. In some embodiments the testing tool generates a notification of the conflict and conditions creation of the different instrumented program on a response from the developer. In some embodiments the testing tool can be configured to generate different versions of the instrumented program when a constraint violation is detected remove the violating instrument and or generate a notification or log event. The testing tool can also be configured to run the different version of the instrumented program upon completion of running the current instrumented program.

At block the instrument of the currently selected code unit is removed from the instrumented program. As with block the testing tool can comment out the instrument delete the instrument or skip over the instrument. Control flows from block back to block .

At block the testing tool determines whether the instrument is an exclusive instrument. The testing tool can analyze the instrument to determine whether the instrument includes an identifier or name that represents the Exclusive instrument class. If the instrument is not an Exclusive instrument then control flows to block . If the instrument is an exclusive instrument then control flows to block .

At block the testing tool records location and an identifier of the exclusive instrument. For example the testing tool records a line number and the instrument name.

At block the testing tool increments a count of exclusive instruments. In some embodiments the instrument identifiers include information that indicates classification of the instrument. If the instrument identifier indicates the classification then the testing tool can uses the instrument identifier to track exclusive instruments without a counter.

At block the testing tool determines whether the exclusive instrument count is greater than 1. If the exclusive count is greater than 1 then control flows to block . Otherwise control flows to block .

At block the testing tool generates a notification that the instrumented program has exclusive instruments that will be instantiated concurrently. The testing tool creates a message or log entry that indicates the concurrent constraint violation and the exclusive instruments. The notification can be supplied upon detection of the violation in order to allow a user to decide which of the exclusive instruments to remove. In some embodiments the information is provided after the instrumented program has been evaluated to give the user a global view of concurrent constraint violations. Control flows from block to block .

If the testing tool determined that the instrument was not exclusive at block then the testing tool determines if the instrument is an active instrument at block . If the instrument is an active instrument then control flows to block . If the instrument is neither an active instrument nor an exclusive instrument then control flows to block . This flowchart example presumes that the only remaining classification is a passive instrument which has no concurrency constraints in this example. Embodiments are not so limited however. Embodiments can implement additional instrument classes beyond Exclusive and Active.

At block the testing tool records location and an identifier of the instrument to track occurrence of the sub class. The identifier of the active instrument indicates a representation of the sub class. For example the identifier includes an indication of the Active instrument class a demarcation and then the sub class.

At block the testing tool determines whether the sub class has occurred more than once. The testing tool can maintain a list of sub class identifiers encountered in the instrumented program. When the testing tool encounters an Active instrument the testing tool compares the instrument sub class to the list. If the sub class is already represented in the list then the instrument would violate the concurrent instrument constraints for that sub class. Otherwise the testing tool records an indication of the sub class of the Active instrument in the list. If the testing tool determines that the same sub class has already been encountered in the instrumented program then control flows to block . If the testing tool has not previously encountered the same sub class then control flows to block .

At block the testing tool determines whether there are additional instruments in the instrumented program to evaluate. If there are still instruments to evaluate then control flows back to block . If the testing tool has evaluated all of the instruments in the instrumented program then control flows to block .

At block the testing tool determines whether any notifications have been generated. If no notifications have been generated then control flows to block . If notifications have been generated then control flows to block .

At block the testing tool generates an executable of the instrumented program and runs the executable.

At block the testing tool supplies the notifications. For example the testing tool displays the notifications in a user interface. As stated earlier the notifications can be displayed as they are generated instead of accumulating the notifications. As another example of supplying the notifications the testing tool records the notifications in an evaluation log.

The flowcharts in this description are provided to aid in understanding embodiments and should not be used to limit embodiments or scope of the claims. Embodiments can perform some of the operations depicted in the flowcharts in a different order in parallel can perform different operations and can perform fewer operations. For instance the operations depicted in blocks and can be partially merged. Determining that an instrument is an exclusive instrument determines that a code unit is an instrument while at the same time determining the classification. In additional operations can be performed to determine whether an exclusive instrument has limited duration during execution of the instrumented program. In the case of a limited duration for an Exclusive instrument or sub class of Active instrument additional operations can be performed to determine whether exclusive instruments are concurrent and whether same sub class Active instruments are concurrent. Thus notifications would be generated when concurrency is detected for these scenarios. And notifications would not be generated if an instrumented program has multiple exclusive instruments that will not be instantiated concurrently. Similarly notifications would not be generated for multiple same sub class Active instruments that will not run concurrently.

As will be appreciated by one skilled in the art aspects of the present inventive subject matter may be embodied as a system method or computer program product. Accordingly aspects of the present inventive subject matter may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present inventive subject matter may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. A computer readable storage medium does not include transitory propagating signals.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present inventive subject matter may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present inventive subject matter are described with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the inventive subject matter. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

While the embodiments are described with reference to various implementations and exploitations it will be understood that these embodiments are illustrative and that the scope of the inventive subject matter is not limited to them. In general techniques for classification based concurrent instrument constraints as described herein may be implemented with facilities consistent with any hardware system or hardware systems. Many variations modifications additions and improvements are possible.

Plural instances may be provided for components operations or structures described herein as a single instance. Finally boundaries between various components operations and data stores are somewhat arbitrary and particular operations are illustrated in the context of specific illustrative configurations. Other allocations of functionality are envisioned and may fall within the scope of the inventive subject matter. In general structures and functionality presented as separate components in the exemplary configurations may be implemented as a combined structure or component. Similarly structures and functionality presented as a single component may be implemented as separate components. These and other variations modifications additions and improvements may fall within the scope of the inventive subject matter.

