---

title: Controlling access to a resource in a distributed computing system with a distributed access request queue
abstract: Controlling access to a resource in a distributed computing system that includes nodes having a status field, a next field, a source data buffer, and that are characterized by a unique node identifier, where controlling access includes receiving a request for access to the resource implemented as an active message that includes the requesting node's unique node identifier, the value stored in the requesting node's source data buffer, and an instruction to perform a reduction operation with the value stored in the requesting node's source data buffer and the value stored in the receiving node's source data buffer; returning the requesting node's unique node identifier as a result of the reduction operation; and updating the status and next fields to identify the requesting node as a next node to have sole access to the resource.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009312&OS=09009312&RS=09009312
owner: International Business Machines Corporation
number: 09009312
owner_city: Armonk
owner_country: US
publication_date: 20121102
---
This application is a continuation application of and claims priority from U.S. patent application Ser. No. 12 721 910 filed on Mar. 11 2010.

The field of the invention is data processing or more specifically methods apparatus and products for controlling access to a resource in a distributed computing system.

The development of the EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time computer systems have evolved into extremely complicated devices. Today s computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components application programs operating systems processors buses memory input output devices and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher more sophisticated computer software has evolved to take advantage of the higher performance of the hardware resulting in computer systems today that are much more powerful than just a few years ago.

Distributed computing is an area of computer technology that has experienced advances. Distributed computing generally refers to computing with multiple semi autonomous computer systems that communicate through a data communications network. The semi autonomous computer systems interact with one another in order to achieve a common goal. A computer program or application that executes in a distributed computing system may be referred to as a distributed program. Distributed computing may also refers to the use of distributed computing systems to solve computational problems. In distributed computing a problem may be divided into many tasks each of which may be solved by one of the semi autonomous computer systems.

Some distributed computing systems are optimized to perform parallel computing. Parallel computing is the simultaneous execution of the same task split up and specially adapted on multiple processors in order to obtain results faster. Parallel computing is based on the fact that the process of solving a problem usually can be divided into smaller tasks which may be carried out simultaneously with some coordination.

Parallel computers execute parallel algorithms. A parallel algorithm can be split up to be executed a piece at a time on many different processing devices and then put back together again at the end to get a data processing result. Some algorithms are easy to divide up into pieces. Splitting up the job of checking all of the numbers from one to a hundred thousand to see which are primes could be done for example by assigning a subset of the numbers to each available processor and then putting the list of positive results back together. In this specification the multiple processing devices that execute the individual pieces of a parallel program are referred to as compute nodes. A parallel computer is composed of compute nodes and other processing nodes as well including for example input output I O nodes and service nodes.

Parallel algorithms are valuable because it is faster to perform some kinds of large computing tasks via a parallel algorithm than it is via a serial non parallel algorithm because of the way modern processors work. It is far more difficult to construct a computer with a single fast processor than one with many slow processors with the same throughput. There are also certain theoretical limits to the potential speed of serial processors. On the other hand every parallel algorithm has a serial part and so parallel algorithms have a saturation point. After that point adding more processors does not yield any more throughput but only increases the overhead and cost.

Parallel algorithms are designed also to optimize one more resource the data communications requirements among the nodes of a parallel computer. There are two ways parallel processors communicate shared memory or message passing. Shared memory processing needs additional locking for the data and imposes the overhead of additional processor and bus cycles and also serializes some portion of the algorithm.

Message passing processing uses high speed data communications networks and message buffers but this communication adds transfer overhead on the data communications networks as well as additional memory need for message buffers and latency in the data communications among nodes. Designs of parallel computers use specially designed data communications links so that the communication overhead will be small but it is the parallel algorithm that decides the volume of the traffic.

Many data communications network architectures are used for message passing among nodes in parallel computers. Compute nodes may be organized in a network as a torus or mesh for example. Also compute nodes may be organized in a network as a tree. A torus network connects the nodes in a three dimensional mesh with wrap around links. Every node is connected to its six neighbors through this torus network and each node is addressed by its x y z coordinate in the mesh. In such a manner a torus network lends itself to point to point operations. In a tree network the nodes typically are connected into a binary tree each node has a parent and two children although some nodes may only have zero children or one child depending on the hardware configuration . Although a tree network typically is inefficient in point to point communication a tree network does provide high bandwidth and low latency for certain collective operations message passing operations where all compute nodes participate simultaneously such as for example an allgather operation. In computers that use a torus and a tree network the two networks typically are implemented independently of one another with separate routing circuits separate physical links and separate message buffers.

Although distributed computing environments are more computationally powerful and efficient in data processing than many non distributed computing environments such distributed computing environments still present substantial challenges to the science of automated computing machinery. Resource allocation and access among nodes in such distributed computing environments for example is just one area of distributed computing that present substantial challenges to the science of automated computing machinery.

Methods apparatus and products for controlling access to a resource in a distributed computing system are disclosed. The distributed computing system includes a plurality of nodes with each node includes a status field a next field a source data buffer and a destination data buffer. Each node is characterized by a unique node identifier. Controlling access to a resource in the distributed computing system includes receiving as an active message from a requesting node by all other nodes a request for access to the resource. The active message includes the requesting node s unique node identifier the value stored in the requesting node s source data buffer and an instruction to perform a reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer.

For a receiving node having a value in the status field that identifies the receiving node as a node most recently queued for access to the resource controlling access to the resource includes returning as a result of the reduction operation the requesting node s unique node identifier. Returning the requesting node s unique node identifier includes storing the requesting node s unique node identifier in the source data buffer of the receiving node and performing the reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer.

Controlling access to the resource also includes updating the status field and next field to identify the requesting node as a next node to have sole access to the resource. Updating the status field and next field includes storing in the next field of the receiving node the requesting node s unique node identifier.

For each of the other receiving nodes controlling access to the resource includes returning to the requesting node as a result of the reduction operation a value other than the requesting node s unique node identifier. Returning a value other than the requesting node s unique node identifier includes storing a predefined value in the source data buffer and performing the reduction operation.

The foregoing and other objects features and advantages of the invention will be apparent from the following more particular descriptions of exemplary embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of exemplary embodiments of the invention.

Exemplary methods apparatus and products for controlling access to a resource in a distributed computing system in accordance with embodiments of the present invention are described with reference to the accompanying drawings beginning with . illustrates an exemplary distributed computing system for controlling access to a resource according to embodiments of the present invention. The system of includes a parallel computer non volatile memory for the computer in the form of data storage device an output device for the computer in the form of printer and an input output device for the computer in the form of computer terminal . Parallel computer in the example of includes a plurality of compute nodes .

The compute nodes are coupled for data communications by several independent data communications networks including a Joint Test Action Group JTAG network a global combining network which is optimized for collective operations and a torus network which is optimized point to point operations. The global combining network is a data communications network that includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. Each data communications network is implemented with data communications links among the compute nodes . The data communications links provide data communications for parallel operations among the compute nodes of the parallel computer. The links between compute nodes are bi directional links that are typically implemented using two separate directional data communications paths.

In addition the compute nodes of parallel computer are organized into at least one operational group of compute nodes for collective parallel operations on parallel computer . An operational group of compute nodes is the set of compute nodes upon which a collective parallel operation executes. Collective operations are implemented with data communications among the compute nodes of an operational group. Collective operations are those functions that involve all the compute nodes of an operational group. A collective operation is an operation a message passing computer program instruction that is executed simultaneously that is at approximately the same time by all the compute nodes in an operational group of compute nodes. Such an operational group may include all the compute nodes in a parallel computer or a subset all the compute nodes. Collective operations are often built around point to point operations. A collective operation requires that all processes on all compute nodes within an operational group call the same collective operation with matching arguments. A broadcast is an example of a collective operation for moving data among compute nodes of an operational group. A reduce operation is an example of a collective operation that executes arithmetic or logical functions on data distributed among the compute nodes of an operational group. An operational group may be implemented as for example an MPI communicator. 

 MPI refers to Message Passing Interface a prior art parallel communications library a module of computer program instructions for data communications on parallel computers. Examples of prior art parallel communications libraries that may be improved for use with systems according to embodiments of the present invention include MPI and the Parallel Virtual Machine PVM library. PVM was developed by the University of Tennessee The Oak Ridge National Laboratory and Emory University. MPI is promulgated by the MPI Forum an open group with representatives from many organizations that define and maintain the MPI standard. MPI at the time of this writing is a de facto standard for communication among compute nodes running a parallel program on a distributed memory parallel computer. This specification sometimes uses MPI terminology for ease of explanation although the use of MPI as such is not a requirement or limitation of the present invention.

Some collective operations have a single originating or receiving process running on a particular compute node in an operational group. For example in a broadcast collective operation the process on the compute node that distributes the data to all the other compute nodes is an originating process. In a gather operation for example the process on the compute node that received all the data from the other compute nodes is a receiving process. The compute node on which such an originating or receiving process runs is referred to as a logical root.

Most collective operations are variations or combinations of four basic operations broadcast gather scatter and reduce. The interfaces for these collective operations are defined in the MPI standards promulgated by the MPI Forum. Algorithms for executing collective operations however are not defined in the MPI standards. In a broadcast operation all processes specify the same root process whose buffer contents will be sent. Processes other than the root specify receive buffers. After the operation all buffers contain the message from the root process.

In a scatter operation the logical root divides data on the root into segments and distributes a different segment to each compute node in the operational group. In scatter operation all processes typically specify the same receive count. The send arguments are only significant to the root process whose buffer actually contains sendcount N elements of a given data type where N is the number of processes in the given group of compute nodes. The send buffer is divided and dispersed to all processes including the process on the logical root . Each compute node is assigned a sequential identifier termed a rank. After the operation the root has sent sendcount data elements to each process in increasing rank order. Rank 0 receives the first sendcount data elements from the send buffer. Rank 1 receives the second sendcount data elements from the send buffer and so on.

A gather operation is a many to one collective operation that is a complete reverse of the description of the scatter operation. That is a gather is a many to one collective operation in which elements of a datatype are gathered from the ranked compute nodes into a receive buffer in a root node.

A reduce operation is also a many to one collective operation that includes an arithmetic or logical function performed on two data elements. All processes specify the same count and the same arithmetic or logical function. After the reduction all processes have sent count data elements from compute node send buffers to the root process. In a reduction operation data elements from corresponding send buffer locations are combined pair wise by arithmetic or logical operations to yield a single corresponding element in the root process s receive buffer. Application specific reduction operations can be defined at runtime. Parallel communications libraries may support predefined operations. MPI for example provides the following pre defined reduction operations 

In addition to compute nodes the parallel computer includes input output I O nodes coupled to compute nodes through the global combining network . The compute nodes in the parallel computer are partitioned into processing sets such that each compute node in a processing set is connected for data communications to the same I O node. Each processing set therefore is composed of one I O node and a subset of compute nodes . The ratio between the number of compute nodes to the number of I O nodes in the entire system typically depends on the hardware configuration for the parallel computer. For example in some configurations each processing set may be composed of eight compute nodes and one I O node. In some other configurations each processing set may be composed of sixty four compute nodes and one I O node. Such example are for explanation only however and not for limitation. Each I O nodes provide I O services between compute nodes of its processing set and a set of I O devices. In the example of the I O nodes are connected for data communications I O devices through local area network LAN implemented using high speed Ethernet.

The parallel computer of also includes a service node coupled to the compute nodes through one of the networks . Service node provides services common to pluralities of compute nodes administering the configuration of compute nodes loading programs into the compute nodes starting program execution on the compute nodes retrieving results of program operations on the computer nodes and so on. Service node runs a service application and communicates with users through a service application interface that runs on computer terminal .

The system of operates generally for controlling access to a resource in a distributed computing system a parallel computer according to embodiments of the present invention. A resource as the term is used in this specification refers to any physical or virtual component of limited availability to one or more nodes within a distributed computing system. Examples of such resources for which access may be controlled in accordance with embodiments of the present invention include processor time portions of physical computer memory portions of virtual computer memory hard disk drive space data communications network throughput electrical power external devices input output I O operations a particular data structure and so on as will occur to readers of skill in the art. In the system of for example the random access memory operations of the I O nodes throughput of the global combining network throughput of the point to point network throughput of the JTAG network the printer storage space on the data storage device may all be a resource in the distributed computing system for which access is controlled in accordance with embodiments of the present invention.

The status field is a data structure configured to store a value indicating a state of a node s relationship to a resource. The data structure may be implemented in a variety of ways as a buffer a variable list table linked list queue and so on as will occur to readers of skill in the art. In some embodiments of the present invention a node s relationship to a resource may be in one of three states 

When the status field of a node is set to a next state the node upon completion of access to the resource is configured to pass sole access to the resource to another node. The next field is a data structure configured to store an identifier of the next node the unique node identifier of the next node.

The unique node identifier may be any value that uniquely identifies a node amongst other nodes. Such an identifier may be implemented as a rank identifier specified for the node in accordance with MPI messaging protocols a rank in a tree network an identifier designated by a user level application a network device identifier of the node and other types of identifiers as will occur to readers of skill in the art.

The combination of the status and next fields of the plurality of compute nodes in the example of operate as a distributed access request queue where at any particular moment in time one and only one of the status fields identifies a most recently queued node one or more status fields indicates that control of the resource is to passed to a next node when access is completed and the next fields associated with the status fields indicating control to be passed specify the next node to which control is to be passed.

The source data buffer is a data structure used to store workpiece data for collective operations among the compute nodes . When the collective operations are implemented with MPI for example the source data buffer may be referred to and operate as a send buffer as described above. In a similar manner the destination data buffer is a data structure designated as storage for results of collective operations. Again in embodiments that implement collective operations with MPI the destination data buffer may be referred to and operate as a receive data buffer as described above.

Stored in RAM is a messaging module a module of automated computing machinery that is configured to among other actions control access to a resource in the system of in accordance with embodiments of the present invention. That is the messaging module enables a node to control access to a resource in accordance with embodiments of the present invention. In describing the operations of a node in controlling access to a resource below a reader of skill in the art will understand that messaging module enables such operations of the node.

The system of may operate generally for controlling access to a resource by receiving by a receiving node having a value in the status field that identifies the receiving node as a node most recently queued for access to the resource from a requesting node a request for access to the resource. In the example of the request for access is implemented as an active message broadcast by the requesting node to a plurality of nodes in the distributed computing system. In some embodiments of the present invention in which the distributed computing system is configured in a similar manner as that of parallel computer in the example of the receiving node and requesting node may be organized as part of the operational group . In such embodiments the requesting node may request access to the resource by broadcasting the active message to all compute nodes in the operational group and in other embodiments by broadcasting the active message to all compute nodes regardless of the organization or the operational group .

Active messages are communications primitives for exploiting performance and flexibility of modern computer interconnects. Active messages operate as a lower level mechanism than other types of messaging. In some embodiments an active message includes a header that in turn contains an address of a userspace handler to be executed upon message arrival with the contents of the active message passed as an argument to the handler. In other embodiments an active message may carry the actual compiled code itself rather than a pointer to the code. These embodiments of active messages may also carry data for processing as well. On arrival at the receiving node the compiled code is executed making use of any data in the message and any data in the receiving node.

In the example of the active message includes the requesting node s unique node identifier the value stored in the requesting node s source data buffer and an instruction to perform a reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer .

The active message in the example of may be implemented as a collective operation such as an MPI REDUCE or MPI ALLREDUCE operation. An instruction to perform a reduction operation included as part of such an active message may be implemented in a variety of ways including for example as executable computer program instructions or a handle specifying a particular reduction operation. In some embodiments for example the instruction may be implemented as a handle MPI BOR specifying a bitwise OR reduction operation in the MPI library.

The system of may also operate to control access to a resource by returning as a result of the reduction operation the requesting node s unique node identifier . Returning the requesting node s unique node identifier may be carried out by storing the requesting node s unique node identifier in the source data buffer of the receiving node and performing the reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer .

The system of may continue to control access to a resource in accordance with embodiments of the present invention by updating the status field and next field of the receiving node to identify the requesting node as a next node to have sole access to the resource. In the example of updating the status field and next field of the receiving node to identify the requesting node as a next node to have sole access to the resource includes storing in the next field of the receiving node the requesting node s unique node identifier .

In this way the next fields and status fields of the compute nodes operate as a distributed queue of access requests from nodes such that a single queue of access requests need not be maintained by a single arbiter that receives requests from all participating nodes. Such single queues require significant computational overhead on the part of the compute node configured as the arbiter. Instead the queue is distributed in pieces among all participating nodes and maintained individually by each node. A particular node in the exemplary system of is only aware the next node to have access to the resource after the particular node if any at all. Although each compute node in the example of rather than a single node in the arbiter example carries out some amount of data processing in maintaining the distributed access request queue the data processing overhead is spread out over many compute nodes operating in parallel thus increasing efficiency of maintaining an access request queue distributed across compute nodes in accordance with embodiments of the present invention.

The arrangement of nodes networks and I O devices making up the exemplary system illustrated in are for explanation only not for limitation of the present invention. Data processing systems capable of controlling access to a resource in a distributed computing system according to embodiments of the present invention may include additional nodes networks devices and architectures not shown in as will occur to those of skill in the art. Although the parallel computer in the example of includes sixteen compute nodes readers will note that parallel computers capable of controlling access to a resource in a distributed computing system according to embodiments of the present invention may include any number of compute nodes. In addition to Ethernet and JTAG networks in such data processing systems may support many data communications protocols including for example TCP Transmission Control Protocol IP Internet Protocol and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .

Controlling access to a resource in a distributed computing system according to embodiments of the present invention may be generally implemented on a parallel computer that includes a plurality of compute nodes. In fact such computers may include thousands of such compute nodes. Each compute node is in turn itself a kind of computer composed of one or more computer processors or processing cores its own computer memory and its own input output adapters. For further explanation therefore sets forth a block diagram of an exemplary compute node useful in a parallel computer capable of controlling access to resources according to embodiments of the present invention. The compute node of includes one or more processing cores as well as random access memory RAM . The processing cores are connected to RAM through a high speed memory bus and through a bus adapter and an extension bus to other components of the compute node . Stored in RAM is an application program a module of computer program instructions that carries out parallel user level data processing using parallel algorithms.

Also stored in RAM is a messaging module a library of computer program instructions that carry out parallel communications among compute nodes including point to point operations as well as collective operations. Application program executes collective operations by calling software routines in the messaging module . A library of parallel communications routines may be developed from scratch for use in systems according to embodiments of the present invention using a traditional programming language such as the C programming language and using traditional programming methods to write parallel communications routines that send and receive data among nodes on two independent data communications networks. Alternatively existing prior art libraries may be improved to operate according to embodiments of the present invention. Examples of prior art parallel communications libraries include the Message Passing Interface MPI library and the Parallel Virtual Machine PVM library.

The messaging module of has been adapted for controlling access to a resource in a distributed computing system. The messaging module of includes a status field a next field a source data buffer and a destination data buffer . The example messaging module and thereby the compute node is characterized by a unique node identifier . Other nodes not shown here coupled for data communications to the compute node through any of the gigabit Ethernet the JTAG master the point to point network or the collective operations network are also configured with a status field a next field a source data buffer and a destination data buffer and each of the other nodes is characterized by a unique node identifier .

The messaging module in the example of controls access to resource in accordance with embodiments of the present invention by receiving a request for access to the resource from a requesting node. Having received a request the compute node is characterized for clarity as a receiving node. In the example of the request for access is implemented as an active message broadcast by the requesting node to a plurality of nodes in the distributed computing system. The active message includes the requesting node s unique node identifier the value stored in the requesting node s source data buffer and an instruction to perform a reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer .

In the example of a value in the status field of the receiving node identifies the node as a node most recently queued for access to the resource. In the example of in controlling access to a resource in a distributed computing system in accordance with embodiments of the present invention the messaging module of a compute node identified as a node most recently queued for access to the resource upon receiving a request for access to the resource returns to the requesting node as a result of the reduction operation specified in the active message the requesting node s unique node identifier . Returning the requesting node s unique node identifier includes storing the requesting node s unique node identifier in the source data buffer of the receiving node and performing the reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer.

The messaging module may also be configured to update the status field and next field of the receiving node to identify the requesting node as a next node to have sole access to the resource. In the example of the messaging module may update the status field and next field by storing in the next field of the receiving node the requesting node s unique node identifier .

Also stored in RAM is an operating system a module of computer program instructions and routines for an application program s access to other resources of the compute node. It is typical for an application program and parallel communications library in a compute node of a parallel computer to run a single thread of execution with no user login and no security issues because the thread is entitled to complete access to all resources of the node. The quantity and complexity of tasks to be performed by an operating system on a compute node in a parallel computer therefore are smaller and less complex than those of an operating system on a serial computer with many threads running simultaneously. In addition there is no video I O on the compute node of another factor that decreases the demands on the operating system. The operating system may therefore be quite lightweight by comparison with operating systems of general purpose computers a pared down version as it were or an operating system developed specifically for operations on a particular parallel computer. Operating systems that may usefully be improved simplified for use in a compute node include UNIX Linux Microsoft XP AIX IBM s i5 OS and others as will occur to those of skill in the art.

The exemplary compute node of includes several communications adapters for implementing data communications with other nodes of a parallel computer. Such data communications may be carried out serially through RS 232 connections through external buses such as Universal Serial Bus USB through data communications networks such as IP networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly or through a network. Examples of communications adapters useful in systems that control access to a resource in a distributed computing system according to embodiments of the present invention include modems for wired communications Ethernet IEEE 802.3 adapters for wired network communications and 802.11b adapters for wireless network communications.

The data communications adapters in the example of include a Gigabit Ethernet adapter that couples example compute node for data communications to a Gigabit Ethernet . Gigabit Ethernet is a network transmission standard defined in the IEEE 802.3 standard that provides a data rate of 1 billion bits per second one gigabit . Gigabit Ethernet is a variant of Ethernet that operates over multimode fiber optic cable single mode fiber optic cable or unshielded twisted pair.

The data communications adapters in the example of include a JTAG Slave circuit that couples example compute node for data communications to a JTAG Master circuit . JTAG is the usual name used for the IEEE 1149.1 standard entitled Standard Test Access Port and Boundary Scan Architecture for test access ports used for testing printed circuit boards using boundary scan. JTAG is so widely adapted that at this time boundary scan is more or less synonymous with JTAG. JTAG is used not only for printed circuit boards but also for conducting boundary scans of integrated circuits and is also useful as a mechanism for debugging embedded systems providing a convenient back door into the system. The example compute node of may be all three of these It typically includes one or more integrated circuits installed on a printed circuit board and may be implemented as an embedded system having its own processor its own memory and its own I O capability. JTAG boundary scans through JTAG Slave may efficiently configure processor registers and memory in compute node for use in controlling access to a resource in a distributed computing system according to embodiments of the present invention.

The data communications adapters in the example of includes a Point To Point Adapter that couples example compute node for data communications to a network that is optimal for point to point message passing operations such as for example a network configured as a three dimensional torus or mesh. Point To Point Adapter provides data communications in six directions on three communications axes x y and z through six bidirectional links x x y y z and z .

The data communications adapters in the example of includes a Global Combining Network Adapter that couples example compute node for data communications to a network that is optimal for collective message passing operations on a global combining network configured for example as a binary tree. The Global Combining Network Adapter provides data communications through three bidirectional links two to children nodes and one to a parent node .

Example compute node includes two arithmetic logic units ALUs . ALU is a component of each processing core and a separate ALU is dedicated to the exclusive use of Global Combining Network Adapter for use in performing the arithmetic and logical functions of reduction operations. Computer program instructions of a reduction routine in parallel communications library may latch an instruction for an arithmetic or logical function into instruction register . When the arithmetic or logical function of a reduction operation is a sum or a logical or for example Global Combining Network Adapter may execute the arithmetic or logical operation by use of ALU in processor or typically much faster by use dedicated ALU .

The example compute node of includes a direct memory access DMA controller which is computer hardware for direct memory access and a DMA engine which is computer software for direct memory access. The DMA engine of is typically stored in computer memory of the DMA controller . Direct memory access includes reading and writing to memory of compute nodes with reduced operational burden on the central processing units . A DMA transfer essentially copies a block of memory from one location to another typically from one compute node to another. While the CPU may initiate the DMA transfer the CPU does not execute it.

For further explanation illustrates an exemplary Point To Point Adapter useful in distributed computing systems capable of controlling access to a resource according to embodiments of the present invention. Point To Point Adapter is designed for use in a data communications network optimized for point to point operations a network that organizes compute nodes in a three dimensional torus or mesh. Point To Point Adapter in the example of provides data communication along an x axis through four unidirectional data communications links to and from the next node in the x direction and to and from the next node in the x direction . Point To Point Adapter also provides data communication along a y axis through four unidirectional data communications links to and from the next node in the y direction and to and from the next node in the y direction . Point To Point Adapter in also provides data communication along a z axis through four unidirectional data communications links to and from the next node in the z direction and to and from the next node in the z direction .

For further explanation illustrates an exemplary Global Combining Network Adapter useful in systems capable of controlling access to a resource in a distributed computing system according to embodiments of the present invention. Global Combining Network Adapter is designed for use in a network optimized for collective operations a network that organizes compute nodes of a parallel computer in a binary tree. Global Combining Network Adapter in the example of provides data communication to and from two children nodes through four unidirectional data communications links . Global Combining Network Adapter also provides data communication to and from a parent node through two unidirectional data communications links .

For further explanation sets forth a line drawing illustrating an exemplary data communications network optimized for point to point operations useful in distributed computing systems capable of controlling access to a resource in accordance with embodiments of the present invention. In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes.

The data communications links are implemented with point to point data communications adapters similar to the one illustrated for example in with data communications links on three axes x y and z and to and fro in six directions x x y y z and z . The links and compute nodes are organized by this data communications network optimized for point to point operations into a three dimensional mesh . The mesh has wrap around links on each axis that connect the outermost compute nodes in the mesh on opposite sides of the mesh . These wrap around links form part of a torus . Each compute node in the torus has a location in the torus that is uniquely specified by a set of x y z coordinates. Readers will note that the wrap around links in the y and z directions have been omitted for clarity but are configured in a similar manner to the wrap around link illustrated in the x direction. For clarity of explanation the data communications network of is illustrated with only 27 compute nodes but readers will recognize that a data communications network optimized for point to point operations for use in controlling access to a resource in a distributed computing system in accordance with embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes.

For further explanation sets forth a line drawing illustrating an exemplary data communications network optimized for collective operations useful in distributed computing systems capable of controlling access to a resource in accordance with embodiments of the present invention. The example data communications network of includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes. The data communications links are implemented with global combining network adapters similar to the one illustrated for example in with each node typically providing data communications to and from two children nodes and data communications to and from a parent node with some exceptions. Nodes in a binary tree may be characterized as a physical root node branch nodes and leaf nodes . The root node has two children but no parent. The leaf nodes each has a parent but leaf nodes have no children. The branch nodes each has both a parent and two children. The links and compute nodes are thereby organized by this data communications network optimized for collective operations into a binary tree . For clarity of explanation the data communications network of is illustrated with only 31 compute nodes but readers will recognize that a data communications network optimized for collective operations for use in systems for controlling access to a resource in a distributed computing system in accordance with embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes.

In the example of each node in the tree is assigned a unit identifier referred to as a rank . A node s rank uniquely identifies the node s location in the tree network for use in both point to point and collective operations in the tree network. The ranks in this example are assigned as integers beginning with 0 assigned to the root node 1 assigned to the first node in the second layer of the tree 2 assigned to the second node in the second layer of the tree 3 assigned to the first node in the third layer of the tree 4 assigned to the second node in the third layer of the tree and so on. For ease of illustration only the ranks of the first three layers of the tree are shown here but all compute nodes in the tree network are assigned a unique rank.

For further explanation sets forth a further exemplary distributed computing system for controlling access to a resource according to embodiments of the present invention in which the distributed computing system is implemented as a hybrid computing environment. A hybrid computing environment as the term is used in this specification is a computing environment in that it includes computer processors operatively coupled to computer memory so as to implement data processing in the form of execution of computer program instructions stored in the memory and executed on the processors. The hybrid computing environment of includes one compute node that represents a small separate hybrid computing environment which when taken with other similar compute nodes together make up a larger hybrid computing environment.

The example compute node of may carry out principal user level computer program execution accepting administrative services such as initial program loads and the like from a service application executing on a service node connected to the compute node through a data communications network. The example compute node may also be coupled for data communications to one or more input output I O nodes that enable the compute node to gain access to data storage and other I O functionality. The I O nodes and service node may be connected to the example compute node to other compute nodes in the larger hybrid computing environment and to I O devices through a local area network LAN implemented using high speed Ethernet or a data communications fabric of another fabric type as will occur to those of skill in the art. I O devices useful in a larger hybrid computing environment that includes the compute node may include non volatile memory for the computing environment in the form of data storage device an output device for the hybrid computing environment in the form of printer and a user I O device in the form of computer terminal that executes a service application interface that provides to a user an interface for configuring compute nodes in the hybrid computing environment and initiating execution by the compute nodes of principal user level computer program instructions.

The compute node in the example of is illustrated in an expanded view to aid a more detailed explanation of a hybrid computing environment that may be combined with other hybrid computing environments other compute nodes to form a larger hybrid computing environment. The compute node in the example of includes a host computer . A host computer is a host in the sense that it is the host computer that carries out interface functions between a compute node and other components of the hybrid computing environment external to any particular compute node. That is it is the host computer that executes initial boot procedures power on self tests basic I O functions accepts user level program loads from service nodes and so on.

The host computer in the example of includes a computer processor operatively coupled to computer memory Random Access Memory RAM through a high speed memory bus . The processor in each host computer has a set of architectural registers that defines the host computer architecture.

The example compute node of also includes one or more accelerators . An accelerator is an accelerator in that each accelerator has an accelerator architecture that is optimized with respect to the host computer architecture for speed of execution of a particular class of computing functions. Such accelerated computing functions include for example vector processing floating point operations and others as will occur to those of skill in the art. Each accelerator in the example of includes a computer processor operatively coupled to RAM through a high speed memory bus . Stored in RAM of the host computer and the accelerators is an operating system . Operating systems useful in host computers and accelerators of hybrid computing environments according to embodiments of the present invention include UNIX Linux Microsoft XP Microsoft Vista Microsoft NT AIX IBM s i5 OS and others as will occur to those of skill in the art. There is no requirement that the operating system in the host computers should be the same operating system used on the accelerators.

The processor of each accelerator has a set of architectural registers that defines the accelerator architecture. The architectural registers of the processor of each accelerator are different from the architectural registers of the processor in the host computer . The architectural registers are registers that are accessible by computer program instructions that execute on each architecture registers such as an instruction register a program counter memory index registers stack pointers and the like. With differing architectures it would be uncommon although possible for a host computer and an accelerator to support the same instruction sets. As such computer program instructions compiled for execution on the processor of an accelerator generally would not be expected to execute natively on the processor of the host computer and vice versa. Moreover because of the typical differences in hardware architectures between host processors and accelerators computer program instructions compiled for execution on the processor of a host computer generally would not be expected to execute natively on the processor of an accelerator even if the accelerator supported the instruction set of the host. The accelerator architecture in example of is optimized with respect to the host computer architecture for speed of execution of a particular class of computing functions. That is for the function or functions for which the accelerator is optimized execution of those functions will proceed faster on the accelerator than if they were executed on the processor of the host computer.

Examples of hybrid computing environments include a data processing system that in turn includes one or more host computers each having an x86 processor and accelerators whose architectural registers implement the PowerPC instruction set. Computer program instructions compiled for execution on the x86 processors in the host computers cannot be executed natively by the PowerPC processors in the accelerators. Readers will recognize in addition that some of the example hybrid computing environments described in this specification are based upon the Los Alamos National Laboratory LANL supercomputer architecture developed in the LANL Roadrunner project named for the state bird of New Mexico the supercomputer architecture that famously first generated a petaflop a million billion floating point operations per second. The LANL supercomputer architecture includes many host computers with dual core AMD Opteron processors coupled to many accelerators with IBM Cell processors the Opteron processors and the Cell processors having different architectures.

In the example of the host computer and the accelerators are adapted to one another for data communications by a system level message passing module SLMPM and two data communications fabrics of at least two different fabric types. A data communications fabric is a configuration of data communications hardware and software that implements a data communications coupling between a host computer and an accelerator. Examples of data communications fabric types include Peripheral Component Interconnect PCI PCI express PCIe Ethernet Infiniband Fibre Channel Small Computer System Interface SCSI External Serial Advanced Technology Attachment eSATA Universal Serial Bus USB and so on as will occur to those of skill in the art. In the example of the host computer and the accelerators are adapted to one another for data communications by a PCIe fabric through PCIe communications adapters and an Ethernet fabric through Ethernet communications adapters . The use of PCIe and Ethernet is for explanation not for limitation of the invention. Readers of skill in the art will immediately recognize that hybrid computing environments according to embodiments of the present invention may include fabrics of other fabric types such as for example PCI Infiniband Fibre Channel SCSI eSATA USB and so on.

An SLMPM is a module or library of computer program instructions that exposes an application programming interface API to user level applications for carrying out message based data communications between the host computer and the accelerator . Examples of message based data communications libraries that may be improved for use as an SLMPM according to embodiments of the present invention include 

In this example to support message based data communications between the host computer and the accelerator both the host computer and the accelerator have an SLMPM so that message based communications can both originate and be received on both sides of any coupling for data communications.

The SLMPM in this example operates generally for data processing in a hybrid computing environment by monitoring data communications performance for a plurality of data communications modes between the host computer and the accelerators receiving a request to transmit data according to a data communications mode from the host computer to an accelerator determining whether to transmit the data according to the requested data communications mode and if the data is not to be transmitted according to the requested data communications mode selecting another data communications mode and transmitting the data according to the selected data communications mode. In the example of the monitored performance is illustrated as monitored performance data stored by the SLMPM in RAM of the host computer during operation of the compute node .

A data communications mode specifies a data communications fabric type a data communications link and a data communications protocol . A data communications link is data communications connection between a host computer and an accelerator. In the example of a link between the host computer and the accelerator may include the PCIe connection or the Ethernet connection through the Ethernet network . A link between the host computer and the accelerator in the example of may include the PCIe connection or the Ethernet connection through the Ethernet network . Although only one link for each fabric type is illustrated between the host computer and the accelerator in the example of readers of skill in the art will immediately recognize that there may any number of links for each fabric type.

A data communications protocol is a set of standard rules for data representation signaling authentication and error detection required to send information from a host computer to an accelerator . In the example of the SLMPM may select one of several protocols for data communications between the host computer and the accelerator. Examples of such protocols include shared memory transfers SMT executed with a send and receive operations and direct memory access DMA executed with PUT and GET operations .

Shared memory transfer is a data communications protocol for passing data between a host computer and an accelerator into shared memory space allocated for such a purpose such that only one instance of the data resides in memory at any time. Consider the following as an example shared memory transfer between the host computer and the accelerator of . An application requests a transmission of data from the host computer to the accelerator in accordance with the SMT protocol. Such a request may include a memory address allocated for such shared memory. In this example the shared memory segment is illustrated in a memory location on the accelerator but readers will recognize that shared memory segments may be located on the accelerator on the host computer on both the host computer and the accelerator or even off the local compute node entirely so long as the segment is accessible as needed by the host and the accelerator. To carry out a shared memory transfer the SLMPM on the host computer establishes a data communications connection with the SLMPM executing on the accelerator by a handshaking procedure similar to that in the TCP protocol. The SLMPM then creates a message that includes a header and a payload data and inserts the message into a message transmit queue for a particular link of a particular fabric. In creating the message the SLMPM inserts in the header of the message an identification of the accelerator and an identification of a process executing on the accelerator. The SLMPM also inserts the memory address from the request into the message either in the header or as part of the payload data. The SLMPM also inserts the data to be transmitted in the message as part of the message payload data. The message is then transmitted by a communications adapter across a fabric to the SLMPM executing on the accelerator where the SLMPM stores the payload data the data that was transmitted in shared memory space in RAM in accordance with the memory address in the message.

Direct memory access DMA is a data communications protocol for passing data between a host computer and an accelerator with reduced operational burden on the computer processor . A DMA transfer essentially effects a copy of a block of memory from one location to another typically from a host computer to an accelerator or vice versa. Either or both a host computer and accelerator may include DMA controller and DMA engine an aggregation of computer hardware and software for direct memory access. Direct memory access includes reading and writing to memory of accelerators and host computers with reduced operational burden on their processors. A DMA engine of an accelerator for example may write to or read from memory allocated for DMA purposes while the processor of the accelerator executes computer program instructions or otherwise continues to operate. That is a computer processor may issue an instruction to execute a DMA transfer but the DMA engine not the processor carries out the transfer.

In the example of only the accelerator includes a DMA controller and DMA engine while the host computer does not. In this embodiment the processor on the host computer initiates a DMA transfer of data from the host to the accelerator by sending a message according to the SMT protocol to the accelerator instructing the accelerator to perform a remote GET operation. The configuration illustrated in the example of in which the accelerator is the only device containing a DMA engine is for explanation only not for limitation. Readers of skill in the art will immediately recognize that in many embodiments both a host computer and an accelerator may include a DMA controller and DMA engine while in yet other embodiments only a host computer includes a DMA controller and DMA engine.

To implement a DMA protocol in the hybrid computing environment of some memory region is allocated for access by the DMA engine. Allocating such memory may be carried out independently from other accelerators or host computers or may be initiated by and completed in cooperation with another accelerator or host computer. Shared memory regions allocated according to the SMA protocol for example may be memory regions made available to a DMA engine. That is the initial setup and implementation of DMA data communications in the hybrid computing environment of may be carried out at least in part through shared memory transfers or another out of band data communications protocol out of band with respect to a DMA engine. Allocation of memory to implement DMA transfers is relatively high in latency but once allocated the DMA protocol provides for high bandwidth data communications that requires less processor utilization than many other data communications protocols.

A direct PUT operation is a mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A direct PUT operation allows data to be transmitted and stored on the target device with little involvement from the target device s processor. To effect minimal involvement from the target device s processor in the direct PUT operation the origin DMA engine transfers the data to be stored on the target device along with a specific identification of a storage location on the target device. The origin DMA knows the specific storage location on the target device because the specific storage location for storing the data on the target device has been previously provided by the target DMA engine to the origin DMA engine.

A remote GET operation sometimes denominated an rGET is another mode of transmitting data from a DMA engine on an origin device to a DMA engine on a target device. A remote GET operation allows data to be transmitted and stored on the target device with little involvement from the origin device s processor. To effect minimal involvement from the origin device s processor in the remote GET operation the origin DMA engine stores the data in an storage location accessible by the target DMA engine notifies the target DMA engine directly or out of band through a shared memory transmission of the storage location and the size of the data ready to be transmitted and the target DMA engine retrieves the data from storage location.

Monitoring data communications performance for a plurality of data communications modes may include monitoring a number of requests in a message transmit request queue for a data communications link . In the example of each message transmit request queue is associated with one particular data communications link . Each queue includes entries for messages that include data to be transmitted by the communications adapters along a data communications link associated with queue.

Monitoring data communications performance for a plurality of data communications modes may also include monitoring utilization of a shared memory space . In the example of shared memory space is allocated in RAM of the accelerator. Utilization is the proportion of the allocated shared memory space to which data has been stored for sending to a target device and has not yet been read or received by the target device monitored by tracking the writes and reads to and from the allocated shared memory. In the hybrid computing environment of shared memory space any memory in fact is limited. As such a shared memory space may be filled during execution of an application program such that transmission of data from the host computer to an accelerator may be slowed or even stopped due to space limitations in the shared memory space.

In some embodiments of the present invention the hybrid computing environment of may be configured to operate as a parallel computing environment in which two or more instances the application program executes on two or more host computers in the parallel computing environment. In such embodiments monitoring data communications performance across data communications modes may also include aggregating data communications performance information across a plurality of instances of the application program executing on two or more host computers in a parallel computing environment. The aggregated performance information may be used to calculate average communications latencies for data communications modes average number of requests in data communications links of a particular fabric type average shared memory utilization among the plurality of host computers and accelerators in the parallel computing environment and so on as will occur to those of skill in the art. Any combination of such measures may be used by the SLMPM for both determining whether to transmit the data according to requested data communications mode and selecting another data communications mode for transmitting the data if the data is not to be transmitted according to the requested data communications mode.

The SLMPM of receives from an application program on the host computer a request to transmit data according to a data communications mode from the host computer to the accelerator . Such data may include computer program instructions compiled for execution by the accelerator such as an executable file of an accelerator application program work piece data for an accelerator application program files necessary for execution of an accelerator application program such as libraries databases drivers and the like. Receiving a request to transmit data according to a data communications mode may include receiving a request to transmit data by a specified fabric type receiving a request to transmit data through a specified data communications link from the host computer to the accelerator or receiving a request to transmit data from the host computer to the accelerator according to a protocol.

A request to transmit data according to a data communications mode may be implemented as a user level application function call through an API to the SLMPM a call that expressly specifies a data communications mode according to protocol fabric type and link. A request implemented as a function call may specify a protocol according to the operation of the function call itself. A dacs put function call for example may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of a DMA PUT operation. Such a call from the perspective of the calling application and the programmer who wrote the calling application represents a request to the SLMPM library to transmit data according to the default mode known to the programmer to be default mode associated with the express API call. The called function in this example dacs put may be coded in embodiments with multiple fabric types protocols and links to make its own determination whether to transmit the data according to the requested data communications mode that is according to the default mode of the called function. In a further example a dacs send instruction may represent a call through an API exposed by an SLMPM implemented as a DACS library to transmit data in the default mode of an SMT send operation where the called function dacs send is again coded in embodiments with multiple fabric types protocols and links to make its own determination whether to transmit the data according to the requested mode.

An identification of a particular accelerator in a function call may effectively specify a fabric type. Such a function call may include as a call parameters an identification of a particular accelerator. An identification of a particular accelerator by use of a PCIe ID for example effectively specifies a PCI fabric type. In another similar example an identification of a particular accelerator by use of a media access control MAC address of an Ethernet adapter effectively specifies the Ethernet fabric type. Instead of implementing the accelerator ID of the function call from an application executing on the host in such a way as to specify a fabric type the function call may only include a globally unique identification of the particular accelerator as a parameter of the call thereby specifying only a link from the host computer to the accelerator not a fabric type. In this case the function called may implement a default fabric type for use with a particular protocol. If the function called in the SLMPM is configured with PCIe as a default fabric type for use with the DMA protocol for example and the SLMPM receives a request to transmit data to the accelerator according to the DMA protocol a DMA PUT or DMA remote GET operation the function called explicitly specifies the default fabric type for DMA the PCIe fabric type.

In hybrid computing environments in which only one link of each fabric type adapts a single host computer to a single accelerator the identification of a particular accelerator in a parameter of a function call may also effectively specify a link. In hybrid computing environments where more than one link of each fabric type adapts a host computer and an accelerator such as two PCIe links connecting the host computer to the accelerator the SLMPM function called may implement a default link for the accelerator identified in the parameter of the function call for the fabric type specified by the identification of the accelerator.

The SLMPM in the example of also determines in dependence upon the monitored performance whether to transmit the data according to the requested data communications mode. Determining whether to transmit the data according to the requested data communications mode may include determining whether to transmit data by a requested fabric type whether to transmit data through a requested data communications link or whether to transmit data according to a requested protocol.

In hybrid computing environments according to embodiments of the present invention where monitoring data communications performance across data communications modes includes monitoring a number of requests in a message transmit request queue for a data communications link determining whether to transmit the data according to the requested data communications mode may be carried out by determining whether the number of requests in the message transmit request queue exceeds a predetermined threshold. In hybrid computing environments according to embodiments of the present invention where monitoring data communications performance for a plurality of data communications modes includes monitoring utilization of a shared memory space determining whether to transmit the data according to the requested data communications mode may be carried out by determining whether the utilization of the shared memory space exceeds a predetermined threshold.

If the data is not to be transmitted according to the requested data communications mode the SLMPM selects in dependence upon the monitored performance another data communications mode for transmitting the data and transmits the data according to the selected data communications mode. Selecting another data communications mode for transmitting the data may include selecting in dependence upon the monitored performance another data communications fabric type by which to transmit the data selecting a data communications link through which to transmit the data and selecting another data communications protocol. Consider as an example that the requested data communications mode is a DMA transmission using a PUT operation through link of the PCIe fabric to the accelerator . If the monitored data performance indicates that the number of requests in transmit message request queue associated with the link exceeds a predetermined threshold the SLMPM may select another fabric type the Ethernet fabric and link through which to transmit the data . Also consider that the monitored performance indicates that current utilization of the shared memory space is less than a predetermined threshold while the number of outstanding DMA transmissions in the queue exceeds a predetermined threshold. In such a case the SLMPM may also select another protocol such as a shared memory transfer by which to transmit the data .

Selecting by the SLMPM another data communications mode for transmitting the data may also include selecting a data communications protocol in dependence upon data communications message size . Selecting a data communications protocol in dependence upon data communications message size may be carried out by determining whether a size of a message exceeds a predetermined threshold. For larger messages the DMA protocol may be a preferred protocol as processor utilization in making a DMA transfer of a larger message is typically less than the processor utilization in making a shared memory transfer of a message of the same size.

As mentioned above the SLMPM may also transmit the data according to the selected data communications mode. Transmit the data according to the selected data communications mode may include transmitting the data by the selected data communications fabric type transmitting the data through the selected data communications link or transmitting the data according to the selected protocol. The SLMPM may effect a transmission of the data according to the selected data communications mode by instructing through a device driver the communications adapter for the data communications fabric type of the selected data communications mode to transmit the message according to a protocol of the selected data communications mode where the message includes in a message header an identification of the accelerator and in the message payload the data to be transmitted.

The example SLMPM in the hybrid computing environment of also operates generally for controlling access to a resource in a distributed computing system. In the example hybrid computing environment of the accelerator the accelerator or the host computer may operate as any of a node a receiving node or a requesting node as context requires for controlling access to a resource in accordance with embodiments of present invention. In addition the compute node may be part of a larger hybrid computing environment that includes many similar compute nodes. These compute nodes and others not shown may also operate as any of a node a receiving node or a requesting node as context requires for controlling access to a resource in accordance with embodiments of present invention.

In the example hybrid computing environment of the host computer includes a status field a next field a source data buffer and a destination data buffer . The accelerator in the example of also includes a status field a next field a source data buffer and a destination data buffer . For clarity not limitation only the host computer and accelerator are depicted with these data structures but readers of skill in the art will recognize that accelerator may also be configured with similar data structures for use in controller access to a resource in accordance with embodiments of the present. The example host computer and accelerator are each characterized by a unique node identifier . The status fields next fields source data buffers destination data buffers and unique node identifiers are depicted in the example of as unique data structures but a reader of skill in the art will recognize that such data structures may be maintained and used by the each instance of the SLMPM operating on the accelerator and host computer to control access to a resource in the example hybrid computing environment of .

The SLMPM is said to operate generally for controlling access to the resource in that the SLMPM provides the underlying messaging mechanism enabling data communications between a host computer and accelerator in the example hybrid computing environment of . A host application program executing on a host computer or an accelerator application program executing on an accelerator may instigate or cause a request for access to a resource to be broadcast to other nodes other accelerators host computers or compute nodes in the example hybrid computing environment of . Upon receipt of such a request for access a receiving host application program or accelerator application program may operate in accordance with embodiments of the present invention to return a result to the requesting host application program or accelerator application program. In both cases requesting and returning results of the request the SLMPM in the example of carries out the underlying data communications communicating a request from a requestor to a recipient and communicating a result of that request form a recipient to the requestor. Consider for purposes of explanation that the example accelerator of includes a value in the status field that identifies the accelerator as a node most recently queued for access to the resource. Consider also that the host computer is a requesting node that is a node requesting access to a resource. The SLMPM in the example of may operate generally for controlling access to the resource in accordance with embodiments of the present invention by receiving by the accelerator from the host computer a request for access to the resource. In the example hybrid computing environment of the request for access includes an active message broadcast by the requesting node to a plurality of nodes and other compute nodes in the hybrid computing environment .

The example active message includes the requesting node s unique node identifier the value stored in the requesting node s source data buffer and an instruction to perform a reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer .

Because the accelerator includes a value in the status field that identifies the accelerator as a node most recently queued for access to the resource the instance of the SLMPM executing on the accelerator upon receiving the request from the requesting node may return to the requesting node as a result of the reduction operation the requesting node s unique node identifier . The instance of the SLMPM executing on the accelerator may return the requesting node s unique node identifier by storing the unique node identifier in the source data buffer of the accelerator and by performing the reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer the requesting node s unique node identifier .

The instance of the SLMPM executing on the accelerator may also update the status field and next field of the accelerator to identify the requesting node as a next node to have sole access to the resource. The instance of the SLMPM may update the next field by storing the requesting node s unique node identifier in the next field of the receiving node. Upon completion of access of the resource by the accelerator if the status field indicates a next node to have sole access the value in the next field identifies that node. In this example when accelerator completes access of the resource the accelerator determines that the status field indicates a next node to have sole access to the resource and identifies from the unique node identifier stored in the next field the host computer the requesting node in this example as the next node to have sole access. The accelerator may then pass sole access of the resource to the host computer .

In this way the next fields status fields operate as a distributed queue of nodes requesting access such that a single queue of access requests need not be maintained by a single arbiter that receives requests from all participating nodes. Instead the queue is distributed in pieces among all participating nodes where each piece is maintained individually by each node. A particular node compute node accelerator or host computer in the exemplary system of is only aware the next node to have access to the resource after the particular node if any at all.

For further explanation sets forth an exemplary method of controlling access to a resource in a distributed computing system according to embodiments of the present invention. The method of may be carried out in a distributed computing system similar to the example distributed computing systems described above the example parallel computers of and the example hybrid computing environment of . In a distributed computing system carrying out the method of each node includes a status field a next field and a source data buffer. Each node is characterized by a unique node identifier

The method of includes storing by a requesting node a data workpiece in the requesting node s source data buffer. A data workpiece as the term is used here refers to data with which to perform a reduction operation. The requesting node may for example store a numerical value such zero in the source requesting nodes source data buffer as a value upon which other nodes are to perform a reduction operation.

The method of also includes broadcasting by the requesting node in the active message to each of the other nodes a request for access to the resource. In the example of the request for access is an active message that includes the requesting node s unique node identifier the value stored in the requesting node s source data buffer and an instruction to perform a reduction operation with the value stored in the requesting node s source data buffer and the value stored in a receiving node s source data buffer. Broadcasting the request for access to the resource may be carried out by data communications in a data communications network across a fabric in accordance with a data communications protocol as explained above with respect to . The active message may be implemented as an ALLREDUCE operation or a REDUCE operation similar to those supported by the MPI communications libraries. The instruction in the active message may be compiled computer program instructions to be executed by the receiving nodes or a handle identification a particular reduction operation to perform. In some embodiments the active message is a reduce operation that specifies by use of a handle a bitwise OR operation such as the MPI bitwise OR operation specified by the handle MPI BOR. In such an exemplary embodiment receiving nodes are instructed to perform the OR operation using the value stored in the requesting node s source data buffer the data workpiece described above and the value stored in the receiving node s source data buffer.

The method of includes two processing paths which may occur in parallel. One processing path sets forth the actions taken by a node most recently queued for access to the resource while the other processing path sets forth actions taken by other receiving nodes . Beginning with the processing path of the node most recently queued the method of includes receiving by the receiving node having a value in the status field that identifies the receiving node as a node most recently queued for access to the resource from the requesting node the request for access to the resource. The method of also includes returning to the requesting node as a result of the reduction operation the requesting node s unique node identifier. In the method of returning the requesting node s unique node identifier to the requesting node is carried out by storing the requesting node s unique node identifier in the source data buffer of the receiving node and performing the reduction operation with the value stored in the requesting node s source data buffer and the value stored in the receiving node s source data buffer. Continuing with the example of an OR operation and the value in the requesting node s source data buffer the workpiece data of zero the receiving node performs the OR reduction with the zero and the requesting node s unique node identifier previously stored in the receiving node s source data buffer . The result of such an OR operation is the requesting node s unique node identifier.

The method also includes updating the status field and next field of the receiving node to identify the requesting node as a next node to have sole access to the resource. Updating the status field may include setting a value of the status field to indicate a next node has requested access to the resource where one of only three possible values may be stored in the status field. In the method of updating the next field is carried out by storing in the next field of the receiving node the requesting node s unique node identifier.

Turning to the processing path of receiving nodes other than the node most recently queued for access to the resource the method of includes receiving the request from the requesting node and returning to the requesting node as a result of the reduction operation a value other than the requesting node s unique node identifier. In the method of returning as a result of the reduction operation a value other than the requesting node s unique node identifier is carried out by storing a predefined value in the receiving node s source data buffer and performing the reduction operation. In some embodiments the predefined value is zero. Consider again the example of the OR reduction operation and the workpiece data implemented as value of zero. Consider also that unique node identifier of the requesting node and all other nodes are not zero. Here a receiving node other than node may store a zero in the receiving node s source data buffer and perform an OR operation with the zero stored in the receiving node s source data buffer and the zero provided by the requesting node in the active message the zero stored in the requesting node s source data buffer as workpiece data for the reduction operation . The result of an OR operation with a zero and a zero is a zero.

Upon receiving by the requesting node the result of each reduction operation from each of the other nodes and the method of continues by reducing the received results. Reducing the received results may be carried out in various ways including for example by combining the received results pair wise by arithmetic or logical operations to yield a single corresponding element.

The method of also includes storing the value of the reduced results in the requesting node s destination data buffer. The method of also includes determining whether the value in the requesting node s destination data buffer matches the requesting node s unique node identifier. If the value matches the unique node identifier the requesting node has been queued for access. That is the request was successful. If the value matches the unique node identifier the method of continues by updating the status field of the requesting node to identify the requesting node as a node most recently queued for access to the resource.

If the value does not match the unique node identifier the requesting node s request was unsuccessful. An access request from a requesting node may be unsuccessful if issued at a time when results of a currently outstanding access request have either not been returned in full to a prior requesting node or have been returned to the prior requesting node but have not yet been reduced as described above. In this example no status field of any node would indicate a node most recently queued. Instead the previous node most recently queued updated its status and next fields to identify the prior requesting node as the next node with sole access to the resource but the status field of the prior requesting node has not yet been updated to identify the prior requesting node as a node most recently queued for access to the resource. As such in this example there is no most recently queued to return the subsequently requesting node s unique node identifier. In case of an unsuccessful request the requesting node may request again after a predetermined period of time.

For further explanation sets forth an exemplary data flow and state diagram of a distributed computing system in which access to a resource is controlled according to embodiments of the present invention. Each state in the example of sets forth the status fields next fields source buffers and destination data buffers of three nodes in a distributed computing system in which access to a resource is controlled in accordance with embodiments of the present invention. In the example of the three compute nodes include a Node1 characterized by a unique node identifier of one a Node2 characterized by a unique node identifier of two and a Node3 characterized by a unique node identifier of three.

The status fields of each if nodes indicates a state of a node s relationship to the resource The three possible states include an Active state in which the node is a node most recently queued for access to the resource a Next state in which the node is configured to pass sole access to the resource to a next node and an Unused state in which the node is not queued to access the resource.

In the exemplary first state of the most recently queued node is Node3 as indicated by the status field in which is stored a status of active. Node2 is an unqueued node as evidenced by the status field in which is stored a status of unused. 

In the first state Node1 stories a data workpiece a value of zero in the source data buffer and broadcasts in the active message to each of the other nodes a request for access to the resource. The request for access includes the requesting node s unique node identifier of one 1 the value stored in the source data buffer of zero and an instruction to perform a reduction operation an OR operation with the value of zero stored in the source data buffer and the value stored in a receiving node s source data buffer .

In the example second state of Node3 receives the request and returns to Node1 as a result of the reduction operation the requesting node s unique node identifier of one 1 . Node3 carries out the return of the requesting node s unique node identifier by first determining by inspection of the status field that Node3 is the node most recently queued for access to the resource. Responsive to such a determination Node3 stores the unique node identifier of one 1 in the source data buffer and performs the OR reduction operation with the value stored in the requesting node s source data buffer a zero and the value stored in the receiving node s source data buffer the unique node identifier of one 1 . ORing a zero and one results in a value of one.

In the example of Node3 then updates the status field and next field to identify Node1 as a next node to have sole access to the resource. Node3 carries out such an update in the example of by altering the state of the states field from Active to Next and storing in the next field the Node1 s unique node identifier of one 1 .

Also in the example second state of Node2 receives the request . Node2 returns to the requesting node as a result of the reduction operation a value other than the requesting node s unique node identifier. In the example of Node2 may return a value other than Node1 s unique node identifier by first determining by inspection of the status field that Node2 is presently unqueued. Upon that determination Node2 may store a predefined value such as zero in the source data buffer and perform the reduction operation an OR operation in this example. ORing the zero in Node2 s source data buffer with the zero in Node1 s source data buffer as instructed in the active message results in a value of zero not Node1 s unique node identifier.

In the example third state of upon receiving the results from all other nodes Node1 reduces the received results through a pair wise OR operation and stores the resulting value of the pair wise OR operation a value of one in the destination data buffer . Node1 then determines whether the value in the destination data buffer matches Node1 s unique node identifier of one 1 . In this example the value in the destination data buffer does match and as such Node1 updates the status field to identify the Node1 as a node most recently queued for access to the resource by changing the value in the status field from Unused to Active. As of the third state in the example of Node1 rather than Node3 is characterized as the node most recently queued for access to resource.

In the example fourth state of Node3 completes access to the resource upon completion Node3 determines through inspection of the status and next fields that Node1 is queued to have sole access to resource after Node3 . Node3 then notifies Node1 of the completion using the unique node identifier in the next field . Node3 then sets the status field to indicate that the Node3 is not queued to access the resource. In some embodiments the resource is a mobile resource at a location. In such an embodiment Node3 may also provide Node1 with the location of the mobile resource when sending the notification of completion to Node1 .

For further explanation sets forth a further exemplary method of controlling access to a resource in a distributed computing system according to embodiments of the present invention. The method of is similar to the method of in that the method of may be carried out in a distributed computing system similar to the example distributed computing systems described above the example parallel computers of and the example hybrid computing environment of . In a distributed computing system carrying out the method of each node includes a status field a next field and a source data buffer and each node is characterized by a unique node identifier.

The method of is also similar to the method of including as it does the receiving a request for access to the resource by a node most recently queued for access to the resource returning the requesting node s unique node identifier to the requesting node updating the status field and next field of the receiving node receiving the request by all other nodes and for each of the other nodes returning a value other than the requesting node s unique node identifier.

The method of differs from the method of however in that the method of includes accessing the resource by a particular node having a status field that that indicates the particular node is configured to pass sole access to the resource to a next node and upon completion of the access notifying the next node of the completion in dependence upon the value of the next field which specifies the unique node identifier of the next node. In the example of notifying the next node may optionally include providing the next node with the location of the mobile resource when the resource is a mobile resource. The method of also includes setting the particular node s status field to indicate that the particular node is not queued to access the resource.

For further explanation sets forth a further exemplary method of controlling access to a resource in a distributed computing system according to embodiments of the present invention.

The method of is similar to the method of in that the method of may be carried out in a distributed computing system similar to the example distributed computing systems described above the example parallel computers of and the example hybrid computing environment of . In a distributed computing system carrying out the method of each node includes a status field a next field and a source data buffer and each node is characterized by a unique node identifier.

The method of is also similar to the method of including as it does the receiving a request for access to the resource by a node most recently queued for access to the resource returning the requesting node s unique node identifier to the requesting node updating the status field and next field of the receiving node receiving the request by all other nodes and for each of the other nodes returning a value other than the requesting node s unique node identifier.

The method of differs from the method of however in that the method of includes completing access of the resource by a particular node prior to receiving a request for access from a subsequent requesting node receiving by the particular node a request for access from a subsequent requesting node and immediately upon receiving the request notifying the subsequent requesting node of sole access to the resource. Such an immediate notification may be carried out by switching a value of a binary digit reserved in the received results of the reduction operation to designate such an immediate notification by adding or subtracting a predefined value or in other ways as will occur to readers of skill in the art.

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.

