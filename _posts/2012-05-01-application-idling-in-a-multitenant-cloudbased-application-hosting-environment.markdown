---

title: Application idling in a multi-tenant cloud-based application hosting environment
abstract: A mechanism for idling an application in a multi-tenant cloud hosting environment is disclosed. A method of the invention includes detecting, by a reverse proxy of a node of a cloud computing architecture, a lack of minimum usage of an application hosted on the node, the application being one of a plurality of applications being hosted on the node and instructing the node to shut down the application in response. The reverse proxy is then; and reconfigured to point to a restarter instead of the application, wherein the restarter restarts the application in response to detecting an access to the application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09317325&OS=09317325&RS=09317325
owner: Red Hat, Inc.
number: 09317325
owner_city: Raleigh
owner_country: US
publication_date: 20120501
---
The embodiments of the invention relate generally to cloud based application hosting and more specifically relate to application resource management in a cloud based application hosting environment.

Cloud computing is a computing paradigm in which a customer pays a cloud provider to execute a program on computer hardware owned and or controlled by the cloud provider. It is common for cloud providers to make virtual machines hosted on its computer hardware available to customers for this purpose. The cloud provider typically provides an interface that a customer can use to requisition virtual machines and associated resources such as processors storage and network services etc. as well as an interface a customer can use to install and execute the customer s program on the virtual machines that the customer requisitions together with additional software on which the customer s program depends. For programs that are web applications the additional software can include such software components as middleware and a framework. Web applications are programs that receive and act on requests in web or other Internet protocols such as HTTP. It is common for a user to interact with a web application via a browser executing on the user s client computer system to send requests in a web protocol via the Internet to a server computer system on which the web application is executing. It is also common for automatic user agents to interact with web applications in web protocols in the same fashion.

While many web applications are suitable for execution in the cloud it often requires significant expertise and effort in order to install execute and manage a web application in the cloud. For example an administrator typically should identify all of the software components for the execution of a web application and what versions of those software components are acceptable. In addition the administrator typically should obtain install and appropriately configure each such software component as well as the application itself. Where this high level of expertise and effort has been invested in order to get a web application running on a particular hypervisor and in a particular provider s cloud a similarly high level of expertise and effort usually should be subsequently invested in order to execute the web application instead or in addition on a different hypervisor and or in a different particular provider s cloud. Also it can be difficult or impossible to obtain useful information about how the application is performing and otherwise behaving when executing in the cloud.

Accordingly software and or hardware facilities for facilitating the execution of web applications in the cloud have been introduced and are known as Platform as a Service PaaS offerings and systems. PaaS offerings facilitate deployment of applications without the cost and complexity of buying and managing the underlying hardware and software and provisioning hosting capabilities providing all of the facilities for supporting the complete life cycle of building and delivering web application and services entirely available from the Internet. Typically these facilities operate as one or more virtual machines VMs running on top of a hypervisor in a host server.

In present PaaS offerings a first customer s deployed applications do not co exist with any other customer s deployed applications on the VMs that are hosting the first customer s deployed applications. However such an arrangement can be inefficient to the PaaS provider offering the platform services. This is because a customer often deploys a single application and the size of the VM does not correspond to the size of the application. It can be costly to initialize a new VM for each customer s application deployment and it can also be a waste of resources that are not being utilized. In a public cloud environment a PaaS provider pays for deploying a VM whether the VM lies idle or not. In a private cloud environment there is still a strain on resources for running VMs that are not completely utilized. As such it may be more cost efficient to deploy applications of multiple customers in a single VM rather than associating a VM or a group of VMs with a single application or a group of applications from a single customer. However a variety of implementation concerns arise when considering deploying applications of multiple customers in a single VM such as security concerns and efficient resource sharing concerns.

Embodiments of the invention provide for idling an application or an application component in a multi tenant cloud hosting environment. A method of the invention includes using a reverse proxy of a node of a cloud computing architecture to detect a lack of minimum usage of an application hosted on the node and instructing the node to shut down the application in response. Then the reverse proxy is reconfigured to point to a restarter instead of the application where the restarter restarts the application in response to a future access to the application

In the following description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually though not necessarily these quantities take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as sending receiving attaching forwarding caching executing applying discovering identifying configuring establishing determining or the like refer to the action and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine readable storage medium such as but not limited to any type of disk including floppy disks optical disks CD ROMs and magnetic optical disks read only memories ROMs random access memories RAMs EPROMs EEPROMs magnetic or optical cards or any type of media suitable for storing electronic instructions each coupled to a computer system bus.

The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.

The present invention may be provided as a computer program product or software that may include a machine readable medium having stored thereon instructions which may be used to program a computer system or other electronic devices to perform a process according to the present invention. A machine readable medium includes any mechanism for storing or transmitting information in a form readable by a machine e.g. a computer . For example a machine readable e.g. computer readable medium includes a machine e.g. a computer readable storage medium e.g. read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices etc. etc.

Embodiments of the invention provide a method of idling an inactive application in a multi tenant PaaS architecture. In one embodiment applications hosted by the PaaS system are automatically shut down to conserve resources in a manner that is transparent to both the owner and users of the application. In one embodiment the state of such applications is noted as idle.

Clients and are connected to hosts and the cloud provider system via a network which may be may be a private network e.g. a local area network LAN a wide area network WAN intranet or other similar private networks or a public network e.g. the Internet . Each client may be a mobile device a PDA a laptop a desktop computer or any other computing device. Each host may be a server computer system a desktop computer or any other computing device. The cloud provider system may include one or more machines such as server computers desktop computers etc.

In one embodiment the cloud provider system is coupled to a cloud controller via the network . The cloud controller may reside on one or more machines e.g. server computers desktop computers etc. and may manage the execution of the Web applications in the cloud . In one embodiment the cloud controller receives commands from PaaS broker server . Based on these commands the cloud controller provides data associated with different applications to the cloud provider system .

Some of the clients access the Web applications hosted on the VMs as users. For example a Web application can be an online social network or blog and a client can log into the social network or blog to update content and generally use the functionality of the Web application. In one embodiment each VM is a multi tenant node meaning each VM can host multiple Web applications owned or managed by different clients. For example VM is shown hosting two applications of different users or customers namely App1 and App2 . A client machine such as client 1 can also be used to create and manage Web applications such as for example App1 hosted by VM . As is explained in more detail below in one embodiment client 1 may be a machine used by a customer of a PaaS system to create or upload a Web application to be hosted by the PaaS system.

The client can include tools . Alternatively tools can be provided by the PaaS broker server and a user of the client can access tools via the browser a command line or other interface. The tools can be used to issue commands that result in the PaaS broker server creating and managing a Web application on one of the VMs such as VM1 shown as hosting two applications App1 App2 . In one embodiment the client can also include a source code management SCM system such as Git to manage version control and to send code to a remote repository on the host nodes .

In one embodiment to identify VM1 as the node to create the Web application on the PaaS broker server can communicate with and collect information from the VMs using a server orchestration system . In one embodiment the PaaS broker server maintains application information about each Web application being hosted on the VMs to track which VM each application is hosted on. Since each VM hosts multiple applications belonging to different application owners in a multi tenant node environment applications have specific identifiers as the identifier of the node can correspond to multiple applications. Unique identification of applications along with sandboxing techniques including security segregation and isolation can be used keep each application from accessing or interfering with another application that may be managed by a different owner. For example on Linux based nodes SELinux security labeling can be used to secure access to the applications and Linux control groups can be used to segregate application into different processing spaces and kernel namespacing can be further used to segregate applications. Tools such as Diskquota can then be used to allocate separate resources to the isolated applications. Nodes running other operating system environments can use other such sandboxing techniques to segregate and isolate applications from one another and from the node operating system.

While various embodiments are described in terms of the environment described above those skilled in the art will appreciate that the facility may be implemented in a variety of other environments including a single monolithic computer system as well as various other combinations of computer systems or similar devices connected in various ways.

One example of such an SCM or revision control system is Git available as open source software. Git and other such distributed SCM systems usually include a working directory for making changes and a local software repository for storing the changes. The packaged software application can then be pushed from the local Git repository to a remote Git repository. From the remote repository the code may be edited by others with access or the application may be executed by a machine. Other SCM systems work in a similar manner.

The client layer in one embodiment also includes a set of command tools that a user can use to create launch and manage applications. In one embodiment the command tools can be downloaded and installed on the users s client machine and can be accessed via a command line interface or a graphical user interface or some other type of interface. In one embodiment the command tools expose the application programming interface API of the broker layer and perform other applications management task in automated fashion using other interfaces as will be described further below in accordance with some embodiments.

In one embodiment the broker layer acts as middleware between the client layer and the node layer . The node layer includes the nodes on which software applications are provisioned and executed. In a multi tenancy cloud hosting environment each node hosts multiple applications or application components of different application owners e.g. different customers of the PaaS system . For example one node application and may have different owners.

As used herein an application owner or simply owner is the person persons or entity that creates operates and or manages an application. The application owner uses the client layer to interact with each application owned by the owner on the node layer . The owner is thus the customer of the PaaS system . In contrast a user of the application refers to the end user of the application i.e. the customer of the application. As an example a social network company can be the application owner and a social network member using the social network application can be the user of the social network application.

Using multi tenancy to host multiple applications belonging to multiple application owners saves resources as multiple applications can utilize the operating system middleware communications resources and other shared resources of the node . However hosting multiple applications belonging to different application owners and operators on a single node results in various complications that are addressed by the embodiments set forth herein.

In one embodiment each node is a virtual machine VM provisioned by an Infrastructure as a Service IaaS provider such as Amazon Web Services . In other embodiments the nodes can be physical machines or virtual machines residing on a single physical machine. In one embodiment the broker layer is implemented on ore or more machines such as server computer desktop computer etc. In some embodiments the broker layer may be implemented on one or more machines separate from machines implementing each of the client layer and the node layer .

In one embodiment the broker layer includes a broker that coordinates some of the requests from the client layer with actions performed at the node layer . One such request is new application creation. In one embodiment when a user using the command tools requests the creating of a new application or some other action to manage the application the broker first authenticates the user using an authentication service such as Streamline or some other authentication tool. Once the user has been authenticated and allowed access to the system the broker uses a server orchestration system to collect information and configuration information about the nodes .

In one embodiment the broker uses the Marionette Collective MCollective framework available from Puppet Labs to facilitate parallel job execution of the server orchestration system . The server orchestration system in one embodiment functions to coordinate server client interaction between multiple sometimes a large number of servers. The servers being orchestrated in one embodiment are the nodes which are acting as application servers and web servers.

For example if the broker wanted to shut down all applications on all even numbered nodes out of 100 000 nodes the broker would only need to provide one command to the server orchestration system . The server orchestration system would in one embodiment generate a separate message to all nodes to shut down applications if the node is even and distribute the messages to the nodes using a messaging and queuing system. Thus in one embodiment the broker manages the business logic and model representing the nodes and the applications residing on the nodes and acts as the controller that generates the actions requested by users via the client tools API. The server orchestration system then takes those actions generated by the broker and orchestrates their execution on the many nodes managed by the system.

In one embodiment the information collected about the nodes can be stored in a data store . In one embodiment the data store can be a locally hosted database or file store or it can be a cloud based storage service provided by a SaaS storage provider such as Amazon S3 Simple Storage Service . The broker then uses the information about the nodes and their applications to model the application hosting service and to maintain records about the nodes. In one embodiment node data is stored in the form of a JavaScript Object Notation JSON blob or string that maintains key value pairs to associate a unique identifier a hostname a list of applications and other such attributes with the node.

Another embodiment of node architecture for nodes is now described with reference to . In one embodiment nodes which are virtual machines of a cloud based IaaS environment can be further subdivided into resource pools. For example node is shown to have three resource pools . Other embodiments can have any other number of resource pools per node and the number of resource pools can vary between different nodes and implementations.

Each node is allocated a certain amount of hardware and middleware resources such as memory processing cycles communications messaging and other such provisions to implement a virtual machine. Each node also has a node operating system to manage and use those allocated resources. In one embodiment a resource pool is a further division of those allocated resources into distinct and separate groups. As used herein a resource pool refers to a collection of VM node resources such as processing cycles memory and middleware that are districted away from other VM resources. In some embodiments a resource pool includes a software cartridge that acts as middleware for an application component for example JBoss for an application server component of a composite application . The resource pools can be managed by the node operating system .

In one embodiment the resource pools are segregated from each other so that each resource pool accesses common node resources as if it were the only resource pool on the node. This allows multiple resource pools to share some node resources such as an HTTP server and the underlying node operating system . In one embodiment using a Linux based node resource pools are segregated from each other using SELinux security labeling Linux control groups and kernel namespacing as described above. Nodes running other operating system environments can use other such sandboxing techniques to segregate and isolate resource pools from one another and from the node operating system.

Communications between the broker and the nodes can be coordinated by an agent of a server orchestration system or other messaging platform as described further below.

In one embodiment applications are not only associated with a node and a software repository on the node but with a resource pool. In one embodiment one resource pool contains only one application or multiple applications owned by the same client. In such an embodiment the resource pools are used as the security and segregation container to implement multi tenancy.

In yet other embodiments the applications hosted by the PaaS system include composite n tier Web applications that have several separate components such as a Web server and application server and a database all implemented separately. In such an embodiment each application component can be provided a different resource pool although several application components owned by the same application owner can reside in the same resource pool.

For example node is shown as having three resource pools . Each resource pool is hosting an application component . Resource pools and host one application component each applications components and respectively. Resource pool is hosting two separate application components . In one embodiment the two separate application components being hosted by resource pool are components of the same composite application but in other embodiments they may be components of different applications owned by the same application owner PaaS customer or two different applications owned by the same application owner.

In one embodiment different components of one composite application can be hosted by different resource pools. For example application component and application component hosted by resource pool and resource pool respectively can be two components of the same composite application. In one embodiment different components of one composite application can further be hosted by different resource pools residing on different nodes . For example application component and application component hosted by resource pool of node and resource pool of node respectively can be two components of the same composite application.

While much of the discussion herein is set forth in terms of applications as a whole for simplicity many facets techniques implementations and embodiments can be applied to application components without loss of generality. For example when determining which node of the PaaS system to select to host an application as described further below the same or similar methodologies and systems can be used to determine which node of the PaaS system to select to host an application component. By way of another example communications and interfaces between the client layer and applications described further below are equally applicable to application components instead of applications. Thus as used herein throughout the terms application and application component can be used interchangeably where appropriate.

One embodiment of the interaction between the server orchestration system and the nodes is now described in more detail with reference to . Each node which in one embodiment is implemented as a virtual machine has an operating system that can execute applications e.g. applications with source code stored in the various software repositories resident on the node . In one embodiment each repository is associated with a resource pool. In other words a resource pool contains an application cartridge including middleware specific to an application hosted in the repository contained in the resource pool. A resource pool in one embodiment can be conceptualized as a security segregated and resource constrained container configured to host an application cartridge middleware and or runtime environment and an application or application component.

For a composite application the components of the application can be spread out over multiple resource pools. In such an embodiment one of the resource pools acts as the interface front end of a distributed repository. Thus one resource pool will contain the main repository that is aware of the current location of all the distributed repositories in other resource pools. When such components or resource pools are relocated the main repository can be updated by its node using information provided by the broker or its server orchestration system that it collects from these other nodes.

The nodes also include an agent configured to track and collect information about the nodes and to perform actions on the node. Thus in one embodiment using MCollective for the server orchestration system the agents can act as MCollective servers. The server orchestration system would then act as the MCollective client that can send requests queries and commands to the agents . The agent collects information about the node on which it resides.

In server management terminology such information is referred to as facts. For example one fact is which operating system is installed on the node. Facts are generally stored as key value pairs such as Kernel Linux Hostname Server1422 IP Address 23.43.65.676. The server orchestration system allows the agents to gather information about facts not originally intended. Such extensions are referred to as custom facts. 

In some cloud platform systems each new application owned by a different owner or customer is given its own node meaning a new virtual machine is created for such an application. However in a multi tenancy platform system one node can host multiple even hundreds of applications owned by potentially hundreds of different application owners or customers. In one embodiment the PaaS system of is a multi tenant PaaS environment. Thus each node runs multiple applications that may be owned or managed by different users and or organizations. As such a first customer s deployed applications may co exist with any other customer s deployed applications on the same node VM and multiple software repositories can exist on the same node.

In one embodiment the agent is configured to maintain a custom fact to track the number of software repositories on the node. For example the name of the custom fact can be Repos and its current integer value such as 30 would indicate 30 repositories each containing a Web application or a component of a Web application being hosted on the node . This is not the type of standard fact maintained by a server orchestration system such as CPU usage and memory usage. Furthermore since in a single tenant hosting environment the application owner would be aware of the number of applications and application component it owns and manages such a custom fact would be unnecessary in a non multi tenancy application hosting environment. In one embodiment the number of repositories being hosted on a node can be used as a factor when determining the capacity of a node to host additional applications or application components.

In one embodiment the agent periodically queries the node for example the operating system to determine the number of software repositories and updates a custom fact with the identified number of repositories. In another embodiment the agent can track application creation and destruction to track changes in the number of software repositories e.g. if a software repository is created in response to application creation or removed in response to application destruction and update the corresponding custom fact accordingly.

In one embodiment the agent is configured to maintain a custom fact to track the number of resource pools instantiated on the node. For example the name of the custom fact can be Resource Pools and its current integer value such as 10 would indicate 10 resource pools each containing a Web application a component of a Web application or several applications or components owned by one owner being instantiated on the node . Since in a single tenant hosting environment applications would not be segregated into resource pools such a custom fact would not make sense in a non multi tenancy application hosting environment that does not implement resource pools. In one embodiment the number of resource pools being instantiated on a node can be used as a factor when determining the capacity of a node to host additional applications or application components in either existing or new resource pools.

In one embodiment the agent periodically queries the node for example the operating system to determine the number of software resource pools and updates a custom fact with the identified number of resource pools. In another embodiment the agent can track resource pool creation and destruction to track changes in the number of resource pools and update the corresponding custom fact accordingly.

In one embodiment the applications or application components residing in the software repositories contained in the resource pools are either executing or not. For example an application may currently be stopped by its owner or the application may not have been started yet. In one embodiment the agent is also configured to track the number of active applications which can be defined as the applications that are currently executing and thus consuming more resources than the applications that are not executing. The number of active application can also be tracked as a custom fact. Yet another custom fact can be the number of idle applications . Several embodiments of idle applications are described below with reference to and .

Another view of a node is shown as node . Node shows multiple Web applications App1 App4 residing on the node . Each application resides in an SCM repository Repo1 Repo4 respectively. Thus the agent would discover four repositories on the node and maintain that number as a custom fact. As an example App1 may be stopped by a user or never started App2 and App3 may be active executing Web applications that are executing in two separate threads in the operating system and App4 may be an idle Web application that is not currently executing due to low or no application usage. In this example the custom fact representing active applications would be two and the custom fact representing idle applications would be one. Custom facts can be defined using a utility program such as Facter and collected by running scripts on the node accessible to the node operating system. For example a script can define a Facter custom fact of git repos and count the number or .git files in the directory of the host VM to populate the custom fact. Similarly scripts can count applications having certain states in the node directory e.g. active idle stopped to determine custom facts for the number of active applications idle applications and the node capacity as discussed further below.

As set forth above the number of idle application on a node can be maintained tracked or determined and stored for example as a custom fact. In one embodiment an idle application is an application hosted on the node that has been started at some point by its owner and even though the application has not been shut down by its owner its low usage by the end users of the application by the owner or both does not justify the resources used to keep the application running. Such applications can be idled. In one embodiment an idled application is shut down to keep it from consuming node resources but provisions are made to ensure that if a user accesses the application over the internet for example a reader of a blog requests the website of the blog or a member of a social network logs into their profile the application is restarted in a manner transparent to the user.

One embodiment of implementing idling an application hosted on a node of the PaaS system is now described with reference to . is a block diagram illustrating a node of the PaaS system and a reverse proxy used in part to implement multi tenancy on the node . As set forth above the node includes several applications being hosted on the node . In one embodiment each application is a Web application and includes a Web server respectively to handle Web requests bound for each application. The node also includes an agent to allow the broker layer to manage the node and an operating system not shown .

In one embodiment each node of the PaaS system has an associated reverse proxy server that is responsible for monitoring applications running on the node and detecting when any of these applications become idle and or when any of the idle applications should be reactivated. The associated reverse proxy server can be implemented on the same VM as the node or on a different VM than the node as shown in which may in turn be hosted by the same physical machine as the node or a different physical machine then the node. In one embodiment the reverse proxy implements virtual name hosting to provide multi tenancy support to the node . By providing a virtual name hosting module multiple applications having different URLs e.g. application www.blogsrus.com and application www.mycarclub.com can be hosted on a node having a single internet protocol IP address.

When Web requests bound for an application e.g. application the Car Club site arrive at the reverse proxy they are redirected to application according to the configuration of the virtual name hosting module . In one embodiment the reverse proxy includes a timer that tracks one or more usage and or access statistics for each application and triggers certain actions when minimum usage thresholds for the access statistics are not met. For example the timer may be set to time out if an application is received no HTTP requests from a user over the Internet for a week and the owner has not logged in to manage the application in over two weeks. For example the car club application may not have anyone visiting the site in over a week and or its owner may have lost interest in managing the car club website.

In one embodiment when the timer times out or otherwise indicates that an action is needed the timer alerts an idler of the reverse proxy of which application met or exceeded an idling condition threshold. The idler in response to the information from the timer then proceeds to idle the identified application. In one embodiment the idler can be implemented as a script or other code residing on the reverse proxy but the idler can reside elsewhere. The timer and the idler can be implemented as a single module or as separate modules such as in . Several embodiments of processing performed by the idler to idle an application will be described in more detail below with reference to .

In one embodiment the reverse proxy also includes a restarter module to transparently restart an idle application. Various actions or triggers can activate the restarter . For example in one embodiment receiving an HTTP request from a user of the idle application over the internet causes the restarter to restart the application and to provide the functionality of the application to the user as if the application was always executing. Several embodiments of processing performed by the restarter to restart an application will be described in more detail below with reference to .

Method begins at block with the observation that some threshold period of time has elapsed without an access to one of the Web application hosted on one or more of the nodes of the PaaS system. In other embodiments even if some access has occurred within the timeout window if a minimum level of access is not maintained the threshold for insufficient access can be triggered. In one embodiment user accesses to the Web application in the form of HTTP requests to the Website are monitored for access and a lack of HTTP requests targeting the application within some threshold time period trigger idling. In other embodiments git push commands git commits or other accesses by the owner are also monitored for sufficient volume of access.

Both the threshold time period and the minimum usage required can vary and can depend on multiple factors. In one embodiment both can be configured by administrators of the PaaS system. One example policy can be to idle any Ruby Web application that has not received an HTTP request in 5 days unless the owner of the application uploaded new code to the repository within the last week. The logs of the code repository can be examined to determine the timing of commits and push operations. The timer can monitor the HTTP requests received at the reverse proxy to trigger idling events. Various other idling policies are possible.

At block the application is shut down in response to the elapsed threshold observation. In embodiment the timer signals the idler that an application should be idled in response to having triggered an idling policy. The idler in one embodiment instructs the agent of the node associated with the reverse proxy to shut down the application. In other embodiments the idler can communicate with the node operating system directly to shut down the target application. The application can be shut down in the normal manner as if the instruction to shut down or stop the application came from the client layer e.g. the owner of the application shutting down the application or the broker layer. In one embodiment the state of the application is saved by the node and this state can be accessed when restarting the idle application.

At block the state of the application is changed from active to idle. The state information about the application can be maintained by the reverse proxy by the node as an application attribute as a custom fact or all of the above. In one embodiment the node for example the agent maintains a custom fact about the number of idle applications as set forth above. Such custom fact can be updated using the changed status of the application being idled.

At block the reverse proxy is reconfigured to point incoming requests and accesses such as HTTP requests to the restarter or other such module whose purpose is to restart an idling application. The restarter can be a script and in one embodiment a pointer to the restarter script can replace the pointer to the Web server of the target application in the virtual name hosting module . Thus for an idle application accesses to the application are not provided to the application since it is not running but instead are provided to a restarter.

Method begins at block with receiving a request such as an HTTP Request at the reverse proxy that is an access to the idle application and addressed to the idle application. Since the application is idle the reverse proxy is configured to redirect requests bound for the application to the restarter . In response to receiving the request the restrater at block starts up the application and changes the state of the application back from idle to active. In one embodiment the restarter can instruct the agent of the node to start running the application or can effect the starting of the application directly with the node operating system using various interprocess communication and task automation techniques. Any saved application state information can be accessed by the node to return the application to the state it was in when idled.

As discussed above the current state of each application can be maintained by the reverse proxy the node or both. In one embodiment the restarter also causes an update to the status of the application back to active. Such update can further cause an update to the custom fact tracking the number of idle or active applications that is maintained in one embodiment by the agent of the node

At block the reverse proxy is reconfigured to point the virtual name hosting module back to the restarted application instead of the restarter. Thus future HTTP requests and other accesses to the restarted application will once again be redirected to the application. Then at block the client machine of the user that originated the request e.g. a visitor to the Website powered by the application is prompted to resend the original HTTP request that was received in block . In one embodiment this is done by the restarter script sending a redirect to the reverse proxy itself in response to the received HTTP request.

In this manner and according to other such embodiments applications that are not being used or accessed enough can be shut down to preserve node resources but in a manner that is transparent to the users and owners of the application. Such application idling capability is especially valuable in a multi tenancy node environment because a node can host many applications or application components many of which may never be accessed be accessed only infrequently or left abandoned after some time.

As set forth above when referring to an application herein a similar process can be implemented to apply to a component of an n tier composite application. For example for the idling processing it may not be an entire application that becomes underutilized. Rather it may be a component of a composite application that is contained in a different resource pool from that is not meeting minimum usage thresholds. For example users may be interacting with a website but not saving any data or creating accounts thus resulting in an active Web server but an idle database executing in a different resource pool. In such an embodiment the database server can be idled according to the processing described above with the application component being treated as the application.

Method begins at block with tracking the number of software repositories on the node. In one embodiment whenever a software application is created deleted or undergoes state change e.g. active to idle instruction to perform the specified action is distributed using the message broker of the server orchestration system. In another embodiment the agent can periodically discover the number of software repositories on a node.

In one embodiment a software repository is a data structure that contains source code for an application various files and directories used by the application and a historical record of changes in the repository and other such revision control items. Software repositories can also include various security and completeness checks such as digital signatures to authenticate the repository and checksums to ensure completeness of the repository. To discover the number of software repositories on a node in one embodiment the agent can query the operating system of the node about the number of software repositories currently resident on the node e.g. using a utility such as Facter available from Puppet Labs to communicate with the operating system and can store this information as one of the facts. The agent can then retrieve and manage the custom facts described herein such as the number of software repositories being hosted on the node.

At block the number of resource pools is tracked. In some embodiments each resource pool hosts only one repository. In such embodiments the number of resource pools will equal the number of software repositories. However in other embodiments a resource pool can host multiple repositories that may have some connection such as being managed by the same owner and being different components of one composite application.

In block a determination is made as to which software repositories contain active applications. In one embodiment active applications are all applications that have been started by their owners and that have not been stopped. Since in one embodiment start and stop commands involve application state changes that pass though the agent the agent can track the number of active applications by incrementing the active application count whenever an application is started and decrementing it whenever an application is stopped.

In another embodiment as set forth above applications may also be idle without intervention of the owner of the application. In such an embodiment the agent can be configured to receive a notification whenever an application starts idling and is reactivated. For example the agent can subscribe to notifications for changes in the status of applications e.g. from active to idle or can maintain an application status indicator itself. In one embodiment each time an application begins to idle the active application count can be decremented and every time an idle application is reactivated the active application count can be incremented.

In one embodiment the capacity of the node to host additional applications or application components is calculated in block and also stored as a custom fact. The capacity of a node is its capacity to host additional applications or application components. A new application or component may be hosted in a new or unallocated resource pool. Furthermore in some embodiment a new application or application component can be hosted in an existing resource pool as long as the resource pool has the capacity and hosts applications and components owned by the same application owner.

As the multiple applications of a multi tenant node increase in number they use more of the resources of the node thereby decreasing the capacity of the node to host more applications. At some point the node will be operating at full capacity which can be defined by a significant deterioration in the performance of the hosted applications were additional applications added. Various embodiments for calculating the capacity of the node will be described in detail further below. For example the capacity of a node can be calculated using the number of repositories as an indication of the node s ability to host additional applications.

As mentioned above the various custom facts described are maintained by the agent including but not limited to the number of software repositories the number of active applications the number of idle applications and the capacity of the node. At block the agent updates the custom facts with the most recent values determined as discussed above. The custom facts maintained by the agent can be used in a number of ways to support various platform operations. For example as described further below the number of software repositories the number of resource pools the number of active applications the number of idle applications and the capacity of the node can all be used when selecting a node on which a new application or application component is to be hosted from a set of available nodes that already host other applications in a multi tenant environment.

As discussed above a user may request to create a new application e.g. using the command tools . One embodiment of creating a new application is now described with reference to . is a flow diagram illustrating a method for selecting a node from a number or available nodes on which to create a new application according to an embodiment of the invention. Method may be performed by processing logic that may comprise hardware e.g. circuitry dedicated logic programmable logic microcode etc. software such as instructions run on a processing device firmware or a combination thereof. In one embodiment method is performed by the broker of .

Method begins at block where a request to create a new application or application component is received from the client layer. As explained above in some cloud platform systems each new application of a different owner or customer is given its own node meaning a new virtual machine is created for each such application. However in a multi tenancy platform system one node can host multiple even hundreds of applications owned by different Paas customers and or organizations. In one embodiment the PaaS system of is a multi tenant PaaS environment. Thus each node runs multiple applications that may be owned or managed by different users and or organizations. As such a first customer s deployed applications may co exist with any other customer s deployed applications on the same node VM .

At block the request to create the new application is parsed to extract any application attributes included in the request. One application attribute can be a software type of the application such as PHP Ruby JBoss JavaSript and other such high level languages in which applications are developed. In one embodiment the number of different types of applications can be stored and updated as a custom fact as explained above.

Another possible application attribute can be application size. This can be measured in terms of sheer memory used by the application code or by the anticipated memory footprint of the application. The memory footprint of the application refers to the memory used or referenced by the application during execution. In one embodiment the application size is user selectable from a list of two e.g. small or large or three e.g. small medium or large options. In one embodiment the number of applications of various sizes can be stored and updated as a custom fact as explained above. Furthermore whether the node is configured to host small or large applications can also be stored and maintained as a custom fact as explained above.

Another possible application attribute can be geographic or network location. This can be a logical zoning districting or other such partitioning of the node farm into various classifications or districts. For example different clouds can be classified as different districts. Similarly nodes residing on servers in different physical geographic areas e.g. Japan can be classified as different districts. Thus a German social network application may be hosted on a node farm in Europe to optimize network bandwidth and latency. In one embodiment district to which each node belongs can be stored and updated as a custom fact as explained above.

At block the set of available nodes on which the new application can be created is discovered using the extracted application attributes e.g. available nodes hosting middleware to be used by the new application . For example if the new application to be created is a PHP application then nodes that have PHP installed are discovered. In another embodiment if a new application or component is to be included in a resource pool that already contains an application or component then nodes are filtered to include only nodes containing resource pools owned by the PaaS customer requesting the new application. If no appropriate node is discovered then a new node can be dynamically created using the cloud IaaS provider and configured according to the needs of the new application or component.

According to another example the new application requested can be a large Ruby application. In such a case in block nodes configured for large applications and with a Ruby interpreter installed would be discovered and identified to the broker. The size of the application i.e. large medium small can be measured by the language IDE used by the application type function by the size of the code or by other such means. For example a PHP application that returns a weather code or stock quote can be a small application whereas a JBoss application with database backend can be a large application. The broker may perform additional filtering based on node attributes instead of application attributes. For example the broker might filter the set of available nodes to include only nodes in a certain geographic region e.g. Japan or only nodes belonging to some logical or geographical organization of nodes. In yet other embodiments the filtering may be to exclude nodes that already host an application component or resource pool managed by the requesting owner in order to spread the risk of node failure among multiple PaaS system customers.

In one embodiment the broker uses the server orchestration system to discover the nodes on which the new application can be hosted. This is one example of using the facts maintained by the agents on the node including the custom facts by the broker layer. In the example above large Ruby applications are discovered by the broker requesting the information from the server orchestration system . The server orchestration system then sends a query to all nodes to respond if they satisfy the filter criteria based on their custom facts.

In block the current capacity on the discovered nodes is determined. A node with more capacity has more unused resources and can thus be a more desirable location for creating a new application. Various processes for determining node capacity will be described in more detail further below. In one embodiment the node capacity is calculated by the broker based on gathered information but it can be pre computed on the nodes and gathered by the broker as one of the pieces of information.

In the embodiment described above the processing described with reference to blocks and is performed dynamically with live discovery of available nodes over the network and the dynamic calculation of the capacity of each discovered node. However in another embodiment information about the nodes and the applications residing on the nodes is stored in a data store accessible by the broker. Such information about the nodes can include the pre calculated capacity of each node. Thus in one embodiment block is performed by accessing information about nodes in the data store and block is performed by retrieving the capacity of the identified nodes from the data store.

At block the broker instructs the node having the most capacity to create the new application or application component. In one embodiment the node having the most capacity includes one or more applications or application components of PaaS customers other than the owner of the new application. In one embodiment the broker can send an instruction to the selected node using the server orchestration tool. In other embodiments the broker can access the selected node directly to instruct the creating of a new application. If no appropriate node is located at block or all discovered nodes are determined to be at full capacity at block then a new node can be created that is appropriate for the new application based on the application attributes

In one embodiment in response to the instruction sent to the selected node to create the new application the node creates a new software repository on the identified node and populates the software repository with a template application. The node layer then uses a Domain Name System DNS to assign a host name to the application and returns an application host name to the broker. The broker then can generate a unique system identifier and associate it with the host name of the application.

At block the broker identifies the node selected for the new application to the client layer. This can be done by sending the host name of the application to the client tools to be presented to the user. The broker can also send the unique application identifier to the client tools. In one embodiment the client can then pull the new software repository to the client machine to synchronize the local software repository on the client machine with the new software repository on the node.

Revisions to the application can then be pushed directly from the client layer local SCM repository to the node on which the application resides remote repository . Since the application is secured and segregated on the node such SCM push actions can identify the application or its resource pool by using a unique ID UUID assigned to the application by the broker and a secure channel interface such as SSL to log into the application being managed by the application owner. Thus the local SCM can log into the node and because of the security and segregation features of multi tenancy such as kernel namespacing and the individual process space allotted to the resource pool containing the local repository be only given access to the remote repository associated with the local repository managed by the owner.

As set forth above in a multi tenant cloud PaaS system a concept of the capacity of a node to host additional applications can be helpful to identify which node to select for the creation of a new application in response to a request from the client layer. By hosting multiple applications of different application owners on nodes a new node need only be instantiated when no current node exists with the appropriate configuration and the capacity to host a new application. Several embodiments of determining node capacity in a multi tenant could platform are now described with reference to . The processing described with reference to is in one embodiment a more detailed explanation of block of that can be performed on each discovered node.

Method begins at block where the number of software repositories on a node is determined. In one embodiment each application residing on the node is associated with one software repository designated to this application. In such an embodiment the number of software repositories can act as a proxy measurement for the number of resident applications. Similarly in one embodiment repository is associated with a resource pool and the number of software repositories can act as a proxy measurement for the number of resource pools on the node or vice versa.

However in other embodiments one application can be hosted by multiple distributed software repositories so the number of software repositories is not necessarily the same as the number of applications resident on the node. However in such embodiments individual application components can be counted as applications such as the Web server of a composite application.

In one embodiment the number of software repositories resident on the node can be determined by querying the node itself or a manager system that manages the node such as the node operating system or a node agent that maintains facts about the node. For example in one embodiment the broker can use the server orchestration system to query the agents as to their current custom fact related to the number of software repositories as described above with reference to . In another embodiment the broker maintains a record in the data store for each node and the number of software repositories on each node and can retrieve this information without querying the nodes. In such an embodiment the data store maintained by the broker would be periodically updated by the agent.

At block each repository is weighted based on software type such as PHP Ruby JBoss ect as discussed above. Some programming languages have larger memory footprints and or other resource utilization than others. For example the weight of PHP applications may be 1 and the weight of a JBoss application may be 1.5 to account for the larger amount of node resources expectedly utilized by the JBoss application. If a node hosts only applications of one software type or software types with similar resource utilization then block can be omitted. In other embodiments block is optional even if applications with different resource utilization footprints reside on the node.

At block each repository is weighted based on application size as discussed above. In one embodiment nodes are configured to host applications of a certain size. For example a large node would be configured to host a small number e.g. 10 of large applications while a small node would be configured to host a larger number e.g. 100 of small applications. If a node hosts only applications of one size then block can be omitted.

However in one embodiment a node is allowed to host applications of different sizes. In such an embodiment for example the weight of small applications may be 1 and the weight of large applications may be 10 to account for the larger amount of node resources expectedly utilized by the large applications. In other embodiments block is optional even if applications of different sizes reside on the node.

At block the current node utilization is determined by summing the weighted repositories. In embodiments where blocks and were omitted at block the actual number of software repositories determined in block is unchanged as the sum is not weighted.

At block the maximum node utilization is determined. The maximum node utilization can be configured by a PaaS administrator. The maximum node utilization can be expressed in one embodiment as the maximum number of software repositories that is allowed to reside on the node. In another embodiment the maximum node utilization can be expressed as the maximum number of weighted software repositories that is allowed to reside on the node. In one embodiment the maximum node utilization can be determined by querying the node itself it can be stored as a custom fact for example or a manager system that manages the node. In another embodiment the broker maintains a record in the data store for each node and the maximum node utilization of each node and can retrieve this information without querying the nodes.

At block the current node capacity is determined by subtracting the current node utilization from the maximum node utilization. Thus a higher capacity indicates more available and unused node resources. However in other embodiments other formulas can be used to similar effect. For example the current node utilization can be divided by the maximum node capacity to express the current node capacity as a percentage.

One illustrative example is as follows. A node currently has 25 resident software repositories. 19 are PHP applications and 6 are JBoss applications. JBoss is weighed as 1.5 PHP applications. Thus the current utilization is 19 1 6 1.5 28. If the maximum node capacity is 50 software repositories than the current capacity is 50 28 22. The new application can then be chosen to reside on the node with the most current capacity as described with reference to .

A similar schema to determine node capacity according to another embodiment is now described with reference to . The processing described with reference to is in one embodiment a more detailed explanation of block of that can be performed on each discovered node.

Method begins at block where the number of active applications on the node is determined. As explained above in one embodiment some applications may be stopped by their owners or may be idling due to low activity or persistent inactivity. Thus the number of active application can be determined as the number of applications or application components hosted on the node minus the applications that are not running e.g. stopped or never started and idling. In one embodiment the number of active applications on the node can be determined by querying the node itself or a manager system that manages the node. For example in one embodiment the broker can use the server orchestration system to query the agents as to their current custom fact related to the number of active applications as described above with reference to . In another embodiment the broker maintains a record in the data store for each node and the number of active applications from when the node was last queried and can retrieve this information without querying the nodes.

At block each active application is weighted based on software type such as PHP Ruby JBoss ect as discussed above. If a node hosts only applications of one software type or software types with similar resource utilization then block can be omitted. In other embodiments block is optional even if applications with different resource utilization footprints reside on the node.

At block each active application is weighted based on application size as discussed above. If a node hosts only applications of one size then block can be omitted. However in one embodiment a node is allowed to host applications of different sizes. In such an embodiment for example the weight of small applications may be 1 and the weight of large applications may be 10 to account for the larger amount of node resources expectedly utilized by the large applications. In other embodiments block is optional even if applications of different sizes reside on the node.

At block the current node utilization is determined by summing the weighted active applications. In embodiments where blocks and were omitted at block the actual number of active applications determined in block is unchanged as the sum is not weighted.

At block the maximum node utilization is determined. The maximum node utilization can be expressed in one embodiment as the maximum number of active applications that is allowed to reside on the node. In another embodiment the maximum node utilization can be expressed as the maximum number of weighted active applications that is allowed to reside on the node. In one embodiment the maximum node utilization can be determined by querying the node itself it can be stored as a custom fact for example or a manager system that manages the node. In another embodiment the broker maintains a record in the data store for each node and the maximum node utilization of each node and can retrieve this information without querying the nodes.

At block the current node capacity is determined by subtracting the current node utilization from the maximum node utilization. Thus a higher capacity indicates more available and unused node resources. However in other embodiments other formulas can be used to similar effect. For example the current node utilization can be divided by the maximum node capacity to express the current node capacity as a percentage. The new application can then be chosen to reside on the node with the most current capacity as described with reference to .

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a data storage device which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be complex instruction set computing CISC microprocessor reduced instruction set computer RISC microprocessor very long instruction word VLIW microprocessor or processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. The processing device is configured to execute the processing logic for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The data storage device may include a machine accessible storage medium on which is stored software embodying any one or more of the methodologies of functions described herein. The software may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine accessible storage media.

The machine readable storage medium may also be used to store instructions to idle application as described for example with reference to and or a software library containing methods that call the above applications. While the machine accessible storage medium is shown in an exemplary embodiment to be a single medium the term machine accessible storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term machine accessible storage medium shall also be taken to include any medium that is capable of storing encoding or carrying a set of instruction for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term machine accessible storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

Whereas many alterations and modifications of the present invention will no doubt become apparent to a person of ordinary skill in the art after having read the foregoing description it is to be understood that any particular embodiment shown and described by way of illustration is in no way intended to be considered limiting. Therefore references to details of various embodiments are not intended to limit the scope of the claims which in themselves recite only those features regarded as the invention.

