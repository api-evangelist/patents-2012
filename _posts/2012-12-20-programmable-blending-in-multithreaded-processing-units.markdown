---

title: Programmable blending in multi-threaded processing units
abstract: A technique for efficiently rendering content reduces each complex blend mode to a series of basic blend operations. The series of basic blend operations are executed within a recirculating pipeline until a final blended value is computed. The recirculating pipeline is positioned within a color raster operations unit of a graphics processing unit for efficient access to image buffer data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09183609&OS=09183609&RS=09183609
owner: NVIDIA Corporation
number: 09183609
owner_city: Santa Clara
owner_country: US
publication_date: 20121220
---
The present invention generally relates to multi threaded computer architectures and more specifically to programmable blending in multi threaded processing units.

A number of important graphics rendering standards known in the art as OpenVG SVG Cairo Skia JavaFX Adobe Flash Adobe PDF Apple s Quartz 2D and HTML5 require complex blend modes that are not directly supported by conventional graphics processing units GPUs . As a consequence graphics content formatted according to these graphics rendering standards is conventionally rendered by a central processing unit CPU which is able to implement the complex blend modes using general processing operations. However the CPU does not provide efficient high throughput processing compared to that of a GPU potentially resulting in comparatively low CPU based rendering performance for the graphics content.

Conventional GPUs organize graphics rendering work as a series of graphics objects that are each decomposed into a series of fragments which are then transmitted to a fragment shader. The fragment shader computes a color for each fragment and generates a corresponding shaded fragment which typically includes color and opacity information. Each shaded fragment is then transmitted to a color raster operations CROP unit which is configured to blend the shaded fragment with color data for a corresponding pixel stored in a frame buffer. The CROP unit conventionally performs this blend operation using a fixed function sum of two products circuit that does not directly implement the complex blend modes.

One approach to performing complex blend modes needed by the graphics rendering standards within a GPU is to program a fragment shader to implement the complex blend modes. While a fragment shader is highly programmable and able to execute the complex blend modes read and write latency from the fragment shader to frame buffer memory is sufficiently long in a conventional GPU that rendering performance is crippled and likely falls below that achievable on a contemporaneous CPU.

As the foregoing illustrates what is needed in the art is a technique for efficiently rendering complex blend modes within a GPU.

One embodiment of the present invention sets forth a method for performing a programmable blend operation the method comprising receiving at least source pixel data or destination pixel data for processing based on a sequence of instructions associated with the programmable blend operation determining that a first blend operation is required wherein the first blend operation is specified by a first instruction from the sequence of instructions performing the first blend operation to generate a first blend result performing a second blend operation to generate a second blend result wherein the second blend operation is specified by a second instruction from the sequence of instructions and storing the second blend result. The programmable blend operation may specify an arbitrary sequence of instructions having an arbitrary number of instructions.

Other embodiments of the present invention include without limitation a computer readable storage medium including instructions that when executed by a processing unit cause the processing unit to perform the techniques described herein as well as a computing device that includes a processing unit configured to perform the techniques described herein.

One advantage of the disclosed technique is that it enables graphics content requiring complex blend modes to be efficiently rendered by a graphics processing unit.

In the following description numerous specific details are set forth to provide a more thorough understanding of the present invention. However it will be apparent to one of skill in the art that the present invention may be practiced without one or more of these specific details.

In one embodiment the parallel processing subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the parallel processing subsystem incorporates circuitry optimized for general purpose processing while preserving the underlying computational architecture described in greater detail herein. In yet another embodiment the parallel processing subsystem may be integrated with one or more other system elements in a single subsystem such as joining the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of parallel processing subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies parallel processing subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip instead of existing as one or more discrete devices. Large embodiments may include two or more CPUs and two or more parallel processing subsystems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

Referring again to as well as in some embodiments some or all of PPUs in parallel processing subsystem are graphics processors with rendering pipelines that can be configured to perform various operations related to generating pixel data from graphics data supplied by CPU and or system memory via memory bridge and the second communication path interacting with local parallel processing memory which can be used as graphics memory including e.g. a conventional frame buffer to store and update pixel data delivering pixel data to display device and the like. In some embodiments parallel processing subsystem may include one or more PPUs that operate as graphics processors and one or more other PPUs that are used for general purpose computations. The PPUs may be identical or different and each PPU may have a dedicated parallel processing memory device s or no dedicated parallel processing memory device s . One or more PPUs in parallel processing subsystem may output data to display device or each PPU in parallel processing subsystem may output data to one or more display devices .

In operation CPU is the master processor of computer system controlling and coordinating operations of other system components. In particular CPU issues commands that control the operation of PPUs . In some embodiments CPU writes a stream of commands for each PPU to a data structure not explicitly shown in either or that may be located in system memory parallel processing memory or another storage location accessible to both CPU and PPU . A pointer to each data structure is written to a pushbuffer to initiate processing of the stream of commands in the data structure. The PPU reads command streams from one or more pushbuffers and then executes commands asynchronously relative to the operation of CPU . Execution priorities may be specified for each pushbuffer by an application program via the device driver to control scheduling of the different pushbuffers.

Referring back now to as well as each PPU includes an I O input output unit that communicates with the rest of computer system via communication path which connects to memory bridge or in one alternative embodiment directly to CPU . The connection of PPU to the rest of computer system may also be varied. In some embodiments parallel processing subsystem is implemented as an add in card that can be inserted into an expansion slot of computer system . In other embodiments a PPU can be integrated on a single chip with a bus bridge such as memory bridge or I O bridge . In still other embodiments some or all elements of PPU may be integrated on a single chip with CPU .

In one embodiment communication path is a PCI Express link in which dedicated lanes are allocated to each PPU as is known in the art. Other communication paths may also be used. An I O unit generates packets or other signals for transmission on communication path and also receives all incoming packets or other signals from communication path directing the incoming packets to appropriate components of PPU . For example commands related to processing tasks may be directed to a host interface while commands related to memory operations e.g. reading from or writing to parallel processing memory may be directed to a memory crossbar unit . Host interface reads each pushbuffer and outputs the command stream stored in the pushbuffer to a front end .

Each PPU advantageously implements a highly parallel processing architecture. As shown in detail PPU includes a processing cluster array that includes a number C of general processing clusters GPCs where C 1. Each GPC is capable of executing a large number e.g. hundreds or thousands of threads concurrently where each thread is an instance of a program. In various applications different GPCs may be allocated for processing different types of programs or for performing different types of computations. The allocation of GPCs may vary dependent on the workload arising for each type of program or computation.

GPCs receive processing tasks to be executed from a work distribution unit within a task work unit . The work distribution unit receives pointers to processing tasks that are encoded as task metadata TMD and stored in memory. The pointers to TMDs are included in the command stream that is stored as a pushbuffer and received by the front end unit from the host interface . Processing tasks that may be encoded as TMDs include indices of data to be processed as well as state parameters and commands defining how the data is to be processed e.g. what program is to be executed . The task work unit receives tasks from the front end and ensures that GPCs are configured to a valid state before the processing specified by each one of the TMDs is initiated. A priority may be specified for each TMD that is used to schedule execution of the processing task. Processing tasks can also be received from the processing cluster array . Optionally the TMD can include a parameter that controls whether the TMD is added to the head or the tail for a list of processing tasks or list of pointers to the processing tasks thereby providing another level of control over priority.

Memory interface includes a number D of partition units that are each directly coupled to a portion of parallel processing memory where D 1. As shown the number of partition units generally equals the number of dynamic random access memory DRAM . In other embodiments the number of partition units may not equal the number of memory devices. Persons of ordinary skill in the art will appreciate that DRAM may be replaced with other suitable storage devices and can be of generally conventional design. A detailed description is therefore omitted. Render targets such as frame buffers or texture maps may be stored across DRAMs allowing partition units to write portions of each render target in parallel to efficiently use the available bandwidth of parallel processing memory .

Any one of GPCs may process data to be written to any of the DRAMs within parallel processing memory . Crossbar unit is configured to route the output of each GPC to the input of any partition unit or to another GPC for further processing. GPCs communicate with memory interface through crossbar unit to read from or write to various external memory devices. In one embodiment crossbar unit has a connection to memory interface to communicate with I O unit as well as a connection to local parallel processing memory thereby enabling the processing cores within the different GPCs to communicate with system memory or other memory that is not local to PPU . In the embodiment shown in crossbar unit is directly connected with I O unit . Crossbar unit may use virtual channels to separate traffic streams between the GPCs and partition units .

Again GPCs can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying laws of physics to determine position velocity and other attributes of objects image rendering operations e.g. tessellation shader vertex shader geometry shader and or pixel shader programs and so on. PPUs may transfer data from system memory and or local parallel processing memories into internal on chip memory process the data and write result data back to system memory and or local parallel processing memories where such data can be accessed by other system components including CPU or another parallel processing subsystem .

A PPU may be provided with any amount of local parallel processing memory including no local memory and may use local memory and system memory in any combination. For instance a PPU can be a graphics processor in a unified memory architecture UMA embodiment. In such embodiments little or no dedicated graphics parallel processing memory would be provided and PPU would use system memory exclusively or almost exclusively. In UMA embodiments a PPU may be integrated into a bridge chip or processor chip or provided as a discrete chip with a high speed link e.g. PCI Express connecting the PPU to system memory via a bridge chip or other communication means.

As noted above any number of PPUs can be included in a parallel processing subsystem . For instance multiple PPUs can be provided on a single add in card or multiple add in cards can be connected to communication path or one or more of PPUs can be integrated into a bridge chip. PPUs in a multi PPU system may be identical to or different from one another. For instance different PPUs might have different numbers of processing cores different amounts of local parallel processing memory and so on. Where multiple PPUs are present those PPUs may be operated in parallel to process data at a higher throughput than is possible with a single PPU . Systems incorporating one or more PPUs may be implemented in a variety of configurations and form factors including desktop laptop or handheld personal computers servers workstations game consoles embedded systems and the like.

Multiple processing tasks may be executed concurrently on the GPCs and a processing task may generate one or more child processing tasks during execution. The task work unit receives the tasks and dynamically schedules the processing tasks and child processing tasks for execution by the GPCs .

The work distribution unit includes a task table with slots that may each be occupied by the TMD for a task that is being executed. The task management unit may schedule tasks for execution when there is a free slot in the task table . When there is not a free slot a higher priority task that does not occupy a slot may evict a lower priority task that does occupy a slot. When a task is evicted the task is stopped and if execution of the task is not complete then a pointer to the task is added to a list of task pointers to be scheduled so that execution of the task will resume at a later time. When a child processing task is generated during execution of a task a pointer to the child task is added to the list of task pointers to be scheduled. A child task may be generated by a TMD executing in the processing cluster array .

Unlike a task that is received by the task work unit from the front end child tasks are received from the processing cluster array . Child tasks are not inserted into pushbuffers or transmitted to the front end. The CPU is not notified when a child task is generated or data for the child task is stored in memory. Another difference between the tasks that are provided through pushbuffers and child tasks is that the tasks provided through the pushbuffers are defined by the application program whereas the child tasks are dynamically generated during execution of the tasks.

Operation of GPC is advantageously controlled via a pipeline manager that distributes processing tasks to streaming multiprocessors SMs . Pipeline manager may also be configured to control a work distribution crossbar by specifying destinations for processed data output by SMs .

In one embodiment each GPC includes a number M of SMs where M 1 each SM configured to process one or more thread groups. Also each SM advantageously includes an identical set of functional execution units e.g. execution units and load store units shown as Exec units and LSUs in that may be pipelined allowing a new instruction to be issued before a previous instruction has finished as is known in the art. Any combination of functional execution units may be provided. In one embodiment the functional units support a variety of operations including integer and floating point arithmetic e.g. addition and multiplication comparison operations Boolean operations AND OR XOR bit shifting and computation of various algebraic functions e.g. planar interpolation trigonometric exponential and logarithmic functions etc. and the same functional unit hardware can be leveraged to perform different operations.

The series of instructions transmitted to a particular GPC constitutes a thread as previously defined herein and the collection of a certain number of concurrently executing threads across the parallel processing engines not shown within an SM is referred to herein as a warp or thread group. As used herein a thread group refers to a group of threads concurrently executing the same program on different input data with one thread of the group being assigned to a different processing engine within an SM . A thread group may include fewer threads than the number of processing engines within the SM in which case some processing engines will be idle during cycles when that thread group is being processed. A thread group may also include more threads than the number of processing engines within the SM in which case processing will take place over consecutive clock cycles. Since each SM can support up to G thread groups concurrently it follows that up to G M thread groups can be executing in GPC at any given time.

Additionally a plurality of related thread groups may be active in different phases of execution at the same time within an SM . This collection of thread groups is referred to herein as a cooperative thread array CTA or thread array. The size of a particular CTA is equal to m k where k is the number of concurrently executing threads in a thread group and is typically an integer multiple of the number of parallel processing engines within the SM and m is the number of thread groups simultaneously active within the SM . The size of a CTA is generally determined by the programmer and the amount of hardware resources such as memory or registers available to the CTA.

Each SM contains a level one L1 cache shown in or uses space in a corresponding L1 cache outside of the SM that is used to perform load and store operations. Each SM also has access to level two L2 caches that are shared among all GPCs and may be used to transfer data between threads. Finally SMs also have access to off chip global memory which can include e.g. parallel processing memory and or system memory . It is to be understood that any memory external to PPU may be used as global memory. Additionally a level one point five L1.5 cache may be included within the GPC configured to receive and hold data fetched from memory via memory interface requested by SM including instructions uniform data and constant data and provide the requested data to SM . Embodiments having multiple SMs in GPC beneficially share common instructions and data cached in L1.5 cache .

Each GPC may include a memory management unit MMU that is configured to map virtual addresses into physical addresses. In other embodiments MMU s may reside within the memory interface . The MMU includes a set of page table entries PTEs used to map a virtual address to a physical address of a tile and optionally a cache line index. The MMU may include address translation lookaside buffers TLB or caches which may reside within multiprocessor SM or the L1 cache or GPC . The physical address is processed to distribute surface data access locality to allow efficient request interleaving among partition units . The cache line index may be used to determine whether or not a request for a cache line is a hit or miss.

In graphics and computing applications a GPC may be configured such that each SM is coupled to a texture unit for performing texture mapping operations e.g. determining texture sample positions reading texture data and filtering the texture data. Texture data is read from an internal texture L1 cache not shown or in some embodiments from the L1 cache within SM and is fetched from an L2 cache that is shared between all GPCs parallel processing memory or system memory as needed. Each SM outputs processed tasks to work distribution crossbar in order to provide the processed task to another GPC for further processing or to store the processed task in an L2 cache parallel processing memory or system memory via crossbar unit . A preROP pre raster operations is configured to receive data from SM direct data to ROP units within partition units and perform optimizations for color blending organize pixel color data and perform address translations.

It will be appreciated that the core architecture described herein is illustrative and that variations and modifications are possible. Any number of processing units e.g. SMs or texture units preROPs may be included within a GPC . Further as shown in a PPU may include any number of GPCs that are advantageously functionally similar to one another so that execution behavior does not depend on which GPC receives a particular processing task. Further each GPC advantageously operates independently of other GPCs using separate and distinct processing units L1 caches to execute tasks for one or more application programs.

Persons of ordinary skill in the art will understand that the architecture described in A and B in no way limits the scope of the present invention and that the techniques taught herein may be implemented on any properly configured processing unit including without limitation one or more CPUs one or more multi core CPUs one or more PPUs one or more GPCs one or more graphics or special purpose processing units or the like without departing the scope of the present invention.

In embodiments of the present invention it is desirable to use PPU or other processor s of a computing system to execute general purpose computations using thread arrays. Each thread in the thread array is assigned a unique thread identifier thread ID that is accessible to the thread during the thread s execution. The thread ID which can be defined as a one dimensional or multi dimensional numerical value controls various aspects of the thread s processing behavior. For instance a thread ID may be used to determine which portion of the input data set a thread is to process and or to determine which portion of an output data set a thread is to produce or write.

A sequence of per thread instructions may include at least one instruction that defines a cooperative behavior between the representative thread and one or more other threads of the thread array. For example the sequence of per thread instructions might include an instruction to suspend execution of operations for the representative thread at a particular point in the sequence until such time as one or more of the other threads reach that particular point an instruction for the representative thread to store data in a shared memory to which one or more of the other threads have access an instruction for the representative thread to atomically read and update data stored in a shared memory to which one or more of the other threads have access based on their thread IDs or the like. The CTA program can also include an instruction to compute an address in the shared memory from which data is to be read with the address being a function of thread ID. By defining suitable functions and providing synchronization techniques data can be written to a given location in shared memory by one thread of a CTA and read from that location by a different thread of the same CTA in a predictable manner. Consequently any desired pattern of data sharing among threads can be supported and any thread in a CTA can share data with any other thread in the same CTA. The extent if any of data sharing among threads of a CTA is determined by the CTA program thus it is to be understood that in a particular application that uses CTAs the threads of a CTA might or might not actually share data with each other depending on the CTA program and the terms CTA and thread array are used synonymously herein.

SM provides on chip internal data storage with different levels of accessibility. Special registers not shown are readable but not writeable by LSU and are used to store parameters defining each thread s position. In one embodiment special registers include one register per thread or per exec unit within SM that stores a thread ID each thread ID register is accessible only by a respective one of the exec unit . Special registers may also include additional registers readable by all threads that execute the same processing task represented by a TMD or by all LSUs that store a CTA identifier the CTA dimensions the dimensions of a grid to which the CTA belongs or queue position if the TMD encodes a queue task instead of a grid task and an identifier of the TMD to which the CTA is assigned.

If the TMD is a grid TMD execution of the TMD causes a fixed number of CTAs to be launched and executed to process the fixed amount of data stored in the queue . The number of CTAs is specified as the product of the grid width height and depth. The fixed amount of data may be stored in the TMD or the TMD may store a pointer to the data that will be processed by the CTAs. The TMD also stores a starting address of the program that is executed by the CTAs.

If the TMD is a queue TMD then a queue feature of the TMD is used meaning that the amount of data to be processed is not necessarily fixed. Queue entries store data for processing by the CTAs assigned to the TMD . The queue entries may also represent a child task that is generated by another TMD during execution of a thread thereby providing nested parallelism. Typically execution of the thread or CTA that includes the thread is suspended until execution of the child task completes. The queue may be stored in the TMD or separately from the TMD in which case the TMD stores a queue pointer to the queue. Advantageously data generated by the child task may be written to the queue while the TMD representing the child task is executing. The queue may be implemented as a circular queue so that the total amount of data is not limited to the size of the queue.

CTAs that belong to a grid have implicit grid width height and depth parameters indicating the position of the respective CTA within the grid. Special registers are written during initialization in response to commands received via front end from device driver and do not change during execution of a processing task. The front end schedules each processing task for execution. Each CTA is associated with a specific TMD for concurrent execution of one or more tasks. Additionally a single GPC may execute multiple tasks concurrently.

A parameter memory not shown stores runtime parameters constants that can be read but not written by any thread within the same CTA or any LSU . In one embodiment device driver provides parameters to the parameter memory before directing SM to begin execution of a task that uses these parameters. Any thread within any CTA or any exec unit within SM can access global memory through a memory interface . Portions of global memory may be stored in the L1 cache .

Local register file is used by each thread as scratch space each register is allocated for the exclusive use of one thread and data in any of local register file is accessible only to the thread to which the register is allocated. Local register file can be implemented as a register file that is physically or logically divided into P lanes each having some number of entries where each entry might store e.g. a 32 bit word . One lane is assigned to each of the N exec units and P load store units LSU and corresponding entries in different lanes can be populated with data for different threads executing the same program to facilitate SIMD execution. Different portions of the lanes can be allocated to different ones of the G concurrent thread groups so that a given entry in the local register file is accessible only to a particular thread. In one embodiment certain entries within the local register file are reserved for storing thread identifiers implementing one of the special registers. Additionally a uniform L1 cache stores uniform or constant values for each lane of the N exec units and P load store units LSU .

Shared memory is accessible to threads within a single CTA in other words any location in shared memory is accessible to any thread within the same CTA or to any processing engine within SM . Shared memory can be implemented as a shared register file or shared on chip cache memory with an interconnect that allows any processing engine to read from or write to any location in the shared memory. In other embodiments shared state space might map onto a per CTA region of off chip memory and be cached in L1 cache . The parameter memory can be implemented as a designated section within the same shared register file or shared cache memory that implements shared memory or as a separate shared register file or on chip cache memory to which the LSUs have read only access. In one embodiment the area that implements the parameter memory is also used to store the CTA ID and task ID as well as CTA and grid dimensions or queue position implementing portions of the special registers. Each LSU in SM is coupled to a unified address mapping unit that converts an address provided for load and store instructions that are specified in a unified memory space into an address in each distinct memory space. Consequently an instruction may be used to access any of the local shared or global memory spaces by specifying an address in the unified memory space.

The L1 cache in each SM can be used to cache private per thread local data and also per application global data. In some embodiments the per CTA shared data may be cached in the L1 cache . The LSUs are coupled to the shared memory and the L1 cache via a memory and cache interconnect .

Data assembler processing unit collects vertex data for high order surfaces primitives and the like and outputs the vertex data including the vertex attributes to vertex processing unit . Vertex processing unit is a programmable execution unit that is configured to execute vertex shader programs lighting and transforming vertex data as specified by the vertex shader programs. For example vertex processing unit may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. Vertex processing unit may read data that is stored in L1 cache parallel processing memory or system memory by data assembler for use in processing the vertex data.

Primitive assembler receives vertex attributes from vertex processing unit reading stored vertex attributes as needed and constructs graphics primitives for processing by geometry processing unit . Graphics primitives include triangles line segments points and the like. Geometry processing unit is a programmable execution unit that is configured to execute geometry shader programs transforming graphics primitives received from primitive assembler as specified by the geometry shader programs. For example geometry processing unit may be programmed to subdivide the graphics primitives into one or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives.

In some embodiments geometry processing unit may also add or delete elements in the geometry stream. Geometry processing unit outputs the parameters and vertices specifying new graphics primitives to a viewport scale cull and clip unit . Geometry processing unit may read data that is stored in parallel processing memory or system memory for use in processing the geometry data. Viewport scale cull and clip unit performs clipping culling and viewport scaling and outputs processed graphics primitives to a rasterizer .

Rasterizer scan converts the new graphics primitives and outputs fragments and coverage data to fragment processing unit . Additionally rasterizer may be configured to perform z culling and other z based optimizations.

Fragment processing unit is a programmable execution unit that is configured to execute fragment shader programs transforming fragments received from rasterizer as specified by the fragment shader programs. For example fragment processing unit may be programmed to perform operations such as perspective correction texture mapping shading blending and the like to produce shaded fragments that are output to CROP unit . Fragment processing unit may read data that is stored in parallel processing memory or system memory for use in processing the fragment data. Fragments may be shaded at pixel sample or other granularity depending on the programmed sampling rate.

CROP unit is a processing unit that performs raster operations such color blending and the like and outputs pixel data as processed graphics data for storage in graphics memory. The processed graphics data may be stored in graphics memory e.g. parallel processing memory and or system memory for display on display device or for further processing by CPU or parallel processing subsystem . In certain embodiments each pixel comprises multiple color samples. In such embodiments CROP unit is configured to compress color sample data that is written to memory and decompress color sample data that is read from memory. The goal of this compression technique is not to reduce the size of an image in memory but rather to reduce processing associated with the image by representing all samples for a given pixel by one set of sample values that require processing. In a typical scene a majority of pixels comprise color samples of equal value and this compression technique enables improved processing performance. Multiple color samples are combined to generate an anti aliased pixel within a resulting image for display or further processing. When all color samples associated with a particular pixel are equal in value one color sample is stored for the pixel and status information for the pixel is set to indicate that the samples are compressed. In one embodiment samples associated with a pixel will have equal color when a corresponding fragment fully covers the pixel. Color samples for each pixel within the image may be combined to generate an anti aliased pixel for display.

Embodiments of the present invention enable a parallel processing subsystem such as a GPU to perform complex blend operations within CROP of . With these complex blend operations available content for graphics rendering standards such as OpenVG SVG Cairo Skia JavaFX Adobe Flash Adobe PDF Apple s Quartz 2D and HTML5 may be efficiently rendered within the GPU thereby beneficially improving system performance. To support complex blend operations CROP is configured to implement a multi pass blending operation on source and destination data. In one embodiment each pass of the multi pass blending operation comprises a sum of two products as set forth below in greater detail.

A conventional CROP unit implements a blend comprising a sum of two products specified by Equation 1 below  color  coefficient  color  coefficient Eq. 1 

Here src refers to data received from upstream such as color and opacity data computed in fragment shader . Here also dst refers to data already stored in a render target such as in frame buffer memory. For example a blend operation that combines an upstream src color that is 70 opaque with a dst color would be performed with a src coefficient of 0.70 and a dst coefficient of 0.30 so that src color contributes 70 and dst color contributes 30 of a blended color stored in the frame buffer. Conventional GPUs support this type of blend operation which is essentially a single pass blend as a native CROP blend operation. However more complex blend operations are not conventionally supported as CROP blend operations. One example of a complex blend operation not supported by a conventional CROP unit is a soft light blend operation implemented in Adobe s Flash format. The soft light blend is illustrated below in Table 1.

Embodiments of the present invention implement complex blend operations by decomposing each complex blend operation into a series of simple blend passes where each blend pass requires only a sum of two products. For example the complex blend operation shown above in Table 1 may be decomposed an implemented as three blend passes each comprising a sum or two products. These three blend passes are illustrated below in Table 2. Conditional execution and temporary storage are added to the basic function of a CROP blend unit. Temporary storage indicated by variable T enables intermediate results to be used between blend passes.

In the example of Table 2 pass1 conditional operator if src0.5 may evaluate to execute a pass2 assignment operation T 1 dst src 0.5 during pass2. Similarly a pass3 conditional operator if src 0.5 may evaluate to execute a pass3 assignment operation T T 1.5 dst during pass2. As specified the pass1 conditional operator is mutually exclusive to the pass2 and pass3 conditional operators so that either the pass1 assignment operation will be executed for a given src data or pass2 and pass3 assignment operations will be executed for the src data. In one embodiment pass1 pass2 and pass3 are performed for each pixel being blended with assignment operations occurring in either pass1 or in both pass2 and pass3. After pass3 is complete variable T holds a final blend value for a corresponding pixel. This final blend value may be written to a frame buffer image.

As illustrated above a temporary value associated with a given blend pass may be stored in temporary variable T during one pass and made available for blend computations in a subsequent blend pass. An array of one or more temporary variables is denoted herein as T k where k represents an array index for selecting one of the one or more temporary variables T k . In one embodiment each T k is initially set to zero prior to beginning a blending operation on a new pixel. An interpretation of the behavior of temporaries is that each blend pass includes an implicit else that recirculates temporary variables so they may be available in a subsequent blend pass on the same pixel.

Multiple samples comprising a pixel are each processed according to a selected complex blend operation. Each sample may include different color samples comprising source data for a complex blend operation. For example a pixel may include a set of four color samples referred to herein as a quad. A complex blend operation on a quad comprises performing the complex blend operation on each color sample associated with the quad to generate four blended color samples.

Each sample may include an alpha opacity value. In one operating mode an alpha blend is performed for each sample with resulting alpha values stored until passes on related color red green and blue data are complete. Resulting alpha values are then paired with their related color data and stored together as pixel samples for example within an image buffer. In an iterated alpha operating mode alpha values associated with each sample are processed identically as corresponding color data.

In general each complex blend mode may be decomposed into a sequence of iterations comprising an ordinary blend equation defined as a sum of two products A B C D . Different temporary values T k may be generated and used as input to the blend equation in a given iteration where k is an index to reference a temporary value. A basic programming model for a blend program implementing a complex blend mode is illustrated in Table 3 below. During each pass p data from various sources may be selected for each variable A B C D and k.

A conditional cond needs to be satisfied for an assignment to be executed in a given pass. Each conditional evaluates to a Boolean value of TRUE or FALSE. In one embodiment eight condition functions are implemented including greater than greater than or equal to equal to not equal to less than or equal to less than never false and always true . Conditionals are evaluated for each component e.g. red green blue and each conditional evaluation is performed per component.

Each different complex blending mode defines a total number of passes N PASSES along with variable selection information for variables A B C D and k for each pass.

In one embodiment temporary values are initialized to zero at the start of each complex blending operation. Each final output of an iterated blend operation will either be the result an assignment in the last pass of the blend program or T 0 if a conditional for the last pass evaluates to FALSE. The output data will have been stored in T 0 in a previous pass if the conditional in the last blend pass evaluates to FALSE. Persons of ordinary skill in the art will recognize that alternative rules for assigning output data may be implemented without departing the scope and spirit of embodiments of the present invention. In one embodiment a maximum number of passes is set to 128 for any complex blend mode. Alternatively more or fewer passes may be executed per complex blending mode.

In certain embodiments a previous blender result PBR is stored at each pass and made available as an input to a subsequent pass. Using PBR as an input may save power in certain scenarios because PBR is available from a local register rather than from a random access memory RAM instance that may require more power to read and write.

In certain implementations a blend circuit implements the sum of two products blend function. A recirculation path is added from the blend circuit output to the blend circuit input. The recirculation path may include a storage for up to a maximum number of quads being processed allowing each quad to pass through the blend circuit for multiple pass iterations. The maximum number of quads may be selected according to a number of processing stages are required to perform one pass. In one embodiment up to seven quads may be in flight within the recirculation path which comprises seven processing stages.

To facilitate certain complex blend operations a set of functions is implemented to act on input data associated with a given pass or to act on output data associated with the pass. Each input value to the blend circuit is selected from a set of input operators that may include without limitation a constant zero a constant one a constant color source color source alpha destination color destination alpha one minus source alpha or destination alpha a temporary value T k a minimum operation a maximum operation an absolute value operations a negate operation a PBR a reciprocal operation a square root operation and a reciprocal of a square root. Operators on output data from a blend pass may include without limitation data swizzle operators and write mask operators. Each color channel red green blue alpha of each sample is computed independently using a set of input values and output operators defined for a particular pass. Additional functions may also implement a dot product operator a vector normalize operator and the like. Certain functions such as reciprocal square root and other arbitrarily defined functions may be implemented via a piecewise linear approximation of the function. Any technically feasible technique may be used to implement the piecewise linear approximation and any smoothing and interpolation technique may be used without departing the scope and spirit of the present invention.

For blend operations having compressed source and destination color components only one blend operation need be performed on the representative color rather than on each independent sample. For configurations having four samples per pixel this represents approximately one quarter the processing requirement of blending each component. This efficiency benefit scales with the number of samples per pixel.

Inputs through N correspond to available inputs comprising the set of input operators for the A variable. Similarly inputs and correspond to available inputs comprising sets of input operators for the respective B C and D variables.

CROP blend unit comprises a single pass blend path and a multi pass blend path configured to recirculate data results for successive iterations via recirculation path . When a single pass blend mode is active the single pass blend path computes blend operations for incoming pixels and multi pass blend path is put into a low power state. When a multi pass blend mode is active the multi pass blend path computes blend operations for incoming pixels via two or more passes iterations comprising blending operations on the incoming pixels. In alternative embodiments only the multi pass blend path is implemented and is configured to also execute single pass blending operations. Such alternative embodiments may consume more power on average because more circuitry is involved in single pass blend operations which tend to dominate any given scene.

In one embodiment recirculation path is configured to transmit up to seven quads in flight pipelined and allows each quad to go through the multi pass blend path multiple times executing sequences of basic blend operations that together enable complex blend modes. In above soft light blend example of Table 2 each soft light blend requires 3 iterations one for each pass listed. In this example throughput for those pixels requiring a soft light blend would be one third that of a single pass blend. Since src data and dst data may be needed in more than one blend pass this data is recirculated and pushed into a fifo that will match the latency of the blender. Temporary data including at least T 0 . . . T 2 is also recirculated for use in multiple iterations.

Embodiments comprising both multi pass blend path and single pass blend path exhibit latency characteristics of single pass blending modes with dynamic power increasing to support multi pass blending modes only when multi pass blending is required. Because multi pass blend path requires no persistent state once processing is complete multiple architectural strategies for power savings are available including powering off circuitry comprising multi pass blend path .

In one embodiment CROP blend unit processes source and destination data in a series of pipeline stages. Source and destination data may each comprise different data formats having different data rates per pixel and different color representation formats. Source and destination data are prepared for blending by stages S0 S5 which map the source and destination data to the same format. Circuitry associated with blending operations is simplified by needing to support only one format. In one embodiment source and destination data are mapped to a floating point representation such as a sixteen bit floating point representation for blending. Resulting data from blend operations may need to be represented and stored in one of various available formats. Stage S11 is configured to reformat the resulting data to a destination format for storage. In one embodiment reformatting the resulting data comprises clamping to a specified range such as a range from 0.0 to 1.0 or 1.0 to 1.0.

Stages SP S6 through SP S10 comprise single pass blend path . Basic blend operations defined by one sum of two products may be processed by stages SP S6 through SP S10 . Stages MP S6 through MP S10 comprise multi pass blend path . Complex blend operations requiring two or more passes may be processed by stages MP S6 through MP S10 . Gatekeeper is configured to admit multi pass source and destination data into multi pass blend path for processing. Flow director is configured to either recirculate resulting data back to gatekeeper for re admission when another processing pass is needed or transmit resulting data to SP S10 which passes the resulting data to S11 for reformatting to a destination format.

In one embodiment gatekeeper admits work to the multi pass blend path for processing in units of quads. Gatekeeper is configured to attempt to maximize the number of quads being processed within MP blend path without exceeding a maximum number of quads that may be in flight at any one time. In on implementation gatekeeper admits quads to enter MP blend path until a first quad recirculates back via recirculation path at which point gatekeeper stops admitting new quads for processing into the admitted group of quads. When the last quad in the admitted group is pushed into MP blend path after recirculating via recirculation path gatekeeper may begin admitting new quads for processing. The goal here is for gatekeeper to efficiently admit work for MP blend path while avoiding bubbles and overflows.

Gatekeeper drains MP blend path when quads requiring a different complex blend mode are presented for processing. Gatekeeper also drains MP blend path prior to a context switch event.

In one embodiment state management for multi blend path may be implemented to prevent pipeline configuration changes while current transactions are in flight. This simplifies overall state management. Each pass may include a command bundle which may be decoded upstream and passed along as a decoded command bundle comprising Iterated blend state for each blend pass.

As shown a method begins in step where the GPU driver receives an application programming interface API call requesting a specific blend mode. This blend mode may be determined by an application program preparing to render content requiring the blend mode. If in step an iterated blend instruction sequence corresponding to the requested blend mode has not been generated then the method proceeds to step where the driver generates an iterated blend instruction sequence for the requested blend mode. If in step the iterated blend instruction sequence is not already resident within an associated GPU then the method proceeds to step where the driver downloads the iterated blend instruction sequence to the GPU. The method terminates after step where the driver configures the GPU to execute the requested blend mode as a blend operation to be performed by CROP unit .

Returning to step if the iterated blend instruction sequence corresponding to the requested blend mode has been generated then the method proceeds to step as described above.

Returning to step above if the iterated blend instruction sequence is already resident within the GPU then the method proceeds to step .

As shown a method begins in step where the CROP unit receives source data and destination data to be blended according to the blend operation. If in step the source data and destination data do not indicate an early out condition then the method proceeds to step . An early out condition is defined herein as a condition where either the source data alone or the destination data alone define a blended result making a blend of the source data and the destination data superfluous. One example of an early out condition is when source data is completely opaque nullifying any contribution of the destination data during a blend. Another example of an early out condition is when source data is completely transparent nullifying any contribution of the source data during a blend. In step source and destination data are mapped to a common format such as a sixteen bit floating point format. Any other technically feasible format may also be implemented as a common format for blending operations.

If in step the blend operation is a multi pass iterated blend operation then the method proceeds to step where a gatekeeper function admits the source data and destination data to a multi pass MP . In one embodiment the gatekeeper function is implemented by gatekeeper of . The gatekeeper function admits enough work into a MP blend path such as MP blend path to efficiently and correctly utilize the MP blend path computational resource while avoiding bubbles. In one embodiment computational state associated with MP blend path is initialized during admission of new data. Computational state may include without limitation a pass count values of T k and so forth. The pass count may indicate how many passes have been executed on a particular set of data. In step a selected blend operation is performed on selected input data. For example a sum of products or difference of products may be performed on four selected operators from a set of input operators described previously.

If in step a currently processed blend pass is the last pass then the method proceeds to step where output data is mapped to a target format. One example of a target format is a screen space red green blue sRGB eight bit integer format. In step the output data is stored to a target location in memory such as an image buffer within PP memory of . The method terminates in step . If however in step the currently processed blend pass is not the last blend pass then the method proceeds back to step as described above.

Returning to step if the blend operation is not a multi pass iterated blend operation then the method proceeds to step as described above.

Returning to step if the source data and destination data do indicate an early out condition then the method proceeds to step as described above. In one embodiment if the source data and destination data do indicate an early out condition that nullifies any influence of the source data then in step the output data is stored to a target location in memory. The method terminates in step .

In one embodiment an early out condition may be determined based on source data being completely transparent obviating any write or blend operation with destination data. In certain embodiments an early out condition may be determined based on destination data being completely opaque obviating a write or blend operation between source data and destination data. If either early out condition is detected the method bypasses steps and terminates in step .

In sum a technique is disclosed for efficiently performing a complex blend operation within a raster operations unit of a graphics processing unit. The technique decomposes the complex blend operation into a series of two or more iterations each of which comprises an operation on two products. The operation may comprise without limitation a sum or a difference. At least two input values for each product are selected from a set of input operators. In one embodiment the two products the operation and the input operators are performed in a common mathematical representation such as a sixteen bit floating point representation. Pixels that only require a single blend operation may be processed according to a conventional blend pipeline to save power.

One advantage of the disclosed technique is that it enables graphics content that requires complex blend modes to be efficiently rendered by a graphics processing unit.

While the foregoing is directed to embodiments of the present invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored.

The invention has been described above with reference to specific embodiments. Persons of ordinary skill in the art however will understand that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention as set forth in the appended claims. The foregoing description and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

