---

title: Seamlessly playing a composite media presentation
abstract: A computer-implemented method for seamlessly playing a composite media presentation, includes receiving, by a sequencer, a sequential playlist provided by a scheduler. The sequential playlist refers to a sequence of one or more streaming media content items. The sequencer receives calls from a native player application at regular intervals, and sends playback segments and seekbar update information to the native player application based on the sequential playlist in response to the calls. The native player application is configured to play the composite media presentation using at least one core player and generate a corresponding seekbar for the presentation based on the playback segments and the seekbar update information sent by the sequencer.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09344472&OS=09344472&RS=09344472
owner: Microsoft Technology Licensing, LLC
number: 09344472
owner_city: Redmond
owner_country: US
publication_date: 20121228
---
Streaming media is multimedia that is constantly received by and normally presented to an end user using a client while it is being delivered by a streaming provider using a server . Streaming can be accomplished using stateless communication between the client and server by breaking media up into chunks that are individually addressable and can be individually requested by clients. For a particular media event or content item the streaming server provides a manifest file that describes each of the chunks that comprise the event. For example a one minute video may include 60 one second audiovisual chunks. Each chunk contains metadata and media content.

The metadata may describe useful information about the media content such as the hit rate of the media content where the media content fits into a larger media element a codec used to encode the media content and so forth. The client uses this information to place the chunk into a storyboard of the larger media element and to properly decode and playback the media content. The chunks can be in any format such as Motion Picture Experts Group MPEG 4 boxes or other containers. A client plays a media event to a user by reading the manifest and regularly requesting chunks from the server. The user may also skip around e.g. seek fast forward rewind and the client can provide these behaviors by requesting later or earlier chunks described by the manifest. For live events the server may provide the manifest to the client piecemeal so that the server informs the client of newly available chunks as they become available.

While these streaming techniques provide a great experience for viewing streaming media over the Internet and other networks users often want to view and producers of content often want to provide content that comes from different sources or from different existing content items including advertisements and highlight videos. For example a sports network may want to provide a highlight video at the end of each day that includes some new commentary and some selections from earlier media events. Today the sports network can provide links to each video but users may not want to view dozens of different video streams or files. Producers of content do not want to re encode or repackage each earlier content item for rerelease as a new content item for these types of purposes. By repackaging the content the publisher can provide the user with familiar smooth streaming controls such as skipping forward and backward in a stream. In many cases the producer may want to provide quick turnaround to create highlights using a combination of on demand and live assets immediately after an event or even as an event is still on going e.g. for late joining viewers of the event .

Some embodiments are directed to a single unified solution for a number of content splicing scenarios including 1 Spliced highlight reels where content from a variety of sources is spliced together into a single linear presentation 2 traditional Web advertisements i.e. non linear or pause timeline true in which playback of the main content is paused exclusive playback of the advertisement is performed and then the system returns to the main content at the paused position and 3 linear advertisements that overwrite and replace main content as if the linear advertisements were part of the main content all along.

One embodiment is directed to a computer implemented method for seamlessly playing a composite media presentation. The method includes receiving by a sequencer a sequential playlist provided by a scheduler. The sequential playlist refers to a sequence of one or more streaming media content items. The sequencer receives calls from a native player application at regular intervals and sends playback segments and seekbar update information to the native player application based on the sequential playlist in response to the calls. The native player application is configured to play the composite media presentation using at least one core player and generate a corresponding seekbar for the presentation based on the playback segments and the seekbar update information sent by the sequencer.

In the following Detailed Description reference is made to the accompanying drawings which form a part hereof and in which is shown by way of illustration specific embodiments in which the invention may be practiced. It is to be understood that other embodiments may be utilized and structural or logical changes may be made without departing from the scope of the present invention. The following detailed description therefore is not to be taken in a limiting sense and the scope of the present invention is defined by the appended claims.

It is to be understood that features of the various exemplary embodiments described herein may be combined with each other unless specifically noted otherwise.

Specific embodiments are directed to 1 A method to specify linear and non linear playback sequences in a sequential playlist which supports on demand and live playback including real time updates to playback range and dynamic scheduling of advertisements and trick mode i.e. fast forward and rewind 2 a pull mode sequencer that is reactive whereas other sequencers are typically push mode meaning that they are expected to carry out all aspects of sequencing using a pull mode makes embodiments easier to integrate into existing players 3 a sequencer plug in chaining application programming interface API that allows for user and third party full customization of the sequencer to meet a wide range of advertising models advertising verification and player functionality such as format agnostic captioning 4 a unified method to display a proper seekbar for spliced highlight reels traditional non linear web advertisements and linear advertisements 5 a method to implement seek to live and resume from last played in the presence of spliced highlight reels traditional non linear web advertisements and linear advertisements 6 a method to abstract player seek accuracy to deal with the fact that some players support accurate seek while others adjust the seek position to the nearest i frame 7 deferred resolution of advertisements which allows for just in time individualized advertisements 8 a method to offload computation to a server side Cloud component which brings a number of advantages including better programming environment to handle complexity better network connections and ability to update on a constant basis and 9 a method to integrate static advertisements into media playlists. Embodiments support a varying degree of seamlessness and work with Microsoft players and non Microsoft players including players in which no low level control is provided.

Computing device may also have additional or different features functionality and additional or different hardware and software. For example computing device may also include additional storage removable and or non removable including but not limited to magnetic or optical disks or tape. Such additional storage is illustrated in by removable storage and non removable storage . Computer storage media includes volatile and nonvolatile removable and non removable media implemented in any suitable method or technology for non transitory storage of information such as computer readable instructions data structures program modules or other data. Memory removable storage and non removable storage are all examples of computer storage media e.g. computer readable storage media storing computer executable instructions that when executed by at least one processor cause the at least one processor to perform a method . Computer storage media includes RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices and does not include transitory storage media. Any such computer storage media may be part of computing device .

The various elements of computing device are communicatively coupled together via one or more communication links . Computing device also includes one or more communication connections such as network connections that allow computing device to communicate with other computers applications . Computing device may also include input device s such as keyboard pointing device e.g. mouse pen voice input device touch input device etc. Computing device may also include output device s such as a display speakers printer etc. In one embodiment computing device also includes a touch device with a motion sensitive display surface .

The media player system includes native player application advertisement ad manifest server sequencer chain processor media abstract sequencing template MAST parser and execution environment sequencer plug ins and scheduler and native pipeline core players . Native pipeline includes Motion Picture Experts Group 4 MPEG4 or MP4 progressive source Smooth source single manifest including live to VOD HTTP live streaming HLS source and dynamic adaptive streaming over HTTP DASH source . A native player application according to one embodiment such as native player application is an application that communicates directly with a native pipeline e.g. native pipeline to play media content. In the illustrated embodiment sources and are core players. In one embodiment a core player is a player or pipeline configuration that is capable of playing single segment content such as progressive HLS DASH Flash or Smooth non RCE .

Native player application provides creation and control information to core players which is represented by arrow . Core players provide position update information and live left right information to native player application which is represented by arrow . Native player application provides seek playthrough position update and buffering complete information to sequencer chain processor which is represented by arrow . Sequencer chain processor provides new playback PB segments and seekbar left right information to native player application which is represented by arrow . Ad manifest server provides individualized ad manifests and live updates to sequencer chain processor which is represented by arrow . Sequencer chain processor provides web requests and individual information and polling information to ad manifest server which is represented by arrow . MAST parser and execution environment provides SetMainContent ScheduleClip and SetDVRWindowModel command information to scheduler which is represented by arrow . Scheduler provides a sequential playlist playlist updates initialization parameters for a live DVR model and updates to base sequencer which is represented by arrow . Sequencer plug ins and communicate with each other and with sequencer chain processor via an IPlayerSequencer interface which is represented by arrows and .

Sequencer chain processor and sequencer plug ins and make up sequencer . In one embodiment sequencer includes the following four features 

 1 Allows for playback of segmented content in a linear manner as if the segmented content had actually been re encoded into a single presentation . This includes support for both web scenarios and broadcast 

b. Linear overlay advertisements also known as pause timeline false advertisements overtop of live or on demand content 

 2 Allows full variation from segment to segment. This means that codecs and protocols Smooth DASH HLS Progressive are able to change from one segment to the next.

In one embodiment the sequencer executes a sequential playlist. The scheduler uses protocols to initially construct the sequential playlist and continually update the sequential playlist in the case of live content.

A large number of functions are performed for the management of advertisements so in order to break the functionality down into isolated pieces the interface for sequencer is exposed to the public for use by the native player application and the sequencer is implemented using a chain of sequencer plug ins and . In one embodiment each of the sequencer plug ins and calls the next plug in in the chain directly rather than having a central processor call the next plug in. Higher plug ins have the ability to override the decisions of lower plug ins.

In one embodiment sequencer plug in provides a live DVR model that models the server live position and DVR window so that the seekbar can be properly painted. Note that the DVR model may also be the start over model that paints a seekbar that corresponds to Electronic Program Guide EPG entries. Sequencer plug in can be implemented in a format agnostic or format specific way. In one embodiment sequencer plug in also includes a future ads update model and a playback range dynamic playback policy model. Sequencer plug in according to one embodiment superimposes playback policy on top of the sequential playlist playback policy to prevent fast forward at live position rewind or pause at left edge of DVR etc.

In one embodiment sequencer plug in includes an ad analytics and tracking model that acts as an event source for reporting of advertisement playback start quartiles and completion and an event sink for user initiated events such as muting pause and click through.

In one embodiment sequencer plug in is a base sequencer that takes a strictly sequential playlist from scheduler and through an API exposed by sequencer chain processor allows native player application to find out what it should be playing or buffering next. The public interface exposed to the native player application is named IPlayerSequencer. In one embodiment the base sequencer is stateless. The API of the base sequencer involves the caller i.e. native player application providing a pointer to the sequential playlist entry that is currently playing which provides all the state information for the base sequencer . The base sequencer therefore does not track which playlist entry is currently playing. This simplifies the design of the base sequencer . The base sequencer according to one embodiment does account for the fact that the currently playing entry has been invalidated.

The base sequencer according to one embodiment provides low level access to modification of the sequential playlist. This allows the application to make small changes via the sequencer such as skipping entries or modifying existing entries. Higher level scheduling APIs are provided by the scheduler .

In one embodiment the chaining model for the plug ins and is that the current plug in is itself responsible for calling the next plug in in the chain. Thus there are two kinds of sequencer plug ins 1 A forwarding plug in which calls the next plug in in the chain and is free to apply its own adjustments to inputs and outputs of downstream plug ins and 2 a non forwarding plug in. In one embodiment only the base sequencer is a non forwarding plug in. As a result the base sequencer resides at the end of the plug in chain. All other plug ins e.g. plug ins and are of the forwarding type.

A forwarding plug in according to one embodiment implements an IPlayerSequencerPluginChain interface which allows the instantiator e.g. native player application to insert the plug in into the chain by calling GetNextPlugin and SetNextPlugin. The following Pseudo Code Example I shows an example of how a forwarding plug in might add its own logic to skip an advertisement if an advertisement has already been played recently e.g. within 2 minutes 

Note that a complete ad skipping implementation applies the same logic to all other IPlayerSequencer methods that return a new playback segment e.g. Seek SkipForward SkipBack etc. . This is a reason why the native player application implements its own customizations in a sequencer plug in rather than above the sequencer level.

In one embodiment sequencer uses a pull model which makes it easier to integrate into existing platform specific single segment players. With the pull model the native player application asks the sequencer what the application should play next. In one embodiment seekbar updates and playback segments are pulled by application from sequencer . Using a pull model a platform independent resource e.g. sequencer is provided that is used by platform dependent players e.g. application to implement segmented playback.

The design of sequencer is accepting of players that do not support accurate seek. In one embodiment segment playback is serialized there is no continuous rendering between segments. Pipeline timestamps are unambiguous the native player application is still responsible for identifying the currently playing segment but it can do so unambiguously . Any pipeline timestamps prior to the splice in point can therefore be easily hidden from the seekbar by the sequencer .

The following Pseudo Code Example II provides some example public APIs for sequencer according to one embodiment 

The scheduler is responsible for producing a strictly sequential playlist which can be fed to sequencer for playback on a series of core players and . In the case of live content the scheduler is responsible for updating the playlist using a model of server live e.g. rolling DVR window . In one embodiment the scheduler uses a parallel representation of manifests internally e.g. advertisement manifests overlaid on top of a main content manifest and exposes an API ScheduleClip for a dynamic ad scheduler to place advertisements. Scheduler may be implemented in multiple ways e.g. simple schedulers for VOD only playback up to broadcast scenario schedulers .

The scheduler provides the application with a low level API for sequential playlist modification. Typically higher level functionality is desired by the MAST parser and execution environment . This is supplied by the scheduler via functions names ScheduleClip ScheduleLinearClip and ScheduleLinearBlackout. The scheduler is also responsible for updating the playlist such as modeling the live DVR window and scheduling new future advertisements as they are known. With regard to advertisements the scheduler deals with the when or where to schedule advertisements and the what is done on the client e.g. native player application .

Example components associated with the scheduler include 1 MAST parser and execution environment which describes the business logic and the appropriate times to schedule an advertisement relative to the content 2 a scheduler API that exposes a parallel playlist model e.g. a two level parallel structure of advertisements scheduled on top of underlying main content and provides an API for the MAST execution environment to schedule advertisements 3 a live update mechanism that detects and executes updates to the MAST manifest which allows future advertisements to be continuously scheduled and 4 a live DVR window model that allows the client to paint the proper seekbar without necessarily requiring format specific code.

The output of the scheduler includes 1 A sequential playlist 2 initialization data for a live DVR window model which updates the seekable range of the sequential playlist over time the client e.g. native player application will typically instantiate an object using this initialization data and may provide additional initialization parameters and 3 initialization data for a live update model playlist sequence number polling interval to discover new advertisements etc. which is used by the client to instantiate an object.

In one embodiment the sequencer and the scheduler are implemented with JavaScript. The scheduler can be implemented on the client side or on the server side.

In one embodiment scheduler is implemented as a VOD scheduler that supports pause timeline true advertisements on top of on demand main content. This implementation of scheduler has no need for a live DVR model or advertisement updates. The following Pseudo Code Example III provides an example API for such a scheduler 

In another embodiment scheduler is implemented as a live scheduler that supports scheduling of linear overlay advertisements on top of on demand or live content. The live scheduler implementation builds on the VOD scheduler discussed above and adds the functions given in the following Pseudo Code Example IV 

In another embodiment scheduler is implemented as a broadcast scheduler built on top of the live scheduler discussed above which adds support to schedule linear blackouts on top of live 24 7 content. An example interface for the broadcast scheduler is shown in the following Pseudo Code Example V 

System according to one embodiment uses at least four different timelines. The first timeline is a manifest timeline. Manifest timestamps are declared in the manifest. The second timeline is a pipeline timeline. Pipeline timestamps are reported by the native pipeline as current playback position. The pipeline timestamps are expected to match the manifest timestamps. The third timeline is a linear timeline with linear timestamps. The linear timeline typically describes the main content which may consist of one or more clips and is normalized to start from 0. Pause timeline true advertisements are modeled as 0 duration playlist entries on the linear timeline. The fourth timeline is a seekbar timeline. Seekbar timestamps are generated when the user clicks on the seekbar and the application wishes to seek to the position corresponding to the clicked location. The seekbar is either showing the linear timeline or it is showing the seekable range of a pause timeline true advertisement that is currently playing. In the case of the former the seekbar timestamp is the same as a linear timestamp. In the case of the latter the seekbar timestamp is the same as the manifest timestamp.

In one embodiment the sequential playlist provided to base sequencer from scheduler is a list of playlist entries arranged in chronological order. Each playlist entry according to one embodiment consists of the following four items 

 1 A uniform resource identifier URI pointing to a single segment manifest. The URI may be of any format e.g. Smooth DASH HLS progressive static page VAST manifest .

 2 Splice in and splice out times expressed using manifest timestamps which define a subrange of the whole single segment manifest to play.

 3 Linear start time and duration. Pause timeline true advertisements are represented as having a linear duration of 0. In one embodiment all linear playlist entries declare linear duration up front even if this means pre downloading the manifest at the time of scheduling. An exception is if there is only a single linear entry in which case a placeholder value of 0 infinity can be used until the manifest is downloaded on demand.

 4 An indication of whether or not the playlist entry represents an advertisement. Advertisements involve special trusted tracing mechanisms to allow for content providers to be paid.

In one embodiment system uses four types of sequential playlist entries 1 Media 2 static page 3 video ad serving template VAST manifest and 4 seek to start. Each of these is discussed in further detail below.

For a media type of sequential playlist entry the URI is a media URL e.g. smooth progressive HLS DASH special offline scheme .

For a static page type of sequential playlist entry the URI points to a static page such as the recommender page in post roll which allows the viewer to share the video he or she just watched and to recommend other videos that he or she may enjoy. Static pages are typically represented as pause timeline true linear duration 0 . The native player application uses or implements a core player that can play static advertisements including extracting a display duration from the URI responding to FF REW etc.

For a VAST manifest type of sequential playlist entry the URI points to a VAST manifest. A VAST manifest resolver downloads and parses the VAST manifest in order to resolve to a media URL that it can actually play. This also gives the opportunity for the client to set up an events sink for tracking URLs.

A seek to start type of sequential playlist entry is a special entry that is placed just ahead of the first entry that has a non zero linear duration and is deleted after completion OnEndOfMedia or Seek ManifestToSeekbarTime will not terminate playback due to the need to initialize the live DVR model . If the main content is on demand the URL can be null. If the main content is live the URL points to the live main content even if the first non zero linear duration entry does not.

The seek to start entry looks like a pause timeline true advertisement with playback range from 0 to infinity and linear duration of 0. It is not intended that the application actually play this content. Rather if the application already knows where it wants to start playback the application can execute this by issuing any of the following 1 If the application knows that the content is on demand the application can call OnEndOfMedia to start playback at the left edge of main content OnEndOfMedia avoids the possibility of infinite loops which arises if there is a persistent advertisement at 0 and the application calls Seek linear pos 0 2 Seek linear resume time if resuming from last played position live or on demand 3 First call ManifestToSeekbarTime with the min max current manifest timestamps followed by Seek linear server live position if the application has a way to know this without downloading the manifest i.e. has a formula to convert from wallclock time to manifest time .

If the application does not know where it wants to start playback because it does not know the server live position then this corresponds with cases 1 and 3 above. The application starts playback in the usual way which causes the manifest to be downloaded. Once playback begins the application can deduce whether the content was live or on demand and if live can deduce the server live position. The application then executes case 1 OnEndOfMedia or case 3 ManifestToSeekbarTime with min max current manifest timestamps and Seek linear server live position . Note that it is okay to call ManifestToSeekbarTime multiple times. The last writer wins and represents the manifest timestamp range of the live presentation to properly initialize the live DVR model.

Starting playback of a live manifest to establish server live position is sub optimal if it turns out that the live position is in the middle of an advertisement but this is done because the sequencer is format agnostic and therefore relies on the native player application to obtain the current server live position and report back. If being sub optimal is an issue then one solution is to use manifest timestamps that correspond to wallclock time.

In one embodiment the playlist itself provides a locking mechanism for thread synchronization so that changes e.g. additions deletions and modifications to two or more playlist entries can be atomic.

The sequential playlist according to one embodiment supports the following scenarios 1 On demand video preroll postroll RCE pause timeline true and false over on demand video 2 live video preroll postroll pause timeline false advertisements over live video and 3 linear live video linear blackout .

In one embodiment sequential playlist entries are not sufficient to describe to the native player application what to play. Sequential playlist entries clips according to one embodiment are wrapped in an object called a playback segment which contains additional information. Playback segments can be thought of as marching orders for a core player . The additional information in a playback segment according to one embodiment includes an initial playback start time and an initial playback rate which are described in further detail below.

The initial playback start time is a manifest time within the playback subrange defined by the sequential playlist entry. For instance if the native player application seeks within the same clip then it will be issued a new playback segment whose clip is the same as the previously playing clip. The initial playback start time will reflect the requested seek position. After starting playback here the player is free to allow playback to roam within the playback subrange defined in the sequential playlist entry.

The initial playback rate is used to implement linear trick modes where rewinding back through one clip and into another starts playback of the next clip at the end and in rewind mode so that the two clips appear to be one single linear piece of content.

Because of the structure of the playback segment the native player application according to one embodiment possesses the following capabilities 

 1 Ability to play progressive and at least one adaptive format e.g. Smooth DASH HLS in single segment form. Typically the native application already has a way to get a content URL in the form that it supports e.g. Smooth DASH HLS . In other words even prior to integration of the sequencer a single segment iOS player for example should already know how to get main content URLs for HLS format and single segment Silverlight players should already know how to get main content URLs for Smooth. It is expected however that advertisements may sometimes be distributed in progressive MP4 format.

 2 Ability to play a single segment URL starting at a particular position and at a particular playback rate.

 4 Ability to play live single segment content and properly render the seekbar min max current position manifest timestamp on its own. Ability to determine the current server live position maximum playback timestamp not the actual server live buffering position .

Advertisements may be in unresolved form i.e. may be represented in the sequential playlist as a pointer to a VAST manifest . The client is responsible for resolving the VAST manifest. Resolution of a VAST manifest according to one embodiment proceeds as follows 

 2 The application can download the VAST manifest which may be customized based on parameters supplied by the client. For instance if the ad server knows the IP address of the client it may resolve this to a geolocation and serve ads that are appropriate for a region. If the ad server knows the identity of the viewer it can access demographic information and serve appropriate ads. If the search or ad viewing history of the viewer is known this too can be used to modify the VAST manifest.

 3 The VAST manifest can contain multiple representations of the same advertisement. The application is responsible for choosing the one that is the most appropriate for the player capabilities. For instance on the iOS platform the most likely choice would be the HLS form of the advertisement.

 4 The VAST manifest also contains tracking information so that events such as ad playback progress midpoint quartiles completion and user events mute pause click through can be reported and acted upon. The application is responsible for implementing this tracking functionality.

The timing of VAST resolution could vary. It can be done just in time by providing a plug in for sequencer which detects and resolves playback segments that point to VAST entries. It can also be done ahead of time by iterating through the sequential playlist. It should be noted however that resolution of the VAST manifest might not be a one time event. If the user plays the same VAST advertisement entry the VAST manifest could be resolved each time it is played resulting in a different advertisement each time. The business model dictates whether VAST manifest resolution is a one time or each time occurrence.

The application can choose to implement VAST resolution as its own functionality or it can choose to implement using a plug in for sequencer . The sequencer plug in for instance is frequently updated with playback position information which puts the plug in in a good position to detect and act on advertisement playback progress. The sequencer plug in does not have visibility into user events such as mute pause or click through but these can be communicated via custom attributes. The application can create a custom attribute class that is consumed by the sequencer plug in responsible for advertising tracking

Given a native player application that is capable of playing single segment content from a variety of formats e.g. progressive Smooth DASH HLS the steps for integrating the sequencer according to one embodiment are as follows 

 1 Modify the Open function to create a new sequencer using a factory function this actually creates a sequencer chain . Call Seek 0 to play any preroll ads. If this returns a seek to start entry the application may Seek linear last played position or call OnEndOfMedia to begin playback from left edge of main content. Either call returns a playback segment containing a single manifest URI and a starting playback position. Execute this playback segment.

 2 Modify the seekbar updating code to first ask the sequencer for the seekbar left right and to translate current pipeline manifest timestamp to seekbar position. If the sequencer reports that current playback range is exceeded the native player application stops playback if end of media had been reached and calls the sequencer s OnEndOfMedia.

 3 Modify the Seek function to call Seek Pipeline Manifest Time first. This will either instruct the native player application to stick with the current clip in which case the application may proceed with a regular seek or a new clip in which case the application acts as though it were asked to open a new URL .

 4 Modify the EndOfMedia handler to call the sequencer s OnEndOfMedia to check if this is really the end. If not the application will be instructed to play a new clip at an initial playback position and playback rate.

 5 Implement playback policy by ghosting and or ignoring the appropriate UI buttons can seek can skip etc .

In the absence of any optimizations buffering for the next clip does not begin until the previous clip has finished playback. This can lead to several seconds delay when transitioning between clips. One optimization provided by system according to one embodiment is to use local media files for advertisements so that transitioning to advertisements is quick. Another optimization is to utilize double buffering where buffering for the next clip begins prior to the previous clip completing playback. In one embodiment double buffering is implemented as follows 

 1 The core player fires an event that indicates that buffering for the current clip has completed the download position for all streams have reached end of stream . Let us call this end of buffering. It is safe to buffer the next clip at this time since no further network activity is expected for the previous clip.

 2 Upon end of buffering the native player application asks the sequencer to peek at the next playback segment via OnEndOfBuffering unlike OnEndOfMedia OnEndOfBuffering has no side effects . The next playback segment is reported.

In one embodiment the native player application is expected to perform a frame accurate splice in. If it is not capable of doing so the sequencer will hide this from being shown on the seekbar. If frame accuracy is desired on splice out the native player application is free to communicate this to the core player as follows 

 1 Monitor the playback range on the sequential playlist entry. A convenient place to do this is during the frequent calls to ManifestToSeekbarTime. Use the minimum or maximum rendering time whichever is appropriate for the direction of playback to set the splice out on the core player .

 2 Changes to the playback range may occur at any time. Such changes are not signaled in any way so it is the responsibility of the native player application to detect and act on such changes.

 2 Upon starting playback of the first clip the native player application notes the playback range and sets the splice out point to be the MaxRenderingTime of the sequential playlist entry because playback rate is in a forward direction.

 3 The core player is designed to stop rendering at the given MaxRenderingTime and to issue end of media to the native player application .

 4 While playing the first clip the native player application checks for changes to MaxRenderingTime but finds no changes.

 5 The core player signals end of media and stops rendering exactly at MaxRenderingTime frame accurate . The native player application calls IPlayerSequencer OnEndOfMedia and is told to play the second clip. This differs from an unoptimized implementation which will play slightly past the splice out point and be told to stop playing via ManifestToSeekbarTime at which point they will call OnEndOfMedia .

 2 After executing a seek to start to the live position the native player application is given a playback segment pointing to main content live. The playback range MaxRenderingTime is infinity.

 3 At some point the ad scheduler is told of an upcoming advertisement and schedules an advertisement in the future. The existing sequential playlist is modified by the scheduler to include the future advertisement.

 4 The next time the native player application checks the currently playing sequential playlist entry typically during the ManifestToSeekbarTime call the application notices that the MaxRenderingTime has changed from infinity to a finite value. The native player application conveys this update to the core player .

 5 The core player signals end of media and stops rendering exactly at MaxRenderingTime frame accurate . The native player application calls IPlayerSequencer OnEndOfMedia and is told to play the advertisement. This differs from an unoptimized implementation which will play slightly past the splice out point and be told to stop playing via ManifestToSeekbarTime at which point they will call OnEndOfMedia .

 6 The advertisement itself is typically a single on demand asset that is played in its entirety which means that having a core player that is capable of frame accurate splice out typically only affects splice out from main content. It is not necessary for splice out from advertisements.

 2 The next time the native player application calls ManifestToSeekbarTime it will be told to stop playback. The application does so issuing a OnEndOfMedia.

 3 The new playback segment instructs the native player application to play the advertisement at some offset into the advertisement not at the beginning . The offset is computed using the last playback position reported via ManifestToSeekbarTime.

 4 In this case the fact that the core player is optimized for frame accurate splice out makes no difference because the scheduler was late in scheduling the advertisement and so no opportunity for frame accurate splice out was given.

The playback policy is a custom attribute on each sequential playlist entry. The native player application according to one embodiment does not access this attribute directly however. Rather each call to ManifestToSeekbarTime returns a playback policy that is the combination of the playback policy on the sequential playback entry and a dynamic playback policy imposed by the sequencer plug in chain. An example of this would be the live DVR model plug in disabling fast forward when the current position is too close to the live position.

In general playback policy is initialized as totally permissive at the head of the sequencer chain and each sequencer plug in has a chance to restrict policies AND operation as the call progresses down the chain. In one embodiment the sequencer chain does not actually enforce playback policy. Rather enforcement of playback policy is done by the native player application above the level of the sequencer . If the current playlist entry is marked as unskippable IPlayerSequencer SkipForward does not enforce this and allows the skip.

In the case of single segment manifest playback with no advertisements the sequencer returns playback segments that refer to the current clip. In the case of single segment manifest playback with no advertisements and a resume from last played is indicated the following may be performed 

 1 The application remembers that when the last time this presentation was played possibly on another device the last linear timestamp recorded was 10000.

 2 During open the application calls Seek 0 . This returns a seek to start entry. Since the application knows where it wants to start it calls Seek LinearTime 10000 . The sequencer returns a playback segment pointing to the main content with playback range of 0 20000 and an initial playback position of 10000.

 3 The core player is told to start playing at 10000 but accurate seek is not supported and playback actually begins at 9000.

 4 The core player asks the sequencer to paint the seekbar. The sequencer does not enforce initial playback position in any way and 9000 is within the playback range of 0 20000 so the sequencer translates the manifest timestamp into a linear timestamp as usual and returns linear left right for seekbar painting.

It is the task of a dynamic ad scheduler to implement preroll ads. One method of doing this is by scheduling one or more entries with linear duration 0 at linear start time 0 with the delete after playing attribute set to true. For example assume that there is a two segment main content that consists of the first main content clip with linear start time of 0 and linear duration of 10000 and the second main content clip with linear start time 10000 and duration 5000. The following will be performed 

 1 During open Seek LinearTime 0 returns a playback segment pointing to the pause timeline true advertisement. The core player starts playing the preroll advertisement.

 2 As the preroll advertisement starts playing the core player asks the sequencer how to paint the seekbar. The core player passes in the pipeline reported min max current positions. Since pause timeline true content is being played the sequencer passes the pipeline reported values through. The seekbar is therefore painted in exactly the same way as prior to sequencer integration.

 3 When the preroll advertisement finishes playing the core player reports this to the sequencer via OnEndOfMedia call. Since the preroll advertisement is marked as delete after playing the sequencer deletes the sequential playlist entry. The sequencer returns a seek to start playback segment.

 4 The application can tell that this is on demand from the URL which is null . The application has no specific starting point in mind so it calls OnEndOfMedia rather than Seek linear . Since the seek to start entry is marked as delete after playing it is deleted. The sequencer returns a playback segment pointing to the first clip of the main content playback range 50000 60000 initial playback position of 50000. The core player starts playing the first clip of the main content but does not support accurate seek so playback starts at 49000.

 5 As the first clip of the main content starts playing the core player asks the sequencer how to paint the seekbar. The sequencer notes that 49000 is outside the playback range of 50000 60000 but that playback rate is 0 so that it will eventually reach the desired playback range. Because of this the sequencer chooses not to terminate playback. The sequencer ignores pipeline reported min max and translates current position into a linear timestamp which is bounded by playback range. In other words a manifest timestamp of 50000 would normally be translated into linear time 0. Thus a manifest timestamp of 49000 is snapped to the acceptable playback range and reported the same as a manifest timestamp of 50000 linear time 0 . In this way non accurate seeks are allowed but the seekbar does not progress during the rendering of splice in content which is normally not rendered by players that do support accurate seek . Linear min max of 0 15000 is returned and this is used to paint the seekbar.

 6 OnEndOfMedia is called for first main content clip. The sequencer returns a playback segment for the second clip of main content.

 7 The core player asks the sequencer how to paint the seekbar. Manifest timestamp is translated to linear timestamp 10000. Linear min max of 0 15000 is returned and this is used to paint the seekbar.

 8 OnEndOfMedia is called for the second main content clip. No playback segment is returned. The end of the presentation has been reached.

In one embodiment system handles seeking across clips in the following manner. Given a sequential playlist with two main content clips 0 10000 10000 15000 and no advertisements 1 Since both clips are linear i.e. not pause timeline true the seekbar is always set to 0 15000 2 If the first clip is currently being played and the user clicks on position 12500 in the seekbar then Seek SeekbarTime 12500 returns a playback segment pointing to the second clip and 3 the native player application translates this seek operation into an open operation and spawns a new core player to play the second clip.

In one embodiment system handles single segment live main content in the following manner. The sequential playlist consists of a single entry pointing to the live manifest with a linear start time of 0 and a linear duration of infinity. The initial playback position of this playlist is set to infinity. The following are performed 

 1 During open Seek LinearTime 0 returns a seek to start segment. The URI is a pointer to the main live manifest.

 2 Either the core player starts playing the live content at which point the server live position becomes known or the native player application is able to deduce the server live position using other means such as converting current wallclock time into an NTP synchronized manifest timestamp .

 3 ManifestToSeekbarTime can be called multiple times. The latest call contains actual min max current server live manifest timestamps from the live presentation.

 4 The native player application converts manifest time to linear time and calls the sequencer s Seek LinearTime current live position . The sequencer returns a playback segment pointing to the same clip as is currently playing. This information is used by the sequencer to initialize the live model in the scheduler which is used to implement fake live when playing on demand content at the live position.

In one embodiment system handles single segment live main content with a preroll advertisement in the following manner. When the system starts playing the main content after the preroll advertisement the system joins at the live position. Preroll advertisements are typically marked as delete after playing so they will not be played a second time if the user seeks or rewinds to the beginning again. When the last preroll advertisement completes typically via a call to OnEndOfMedia the playback segment returned is a seek to start. The URI is a pointer to the main live manifest and playback of the live main content proceeds.

In one embodiment system handles live main content with overlay advertisements Pause Timeline False at live fake live in the following manner. If one takes live main content and schedules a single linear overlay advertisement at linear time 1M the result is a sequential playlist with three entries live main content 0 1M overlay advertisement 1M 1.5M live main content 1.5M infinity. The following are performed 

 1 During open Seek LinearTime 0 returns a seek to start segment with a URI pointing to the live main manifest. The application executes a seek to live.

 2 Assume that the current live position is 1.1M. The native player application converts the manifest timestamp to linear time and calls the sequencer s Seek LinearTime current live position . The live DVR model plug in initializes its model. Assume that the live model is a rolling DVR window of width 200 000. The model is therefore initialized to have a playable seekable range from 0.9M 1.1M.

 3 The base sequencer would return a playback segment pointing to the advertisement manifest on demand . The playback subrange is not modified and still shows 1M 1.5M even though playing at 1.5M would put the playback position past the current server live position.

 4 Playback of the linear advertisement begins at 1.1M part way into the advertisement . Note that playback range does not denote buffering range which is unconstrained.

 5 The core player asks how to paint the seekbar. The live model plug in is used to trim the linear timeline and a seekable range of 0.9 1.1M is reported with current playback position at 1.1M. The user is not able to seek past the current server live position with this seekbar.

 6 Two seconds later the live model updates and two seconds are added to playback range left right. This update is reflected very quickly in the seekbar.

 7 Any attempt to fast forward will cause playback position to exceed server live position. This will be detected in the next seekbar painting update and the sequencer will instruct the native player application to end playback. When the native player application complies a playback segment is returned which instructs the native player application to play at 1 at the current server live position as determined by the live model SeekToLive is false .

 8 Once playing at the live position the live DVR model plug in can prevent fast forward by disabling this in the playback policy. The application continues to call the sequencer frequently with position updates so if position changes the live DVR model plug in can re enable fast forward.

In one embodiment system handles rewinding through multiple clips in the following manner. Assume that a user is playing near the end of a multiple clip presentation. The following are performed.

 1 The user hits rewind. The core player enters rewind mode. The sequencer is not explicitly notified of this but the core player continues to ask the sequencer how to paint the seekbar. This informs the sequencer that the system is currently in rewind mode but the sequencer does not care.

 2 The playback position reaches the start of content. This is reported to the sequencer via OnEndOfMedia. The sequencer returns a playback segment pointing to the previous clip with an initial start position at the end of the clip and an initial playback rate that is the same as the playback rate reported via OnEndOfMedia.

 3 The core player executes this playback segment. It appears to the user as though the user is rewinding through two clips as if the clips were actually one unbroken piece of linear content i.e. a single clip .

 1 The sequencer is notified of playback position as the core player asks the sequencer how to paint the seekbar.

 2 Eventually the current playback position either equals or exceeds the maximum playback timestamp. The sequencer notes that the playback rate is greater than 1 and therefore the core player will continue to move away from the desired playback range. The sequencer tells the seekbar painting code to terminate playback as if end of media had been reached.

 3 The core player stops playback and calls OnEndOfMedia reporting a playback rate 1. The sequencer responds by returning a playback segment pointing to the current clip with initial playback position equal to the maximum playback timestamp live position and initial playback rate of 1.

 4 As an optimization while at the live position further attempts to enter fast forward may optionally be blocked by way of playback policy. As playback position as reported via seekbar painting code drifts away from live position playback policy may be relaxed to allow fast forward again.

In one embodiment system handles a user being paused on live content close to the left edge of the DVR window in the following manner.

 1 Even when paused the native player application is expected to call the sequencer frequently for seekbar painting instructions. This is so that server live position can continue to be painted on the seekbar which continues to advance even as the user is paused.

 2 When calling for seekbar painting instructions the native player application reports playback rate as 0.

 3 Eventually the current playback position is equal to or less than the minimum playback range timestamp. The sequencer notes that the playback rate is 0 and so the playback position will continue to move away from the desired playback range. On this call to ManifestToSeekbarTime the sequencer sets pfPlaybackRangeExceeded to true to terminate the current playback session.

 4 The native player application complies with the request by stopping playback and calling OnEndOfMedia. The sequencer returns a playback segment pointing to the current live clip initial playback position at left edge of DVR window initial playback rate of 1 .

In one embodiment system handles a mid playback invalidation of a currently playing playlist entry in the following manner. In one embodiment it is the responsibility of the base sequencer to deal with the scenario where the sequential playlist has been updated thus invalidating the currently playing playlist. Thus when the application calls IPlayerSequencer with a pointer to the sequential playlist entry that is currently playing which no longer exists in the new sequential playlist the base sequencer deals with this situation. This can be dealt with in a number of ways including but not limited to 1 Keeping the old sequential playlist around until nobody is referencing it in this way the old sequential playlist entry can be mapped to a linear timestamp which can then be mapped to the new sequential playlist entry or 2 disallow wholesale replacement of sequential playlists and instead implement the add delete modify API in this way deletion or modification of a playlist entry can mark the entry as dead but still keep it in the playlist until nobody is referencing it . It should be noted that implementation of option 1 suggests the creation of a CircularReference class which allows for a reference to a sequential playlist entry to keep its parent sequential playlist alive and allows for access to the parent from the child.

In one embodiment system handles a live event becoming on demand in the following manner. When a live event ends and becomes on demand the native player application signals this by calling OnEndOfMedia on the current playback segment. If the current playback segment points to the last sequential playlist entry in the list then the base sequencer will return null for the next playback segment which causes the application to stop playback.

There may be cases where the current playback segment does not point to the last sequential playlist entry in the list. This can arise if advertisements have been scheduled for a future time that now will no longer be reachable. In one embodiment the scheduler is configured to avoid scheduling advertisements that will never be reached.

In one embodiment system handles start over and cloud DVR situations in the following manner. Smooth format supports live to VOD manifests that are essentially infinite manifests. Such manifests allow for start over functionality which allows a user joining in the middle of a live television program to rewind to the start even though the user joined afterwards. They also allow for cloud DVR scenarios where the player can be instructed to play a live infinite manifest between two finite timestamps. In one embodiment the scheduler is responsible for creating the sequential playlist and updating it using a plug in that models the live DVR window. In the case of start over the live DVR window plug in is set with the appropriate parameters so that the left edge does not roll forward but instead stays fixed at start of program. When the current program ends and a new program begins the live DVR window plug in is configured to know this. In the case of cloud DVR the scheduler is responsible for initializing the live DVR model in plug in so that the playback range is constrained to the proper range.

In one embodiment system handles the seeking over of unplayed advertisements in the following manner. The mid roll advertisements are clearly visible on the main content linear seekbar. When the user seeks over one or more unplayed advertisements the system forces the viewer to watch the closest skipped advertisement before finishing the seek. Consider the following example 1 Playback of main content begins at timestamp 0 and there is an advertisement at timestamp 10000 ms 2 the user immediately seeks to 12000 ms which seeks over the unplayed ad at 10000 ms 3 the system forces the user to watch the ad at 10000 ms and 4 when the advertisement is complete the system completes the seek to 12000 ms.

In one embodiment this functionality is implemented in the sequencer by the application inserting a force ad playback sequencer plug in at the start of the chain whose Seek implementation checks for skipped advertisements and if it finds them defers playback. In one embodiment the following are performed.

 1 The force ad playback plug in receives a Seek seekbar time linear time 12000 ms command directly from the application . The plug in forwards this request to the next plug in the chain of sequencer plug ins. Eventually this reaches the base sequencer which returns a playback segment pointing to main content initial playback position 12000.

 2 The force ad playback plug in takes the returned playback segment finds the playlist entry position in the playlist and walks backwards in the playlist until it finds a playlist entry which returns true for IsAdvertisement .

 3 The force ad playback plug in queries for a custom attribute by IID GUID . Assume that this custom attribute is an object with one method AdHasBeenPlayed . If the custom attribute is found and if AdHasBeenPlayed returns true then the plug in returns the playback segment unmodified and no ad is played. Otherwise the plug in will want to force the closest advertisement to be played.

 4 In this example the force ad playback plug in finds the playlist entry for the advertisement at 10000 ms and it does not find the custom attribute. Therefore this advertisement has not been played. The plug in enters the deferred user action state and saves the playback segment pointing to main content 12000 ms for later use.

 5 Instead of returning the playback segment pointing to main content 12000 ms the force ad playback plug in calls into the sequencer chain with Seek linear 10000 to obtain a playback segment to the advertisement. Thus the plug in does not create its own playback segment but rather obtains one through the sequencer chain. This allows the sequencer chain plug ins to perform their normal adjustments such as dynamic playback policy.

 6 The force ad playback plug in returns the playback segment for the advertisement which the application executes.

 8 The force ad playback plug in s OnEndOfMedia implementation first notes that the current playback segment is an advertisement. It creates an object which will return true for AdHasBeenPlayed and attaches it to the sequential playlist entry for the current playback segment.

 9 The force ad playback plug in then notes that it is in a deferred user action state. The plug in exits this state and returns the saved playback segment which points to main content at 12000 ms.

 11 Any future seeks past the advertisement at 10000 ms will not force playback of the advertisement because the custom attribute will return a value of true for AdHasBeenPlayed .

In one embodiment system is configured to provide format agnostic captions in the following manner. In one embodiment format agnostic captioning is implemented with a sequencer plug in. Captions can be conveyed in band format specific typically embedded in the video bitstream or out of band typically as a sidecar file SMPTE TT . It is often conveyed in both ways simultaneously. In one embodiment out of band captions format agnostic are provided in the following way.

 1 Whenever asked to play a new playback segment which includes a media URL the application obtains a list of URLs to caption sidecar files each URL would be for a particular language . Based on the user settings the application chooses the appropriate captions URL.

 2 The application instantiates a captions plug in given a media URL captions URL and event handler and inserts the captions plug in into the chain of plug ins in the sequencer .

 3 The captions plug in passes through all IPlayerSequencer calls to the chain and modifies no responses.

 4 The captions plug in acts on calls to IPlayerSequencer ManifestToSeekbarTime. During this call if the current playback segment matches the media URL that the captions plug in was instantiated with the captions plug in then pays attention to the current playback position expressed in manifest time .

 5 If the playback position cross a caption trigger the captions plug in fires an event and delivers the caption payload to the application . The application renders the caption immediately.

 7 In the case of live content the captions plug in is responsible for keeping itself updated. For instance it can poll re download the captions file periodically. Or a more advanced protocol can be employed.

 8 It is the responsibility of the application to resolve conflicts between in band and out of band captions and choose only one to be active at any one time.

In one embodiment of method the native player application the at least one core player and the sequencer are implemented on a client computing device that is configured to receive the composite media presentation from a plurality of server computers. The sequencer in method according to one embodiment is platform independent and stateless and the method further includes receiving by the sequencer with each of the calls a pointer to a playlist entry in the sequential playlist that is currently playing.

In one embodiment of method the playback segments comprise a combination of main content at least one linear advertisement and at least one non linear advertisement. In one form of this embodiment the main content comprises on demand content. In another form of this embodiment the main content comprises live content. In yet another form of this embodiment the sequencer is configured to support fast forwarding and rewinding through the combination of main content at least one linear advertisement and at least one non linear advertisement.

In one embodiment of method each of the playback segments includes an initial playback start time and an initial playback rate. Each of the playback segments according to one embodiment includes a uniform resource identifier URI pointing to a single segment manifest. In one form of this embodiment each of the playback segments includes splice in and splice out times that define a subrange of the single segment manifest to play a linear start time and duration and an indication of whether the playback segment represents an advertisement. The playback segments according to one embodiment represent a plurality of different media formats including at least two of Motion Picture Experts Group 4 MPEG4 or MP4 progressive Smooth HTTP live streaming HLS and dynamic adaptive streaming over HTTP DASH . In one embodiment the sequencer in method includes an application programming interface API that allows the native player application to skip and modify playlist entries in the sequential playlist.

Another embodiment is directed to a client computing device which includes a core player and a native player application configured to cause single segment media content to be played on the core player. The client computing device further includes a sequencer configured to receive a sequential playlist from a scheduler and send playback segments and seekbar update information to the native player application based on the sequential playlist. The sequencer comprises a plurality of sequencer plug ins in a chain configuration such that each sequencer plug in directly calls a next one of the sequencer plug ins in the chain configuration. The native player application is configured to play a composite media presentation and generate a corresponding seekbar for the presentation based on the playback segments and the seekbar update information sent by the sequencer.

In one embodiment the sequencer of the client computing device is configured to receive calls from the native player application at regular intervals and upon predetermined events and send the playback segments and seekbar update information to the native player application in response to the calls. In one embodiment one of the sequencer plug ins comprises a live DVR model that models a server live position and DVR window. In another embodiment one of the sequencer plug ins comprises an advertisement tracking model. The sequencer according to one embodiment is platform independent.

Another embodiment is directed to a computer readable storage medium storing computer executable instructions that when executed by at least one processor cause the at least one processor to perform a method for seamlessly playing a composite media presentation. The method includes receiving by a sequencer a sequential playlist provided by a scheduler. The sequential playlist refers to a sequence of one or more streaming media content items. The sequencer comprises a plurality of sequencer plug ins in a chain configuration. The method includes receiving by the sequencer calls from a native player application at regular intervals wherein each of the calls includes a pointer to a playlist entry in the sequential playlist that is currently playing. The method further includes sending playback segments and seekbar update information from the sequencer to the native player application based on the sequential playlist in response to the calls. The native player application is configured to play the composite media presentation using at least one core player and generate a corresponding seekbar for the presentation based on the playback segments and the seekbar update information sent by the sequencer.

Although specific embodiments have been illustrated and described herein it will be appreciated by those of ordinary skill in the art that a variety of alternate and or equivalent implementations may be substituted for the specific embodiments shown and described without departing from the scope of the present invention. This application is intended to cover any adaptations or variations of the specific embodiments discussed herein. Therefore it is intended that this invention be limited only by the claims and the equivalents thereof.

