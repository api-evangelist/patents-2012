---

title: Generating a replacement binary for emulation of an application
abstract: Disclosed are various embodiments for generating a replacement binary for emulation of an application. A computer ingests native object code and identifies a central processing unit (CPU) from the native object code. The computer transforms the native object code to produce replacement object code. When executed on the computing device, the replacement code invokes an emulator for the CPU to execute the native code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09081896&OS=09081896&RS=09081896
owner: Amazon Technologies, Inc.
number: 09081896
owner_city: Seattle
owner_country: US
publication_date: 20120321
---
Software emulation allows an application designed for one type of hardware platform to be executed on another type of hardware platform. Remote or streaming execution provides emulation of an application and further provides the input and output to be redirected from the computing device that performs the emulation to a client device. Using streaming execution a customer can execute applications for hardware different from his own device without having to buy the hardware platform or the emulation software.

The present disclosure relates to emulation of software applications. A service provider may wish to allow users to remotely execute an application so that a user can for example play a game that requires hardware that is different from his own device. In some cases the hardware required by the application is also different than that used by the service provider. If the service provider has access to the source code for the application the application may be adapted or ported to match the hardware platform used by the service provider.

However developers do not always make the source code available. In such cases the service provider may emulate the application instead. The service provide can further provide streaming execution in connection with this emulation so that the application input and output is redirected from the computing device that performs the emulation to a client device. The present disclosure uses emulation in conjunction with a process that transforms the original application before emulation.

In various embodiments disclosed herein an emulation environment executing on a computing device includes a bytecode virtual machine layered above a host operating system. The host operating system is written for or matches the particular processor on which the emulation environment executes. The bytecode virtual machine in conjunction with the host operating system allows applications composed only of intermediate or platform agnostic code to execute without emulation the operating system since the host operating system matches the processor on which it executes.

Various embodiments of the emulation environment described herein also include a platform emulator for a target hardware platform where the target hardware platform includes a target processor different than the processor used by the host operating system. The emulation environment also includes a transformation module that processes the application to be emulated before emulation in order to generate replacement code for any native code present in the application to be emulated. Native code refers to code that is specific to a hardware platform. The transformation process can be performed once and the application executed multiple times on the computing device. That is the transformation is not required to be performed every time the application is executed.

When the application to be emulated is executed the replacement code invokes an emulator. The emulator may in turn invoke host operating system if necessary. The replacement code also returns values from the emulator back to the application. Thus the transformation module in conjunction with the platform emulator allows emulation of applications that include native or platform specific code in combination with intermediate code. The intermediate code is executed by the bytecode virtual machine while the emulator executes replacement application code that was generated by the transformation module based on the application to be emulated.

The applications to be emulated may be provided in a binary format. The binary format may be implemented as a shared library and the shared library may be packaged in an application package file. In the following discussion a general description of the system and its components is provided followed by a discussion of the operation of the same.

With reference to shown is a networked environment according to various embodiments. The networked environment includes one or more computing devices in data communication with one or more client devices by way of a network . The network may include for example the Internet intranets extranets wide area networks WANs local area networks LANs wired networks wireless networks or other suitable networks etc. or any combination of two or more such networks.

The computing device may comprise for example a server computer or any other system providing computing capability. Alternatively a plurality of computing devices may be employed that are arranged for example in one or more server banks or computer banks or other arrangements. A plurality of computing devices together may comprise for example a cloud computing resource a grid computing resource and or any other distributed computing arrangement. Such computing devices may be located in a single installation or may be distributed among many different geographical locations. For purposes of convenience the computing device is referred to herein in the singular. Even though the computing device is referred to in the singular it is understood that a plurality of computing devices may be employed in the various arrangements as described above.

Various applications and or other functionality may be executed in the computing device according to various embodiments. Also various data is stored in a data store that is accessible to the computing device . The data store may be representative of a plurality of data stores as can be appreciated. The data stored in the data store for example is associated with the operation of the various applications and or functional entities described below. The data stored in the data store may include for example computing device central processing unit CPU type native code modules intermediate code modules application package files replacement code modules and transformed application package files as well as potentially other data.

The components executed on the computing device include for example a bytecode virtual machine a host operating system one or more central processing unit CPU emulators a transformation module and a binary translation module . In some embodiment the components executed on the computing device also include a streaming emulation service . The components executed on the computing device may also include other applications services processes systems engines or functionality not discussed in detail herein. These components may communicate with each other using various mechanisms including but not limited to any type of middleware framework. Examples of such frameworks include remote procedure calls simple object access protocol SOAP representational state transfer REST Windows Communication Foundation and other frameworks. Though shown as logically separate components the functionality of these components can be combined and or distributed in various ways as can be appreciated.

The bytecode virtual machine is executed to provide a run time hosted environment for intermediate code. Code that is agnostic with respect to the type of processor and hardware platform is referred to herein as intermediate code. Intermediate code executes without regard to processor or platform by executing within the context of a bytecode virtual machine . Intermediate code may take the form of bytecode for example Java bytecode. In some embodiments the bytecode virtual machine is implemented as a Java virtual machine. In contrast code that is specific to a processor or a hardware platform is referred to herein as native code. Native code may conform to a particular interface such as Java Native Interface JNI if written in Java or Platform Invoke PInvoke if written in C .

The host operating system is executed to provide operating system services such as memory management task scheduling device driver access etc. for the bytecode virtual machine and or the CPU emulator . Thus the bytecode virtual machine can be viewed as being layered above the host operating system and the host operating system as layered above the host processor and the host hardware platform of the computing device .

A CPU emulator executes on the computing device to provide emulation of various applications that are designed to execute on a target CPU different than the CPU of the computing device . For example the CPU emulator may provide emulation of an ARM processor while executing on a computing device that uses the Intel x86 processor. Thus the platform emulator allows code specific to one processor to execute on a different processor. The computing device may include multiple CPU emulators so that more than one type of CPU can be emulated.

In some embodiments the CPU emulator may provide emulation of an entire hardware platform including various peripheral devices which make up the hardware platform. In such embodiments the CPU emulator may be viewed as a platform emulator and may include a processor emulator module as well as various device emulation modules. When emulating an entire platform the emulator may use the services of an operating system such as the host operating system . For example an emulator specific to the Android operating system may map calls to an Android memory management service to a corresponding memory management service provided by a host operating system such as Linux. In this manner the platform emulator may provide emulation of an entire Android hardware platform which uses the ARM processor and the Android operating system while executing on a computing device that uses the Intel x86 processor and a Linux operating system.

Emulation of an entire hardware platform may be useful when executing applications that interact directly with hardware. If applications instead use the services of the host operating system to access hardware and do not access hardware directly emulation of the CPU is sufficient as should be appreciated.

The transformation module is executed to generate code that replaces native code with replacement code that invokes the CPU emulator . Thus the transformation module allows the computing device to execute applications that include native code for a platform different than the computing device and that also include intermediate code. The intermediate code portion of the application under emulation executes within the bytecode virtual machine and the replacement code module executes on the CPU emulator . Without the transformation module an application including native code for a different platform and also including intermediate code would not properly execute on the computing device .

The binary translation module may be executed to translate executable code for a source CPU into executable code for a target CPU. For example in an embodiment in which the application to be emulated is written for an ARM processor and computing device includes an Intel x86 processor the binary translation module may generate translate the ARM instructions to x86 instructions. The computing device may include multiple binary translation modules to handle various combinations of source and target CPU e.g. ARM to x86 x86 to ARM PowerPC to x86 x86 to PowerPC etc. .

The streaming emulation service is executed to provide streaming emulation or remote emulation of applications executing on the computing device . The streaming emulation service provides these services by interacting with the emulation environment formed by the bytecode virtual machine the host operating system the CPU emulator and the transformation module . The application executes in the emulation environment and the streaming emulation service redirects the output of the emulated application to appear on a client device rather than on a display attached to the computing device . Similarly the streaming emulation service redirects the input of the emulated application to be received from a client device rather than from a keyboard or other input device attached to the computing device .

In other environments the emulation environment is used without the streaming emulation service . In such embodiments output from the emulated application is displayed locally at the computing device and input from emulated application is received locally from input device s of the computing device .

Having discussed various components of the computing device the client device will now be discussed. The client device is representative of a plurality of client devices that may be coupled to the network . The client device may comprise for example a processor based system such as a computer system. Such a computer system may be embodied in the form of a desktop computer a laptop computer a personal digital assistant a cellular telephone a smart phone a set top box a television a music player a video player a media player a web pad a tablet computer system a game console an electronic book reader or other devices with like capability.

The client device may be configured to execute various applications such as a browser and other applications. The browser may be executed in a client device for example to access and render network pages such as web pages or other network content served up by a web server a page server or other servers. In some embodiments the network content originates from one of the computing devices . The client device may be configured to execute applications beyond browser such as for example email applications instant message applications and or other applications.

Next a general description of the operation of the various components of the networked environment is provided. To begin a user of the client device requests from the computing device execution of an application contained within an application package file . This request may be serviced by the streaming emulation service . The computing device determines that the requested application is not native to the computing device that is the application is designed for a hardware platform different than the computing device . The computing device further determines whether the application also includes intermediate code.

If both conditions are met the streaming emulation service determines whether the transformation module has already generated a replacement code module corresponding to the requested application. If not the transformation module invokes the transformation module to generate another version of the application package file one that includes an appropriate replacement code module and that will therefore in conjunction with the CPU emulator execute properly on the computing device . The transformation process will be described in further detail below in conjunction with and .

Once a replacement or transformed application package file has been generated by the transformation module the streaming emulation service cooperates with the emulation environment to execute the transformed application package file on the computing device . As noted above the streaming emulation service redirects input and output of the emulated application to the client device . Thus application appears to be executing locally on the client device but is actually being remotely emulated by the computing device .

Referring next to shown is data flow diagram illustrating one example of the operation of the transformation module of according to various embodiments of the present disclosure. To begin the transformation module ingests one or more native code modules A N which may be stored in the data store . In some embodiments a native code module takes the form of a shared library which can use various formats such as Executable and Linkable Format ELF Mach O and Process Executable PE . The transformation module then transforms each native code module to produce a corresponding replacement code module . In some embodiments a replacement code module takes the form of a shared library one that is separate from the shared library in which the native code module resides.

A replacement code module includes code that when executed on a computing device invokes a CPU emulator also executing on the computing device and further causes the CPU emulator to execute code in the native code module . Thus where execution of the native code module causes the hardware platform to take certain actions execution of the corresponding replacement code module causes the CPU emulator to perform equivalent actions.

In some embodiments the replacement code module when executed on the computing device provides parameters to the CPU emulator where these parameters were provided by the native code module . In some embodiments the replacement code module when executed on the computing device obtains a result obtained from invoking the CPU emulator and returns that result to the caller of the replacement code. The replacement code module thus performs a two way function. First the replacement code module is called by an intermediate code module and the replacement code module in turn passes parameters to the CPU emulator . Next when the CPU emulator returns the replacement code module returns the result to its caller. In some embodiments the replacement code module is invoked by the bytecode virtual machine and the replacement code module returns the result provided by the CPU emulator to the bytecode virtual machine .

To generate the replacement code module the transformation module first parses the native code module to identify a list of native methods that are contained within and exported by the native code module . The transformation module may use various mechanisms for determining that an exported method is a native method. Some of these identification methods may be platform dependent. For example native code that conforms to Java Native Interface JNI uses a predefined name format for exported native methods. The JNI name for an exported native function takes the form of a concatenated string containing the prefix Java  a mangled fully qualified class name an underscore   separator a mangled method name and for overloaded native methods two underscores   followed by the mangled argument signature.

Having identified the native methods in the native code module the transformation module creates a stub native method for each of the native methods. A stub native method has the same name as the native method in the native code module . The transformation module then fills in the stub native method with code that when executed on a computing device invokes a CPU emulator also executing on the computing device and also causes the CPU emulator to execute code in the native code module . As a result when the computing device executes the replacement code module the emulator first executes the processor instructions in the native code module and then provides the result of the emulated processor instructions to the replacement code module .

The code to invoke the CPU emulator may be emulator specific and or platform specific. For example a software trap instruction may be used to invoke the CPU emulator . The location of the code to be emulated may be passed as a parameter to the CPU emulator . In some embodiments the CPU emulator loads the native method from the shared library containing the native code module .

Having generated a replacement native method for each native method in the native code module the transformation module adds these replacement native methods to the replacement code module . In some embodiments the replacement code module is included in a shared library. The transformation module may generate a single shared library that includes replacement code from multiple replacement code modules or may generate a different shared library for each replacement code module .

Moving on to shown is data flow diagram illustrating another example of the transformation module of according to various embodiments of the present disclosure. To begin the transformation module obtains an application package file from the data store . The application package file may be an archive file that supports a hierarchical directory structure. In some embodiments an application package file is based on the Java Archive JAR file format and or is compressed using the ZIP file format. The transformation module then parses the application package file to identify native code modules and intermediate code modules . These code modules may take the form of object code files or shared library files.

The transformation module then uses the techniques described herein to transform each native code module into a corresponding replacement code module . As noted above a replacement code module includes code that when executed on a computing device invokes a CPU emulator also executing on the computing device and also causes the CPU emulator to emulate code in the native code module .

Having generated one or more replacement code modules the transformation module adds the replacement code modules to the application package file to produce a transformed application package file . The location of the replacement code modules within the application package file is platform specific. For example the name of the directory which stores the replacement code modules may be based on the processor type and or platform type e.g. lib armeabi . In some embodiments the transformation module leaves untouched the native code modules in the application package file so that the transformed application package file includes the original native code modules from the original application package file along with additional corresponding replacement code modules .

With reference now to shown is a flowchart that provides one example of the operation of a portion of the streaming emulation service according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the streaming emulation service as described herein. As an alternative the flowchart of may be viewed as depicting an example of steps of a method implemented in the computing device according to one or more embodiments.

Beginning at box the streaming emulation service obtains a request from a client device to stream a particular application. Next at box the streaming emulation service locates the application package file that corresponds to the requested application and examines the application package file or components within the application package file to identify the type of processor required to execute the application. In some embodiments the processor type may correspond to a processor architecture or family rather than a specific manufacturer model version or stepping. For example the streaming emulation service may identify the processor type as x86 rather a more specific identification such as Intel Celeron or AMD K5 . As another example the service may identify the processor type as 32 bit x86 rather than Intel 80386 80486 or Pentium .

Next at box the streaming emulation service determines whether the processor type of the application package file matches the type of the host processor of the computing device . This information may be determined once and stored in the data store as CPU type . The service may determine the host processor type in various ways for example by a call to an operating system service from a registry database from stored configuration information or through various other mechanisms.

If the processor in the application package file matches the host processor type then processing continues at box where the streaming emulation service provides remote execution of the requested application. When the application is finished executing the process of is complete. Techniques for remote execution are described in the following commonly assigned applications each of which is hereby incorporated in its entirety Ser. No. 12 968 845 Sending Application Input Commands over a Network Ser. No. 13 099 753 Reducing Latency for Remotely Executed Applications and Ser. No. 13 114 534 Remotely Emulating Computing Devices .

If however it is determined at box that the application package file does not match the host processor type then processing continues at box where a further comparison is performed. At box the streaming emulation service determines whether the processor type of the application package file matches one of the CPU emulators executing on the computing device . If the processor in the application package file matches an emulator then processing continues at box where the transformation module is invoked to transform the application code as appropriate using techniques described herein. In some embodiments the transformation module may be provided with a parameter that indicates the CPU type for the emulator . In other embodiments multiple transformation modules may be used each specific to a particular CPU emulator .

Once the transformation module has transformed native code present in the application package file then at box the streaming emulation service emulates the requested application using the transformed code in the transformed application package file . When the emulated application is finished executing the process of is complete.

If however it is determined at box that the application package file does not match a CPU emulator then processing continues at box . Box is thus reached when the processor required by the application file does not match the host processor of the computing device or a CPU emulator on the computing device . In such case the streaming emulation service returns an error to the requesting client device and the process of is complete.

Although the embodiment illustrated in performs the transformation of native code in response to a request for streaming execution of an application other embodiments may perform the transformation before such a request. For example the transformation module may be invoked after a developer uploads or otherwise provides an application for use with the streaming emulation service . The transformation can thus be performed once as part of the ingestion process and used multiple times. This allows any performance cost associated with the translation process to be spread across many users.

Turning now to shown is a flowchart that provides one example of the operation of a portion of the transformation module according to various embodiments. It is understood that the flowchart of provides merely an example of the many different types of functional arrangements that may be employed to implement the operation of the portion of the transformation module as described herein. As an alternative the flowchart of may be viewed as depicting an example of steps of a method implemented in the computing device according to one or more embodiments.

Beginning at box the transformation module obtains an application package file from the data store . Next at box the transformation module begins an iteration loop to process any code modules within the application package file . These code modules may take the form for example of native code packaged in a shared library of intermediate code packaged in a class library of object or binary code as well as other forms of code. At box the transformation module determines whether the code module currently being processed includes native code or intermediate code. As explained above native code is specific to a particular hardware platform and or processor.

If it is determined at box that the current code module includes one or more native methods the transformation module moves to box . At box the transformation module generates a transformed native method for native methods in the current code module. In some embodiments the transformation involves generating code that invokes a CPU emulator as described above. In other embodiments the transformation involves a binary translation of instructions that are specific to the processor required by the application into instructions that are specific to the host processor of the computing device . For example if the application to be emulated includes code for an ARM processor and the host processor of the device is an Intel x86 processor then the transformation at box may process native methods in the current code module to translate the ARM instructions to x86 instructions.

Next at box the transformation module adds the transformed native method s to a new shared library one that contains transformed replacement code modules rather than the original native code modules . At box the transformation module adds the new shared library to the application package file thus producing a transformed application package file . Processing then continues at box where the transformation module continues the iteration loop by retrieving the next code module in the application package file .

If however it is determined at box that the current code module contains intermediate code the transformation module continues at box where the transformation module generates transformed intermediate methods for methods in the current code module. For example when the intermediate code module includes code that invokes native methods then the invocation may be transformed to reorder parameters passed to the native method.

At box the transformation module replaces the original intermediate method s in the current intermediate code module with the transformed intermediate method s . Processing then continues at box where the transformation module continues the iteration loop by retrieving the next code module in the application package file .

When all code modules have been processed the iteration loop ends. Having generated a transformed application package file from the original application package file the process of is complete. Otherwise the transformation module continues processing with the next code module at the top of the iteration loop box .

The embodiment described in connection with transformed intermediate code modules as well as native code modules. In another embodiment only native code modules are transformed. In yet another embodiment only intermediate code modules are transformed.

Moving on to shown is a schematic block diagram of the computing device according to an embodiment of the present disclosure. The computing device includes at least one processor circuit for example having a processor and a memory both of which are coupled to a local interface . To this end the computing device may comprise for example at least one server computer or like device. The local interface may comprise for example a data bus with an accompanying address control bus or other bus structure as can be appreciated.

Stored in the memory are both data and several components that are executable by the processor . In particular stored in the memory and executable by the processor are the CPU emulator the bytecode virtual machine the transformation module streaming emulation service and potentially other applications. Also stored in the memory may be a data store and other data. In addition an operating system may be stored in the memory and executable by the processor . While not illustrated the client device also includes components like those shown in whereby the browser is stored in a memory and executable by a processor.

It is understood that there may be other applications that are stored in the memory and are executable by the processors as can be appreciated. Where any component discussed herein is implemented in the form of software any one of a number of programming languages may be employed such as for example C C C Objective C Java JavaScript Perl PHP Visual Basic Python Ruby Delphi Flash or other programming languages.

A number of software components are stored in the memory and are executable by the processor . In this respect the term executable means a program file that is in a form that can ultimately be run by the processor . Examples of executable programs may be for example a compiled program that can be translated into machine code in a format that can be loaded into a random access portion of the memory and run by the processor source code that may be expressed in proper format such as object code that is capable of being loaded into a random access portion of the memory and executed by the processor or source code that may be interpreted by another executable program to generate instructions in a random access portion of the memory to be executed by the processor etc. An executable program may be stored in any portion or component of the memory including for example random access memory RAM read only memory ROM hard drive solid state drive USB flash drive memory card optical disc such as compact disc CD or digital versatile disc DVD floppy disk magnetic tape or other memory components.

The memory is defined herein as including both volatile and nonvolatile memory and data storage components. Volatile components are those that do not retain data values upon loss of power. Nonvolatile components are those that retain data upon a loss of power. Thus the memory may comprise for example random access memory RAM read only memory ROM hard disk drives solid state drives USB flash drives memory cards accessed via a memory card reader floppy disks accessed via an associated floppy disk drive optical discs accessed via an optical disc drive magnetic tapes accessed via an appropriate tape drive and or other memory components or a combination of any two or more of these memory components. In addition the RAM may comprise for example static random access memory SRAM dynamic random access memory DRAM or magnetic random access memory MRAM and other such devices. The ROM may comprise for example a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other like memory device.

Also the processor may represent multiple processors and the memory may represent multiple memories that operate in parallel processing circuits respectively. In such a case the local interface may be an appropriate network that facilitates communication between any two of the multiple processors between any processor and any of the memories or between any two of the memories etc. The local interface may comprise additional systems designed to coordinate this communication including for example performing load balancing. The processor may be of electrical or of some other available construction.

Although the transformation module and other various systems described herein may be embodied in software or code executed by general purpose hardware as discussed above as an alternative the same may also be embodied in dedicated hardware or a combination of software general purpose hardware and dedicated hardware. If embodied in dedicated hardware each can be implemented as a circuit or state machine that employs any one of or a combination of a number of technologies. These technologies may include but are not limited to discrete logic circuits having logic gates for implementing various logic functions upon an application of one or more data signals application specific integrated circuits having appropriate logic gates or other components etc. Such technologies are generally well known by those skilled in the art and consequently are not described in detail herein.

The flowcharts of show the functionality and operation of an implementation of portions of the transformation module . If embodied in software each block may represent a module segment or portion of code that comprises program instructions to implement the specified logical function s . The program instructions may be embodied in the form of source code that comprises human readable statements written in a programming language or machine code that comprises numerical instructions recognizable by a suitable execution system such as a processor in a computer system or other system. The machine code may be converted from the source code etc. If embodied in hardware each block may represent a circuit or a number of interconnected circuits to implement the specified logical function s .

Although the flowcharts of show a specific order of execution it is understood that the order of execution may differ from that which is depicted. For example the order of execution of two or more blocks may be scrambled relative to the order shown. Also two or more blocks shown in succession in may be executed concurrently or with partial concurrence. Further in some embodiments one or more of the blocks shown in may be skipped or omitted. In addition any number of counters state variables warning semaphores or messages might be added to the logical flow described herein for purposes of enhanced utility accounting performance measurement or providing troubleshooting aids etc. It is understood that all such variations are within the scope of the present disclosure.

Also any logic or application described herein including the transformation module that comprises software or code can be embodied in any non transitory computer readable medium for use by or in connection with an instruction execution system such as for example a processor in a computer system or other system. In this sense the logic may comprise for example statements including instructions and declarations that can be fetched from the computer readable medium and executed by the instruction execution system. In the context of the present disclosure a computer readable medium can be any medium that can contain store or maintain the logic or application described herein for use by or in connection with the instruction execution system. The computer readable medium can comprise any one of many physical media such as for example magnetic optical or semiconductor media. More specific examples of a suitable computer readable medium would include but are not limited to magnetic tapes magnetic floppy diskettes magnetic hard drives memory cards solid state drives USB flash drives or optical discs. Also the computer readable medium may be a random access memory RAM including for example static random access memory SRAM and dynamic random access memory DRAM or magnetic random access memory MRAM . In addition the computer readable medium may be a read only memory ROM a programmable read only memory PROM an erasable programmable read only memory EPROM an electrically erasable programmable read only memory EEPROM or other type of memory device.

It should be emphasized that the above described embodiments of the present disclosure are merely possible examples of implementations set forth for a clear understanding of the principles of the disclosure. Many variations and modifications may be made to the above described embodiment s without departing substantially from the spirit and principles of the disclosure. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims.

