---

title: Identifying business transactions from traffic in an enterprise content management system
abstract: Systems and methods are disclosed for identifying business transactions from traffic in an enterprise content management system. The system intercepts HTTP messages that originate from or are destined for a server in an enterprise content management (ECM) system. The system also receives notifications related to lifecycle events in the ECM system. The system then correlates information in the HTTP messages and the notifications to identify a corresponding business transaction performed by the ECM system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09166991&OS=09166991&RS=09166991
owner: RTIP, Inc.
number: 09166991
owner_city: Alpharetta
owner_country: US
publication_date: 20120426
---
The present disclosure generally relates to enterprise content management systems and more specifically to identifying business transactions from traffic in an enterprise content management system

Today enterprises such as businesses governments educational institutions and various other organizations use vast amounts of data to drive decision making in their organization. Enterprises use many varieties of computerized information systems and a large amount of networking infrastructure to manage and organize the structured semi structured and unstructured data used by the enterprise. As the number of systems and the amount of data continues to grow keeping these systems running at an acceptable level of availability and performance becomes more of a challenge.

Having summarized various aspects of the present disclosure reference will now be made in detail to the description of the disclosure as illustrated in the drawings. While the disclosure will be described in connection with these drawings there is no intent to limit it to the embodiment or embodiments disclosed herein. On the contrary the intent is to cover all alternatives modifications and equivalents included within the spirit and scope of the disclosure as defined by the appended claims.

Enterprise content management ECM system provides various computing services associated with content and or documents that are related to the organizational processes of an enterprise such as capturing managing storing preserving and or delivering the content and documents to various users. Users associated with the enterprise interact with ECM system through various ECM clients . For example a user may through ECM client view or check out documents collaborate and share documents with other users. As another example a user may interact with ECM client to run a workflow application which leads a user through various forms necessary to complete a business task. ECM system may include components that are specific to or customized for a particular enterprise. In some embodiments ECM system is implemented with Microsoft SharePoint but the techniques disclosed herein also apply to other enterprise content management systems.

Application Performance Monitoring APM system provides computing services that monitor the behavior and health of software and hardware components of ECM system . In particular as users associated with an enterprise interact with business related content through ECM system APM system collects experience and performance data that allows the enterprise to monitor the actual user experience with ECM system in terms of for example response times activity levels during particular time periods etc. As shown in APM system may include some software components that are deployed within ECM system while the remaining components may be separate from ECM system .

The experience and performance data collected by APM system may be provided through various mechanisms and in various forms to enterprise personnel such as managers decision makers or system administrators. These users interact with the APM system through one or more APM clients . For example APM system may generate and provide to users a dashboard display of various metrics related to the monitored ECM system . APM system may allow users to generate reports related to the monitored metrics and to configure alerts and alarms which are triggered when the metrics go out of range. As another example APM system may allow a user to create tests that exercise specific functionality of ECM system .

In the example configuration shown in ECM system includes one or more web front end servers one or more application servers and one or more database servers . Such a collection of servers may be referred to as a server farm. A web front end server operates as a Hyper Text Transport Protocol HTTP server serving up enterprise content to various ECM clients shown in . Content may take the form of for example sites lists or libraries. Although content may be cached locally by a web front end server a content database on database server acts as a repository for the content . An application server hosts various services or granular components of functionality which combine to provide the overall functionality of the ECM system . In the example configuration shown in applications and are hosted by application server A while applications and are hosted by application server B.

A non limiting list of services which may be hosted by an application server includes search indexing application discovery and load balancing. Some service applications may be part of the ECM platform itself e.g. part of Microsoft SharePoint while others may be provided by a third party to extend the functionality of ECM system . The services hosted by application server may be implemented using a variety of middleware frameworks such as Sharepoint Service Application Framework Windows Communication Foundation WCF service oriented architecture SOAP representational state transfer REST remote procedure calls RPC and combinations thereof.

As mentioned above in connection with APM system includes components that are deployed within ECM system . As shown in these deployed APM components include a collector one or more event receivers and one or more HTTP sniffers . In the embodiment shown in an instance of HTTP sniffer and an instance of event receiver are deployed on all web front end servers and application servers while a single collector is deployed on one of web front end servers or application servers .

Collector receives messages from HTTP sniffer s and event receiver s . These messages are generated as users interact with ECM system to perform various business level transactions for example completing a specific workflow e.g. Order Widget or checking out a particular file e.g. Check Out Prospectus . When associated with time and quantity information these enterprise transactions measure the actual experience of users interacting with ECM system . A non limiting list of experience metrics includes average time to check out a particular document and number of orders completed using a particular workflow during a one hour period.

Collector examines the incoming sniffer messages and event receiver messages and create one or more transaction packets which encapsulate at least a portion of the data from the sniffer provided HTTP messages and the ECM provided events. Data encapsulated by collector in a transaction packet may include for example a transaction packet type an IP address and or port from the sender client or receiver server a user name a session identifier an instance identifier a timestamp a uniform resource indicator URI a content size an object type an ECM site name an ECM list title an ECM object type and an ECM item name. Collector may map user name to client IP address and vice versa. After creating a transaction packet collector communicates the transaction packet to the APM system . In particular collector sends the packets to a transaction server .

The process of extracting business level transactions from the stream of transaction packets provided by the collector will be described at a high level here then explained in further detail below. In brief transaction server processes the transaction packets according to a transaction schema which contains definitions of the supported transactions. For example the schema may indicate that a Check Out transaction includes the following sequence an event indicating creation of a check out object an HTTP GET message with a first specified URI an HTTP PUT message with a second specified URI and an event indicating deletion of a check out object. The schema may be implemented for example using eXtensible Markup Language XML .

A non limiting list of business level transaction types includes document folder list search and workflow. A non limiting list of business level transactions includes 

Once the transaction server has identified a particular business transaction by correlating the series of transaction messages received from collector transaction server writes the transactions to an APM database . In some embodiments an adapter module may translate the transaction data from one format to another. For example the transaction packets generated by collector and received by transaction server may be expressed in XML while APM database uses a binary record format. In such cases adapter module may create a database record appropriate for APM database and then populate the record from the XML data in the received transaction packet.

Once business level transactions are stored in APM database other components of APM system may utilize the transaction data in various ways. For example a reporting sever may communicate this data to enterprise users such as managers and decision makers by generating various reports. Reporting sever may also check various metrics associated with the transactions and determine whether a transaction metric has exceeded or has dropped below a service level threshold e.g. 25 of View Document transactions have exceeded a threshold . Reporting sever may also proactively take remedial action when a service level violation is detected.

Having discussed the overall process of identifying business level transactions in the ECM system from a combination of HTTP traffic and ECM object events HTTP sniffer and event receiver will now be discussed in more detail. An event receiver receives notifications related to the lifecycle of various objects in ECM system . A non limiting list of lifecycle events includes add delete move update check in check out cancel check out and convert. A non limiting list of ECM objects includes sites lists list items documents folders searches and workflows. A given event receiver may handle notifications for more than one type of ECM object.

As noted above each event receiver is deployed on a particular server or . An event receiver registers to receive notifications for those objects that are managed by applications hosted on that server or . For example event receiver A is hosted on server A and therefore handles notifications for objects managed by applications and .

An HTTP sniffer intercepts or sniffs HTTP traffic originating at or destined for its corresponding server or . As a web server web front end server receives requests for web pages and provides a web page in response. Thus an HTTP sniffer deployed on a web front end server will generally see corresponding HTTP messages such as GET PUT POST etc. In addition middleware protocols such as SOA protocol SOAP and REST build on HTTP so an HTTP sniffer deployed on a web front end server may also see HTTP messages that correspond to SOAP and REST traffic. Similarly an HTTP sniffer deployed on an application server will see HTTP messages for SOAP and REST traffic associated with applications hosted on that application server .

As event notifications and HTTP messages are received by event receiver and HTTP sniffer respectively these events and messages are communicated to collector at block and block respectively. In some embodiments communication between event receiver HTTP sniffer and collector is implemented with a queuing service such as Microsoft Messaging Queuing Service. Event receiver HTTP sniffer may preprocess the event message before communicating the data to collector . By doing so only a subset of information in the event message is passed on to collector . The preprocessing may also add information that is not in the actual object lifecycle event or HTTP message for example information identifying event receiver or HTTP sniffer .

Processing then continues at block or block depending on whether an event or HTTP message was received. In either case collector creates a transaction packet using data from the event or message. Finally at block collector sends the transaction packet to the transaction server and the process of is complete.

Next at block transaction server determines whether the transaction packet received at block marks the end of a business level transaction. If No then processing continues at block where transaction server awaits another transaction packet. If Yes then at block transaction server generates a description of the transaction including specifics from the transaction packet e.g. file or folder name timestamps user name . In some embodiments the description may be expressed in XML. Next at block transaction server stores the transaction in APM database . Some embodiments of APM system may translate the description from one format to another for example from XML to a binary record format as used by a relational database. Though not expressly shown in the flowchart the process of eventually terminates either through a graceful exit or an abnormal condition such an exception but otherwise continues to process events and messages indefinitely.

As mentioned above blocks and in process the current transaction packet in the context of a series of previously received transaction packets in order to identify a single business level transaction defined in schema . This process will now be described in more detail in connection with . Before describing those details an example of a transaction definition will now provided in order to provide context for the discussion of . In some embodiments a transaction definition includes the following fields 

Next at block transaction server checks for the existence of duplicate packets in the transaction and handles a duplicate if found. To do so transaction server examines the definition of the current pending transaction to determine if duplicate packets are allowed and the definition does not include an end URL. If either condition is false then processing continues at block discussed below . If both conditions are true transaction server then compares the StartURL in the definition with the URL of the currently received transaction packet. If the URLs match then the currently received transaction packet is a duplicate which is saved for later completion and the process is complete. If the URLs do not match then the currently received packet is not a duplicate and the current pending transaction is completed and processing continues at block with the iteration of the next pending transaction.

Next at block transaction server checks for the end of the current transaction and handles the end if found. To do so transaction server retrieves the EndURL in the definition of the current pending transaction and compares this with the URL of the currently received transaction packet. If no match is found processing continues at block with the iteration of the next pending transaction. If the URLs do match the currently received transaction packet marks the end of a business level transaction and transaction server handles this by checking the definition for any required Ending Post Data actions. If no Ending actions are required then transaction server completes the pending transaction and the process is complete. However if the definition of the current pending transaction does require one or more Ending actions the URL of the currently received transaction packet is compared to the list of Ending actions in the definition. If all required Ending actions are found in the URL then transaction server completes the pending transaction and the process is complete. If all required Ending actions are not found in the URL processing continues at block .

Transaction server reaches block if the current pending transaction is not an end of the transaction or a duplicate transaction. At block checks for a cancelled transaction and handles the cancelled transaction if found. To do so transaction server retrieves the CancelURL in the definition of the current pending transaction and compares this with the URL of the currently received transaction packet. If no match is found processing continues at block with the iteration of the next pending transaction. If the URLs do match transaction server checks the definition for any required Cancel Post Data actions. If no Cancel Post Data actions are required then the process is complete. However if the definition of the current pending transaction does require one or more Cancel Post Data actions the URL of the currently received transaction packet is compared to the list of Cancel Post Data actions in the definition. If all required Cancel actions are found in the URL then transaction server removes the pending transaction from the list and the process is complete. If all required Ending actions are not found in the URL processing continues at block with the iteration of the next pending transaction.

When it is determined at block that all transactions on the pending transaction list have been processed then the process of is complete.

Transaction server thus handles the packet as a new transaction by attempting to match the transaction packet with a transaction definition in schema . Therefore at block transaction server begins iterating through all the defined transactions. A series of tests is applied at blocks and and if the transaction packet passes all the tests then at block the currently received transaction packet is added to the list of currently pending transactions and the process of is complete The tests include comparing the URL of the transaction packet to the StartURL in the definition block comparing the URL of the transaction packet to all of the ActionURLs in the definition block and comparing the URL of the transaction packet to all the ClientURLs in the definition block . If any of the tests fail then processing continues at block which iterates to the next transaction definition. When all definitions have been handled the process of is complete.

The various components of APM system can be implemented in software i.e. instructions executing on a processor . depicts a software implementation with memory used to store collector event receiver and HTTP sniffer . Any or all of these components can also be implemented in specialized hardware logic. Hardware implementations include but are not limited to a programmable logic device PLD programmable gate array PGA field programmable gate array FPGA an application specific integrated circuit ASIC a system on chip SoC and a system in package SiP . These components may be implemented using any combination of hardware and software as should be appreciated.

In some embodiments of APM system one or more of the software implemented components are stored on a computer readable medium which in the context of this disclosure refers to any structure which can contain store or embody instructions executable by a processor. The computer readable medium can be for example based on electronic magnetic optical electromagnetic infrared or semiconductor technology. Specific examples of a computer readable medium using electronic technology include but are not limited to the following a random access memory RAM a read only memory ROM and an erasable programmable read only memory EPROM or Flash memory . A specific example using magnetic technology includes but is not limited to a disk drive and a portable computer diskette. Specific examples using optical technology include but are not limited to a compact disk read only memory CD ROM or a digital video disk read only memory DVD ROM .

Any process descriptions or blocks in flowcharts would be understood as representing modules segments or portions of code which include one or more executable instructions for implementing specific functions or steps in the process. As would be understood by those of ordinary skill in the art of the software development alternate implementations are also included within the scope of the disclosure. In these alternate implementations functions may be executed out of order from that shown or discussed including substantially concurrently or in reverse order depending on the functionality involved.

The above description has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the disclosure to the precise forms disclosed. Obvious modifications or variations are possible in light of the above teachings. The implementations discussed however were chosen and described to illustrate the principles of the disclosure and its practical application to thereby enable one of ordinary skill in the art to utilize the disclosure in various implementations and with various modifications as are suited to the particular use contemplated. All such modifications and variation are within the scope of the disclosure as determined by the appended claims when interpreted in accordance with the breadth to which they are fairly and legally entitled.

