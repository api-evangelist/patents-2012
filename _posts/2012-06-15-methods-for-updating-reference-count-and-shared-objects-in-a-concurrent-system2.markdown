---

title: Methods for updating reference count and shared objects in a concurrent system
abstract: A method for referencing and updating objects in a shared resource environment. A reference counter counts is incremented for every use of an object subtype in a session and decremented for every release of an object subtype in a session. A session counter is incremented upon the first instance of fetching an object type into a session cache and decremented upon having no instances of the object type in use in the session. When both the reference counter and the session counter are zero, the object type may be removed from the cache. When the object type needs to be updated, it is cloned into a local cache, and changes are made on the local copy. The global cache is then locked to all other users, the original object type is detached, and the cloned object type is swapped into the global cache, after which the global cache in unlocked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569356&OS=09569356&RS=09569356
owner: EMC Corporation
number: 09569356
owner_city: Hopkinton
owner_country: US
publication_date: 20120615
---
This disclosure relates generally to the field of database management and more particularly to apparatus and methods for concurrent session management.

In a distributed computing system having a content management system including a data repository users through client devices establish sessions with the content management system in order to access the data repository for read and or write operations. However in systems where concurrent access to data resources is allowed data errors can occur unless access by concurrent users to shared resources is controlled.

One control technique employs a reference counter which is updated every time an object type referenced or de referenced. However in order to update an object or object type the reference counter must be zero. When that happens the object is exclusively locked so that no other reads or writes can be committed to avoid concurrency errors. However users must wait until the object is unlocked before their session can proceed.

Therefore it would be desirable to provide a mechanism to allow updates to objects in a more efficient manner.

This disclosure describes methods and systems for concurrent collection and or generation of shared information.

In a distributed computing system concurrent access to a shared resource is controlled by a status indicator. For example in a single reader system a flag is set to TRUE to indicate concurrent access by the single reader. When the flag is FALSE then there are no concurrent sessions. In a multiple reader system a counter is incremented each time a new concurrent session is initiated and decremented each time a session is terminated and releases the shared resource. When the counter has a value of zero there are no concurrent sessions.

Typically a shared resource has a defined size for example as a linked list. In one embodiment after a user writes new data to the shared resource data push the status indicator is checked to see if there are any concurrent sessions active. If so then older data is not removed from the shared resource data pop to make room for the new data until such time as there are no more concurrent sessions for that resource. If there are no active concurrent sessions then older data is removed and the resource returns to its fixed size.

Communication network may include many interconnected computer systems and communication links. Communication links may be hardwire links optical links satellite or other wireless communications links wave propagation links or any other mechanisms for communication of information and may be the same or different for the various hardware components that are coupled to the network . Various communication protocols may be used to facilitate communication between the various systems shown in including TCP IP HTTP protocols wireless application protocol WAP vendor specific protocols customized protocols and others. In one embodiment communication network is the Internet while in other embodiments any suitable communication network may be used including a local area network LAN a wide area network WAN a wireless network an intranet a private network a public network a switched network any combinations of these and the like.

Distributed computer network is merely one illustrative embodiment and is not intended to limit the scope of the disclosure. One of ordinary skill in the art would recognize many other variations modifications and alternatives in how to effectively arrange such components and systems.

In a typical client server arrangement as shown in one or more client systems may request information from the server system which responds to the client by providing the requested information. For this reason a server system will typically have more computing and storage capacity than client systems and indeed the server system may be a gateway and content manager for providing access to content storage and related repository services as further described below. However a particular computer system may act as either a client or a server depending on whether the computer system is requesting or providing information. Further although aspects of the subject matter disclosed herein are described as using a client server environment it should be apparent that the subject matter may be embodied in other ways for example as a stand alone computer system or part of a cloud computing environment.

Server system receives requests for information from one or more of client systems and performs processing in order to satisfy the requests then forwards the resultant information back to the requesting client system. The processing required to satisfy the request may be performed by server system or may alternatively be delegated to or obtained with the help of other servers connected to communication network or to server system .

Client systems enable users to access and query information stored or managed by server system . In one embodiment a web browser application executing on a client system enables users to select access retrieve and or query information stored or managed by server system . Examples of web browser programs include the Internet Explorer browser by Microsoft Corporation the Firefox browser by Mozilla Foundation and others.

Mass storage devices may include disk drives floppy disks magnetic disks optical disks magneto optical disks fixed disks hard disks CD ROMs recordable CDs DVDs recordable DVDs e.g. DVD R DVD R DVD RW DVD RW HD DVD or Blu ray Disc flash and other nonvolatile solid state storage e.g. USB flash drive battery backed up volatile memory tape storage reader and other similar media and combinations of these.

The subject matter described herein may be computer implemented in a suitable system by providing computer executable instructions stored on a non transitory computer readable medium. A computer readable medium may include any medium that participates in providing instructions to one or more processors for execution. Such a medium may take many forms including but not limited to nonvolatile volatile and transmission media. Nonvolatile media includes for example flash memory or optical or magnetic disks. Volatile media includes static or dynamic memory such as cache memory or RAM. Transmission media includes coaxial cables copper wire fiber optic lines and wires arranged in a bus. Transmission media can also take the form of electromagnetic energy radio frequency signals acoustic or light waves such as those generated during radio wave and infrared data communications.

For example a binary machine executable version of software instructions for providing the features described herein may be stored or reside in RAM or cache memory or on mass storage device . The source code of the software may also be stored or reside on mass storage device e.g. hard disk magnetic disk tape or CD ROM . As a further example software code may be transmitted via wires or radio waves or downloaded through a network such as the Internet.

A system block diagram of the computer system workstation is shown in . The display monitor keyboard and storage devices are as shown in . The CPU cabinet contains key components such as central processor system memory input output I O controller display adapter serial or universal serial bus USB port network interface and speaker . In other embodiments a computer system may include more or fewer components and or subsystems. For one example a computer system could include more than one processor i.e. a multiprocessor system or a system may include a cache memory.

The system bus of computer system are exemplary of an interconnection scheme serving to link the subsystems. For example speaker could be connected to the other subsystems through a port or have an internal direct connection to central processor . The processor may include multiple processors or a multi core processor which may permit parallel processing of information. Computer system is only one example of a suitable computer system. Other configurations of components and or subsystems suitable for use with the methods described herein will be readily apparent to one of ordinary skill in the art.

Computer software products may be written in any of various suitable programming languages such as C C C Pascal Fortran Perl Matlab from MathWorks SAS SPSS JavaScript AJAX Java SQL and XQuery. A computer software product may be an independent application with data input and data display modules. Alternatively computer software products may be classes that are instantiated as distributed objects or component software such as Java Beans or Enterprise Java Beans both by Oracle Corporation . In one embodiment the subject matter described herein is embodied as a computer program product which stores instructions such as computer code that when executed by a computer cause the computer to perform the processes and or techniques described below.

The computer system runs an operating system OS to manage hardware resources and provide common application services for application software. As an example the computer may run a Microsoft Windows operating system e.g. Windows NT Windows XP Windows Vista Windows 7 Windows CE Windows Mobile or Linux UNIX Sun OS Solaris Mac OS X Alpha OS AIX IRIX32 or IRIX64. Other operating systems may also be used.

The client applications originate from client devices such as devices which communicate through a network with an application server in order to use one or more applications hosted on the application server. In one embodiment the network is an Ethernet connection using conventional TCP IP communication methods with both client devices and server devices. However other types of network connection technologies are well known and may also be used to full advantage including local area network LAN wide area network WAN storage area network SAN the Internet etc. Client devices may be any type of processor based digital device such as desktop or laptop computer iPhone or other smart hand held device.

The application server hosts one or more applications running on a content management platform that provide access to repository for clients hosted on content server which is also accessible to clients via network . An HTTP server is also coupled to the network to provide an administrative terminal for system operators to perform system maintenance logging access control etc.

The repository is provided for use by client applications through the content server which is accessible to the client devices through a network . The repository may include a file store for storing content items a relational database for storing attributes metadata associated with the content items a full text index store for the content items and directory services .

A software platform runs on each of the various components such as the EMC Documentum Platform software and related EMC Enterprise Content Management software distributed by EMC Corporation Hopkington Mass. The Documentum Platform provides capabilities for managing enterprise content and is the foundation for related content management and case management product offerings.

For example shows one simplified embodiment of the application server which runs a content management framework having a foundation layer such as Documentum Foundation Classes DFC an interface layer such as Documentum Foundation Services DFS and one or more applications on application layer having integrated Documentum functionality through a Web Development Kit WDK or Webtop for example. The HTTP server runs a similar content management framework for applications such as System Administrator or Intranet Client.

DFC is the programming interface for accessing the functionality of the Documentum platform through Java and COM class libraries and underlies all Documentum platforms. DFS is an SOA development framework and application programming interface API based on web services and designed to support interoperable machine to machine interaction over a network. DFS is now the primary interface for most developers and users of the Documentum platform although use the terms DFC and DFS are frequently although incorrectly used interchangeably.

Each of the clients also runs a content management framework with the API provided by the Documentum Client Library DMCL which is a linked library inside the client application a DLL in Windows a shared library in Unix . The DMCL takes documented API calls made by the client application and maps them to Server RPC functions that can be executed by the Content Server. Once the API call has arrived inside the Content Server processing is no longer affected by the DMCL environment. In fact the DMCL thread that made the call will simply be sleeping awaiting the results of the processing from the server.

The Documentum platform also includes an extensible Business Objects Framework BOF which is built into DFC. BOF provides a useful framework and methodology for developing reusable business logic components called Business Objects that can be plugged into middle tier or client applications. More information about the Documentum Platform and related content management and case management product offerings can be found on the EMC website located at URL www.emc.com.

A session is established between a client and the data repository when the client software issues an API call to connect to the content server. The DMCL on the client device creates a thread Windows or a process Unix representing the session in client memory and likewise the content server creates a thread process representing the session on the server. A session created on the client device typically does not have a timeout associated with it but will remain in client memory until disconnected. A session on the server however will usually have a timeout set in the configuration file.

Although concurrent sessions are generally permitted in most systems there are typically limits set in configuration files for the number of sessions that may be handled at one time and these limits are usually different for the client fewer sessions and the server more sessions . In the client the DMCL layer defines a key max session count in the configuration file dmcl.ini that controls the number of sessions which may be active on the client at one time. The server also includes a defined key concurrent sessions in its configuration file server.ini that controls the number of sessions that may be active on the server.

Many databases and content management systems such as the EMC Documentum platform are object oriented systems wherein each individual item is defined as an object. An object type represents a class of objects and the definition of an object type is a set of properties whose values describe individual objects of that type. Thus object types are like templates and the content server uses the type definition as a template to create an object and then set the properties of the object to values specific to that object instance.

While objects are actually stored in the data repository the content server allocates server resources including pointers and caches to facilitate session management of objects. For example an Object Cache may be defined to deal with objects based on a set of policies including fetching finding naming mapping detaching and cloning objects. A Global Cache may be defined as the object cache of the root session and is used as the basis for spawning new user sessions. A pointer may be defined to point to a specified object in the global cache. A Session Cache may be defined as the object cache for the session. When a new session is created the session cache is populated by the global cache. One or more Change Checker routines may be defined to periodically wake up and refresh the global cache and other caches as required to ensure that entries are up to date.

However considerable overhead may be consumed with cache operations. For example a subtype usually repeats the definition of its inherited attributes from its parent type. Another example from the Windows platform is that type definitions are copied from the main thread to the session thread even though they are identical. Also in Unix platforms object types are constantly updated which causes the session to create its own copy known as the copy on write COW mechanism.

Current implementations of the Type Cache are different on thread based Windows platforms see and process based Unix platforms see .

If there is a parent child cache set up in a Windows thread the global parent cache actually issues a call back into the session child cache and forces it to load the type object and then create a copy allocated from the global heap to store in its own object store. This is done to avoid lengthy locking times on the global cache which can block other sessions from accessing the cache.

As is evident from it is not trivial to maintain consistency among the global cache session cache and database when type objects are changed.

In the new implementation shown in the session cache issues an RPC to generate one or more pointers to point directly to the corresponding type objects in global cache when the session places those type objects in use. After each RPC the pointers in session cache will be set back to NULL or destroyed if only a session copy if there is no open transaction involving those type objects.

In current implementations of the type class the variable reference count ref count is used to keep track of how many times the type object is referenced including the following 

 ii cache reference count anytime a type object is added to the cache or removed from the cache the reference count is increased by one or decreased by one respectively and

 iii object reference count the number of persistent objects of the type pointing to the type object.

In particular the cache reference count and the object reference count cause the type object to be updated frequently and such operations unnecessarily consume memory creating a possible negative impact on performance. For example the reference count may trigger the copy on write mechanism on the Unix platform.

In an effort to reduce the memory overhead requirements for type objects and type cache in sessions in one embodiment the existing variable reference count is changed from an inter session counter to an intra session counter by referring only to subtypes. During type creation the variable subtype ref count will be incremented as needed.

Thus the reference count will not be increased when a type object is inserted into session cache or global cache but only when a subtype is used. Likewise there is no need to decrease the reference count when a type object is detached but only when a subtype is detached. However a type object will still be marked as invalid when it is detached from the cache.

In one thread embodiment for a Windows environment shown in a method employs two reference counts a session reference count and a subtype reference count. The new counter session reference count will be used to map a type pointer in the global cache to the session reference count. As noted above the old counter is re characterized as the subtype reference count.

In step a session is active. In step a type object is requested by the session. In step the session looks for the type object in its session cache. Step poses the question is the type object in the session cache If so then proceed to step which poses the question is the type object in the session cache valid If so then in step the session uses the type object is the session cache. If the type object is not valid in step then the type object is removed from the session cache in step and the session reference count in the global context map is decremented in step .

If the type object is not in the session cache in step then in step the session looks it up in the global cache. If the type object is in the global cache step then a pointer is placed in the session cache that points directly to the corresponding type object in the global cache in step . Further the session reference count in the global context map is increased by one in step . If the type object is not found in the global cache in step then the global cache fetches the type object from the database in step then proceeds to step .

At the end of each session RPC all entries in the session cache will be removed except for local copies . Further the session reference count for each type object in the global context map will be decreased by one if there are no open transactions.

If the subtype reference count and the session reference count are both equal to 0 and the type object is marked as invalid then it will be removed from global cache and destroyed. When a type object is destroyed the reference count to its supertype subtype will be decreased by one.

Under some conditions the object type may need to be updated in the global cache. However since the global cache is shared among threads processes any concurrency must be managed in order to avoid read or write errors. A prior solution was to simply lock the object in the global cache then make and save changes to the object and then unlock the changed object. Of course no one has access to the object when it is locked except the user making the changes and this can cause unacceptable delays.

For example changes to the type definition may be triggered by an SQL statement. Referring to a process is illustrated that improves the efficiency of updates. In step a request to change an object type is received. In step the object type is cloned from the global cache to the session cache. In step changes are made to the cloned copy of the object type. In step the global cache is locked. In step the original object type is detached from the global cache. In step the cloned copy with changes is saved into the global cache and is now the object type. In step the global cache is unlocked. In step a pointer in the session cache is updated to point to the referenced object type.

