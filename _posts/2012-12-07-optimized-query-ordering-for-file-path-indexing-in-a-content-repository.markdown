---

title: Optimized query ordering for file path indexing in a content repository
abstract: Techniques for indexing file paths of items in a repository may include, for each type associated with instances that are not associated with file path indexes, starting with folder types prior to item types in a round robin sequence, attempting to associate the instances of the type with file path indexes. The repository may be queried for instances of a current type that are not associated with file path indexes and that are filed in a folder that is associated with a file path index. Responsive to the querying returning one or more instances of the current type, the one or more instances of the current type may be associated with the file path indexes. Responsive to the querying returning one or more instances of the current type, attempting to associate the instances of the same current type with file path indexes may be repeated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09323761&OS=09323761&RS=09323761
owner: International Business Machines Corporation
number: 09323761
owner_city: Armonk
owner_country: US
publication_date: 20121207
---
The invention relates to data storage and more specifically relates to file paths of items in folder trees.

Documents and content stored as files in a content repository may be logically represented as a folder tree where each file in the content repository may be associated with and accessed by a file path that specifies a unique location of the file in the content repository. In some examples the content repository may maintain an index for the file paths of the files in the content repository referred to as a file path index so that the file path of a file in the content repository may be quickly determined instead of having to be determined on the fly when retrieving or otherwise accessing a file. As files are created deleted moved and otherwise modified in the content repository it may be necessary to update the file path index for the content repository.

In one aspect the disclosure is directed to a method for indexing file paths of items in a content repository. The method may include for each of a plurality of types associated with one or more indexable instances that are not associated with file path indexes in turn starting with folder types prior to item types in a round robin sequence attempting by at least one processor to associate the one or more indexable instances of the type with file path indexes including querying by the at least one processor the content repository for instances of a current type out of the plurality of types that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index responsive to the querying returning by the at least one processor one or more instances of the current type associating by the at least one processor the one or more instances of the current type with the one or more file path indexes and responsive to the querying returning one or more instances of the current type repeating by the at least one processor the attempting to associate the one or more indexable instances of the same current type with file path indexes.

In another aspect the disclosure is directed to a computing system. The computing system may include one or more processors. The computing device may also include an indexer operable on the one or more processors and configured to for each of a plurality of types associated with one or more indexable instances that are not associated with file path indexes in turn starting with folder types prior to item types in a round robin sequence attempt to associate the one or more indexable instances of the type with file path indexes including query the content repository for instances of a current type out of the plurality of types that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index responsive to the query returning one or more instances of the current type associate the one or more instances of the current type with the one or more file path indexes and responsive to the querying returning one or more instances of the current type repeating the attempting to associate the one or more indexable instances of the same current type with file path indexes.

In another aspect the disclosure is directed to a computer readable storage medium containing instructions. The instructions when executed on at least one programmable processor may cause the at least one programmable processor to perform operations. The operations may include for each of a plurality of types associated with one or more indexable instances that are not associated with file path indexes in turn starting with folder types prior to item types in a round robin sequence attempting to associate the one or more indexable instances of the type with file path indexes including querying the content repository for instances of a current type out of the plurality of types that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index responsive to the querying returning one or more instances of the current type associating the one or more instances of the current type with the one or more file path indexes and responsive to the querying returning one or more instances of the current type repeating the attempting to associate the one or more indexable instances of the same current type with file path indexes.

The details of one or more aspects of the disclosure are set forth in the accompanying drawings and the description below. Other features objects and advantages of the disclosure will be apparent from the description and drawings and from the claims.

In general techniques are described for creating and updating file path indexes for files that are represented as a folder tree in a content repository. Previous techniques such as crawling the folder tree to create and update file path indexes of files in the folder tree may be too resource intensive in an enterprise environment requiring high performance high scaling high stress high load and many users. One technique for ameliorating those deficiencies may include broadly querying across all types in a content repository to identify nodes that are missing file path indexes and to associate those nodes with file path indexes. However querying broadly across all types in the content repository may sometimes be too resource intensive slow and complex to execute because such a broad query may necessitate evaluation of all possible folder and document types including any combinations of folder and document types. In some examples such queries may exceed the query language limits of the content repository so that such queries are not able to be executed by the content repository.

Techniques for creating and updating file path indexes that is less resource intensive less complex and faster to execute compared to previous techniques may include splitting the queries into separate queries for each type in the content repository to identify nodes that are missing file path indexes and to associate those nodes with file path indexes. For example each type in the content repository may in turn be queried for instances of the type that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index. Because the content repository is queried for instances that are filed in a folder that is associated with a file path index wasted queries that return no instances of a type can be minimized by maximizing the instances of folder types that are associated with file path indexes prior to querying for instances of other types. Thus instances of folder types may be queried prior to instances other types. Furthermore because it is unlikely that a single query for instances of a type that are missing file path indexes will return every instance of the type that are missing file path indexes if a query for instance of a type that are missing file path indexes returns at least one instance of the type the query for instances of that same type that are missing file path indexes may be re performed prior to a query for instances of another type that are missing file path indexes until the query returns zero instances of the type.

The techniques disclosed herein may take turns in querying each different type to visit select nodes of the folder tree of that type to update and maintain the file path indexes. For example an optimized indexer is described that may for example visit only nodes within the folder tree that are of the specified type and that are missing indexes. This may significantly reduce or completely eliminate cost of visiting nodes that are already indexed or visiting nodes in the part of the content repository that should not be optimized for paths or indexed. Furthermore by taking turns in querying for instances of a single type at a time the queries may be less resource intensive compared with queries that query across a plurality of types. The queries may also be able to find instances without file path indexes at different levels of the folder tree as opposed to some techniques that traverse the folder tree a level at a time. In addition by querying for folder type prior to other types and by re querying for instances of the same type if the query for instances of that type returned at least one instance of the type the optimized indexer may reduce wasted queries that return zero instances of a type. In this way the efficiency of identifying files without file path indexes and creating file path indexes for those files within the folder tree hierarchy may be improved.

In some examples the content repository may be accessed via a services layer. The services layer may maintain the file path indexes for the files in the content repository so that a file path for a file in a folder tree may be quickly looked up. The services layer may create or update the file path indexes based on changes made to files in the content repository by applications accessing the content repository through the services layer. However in some computing environments certain applications may directly access the content repository without using the services layer to create delete move or otherwise modify the files in the content repository thereby causing the file path indexes maintained in the services layer to become out of date. As described the techniques may be used for example to optimally update the file path indexes maintained by the services layer and to determine whether any files in the content repository do not have an associated file path index maintained by the services layer.

In accordance with the techniques described herein an indexer may periodically determine whether instances of each type in the content repository qualify for an associated file path index but do not have an associated file path index by issuing queries for instances of a specified type determining the file path for those instances and may associate the file path indexes with those instances.

Computing system may be made up of one or more computing devices that each includes one or more programmable processors. In some examples computing system is a part of an enterprise environment. Content repository services layer indexer one or more applications and one or more applications may be operable on one or more computing devices. In some examples a single computing device comprises content repository services layer indexer one or more applications and one or more applications . In some other examples content repository services layer indexer one or more applications and one or more applications are spread out over a plurality of computing devices.

Content repository may be an enterprise repository that includes one or more data stores for storing documents or other digital content in computing system as files on one or more computer readable storage media. In some examples content repository is organized into a hierarchy of folders and may natively support file paths or folder trees for accessing files stored within the folders. In some examples items in content repository may be associated with types and the items in content repository may be grouped or otherwise organized according to its associated type. For example an item s associated type can denote information such as the department that the item belongs to in an organization the database table the item resides in and the like.

In some examples content repository is a relational database that receives queries and returns one or more files based on the queries. If content repository is a relational database then content repository may include tables A N tables and each of the tables may include one or more items. Items in content repository may be associated with a plurality of different types. For example items may be associated with a type based on which table out of tables in the relational database includes the item so that items A B H and J may be associated with type 1 because they are included in table 1 A items C E F and I may be associated with type 2 because they are included in table 2 B and items D G K and L may be associated with type N because they are included in table N.

In some environments content repository may include indexable content and non indexable content . Indexable content may include items that may be represented hierarchically as part of one or more folder trees by services layer . Items in indexable content may have an associated file path index in file path indexes so that the items may be uniquely identified by a file path of the item in a folder tree. In some examples file path indexes is stored in content repository and may be considered a part of non indexable content . Conversely non indexable content may include items that are not represented as folder trees by services layer . For example non indexable content includes e mail archives or e mail inboxes that are not typically represented hierarchically as a folder tree.

Services layer may be operably coupled to content repository and may provide one or more software services and interfaces to software applications such as one or more applications for accessing items stored in content repository . In some examples the services and interfaces provided by services layer includes an application programming interface API that applications may use to access data stored in content repository . In some examples services layer provides web services that applications use to access data stored in content repository .

Services layer may abstract the items in indexable content of content repository for one or more applications so that they may appear as a part of one or more folder trees. For example services layer may maintain file path indexes that includes a file path index indicating the file path for each item in a folder tree in indexable content . For example as shown in file path indexes may include a file path index for file C indicating a file path of A C thereby indicating that file C may be contained in folder A which may be contained by the root folder of a folder tree. The file path index for file C may also indicate the type associated with type C. The services and interfaces provided by services layer for example enables one or more applications to specify an item in indexable content by a file path that uniquely identifies the item in the folder tree. As shown items of one type can be contained in folders of another type. For example while item C is associated with type 2 folders A may be associated with type 1.

One or more applications may also directly access content repository without use of services layer and may directly create delete move or otherwise modify files in content repository without using or notifying services layer . Thus file path indexes maintained by services layer can become out of date if one or more applications add delete move or otherwise modify items in indexable content . For example one or more applications may directly create a new file under a pre existing folder in a folder tree or may move a file from one folder to another folder in a folder tree.

Indexer may be operably coupled to content repository and services layer and may index items in indexable content in content repository . Indexer may determine the types in content repository that are subject to file path indexing and may calculate or otherwise estimate the maximum possible number of missing file path indexes for each type that is subject to file path indexing. For each type in content repository that has at least one missing file path index indexer may associate that type with the count of missing file path indexes and may store that association in a map not shown . Indexer may for each of the types in turn starting with folder types prior to item types in a round robin sequence determine instances of the type in indexable content that do not have associated file path indexes and are filed in a folder that is associated with a file path index and may create file path indexes for those instances of the type. If content repository is queryable such as by being a relational database indexer may determine the instances of the type in indexable content that do not have associated file path indexes by sending queries to content repository . The number of instances of the type that were found during the query and associated with file path indexes may be subtracted from the count of missing file path indexes associated with the type in the map to keep track of the number of instances of the type that are still missing file path indexes.

For example indexer may identify two types that each has one or more missing file path indexes a folder type and an item type. Indexer may initially send a query to content repository for one or more instances of the folder type that qualify for file path indexes such as folder stored in indexable content do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes . Content repository may receive the query from indexer perform the query and return a query result to indexer . The query result may indicate one or more resulting instances of the folder type that met all of the requirements of the query. In response indexer may create file path indexes for the resulting instances from the querying may store each file path index in file path indexes and may decrement the number of missing file path indexes associated with the folder type by the number of instances of the folder type returned in the query result and associated with file path indexes.

If the query result indicates at least one instance of the folder type that has met all of the requirements of the query the query for one or more instances of the folder type may be repeated prior to a query is performed for any other type until no instances are returned as a result of the query.

After the query for one or more instances of the folder type returns no instances of the folder type indexer may subsequently send a query to content repository for one or more instances of the item type out of the two types that qualify for file path indexes such as items stored in indexable content do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes . Content repository may receive the query from indexer perform the query and return a query result to indexer . The query result may indicate one or more resulting instances of the item type that met all of the requirements of the query. In response indexer may create file path indexes for the resulting instances from the querying may store each file path index in file path indexes and may decrement the number of missing file path indexes associated with the item type by the number of instances of the second item type returned in the query result and associated with file path indexes.

Similar to the folder type described above if the query result indicates at least one instance of the item type that has met all of the requirements of the query the query for one or more instances of the item type may be repeated prior to a query is performed for any other type until no instances of the item type are returned as a result of the query.

Because indexer operates in a round robin schedule in querying for instances of each of the two types after the query for one or more instances of the item type returns no instances of the item type the process may repeat with the folder type and subsequently the item type until all of the indexable instances of the folder type and the item type that are missing file path indexes are now associated with file path indexes. In some examples the count associated with each of the types will not reach zero because the count may include one or more instances in non indexable content that are missing file path indexes. Thus instead of determining if the count associated with each of the types reaches zero the process may end if all of the queries consecutively one after another all return zero items.

If the query for instances of a folder type or item type that qualify for file path indexes in file path indexes do not have file path indexes in file path indexes and have a parent folder that has a file path index in file path indexes returns zero instances of the type the zero instances may not necessarily indicate that every instance of the type that qualify for file path indexes is now associated with a file path index. Because the query includes the qualifier of having a parent folder that has a file path index if the parent folder for an instance of that type is not yet associated with a file path index then the instance of that type that is a child of the unindexed parent folder is also not returned by the query until its parent folder is associated with a file path index in file path indexes .

Indexer may periodically issue queries to content repository to keep file path indexes up to date. In some examples an enterprise administrator may manually cause indexer to issue queries to content repository . In some examples indexer may automatically issue queries on a periodic basis.

To determine if each query for instances of types returns no instances a type may be marked if the query for instances of the type returns no instances and if the immediately preceding query for instances of the type immediately preceding the type returned at least one instance. As long as subsequent queries for instances of subsequent types return no instances the marked type may remain marked. However if a subsequent query for instances of a subsequent type returns at least one instance the marked type may be unmarked. If the queries loop back to the marked type and the marked type remains marked then it may be determined that there are no instances in indexable content that are missing file path indexes and the querying may terminate. Some examples of marking a specified type may include associating the specified type with a marker or any other indication that the specified type is marked setting a marked type variable to the specified type or any other techniques of marking the specified type.

As shown in indexer may determine a list of types e.g. item types or folder types and may remove the types from the list of types that are not subject to file path indexing . Because folder types are to be queried prior to other types indexer may order the list of types so that folder types are placed ahead of other types in the list of types . Subsequently indexer may set the current type to the first type in the list of types . Indexer may determine if the current type is marked . Determining if the current type is marked may in some examples include determining if the type is associated with a mark or an indication that the type is marked or may also include determining if a marked type variable is set to the type. If the type is marked then the process may end. If the type is not marked indexer may perform a query for instances of the current type that are not associated with file path indexes and that are stored in a folder that is associated with a file path index .

As shown in indexer may determine if the query returned at least 1 instance . If the query returned at least 1 instance of the current type indexer may unmark any currently marked types associate the instance with file path indexes and re perform the query for the current type. If the query did not return at least 1 instance of the type indexer may determine if a type in the list of types is currently marked . If no types in the list of types are currently marked indexer may mark the current type set the next type in the list of types as the current type and perform the query for the current type . If a type is currently marked indexer may set the next type as the current type and may check whether the current type is already marked .

As shown in if the query returned one or more instances of the current item type indexer may associated the one or more instances returned as a result of the query with file path indexes and may decrement the count associated with the current type by the count of instances of the current type that was returned and associated with file path indexes . Indexer may determine if every type in the map is associated with a zero count . If so then the process may end. However if not every item type in the map is associated with a zero count then indexer may determine if the current type is associated with a zero count . If the current type is associated with a zero count indexer may remove the current type from the list of types may set the next type in the list of types as the current type and may repeat the process with that type . As discussed above because indexer processes the item types in a round robin fashion if the current item type is the last item type in the map the indexer may circle back to the first item type in the map as the next item type. If the current type is not associated with a zero count indexer may set the next type in the list of types as the current type and may repeat the process with that type .

Folder tree may include root folder that is at the topmost level of folder tree . Because root folder is considered to be indexed the representation of root folder may be outlined by a thick black border as shown in . Children of root folder may include folder A1 folder B2 folder C3 file D4 file E4 folder F3 folder G3 folder H3 folder I3 folder J3 and file K1 . Items that are associated with file path indexes may be represented with a thick border while items that are not associated with file path indexes may be represented with a thin border. Because none of the children of root folder are indexed the representations of the children of root folder are outlined by a thin border. As also shown in items that are identified with a character together with a number may be associated with a type identified by the number so that for example folder A1 may be associated with type 1 folder B2 may be associated with type 2 folder C3 may be associated with type 3 item D4 may be associated with type 4 and so on.

For each type in content repository having one or more indexable instances that are not associated with file path indexes indexer may type by type attempt to associate one or more instances of each type with file path indexes. Because items in content repository are likely to be contained in a folder indexer may attempt to associate instances of folder types with file path indexes prior to attempting to associate instances of other types in content repository and may process the types in a round robin schedule so that if indexer may continuously loop through all of the types until all indexable instances are associated with file path indexes. Furthermore because a single query for instances of a type may be unlikely to return every single instance of the type that are missing file path indexes if the query for instances of a type that are missing file path indexes results in one or more instances of the type then the next query performed by indexer may be a query for instances of the same type that are missing file path indexes.

For each type having one or more indexable instances in content repository indexer may attempt to associate one or more instances of a type with file path indexes by querying content repository for instances of the type that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and associating the instances if any returned by the query with file path indexes. The round robin schedule denotes that indexer may repeatedly cycle through the types in order in a circular fashion until indexable instances that are missing file path indexes are associated with file path indexes.

In the example shown in because types 1 2 and 3 are folder types and because type 4 is not a folder type indexer may first attempt to associate instances of folder types 1 2 and 3 with file path indexes prior to attempting to associate instances of type 4 with file path indexes. Furthermore as discussed above if indexer is able to successfully associate one or more instances of a type with a file path index indexer may in the next query immediately re attempt to associate instances of the same type with file path indexes. Thus indexer may first attempt to associate instances of type 1 with file path indexes by querying for instances of type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. In the example shown in the query may return folder A1 and indexer may associate folder A1 with a file path index. Because the query for instances of type 1 resulted in an instance of type 1 i.e. folder A1 indexer may immediately re query for instances of type 1. However because there are no other instances of type 1 in folder tree that are missing file path indexes the query will not return any instances of type 1.

As shown in after indexer has attempted to associate indexable instances of type 1 with file path indexes folder A1 is now associated with a file path index as denoted by the thick border around the representation of folder A1 in . After the query for instances of type 1 that are missing file path indexes returned zero instances of type 1 indexer may move on and attempt to associate instances of type 2 with file path indexes by querying for instances of type 2 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. The query may return folder B2 and indexer may associate folder B2 with a file path index. Because the query for instances of type 2 resulted in an instance of type 2 i.e. folder B2 indexer may immediately re query for instances of type 2. However because there are no other instances of type 2 in folder tree the query will return zero instances of type 2.

As shown in after indexer has attempted to associate indexable instances of type 1 and type 2 with file path indexes folder A1 and folder B2 are now associated with file path indexes. After the query for instances of type 2 returned zero instances of type 2 indexer may move on and attempt to associate instances of type 3 with file path indexes by querying for instances of type 3 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. The query may return folder C3 and indexer may associate folder C3 with a file path index. Because the query for instances of type 3 resulted in an instance of type 3 i.e. folder C3 indexer may immediately re query for instances of type 3. The query may return folder F3 and indexer may associate F3 with a file path index. Because the query for instances of type 3 once again resulted in an instance of type 3 i.e. folder F3 indexer may immediately re query for instances of type 3. The query may return folder G3 and indexer may associate G3 with a file path index. Because the query for instances of type 3 once again resulted in an instance of type 3 i.e. folder G3 indexer may immediately re query for instances of type 3. The query may return folder H3 and indexer may associate H3 with a file path index. Because the query for instances of type 3 once again resulted in an instance of type 3 i.e. folder H3 indexer may immediately re query for instances of type 3. The query may return folder I3 and indexer may associate I3 with a file path index. Because the query for instances of type 3 once again resulted in an instance of type 3 i.e. folder I3 indexer may immediately re query for instances of type 3. The query may return folder J3 and indexer may associate J3 with a file path index. Finally the query for instances of type 3 resulted in an instance of type 3 i.e. folder J3 indexer may immediately re query for instances of type 3. However because there are no other indexable instances of type 3 that are missing file path indexes in folder tree the query does not result in any instances of type 3.

As shown in after indexer has attempted to associate indexable instances of types 1 2 and 3 with file path indexes all indexable instances of types 1 2 and 3 in folder tree except for file K1 are now associated with file path indexes. After the query for instances of type 3 returned zero instances of type 3 indexer may move on and attempt to associate instances of type 4 with file path indexes by querying for instances of type 4 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. The query may return file D4 and file E4 and indexer may associate each of the files D4 and E4 with a file path index. Because the query for instances of type 4 resulted in one or more instances of type 4 indexer may immediately re query for instances of type 4. However because there are no other instances of type 4 in folder tree that are not associated with file path indexes the query does not result in any instances of type 4.

As shown in after indexer has attempted to associate indexable instances of types 1 2 3 and 4 with file path indexes all indexable instances of types 1 2 3 and 4 in folder tree except for file K1 are now associated with file path indexes. Because type 4 is the last type out of types 1 2 3 and 4 to be queried by indexer indexer may after attempting to associate indexable instances of type 3 with file path indexes loop back to type 1 and attempt to associate indexable instances of type 1 with file path indexes by querying for instances of type 1 that 1 qualify for file path indexes 2 do not have file path indexes and 3 have a parent folder that is associated with a file path index and may associate the instances returned by the query if any with file path indexes. The query may return file K1 and indexer may associate file K1 with a file path index. Because the query for instances of type 1 resulted in one or more instances of type 1 indexer may immediately re query for instances of type 1. However because there are no other instances of type 1 in folder tree that are not associated with a file path index this query does not result in any instances of type 1.

As shown in every file or folder in folder tree is now associated with a file path index and thus indexer may terminate querying for indexable instances of the types represented in folder tree that are not associated with file path indexes. Indexer may determine whether to terminate the querying using a variety of techniques. In one example technique as illustrated above with respect to if a query by indexer for instances of a type resulted in zero instances of the type that are missing file path indexes and if there are no types that are currently marked then the queried type may be marked. If a subsequent query by indexer returns one or more instances then indexer may unmark the previously marked type. However if indexer loops through the types during the querying and associating and reaches the already marked type then indexer may determine that all of the instances in indexable content of content repository that are missing file path indexes are now associated with file path indexes and may terminate the process.

In another example technique as illustrated above with respect to prior to the round robin querying of the types indexer may for each type determine a count of indexable instances of the type that are missing file path indexes. In some examples indexer may estimate the count of indexable instances of each type that are missing file path indexes. Indexer may associate the count of indexable instances with the respective type in a map and may remove from the map any types that are associated with a zero count of instances. As instances of a type are associated with file path indexes the count of instances for that type may be decremented accordingly. If the count of instances for a type reaches zero indexer may skip querying for instances of that type and may remove the type from the map. If the count of indexable instances that are missing file path indexes for each type reaches zero indexer may determine that there are no indexable instances that are missing file path indexes and may terminate the querying.

Processors in one example may be configured to implement functionality and or process instructions for execution within computing device . For example processors may be capable of processing instructions stored in memory or instructions stored on storage devices . These instructions may define or otherwise control the operation of operating system indexer services layer and one or more applications .

Memory may in one example be configured to store information within computing device during operation. Memory in some examples may be described as a computer readable storage medium. In some examples memory may be a temporary memory meaning that a primary purpose of memory is not long term storage. Memory may in some examples be described as a volatile memory meaning that memory does not maintain stored contents when computing device is turned off. Examples of volatile memories may include random access memories RAM dynamic random access memories DRAM static random access memories SRAM and other forms of volatile memories known in the art. In some examples memory may be used to store program instructions for execution by processors . Memory may in one example be used by software or applications running on computing device e.g. indexer to temporarily store information during program execution.

Computing device may in some examples also include network interface . Computing device may in one example use network interface to communicate with external devices via one or more networks. Network interface may be a network interface card such as an Ethernet card an optical transceiver a radio frequency transceiver or any other type of device that can send and receive information. Other examples of such network interfaces may include Bluetooth 3G and Wi Fi radios in mobile computing devices as well as USB. In some examples computing device may use network interface to wirelessly communicate with an external device such as a server mobile phone or other networked computing device.

Storage devices may in some examples also include one or more computer readable storage media. Storage devices may be configured to store larger amounts of information than memory . Storage devices may further be configured for long term storage of information. In some examples storage devices may include non volatile storage elements. Examples of such non volatile storage elements may include magnetic hard discs optical discs floppy discs flash memories or forms of electrically programmable memories EPROM or electrically erasable and programmable EEPROM memories.

In some examples storage devices may include content repository such as content repository shown in and file path indexes such as file path indexes shown in . Content repository may include one or more data stores for storing digital content. In some examples content repository may not natively support file paths or folder trees. For example content repository may be a queryable repository such as a relational database. In some examples content repository may be an enterprise repository. Content repository in some examples may include indexable content and non indexable content. Indexable content may include data that may be represented as folder trees by services layer . Non indexable content may include data that are not represented as folder trees by services layer . In some examples file path indexes may include a file path index indicating the file path for each file in a folder tree in indexable content of content repository so that services layer may for example enable one or more applications to specify an item in content repository by a file path that uniquely identifies the item in a folder tree. In some examples file path indexes may be stored in content repository and may be considered non indexable content.

Computing device may in some examples also include one or more user interfaces . User interface may be configured to receive input from a user e.g. tactile audio or video feedback . User interface may include a touch sensitive and or a presence sensitive screen mouse a keyboard a voice responsive system or any other type of device for detecting a command from a user. In some examples user interface may include a touch sensitive screen mouse keyboard microphone or camera.

User interface may also include combined or separate from input devices output devices. In this manner user interface may be configured to provide output to a user using tactile audio or video stimuli. In one example user interface may include a touch sensitive screen sound card a video graphics adapter card or any other type of device for converting a signal into an appropriate form understandable to humans or machines. In addition user interface may include a speaker a cathode ray tube CRT monitor a liquid crystal display LCD or any other type of device that can generate intelligible output to a user.

Computing device may in some examples also include operating system . Operating system may in some examples control the operation of components of computing device . For example operating system may in one example facilitate the interaction of indexer with services layer applications processors memory network interface storage device and user interface .

Computing device may in some examples further include indexer which may be similar to indexer shown in . Indexer may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples indexer may be configured to determine items in a content repository such as content repository that are not associated with file path indexes and to associate those items with file path indexes.

Indexer may be configured to for each of a plurality of types associated with one or more indexable instances that are not associated with file path indexes in turn starting with folder types prior to other types in a round robin sequence attempt to associate the one or more indexable instances of the type with file path indexes. Indexer may query content repository for instances of a current type out of the plurality of types that are not associated with one or more file path indexes and that are filed in a folder that is associated with a file path index responsive to the query return one or more instances of the type and associate the one or more instances of the type with the one or more file path indexes. Indexer may also repeat the query for instances of a type if a query for instances of that type that are missing file path indexes returned one or more instances of the type that are missing file path indexes.

Computing device may in some examples further include services layer which may be similar to services layer shown in . Services layer may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples services layer may be configured to provide services and interfaces to applications such as one or more applications for accessing data stored in content repository . In some examples the services and interfaces provided by services layer may include an application programming interface API that applications may use to access data stored in content repository . In some other examples services layer may provide web services that applications may use to access data stored in content repository over the web.

In some examples services layer may also be configured to abstract items in content repository so that they may appear as one or more folder trees to one or more applications. For example services layer may be configured to maintain file path indexes that includes a file path index indicating the file path for files in a folder tree in content repository . The services and interfaces provided by services layer may for example enable one or more applications to specify an item in content repository by a file path that uniquely identifies the item in a folder tree.

Computing device may in some examples further include one or more applications such as one or more applications and one or more applications shown in . One or more applications may be an executable software application running on one or more processors and stored in memory or one or more storage devices . In some examples one or more applications may be configured to access items in content repository via services layer . In some examples one or more applications may be configured to directly access items in content repository without using services layer .

Any applications e.g. indexer implemented within or executed by computing device may be implemented or contained within operable by executed by and or be operatively communicatively coupled to components of computing device e.g. processors memory network interface storage devices and user interface .

As will be appreciated by one skilled in the art aspects of the present invention may be embodied as a system method or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device.

Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described below with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

Various embodiments of the invention have been described. These and other embodiments are within the scope of the following claims.

