---

title: Lock leasing method for solving deadlock
abstract: A method for resolving deadlock in a multi-threaded computing system using a novel lock lease is disclosed. A first thread leases a lock held by the first thread to a second thread different from the first thread. The leasing transfers control of the lock to the second thread while the first thread retains ownership of the lock. To lease the lock: (1) the second thread applies for the lease from the first thread; (2) the first thread grants the lease; (3) the first thread waits for the second thread to complete a task; (4) the second thread terminates the lease; (5) the first thread confirms termination of the lease. The first thread receives control of the lock back from the second thread after the second thread has finished using resources controlled by the lock. The second thread also can sublease the lock to a third thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08966147&OS=08966147&RS=08966147
owner: 
number: 08966147
owner_city: 
owner_country: 
publication_date: 20120822
---
The described embodiments relate generally to methods and apparatuses for solving deadlock and more particularly to methods and apparatuses using a novel lock lease for solving deadlock.

In computer systems a lock is a synchronization mechanism used to enforce limits on access to a resource in an environment where there are many executing threads. In other words locks are used to enforce concurrency control policies. Locks are vulnerable to certain problems and failures. One such problem is deadlock where each of two threads waits for a lock that the other thread holds and will not proceed until it has acquired the lock. Consequently unless something is done both threads will wait forever for each other.

In a conventional single threaded computing system a single thread can lock and unlock the same lock in the same thread so that no deadlock problem will occur. On the other hand in a more sophisticated multi threaded computing system deadlocks can occur when more than one thread need to acquire the same lock. For example one common source of deadlock is the following scenario. Two threads t1 and t2 share a set of common resources R by taking a lock L before accessing any of the resources in R and releasing it when done with that resource. Consider the case where thread t1 takes lock L to access resource r1 in R and then waits on thread t2 to perform a task. Deadlock occurs if thread t2 must take lock L to access resource r2 in R before it can finish. In that situation thread t1 waits for thread t2 to finish while thread t2 waits for thread t1 to release lock L. They will both wait forever and not make any further progress resulting in a deadlock.

The standard solution to this problem is create two locks L1 and L2 and split the set of resources R into two groups R1 and R2 controlled by these two different locks making sure r1 is a member of R1 and r2 is a member of R2. Now thread t1 takes lock L1 to access r1 and waits on thread t2. Thread t2 takes lock L2 to access r2. Thread t2 successfully completes its transaction so now thread t1 can also proceed. This resolves the deadlock. However for a large existing piece of software correctly dividing resources originally synchronized by a single lock into two groups synchronized by separate locks requires a significant and often overly costly engineering effort.

In summary deadlock can easily occur when two threads accessing separate resources must cooperate but these separate resources are accessed under the same lock. Re engineering the software so that these separate resources are accessed under separate locks may be too costly if the software is very complex. Therefore what is desired is an invention to avoid deadlock and costly re engineering of software.

This paper describes various embodiments that relate to methods and apparatuses that use a novel lock lease for solving deadlock. A lock lease allows a first thread to transfer control of a lock it owns to a second thread. The leasing transfers control of the lock to the second thread while the first thread retains ownership of the lock. In this way the second thread can use the resources controlled by the lock while ownership of the lock with the first thread protects the lock from other threads. The second thread returns control of the lock back to the first thread after the second thread has finished using resources controlled by the lock. In one embodiment the second thread can belong to a group of select threads given authorization to lease the lock. If two or more threads from the group of select threads attempt to lease the lock at the same time the second thread is chosen based on one of the following queues a priority based scheduling queue a round robin queue first in first out queue and shortest remaining time queue. In another embodiment the second thread can further transfer control of the lock to a third thread through subleasing. The third thread returns the lease to the second or first thread after the third thread has finished using resources controlled by the lock.

A method for resolving deadlock in a multi threaded computing system is disclosed. In one embodiment the method includes a first thread leasing a lock held by the first thread to a second thread different from the first thread. The leasing transfers control of the lock to the second thread while the first thread retains ownership of the lock. The first thread receives control of the lock back from the second thread after the second thread has finished using the lock. In another embodiment the first thread leases the lock held by the first thread to the second thread different from the first thread through the following steps 1 the second thread applies for the lease on the lock 2 the first thread grants the lease on the lock 3 the first thread waits for the second thread to complete a task 4 the second thread terminates the lease on the lock and 5 the first thread confirms termination of the lease on the lock. In yet another embodiment the second thread belongs to a group of select threads given authorization to lease the lock. If two or more threads from the group of select threads attempt to lease the lock at the same time the second thread is chosen based on one of the following queues a priority based scheduling queue a round robin queue first in first out queue and shortest remaining time queue. In a further embodiment the second thread can also sublease the lock to a third thread different from the first and second threads. The subleasing transfers control of the lock to the third thread while the first thread retains ownership of the lock. The second thread receives control of the lock back from the third thread after the third thread has finished using the lock.

An electronic device for resolving deadlock in a multi threaded computing system is disclosed. The electronic device includes a processor configured to lease by a first thread a lock held by the first thread to a second thread different from the first thread. The lease enables the second thread to use resources controlled by the lock while the first thread continues to own the lock. The processor is further configured to return the use of resources controlled by the lock back to the first thread after the second thread has finished using resources controlled by the lock. In another embodiment when leasing by the first thread the lock held by the first thread to the second thread different from the first thread the processor is configured to 1 apply for the lease on the lock by the second thread 2 grant the lease on the lock by the first thread 3 wait for the second thread to complete a task by the first thread 4 terminate the lease on the lock by the second thread and 5 confirm termination of the lease on the lock by the first thread.

A computer program product encoded in a non transitory computer readable medium for resolving deadlock in a multi threaded computing system is disclosed. In one embodiment the computer program product includes computer code for leasing by a first thread a lock held by the first thread to a second thread different from the first thread. The leasing transfers control of the lock to the second thread while the first thread retains ownership of the lock and does not use resources controlled by the lock during leasing. The computer program product further includes computer code for receiving by the first thread control of the lock back from the second thread after the second thread has finished using resources controlled by the lock. In another embodiment the computer program code for leasing the lock held by the first thread to the second thread includes the following 1 computer code for applying for the lease on the lock by the second thread 2 computer code for granting the lease on the lock by the first thread 3 computer code for waiting for the second thread to complete a task by the first thread 4 computer code for terminating the lease on the lock by the second thread and 5 computer code for confirming termination of the lease on the lock by the first thread.

Other aspects and advantages of the invention will become apparent from the following detailed description taken in conjunction with the accompanying drawings which illustrate by way of example the principles of the described embodiments.

Representative applications of methods and apparatus according to the present application are described in this section. These examples are being provided solely to add context and aid in the understanding of the described embodiments. It will thus be apparent to one skilled in the art that the described embodiments may be practiced without some or all of these specific details. In other instances well known process steps have not been described in detail in order to avoid unnecessarily obscuring the described embodiments. Other applications are possible such that the following examples should not be taken as limiting.

In the following detailed description references are made to the accompanying drawings which form a part of the description and in which are shown by way of illustration specific embodiments in accordance with the described embodiments. Although these embodiments are described in sufficient detail to enable one skilled in the art to practice the described embodiments it is understood that these examples are not limiting such that other embodiments may be used and changes may be made without departing from the spirit and scope of the described embodiments.

In particular the following detailed description often refer to a single lock as the WL workloop lock in the context of I O driver stack but it is understood that this is merely an example to enable one skilled in the art to practice the described embodiments. It is further understood that this example is not limited to WL workloop lock in the context of I O driver stack such that other embodiments may be used and changes may be made without departing from the spirit and scope of the described embodiments.

Deadlock issue occurring when multi threading is used in the context of I O input output driver stack is provided as an example. I O or input output is the communication between an information processing system such as a computer and the outside world possibly a human or another information processing system. With an incoming I O its I O request is passed down through the layers. When the lowest hardware layer has satisfied the request the request is sent back up the layers. If each driver has its own lock instead of having a single WL workloop lock for the entire driver stack then it is very easy to form deadlocks because the incoming I O request takes the locks in a reverse order from the outgoing notification. The incoming I O will take the higher level lock first then the lower level lock. The order is going from top to bottom. But when the I O finishes the notification is sent back up and the order is reversed going from bottom to top. This reversal in order makes it easy to form deadlocks. Having a single lock such as the WL workloop lock for the entire driver stack solves this potential deadlock problem. With a single lock no matter where the request comes from whether it is an incoming I O request or the device is unplugged and a notification comes in from the bottom they all take the same lock. It does not matter if the single lock is taken from the top or bottom layer. It is the same lock so the driver holding the lock has access to all the resources associated with the single lock. Consequently when the driver stack is locked by a single thread no other threads can use that lock. All other threads have to wait until that single thread releases the single lock. This ensures consistency of the I O driver data.

In single threading there are no deadlock problems because the locking and unlocking of the WL workloop lock can be designed to occur within a single thread. In two common I O tasks using single threading is shown. In task 1 an I O request is executed as follows 1 an I O comes in 2 it locks the WL workloop lock 3 it sends request and 4 it unlocks the WL lock. In task 2 an I O completion is executed as follows 1 it locks the WL lock 2 it calls Completion routine and 3 it unlocks the WL lock. All the WL locking and unlocking occur within a single thread so there are no deadlock issues. In general deadlock issues can be avoided by not holding the lock across different I O requests.

However as the I O drivers become more and more sophisticated there is a desire for the drivers to become multi threaded so they can do some background maintenance tasks etc. The complex I O driver software uses one WL lock to synchronize access to many separate resources. With multi threading two threads can access separate resources that are locked under the same WL lock. When these two threads wait on each other they deadlock. shows an example of how deadlocks can occur in multi threading. Thread locks WL. Then it waits for thread to complete transaction X before it can unlock WL. However thread needs to lock WL in order to complete transaction X so there is a deadlock as threads and wait for each other. Please note that this deadlock does not occur in single threading because in single threading one thread does all this processing and so the WL lock is always available to this one thread.

The deadlock shown in can be avoided through the use of a mechanism called lock leasing. In lock leasing a first thread leases a lock it owns to a second thread by transferring control completely to the second thread during the leasing period. During the leasing period the first thread lessor just waits for the second thread lessee to complete its processing and it does nothing with respect to the lock or the resources the lock grants access to. This is an important element of this mechanism because by not doing any processing with respect to the lock or the resources the lock grants access to consistency of the data is guaranteed. If on the other hand the first thread does something concurrently with the second thread while the second thread is holding the lease then data consistency may be compromised. Another key to this mechanism is that the first thread retains ownership of the lock so this prevents other threads from accessing resources associated with the lock while the second thread is leasing the lock. Of course it is also important for the first thread to make sure the internal structure that is protected by the lock is consistent before the first thread hands over the leased lock to the second thread. If there is any inconsistency with the internal structure then it would be unsafe for the second thread to take the leased lock. Similarly this data consistency should also be maintained before the second thread returns the leased lock back to the first thread at the end of the lease. In other words lock leasing can avoid deadlocks if a lessor thread allows a lessee thread to run via a lease when the lessor thread knows the lessee thread will access orthogonal resources and so there is no risk of violating consistency.

In the interaction between thread and thread is shown more clearly by highlighting the sequence of events. The process begins with thread locking WL. Thread does some work. Then it needs to wait for thread to complete transaction X. This triggers thread to do task. Since thread requires WL lock to do transaction X thread calls leaseApply to apply for a lock lease on WL. Thread grants the lock lease on WL when it is ready to wait for thread by calling leaseGrant. Once thread has the lock lease on WL it is able to complete transaction X. Because thread still owns the WL lock it is able to block out other threads also trying to acquire the WL lock. This protects the data that thread needs to access for completion of transaction X. When thread has completed transaction X it is able to terminate the lock lease on WL by calling leaseTerminate. Similarly when thread can confirm that it has complete control of the lease again and that no other thread has taken the lease or done any work thread can confirm lease termination by calling leaseConfirmTermination. Alternatively the step of confirming termination of the lease on the lock by the first thread can be performed before the step of terminating the lease on the lock by the second thread. For this to occur thread should first confirm that transaction X has already been completed before calling routine leaseConfirmTermination. Later thread should confirm that thread has already called routine leaseTerminate before thread unlocks WL.

To further illustrate the principles of lock leasing as demonstrated in an embodiment from I O drivers is shown in . Here lock leasing is applied to the task of clearing hardware cache so that deadlocks occurring in a multi threaded computing system are prevented. The issue of deadlock arises because two concurrently processing threads are involved with the task of clearing hardware cache. In the beginning a worker thread is activated on a client s request. This is equivalent to thread from . Worker thread locks WL and it does work. Worker thread needs to wait for the clearing cache task to complete. However the clearing cache task is performed by a different thread namely the syncer thread. The syncer thread is equivalent to thread from . The syncer thread will do I O and issue request to synchronize cache which is a special request to clear the cache of the hardware. To do a synchronize cache the syncer thread needs the WL lock. Since the worker thread still has WL lock syncer thread will do nothing while it waits for the WL lock. Meanwhile worker thread is holding WL lock and also waiting for the syncer thread to do a synchronize cache. Because both the worker thread and syncer thread are waiting for each other there is a deadlock. It should be noted that the WL lock was originally designed for the situation where all these operations are processed in the same thread i.e. single threading so the WL lock will be available for all the operations to use. But the more sophisticated multi threaded driver has bifurcated these operations into two threads so both threads wait for each other resulting in deadlock.

The lock leasing methodology of can be applied to solve the deadlock problem for synchronizing cache. This is shown in . First a new kind of WL lock is created using the routines shown in . The process begins with worker thread locking WL. Worker thread does some work. Then it needs to wait for the synchronize cache transaction to commit. Synchronize cache is performed by the syncer thread. The syncer thread does I O. Then the syncer thread calls leaseApply to apply for a lock lease on WL. Worker thread grants the lock lease on WL when it is ready to wait for syncer thread by calling leaseGrant. Once the syncer thread has the lock lease on WL it is able to complete the synchronize cache transaction which is a special request to clear the cache of the hardware. The worker thread protects the data that syncer thread will access from other threads because the worker thread still owns the WL lock. At the same time the worker thread is just waiting and not doing anything or at least not doing anything related to the lock and the data the lock protects. All this helps to protect the syncer thread transactions and maintain data consistency. When syncer thread has completed synchronizing the cache it is able to terminate the lock lease on WL by calling leaseTerminate. Similarly when the worker thread can confirm that it has complete control of the WL lock again and that no other thread has taken the lease or done any work worker thread can confirm lease termination by calling leaseConfirmTermination.

In one embodiment such as the worker thread and syncer thread example shown in only one thread is given authorization to lease the WL lock. This is accomplished by providing the identification of the syncer thread to the worker thread. However in other embodiments the authorization to lease the WL lock can be extended to more than one thread. In fact there may be a plurality of select threads which are given authorization to lease the WL lock. This plurality of threads can in turn be contained in a list of authorized lock lessees. In the scenario where there are more than one authorized lock lessee a situation can occur where two or more threads from the plurality of select threads attempt to lease the lock at the same time. In that case the second thread can be chosen based on one of the following queues a priority based scheduling queue a round robin queue first in first out queue and shortest remaining time queue. An example of such a method to choose a thread for lock leasing when two or more threads compete for the same lock lease is shown in .

Electronic device can also include user input device that allows a user of the electronic device to interact with the electronic device . For example user input device can take a variety of forms such as a button keypad dial touch screen audio input interface visual image capture input interface input in the form of sensor data etc. Still further electronic device can include a display screen display that can be controlled by processor to display information to the user. Data bus can facilitate data transfer between at least file system cache processor and controller . Controller can be used to interface with and control different hardware equipment through equipment control bus . For example control bus can be used to control a printer an image scanner a digital camera or other such equipment.

Electronic device can also include a network bus interface that couples to data link . Data link can allow electronic device to couple to a host computer or to accessory devices. The data link can be provided over a wired connection or a wireless connection. In the case of a wireless connection network bus interface can include a wireless transceiver. Sensor can take the form of circuitry for detecting any number of stimuli. For example sensor can include any number of sensors such as for example an audio sensor a light sensor computer vision sensor and so on.

The various aspects embodiments implementations or features of the described embodiments can be used separately or in any combination. Various aspects of the described embodiments can be implemented by software hardware or a combination of hardware and software. The described embodiments can also be embodied as a computer program product comprising computer readable code encoded in a non transitory computer readable medium. The computer readable medium is any data storage device that can store data which can thereafter be read by a computer system. Examples of the computer readable medium include read only memory random access memory CD ROMs HDDs SSDs solid state drives DVDs magnetic tape and optical data storage devices. The computer readable medium can also be distributed over network coupled computer systems so that the computer readable code is stored and executed in a distributed fashion.

The foregoing description for purposes of explanation used specific nomenclature to provide a thorough understanding of the described embodiments. However it will be apparent to one skilled in the art that the specific details are not required in order to practice the described embodiments. Thus the foregoing descriptions of specific embodiments are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the described embodiments to the precise forms disclosed. It will be apparent to one of ordinary skill in the art that many modifications and variations are possible in view of the above teachings.

