---

title: Tool-based testing for composited systems
abstract: Tool-based testing of composited systems indirectly tests properties of a dynamic linked library for a desktop compositor such as DWMCore.dll via an algebraic structure of tools that define composition and rendering properties and derive equivalent resource models. The system tests for undesired side effects by examining characteristics of pixels from complicated render operations and employs a framework to test the composition and rendering of Desktop Windows Manager directly on the DWMCore.dll Application Programming Interface. The process includes mimicking uDWM.dll behavior by using resources with test patterns to take controlled measurements and validate primitives. The framework includes an infrastructure, a resource model, and tools. Each tool exposes a different composition or rendering property. A tool combinator exposes high level composition properties, including correct overlapping of transparent content and visual transformation (translation, scale, color transforms, etc.) by taking tools as input and using visual tree constructs to combine them.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069905&OS=09069905&RS=09069905
owner: Microsoft Technology Licensing, LLC
number: 09069905
owner_city: Redmond
owner_country: US
publication_date: 20120716
---
When myriad developers create applications visual verification tests of these applications is typically time consuming and resource intensive due to the need for human confirmation of test results falling outside of specified parameters. For example when a developer submits a new graphics card driver user mode test programs rely on comparison of master images to output from the driver to test the driver. When the user mode test program identifies a divergence from the master image the user mode test program files a bug report and human intervention is required to address the bug.

In many cases the divergences do not actually represent problems but instead represent false positive reports of bugs due to round off errors hardware differences or non human perceptible color changes introduced by the new driver. Nevertheless a human has to review the output to determine whether a problem actually exists due to the new driver which is expensive in terms of dollar cost and time.

Desktop Window Manager DWM is part of the Windows operating system and is a full screen DirectX application that takes advantage of hardware acceleration and includes a desktop compositor and a window manager. The window manager takes care of window operations such as scrolling resizing moving minimizing maximizing and so on. The window manager also enables different window types such as layered windows popup windows and so on.

When DWM is running applications do not draw directly to the video memory but to an off screen buffer called a surface. The desktop compositor then takes surfaces for all the applications running on Windows composes the entire desktop and renders using DirectX runtime. The compositor uses various primitives to render different parts of the desktop. It represents parts of each window such as client area buttons title bar and so on using a two dimensional 2D mesh. The actual mesh used by the compositor is complex to render effects such as rounded corners and shadows and the mesh is textured using bitmaps. These bitmaps can be off screen surfaces drawn by the application or parts of the theme texture. For example the non client area of the windows that are part of the composited desktop can be rendered to present a glass like or other textured appearance. The superbar which can enclose the address bar and the navigation buttons can also be rendered to present the glass like or other textured appearance. The compositor also uses a solid color brush. For example a semi transparent black brush can be used to dim the wallpaper.

In addition various visualization elements including composition and rendering primitives as exposed by DWMCore.dll are not accessible via the Desktop Window Manager DWM API surface to consume in a user mode test suite. Such primitives often have complicated semantics and validation of the primitives behavior is problematic. DWMCore.dll and its precursor MILCore.dll represent examples of dynamic linked libraries that a desktop compositor uses to create user interface graphics.

The difficulties in testing primitives are exacerbated due to the large number of primitives and because they can be arbitrarily arranged this leads to a combinatorial explosion of possible test scenarios. In addition not every test scenario is useful for each composition and there is little indication of which of the possible test scenarios will be useful. Traditionally validating the rendering of primitives requires a previously created database of master images against which the test is run. These master images must be refreshed frequently and differences during validation due to floating point errors often lead to false indications of failure.

Tool based testing of composited systems as described herein does not rely on master images and replaces the concept of colored images in user mode testing with a representation that is less reliant on human intervention. In particular tool based testing of composited systems as described herein tests composition and rendering properties of the dwmcore.dll. Tool based testing of composited systems introduces an algebraic structure of tools and tool combinators defines the composition and rendering properties of the tools and tool combinators and demonstrates how to derive equivalent resource models rather than manipulating the resource model directly to create useful testing scenarios. By examining characteristics of pixels from complicated render operations tool based testing as described herein tests for undesired side effects of the operations while disregarding side effects that are not human perceptible.

Tool based testing of composited systems employs a framework to test the composition and rendering of Desktop Windows Manager DWM directly on top of the dynamic linked library such as DWMCore.dll s Application Programming Interface API set. The described tool based testing process provides a convenient representation of the dynamic linked library resource model and controls composition. The described tool based testing process includes creating tests that mimic uDWM.dll behavior by using resources with the test patterns to take controlled measurements and validate composition and rendering primitives.

The described tool based testing test framework includes three parts infrastructure resource model and tools. Tools control composition by driving the resource model which in turn uses the infrastructure to communicate with dynamic linked libraries that a desktop compositor uses to create user interface graphics such as DWMCore.dll.

Each of the tools exposes a different composition or rendering property. It is not necessary for a tool to focus on any particular feature. Instead tools mimic real world usage scenarios for the dynamic linked libraries such as DWMCore.dll. The described tools strike a balance between relevance of the scenario and ease of providing results validation.

One type of tools called tool combinators expose higher level composition properties such as correct overlapping of transparent content or visual transformation translation scale color transforms etc. . Tool combinators take a number of tools as input and use visual tree constructs to combine them together in a meaningful way.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used as an aid in determining the scope of the claimed subject matter. The terms techniques or facility for instance may refer to device s system s method s and or computer readable instructions as permitted by the context above and throughout the document.

The tool based testing framework described herein includes three distinct parts infrastructure resource model and tools. Tools control composition by driving the resource model. In turn the resource model uses the infrastructure to communicate with DWMCore.dll. DWMCore.dll and the precursor MILCore.dll represent examples of dynamic linked libraries that desktop compositors use to create user interface graphics.

The process and systems described herein may be implemented in a number of ways. Example implementations are provided below with reference to the accompanying figures.

In accordance with various embodiments the test suite may be hosted by various servers such as servers . . . N . For example the servers N may be configured as a server farm among many other possibilities. The test suite may be configured to receive as input content information from applications to create a composited rendering via user initiated requests from the users via the computing devices . The test suite may be configured to run tests on the composition and rendering properties of a dynamic linked library for a desktop compositor such as DWMCore.dll and to return test results based on the user requests. In another example the test suite may be configured to automatically receive as input content information from applications to create a composited desktop through an application submission system via the computing devices . In this example the test suite may be configured to run tests on the composition and rendering properties of dwmcore.dll and to return test results for each application. In another example test results may only be returned to a user submitter or test manager when the results exceed a predetermined parameter.

As illustrated the test suite is equipped with one or more processors and memory . The memory may store applications modules and or data. In some embodiments the memory may include a test framework and or operating system which may facilitate tool based testing of composited systems.

Although illustrated in as being stored in memory in some implementations test framework or portions thereof can be stored on one or more servers and or executed via a cloud based implementation accessible by test suite . In addition in some implementations test framework or portions thereof can be implemented using any form of computer readable media that is accessible by a computing device . Furthermore in some embodiments one or more components of test framework may be implemented as part of an integrated circuit that is part of or accessible to test suite or a computing device .

Computer readable media as the term is used herein includes at least two types of computer readable media namely computer storage media and communications media. Computer storage media includes volatile and non volatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other non transmission medium that can be used to store information for access by a computing device.

In contrast communication media may embody computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transmission mechanism. As defined herein computer storage media does not include communication media exclusive of any of the hardware components necessary to perform transmission.

The test framework may include a number of modules such as an infrastructure module a resource model module and a tools module . Collectively the modules may perform various operations to isolate high level scenario setup test graphics infrastructure integration and perform indirect validation of composition and rendering features provided by dwmcore.dll. Each of these modules is described in turn.

In accordance with one or more embodiments the infrastructure module communicates with the dynamic linked library for a desktop compositor such as DWMCore.dll and creates a render target. The test framework communicates with dynamic linked library for a desktop compositor directly by forming a dedicated channel using the infrastructure module of the framework. The infrastructure module creates a mock surface and mock surface manager initializes the partition manager initializes the connection manager creates transport parameters and opens a channel to the dynamic linked library for a desktop compositor. These actions also create a separate partition in the dynamic linked library for a desktop compositor which stores the resources associated with the tool based testing framework.

Once a channel is formed between the test framework and dynamic linked library for a desktop compositor such as DWMCore.dll the infrastructure module creates a desktop render target. The desktop render target acts as the root of a visual tree which represents various parts of the top level windows on the desktop.

In accordance with one or more embodiments the resource model module adds nodes to the visual tree in order to render primitives. The resource model module also creates render data and other resources corresponding to each visual. In addition the resource model module sends draw instructions to cause rendering of the primitives.

In accordance with one or more embodiments the tools module drives the resource model and creates an oracle for rendering. The tool based testing framework indirectly tests composition and rendering properties of dwmcore.dll. The tool based testing framework uses an algebraic structure of tools and tool combinators in the tools module to define composition and rendering properties and to derive equivalent resource models rather than manipulating the resource model directly to create test scenarios such as that shown on display .

As a part of test framework infrastructure enables test framework process to communicate directly with the dynamic linked library for the desktop compositor by forming a dedicated channel. Infrastructure performs operations including creating a mock surface manager initializing the partition manager and setting up a render target. When infrastructure opens a channel infrastructure also creates a separate partition in the dynamic linked library for the desktop compositor which stores each of the resources associated with the test framework .

In various embodiments infrastructure employs a variety of APIs and classes to form the channel. Infrastructure can use APIs to initialize a global partition manager to create a mock surface manager and a mock surface to initialize the connection manager to create transport parameters to create a connection to create a channel to associate the channel with the partition and to register the partition for the surface manager updates. In at least one embodiment infrastructure uses hosting and core classes as well as counterpart native classes to provide an implementation of the surface manager interfaces.

Responsive to the infrastructure forming a channel between the test framework and the dynamic linked library for the desktop compositor such as DWMCore.dll infrastructure creates a desktop render target. For example infrastructure uses a class to create a resource create a pop up window create the desktop render target of an identified size and color at an identified location using the created resource and pop up window create a visual corresponding to the created desktop render target and set the visual as the root of a visual tree.

Resource model includes builder classes to build and manage visual and render data trees resource classes to create and update composition resources and render data instruction classes to draw composition primitives. In various embodiments resource model uses a variety of classes to add nodes to a tree of visuals create render data and other resources corresponding to each visual and send draw instructions to render the primitives. Actions resource model takes to build a tree of visuals are discussed in more detail below with regard to .

In various embodiments tools drive the resource model and create an oracle for rendering. Dynamic linked libraries that desktop compositors use to create user interface graphics such as DWMCore.dll come with a breadth of composition and rendering primitives that can be arbitrarily arranged. Such an arbitrary arrangement leads to a combinatorial explosion of possible test scenarios that provide little indications of which test scenario will be useful and which test scenario will not be useful. In addition the primitives exposed by such dynamic linked libraries usually have complicated semantics such that validating the behavior of the primitives is difficult. Accordingly tools indirectly test composition and rendering properties of such dynamic linked libraries such as DWMCore.dll. Instead of manipulating the resource model directly to create scenarios tools test framework process uses an algebraic structure of tools and tool combinators defines the composition and rendering properties of the created scenarios and derives appropriate resource models . Each tool exposes a different composition or rendering property. Rather than a tool focusing on a particular feature tools mimic real world usage scenarios for DWMCore.dll while striking a balance between relevance of the scenario and ease of validating results.

Tools validate output of dynamic linked libraries for a desktop compositor such as DWMCore.dll against oracles generated on the fly which means in real time or near real time. Tools creating an oracle for rendering on the fly eliminates the need for a huge database of images which necessarily include an image per primitive per combination and per resolution. Moreover by tools creating an oracle for rendering on the fly the dynamic linked library for the desktop compositor s rendering can be modified without the need for regeneration of master images to test against.

In one example implementation a tool representing glass over a bitmap such as GlassOverBitmap Tool verifies blur quality and colorization correctness. A Glass Oracle calculates the Gaussian matrix at run time using a blur radius and sigma. The Glass Oracle convolutes part of the bitmap that lies beneath a glass region with this Gaussian matrix to calculate the blur. Test framework uses this expected rendering to verify the actual rendering of GlassOverBitmap Tool by the dynamic linked library for a desktop compositor such as DWMCore.dll. In various embodiments both the expected and actual renderings are converted from the RGB color space to the CIELab color space and one or more pixels are compared to determine whether the difference between corresponding pixels exceeds a threshold of human perception. In previous systems absent such a comparison slight changes in color that registered as a bug due to floating point errors although these changes were not noticeable lead to false positive reports of bugs which required inordinate resources to check and resolve.

Resource model creates visual nodes starting with node which represents a render target visual. Resource model uses a class to create a visual node and to add the visual node to the visual tree as a child of the render target visual node . Resource model uses the class to create additional visual nodes and and to add the visual nodes and to the visual tree as children of visual node .

In the illustrated example resource model uses a visual artifact class such as CoreVisualArtifact class to create a visual and a tree builder class such as VisualTreeBuilder class to add the created visual to the visual tree as a child of the render target visual . Resource model uses the visual artifact class to create additional visual nodes corresponding to bitmap and glass and the tree builder class to add the created bitmap visual and glass visual to the visual tree as children of the created visual .

Using another class resource model can create a variety of resources of various types to which the visuals refer. In the illustrated implementation a color artifact class such as CoreColorArtifact class creates color type resources for glass color and afterglow color and sets the value for the glass color and afterglow resources by sending a set content command. A double artifact class such as CoreDoubleArtifact class creates double type resources for glass color balance afterglow balance and blur balance and sets the value for the glass color balance afterglow balance and blur balance resources by sending a set content command. A path geometry class such as CorePathGeometryArtifact class creates path geometry type resources for glass geometries in various regions such as region region region to region N . The path geometry class also sets the value for the glass geometries according to region by sending a set content command.

Resource model uses another class to create a resource type for rendering data and to add it to the visual tree. In the illustrated example resource model uses a render data class such as CoreRenderData class to create the resource renderdata which will be used to render glass and a builder class such as RenderDataBuilder class adds resource renderdata to the visual tree. The visual artifact class sets the resource render data on the glass visual by sending a set content command. In order to render glass a render data artifact class such as CoreRenderDataArtifact class sends a render data command and a drawing instruction artifact class such as DrawGlassInstructionArtifact class sends a draw glass command with pointers to resources .

Resource model uses another class to create a resource type for a bitmap and to add it to the visual tree. In the illustrated example resource model uses a bitmap artifact class such as CoreBitmapArtifact class to create the bitmap type resource which will be used to render a bitmap and to initialize the bitmap with a test image. A render data artifact class such as CoreRenderDataArtifact class creates a renderdata type resource to render the bitmap and adds the renderdata type resource to the visual tree.

To render a bitmap the render data artifact class sends a render data command and a bitmap drawing instruction class such as DrawBitmapInstructionArtifact class sends a draw bitmap command with a pointer to the bitmap resource .

To summarize resource model includes a variety of builder classes such as a visual tree builder class and a render data builder class. Resource model uses various artifact classes as resource classes to create and update a composition resource. Examples of artifact classes that resource model can use to create and update composition resources include but are not limited to a core color artifact core double artifact core path geometry artifact and core bitmap artifact. Resource model uses various artifact classes as resource classes to create and update common visual and render data resources. Examples of artifact classes that resource model can use to create and update common visual and render data resources respectively include core visual artifact class and core render data artifact class. The resource model also contains render data instruction classes that are used to draw a composition primitive.

Tools drive the resource model and create an oracle for rendering as described in more detail below regarding and .

This acknowledges that software can be a valuable separately tradable commodity. It is intended to encompass software which runs on or controls dumb or standard hardware to carry out the desired functions. It is also intended to encompass software which describes or defines the configuration of hardware such as HDL hardware description language software as is used for designing silicon chips or for configuring universal programmable chips to carry out desired functions.

Note that the order in which the processes are described is not intended to be construed as a limitation and any number of the described process blocks can be combined in any order to implement the processes or alternate processes. Additionally individual blocks may be deleted from the processes without departing from the spirit and scope of the subject matter described herein. Furthermore while the processes are described with reference to the test suite and or computing device described above with reference to in some embodiments other computer architectures including cloud based architectures may implement one or more portions of these processes in whole or in part.

In the illustrated process at a bitmap tool creates an instance of core bitmap artifact and at the bitmap tool creates an instance of draw bitmap instruction artifact class. At the bitmap tool creates instances of the common resource classes core visual artifact and core render data artifact consistent with the discussion of .

At the bitmap tool initializes each of these classes artifacts with values that a dynamic linked library for a desktop compositor such as DWMCore.dll uses to create bitmap resource . For example this initialization includes the bitmap tool setting pixel colors of the bitmap which bitmap tool can do by generating patterns to isolate and expose issues with the rendering layer. For example vertical and horizontal stripes can effectively demonstrate issues with glass rendering from too much or not enough filtering applied by each of the linearly separated convolutions that when combined form the glass blur.

At the bitmap tool class executes functions of the resource classes discussed regarding to identify and send appropriate commands to set the render data.

In some implementations at the bitmap tool class executes functions of the resource classes discussed regarding to identify and send appropriate commands to cause rendering of the bitmap such as on a desktop . In other implementations the operation shown at may optionally be performed to cause rendering for human intervention such as when an error exceeds a threshold identifying a humanly perceptible difference.

The glass over bitmap tool represents a tool combinator that takes the bitmap tool and the glass tool as input and uses the visual tree constructs to combine the bitmap tool and the glass tool together in a way that is meaningful for testing. Similarly other tool combinators expose composition properties. These tool combinators can correct for overlapping of transparent content or of visual transformations such as translation scale color transforms etc. of composition primitives such as bitmaps or rectangles with a solid color brush.

At the resource model creates a render target visual. The render target visual may be considered the root node of a visual tree.

In some embodiments at the resource model uses a class to create a visual node . In the illustrated example resource model uses a visual artifact class such as CoreVisualArtifact class to create a visual .

In embodiments employing the visual node at the resource model uses a class to add the visual node to the visual tree as a child of the render target visual node . In the illustrated example resource model uses a tree builder class such as VisualTreeBuilder class to add the created visual to the visual tree as a child of the render target visual .

At the resource model may use a class to create a node for the bitmap. Note that a render target can be considered a base layer of a composite for rendering. For example resource model may use a visual artifact class to create a visual node corresponding to a bitmap representing a desktop background.

At the resource model may use a class to add the node for the base layer of the composite for rendering to the visual tree. For example resource model may use a tree builder class to add the created bitmap visual to the visual tree as a child of the created visual .

At the resource model may use a class to create a node for a next layer of a composite for rendering. For example resource model may use the visual artifact class to create a visual node corresponding to a glass representing a glass layer for rendering.

At the resource model may use a class to add the node for the next layer of the composite for rendering to the visual tree. For example resource model may use a tree builder class to add the created glass visual to the visual tree as a child of the created visual .

At the resource model may use another class to create a variety of resources of various types to which the visuals refer. For example resource model may use a color artifact class such as CoreColorArtifact class to create color type resources for glass color and afterglow color .

At the resource model may use another class to set color values. For example resource model may use the color artifact class to set the value for the glass color and afterglow resources by sending a set content command.

At the resource model may use another class to create combination resources. For example the resource model may use a double artifact class such as CoreDoubleArtifact class to create double type resources to balance glass color balance afterglow and balance blur .

At the resource model may use another class to set the balance values. For example the resource model may use a double artifact class to set values for the glass color balance afterglow balance and blur balance resources by sending a set content command.

At the resource model may use another class to create geometry type resources according to rendering regions. For example the resource model may use path geometry class such as CorePathGeometryArtifact class to create path geometry type resources for glass geometries in various regions such as region region region and region N .

At the resource model may use another class to set values for geometries according to region. For example the resource model may use the path geometry class to set the value for the glass geometries according to region by sending a set content command.

At the resource model may use another class to create a resource type for rendering data. For example the resource model may use a render data class such as CoreRenderData class to create the resource renderdata which will be used to render glass.

At the resource model may use another class to add the resource type for rendering data to the visual tree. For example the resource model may use a builder class such as RenderDataBuilder class to add resource renderdata and to the visual tree.

At the resource model may use another class to set a value for rendering data. For example the resource model may use a visual artifact class to set the render data resource on the glass visual by sending a set content command.

At the resource model may use another class to send a command pointing to resources. For example the resource model may use the render data artifact class to send a command with pointers to resources and in order to render glass and a bitmap respectively.

At tools create a rendering oracle. For example a tool providing for glass over a bitmap such as GlassOverBitmapTool creates the rendering of the bitmap blurred by the glass geometries which can be thought of as an expected rendering. The resource model may use another class so that a dynamic linked library for a desktop compositor such as DWMCore.dll renders the primitives which will be used to initialize the oracle with a test image.

At the resource model may use another class so that a dynamic linked library for a desktop compositor such as DWMCore.dll renders the primitives which can be thought of as an actual rendering. For example resource model may use the render data artifact class to send a render data command and a bitmap instruction class such as DrawBitmapInstructionArtifact class to send a draw bitmap command with a pointer to the bitmap resource .

At the tools compare the rendering by DWMCore.dll with the rendering generated as part of the oracle. For example comparison of the rendering by a dynamic linked library for a desktop compositor such as DwmCore.dll can be compared with the rendering generated by the oracle on a per pixel basis. In some implementations the colors at various pixels are converted to a system that is close to the human vision such as CIELab. The colors can then be compared to confirm whether they match. In some implementations when the analysis indicates that the colors do not match the tools determine whether the difference is beyond the threshold value. When the difference exceeds the threshold value an error or a bug is indicated and a bug report can be generated. In some implementation the comparison to the threshold value can be performed without first checking for a match.

Although the techniques have been described in language specific to structural features and or methodological acts it is to be understood that the appended claims are not necessarily limited to the specific features or acts described. Rather the specific features and acts are disclosed as exemplary forms of implementing such techniques.

