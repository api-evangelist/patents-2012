---

title: Validating an electronic order transmitted over a network between a client server and an exchange server with a hardware device
abstract: Methods and systems for performing risk checks on electronic orders for securities. According to one embodiment, the method comprises performing risk checks on an electronic order for a security, the electronic order being issued from a client computer to an exchange computer via a network, wherein a risk check engine is logically interposed between the client computer and the exchange computer on the network. According to the illustrative method, at the risk check engine, the electronic order is received and parsed into one of more fields and data within the fields is identified at a network layer. The risk check engine performs one or more risk checks on the data using a processing element at the network layer. If the risk checks are passed, the risk check engine permits the electronic order to be transmitted to the exchange computer. If one or more of the risk checks are violated, the risk check engine rejects the order.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09501795&OS=09501795&RS=09501795
owner: 
number: 09501795
owner_city: 
owner_country: 
publication_date: 20121029
---
This application is a continuation of U.S. patent application Ser. No. 13 216 161 filed Aug. 23 2011 the entire disclosure of which is incorporated herein by reference. This application also claims priority to U.S. Provisional Patent Application No. 61 376 162 filed Aug. 23 2010 the entire disclosure of which is incorporated herein by reference.

The present invention relates to a methods and systems for performing analysis such as risk and regulatory checks on electronic market orders for securities and more specifically methods and systems for the implementation of a risk management platform and the performance of risk regulatory checks.

In the financial industry it has been common practice since about 1995 for institutional investors to access financial exchanges for order placement via electronic computerized order management routing and trading systems. Initially these systems replaced traditional client broker communication methods such as phone and electronic mail or other electronic messaging systems such as those operated by Bloomberg or Reuters while the broker maintained their traditional role of conducting order management i.e. the placement of orders to an exchange .

However beginning in the late 1990 s a fundamental evolution began to reshape the traditional methods of order placement and order management with the introduction of direct market access or DMA . DMA allows institutional investors to place orders electronically directly to a financial exchange passing through or bypassing the order management infrastructure of their broker.

As the financial markets continued to evolve and DMA took on greater importance the dependency on technology to deliver a competitive edge particularly by realizing increased order message throughput and lower latency gained increasing importance. Achieving a competitive edge by achieving greater order message throughput and lower latency in exchange venue access became a principal concern for institutional investors.

Given the importance and benefits of quickly and efficiently routing orders to an exchange for execution the DMA model evolved to include so called naked access and sponsored access to exchanges methodologies where institutional investors access financial markets directly using their internal order management systems OMS s without transiting the order management infrastructure of their broker. With naked access and sponsored access brokers were no longer able to conduct regulatory required pre trade real time risk management checks of order flow. Due to perceived danger to the markets in permitting institutional investors to utilize naked access and sponsored access regulatory bodies in particular U.S. based regulators moved to end the practice of bypassing a broker s order management infrastructure and have implemented regulations which require brokers in all but a few circumstances to conduct pre trade real time risk management checks of a client s order flow.

By way of example Rule 15c3 5 under the Securities Exchange Act of 1934 requires a myriad of risk checks regulatory checks and other order management analyses on the order message prior to permitting the order message to be routed to an exchange system. More specifically as quoted from SEC Release No. 34 63241 

Rule 15c3 5 will require brokers or dealers with access to trading securities directly on an exchange or alternative trading system ATS including those providing sponsored or direct market access to customers or other persons and broker dealer operators of an ATS that provide access to trading securities directly on their ATS to a person other than a broker or dealer to establish document and maintain a system of risk management controls and supervisory procedures that among other things are reasonably designed to 1 systematically limit the financial exposure of the broker or dealer that could arise as a result of market access and 2 ensure compliance with all regulatory requirements that are applicable in connection with market access.

It will also be recognized that such systems that perform primary market regulatory risk management checks may also be utilized by broker dealers or other persons or entities with market access to perform checks on their internal exchange bound orders. Thus systems that perform primary market regulatory risk management checks should not be understood in the context of the present application as being limited only to systems that perform checks on a customer s or other third party s orders.

One technological problem with the implementation of a system that performs such primary market regulatory risk management checks is that such systems may introduce latency into the transmission of orders from the customer s OMS through the risk check system and on to the exchange. Such latency is believed to be on the order of about 180 milliseconds. Although such latency in having the order routed to the exchange is typically measured in just milliseconds it can introduce undesired exposure to market movements.

Thus there is a need in the field for systems and methods that perform desired or required primary market regulatory risk management checks while reducing latency in the delivery of order messages to an exchange. Furthermore because any latency in delivering an order inherently exposes the order and the customer issuing it to market risk there is a further need in the field for systems and methods that further reduce such latency to ultra low levels e.g. to a fraction of a millisecond or the microsecond range .

Embodiments of the present invention satisfy the foregoing and other needs in the art. For example a method for providing risk management according to one embodiment comprises performing risk checks on an electronic order for a security the electronic order being issued from a client computer to an exchange computer via a network wherein a risk check engine is logically interposed between the client computer and the exchange computer on the network. According to the illustrative method at the risk check engine the electronic order is received and parsed into one of more fields and data within the fields is identified at a network layer. The risk check engine performs one or more risk checks on the data using a processing element at the network layer. If the risk checks are passed the risk check engine permits the electronic order to be transmitted to the exchange computer. If one or more of the risk checks are violated the risk check engine rejects the order. Illustrative systems for performing such method are also disclosed.

Additional features and advantages of the present invention are described further below. This Summary section is meant merely to illustrate certain features of the invention and is not meant to limit the scope of the invention in any way. The failure to discuss a specific benefit or feature of the invention or the inclusion of one or more benefits or features in this Summary should not be construed to limit the invention as claimed.

The systems and methods of the various embodiments described herein represent a novel approach and philosophy for optimizing performance of DMA order flow while permitting performance of required risk management checks and overcome shortcomings of prior systems. One objective of such systems and methods is to achieve increased performance e.g. low latency and high order message throughput while permitting the applicable regulatory required real time risk management checks to be performed. This approach is underpinned in the use of advanced technology and technological concepts that broadly have to this point not been utilized in a cohesive solution within the financial industry.

In summary the systems and methods of the various embodiments of the invention recognize that a commercially successful risk management platform should preferably i.e. but not necessarily use hardware acceleration techniques to improve mean performance reduce performance variability increase capacity and throughput while also preferably reducing the physical and power requirement footprint and preferably lowering the cost of implementation. Such hardware acceleration techniques preferably may be combined with a novel native protocol network based risk management technique as further described below. Such native protocol network based risk management technique in a preferred embodiment overcomes the constraints available using traditional computing concepts associated with moving data from one server to another or moving data between physical components within a single server or between different applications or processes within a single server. Such traditional computing concepts can introduce capacity and performance constraints which may be partially or wholly overcome by utilizing the native protocol network based risk management technique described herein in the context of the various embodiments.

By way of non limiting example the systems and methods of the various embodiments of the invention described herein reduce the processing duplication that occurs in traditional electronic order management infrastructure and reflect a departure from the traditional paradigm of standardized messaging whether FIX or Custom API. With such systems and methods a trading strategy can implement the native exchange protocol for messaging thereby reducing the number of processing steps including the need for traditional two way standardized messaging to native exchange protocol translation mechanisms. Such systems and methods may also reduce the duplicative nature of both a client and broker managing real time state management validation of tick sizes and lot sizes symbology lookups and mapping and a variety of other processing steps.

In certain of the preferred embodiments primary market regulatory risk management checks may be implemented via an active risk management real time network packet decoding and introspection deep inspection technology solution. In certain of such embodiments secondary market regulatory and counterparty risk management checks may be implemented in a near real time passive risk management network packet decoding and introspection deep inspection technology solution. Thus platform introduced latency for active risk management may be advantageously reduced from the roughly 180 microseconds of traditional FIX based platforms to a fraction thereof.

In certain deployment scenarios the unique business and technical concept of the embodiments of the present invention include but are not limited to techniques that permit data to be examined within the network layer in the network protocol as defined by a particular exchange or financial market . Accordingly such embodiments seek to bring the processing functionality of the application closer to the data that needs to be examined a significant departure from traditional technology solutions in which the relevant data is received from the client removed from the network passed up through a series of physical and software based components and layers delivered to an application programmed to perform the regulatory checks e.g. at the application network layer and then passed down through the series of physical and software based components and layers on the outbound side before being returned to the network layer for transmission to the exchange. Such techniques in contrast to certain embodiments described herein introduce unwanted latency into the order message checking process and thus to the transmission of the order to the exchange and execution of the order.

According to certain embodiments a risk management system comprises a printed circuit board PCB communicatively connected on an input side to a client system configured to generate an order message and on an output side to an exchange system configured to receive the order message and execute a trade based on the order message wherein the PCB includes programming operative to perform one or more checks on the order message and make a determination whether to reject modify or block the order message from being transmitted to the exchange system or permit the order message to be transmitted to the exchange system.

In accordance with certain embodiments of the invention the PCB may be used as a standalone board powered by a rack designed to house such standalone PCBs or configured as a Peripheral Component Interconnect Express PCI E board hosted within a server. In at least one embodiment a host server is preferably utilized to interact with the PCB even though order messages received within the PCB need not be communicated to the host server in order for the checking function to be performed. The interface between the PCB and the host server may either comprise a Serial Port for standalone PCBs or a PCI E interface for PCBs hosted within the host server.

In other embodiments the PCB can be hosted directly within the client system via a PCI E interface to avoid transmission of the order message across a first network to the PCB and then on to the exchange system. In such embodiments the client system may be designed and configured to transmit order message data to the PCB via a PCI E interface. The PCB would check the order message as further describe below and if the order is not rejected place the order message back into the client system s communication path leading to the exchange server.

Referring generally to the PCB the PCB includes commonly known communication elements such as a physical layer PHY e.g. Ethernet connection media access control MAC and TCP IP stack as well as a processing agent. The communication elements function to physically receive the order message data across the network from the client system and de pack the order message into payload data that can be processed by the PCB.

The PCB s processing agent comprises a transaction message handler. The transaction message handler is designed and configured to receive payload data from the TCP IP stack and perform checking and other functions and communicate the order message back to the PCB s communication elements for eventual routing to the exchange server. The transaction message handler may also be configured to communicate the payload data to the processor of the host server for further processing.

In an alternate embodiment of the invention a risk management system comprises a network switch communicatively connected on an input side to a client system configured to generate an order message and on an output side to an exchange system configured to receive the order message and execute a trade based on the order message wherein the network switch includes programming operative to perform one or more checks on the order message for example to make a determination whether to block the order message from being transmitted to the exchange system or permit the order message to be transmitted to the exchange system.

The risk management system in accordance with various embodiments of the invention reduces latency in the transmission of orders and performance of risk management checks by avoiding the latency associated with passing order message payload data to the application layer e.g. of the OSI Model within a conventional server system. In conventional servers the processing of data received via a network requires the data to be passed from the physical layer to the application layer and ultimately processed by programming executed by the server s computer chip e.g. x86 processor. This process inherently adds latency to the overall transmission and processing speed of the server due to the movement of data from physical components on an input side through various software based layers to the application layer and then back through those layers to physical components on an output side. The embodiments of the risk management system advantageously avoid the afore mentioned process by processing the order message payload data to a desired extent at the network layer. This advantageously reduces the latency in the transmission and performance of the risk checking function to better enable order messages to be checked in accordance with a broker dealer s order requirements a client s order requirements and or applicable law rule or regulation.

Certain embodiments of the present invention will now be described in greater detail with reference to the figures. Turning first to one illustrative relationship between the computer systems of a host such as a broker dealer clients e.g. those interested in trading securities and an exchange e.g. Tokyo Stock Exchange New York Stock Exchange alternative trading system or other electronic market for the trading of securities is shown. More specifically an exchange network which may include various computer hardware for receiving matching and processing orders for securities is communicatively connected to have an outside facing network communicatively coupled to one or more switches S S which may be connected to one or more client servers C C via any known communication networks and or protocols. The client servers C C may each have a trading application such as an order management system or algorithmic trading application and in turn may also be coupled to one or more switches S S coupled to an outward facing network of a host network. The host network may include for example one or more servers and databases for providing back office middle office and other support systems order and position tracking market data and any other desired components data or services.

As will be described in greater detail below the host may also include one or more servers H H each of which may include one or more field programmable gate arrays FPGAs or one or more racks having one or more network processing units NPUs for performing active and or passive risk checks. More specifically each FPGA or NPU which each include PCB s may be coupled to a single client server and each host server or rack H H may have multiple FPGAs or NPU s for either a single client or multiple clients. As will be appreciated by those of skill in the art based on the discussion herein where multiple FPGAs or NPUs are used for a single client each such FPGA or NPU may include interconnections and programming for sharing trade position risk and other client related information as seen by such FPGA or NPU as the case may be between FPGAs and NPUs used for that same client on the same server and on different host servers H H . It should further be understood by those skilled in the art that the network connections and arrangement shown in are merely exemplary and changes may be made while keeping with the spirit of the present invention.

In a relatively simple embodiment as shown in a host server sits between a client server and an exchange server with a switch interposed between the host server exchange server . As shown the host server is connected to middle office and support systems which in turn includes electronic storage for backup instances of client trade and position related data. These systems provide symbology data average daily volume risk volumes connection information for example which port or ports to use for communicating with the client server and which for communicating with the switch risk thresholds cut off and shut down instructions in the event of violation of a risk check and related data for performing the risk checks. In return the systems received from the host server drop copies of the client order copies of alerts or rejection of an order and execution information from the exchange server. In return these systems receive from the host server drop copies of the client s orders and execution information from the exchange server . The host server also receives real time market data feeds .

In the present embodiment the host server performs both active risk checks and passive risk checks and is responsible for persisting stage information and uploading pricing information to an FPGA . More specifically the host server includes a printed circuit board having the FPGA at the network layer in direct communication with the client server and switch . The printed circuit board may be a standalone board for a PCI E board such as an IPBlaze board hosted within the host server . The FPGA may interface with the host server using either a PCI E port or may in a standalone version use a serial port and a JTAG connection to reconfigure the FPGA . The FPGA may provide transparent access to the exchange for the client and perform parallel processing of the order message fields to automatically as appropriate either reject or pass through client orders to the exchange server .

More specifically the FPGA includes a physical. MAC and TCP IP stack that receives client orders and converts TCP IP segments into payload data. Another physical MAC and TCP IP stack passes as appropriate client orders on to the exchange server after recreating the TCP IP header.

The FPGA is also programmed with a transaction message handler which includes an active risk check module and a data cache . In general utilizing the FPGA helps to reduce latency because the FPGA includes the TCP IP stacks and all the active risk check logic as described below preferably only the passive risk checks are performed off the FPGA by virtue of the FPGA passing a drop copy of the message data to the host server . In the present embodiment the transaction message handler includes components that further reduce latency for performing risk checks and passing on client orders. For example the transaction message handler preferably parses the order payload data into the appropriate fields e.g. symbol quantity price size in parallel thereby further reducing latency. The transaction message handler uses the parsed data to perform active risk checks again preferably in parallel. Thus the length of time to perform all of the risk checks is roughly equal to the duration it takes to perform the slowest risk check as opposed to typical processing which performs risk checks serially in which case the time to perform all of the risk checks is equal to the aggregate duration to perform all checks. The transaction message handler is further programmed to reduce latency by performing security symbol lookups e.g. binary on buckets of numerous bytes for example 128 bytes at a time.

The FPGA also includes one or more data cache for storing client order and market data e.g. symbol price average daily volume etc as necessary to perform the active risk checks desired.

The host server also includes various software modules residing in memory such as RAM for causing the host server processor to perform various processes. The host server includes a passive risk check module for performing various checks and as appropriate generating notifications and order modification or cancellation alerts or instructions a state information persistence module for persisting state information from the FPGA and a market price update module for loading market price data into the FPGA specifically data cache . The FPGA provides a drop copy of each client order data and each alert or rejection of an order to the host server for additional processing and data management including using these modules.

The operation of the foregoing embodiment will now be described with reference to the flow diagram of and continuing reference to . As an initial step certain information is loaded into the host server from the middle office and support systems including preferably risk check thresholds a stoplist of securities inventory downloads and updates client start of day position information relevant communication port information and any other client security position or market data desired for use in performing the risk checks. The host waits for an order from the client updating data business. Step . Virtually the client will generate and transmit in order which is intercepted by the host server and more specifically the FPGA . Step .

The FPGA receives the order step stripping the TCP IP header information in the stack and as part of the transaction message handler parses the order fields in parallel. Step . In the present embodiment the relevant fields include symbol quantity price and order type i.e. new order or modification although it should be understood that fewer or additional fields may be used in different embodiments. Once the fields are parsed the FPGA provides a drop copy to the host server that is available to the passive risk check module . Step .

After parsing payload data of the client order into the relevant fields the transaction message handler proceeds to perform the active risk checks preferably in parallel. Step . In the present embodiment the active risk checks may include 1 ensuring the security identified in the order is not a prohibited security by comparing the security in the order to a stoplist of i.e. a list of prohibited securities stored in data cache 2 ensuring that the order quantity is less than a maximum risk threshold quantity for the security identified in the order by looking up the risk threshold quantity for the security and comparing it to the order quantity and 3 ensuring that the order value price multiplied by order quantity is less than a set maximum risk threshold order value by looking up the threshold order value for the security in the order and comparing it to the calculated order value. In performing these active risk checks the present embodiment utilizes a Symbol Price Limit lookup table which correlates each symbol security with a current price as provided by and updated intraday preferably in real time by the market price update module and a threshold quantity. Active risk checks may include any check necessitated by Rule 15c3 5 or any other existing or hereafter enacted law rule or regulation. It should further be understood that type and quantity of the active risk checks may vary in different embodiments with a potential trade off between the number and type of checks versus the order transmission latency however in certain embodiments the active risk checks may be viewed as real time risk management directed to ensuring compliance with primary regulatory items mitigating market risk concerns and in the present embodiment introducing latency of less than 15 s whereas the passive risk checks are near real time risk management directed to compliance with secondary regulatory items and the monitoring and altering of secondary market and counterparty risk.

If no risk checks are violated step then the TCP IP stack re creates the message header which is appended to the order data having been stored in a buffer and the order is forwarded to the switch and only the exchange server . Step . The exchange server receives the order step acting on it e.g. entering it into its order matching engine and either fully or partially executing the order . Any execution information is returned back to the host server from the exchange server and provided to the middle office and support systems . Transmission of the order may also result in the client and trade data being updated step including for example a copy of the order information being saved both to be FPGA data cache and as a drop copy to the host server and middle office and systems.

In the event one or more of the risk checks are violated the transaction message handler initiates an appropriate preventative or rejection action. Step . It should be understood that reference to preventative is not intended to mean the order is strictly prevented from being transmitted or executed. In the present embodiment if any of these three active risk checks are violated then the order is rejected which is accomplished in the present embodiment by modifying the client order to include a quantity of zero and permitting the order to be transmitted to and received by the exchange server . Step . For example a decision component of the transaction message handler may indicate whether to permit the order to be transmitted to the exchange or to replace the quantity field data with a value equal to zero reassemble the order add header information and transmit it to the exchange servicer . As will be appreciated by those skilled in the art by modifying the order to have a quantity of zero the order may be processed in accordance with the general order processing. In keeping with the desire to minimize latency in the present embodiment the transaction message handler outputs an accepted or rejected signal at the earliest possible point for example immediately upon identifying a rejected risk check rather than waiting for the longest risk check or additional risk checks to be accomplished. In other embodiments different preventative action may be taken for example based on which risk check is violated e.g. reducing the order quantity to a value greater than zero .

As with the case where no risk check has been violated once it is determined that a violation has occurred and preventative action has been taken the system updates the data as necessary step such as providing a drop copy of the instruction e.g. modified order to the host server and middle office and support systems and updating the data cache . In connection with taking preventative action step the host server may also provide a notification of the risk check violation to the client server step .

As noted above step a drop copy of the order data is provided to the host server for performing the passive risk checks. The passive risk checks in the present embodiment may include 1 ensuring the client s borrow limits are not exceeded 2 ensuring short sell orders are transmitted only if permitted 3 client position limits are not exceeded e.g. for a particular security and or overall market exposure 4 ensuring proper order type for sell order the client position becomes or already is a short position after the order the order type must be a short sell not a sell to perform this the real time position of the client is calculated and maintained beginning with the start of day position 5 ensuring that for a short sell order the limit price should follow the up tick rule 6 checking the availability of the host broker dealer to cover the clients short position in the security and 7 any other check deemed desirable or required. To enable performance of the passive risk checks the host server includes a table for each client security symbol combination containing the following information number of shares of the security held by the client which can be negative if stock is borrowed average price of the shares held currently by the client pending position which is based on storing the order quantity and price of pending orders for the security the client s borrowing limit for the security a flag indicating whether or not short sell orders are allowed for this client in the particular security and inventory available against which a short sell order request is checked to determine whether a trade should be allowed . It should be understood that the information stored on a security by security basis may be aggregated to enable checks based on the client s entire portfolio of securities and exposure e.g. a passive risk check based on total value of borrowed shares . The passive risk checks are performed and the host server determines whether any passive risk check is violated. Step . Unlike the active risk checks in the present embodiment the passive risk checks are performed by the host server processor and as such may be performed serially. Consequently to reduce latency for acting on the passive risk checks host server will initiate preventative action as soon as any of the passive risk checks is violated. Step .

The preventative action taken based on violation of a passive risk check may be on an order by order basis or a client basis. Specifically the passive risk check module after determining a violation of a passive risk check may initiate 1 a cancellation of the specific offending order to the exchange server such an instruction being referred to as a chasing cancel because the cancel is initiated after and is following the order provided to the exchange 2 a mass cancellation i.e. cancellation of all of the clients pending orders on the exchange that received the order or all exchanges to which the client transmits orders via the host 3 cutting off or terminating client s connection to or session with the exchange server e.g. by sending a message directly from the host server NIC to the switch or in alternate embodiments to a switch interposed between the client server and the host server and any other desired or required action. Because an order may have already been rejected based on the active risk checks by the time the passive risk checks are run before initiating an order cancel instruction the host server e.g. based on evaluation of the state information persistence module preferably will first determine whether the order has already been rejected so as to avoid duplicate rejections. As with the active risk checks once the preventative action is taken for violation of a passive risk check relevant data in fields may be updated. Step .

Once each of the active risk checks and passive risk check are performed the host continues by waiting for the next order and updating data as necessary. Step .

In connection with accepting or rejecting the inbound messages received from the client server in certain embodiments the FPGA includes components and logic for checking and sequencing such inbound messages and exchange generated messages. As should be understood by those skilled in the art the logic for handling such message sequencing may depend on the particular message protocol and specifications of the particular exchange. For example in the present embodiment when dealing with NASDAQ and the OUCH protocol sequence number handling is relatively simple because the inbound messages are not sequenced and the sequence number of the outbound sequenced message is implicit and a Replace Order with Market Order will be rejected to avoid keeping an order book.

In the present embodiment during normal session flow the FPGA includes an exchange message first in first out FIFO buffer and inject message FIFO buffer and a sequence number handler module that receives messages from each buffer and that tracks the relationship between the implicit outbound sequence number and the injected messages. The ordering of all exchange generated sequenced messages and the rejected messages is kept using a data structure. Such data structure may be an array of integer InjectArray i j where the i 1 injected message is injected after the jexchange message. For example the first client injected message i 1 occurs when there has been no exchange messages j 0 following the first exchange message j 1 the next client injected message is i 2 .

In the event a client connection to the host server is dropped the client preferably will re login with a new expected sequence number and the expected sequence number from the exchange point of view will be communicated. If the implicit exchange sequence number is greater than the value of the then current InjectArray element the element index is incremented by 1 and the FPGA passes the message to the client server . If the exchange sequence number is the same as the value of the InjectArray element the FPGA passes the first message to the client server and then sends an inject message incrementing the element index. If the InjectArray element does not change a new inject message is sent and the element index is incremented. If the InjectArray element changes the system waits for a new exchange message. If the element index passes the array value the reconnection mode ends.

In certain embodiments sequence number handling where ArcaDirect is the exchange may be similar to the handling process for OUCH despite the fact that in ArcaDirect both inbound client to exchange and outbound messages have a sequence number. Unlike with OUCH the sequence number handler also updates the sequence for outbound messages i.e. exchange to client . The reconnect scenario is also similar except that with ArcaDirect the logon message includes the last sequence number instead of the next sequence number as with OUCH.

The inbound message sequence handling accounts for the potential to have a message rejected and an inject message to the exchange. A logical total order of the messages sent and rejected may be kept. A data structure that may be used to encode this information is an array of tuple MsgEventArray i j k where the i 1 event happens after the jclient message. Where k 0 then it represents an injection event and k equals the number of the injected messages at that point in time. Where k

One illustrative message delimiter detector of the transaction message handler will now be described with reference to and Tables I message delimiter parameters and message delimiter signals below. The message delimiter of the present embodiment is responsible for detecting message start and end handling the control signals of an RX FIFO buffer that receives the TCP IP payload message indicating the valid bytes for each word received handling the flow control between the message handler and the TCP offload engine TOE and multiplex any multiple connections channel. In such an embodiment the TCP IP stacks will handle TCP IP packet resend reordering the payload message arrival will always be in order and any partial TCP IP packet will be stored in the RX FIFO.

As illustrated in the present message delimiter detector includes three primary components or modules. First the message delimiter detector preferably includes a data alignment and right controller which consumes data from a TOE FIFO interface and writes the data into a multi channel no boundary RAM. The logic and operation of the data alignment and write controller module is further illustrated in .

Second the message delimiter detector preferably also includes a multichannel no boundary RAM. The multi channel no boundary RAM comprises a separate RAM per byte and forms one logical word. As a result unlike a conventional RAM it can be written in red at any offset and there is no need to account for byte alignment. As will be appreciated by those of skill in the art this greatly simplifies the right controller and state machine logic. In the present environment one channel per connection is used although other arrangements may be used in alternate embodiments.

Third the message delimiter detector preferably also includes a message delimiter state machine as illustrated in . The message delimiter state machine reads data from the no boundary RAM and generates the SOM and EOM signals described herein. illustrates the logic and operation of the state machine module.

As noted above the present environment further reduces latency by virtue of the FPGA extracting the fields of the client order in parallel. One illustrative field extractor of the transaction message handler for performing this function will now be described with reference to . The component is preferably a generic block which is parameterized like a C template class.

The field extractor receives messages no storage and extracts a given field from the message. More specifically the field extractor receives the message without blocking message data extracts the expected field using starting and ending byte offset and presents the field to the other logic components on the FPGA e.g. comparators that implement the active risk checks at the soonest available time for further computation. The present embodiment may be used in fixed offset protocols. As such the field extractor may be used for extracting the following fields for protocols such as OUCH and Arrowhead message type price quantity symbol and order type.

The logic of the field extractor of the present embodiment is shown in the flow diagram of and the parameters used by the field extractor of the present embodiment are set forth in Table 3 below and the signals used by the field extractor of the present embodiment are set forth in Table 4 below. It should be understood that the present embodiment preferably includes multiple field extractor components reading the same message data from a bus. If there is more than one field e.g. in a single 64 bit word then each field extractor may be extracting a different field in parallel i.e. in the same clock cycle thereby further reducing latency.

In certain embodiments the transaction message handler includes an ASCII to integer converter which will be understood by those of skill in the art be very useful for protocols which are character based such as FIX and is useful in further reducing latency. illustrates one parameterized ASCII to integer conversion module of the transaction message handler which will now be described. The ASCII to integer converter receives the length of the character field and gives the integer value in O 0 number of clocks. In other words regardless of the number of characters in the ASCII string e.g. two digits in 10 versus five digits in 10000 the time number of clock cycles required to convert the ASCII to integer is constant. The module is used in converting the price field and converting the quantity field in character based protocols such as FIX.

The present ASCII to integer converter utilizes the parameters and signals in Tables 6 and 7 respectively below.

One illustrative logical flow for handling the creation and delivery of drop copies will now be described and is shown in . On driver initialization the driver will write n e.g. 1 256 in the present embodiment fixed sized pre allocated buffer address into a device register e.g. DropCopyBufferAddressWriteReg on the FPGA . These writes will populate a FIFO in the FPGA which it will use as a circular buffer to dump the drop copy data. In the present embodiment two are used for a client one for the client and one for the host server although in an alternate embodiment the two paths are multiplexed. The FPGA may re use these buffers in the order they were presented in a circular manner. The process to avoid the overwriting of the buffer before the host is able to read it is discussed below.

Once all values are populated in the register the FPGA will be in a ready state. Once drop copy data is available the FPGA will write a register in host memory with the current write pointer. This register is preferably continuously polled by memory of the host server . The FPGA also pushes the data to the host memory address given by the host at initialization init time by direct memory access. Once the host server determines the write address was incremented it reads the data record B processes it and writes a read pointer back to the FPGA indicating the record was read.

The format is shared by the drop copy data and log entry operations. The log entry operation has codes associated with each entry. Such codes indicate whether the client to exchange and exchange to client connections are open and ready provide indication of buffer events e.g. reject generate threshold exceeded entry overflow underflow for the drop copy buffer and or log buffer and any exchange specific errors in accordance with such exchange s protocol.

As noted above various alternate embodiments in which the active risk checks are not performed by the host server are within the scope of the present invention. One such embodiment will now be described with reference to . As will be apparent to those skilled in the art based on the present specification this embodiment is based on the foregoing embodiments but places the FPGA and the associated active risk check logic on a PCB on the client server as opposed to a host server apart from client s server. As illustrated a trading application such as an order management system or algorithmic trading application resides on the client server. A sockets library intercepts the order flow from the trading application and redirects it so that rather than being delivered to the NIC for delivery to the switch and exchange server the order is delivered to specific device drivers and via a PCI e connection to the FPGA and resident transaction message handler having at his risk check components and logic. In an alternate environment the trading application communicates with a host API application programming interface which redirects the order flow to the drivers for provision to the FPGA.

As will be apparent to those skilled in the art because the active risk check module is provided on the FPGA at the client server the host server preferably must provide the data necessary for performing the active risk checks to the client server and FPGA installed therein.

In operation the FPGA performs the active risk checks and if no violation assembles the TCP message for delivery to the exchange server e.g. by way of a switch . The host server receives a drop copy of the order from the client server and performs the passive risk checks via a resident passive risk check module.

Because the present embodiment like the embodiment of includes performing the active risk checks on a network device and thus at the network layer latency may be reduced because the order does not need to be communicated to the various other layers within the OSI model. Further the various specific features for reducing latency such as parsing the order fields in parallel and performing the active risk checks in parallel are maintained in the present embodiment. It should also be noted that as with the environment of the FPGA may be replaced with a network processing unit NPU and the client server may include multiple FPGAs and NPUs.

Within the user space of the client server is an active risk check module which includes a module for parsing the order message and performing the active risk checks. As with prior embodiments the message parser or extractor module parses the order message into its various fields in parallel. Similarly as with prior embodiments the active risk checks are calculations based on symbol quantity price and size value and may be performed in parallel. Specifically each risk check or calculation is performed by a separate data element in parallel.

In performing the active risk checks the active risk check engine accesses memory which is shared with a position cache daemon. The position cache daemon receives a data feed from the exchange server containing responses to the clients orders on the exchange and thus the client s positions. The position cache daemon is for gathering client position information from multiple systems if any on which the client trades e.g. FPGA based or any other trading systems and providing an unified view of the current aggregated positions of a client.

The active risk check engine determines whether or not any of the active risk checks are violated and either initiates creation of the order for transmission to the switch and exchange server or rejects the order e.g. modifying the order to be for a quantity of zero . By virtue of a socket bypass library messages may be provided directly to the NIC.

In one embodiment the system comprises an inspection node that utilizes a network processing unit NPU that operates within the network layer of the network protocol defined by the specific exchange to which the order may be routed in order to reduce latency in the communication of the order message from the trading strategy engine and the exchange server. Within the inspection node the NPU operative within the network layer preferably uses a deep packet inspection DPI methodology in order to examine the data portion of a data packet as its passes through the inspection node.

For example in the embodiment currently being described a system for analyzing orders for the purchase or sale of a security comprises an inspection node interposed between a client system incorporating a trading strategy or order routing engine and an exchange system wherein each of the inspection node client system and exchange system are communicatively connected via a network. The inspection node includes an NPU programmatically designed and configured to analyze the order message in accordance with certain pre defined characteristics and make a determination whether to pass the order message through to the exchange system or take some other action e.g. flag or block the order message . By way of non limiting example the inspection node preferably includes programming that functions to evaluate a client s trade orders for compliance with one or more regulatory rules such as Rule 15c3 5.

As such the programming operative on the NPU of the inspection node actively monitors client trade orders and determines if a violation has occurred. If a violation has occurred the programming may be designed and configured to prevent the client trade order from being communicated to an exchange system for execution deliver a message to the client and or host broker dealer flag the order for later review or take other action as may be necessary or desirable to attempt to prevent execution based on the rejected order.

One such embodiment is shown in . As illustrated the client server is separated from the exchange server by virtue of a switch. In this embodiment the active risks checks and passive risk checks are performed on the switch for example on an NPU. Again as with the prior embodiments latency is reduced by virtue of the active risk management checks being performed at the network layer.

It should be understood that the foregoing are merely illustrative embodiments and then various modifications may be made while staying within the scope of the present invention. For example in certain embodiments the device or inspection node performing any of the risk checks may also include a risk bypass detector. In this regard in the embodiment of the host server may further include a risk bypass detector module in addition to or as part of the passive risk check module . In such an embodiment the risk bypass detector compares trading activity that has been evaluated by the risk modules a summary of which is generated locally against a summary of activity that has actually occurred at the exchange received from the exchange . If the risk bypass detector detects trading activity that has not been routed through the risk check components or modules then the risk bypass detector produces a notification to disable the trading session and or generates an alert calling for the employees of the host broker dealer to contact the exchange.

While there have been shown and described various features of illustrative embodiments it will be understood that omissions and substitutions and changes in the form and details of the disclosed embodiments of the invention may be made by those skilled in the art without departing from the spirit of the invention. In this regard it should be understood that the embodiments are merely illustrative and that the various features and implementations may be combined interchanged and or modified.

