---

title: Systems and methods for identifying long matches of data in a compression history
abstract: Systems and methods of storing previously transmitted data and using it to reduce bandwidth usage and accelerate future communications are described. By using algorithms to identify long compression history matches, a network device may improve compression efficiently and speed. A network device may also use application specific parsing to improve the length and number of compression history matches. Further, by sharing compression histories, compression history indexes and caches across multiple devices, devices can utilize data previously transmitted to other devices to compress network traffic. Any combination of the systems and methods may be used to efficiently find long matches to stored data, synchronize the storage of previously sent data, and share previously sent data among one or more other devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08832300&OS=08832300&RS=08832300
owner: Citrix Systems, Inc.
number: 08832300
owner_city: Fort Lauderdale
owner_country: US
publication_date: 20120806
---
This application claims priority to and is a continuation of U.S. application Ser. No. 13 286 869 issued as U.S. Pat. No. 8 244 852 entitled Systems and Methods For Identifying Long Matches Of Data In A Compression History and filed on Nov. 1 2011 which claims priority to and is a continuation of U.S. application Ser. No. 12 788 023 issued as U.S. Pat. No. 8 051 127 entitled Systems and Methods For Identifying Long Matches Of Data In A Compression History and filed on May 26 2010 which claims the benefit of and priority to U.S. application Ser. No. 11 685 159 issued as U.S. Pat. No. 7 827 237 entitled Systems and Methods For Identifying Long Matches Of Data In A Compression History and filed on Mar. 12 2007 all of which are incorporated herein by reference in their entirety for all purposes.

The present invention generally relates to data communication networks. In particular the present invention relates to systems and methods for compressing data streams and improving network performance by leveraging previously stored data.

Compressing data streams by utilizing previously stored data is a known technique for reducing the size of data streams transmitted between two devices. In broad terms a typical compression method entails two devices each storing copies of data that is sent between the devices. These stored copies of the data can be referred to as compression histories as they represent a history of previously transmitted data that is then used to compress future data streams. When one of the devices is transmitting data to the other device it searches its compression history for matches to the input data and replaces the matched portions with references to the stored data in the transmission stream reducing the size of the transmitted stream. The receiving device then uses the references in combination with its own compression history to reconstruct the uncompressed data stream. However this general technique presents a number of challenges.

First insufficiently long matches between input streams and compression histories can result in poor compression ratios as well as increasing the processing overhead and number of times that a compression history must be accessed. These problems can be exacerbated in cases where a device is transmitting multiple data streams simultaneously and thus may have several processes attempting to access a compression history simultaneously. These problems also may be accentuated in devices using a compression history stored on a medium such as a disk with long potential access latencies. To give a concrete example a device sending a 2K file may find forty matching references scattered across its compression history each reference matching a different 50 bytes of the file. This may require 40 separate iterations of a potentially complex matching algorithm and 40 separate disk accesses to a compression history. By contrast if a device finds a single matching reference for the entire 2K file only a single disk access may be needed. Thus there is a need for systems and methods for efficiently creating locating long matches between an input stream and a compression history.

Second when one device has sequences in its compression history that are not in a corresponding compression history on another device inefficiencies may result. The device may replace portions of data streams with references to the sequences and then be forced to retransmit the data stream as it discovers the other device does not have the referenced sequences. Further the unshared sequences may occupy space in a compression history that could be used for other data. A number of methods may be used to synchronize compression histories with respect to data currently being transmitted between two devices. For example each device may transmit information corresponding to the total number of bytes transmitted received and stored as well as location identifiers identifying where the data has been stored. However even if the compression histories are synchronized immediately following transmission of data a number of events may cause the compression histories to subsequently diverge. For example one device may run out of storage and be forced to overwrite one or more previously stored portions. Or one device may have a disk error or other hardware or software glitch which corrupts or removes one or more previously stored portions. Thus there exists a need for improved systems and methods for efficiently synchronizing shared compression histories.

Third in many implementations compression histories and caching only provide benefits if the same data is repeatedly sent between the same two devices. This can be especially problematic in situations where two sites each having a cluster of devices may repeatedly communicate similar information but there is no guarantee the information will pass through the same pair of devices. For example two sites may each maintain a cluster of devices to accelerate communications between the sites. Cluster 1 may contain the devices A B and C and cluster 2 may contain the devices X Y and Z. For example devices A and Z may each maintain a compression history of a file sent between A and Z but the next time the file is requested the request and response may pass through devices A and Y. Similarly the next time the file is requested the request and response may pass through device B and device X. One potential solution is to organize the device clusters in a hierarchy so that all requests to a given cluster network or region pass through a gateway device. However this solution may involve additional configuration and create network bottlenecks. Thus there exists a need for leveraging data previously transmitted between two devices to compress data streams transmitted between devices other than the original transmitters without necessarily requiring explicit hierarchies.

The present invention is directed towards systems and methods of storing previously transmitted data and using it to reduce bandwidth usage and accelerate future communications. By using algorithms to identify long compression history matches a network device may improve compression efficiently and speed. A network device may also use application specific parsing to improve the length and number of compression history matches. Further by sharing compression histories compression history indexes and caches across multiple devices devices can utilize data previously transmitted to other devices to compress network traffic. Any combination of the systems and methods described in the following paragraphs may be used to efficiently find long matches to stored data synchronize the storage of previously sent data and share previously sent data among one or more other devices.

In a first aspect the present invention relates to systems and methods for determining whether to perform disk based compression by identifying in an index maintained in memory an estimated extent of a match of input data to contiguous data stored on disk is above or below a predetermined threshold. In one embodiment a device having a compression history establishes an index in memory that corresponds fingerprints of a plurality of portions of data of the compression history to location identifiers identifying locations on disk having the plurality of portions of data. The device identifies a number of fingerprints of input data match fingerprints of a plurality of entries of the index in memory and determines from the number of identified fingerprints in memory having entries corresponding to a first location identifier that an estimated match of input data to contiguous data on disk is extendable below a predetermined threshold. If the match is extendable below a given threshold the device transmits the data uncompressed. If the match is extendable above the given threshold the device uses the compression history to compress the data.

In a second aspect the present invention relates to systems and methods for determining a precedence for matching fingerprints of input data to an index of fingerprints identifying a plurality of instances of data in a compression history. In one embodiment a device having a compression history establishing an index that corresponds fingerprints of a plurality of portions of data of the compression history to location identifiers identifying locations on disk having the plurality of portions of data. The device identifies that a plurality of fingerprints of input data match a plurality of entries in the index having at least one location identifier and selects an entry of the plurality of entries having a fewest number of location identifiers. The device may then match a first portion of the input data to data in a first location in the compression history identified by the selected entry.

In a third aspect the present invention relates to systems and methods for a method for improving compression history matches by removing application layer protocol headers from compression history data. In one embodiment these systems and method include transmitting between a first device and a second device an application data stream the application data stream comprising at least one application layer protocol header between a first sequence of application data and a second sequence of application data. The first device identifies the first sequence and the second sequence from the application data stream and stores a combined sequence comprising the first sequence and the third sequence to a compression history.

In a fourth aspect the present invention relates to systems and methods for synchronizing compression histories shared between two devices. In one embodiment a first device stores a first compression history the compression history comprising a plurality of portions of data previously transmitted to a second device each portion of data having a location identifier. The first device may then create an ordered list of location identifiers ordered by a time the first device last accessed a portion of data in a location corresponding to each identifier. The first device receives from the second device information identifying a quantity of location identifiers of a corresponding second compression history on the second device and determines the received quantity is less than a quantity of location identifiers of the first compression history by a first amount. The first device may then select for obsolescence from the list of location identifiers the first amount of location identifiers at an end of the ordered list corresponding to least recently accessed portions of data.

In a fifth aspect the present invention relates to systems and methods for sharing compression histories among a plurality of devices to improve compression of data transmitted via a plurality of connections. In one embodiment a first device transmits to a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device. The first device may receive from the third device an indication that a third device is located on the same network as the second device. The first device receives a second data stream intended for the third device. The first device identifies that a portion of the data stream matches within a predetermined threshold a portion of the first compression history and transmits to the third device information identifying the portion of the first compression history. This may allow communications between the first and third device to be compressed according to a compression history originally shared between the first and second devices.

Another embodiment of the fifth aspect includes transmitting between a first device and a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device. The first device receives information identifying a third device and a portion of the first compression history and transmits to the third device the identified portion of the first compression history.

Still another embodiment includes a first device receiving by a first device from a second device a data stream the data stream compressed according to a compression history shared between the first device and a third device. The first device identifies the third device and transmits to the third device a request for a portion of the compression history. The first device receives from the third device the requested portion of the compression history. The first device may then decompress the data stream and transmit the decompressed stream to the client.

A sixth aspect of the present invention relates to systems and methods for sharing compression indexes among one or more clusters of devices to improve compression of data transmitted via a plurality of connections. One embodiment includes receiving by a first device from a second device an index of entries for a compression history shared between the second device and a third device each index entry comprising a location identifier of data stored in the second device. The first device receives a data stream intended for a fourth device and identifies that a portion of the data stream matches an entry of the received index. The first device transmits to the second device a location identifier corresponding to the matched entry. The first device receives from the second device a portion of the compression history corresponding to the location identifier and determines the portion of the compression history matches a portion of the data stream. The first device may then transmit to the fourth device information identifying the portion of the compression history. This allows communications between the third and fourth device to be compressed according to the compression history originally shared between the first and second devices.

A seventh aspect of the present invention relates to systems and methods for providing an ad hoc hierarchy of caches to serve objects. In one embodiment a first appliance receives from a client a first request for an object from a server. The first device identifies that the object is not located in a first cache of the appliance and forward the first request for the object to the serve. The appliance transmits prior to receiving a response to the forwarded request a second request for the object to a second device. The appliance receives from at least one of the server or the second device the object and then transmits the object to the client.

The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.

The features and advantages of the present invention will become more apparent from the detailed description set forth below when taken in conjunction with the drawings in which like reference characters identify corresponding elements throughout. In the drawings like reference numbers generally indicate identical functionally similar and or structurally similar elements.

For purposes of reading the description of the various embodiments of the present invention below the following descriptions of the sections of the specification and their respective contents may be helpful 

Prior to discussing the specifics of embodiments of the systems and methods of an appliance and or client it may be helpful to discuss the network and computing environments in which such embodiments may be deployed. Referring now to an embodiment of a network environment is depicted. In brief overview the network environment has one or more clients also generally referred to as local machine s or client s in communication with one or more servers also generally referred to as server s or remote machine s via one or more networks . In some embodiments a client communicates with a server via one or more network optimization appliances generally referred to as appliance . In one embodiment the network optimization appliance is designed configured or adapted to optimize Wide Area Network WAN network traffic. In some embodiments a first appliance works in conjunction or cooperation with a second appliance to optimize network traffic. For example a first appliance may be located between a branch office and a WAN connection while the second appliance is located between the WAN and a corporate Local Area Network LAN . The appliances and may work together to optimize the WAN related network traffic between a client in the branch office and a server on the corporate LAN.

Although shows a network network and network generally referred to as network s between the clients and the servers the clients and the servers may be on the same network . The networks can be the same type of network or different types of networks. The network can be a local area network LAN such as a company Intranet a metropolitan area network MAN or a wide area network WAN such as the Internet or the World Wide Web. The networks can be a private or public network. In one embodiment network or network may be a private network and network may be a public network. In some embodiments network may be a private network and network and or network a public network. In another embodiment networks may be private networks. In some embodiments clients may be located at a branch office of a corporate enterprise communicating via a WAN connection over the network to the servers located on a corporate LAN in a corporate data center.

The network may be any type and or form of network and may include any of the following a point to point network a broadcast network a wide area network a local area network a telecommunications network a data communication network a computer network an ATM Asynchronous Transfer Mode network a SONET Synchronous Optical Network network a SDH Synchronous Digital Hierarchy network a wireless network and a wireline network. In some embodiments the network may comprise a wireless link such as an infrared channel or satellite band. The topology of the network may be a bus star or ring network topology. The network and network topology may be of any such network or network topology as known to those ordinarily skilled in the art capable of supporting the operations described herein.

As depicted in a first network optimization appliance is shown between networks and and a second network optimization appliance is also between networks and . In some embodiments the appliance may be located on network . For example a corporate enterprise may deploy an appliance at the branch office. In other embodiments the appliance may be located on network . In some embodiments the appliance may be located on network or network . For example an appliance may be located at a corporate data center. In one embodiment the appliance and are on the same network. In another embodiment the appliance and are on different networks.

In one embodiment the appliance is a device for accelerating optimizing or otherwise improving the performance operation or quality of service of any type and form of network traffic. In some embodiments the appliance is a performance enhancing proxy. In other embodiments the appliance is any type and form of WAN optimization or acceleration device sometimes also referred to as a WAN optimization controller. In one embodiment the appliance is any of the product embodiments referred to as WANScaler manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. In other embodiments the appliance includes any of the product embodiments referred to as BIG IP link controller and WANjet manufactured by F5 Networks Inc. of Seattle Wash. In another embodiment the appliance includes any of the WX and WXC WAN acceleration device platforms manufactured by Juniper Networks Inc. of Sunnyvale Calif. In some embodiments the appliance includes any of the steelhead line of WAN optimization appliances manufactured by Riverbed Technology of San Francisco Calif. In other embodiments the appliance includes any of the WAN related devices manufactured by Expand Networks Inc. of Roseland N.J. In one embodiment the appliance includes any of the WAN related appliances manufactured by Packeteer Inc. of Cupertino Calif. such as the PacketShaper iShared and SkyX product embodiments provided by Packeteer. In yet another embodiment the appliance includes any WAN related appliances and or software manufactured by Cisco Systems Inc. of San Jose Calif. such as the Cisco Wide Area Network Application Services software and network modules and Wide Area Network engine appliances.

In some embodiments the appliance provides application and data acceleration services for branch office or remote offices. In one embodiment the appliance includes optimization of Wide Area File Services WAFS . In another embodiment the appliance accelerates the delivery of files such as via the Common Internet File System CIFS protocol. In other embodiments the appliance provides caching in memory and or storage to accelerate delivery of applications and data. In one embodiment the appliance provides compression of network traffic at any level of the network stack or at any protocol or network layer. In another embodiment the appliance provides transport layer protocol optimizations flow control performance enhancements or modifications and or management to accelerate delivery of applications and data over a WAN connection. For example in one embodiment the appliance provides Transport Control Protocol TCP optimizations. In other embodiments the appliance provides optimizations flow control performance enhancements or modifications and or management for any session or application layer protocol. Further details of the optimization techniques operations and architecture of the appliance are discussed below in Section B.

Still referring to the network environment may include multiple logically grouped servers . In these embodiments the logical group of servers may be referred to as a server farm . In some of these embodiments the servers may be geographically dispersed. In some cases a farm may be administered as a single entity. In other embodiments the server farm comprises a plurality of server farms . In one embodiment the server farm executes one or more applications on behalf of one or more clients .

The servers within each farm can be heterogeneous. One or more of the servers can operate according to one type of operating system platform e.g. WINDOWS NT manufactured by Microsoft Corp. of Redmond Wash. while one or more of the other servers can operate on according to another type of operating system platform e.g. Unix or Linux . The servers of each farm do not need to be physically proximate to another server in the same farm . Thus the group of servers logically grouped as a farm may be interconnected using a wide area network WAN connection or metropolitan area network MAN connection. For example a farm may include servers physically located in different continents or different regions of a continent country state city campus or room. Data transmission speeds between servers in the farm can be increased if the servers are connected using a local area network LAN connection or some form of direct connection.

Servers may be file servers application servers web servers proxy servers and or gateway servers. In some embodiments a server may have the capacity to function as either an application server or as a master application server. In one embodiment a server may include an Active Directory. The clients may also be referred to as client nodes or endpoints. In some embodiments a client has the capacity to function as both a client node seeking access to applications on a server and as an application server providing access to hosted applications for other clients 

In some embodiments a client communicates with a server . In one embodiment the client communicates directly with one of the servers in a farm . In another embodiment the client executes a program neighborhood application to communicate with a server in a farm . In still another embodiment the server provides the functionality of a master node. In some embodiments the client communicates with the server in the farm through a network . Over the network the client can for example request execution of various applications hosted by the servers in the farm and receive output of the results of the application execution for display. In some embodiments only the master node provides the functionality required to identify and provide address information associated with a server hosting a requested application.

In one embodiment a server provides functionality of a web server. In another embodiment the server receives requests from the client forwards the requests to a second server and responds to the request by the client with a response to the request from the server . In still another embodiment the server acquires an enumeration of applications available to the client and address information associated with a server hosting an application identified by the enumeration of applications. In yet another embodiment the server presents the response to the request to the client using a web interface. In one embodiment the client communicates directly with the server to access the identified application. In another embodiment the client receives application output data such as display data generated by an execution of the identified application on the server .

Referring now to another embodiment of a network environment is depicted in which the network optimization appliance is deployed with one or more other appliances generally referred to as appliance or second appliance such as a gateway firewall or acceleration appliance. For example in one embodiment the appliance is a firewall or security appliance while appliance is a LAN acceleration device. In some embodiments a client may communicate to a server via one or more of the first appliances and one or more second appliances .

One or more appliances and may be located at any point in the network or network communications path between a client and a server . In some embodiments a second appliance may be located on the same network as the first appliance . In other embodiments the second appliance may be located on a different network as the first appliance . In yet another embodiment a first appliance and second appliance is on the same network for example network while the first appliance and second appliance is on the same network such as network .

In one embodiment the second appliance includes any type and form of transport control protocol or transport later terminating device such as a gateway or firewall device. In one embodiment the appliance terminates the transport control protocol by establishing a first transport control protocol connection with the client and a second transport control connection with the second appliance or server. In another embodiment the appliance terminates the transport control protocol by changing managing or controlling the behavior of the transport control protocol connection between the client and the server or second appliance. For example the appliance may change queue forward or transmit network packets in manner to effectively terminate the transport control protocol connection or to act or simulate as terminating the connection.

In some embodiments the second appliance is a performance enhancing proxy. In one embodiment the appliance provides a virtual private network VPN connection. In some embodiments the appliance provides a Secure Socket Layer VPN SSL VPN connection. In other embodiments the appliance provides an IPsec Internet Protocol Security based VPN connection. In some embodiments the appliance provides any one or more of the following functionality compression acceleration load balancing switching routing caching and Transport Control Protocol TCP acceleration.

In one embodiment the appliance is any of the product embodiments referred to as Access Gateway Application Firewall Application Gateway or NetScaler manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. As such in some embodiments the appliance includes any logic functions rules or operations to perform services or functionality such as SSL VPN connectivity SSL offloading switching load balancing Domain Name Service resolution LAN acceleration and an application firewall.

In some embodiments the appliance provides a SSL VPN connection between a client and a server . For example a client on a first network requests to establish a connection to a server on a second network . In some embodiments the second network is not routable from the first network . In other embodiments the client is on a public network and the server is on a private network such as a corporate network. In one embodiment a client agent intercepts communications of the client on the first network encrypts the communications and transmits the communications via a first transport layer connection to the appliance . The appliance associates the first transport layer connection on the first network to a second transport layer connection to the server on the second network . The appliance receives the intercepted communication from the client agent decrypts the communications and transmits the communication to the server on the second network via the second transport layer connection. The second transport layer connection may be a pooled transport layer connection. In one embodiment the appliance provides an end to end secure transport layer connection for the client between the two networks 

In one embodiment the appliance hosts an intranet internet protocol or intranetIP address of the client on the virtual private network . The client has a local network identifier such as an internet protocol IP address and or host name on the first network . When connected to the second network via the appliance the appliance establishes assigns or otherwise provides an IntranetIP which is a network identifier such as IP address and or host name for the client on the second network . The appliance listens for and receives on the second or private network for any communications directed towards the client using the client s established IntranetIP. In one embodiment the appliance acts as or on behalf of the client on the second private network .

In some embodiment the appliance has an encryption engine providing logic business rules functions or operations for handling the processing of any security related protocol such as SSL or TLS or any function related thereto. For example the encryption engine encrypts and decrypts network packets or any portion thereof communicated via the appliance . The encryption engine may also setup or establish SSL or TLS connections on behalf of the client server or appliance . As such the encryption engine provides offloading and acceleration of SSL processing. In one embodiment the encryption engine uses a tunneling protocol to provide a virtual private network between a client and a server . In some embodiments the encryption engine uses an encryption processor. In other embodiments the encryption engine includes executable instructions running on an encryption processor.

In some embodiments the appliance provides one or more of the following acceleration techniques to communications between the client and server 1 compression 2 decompression 3 Transmission Control Protocol pooling 4 Transmission Control Protocol multiplexing 5 Transmission Control Protocol buffering and 6 caching. In one embodiment the appliance relieves servers of much of the processing load caused by repeatedly opening and closing transport layers connections to clients by opening one or more transport layer connections with each server and maintaining these connections to allow repeated data accesses by clients via the Internet. This technique is referred to herein as connection pooling .

In some embodiments in order to seamlessly splice communications from a client to a server via a pooled transport layer connection the appliance translates or multiplexes communications by modifying sequence number and acknowledgment numbers at the transport layer protocol level. This is referred to as connection multiplexing . In some embodiments no application layer protocol interaction is required. For example in the case of an in bound packet that is a packet received from a client the source network address of the packet is changed to that of an output port of appliance and the destination network address is changed to that of the intended server. In the case of an outbound packet that is one received from a server the source network address is changed from that of the server to that of an output port of appliance and the destination address is changed from that of appliance to that of the requesting client . The sequence numbers and acknowledgment numbers of the packet are also translated to sequence numbers and acknowledgement expected by the client on the appliance s transport layer connection to the client . In some embodiments the packet checksum of the transport layer protocol is recalculated to account for these translations.

In another embodiment the appliance provides switching or load balancing functionality for communications between the client and server . In some embodiments the appliance distributes traffic and directs client requests to a server based on layer 4 payload or application layer request data. In one embodiment although the network layer or layer 2 of the network packet identifies a destination server the appliance determines the server to distribute the network packet by application information and data carried as payload of the transport layer packet. In one embodiment a health monitoring program of the appliance monitors the health of servers to determine the server for which to distribute a client s request. In some embodiments if the appliance detects a server is not available or has a load over a predetermined threshold the appliance can direct or distribute client requests to another server .

In some embodiments the appliance acts as a Domain Name Service DNS resolver or otherwise provides resolution of a DNS request from clients . In some embodiments the appliance intercepts a DNS request transmitted by the client . In one embodiment the appliance responds to a client s DNS request with an IP address of or hosted by the appliance . In this embodiment the client transmits network communication for the domain name to the appliance . In another embodiment the appliance responds to a client s DNS request with an IP address of or hosted by a second appliance . In some embodiments the appliance responds to a client s DNS request with an IP address of a server determined by the appliance .

In yet another embodiment the appliance provides application firewall functionality for communications between the client and server . In one embodiment a policy engine provides rules for detecting and blocking illegitimate requests. In some embodiments the application firewall protects against denial of service DoS attacks. In other embodiments the appliance inspects the content of intercepted requests to identify and block application based attacks. In some embodiments the rules policy engine includes one or more application firewall or security control policies for providing protections against various classes and types of web or Internet based vulnerabilities such as one or more of the following 1 buffer overflow 2 CGI BIN parameter manipulation 3 form hidden field manipulation 4 forceful browsing 5 cookie or session poisoning 6 broken access control list ACLs or weak passwords 7 cross site scripting XSS 8 command injection 9 SQL injection 10 error triggering sensitive information leak 11 insecure use of cryptography 12 server misconfiguration 13 back doors and debug options 14 website defacement 15 platform or operating systems vulnerabilities and 16 zero day exploits. In an embodiment the application firewall of the appliance provides HTML form field protection in the form of inspecting or analyzing the network communication for one or more of the following 1 required fields are returned 2 no added field allowed 3 read only and hidden field enforcement 4 drop down list and radio button field conformance and 5 form field max length enforcement. In some embodiments the application firewall of the appliance ensures cookies are not modified. In other embodiments the appliance protects against forceful browsing by enforcing legal URLs.

In still yet other embodiments the application firewall appliance protects any confidential information contained in the network communication. The appliance may inspect or analyze any network communication in accordance with the rules or polices of the policy engine to identify any confidential information in any field of the network packet. In some embodiments the application firewall identifies in the network communication one or more occurrences of a credit card number password social security number name patient code contact information and age. The encoded portion of the network communication may include these occurrences or the confidential information. Based on these occurrences in one embodiment the application firewall may take a policy action on the network communication such as prevent transmission of the network communication. In another embodiment the application firewall may rewrite remove or otherwise mask such identified occurrence or confidential information.

Although generally referred to as a network optimization or first appliance and a second appliance the first appliance and second appliance may be the same type and form of appliance. In one embodiment the second appliance may perform the same functionality or portion thereof as the first appliance and vice versa. For example the first appliance and second appliance may both provide acceleration techniques. In one embodiment the first appliance may perform LAN acceleration while the second appliance performs WAN acceleration or vice versa. In another example the first appliance may also be a transport control protocol terminating device as with the second appliance . Furthermore although appliances and are shown as separate devices on the network the appliance and or could be a part of any client or server .

Referring now to other embodiments of a network environment for deploying the appliance are depicted. In another embodiment as depicted on the top of the appliance may be deployed as a single appliance or single proxy on the network . For example the appliance may be designed constructed or adapted to perform WAN optimization techniques discussed herein without a second cooperating appliance . In other embodiments as depicted on the bottom of a single appliance may be deployed with one or more second appliances . For example a WAN acceleration first appliance such as a Citrix WANScaler appliance may be deployed with a LAN accelerating or Application Firewall second appliance such as a Citrix NetScaler appliance.

The client server and appliance and may be deployed as and or executed on any type and form of computing device such as a computer network device or appliance capable of communicating on any type and form of network and performing the operations described herein. depict block diagrams of a computing device useful for practicing an embodiment of the client server or appliance . As shown in each computing device includes a central processing unit and a main memory unit . As shown in a computing device may include a visual display device a keyboard and or a pointing device such as a mouse. Each computing device may also include additional optional elements such as one or more input output devices generally referred to using reference numeral and a cache memory in communication with the central processing unit .

The central processing unit is any logic circuitry that responds to and processes instructions fetched from the main memory unit . In many embodiments the central processing unit is provided by a microprocessor unit such as those manufactured by Intel Corporation of Mountain View Calif. those manufactured by Motorola Corporation of Schaumburg Ill. those manufactured by Transmeta Corporation of Santa Clara Calif. the RS 6000 processor those manufactured by International Business Machines of White Plains N.Y. or those manufactured by Advanced Micro Devices of Sunnyvale Calif. The computing device may be based on any of these processors or any other processor capable of operating as described herein.

Main memory unit may be one or more memory chips capable of storing data and allowing any storage location to be directly accessed by the microprocessor such as Static random access memory SRAM Burst SRAM or SynchBurst SRAM BSRAM Dynamic random access memory DRAM Fast Page Mode DRAM FPM DRAM Enhanced DRAM EDRAM Extended Data Output RAM EDO RAM Extended Data Output DRAM EDO DRAM Burst Extended Data Output DRAM BEDO DRAM Enhanced DRAM EDRAM synchronous DRAM SDRAM JEDEC SRAM PC100 SDRAM Double Data Rate SDRAM DDR SDRAM Enhanced SDRAM ESDRAM SyncLink DRAM SLDRAM Direct Rambus DRAM DRDRAM or Ferroelectric RAM FRAM . The main memory may be based on any of the above described memory chips or any other available memory chips capable of operating as described herein. In the embodiment shown in the processor communicates with main memory via a system bus described in more detail below . depicts an embodiment of a computing device in which the processor communicates directly with main memory via a memory port . For example in the main memory may be DRDRAM.

The computing device may support any suitable installation device such as a floppy disk drive for receiving floppy disks such as 3.5 inch 5.25 inch disks or ZIP disks a CD ROM drive a CD R RW drive a DVD ROM drive tape drives of various formats USB device hard drive or any other device suitable for installing software and programs such as any client agent or portion thereof. The computing device may further comprise a storage device such as one or more hard disk drives or redundant arrays of independent disks for storing an operating system and other related software and for storing application software programs such as any program related to the client agent . Optionally any of the installation devices could also be used as the storage device . Additionally the operating system and the software can be run from a bootable medium for example a bootable CD such as KNOPPIX a bootable CD for GNU Linux that is available as a GNU Linux distribution from knoppix.net.

Furthermore the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56 kb X.25 broadband connections e.g. ISDN Frame Relay ATM wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein. A wide variety of I O devices may be present in the computing device . Input devices include keyboards mice trackpads trackballs microphones and drawing tablets. Output devices include video displays speakers inkjet printers laser printers and dye sublimation printers. The I O devices may be controlled by an I O controller as shown in . The I O controller may control one or more I O devices such as a keyboard and a pointing device e.g. a mouse or optical pen. Furthermore an I O device may also provide storage and or an installation medium for the computing device . In still other embodiments the computing device may provide USB connections to receive handheld USB storage devices such as the USB Flash Drive line of devices manufactured by Twintech Industry Inc. of Los Alamitos Calif.

In some embodiments the computing device may comprise or be connected to multiple display devices which each may be of the same or different type and or form. As such any of the I O devices and or the I O controller may comprise any type and or form of suitable hardware software or combination of hardware and software to support enable or provide for the connection and use of multiple display devices by the computing device . For example the computing device may include any type and or form of video adapter video card driver and or library to interface communicate connect or otherwise use the display devices . In one embodiment a video adapter may comprise multiple connectors to interface to multiple display devices . In other embodiments the computing device may include multiple video adapters with each video adapter connected to one or more of the display devices . In some embodiments any portion of the operating system of the computing device may be configured for using multiple displays . In other embodiments one or more of the display devices may be provided by one or more other computing devices such as computing devices and connected to the computing device for example via a network. These embodiments may include any type of software designed and constructed to use another computer s display device as a second display device for the computing device . One ordinarily skilled in the art will recognize and appreciate the various ways and embodiments that a computing device may be configured to have multiple display devices 

In further embodiments an I O device may be a bridge between the system bus and an external communication bus such as a USB bus an Apple Desktop Bus an RS 232 serial connection a SCSI bus a FireWire bus a FireWire bus an Ethernet bus an AppleTalk bus a Gigabit Ethernet bus an Asynchronous Transfer Mode bus a HIPPI bus a Super HIPPI bus a SerialPlus bus a SCI LAMP bus a FibreChannel bus or a Serial Attached small computer system interface bus.

A computing device of the sort depicted in typically operate under the control of operating systems which control scheduling of tasks and access to system resources. The computing device can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS or OS X for Macintosh computers any embedded operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or any other operating system capable of running on the computing device and performing the operations described herein. Typical operating systems include WINDOWS 3.x WINDOWS 95 WINDOWS 98 WINDOWS 2000 WINDOWS NT 3.51 WINDOWS NT 4.0 WINDOWS CE WINDOWS 2003 WINDOWS XP and WINDOWS VISTA all of which are manufactured by Microsoft Corporation of Redmond Wash. MacOS and OS X manufactured by Apple Computer of Cupertino Calif. OS 2 manufactured by International Business Machines of Armonk N.Y. and Linux a freely available operating system distributed by Caldera Corp. of Salt Lake City Utah or any type and or form of a Unix operating system such as those versions of Unix referred to as Solaris Sparc Solaris x86 AIX IBM HP UX and SGI Silicon Graphics among others.

In other embodiments the computing device may have different processors operating systems and input devices consistent with the device. For example in one embodiment the computer is a Treo 180 270 1060 600 or 650 smart phone manufactured by Palm Inc. In this embodiment the Treo smart phone is operated under the control of the PalmOS operating system and includes a stylus input device as well as a five way navigator device. In another example the computing device may be a WinCE or PocketPC device with an ARM Advanced RISC Machine type of processor. In one example the computing device includes a Series 80 Nokia 9500 or Nokia 9300 type of smart phone manufactured by Nokia of Finland which may run the Symbian OS or EPOC mobile operating system manufactured by Symbian Software Limited of London United Kingdom. In another example the computing device may include a FOMA M100 brand smart phone manufactured by Motorola Inc. of Schaumburg Ill. and operating the EPOC or Symbian OS operating system. In yet another example the computing device includes a Sony Ericsson P800 P900 or P910 Alpha model phone manufactured by Sony Ericsson Mobile Communications USA Inc. of Research Triangle Park N.C. Moreover the computing device can be any workstation desktop computer laptop or notebook computer server handheld computer mobile telephone smart phone any other computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

Referring now to an embodiment of a system environment and architecture of an appliance for delivering and or operating a computing environment on a client is depicted. In some embodiments a server includes an application delivery system for delivering a computing environment or an application and or data file to one or more clients . In brief overview a client is in communication with a server via network and appliance . For example the client may reside in a remote office of a company e.g. a branch office and the server may reside at a corporate data center. The client has a client agent and a computing environment . The computing environment may execute or operate an application that accesses processes or uses a data file. The computing environment application and or data file may be delivered via the appliance and or the server .

In some embodiments the appliance accelerates delivery of a computing environment or any portion thereof to a client . In one embodiment the appliance accelerates the delivery of the computing environment by the application delivery system . For example the embodiments described herein may be used to accelerate delivery of a streaming application and data file processable by the application from a central corporate data center to a remote user location such as a branch office of the company. In another embodiment the appliance accelerates transport layer traffic between a client and a server . In another embodiment the appliance controls manages or adjusts the transport layer protocol to accelerate delivery of the computing environment. In some embodiments the appliance uses caching and or compression techniques to accelerate delivery of a computing environment.

In some embodiments the application delivery management system provides application delivery techniques to deliver a computing environment to a desktop of a user remote or otherwise based on a plurality of execution methods and based on any authentication and authorization policies applied via a policy engine . With these techniques a remote user may obtain a computing environment and access to server stored applications and data files from any network connected device . In one embodiment the application delivery system may reside or execute on a server . In another embodiment the application delivery system may reside or execute on a plurality of servers . In some embodiments the application delivery system may execute in a server farm . In one embodiment the server executing the application delivery system may also store or provide the application and data file. In another embodiment a first set of one or more servers may execute the application delivery system and a different server may store or provide the application and data file. In some embodiments each of the application delivery system the application and data file may reside or be located on different servers. In yet another embodiment any portion of the application delivery system may reside execute or be stored on or distributed to the appliance or a plurality of appliances.

The client may include a computing environment for executing an application that uses or processes a data file. The client via networks and appliance may request an application and data file from the server . In one embodiment the appliance may forward a request from the client to the server . For example the client may not have the application and data file stored or accessible locally. In response to the request the application delivery system and or server may deliver the application and data file to the client . For example in one embodiment the server may transmit the application as an application stream to operate in computing environment on client .

In some embodiments the application delivery system comprises any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application delivery system may deliver one or more applications to clients or users via a remote display protocol or otherwise via remote based or server based computing. In another embodiment the application delivery system may deliver one or more applications to clients or users via steaming of the application.

In one embodiment the application delivery system includes a policy engine for controlling and managing the access to applications selection of application execution methods and the delivery of applications. In some embodiments the policy engine determines the one or more applications a user or client may access. In another embodiment the policy engine determines how the application should be delivered to the user or client e.g. the method of execution. In some embodiments the application delivery system provides a plurality of delivery techniques from which to select a method of application execution such as a server based computing streaming or delivering the application locally to the client for local execution.

In one embodiment a client requests execution of an application program and the application delivery system comprising a server selects a method of executing the application program. In some embodiments the server receives credentials from the client . In another embodiment the server receives a request for an enumeration of available applications from the client . In one embodiment in response to the request or receipt of credentials the application delivery system enumerates a plurality of application programs available to the client . The application delivery system receives a request to execute an enumerated application. The application delivery system selects one of a predetermined number of methods for executing the enumerated application for example responsive to a policy of a policy engine. The application delivery system may select a method of execution of the application enabling the client to receive application output data generated by execution of the application program on a server . The application delivery system may select a method of execution of the application enabling the client or local machine to execute the application program locally after retrieving a plurality of application files comprising the application. In yet another embodiment the application delivery system may select a method of execution of the application to stream the application via the network to the client .

A client may execute operate or otherwise provide an application which can be any type and or form of software program or executable instructions such as any type and or form of web browser web based client client server application a thin client computing client an ActiveX control or a Java applet or any other type and or form of executable instructions capable of executing on client . In some embodiments the application may be a server based or a remote based application executed on behalf of the client on a server . In one embodiment the server may display output to the client using any thin client or remote display protocol such as the Independent Computing Architecture ICA protocol manufactured by Citrix Systems Inc. of Ft. Lauderdale Fla. or the Remote Desktop Protocol RDP manufactured by the Microsoft Corporation of Redmond Wash. The application can use any type of protocol and it can be for example an HTTP client an FTP client an Oscar client or a Telnet client. In other embodiments the application comprises any type of software related to VoIP communications such as a soft IP telephone. In further embodiments the application comprises any application related to real time data communications such as applications for streaming video and or audio.

In some embodiments the server or a server farm may be running one or more applications such as an application providing a thin client computing or remote display presentation application. In one embodiment the server or server farm executes as an application any portion of the Citrix Access Suite by Citrix Systems Inc. such as the MetaFrame or Citrix Presentation Server and or any of the Microsoft Windows Terminal Services manufactured by the Microsoft Corporation. In one embodiment the application is an ICA client developed by Citrix Systems Inc. of Fort Lauderdale Fla. In other embodiments the application includes a Remote Desktop RDP client developed by Microsoft Corporation of Redmond Wash. Also the server may run an application which for example may be an application server providing email services such as Microsoft Exchange manufactured by the Microsoft Corporation of Redmond Wash. a web or Internet server or a desktop sharing server or a collaboration server. In some embodiments any of the applications may comprise any type of hosted service or products such as GoToMeeting provided by Citrix Online Division Inc. of Santa Barbara Calif. WebEx provided by WebEx Inc. of Santa Clara Calif. or Microsoft Office Live Meeting provided by Microsoft Corporation of Redmond Wash.

The appliance includes or is under the control of an operating system. The operating system of the appliance may be any type and or form of Unix operating system although the invention is not so limited. As such the appliance can be running any operating system such as any of the versions of the Microsoft Windows operating systems the different releases of the Unix and Linux operating systems any version of the Mac OS for Macintosh computers any embedded operating system any network operating system any real time operating system any open source operating system any proprietary operating system any operating systems for mobile computing devices or network devices or any other operating system capable of running on the appliance and performing the operations described herein.

The operating system of appliance allocates manages or otherwise segregates the available system memory into what is referred to as kernel or system space and user or application space. The kernel space is typically reserved for running the kernel including any device drivers kernel extensions or other kernel related software. As known to those skilled in the art the kernel is the core of the operating system and provides access control and management of resources and hardware related elements of the appliance . In accordance with an embodiment of the appliance the kernel space also includes a number of network services or processes working in conjunction with the network optimization engine or any portion thereof. Additionally the embodiment of the kernel will depend on the embodiment of the operating system installed configured or otherwise used by the device . In contrast to kernel space user space is the memory area or portion of the operating system used by user mode applications or programs otherwise running in user mode. A user mode application may not access kernel space directly and uses service calls in order to access kernel services. The operating system uses the user or application space for executing or running applications and provisioning of user level programs services processes and or tasks.

The appliance has one or more network ports for transmitting and receiving data over a network . The network port provides a physical and or logical interface between the computing device and a network or another device for transmitting and receiving network communications. The type and form of network port depends on the type and form of network and type of medium for connecting to the network. Furthermore any software of provisioned for or used by the network port and network stack may run in either kernel space or user space.

In one embodiment the appliance has one network stack such as a TCP IP based stack for communicating on a network such with the client and or the server . In one embodiment the network stack is used to communicate with a first network such as network and also with a second network . In another embodiment the appliance has two or more network stacks such as first network stack A and a second network stack N. The first network stack A may be used in conjunction with a first port A to communicate on a first network . The second network stack N may be used in conjunction with a second port N to communicate on a second network . In one embodiment the network stack s has one or more buffers for queuing one or more network packets for transmission by the appliance .

The network stack includes any type and form of software or hardware or any combinations thereof for providing connectivity to and communications with a network. In one embodiment the network stack includes a software implementation for a network protocol suite. The network stack may have one or more network layers such as any networks layers of the Open Systems Interconnection OSI communications model as those skilled in the art recognize and appreciate. As such the network stack may have any type and form of protocols for any of the following layers of the OSI model 1 physical link layer 2 data link layer 3 network layer 4 transport layer 5 session layer 6 presentation layer and 7 application layer. In one embodiment the network stack includes a transport control protocol TCP over the network layer protocol of the internet protocol IP generally referred to as TCP IP. In some embodiments the TCP IP protocol may be carried over the Ethernet protocol which may comprise any of the family of IEEE wide area network WAN or local area network LAN protocols such as those protocols covered by the IEEE 802.3. In some embodiments the network stack has any type and form of a wireless protocol such as IEEE 802.11 and or mobile internet protocol.

In view of a TCP IP based network any TCP IP based protocol may be used including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In another embodiment the network stack comprises any type and form of transport control protocol such as a modified transport control protocol for example a Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol. In other embodiments any type and form of user datagram protocol UDP such as UDP over IP may be used by the network stack such as for voice communications or real time data communications.

Furthermore the network stack may include one or more network drivers supporting the one or more layers such as a TCP driver or a network layer driver. The network drivers may be included as part of the operating system of the computing device or as part of any network interface cards or other network access components of the computing device . In some embodiments any of the network drivers of the network stack may be customized modified or adapted to provide a custom or modified portion of the network stack in support of any of the techniques described herein.

In one embodiment the appliance provides for or maintains a transport layer connection between a client and server using a single network stack . In some embodiments the appliance effectively terminates the transport layer connection by changing managing or controlling the behavior of the transport control protocol connection between the client and the server. In these embodiments the appliance may use a single network stack . In other embodiments the appliance terminates a first transport layer connection such as a TCP connection of a client and establishes a second transport layer connection to a server for use by or on behalf of the client e.g. the second transport layer connection is terminated at the appliance and the server . The first and second transport layer connections may be established via a single network stack . In other embodiments the appliance may use multiple network stacks for example A and N. In these embodiments the first transport layer connection may be established or terminated at one network stack A and the second transport layer connection may be established or terminated on the second network stack N. For example one network stack may be for receiving and transmitting network packets on a first network and another network stack for receiving and transmitting network packets on a second network.

As shown in the network optimization engine includes one or more of the following elements components or modules network packet processing engine LAN WAN detector flow controller QoS engine protocol accelerator compression engine cache manager and policy engine . The network optimization engine or any portion thereof may include software hardware or any combination of software and hardware. Furthermore any software of provisioned for or used by the network optimization engine may run in either kernel space or user space. For example in one embodiment the network optimization engine may run in kernel space. In another embodiment the network optimization engine may run in user space. In yet another embodiment a first portion of the network optimization engine runs in kernel space while a second portion of the network optimization engine runs in user space.

The network packet engine also generally referred to as a packet processing engine or packet engine is responsible for controlling and managing the processing of packets received and transmitted by appliance via network ports and network stack s . The network packet engine may operate at any layer of the network stack . In one embodiment the network packet engine operates at layer 2 or layer 3 of the network stack . In some embodiments the packet engine intercepts or otherwise receives packets at the network layer such as the IP layer in a TCP IP embodiment. In another embodiment the packet engine operates at layer 4 of the network stack . For example in some embodiments the packet engine intercepts or otherwise receives packets at the transport layer such as intercepting packets as the TCP layer in a TCP IP embodiment. In other embodiments the packet engine operates at any session or application layer above layer 4. For example in one embodiment the packet engine intercepts or otherwise receives network packets above the transport layer protocol layer such as the payload of a TCP packet in a TCP embodiment.

The packet engine may include a buffer for queuing one or more network packets during processing such as for receipt of a network packet or transmission of a network packet. Additionally the packet engine is in communication with one or more network stacks to send and receive network packets via network ports . The packet engine may include a packet processing timer. In one embodiment the packet processing timer provides one or more time intervals to trigger the processing of incoming i.e. received or outgoing i.e. transmitted network packets. In some embodiments the packet engine processes network packets responsive to the timer. The packet processing timer provides any type and form of signal to the packet engine to notify trigger or communicate a time related event interval or occurrence. In many embodiments the packet processing timer operates in the order of milliseconds such as for example 100 ms 50 ms 25 ms 10 ms 5 ms or 1 ms.

During operations the packet engine may be interfaced integrated or be in communication with any portion of the network optimization engine such as the LAN WAN detector flow controller QoS engine protocol accelerator compression engine cache manager and or policy engine . As such any of the logic functions or operations of the LAN WAN detector flow controller QoS engine protocol accelerator compression engine cache manager and policy engine may be performed responsive to the packet processing timer and or the packet engine . In some embodiments any of the logic functions or operations of the encryption engine cache manager policy engine and multi protocol compression logic may be performed at the granularity of time intervals provided via the packet processing timer for example at a time interval of less than or equal to 10 ms. For example in one embodiment the cache manager may perform expiration of any cached objects responsive to the integrated packet engine and or the packet processing timer . In another embodiment the expiry or invalidation time of a cached object can be set to the same order of granularity as the time interval of the packet processing timer such as at every 10 ms.

The cache manager may include software hardware or any combination of software and hardware to store data information and objects to a cache in memory or storage provide cache access and control and manage the cache. The data objects or content processed and stored by the cache manager may include data in any format such as a markup language or any type of data communicated via any protocol. In some embodiments the cache manager duplicates original data stored elsewhere or data previously computed generated or transmitted in which the original data may require longer access time to fetch compute or otherwise obtain relative to reading a cache memory or storage element. Once the data is stored in the cache future use can be made by accessing the cached copy rather than refetching or recomputing the original data thereby reducing the access time. In some embodiments the cache may comprise a data object in memory of the appliance . In another embodiment the cache may comprise any type and form of storage element of the appliance such as a portion of a hard disk. In some embodiments the processing unit of the device may provide cache memory for use by the cache manager . In yet further embodiments the cache manager may use any portion and combination of memory storage or the processing unit for caching data objects and other content.

Furthermore the cache manager includes any logic functions rules or operations to perform any caching techniques of the appliance . In some embodiments the cache manager may operate as an application library program service process thread or task. In some embodiments the cache manager can comprise any type of general purpose processor GPP or any other type of integrated circuit such as a Field Programmable Gate Array FPGA Programmable Logic Device PLD or Application Specific Integrated Circuit ASIC .

The policy engine includes any logic function or operations for providing and applying one or more policies or rules to the function operation or configuration of any portion of the appliance . The policy engine may include for example an intelligent statistical engine or other programmable application s . In one embodiment the policy engine provides a configuration mechanism to allow a user to identify specify define or configure a policy for the network optimization engine or any portion thereof. For example the policy engine may provide policies for what data to cache when to cache the data for whom to cache the data when to expire an object in cache or refresh the cache. In other embodiments the policy engine may include any logic rules functions or operations to determine and provide access control and management of objects data or content being cached by the appliance in addition to access control and management of security network traffic network access compression or any other function or operation performed by the appliance .

In some embodiments the policy engine provides and applies one or more policies based on any one or more of the following a user identification of the client identification of the server the type of connection the time of the connection the type of network or the contents of the network traffic. In one embodiment the policy engine provides and applies a policy based on any field or header at any protocol layer of a network packet. In another embodiment the policy engine provides and applies a policy based on any payload of a network packet. For example in one embodiment the policy engine applies a policy based on identifying a certain portion of content of an application layer protocol carried as a payload of a transport layer packet. In another example the policy engine applies a policy based on any information identified by a client server or user certificate. In yet another embodiment the policy engine applies a policy based on any attributes or characteristics obtained about a client such as via any type and form of endpoint detection see for example the collection agent of the client agent discussed below .

In one embodiment the policy engine works in conjunction or cooperation with the policy engine of the application delivery system . In some embodiments the policy engine is a distributed portion of the policy engine of the application delivery system . In another embodiment the policy engine of the application delivery system is deployed on or executed on the appliance . In some embodiments the policy engines both operate on the appliance . In yet another embodiment the policy engine or a portion thereof of the appliance operates on a server .

The compression engine includes any logic business rules function or operations for compressing one or more protocols of a network packet such as any of the protocols used by the network stack of the appliance . The compression engine may also be referred to as a multi protocol compression engine in that it may be designed constructed or capable of compressing a plurality of protocols. In one embodiment the compression engine applies context insensitive compression which is compression applied to data without knowledge of the type of data. In another embodiment the compression engine applies context sensitive compression. In this embodiment the compression engine utilizes knowledge of the data type to select a specific compression algorithm from a suite of suitable algorithms. In some embodiments knowledge of the specific protocol is used to perform context sensitive compression. In one embodiment the appliance or compression engine can use port numbers e.g. well known ports as well as data from the connection itself to determine the appropriate compression algorithm to use. Some protocols use only a single type of data requiring only a single compression algorithm that can be selected when the connection is established. Other protocols contain different types of data at different times. For example POP IMAP SMTP and HTTP all move files of arbitrary types interspersed with other protocol data.

In one embodiment the compression engine uses a delta type compression algorithm. In another embodiment the compression engine uses first site compression as well as searching for repeated patterns among data stored in cache memory or disk. In some embodiments the compression engine uses a lossless compression algorithm. In other embodiments the compression engine uses a lossy compression algorithm. In some cases knowledge of the data type and sometimes permission from the user are required to use a lossy compression algorithm. In some embodiments compression is not limited to the protocol payload. The control fields of the protocol itself may be compressed. In some embodiments the compression engine uses a different algorithm for control fields than that used for the payload.

In some embodiments the compression engine compresses at one or more layers of the network stack . In one embodiment the compression engine compresses at a transport layer protocol. In another embodiment the compression engine compresses at an application layer protocol. In some embodiments the compression engine compresses at a layer 2 4 protocol. In other embodiments the compression engine compresses at a layer 5 7 protocol. In yet another embodiment the compression engine compresses a transport layer protocol and an application layer protocol. In some embodiments the compression engine compresses a layer 2 4 protocol and a layer 5 7 protocol.

In some embodiments the compression engine uses memory based compression cache based compression or disk based compression or any combination thereof. As such the compression engine may be referred to as a multi layer compression engine. In one embodiment the compression engine uses a history of data stored in memory such as RAM. In another embodiment the compression engine uses a history of data stored in a cache such as L2 cache of the processor. In other embodiments the compression engine uses a history of data stored to a disk or storage location. In some embodiments the compression engine uses a hierarchy of cache based memory based and disk based data history. The compression engine may first use the cache based data to determine one or more data matches for compression and then may check the memory based data to determine one or more data matches for compression. In another case the compression engine may check disk storage for data matches for compression after checking either the cache based and or memory based data history.

In one embodiment multi protocol compression engine compresses bi directionally between clients and servers any TCP IP based protocol including Messaging Application Programming Interface MAPI email File Transfer Protocol FTP HyperText Transfer Protocol HTTP Common Internet File System CIFS protocol file transfer Independent Computing Architecture ICA protocol Remote Desktop Protocol RDP Wireless Application Protocol WAP Mobile IP protocol and Voice Over IP VoIP protocol. In other embodiments multi protocol compression engine provides compression of HyperText Markup Language HTML based protocols and in some embodiments provides compression of any markup languages such as the Extensible Markup Language XML . In one embodiment the multi protocol compression engine provides compression of any high performance protocol such as any protocol designed for appliance to appliance communications. In another embodiment the multi protocol compression engine compresses any payload of or any communication using a modified transport control protocol such as Transaction TCP T TCP TCP with selection acknowledgements TCP SACK TCP with large windows TCP LW a congestion prediction protocol such as the TCP Vegas protocol and a TCP spoofing protocol.

As such the multi protocol compression engine may accelerate performance for users accessing applications via desktop clients e.g. Microsoft Outlook and non Web thin clients such as any client launched by popular enterprise applications like Oracle SAP and Siebel and even mobile clients such as the Pocket PC. In some embodiments the multi protocol compression engine by integrating with packet processing engine accessing the network stack is able to compress any of the protocols carried by a transport layer protocol such as any application layer protocol.

The LAN WAN detector includes any logic business rules function or operations for automatically detecting a slow side connection e.g. a wide area network WAN connection such as an Intranet and associated port and a fast side connection e.g. a local area network LAN connection and an associated port . In some embodiments the LAN WAN detector monitors network traffic on the network ports of the appliance to detect a synchronization packet sometimes referred to as a tagged network packet. The synchronization packet identifies a type or speed of the network traffic. In one embodiment the synchronization packet identifies a WAN speed or WAN type connection. The LAN WAN detector also identifies receipt of an acknowledgement packet to a tagged synchronization packet and on which port it is received. The appliance then configures itself to operate the identified port on which the tagged synchronization packet arrived so that the speed on that port is set to be the speed associated with the network connected to that port. The other port is then set to the speed associated with the network connected to that port.

For ease of discussion herein reference to slow side will be made with respect to connection with a wide area network WAN e.g. the Internet and operating at a network speed of the WAN. Likewise reference to fast side will be made with respect to connection with a local area network LAN and operating at a network speed the LAN. However it is noted that fast and slow sides in a network can change on a per connection basis and are relative terms to the speed of the network connections or to the type of network topology. Such configurations are useful in complex network topologies where a network is fast or slow only when compared to adjacent networks and not in any absolute sense.

In one embodiment the LAN WAN detector may be used to allow for auto discovery by an appliance of a network to which it connects. In another embodiment the LAN WAN detector may be used to detect the existence or presence of a second appliance deployed in the network . For example an auto discovery mechanism in operation in accordance with functions as follows appliance and are placed in line with the connection linking client and server . The appliances and are at the ends of a low speed link e.g. Internet connecting two LANs. In one example embodiment appliances and each include two ports one to connect with the lower speed link and the other to connect with a higher speed link e.g. a LAN. Any packet arriving at one port is copied to the other port. Thus appliance and are each configured to function as a bridge between the two networks .

When an end node such as the client opens a new TCP connection with another end node such as the server the client sends a TCP packet with a synchronization SYN header bit set or a SYN packet to the server . In the present example client opens a transport layer connection to server . When the SYN packet passes through appliance the appliance inserts attaches or otherwise provides a characteristic TCP header option to the packet which announces its presence. If the packet passes through a second appliance in this example appliance the second appliance notes the header option on the SYN packet. The server responds to the SYN packet with a synchronization acknowledgment SYN ACK packet. When the SYN ACK packet passes through appliance a TCP header option is tagged e.g. attached inserted or added to the SYN ACK packet to announce appliance presence to appliance . When appliance receives this packet both appliances are now aware of each other and the connection can be appropriately accelerated.

Further to the operations of the LAN WAN detector a method or process for detecting fast and slow sides of a network using a SYN packet is described. During a transport layer connection establishment between a client and a server the appliance via the LAN WAN detector determines whether the SYN packet is tagged with an acknowledgement ACK . If it is tagged the appliance identifies or configures the port receiving the tagged SYN packet SYN ACK as the slow side. In one embodiment the appliance optionally removes the ACK tag from the packet before copying the packet to the other port. If the LAN WAN detector determines that the packet is not tagged the appliance identifies or configure the port receiving the untagged packet as the fast side. The appliance then tags the SYN packet with an ACK and copies the packet to the other port.

In another embodiment the LAN WAN detector detects fast and slow sides of a network using a SYN ACK packet. The appliance via the LAN WAN detector determines whether the SYN ACK packet is tagged with an acknowledgement ACK . If it is tagged the appliance identifies or configures the port receiving the tagged SYN packet SYN ACK as the slow side. In one embodiment the appliance optionally removes the ACK tag from the packet before copying the packet to the other port. If the LAN WAN detector determines that the packet is not tagged the appliance identifies or configures the port receiving the untagged packet as the fast side. The LAN WAN detector determines whether the SYN packet was tagged. If the SYN packet was not tagged the appliance copied the packet to the other port. If the SYN packet was tagged the appliance tags the SYN ACK packet before copying it to the other port.

The appliance may add insert modify attach or otherwise provide any information or data in the TCP option header to provide any information data or characteristics about the network connection network traffic flow or the configuration or operation of the appliance . In this manner not only does an appliance announce its presence to another appliance or tag a higher or lower speed connection the appliance provides additional information and data via the TCP option headers about the appliance or the connection. The TCP option header information may be useful to or used by an appliance in controlling managing optimizing acceleration or improving the network traffic flow traversing the appliance or to otherwise configure itself or operation of a network port.

Although generally described in conjunction with detecting speeds of network connections or the presence of appliances the LAN WAN detector can be used for applying any type of function logic or operation of the appliance to a port connection or flow of network traffic. In particular automated assignment of ports can occur whenever a device performs different functions on different ports where the assignment of a port to a task can be made during the unit s operation and or the nature of the network segment on each port is discoverable by the appliance .

The flow controller includes any logic business rules function or operations for optimizing accelerating or otherwise improving the performance operation or quality of service of transport layer communications of network packets or the delivery of packets at the transport layer. A flow controller also sometimes referred to as a flow control module regulates manages and controls data transfer rates. In some embodiments the flow controller is deployed at or connected at a bandwidth bottleneck in the network . In one embodiment the flow controller effectively regulates manages and controls bandwidth usage or utilization. In other embodiments the flow control modules may also be deployed at points on the network of latency transitions low latency to high latency and on links with media losses such as wireless or satellite links .

In some embodiments a flow controller may include a receiver side flow control module for controlling the rate of receipt of network transmissions and a sender side flow control module for the controlling the rate of transmissions of network packets. In other embodiments a first flow controller includes a receiver side flow control module and a second flow controller includes a sender side flow control module. In some embodiments a first flow controller is deployed on a first appliance and a second flow controller is deployed on a second appliance . As such in some embodiments a first appliance controls the flow of data on the receiver side and a second appliance controls the data flow from the sender side. In yet another embodiment a single appliance includes flow control for both the receiver side and sender side of network communications traversing the appliance .

In one embodiment a flow control module is configured to allow bandwidth at the bottleneck to be more fully utilized and in some embodiments not overutilized. In some embodiments the flow control module transparently buffers or rebuffers data already buffered by for example the sender network sessions that pass between nodes having associated flow control modules . When a session passes through two or more flow control modules one or more of the flow control modules controls a rate of the session s .

In one embodiment the flow control module is configured with predetermined data relating to bottleneck bandwidth. In another embodiment the flow control module may be configured to detect the bottleneck bandwidth or data associated therewith. A receiver side flow control module may control the data transmission rate. The receiver side flow control module controls the sender side flow control module e.g. data transmission rate by forwarding transmission rate limits to the sender side flow control module . In one embodiment the receiver side flow control module piggybacks these transmission rate limits on acknowledgement ACK packets or signals sent to the sender e.g. client by the receiver e.g. server . The receiver side flow control module does this in response to rate control requests that are sent by the sender side flow control module . The requests from the sender side flow control module may be piggybacked on data packets sent by the sender .

In some embodiments the flow controller manipulates adjusts simulates changes improves or otherwise adapts the behavior of the transport layer protocol to provide improved performance or operations of delivery data rates and or bandwidth utilization of the transport layer. The flow controller may implement a plurality of data flow control techniques at the transport layer including but not limited to 1 pre acknowledgements 2 window virtualization 3 recongestion techniques 3 local retransmission techniques 4 wavefront detection and disambiguation 5 transport control protocol selective acknowledgements 6 transaction boundary detection techniques and 7 repacketization.

Although a sender may be generally described herein as a client and a receiver as a server a sender may be any end point such as a server or any computing device on the network . Likewise a receiver may be a client or any other computing device on the network .

In brief overview of a pre acknowledgement flow control technique the flow controller in some embodiments handles the acknowledgements and retransmits for a sender effectively terminating the sender s connection with the downstream portion of a network connection. In reference to one possible deployment of an appliance into a network architecture to implement this feature is depicted. In this example environment a sending computer or client transmits data on network for example via a switch which determines that the data is destined for VPN appliance . Because of the chosen network topology all data destined for VPN appliance traverses appliance so the appliance can apply any necessary algorithms to this data.

Continuing further with the example the client transmits a packet which is received by the appliance . When the appliance receives the packet which is transmitted from the client to a recipient via the VPN appliance the appliance retains a copy of the packet and forwards the packet downstream to the VPN appliance . The appliance then generates an acknowledgement packet ACK and sends the ACK packet back to the client or sending endpoint. This ACK a pre acknowledgment causes the sender to believe that the packet has been delivered successfully freeing the sender s resources for subsequent processing. The appliance retains the copy of the packet data in the event that a retransmission of the packet is required so that the sender does not have to handle retransmissions of the data. This early generation of acknowledgements may be called preacking 

If a retransmission of the packet is required the appliance retransmits the packet to the sender. The appliance may determine whether retransmission is required as a sender would in a traditional system for example determining that a packet is lost if an acknowledgement has not been received for the packet after a predetermined amount of time. To this end the appliance monitors acknowledgements generated by the receiving endpoint e.g. server or any other downstream network entity so that it can determine whether the packet has been successfully delivered or needs to be retransmitted. If the appliance determines that the packet has been successfully delivered the appliance is free to discard the saved packet data. The appliance may also inhibit forwarding acknowledgements for packets that have already been received by the sending endpoint.

In the embodiment described above the appliance via the flow controller controls the sender through the delivery of pre acknowledgements also referred to as preacks as though the appliance was a receiving endpoint itself. Since the appliance is not an endpoint and does not actually consume the data the appliance includes a mechanism for providing overflow control to the sending endpoint. Without overflow control the appliance could run out of memory because the appliance stores packets that have been preacked to the sending endpoint but not yet acknowledged as received by the receiving endpoint. Therefore in a situation in which the sender transmits packets to the appliance faster than the appliance can forward the packets downstream the memory available in the appliance to store unacknowledged packet data can quickly fill. A mechanism for overflow control allows the appliance to control transmission of the packets from the sender to avoid this problem.

In one embodiment the appliance or flow controller includes an inherent self clocking overflow control mechanism. This self clocking is due to the order in which the appliance may be designed to transmit packets downstream and send ACKs to the sender or . In some embodiments the appliance does not preack the packet until after it transmits the packet downstream. In this way the sender will receive the ACKs at the rate at which the appliance is able to transmit packets rather than the rate at which the appliance receives packets from the sender . This helps to regulate the transmission of packets from a sender .

Another overflow control mechanism that the appliance may implement is to use the TCP window size parameter which tells a sender how much buffer the receiver is permitting the sender to fill up. A nonzero window size e.g. a size of at least one Maximum Segment Size MSS in a preack permits the sending endpoint to continue to deliver data to the appliance whereas a zero window size inhibits further data transmission. Accordingly the appliance may regulate the flow of packets from the sender for example when the appliance s buffer is becoming full by appropriately setting the TCP window size in each preack.

Another technique to reduce this additional overhead is to apply hysteresis. When the appliance delivers data to the slower side the overflow control mechanism in the appliance can require that a minimum amount of space be available before sending a nonzero window advertisement to the sender. In one embodiment the appliance waits until there is a minimum of a predetermined number of packets such as four packets of space available before sending a nonzero window packet such as a packet indicating a window size of four packets. This may reduce the overhead by approximately a factor of four since only two ACK packets are sent for each group of four data packets instead of eight ACK packets for four data packets.

Another technique the appliance or flow controller may use for overflow control is the TCP delayed ACK mechanism which skips ACKs to reduce network traffic. The TCP delayed ACKs automatically delay the sending of an ACK either until two packets are received or until a fixed timeout has occurred. This mechanism alone can result in cutting the overhead in half moreover by increasing the numbers of packets above two additional overhead reduction is realized. But merely delaying the ACK itself may be insufficient to control overflow and the appliance may also use the advertised window mechanism on the ACKs to control the sender. When doing this the appliance in one embodiment avoids triggering the timeout mechanism of the sender by delaying the ACK too long.

In one embodiment the flow controller does not preack the last packet of a group of packets. By not preacking the last packet or at least one of the packets in the group the appliance avoids a false acknowledgement for a group of packets. For example if the appliance were to send a preack for a last packet and the packet were subsequently lost the sender would have been tricked into thinking that the packet is delivered when it was not. Thinking that the packet had been delivered the sender could discard that data. If the appliance also lost the packet there would be no way to retransmit the packet to the recipient. By not preacking the last packet of a group of packets the sender will not discard the packet until it has been delivered.

In another embodiment the flow controller may use a window virtualization technique to control the rate of flow or bandwidth utilization of a network connection. Though it may not immediately be apparent from examining conventional literature such as RFC 1323 there is effectively a send window for transport layer protocols such as TCP. The send window is similar to the receive window in that it consumes buffer space though on the sender . The sender s send window consists of all data sent by the application that has not been acknowledged by the receiver. This data must be retained in memory in case retransmission is required. Since memory is a shared resource some TCP stack implementations limit the size of this data. When the send window is full an attempt by an application program to send more data results in blocking the application program until space is available. Subsequent reception of acknowledgements will free send window memory and unblock the application program. This window size is known as the socket buffer size in some TCP implementations.

In one embodiment the flow control module is configured to provide access to increased window or buffer sizes. This configuration may also be referenced to as window virtualization. In an embodiment including TCP as the transport layer protocol the TCP header may include a bit string corresponding to a window scale. In one embodiment window may be referenced in a context of send receive or both.

One embodiment of window virtualization is to insert a preacking appliance into a TCP session. In reference to any of the environments of or B initiation of a data communication session between a source node e.g. client for ease of discussion now referenced as source node and a destination node e.g. server for ease of discussion now referenced as destination node is established. For TCP communications the source node initially transmits a synchronization signal SYN through its local area network to first flow control module . The first flow control module inserts a configuration identifier into the TCP header options area. The configuration identifier identifies this point in the data path as a flow control module.

The appliances via a flow control module provide window or buffer to allow increasing data buffering capabilities within a session despite having end nodes with small buffer sizes e.g. typically 16 k bytes. However RFC 1323 requires window scaling for any buffer sizes greater than 64 k bytes which must be set at the time of session initialization SYN SYN ACK signals . Moreover the window scaling corresponds to the lowest common denominator in the data path often an end node with small buffer size. This window scale often is a scale of 0 or 1 which corresponds to a buffer size of up to 64 k or 128 k bytes. Note that because the window size is defined as the window field in each packet shifted over by the window scale the window scale establishes an upper limit for the buffer but does not guarantee the buffer is actually that large. Each packet indicates the current available buffer space at the receiver in the window field.

In one embodiment of scaling using the window virtualization technique during connection establishment i.e. initialization of a session when the first flow control module receives from the source node the SYN signal or packet the flow control module stores the windows scale of the source node which is the previous node or stores a 0 for window scale if the scale of the previous node is missing. The first flow control module also modifies the scale e.g. increases the scale to 4 from 0 or 1 in the SYN FCM signal. When the second flow control module receives the SYN signal it stores the increased scale from the first flow control signal and resets the scale in the SYN signal back to the source node scale value for transmission to the destination node . When the second flow controller receives the SYN ACK signal from the destination node it stores the scale from the destination node scale e.g. 0 or 1 and modifies it to an increased scale that is sent with the SYN ACK FCM signal. The first flow control node receives and notes the received window scale and revises the windows scale sent back to the source node back down to the original scale e.g. 0 or 1. Based on the above window shift conversation during connection establishment the window field in every subsequent packet e.g. TCP packet of the session must be shifted according to the window shift conversion.

The window scale as described above expresses buffer sizes of over 64 k and may not be required for window virtualization. Thus shifts for window scale may be used to express increased buffer capacity in each flow control module . This increase in buffer capacity in may be referenced as window or buffer virtualization. The increase in buffer size allows greater packet throughput from and to the respective end nodes and . Note that buffer sizes in TCP are typically expressed in terms of bytes but for ease of discussion packets may be used in the description herein as it relates to virtualization.

By way of example a window or buffer virtualization performed by the flow controller is described. In this example the source node and the destination node are configured similar to conventional end nodes having a limited buffer capacity of 16 k bytes which equals approximately 10 packets of data. Typically an end node must wait until the packet is transmitted and confirmation is received before a next group of packets can be transmitted. In one embodiment using increased buffer capacity in the flow control modules when the source node transmits its data packets the first flow control module receives the packets stores it in its larger capacity buffer e.g. packet capacity and immediately sends back an acknowledgement signal indicating receipt of the packets REC ACK back to the source node . The source node can then flush its current buffer load the buffer with 10 new data packets and transmit those onto the first flow control module . Again the first flow control module transmits a REC ACK signal back to the source node and the source node flushes its buffer and loads it with 10 more new packets for transmission.

As the first flow control module receives the data packets from the source nodes it loads up its buffer accordingly. When it is ready the first flow control module can begin transmitting the data packets to the second flow control module which also has an increased buffer size for example to receive 512 packets. The second flow control module receives the data packets and begins to transmit packets at a time to the destination node . Each REC ACK received at the second flow control node from the destination node results in 10 more packets being transmitted to the destination node until all the data packets are transferred. Hence the present invention is able to increase data transmission throughput between the source node sender and the destination node receiver by taking advantage of the larger buffer in the flow control modules between the devices.

It is noted that by preacking the transmission of data as described previously a sender or source node is allowed to transmit more data than is possible without the preacks thus affecting a larger window size. For example in one embodiment this technique is effective when the flow control module is located near a node e.g. source node or destination node that lacks large windows.

Another technique or algorithm of the flow controller is referred to as recongestion. The standard TCP congestion avoidance algorithms are known to perform poorly in the face of certain network conditions including large RTTs round trip times high packet loss rates and others. When the appliance detects a congestion condition such as long round trip times or high packet loss the appliance intervenes substituting an alternate congestion avoidance algorithm that better suits the particular network condition. In one embodiment the recongestion algorithm uses preacks to effectively terminate the connection between the sender and the receiver. The appliance then resends the packets from itself to the receiver using a different congestion avoidance algorithm. Recongestion algorithms may be dependent on the characteristics of the TCP connection. The appliance monitors each TCP connection characterizing it with respect to the different dimensions selecting a recongestion algorithm that is appropriate for the current characterization.

In one embodiment upon detecting a TCP connection that is limited by round trip times RTT a recongestion algorithm is applied which behaves as multiple TCP connections. Each TCP connection operates within its own performance limit but the aggregate bandwidth achieves a higher performance level. One parameter in this mechanism is the number of parallel connections that are applied N . Too large a value of N and the connection bundle achieves more than its fair share of bandwidth. Too small a value of N and the connection bundle achieves less than its fair share of bandwidth. One method of establishing N relies on the appliance monitoring the packet loss rate RTT and packet size of the actual connection. These numbers are plugged into a TCP response curve formula to provide an upper limit on the performance of a single TCP connection in the present configuration. If each connection within the connection bundle is achieving substantially the same performance as that computed to be the upper limit then additional parallel connections are applied. If the current bundle is achieving less performance than the upper limit the number of parallel connections is reduced. In this manner the overall fairness of the system is maintained since individual connection bundles contain no more parallelism than is required to eliminate the restrictions imposed by the protocol itself. Furthermore each individual connection retains TCP compliance.

Another method of establishing N is to utilize a parallel flow control algorithm such as the TCP Vegas algorithm or the TCP Stabilized Vegas algorithm. In this method the network information associated with the connections in the connection bundle e.g. RTT loss rate average packet size etc. is aggregated and applied to the alternate flow control algorithm. The results of this algorithm are in turn distributed among the connections of the bundle controlling their number i.e. N . Optionally each connection within the bundle continues using the standard TCP congestion avoidance algorithm.

In another embodiment the individual connections within a parallel bundle are virtualized i.e. actual individual TCP connections are not established. Instead the congestion avoidance algorithm is modified to behave as though there were N parallel connections. This method has the advantage of appearing to transiting network nodes as a single connection. Thus the QOS security and other monitoring methods of these nodes are unaffected by the recongestion algorithm. In yet another embodiment the individual connections within a parallel bundle are real i.e. a separate. TCP connection is established for each of the parallel connections within a bundle. The congestion avoidance algorithm for each TCP connection need not be modified.

In some embodiments the flow controller may apply a local retransmission technique. One reason for implementing preacks is to prepare to transit to a high loss link e.g. wireless . In these embodiments the preacking appliance or flow control module is located most beneficially before the wireless link. This allows retransmissions to be performed closer to the high loss link removing the retransmission burden from the remainder of the network. The appliance may provide local retransmission in which case packets dropped due to failures of the link are retransmitted directly by the appliance . This is advantageous because it eliminates the retransmission burden upon an end node such as server and infrastructure of any of the networks . With appliance providing local retransmissions the dropped packet can be retransmitted across the high loss link without necessitating a retransmit by an end node and a corresponding decrease in the rate of data transmission from the end node.

Another reason for implementing preacks is to avoid a receive time out RTO penalty. In standard TCP there are many situations that result in an RTO even though a large percentage of the packets in flight were successfully received. With standard TCP algorithms dropping more than one packet within an RTT window would likely result in a timeout.

Additionally most TCP connections experience a timeout if a retransmitted packet is dropped. In a network with a high bandwidth delay product even a relatively small packet loss rate will cause frequent Retransmission timeouts RTOs . In one embodiment the appliance uses a retransmit and timeout algorithm is avoid premature RTOs. The appliance or flow controller maintains a count of retransmissions is maintained on a per packet basis. Each time that a packet is retransmitted the count is incremented by one and the appliance continues to transmit packets. In some embodiments only if a packet has been retransmitted a predetermined number of times is an RTO declared.

In some embodiments the appliance or flow controller uses wavefront detection and disambiguation techniques in managing and controlling flow of network traffic. In this technique the flow controller uses transmit identifiers or numbers to determine whether particular data packets need to be retransmitted. By way of example a sender transmits data packets over a network where each instance of a transmitted data packet is associated with a transmit number. It can be appreciated that the transmit number for a packet is not the same as the packet s sequence number since a sequence number references the data in the packet while the transmit number references an instance of a transmission of that data. The transmit number can be any information usable for this purpose including a timestamp associated with a packet or simply an increasing number similar to a sequence number or a packet number . Because a data segment may be retransmitted different transmit numbers may be associated with a particular sequence number.

As the sender transmits data packets the sender maintains a data structure of acknowledged instances of data packet transmissions. Each instance of a data packet transmission is referenced by its sequence number and transmit number. By maintaining a transmit number for each packet the sender retains the ordering of the transmission of data packets. When the sender receives an ACK or a SACK the sender determines the highest transmit number associated with packets that the receiver indicated has arrived in the received acknowledgement . Any outstanding unacknowledged packets with lower transmit numbers are presumed lost.

In some embodiments the sender is presented with an ambiguous situation when the arriving packet has been retransmitted a standard ACK SACK does not contain enough information to allow the sender to determine which transmission of the arriving packet has triggered the acknowledgement. After receiving an ambiguous acknowledgement therefore the sender disambiguates the acknowledgement to associate it with a transmit number. In various embodiments one or a combination of several techniques may be used to resolve this ambiguity.

In one embodiment the sender includes an identifier with a transmitted data packet and the receiver returns that identifier or a function thereof with the acknowledgement. The identifier may be a timestamp e.g. a TCP timestamp as described in RFC 1323 a sequential number or any other information that can be used to resolve between two or more instances of a packet s transmission. In an embodiment in which the TCP timestamp option is used to disambiguate the acknowledgement each packet is tagged with up to 32 bits of unique information. Upon receipt of the data packet the receiver echoes this unique information back to the sender with the acknowledgement. The sender ensures that the originally sent packet and its retransmitted version or versions contain different values for the timestamp option allowing it to unambiguously eliminate the ACK ambiguity. The sender may maintain this unique information for example in the data structure in which it stores the status of sent data packets. This technique is advantageous because it complies with industry standards and is thus likely to encounter little or no interoperability issues. However this technique may require ten bytes of TCP header space in some implementations reducing the effective throughput rate on the network and reducing space available for other TCP options.

In another embodiment another field in the packet such as the IP ID field is used to disambiguate in a way similar to the TCP timestamp option described above. The sender arranges for the ID field values of the original and the retransmitted version or versions of the packet to have different ID fields in the IP header. Upon reception of the data packet at the receiver or a proxy device thereof the receiver sets the ID field of the ACK packet to a function of the ID field of the packet that triggers the ACK. This method is advantageous as it requires no additional data to be sent preserving the efficiency of the network and TCP header space. The function chosen should provide a high degree of likelihood of providing disambiguation. In a preferred embodiment the sender selects IP ID values with the most significant bit set to 0. When the receiver responds the IP ID value is set to the same IP ID value with the most significant bit set to a one.

In another embodiment the transmit numbers associated with non ambiguous acknowledgements are used to disambiguate an ambiguous acknowledgement. This technique is based on the principle that acknowledgements for two packets will tend to be received closer in time as the packets are transmitted closer in time. Packets that are not retransmitted will not result in ambiguity as the acknowledgements received for such packets can be readily associated with a transmit number. Therefore these known transmit numbers are compared to the possible transmit numbers for an ambiguous acknowledgement received near in time to the known acknowledgement. The sender compares the transmit numbers of the ambiguous acknowledgement against the last known received transmit number selecting the one closest to the known received transmit number. For example if an acknowledgement for data packet is received and the last received acknowledgement was for data packet the sender resolves the ambiguity by assuming that the third instance of data packet caused the acknowledgement.

Another technique of the appliance or flow controller is to implement an embodiment of transport control protocol selective acknowledgements or TCP SACK to determine what packets have or have not been received. This technique allows the sender to determine unambiguously a list of packets that have been received by the receiver as well as an accurate list of packets not received. This functionality may be implemented by modifying the sender and or receiver or by inserting sender and receiver side flow control modules in the network path between the sender and receiver. In reference to or a sender e.g. client is configured to transmit data packets to the receiver e.g. server over the network . In response the receiver returns a TCP Selective Acknowledgment option referred to as SACK packet to the sender. In one embodiment the communication is bi directional although only one direction of communication is discussed here for simplicity. The receiver maintains a list or other suitable data structure that contains a group of ranges of sequence numbers for data packets that the receiver has actually received. In some embodiments the list is sorted by sequence number in an ascending or descending order. The receiver also maintains a left off pointer which comprises a reference into the list and indicates the left off point from the previously generated SACK packet.

Upon reception of a data packet the receiver generates and transmits a SACK packet back to the sender. In some embodiments the SACK packet includes a number of fields each of which can hold a range of sequence numbers to indicate a set of received data packets. The receiver fills this first field of the SACK packet with a range of sequence numbers that includes the landing packet that triggered the SACK packet. The remaining available SACK fields are filled with ranges of sequence numbers from the list of received packets. As there are more ranges in the list than can be loaded into the SACK packet the receiver uses the left off pointer to determine which ranges are loaded into the SACK packet. The receiver inserts the SACK ranges consecutively from the sorted list starting from the range referenced by the pointer and continuing down the list until the available SACK range space in the TCP header of the SACK packet is consumed. The receiver wraps around to the start of the list if it reaches the end. In some embodiments two or three additional SACK ranges can be added to the SACK range information.

Once the receiver generates the SACK packet the receiver sends the acknowledgement back to the sender. The receiver then advances the left off pointer by one or more SACK range entries in the list. If the receiver inserts four SACK ranges for example the left off pointer may be advanced two SACK ranges in the list. When the advanced left off pointer reaches at the end of the list the pointer is reset to the start of the list effectively wrapping around the list of known received ranges. Wrapping around the list enables the system to perform well even in the presence of large losses of SACK packets since the SACK information that is not communicated due to a lost SACK packet will eventually be communicated once the list is wrapped around.

It can be appreciated therefore that a SACK packet may communicate several details about the condition of the receiver. First the SACK packet indicates that upon generation of the SACK packet the receiver had just received a data packet that is within the first field of the SACK information. Secondly the second and subsequent fields of the SACK information indicate that the receiver has received the data packets within those ranges. The SACK information also implies that the receiver had not at the time of the SACK packet s generation received any of the data packets that fall between the second and subsequent fields of the SACK information. In essence the ranges between the second and subsequent ranges in the SACK information are holes in the received data the data therein known not to have been delivered. Using this method therefore when a SACK packet has sufficient space to include more than two SACK ranges the receiver may indicate to the sender a range of data packets that have not yet been received by the receiver.

In another embodiment the sender uses the SACK packet described above in combination with the retransmit technique described above to make assumptions about which data packets have been delivered to the receiver. For example when the retransmit algorithm using the transmit numbers declares a packet lost the sender considers the packet to be only conditionally lost as it is possible that the SACK packet identifying the reception of this packet was lost rather than the data packet itself. The sender thus adds this packet to a list of potentially lost packets called the presumed lost list. Each time a SACK packet arrives the known missing ranges of data from the SACK packet are compared to the packets in the presumed lost list. Packets that contain data known to be missing are declared actually lost and are subsequently retransmitted. In this way the two schemes are combined to give the sender better information about which packets have been lost and need to be retransmitted.

In some embodiments the appliance or flow controller applies a technique referred to as transaction boundary detection. In one embodiment the technique pertains to ping pong behaved connections. At the TCP layer ping pong behavior is when one communicant a sender sends data and then waits for a response from the other communicant the receiver. Examples of ping pong behavior include remote procedure call HTTP and others. The algorithms described above use retransmission timeout RTO to recover from the dropping of the last packet or packets associated with the transaction. Since the TCP RTO mechanism is extremely coarse in some embodiments for example requiring a minimum one second value in all cases poor application behavior may be seen in these situations.

In one embodiment the sender of data or a flow control module coupled to the sender detects a transaction boundary in the data being sent. Upon detecting a transaction boundary the sender or a flow control module sends additional packets whose reception generates additional ACK or SACK responses from the receiver. Insertion of the additional packets is preferably limited to balance between improved application response time and network capacity utilization. The number of additional packets that is inserted may be selected according to the current loss rate associated with that connection with more packets selected for connections having a higher loss rate.

One method of detecting a transaction boundary is time based. If the sender has been sending data and ceases then after a period of time the sender or flow control module declares a transaction boundary. This may be combined with other techniques. For example the setting of the PSH TCP Push bit by the sender in the TCP header may indicate a transaction boundary. Accordingly combining the time based approach with these additional heuristics can provide for more accurate detection of a transaction boundary. In another technique if the sender or flow control module understands the application protocol it can parse the protocol data stream and directly determine transaction boundaries. In some embodiment this last behavior can be used independent of any time based mechanism.

Responsive to detecting a transaction boundary the sender or flow control module transmits additional data packets to the receiver to cause acknowledgements therefrom. The additional data packets should therefore be such that the receiver will at least generate an ACK or SACK in response to receiving the data packet. In one embodiment the last packet or packets of the transaction are simply retransmitted. This has the added benefit of retransmitting needed data if the last packet or packets had been dropped as compared to merely sending dummy data packets. In another embodiment fractions of the last packet or packets are sent allowing the sender to disambiguate the arrival of these packets from their original packets. This allows the receiver to avoid falsely confusing any reordering adaptation algorithms. In another embodiment any of a number of well known forward error correction techniques can be used to generate additional data for the inserted packets allowing for the reconstruction of dropped or otherwise missing data at the receiver.

In some embodiments the boundary detection technique described herein helps to avoid a timeout when the acknowledgements for the last data packets in a transaction are dropped. When the sender or flow control module receives the acknowledgements for these additional data packets the sender can determine from these additional acknowledgements whether the last data packets have been received or need to be retransmitted thus avoiding a timeout. In one embodiment if the last packets have been received but their acknowledgements were dropped a flow control module generates an acknowledgement for the data packets and sends the acknowledgement to the sender thus communicating to the sender that the data packets have been delivered. In another embodiment if the last packets have not been received a flow control module sends a packet to the sender to cause the sender to retransmit the dropped data packets.

In yet another embodiment the appliance or flow controller applies a repacketization technique for improving the flow of transport layer network traffic. In some embodiments performance of TCP is proportional to packet size. Thus increasing packet sizes improves performance unless it causes substantially increased packet loss rates or other nonlinear effects like IP fragmentation. In general wired media such as copper or fibre optics have extremely low bit error rates low enough that these can be ignored. For these media it is advantageous for the packet size to be the maximum possible before fragmentation occurs the maximum packet size is limited by the protocols of the underlying transmission media . Whereas for transmission media with higher loss rates e.g. wireless technologies such as WiFi etc. or high loss environments such as power line networking etc. increasing the packet size may lead to lower transmission rates as media induced errors cause an entire packet to be dropped i.e. media induced errors beyond the capability of the standard error correcting code for that media increasing the packet loss rate. A sufficiently large increase in the packet loss rate will actually negate any performance benefit of increasing packet size. In some cases it may be difficult for a TCP endpoint to choose an optimal packet size. For example the optimal packet size may vary across the transmission path depending on the nature of each link.

By inserting an appliance or flow control module into the transmission path the flow controller monitors characteristics of the link and repacketizes according to determined link characteristics. In one embodiment an appliance or flow controller repacketizes packets with sequential data into a smaller number of larger packets. In another embodiment an appliance or flow controller repacketizes packets by breaking part a sequence of large packets into a larger number of smaller packets. In other embodiments an appliance or flow controller monitors the link characteristics and adjusts the packet sizes through recombination to improve throughput.

Still referring to the flow controller in some embodiments may include a QoS Engine also referred to as a QoS controller. In another embodiment the appliance and or network optimization engine includes the QoS engine for example separately but in communication with the flow controller . The QoS Engine includes any logic business rules function or operations for performing one or more Quality of Service QoS techniques improving the performance operation or quality of service of any of the network connections. In some embodiments the QoS engine includes network traffic control and management mechanisms that provide different priorities to different users applications data flows or connections. In other embodiments the QoS engine controls maintains or assures a certain level of performance to a user application data flow or connection. In one embodiment the QoS engine controls maintains or assures a certain portion of bandwidth or network capacity for a user application data flow or connection. In some embodiments the QoS engine monitors the achieved level of performance or the quality of service corresponding to a user application data flow or connection for example the data rate and delay. In response to monitoring the QoS engine dynamically controls or adjusts scheduling priorities of network packets to achieve the desired level of performance or quality of service.

In some embodiments the QoS engine prioritizes schedules and transmits network packets according to one or more classes or levels of services. In some embodiments the class or level service may include 1 best efforts 2 controlled load 3 guaranteed or 4 qualitative. For a best efforts class of service the appliance makes reasonable effort to deliver packets a standard service level . For a controlled load class of service the appliance or QoS engine approximates the standard packet error loss of the transmission medium or approximates the behavior of best effort service in lightly loaded network conditions. For a guaranteed class of service the appliance or QoS engine guarantees the ability to transmit data at a determined rate for the duration of the connection. For a qualitative class of service the appliance or QoS engine the qualitative service class is used for applications users data flows or connection that require or desire prioritized traffic but cannot quantify resource needs or level of service. In these cases the appliance or QoS engine determines the class of service or prioritization based on any logic or configuration of the QoS engine or based on business rules or policies. For example in one embodiment the QoS engine prioritizes schedules and transmits network packets according to one or more policies as specified by the policy engine .

The protocol accelerator includes any logic business rules function or operations for optimizing accelerating or otherwise improving the performance operation or quality of service of one or more protocols. In one embodiment the protocol accelerator accelerates any application layer protocol or protocols at layers 5 7 of the network stack. In other embodiments the protocol accelerator accelerates a transport layer or a layer 4 protocol. In one embodiment the protocol accelerator accelerates layer 2 or layer 3 protocols. In some embodiments the protocol accelerator is configured constructed or designed to optimize or accelerate each of one or more protocols according to the type of data characteristics and or behavior of the protocol. In another embodiment the protocol accelerator is configured constructed or designed to improve a user experience response times network or computer load and or network or bandwidth utilization with respect to a protocol.

In one embodiment the protocol accelerator is configured constructed or designed to minimize the effect of WAN latency on file system access. In some embodiments the protocol accelerator optimizes or accelerates the use of the CIFS Common Internet File System protocol to improve file system access times or access times to data and files. In some embodiments the protocol accelerator optimizes or accelerates the use of the NFS Network File System protocol. In another embodiment the protocol accelerator optimizes or accelerates the use of the File Transfer protocol FTP .

In one embodiment the protocol accelerator is configured constructed or designed to optimize or accelerate a protocol carrying as a payload or using any type and form of markup language. In other embodiments the protocol accelerator is configured constructed or designed to optimize or accelerate a HyperText Transfer Protocol HTTP . In another embodiment the protocol accelerator is configured constructed or designed to optimize or accelerate a protocol carrying as a payload or otherwise using XML eXtensible Markup Language .

In some embodiments the appliance and or network optimization engine is transparent to any data flowing across a network connection or link such as a WAN link. In one embodiment the appliance and or network optimization engine operates in such a manner that the data flow across the WAN is recognizable by any network monitoring QOS management or network analysis tools. In some embodiments the appliance and or network optimization engine does not create any tunnels or streams for transmitting data that may hide obscure or otherwise make the network traffic not transparent. In other embodiments the appliance operates transparently in that the appliance does not change any of the source and or destination address information or port information of a network packet such as internet protocol addresses or port numbers. In other embodiments the appliance and or network optimization engine is considered to operate or behave transparently to the network an application client server or other appliances or computing device in the network infrastructure. That is in some embodiments the appliance is transparent in that network related configuration of any device or appliance on the network does not need to be modified to support the appliance .

The appliance may be deployed in any of the following deployment configurations 1 in line of traffic 2 in proxy mode or 3 in a virtual in line mode. In some embodiments the appliance may be deployed inline to one or more of the following a router a client a server or another network device or appliance. In other embodiments the appliance may be deployed in parallel to one or more of the following a router a client a server or another network device or appliance. In parallel deployments a client server router or other network appliance may be configured to forward transfer or transit networks to or via the appliance .

In the embodiment of in line the appliance is deployed inline with a WAN link of a router. In this way all traffic from the WAN passes through the appliance before arriving at a destination of a LAN.

In the embodiment of a proxy mode the appliance is deployed as a proxy device between a client and a server. In some embodiments the appliance allows clients to make indirect connections to a resource on a network. For example a client connects to a resource via the appliance and the appliance provides the resource either by connecting to the resource a different resource or by serving the resource from a cache. In some cases the appliance may alter the client s request or the server s response for various purposes such as for any of the optimization techniques discussed herein. In one embodiment the client send requests addressed to the proxy. In one case the proxy responds to the client in place of or acting as a server . In other embodiments the appliance behaves as a transparent proxy by intercepting and forwarding requests and responses transparently to a client and or server. Without client side configuration the appliance may redirect client requests to different servers or networks. In some embodiments the appliance may perform any type and form of network address translation referred to as NAT on any network traffic traversing the appliance.

In some embodiments the appliance is deployed in a virtual in line mode configuration. In this embodiment a router or a network device with routing or switching functionality is configured to forward reroute or otherwise provide network packets destined to a network to the appliance . The appliance then performs any desired processing on the network packets such as any of the WAN optimization techniques discussed herein. Upon completion of processing the appliance forwards the processed network packet to the router to transmit to the destination on the network. In this way the appliance can be coupled to the router in parallel but still operate as it if the appliance were inline. This deployment mode also provides transparency in that the source and destination addresses and port information are preserved as the packet is processed and transmitted via the appliance through the network.

Although the network optimization engine is generally described above in conjunction with an appliance the network optimization engine or any portion thereof may be deployed distributed or otherwise operated on any end node such as a client and or server . As such a client or server may provide any of the systems and methods of the network optimization engine described herein in conjunction with one or more appliances or without an appliance .

Referring now to an example embodiment of the network optimization engine deployed on one or more end nodes is depicted. In brief overview the client may include a first network optimization engine and the server may include a second network optimization engine . The client and server may establish a transport layer connection and exchange communications with or without traversing an appliance .

In one embodiment the network optimization engine of the client performs the techniques described herein to optimize accelerate or otherwise improve the performance operation or quality of service of network traffic communicated with the server . In another embodiment the network optimization engine of the server performs the techniques described herein to optimize accelerate or otherwise improve the performance operation or quality of service of network traffic communicated with the client . In some embodiments the network optimization engine of the client and the network optimization engine of the server perform the techniques described herein to optimize accelerate or otherwise improve the performance operation or quality of service of network traffic communicated between the client and the server . In yet another embodiment the network optimization engine of the client performs the techniques described herein in conjunction with an appliance to optimize accelerate or otherwise improve the performance operation or quality of service of network traffic communicated with the client . In still another embodiment the network optimization engine of the server performs the techniques described herein in conjunction with an appliance to optimize accelerate or otherwise improve the performance operation or quality of service of network traffic communicated with the server .

As illustrated in a client deployed in the system or with an appliance or may include a client agent . In one embodiment the client agent is used to facilitate communications with one or more appliances or . In some embodiments any of the systems and methods of the appliance or described herein may be deployed implemented or embodied in a client such as via a client agent . In other embodiments the client agent may include applications programs or agents providing additional functionality such as end point detection and authorization virtual private network connectivity and application streaming. Prior to discussing other embodiments of systems and methods of the appliance embodiments of the client agent will be described.

Referring now to an embodiment of a client agent is depicted. The client has a client agent for establishing exchanging managing or controlling communications with the appliance appliance and or server via a network . In some embodiments the client agent which may also be referred to as a WAN client accelerates WAN network communications and or is used to communicate via appliance on a network. In brief overview the client operates on computing device having an operating system with a kernel mode and a user mode and a network stack with one or more layers . The client may have installed and or execute one or more applications. In some embodiments one or more applications may communicate via the network stack to a network . One of the applications such as a web browser may also include a first program . For example the first program may be used in some embodiments to install and or execute the client agent or any portion thereof. The client agent includes an interception mechanism or interceptor for intercepting network communications from the network stack from the one or more applications.

As with the appliance the client has a network stack including any type and form of software hardware or any combinations thereof for providing connectivity to and communications with a network . The network stack of the client includes any of the network stack embodiments described above in conjunction with the appliance . In some embodiments the client agent or any portion thereof is designed and constructed to operate with or work in conjunction with the network stack installed or otherwise provided by the operating system of the client .

In further details the network stack of the client or appliance or may include any type and form of interfaces for receiving obtaining providing or otherwise accessing any information and data related to network communications of the client . In one embodiment an interface to the network stack includes an application programming interface API . The interface may also have any function call hooking or filtering mechanism event or call back mechanism or any type of interfacing technique. The network stack via the interface may receive or provide any type and form of data structure such as an object related to functionality or operation of the network stack . For example the data structure may include information and data related to a network packet or one or more network packets. In some embodiments the data structure includes references or identifies a portion of the network packet processed at a protocol layer of the network stack such as a network packet of the transport layer. In some embodiments the data structure is a kernel level data structure while in other embodiments the data structure is a user mode data structure. A kernel level data structure may have a data structure obtained or related to a portion of the network stack operating in kernel mode or a network driver or other software running in kernel mode or any data structure obtained or received by a service process task thread or other executable instructions running or operating in kernel mode of the operating system.

Additionally some portions of the network stack may execute or operate in kernel mode for example the data link or network layer while other portions execute or operate in user mode such as an application layer of the network stack . For example a first portion of the network stack may provide user mode access to the network stack to an application while a second portion of the network stack provides access to a network. In some embodiments a first portion of the network stack has one or more upper layers of the network stack such as any of layers 5 7. In other embodiments a second portion of the network stack includes one or more lower layers such as any of layers 1 4. Each of the first portion and second portion of the network stack may include any portion of the network stack at any one or more network layers in user mode kernel mode or combinations thereof or at any portion of a network layer or interface point to a network layer or any portion of or interface point to the user mode and kernel mode .

The interceptor may include software hardware or any combination of software and hardware. In one embodiment the interceptor intercepts or otherwise receives a network communication at any point in the network stack and redirects or transmits the network communication to a destination desired managed or controlled by the interceptor or client agent . For example the interceptor may intercept a network communication of a network stack of a first network and transmit the network communication to the appliance for transmission on a second network . In some embodiments the interceptor includes or is a driver such as a network driver constructed and designed to interface and work with the network stack . In some embodiments the client agent and or interceptor operates at one or more layers of the network stack such as at the transport layer. In one embodiment the interceptor includes a filter driver hooking mechanism or any form and type of suitable network driver interface that interfaces to the transport layer of the network stack such as via the transport driver interface TDI . In some embodiments the interceptor interfaces to a first protocol layer such as the transport layer and another protocol layer such as any layer above the transport protocol layer for example an application protocol layer. In one embodiment the interceptor includes a driver complying with the Network Driver Interface Specification NDIS or a NDIS driver. In another embodiment the interceptor may be a min filter or a mini port driver. In one embodiment the interceptor or portion thereof operates in kernel mode . In another embodiment the interceptor or portion thereof operates in user mode . In some embodiments a portion of the interceptor operates in kernel mode while another portion of the interceptor operates in user mode . In other embodiments the client agent operates in user mode but interfaces via the interceptor to a kernel mode driver process service task or portion of the operating system such as to obtain a kernel level data structure . In further embodiments the interceptor is a user mode application or program such as application.

In one embodiment the interceptor intercepts or receives any transport layer connection requests. In these embodiments the interceptor executes transport layer application programming interface API calls to set the destination information such as destination IP address and or port to a desired location for the location. In this manner the interceptor intercepts and redirects the transport layer connection to an IP address and port controlled or managed by the interceptor or client agent . In one embodiment the interceptor sets the destination information for the connection to a local IP address and port of the client on which the client agent is listening. For example the client agent may comprise a proxy service listening on a local IP address and port for redirected transport layer communications. In some embodiments the client agent then communicates the redirected transport layer communication to the appliance .

In some embodiments the interceptor intercepts a Domain Name Service DNS request. In one embodiment the client agent and or interceptor resolves the DNS request. In another embodiment the interceptor transmits the intercepted DNS request to the appliance for DNS resolution. In one embodiment the appliance resolves the DNS request and communicates the DNS response to the client agent . In some embodiments the appliance resolves the DNS request via another appliance or a DNS server .

In yet another embodiment the client agent may include two agents and . In one embodiment a first agent may include an interceptor operating at the network layer of the network stack . In some embodiments the first agent intercepts network layer requests such as Internet Control Message Protocol ICMP requests e.g. ping and traceroute . In other embodiments the second agent may operate at the transport layer and intercept transport layer communications. In some embodiments the first agent intercepts communications at one layer of the network stack and interfaces with or communicates the intercepted communication to the second agent .

The client agent and or interceptor may operate at or interface with a protocol layer in a manner transparent to any other protocol layer of the network stack . For example in one embodiment the interceptor operates or interfaces with the transport layer of the network stack transparently to any protocol layer below the transport layer such as the network layer and any protocol layer above the transport layer such as the session presentation or application layer protocols. This allows the other protocol layers of the network stack to operate as desired and without modification for using the interceptor . As such the client agent and or interceptor interfaces with or operates at the level of the transport layer to secure optimize accelerate route or load balance any communications provided via any protocol carried by the transport layer such as any application layer protocol over TCP IP.

Furthermore the client agent and or interceptor may operate at or interface with the network stack in a manner transparent to any application a user of the client the client and or any other computing device such as a server or appliance in communications with the client . The client agent or any portion thereof may be installed and or executed on the client in a manner without modification of an application. In one embodiment the client agent or any portion thereof is installed and or executed in a manner transparent to any network configuration of the client appliance or server . In some embodiments the client agent or any portion thereof is installed and or executed with modification to any network configuration of the client appliance or server . In one embodiment the user of the client or a computing device in communications with the client are not aware of the existence execution or operation of the client agent or any portion thereof. As such in some embodiments the client agent and or interceptor is installed executed and or operated transparently to an application user of the client the client another computing device such as a server or appliance or any of the protocol layers above and or below the protocol layer interfaced to by the interceptor .

The client agent includes a streaming client a collection agent SSL VPN agent a network optimization engine and or acceleration program . In one embodiment the client agent is an Independent Computing Architecture ICA client or any portion thereof developed by Citrix Systems Inc. of Fort Lauderdale Fla. and is also referred to as an ICA client. In some embodiments the client agent has an application streaming client for streaming an application from a server to a client . In another embodiment the client agent includes a collection agent for performing end point detection scanning and collecting end point information for the appliance and or server . In some embodiments the client agent has one or more network accelerating or optimizing programs or agents such as a network optimization engine and an acceleration program . In one embodiment the acceleration program accelerates communications between client and server via appliance . In some embodiments the network optimization engine provides WAN optimization techniques as discussed herein.

The streaming client is an application program process service task or set of executable instructions for receiving and executing a streamed application from a server . A server may stream one or more application data files to the streaming client for playing executing or otherwise causing to be executed the application on the client . In some embodiments the server transmits a set of compressed or packaged application data files to the streaming client . In some embodiments the plurality of application files are compressed and stored on a file server within an archive file such as a CAB ZIP SIT TAR JAR or other archive. In one embodiment the server decompresses unpackages or unarchives the application files and transmits the files to the client . In another embodiment the client decompresses unpackages or unarchives the application files. The streaming client dynamically installs the application or portion thereof and executes the application. In one embodiment the streaming client may be an executable program. In some embodiments the streaming client may be able to launch another executable program.

The collection agent is an application program process service task or set of executable instructions for identifying obtaining and or collecting information about the client . In some embodiments the appliance transmits the collection agent to the client or client agent . The collection agent may be configured according to one or more policies of the policy engine of the appliance. In other embodiments the collection agent transmits collected information on the client to the appliance . In one embodiment the policy engine of the appliance uses the collected information to determine and provide access authentication and authorization control of the client s connection to a network .

In one embodiment the collection agent is an end point detection and scanning program which identifies and determines one or more attributes or characteristics of the client. For example the collection agent may identify and determine any one or more of the following client side attributes 1 the operating system an or a version of an operating system 2 a service pack of the operating system 3 a running service 4 a running process and 5 a file. The collection agent may also identify and determine the presence or version of any one or more of the following on the client 1 antivirus software 2 personal firewall software 3 anti spam software and 4 internet security software. The policy engine may have one or more policies based on any one or more of the attributes or characteristics of the client or client side attributes.

The SSL VPN agent is an application program process service task or set of executable instructions for establishing a Secure Socket Layer SSL virtual private network VPN connection from a first network to a second network or a SSL VPN connection from a client to a server . In one embodiment the SSL VPN agent establishes a SSL VPN connection from a public network to a private network or . In some embodiments the SSL VPN agent works in conjunction with appliance to provide the SSL VPN connection. In one embodiment the SSL VPN agent establishes a first transport layer connection with appliance . In some embodiment the appliance establishes a second transport layer connection with a server . In another embodiment the SSL VPN agent establishes a first transport layer connection with an application on the client and a second transport layer connection with the appliance . In other embodiments the SSL VPN agent works in conjunction with WAN optimization appliance to provide SSL VPN connectivity.

In some embodiments the acceleration program is a client side acceleration program for performing one or more acceleration techniques to accelerate enhance or otherwise improve a client s communications with and or access to a server such as accessing an application provided by a server . The logic functions and or operations of the executable instructions of the acceleration program may perform one or more of the following acceleration techniques 1 multi protocol compression 2 transport control protocol pooling 3 transport control protocol multiplexing 4 transport control protocol buffering and 5 caching via a cache manager. Additionally the acceleration program may perform encryption and or decryption of any communications received and or transmitted by the client . In some embodiments the acceleration program performs one or more of the acceleration techniques in an integrated manner or fashion. Additionally the acceleration program can perform compression on any of the protocols or multiple protocols carried as a payload of a network packet of the transport layer protocol.

In one embodiment the acceleration program is designed constructed or configured to work with appliance to provide LAN side acceleration or to provide acceleration techniques provided via appliance . For example in one embodiment of a NetScaler appliance manufactured by Citrix Systems Inc. the acceleration program includes a NetScaler client. In some embodiments the acceleration program provides NetScaler acceleration techniques stand alone in a remote device such as in a branch office. In other embodiments the acceleration program works in conjunction with one or more NetScaler appliances . In one embodiment the acceleration program provides LAN side or LAN based acceleration or optimization of network traffic.

In some embodiments the network optimization engine may be designed constructed or configured to work with WAN optimization appliance . In other embodiments network optimization engine may be designed constructed or configured to provide the WAN optimization techniques of appliance with or without an appliance . For example in one embodiment of a WANScaler appliance manufactured by Citrix Systems Inc. the network optimization engine includes the WANscaler client. In some embodiments the network optimization engine provides WANScaler acceleration techniques stand alone in a remote location such as a branch office. In other embodiments the network optimization engine works in conjunction with one or more WANScaler appliances .

In another embodiment the network optimization engine includes the acceleration program or the function operations and logic of the acceleration program . In some embodiments the acceleration program includes the network optimization engine or the function operations and logic of the network optimization engine . In yet another embodiment the network optimization engine is provided or installed as a separate program or set of executable instructions from the acceleration program . In other embodiments the network optimization engine and acceleration program are included in the same program or same set of executable instructions.

In some embodiments and still referring to a first program may be used to install and or execute the client agent or any portion thereof automatically silently transparently or otherwise. In one embodiment the first program is a plugin component such an ActiveX control or Java control or script that is loaded into and executed by an application. For example the first program comprises an ActiveX control loaded and run by a web browser application such as in the memory space or context of the application. In another embodiment the first program comprises a set of executable instructions loaded into and run by the application such as a browser. In one embodiment the first program is a designed and constructed program to install the client agent . In some embodiments the first program obtains downloads or receives the client agent via the network from another computing device. In another embodiment the first program is an installer program or a plug and play manager for installing programs such as network drivers and the client agent or any portion thereof on the operating system of the client .

In some embodiments each or any of the portions of the client agent a streaming client a collection agent SSL VPN agent a network optimization engine acceleration program and interceptor may be installed executed configured or operated as a separate application program process service task or set of executable instructions. In other embodiments each or any of the portions of the client agent may be installed executed configured or operated together as a single client agent .

Referring now to a block diagram of an embodiment of using a shared compression history to reduce the size of transmitted data is shown. In brief overview two clients and transmit data via two appliances and having compression histories and generally respectively and which communicate over a network . The compression histories and are used to compress data transmitted between the appliances and comprise portions of data previously transmitted between the two appliances . The appliance compresses the data transmitted via the network by identifying portions of data in a data stream sent by a client which have previously been transmitted between the two clients. The appliance then replaces those portions of data with a reference to a location in the compression histories reducing the volume of data transmitted while allowing the corresponding appliance to accurately reconstruct the original data stream. A client containing a network optimization engine may also use a compression history to accelerate communications with an appliance or second client having a compression history

Still referring to now in greater detail a client transmits a data stream to an appliance . The data stream may comprise any type of data sent over a network including any protocol. In some embodiments the data stream may be transmitted via a transport layer connection such as a TCP connection. In other embodiments the data stream may be transmitted via a session layer protocol such as SSL. In some embodiments some or all of the data stream may be encrypted.

In some embodiments one or more of the appliances may operate transparently to one or more of the clients . In other embodiments one or more of the appliances may operate as a transparent proxy for one or more of the clients . For example the appliances and may intercept and compress network traffic via a TCP connection between clients and transparently to one or both of the clients . In this example the client may send a TCP stream addressed to client which is intercepted by the appliances . The appliance may then compress the data stream and forward to client via appliance . Appliance after receiving the stream may then decompress and forward the data stream to client . In this way client and client are able to maintain their use of standard TCP protocols and addresses.

The appliances maintain synchronized compression histories each of which contain data previously transmitted between the appliances . These synchronized compression histories may also be referred to as shared compression histories. The compression histories may be synchronized by any means. In one embodiment the compression histories may be synchronized by means of the appliances intercepting and storing the same data streams to the compression histories . In another embodiment the appliances may transfer all or a portion of a compression history between themselves. In some embodiments the compression histories may be only imperfectly or partially synchronized. A compression history may reside on any storage medium including without limitation RAM and disks. In some embodiments a compression engine residing on an appliance may maintain a compression history .

A compression history may store any type and form of data including any previously transmitted data. In some embodiments an appliance may store all data that passes through the appliance to the compression history. In other embodiments an appliance may select portions of data from a data stream to be stored in the compression history based on any factor including without limitation the data stream source data stream destination transmission protocol application protocols available disk space current disk usage available memory space current available bandwidth and size of the data portions. In some embodiments the data stored in the compression history may be compressed using a lossless compression algorithm. In one embodiment a compression history may store data in chunks which will be discussed with reference to .

In some embodiments an appliance may store the payloads or any portions thereof of any protocol layer of packets passing transmitted via the appliance in the compression history. In one embodiment an appliance may store only the payload of TCP packets transmitted via the appliance in a compression history. In one embodiment the appliance stores application data obtained via an application layer protocol to the compression history . In some embodiments the appliance stores headers of the network packet such as application layer header of an HTTP payload to a compression history. In other embodiments the appliance does not store headers of the network packet. In another embodiment an appliance may store only the payload of a UDP packet transmitted via the appliance in a compression history. In one embodiment an appliance may elect not to store any encrypted data in the compression history. In another embodiment an appliance may decrypt encrypted data and store the decrypted data in a compression history. In still another embodiment an appliance may store encrypted data to a compression history.

A compression engine may store the compression history in storage such as disk memory such as RAM or a combination of storage and memory. In some embodiments the compression engine uses an object or data index to reference or identify corresponding objects or data stored in the compression history. A specific example of one embodiment of such an index is given in . In one embodiment a compression engine uses an object index stored in memory. In other embodiments a compression engine uses an object index stored to disk. An object index may comprise any type and form of indexing scheme for corresponding an index to an object in a compression history . In one embodiment an object index is maintained in memory while the corresponding object is stored a compression history . In some embodiments an object index comprises an entry that references or identifies a location or pointer to the object stored in the compression history . In some embodiments some or all of a compression history or an index may be stored in a cache . In other embodiments some or all of a cache may be stored using a compression history.

In writing a portion of transmitted data to the compression history an appliance may create a shared identifier to enable the appliance and an appliance receiving the transmitted data to refer to the portion of data in later communications. In one embodiment this identifier may be a unique identifier between the two appliances. In other embodiments this shared identifier may be a globally unique identifier among a plurality of appliances. The shared identifier may be created for example by tracking the number of bytes sent via a connection between the appliances and assigning successive identifiers to successive bytes transmitted.

In some embodiments a single appliance may maintain multiple compression histories. For example an appliance in communication with multiple other appliances may maintain a separate compression history containing the data transmitted to and from each appliance. In one embodiment these separate compression histories may be physically separate such as where separate disks are maintained for each compression history. In another embodiment these separate compression histories may be logically separate such as where multiple compression histories are intermingled on a single disk with identifiers or indices identifying which compression history or compression histories a given data portion belongs to.

In the embodiment shown the appliance used the compression history to identify portions of data in the data stream from the client which have previously been transmitted to the appliance . The appliance then replaces those portions of the data stream with identifiers identifying the locations of the compression history containing those portions before sending the data stream to appliance . For example the appliance may replace a sequence of 120 bytes with a reference to a memory location containing the sequence and an instruction to include 120 bytes from the referenced location.

Upon receiving the data stream containing a reference to a location in the compression history the appliance searches its compression history for the identified portion of data. The appliance then replaces the identifier in the data stream with the identified portion of data and sends the reconstructed data stream to the client

In these embodiments and subsequent embodiments discussed below the compression history and caching functions performed by the appliances may be performed by one or more of a client client agent or server . For example a client agent may maintain a compression history comprising portions of data previously transmitted to a server the server also maintain a corresponding compression history. The client agent and the server may then compress data sent between the server and a client on which the client agent resides by using the compression histories.

Referring now to a block diagram of one embodiment of a data structure used to store data in a compression history is shown. In brief overview a compression history comprises a plurality storage units referred to as chunks generally referred to as for storing data of a compression history. Each chunk comprises a header having a status identifier and a next chunk pointer . Each chunk also includes a section containing previously transmitted data .

Still referring to now in greater detail a compression history comprises a number of chunks . A chunk may refer to any discrete physical or logical storage element. Examples of a chunk may include a region of a disk multiple sequential regions of a disk and a memory location a series of consecutive memory locations. For example a 10 MB disk may be divided into 1 000 10 KB chunks where each chunk is a 10K logically contiguous region on the disk. Or for example two 10 MB disks may be divided into 20 000 1 KB chunks with one or more chunks crossing disks. In other embodiments a chunk may comprise non sequential areas of a disk or disks. For example a 2K chunk may be stored in 4 separate 512 byte pieces and a data structure may be maintained which identifies the locations of the separate pieces. In still other embodiments a chunk header may be stored in a different location than a chunk payload . For example one or more chunk headers may be maintained in memory while the chunk data may be maintained on a disk.

A chunk may be any size including without limitation 32 bytes 64 bytes 100 bytes 128 bytes 256 bytes 512 bytes 1K 2K 3K 4K 8K 10K 16K 32K 64K and 128K. In some embodiments some chunks may only be partially filled with data. For example in an embodiment where chunks have a fixed size of 5K a chunk may only include 2K of data in a case where the chunk held the last bytes of a given transmission.

In some embodiments a series of chunks may be stored sequentially on a disk or in memory. In other embodiments chunks may be stored in a plurality of locations on a disk or in memory. For example in one embodiment an appliance may store chunks which contain data transmitted to another appliance in a contiguous section of a disk. In another embodiment a compression engine on a client may store chunks with data transmitted to a first appliance interleaved on disk with chunks including data transmitted to a second appliance.

In some embodiments an appliance may create a new chunk for each new connection that is opened via the appliance. For example in an appliance serving as an intermediary for a plurality of TCP connections an appliance may create a new chunk each time a new TCP connection is opened and store the data from the TCP connection in the chunk. In this example the appliance may create additional chunks for a TCP connection if the initial chunk becomes full. In this embodiment the appliance may ensure that each chunk holds data from only one TCP connection. The appliance may store any information relating to the TCP connection including timestamps sequence numbers and source and destination addresses in one or more chunk headers.

In some embodiments a compression history may contain chunks of a uniform size. In other embodiments a compression history may contain chunks of varying sizes.

The compression history shown comprises a plurality of chunks . Each chunk contains a chunk header . A chunk header may comprise any identifying navigational or historical data relating to the chunk. Examples of data which may be stored in a chunk header include without limitation a chunk identifier a pointer to the next chunk in a sequence a pointer to a previous chunk in a sequence a size for the chunk a time the chunk was created a time the chunk was last accessed a total number of times the chunk has been accessed and a checksum or other error correcting measures.

In the embodiment shown the chunk includes a chunk identifier which may comprise a unique serial number assigned to the chunk. In one embodiment this unique serial number may correspond to a memory address of the chunk such as a starting address of the location of the chunk in memory or on a disk. In other embodiments the chunk identifier may correspond to a location within a sequence of transmitted data. For example in a compression history shared between two devices a chunk with serial number 4 500 000 may contain the 4 500 000byte transmitted between the two appliances and some number of subsequent bytes. The chunk identifier corresponding to a portion of transmitted data may be shared with the corresponding appliance either explicitly or implicitly. For example two appliances may use the above method such that a given portion of transmitted data will have the same chunk identifier on both appliances. In this manner the unique serial number refers to an identical portion of data residing on two or more appliances. In another example after a first appliance transmits a given number of bytes to a second appliance the first appliance may transmit a chunk identifier identifying the chunk in which the first appliance stored the transmitted data. The second appliance may then record the received chunk identifier in a table corresponding to the second appliance s chunk identifier assigned to the same data.

In one embodiment chunk identifiers may be globally unique among a plurality of appliances. For example in a set of appliances each with unique serial numbers an appliance may append the appliance s serial number to the beginning or end of a locally unique chunk identifier to create a globally unique chunk identifier. In another embodiment each device storing transmitted data to chunks on a disk may create a chunk identifier by appending the disk serial number to a chunk serial number. If the chunk serial numbers are never reused this technique may be used to create globally unique chunk identifiers. A device may then transmit to a recipient of the transmitted data the created chunk identifier so that a table of correspondences can be maintained on the receiving device.

In some embodiments some or all of the data included in the chunk header may be stored in a footer after the chunk. In still other embodiments some or all of the data contained in the chunk header may be stored in an external table or other data structure.

Referring now to a block diagram of one embodiment of a data structure which can be used to locate data portions in a compression history a compression index is shown. In brief overview a compression index contains a number of location identifiers arranged in a table. Each row of the table corresponds to a given data fingerprint. For example row of the table contains location identifiers for portions of data in the compression history that have a data fingerprint equal to 4. Each of the location identifiers points to a location in a compression history by identifying a location within a given chunk. In the embodiment shown the location identifiers identify a particular chunk and an offset within the chunk.

Still referring to now in greater detail a compression index includes a number of location identifiers arranged in an index where each row corresponds to a given data fingerprint. The index may be implemented using any data structure including arrays tables hash tables and linked lists binary trees red black trees and tries. The index may also be implemented using any technique for implementing a hash table. For example in one embodiment the index may be implemented as an array of linked lists where each linked list corresponds to a row of the index. In another embodiment the table may be implemented as a single two dimensional array. In this embodiment if a row of the array becomes full the least recently used location identifier in the row may be discarded. In still other embodiments the index may be implemented as a single array where hash collisions are resolved by placing location identifiers in array slots subsequent to a slot of the overloaded hash value. Throughout this specification the word entry may be also be used to indicate the portion of a compression index having location identifiers corresponding to a given fingerprint. Thus with respect to entry 8 stores location identifiers C x and C x where x represents any offset .

The location identifiers may comprise any identifier which allows the appliance to locate the corresponding portion of data in a compression history. In one embodiment a location identifier may comprise a chunk identifier and an offset. In another embodiment a location identifier may comprise a single address corresponding to a memory or disk location of the data portion. In still another embodiment a location identifier may comprise an address and a size indicator.

After determining a portion of a compression history matches a portion of an input stream an appliance may then perform a run length extension to determine a total length for the matching sequence. A run length extension may be performed by comparing successive bytes in the compression history to successive bytes of the input stream without the need for computing fingerprints. In some embodiments a run length extension may also compare previous bytes in the compression history to previous bytes in the input stream. For example if a 600 byte sequence of input data has been buffered by an appliance for later transmission and a match is found in a compression history with respect to the 140 145th bytes the appliance may compare previous and successive bytes in the compression history with previous and successive bytes of the input stream to identify the full extent of the compression history match. In some embodiments a run length extension may extend over a plurality of chunks. In these embodiments next chunk and previous chunk pointers contained within a given chunk may be used to identify successive and preceding areas of the compression history.

Referring now to a block diagram illustrating one embodiment of a method of using a compression index to locate compression history matches corresponding to input data is shown. In brief overview an appliance may intercept one or more data streams . The appliance organizes a data stream into a number of shingles and then computes a fingerprint for each shingle. For example the 10 character stream the quick is treated as ten four byte overlapping shingles. Each fingerprint then serves as an index into a compression index . For example the shingle the produces a fingerprint of 4 which corresponds to row of the compression index . This row has a number of location identifiers pointing to locations in a compression history including shingles which also have a fingerprint of 4.

Still referring to now in greater detail an appliance divides a data stream into a number of shingles. In the embodiment shown the data stream is the string the quick . The appliance breaks the string into 4 byte shingles. In other embodiments the shingles may be any other length including without limitation 3 5 6 7 8 10 12 16 32 or 64 bytes. In the embodiment shown the appliance creates overlapping shingles of 4 bytes for each successive byte in the data stream. In other embodiments shingles may be non overlapping. In still other embodiments an appliance may create shingles for only a subset of the bytes in a data stream. For example an appliance may create a shingle for every other byte in a data stream or every third byte in a data stream. In some embodiments the appliance may compute a fingerprint for a number of shingles in order to select the fingerprint which will be looked up in a compression index. This technique and other fingerprint techniques are described more fully in U.S. Pat. No. 7 098 815 Method and apparatus for efficient compression the entire contents of which are expressly incorporated by reference herein.

In the embodiment shown the appliance computes a fingerprint value for each shingle which is then used as an index into a compression index . In some embodiments the appliance may then access the data portion identified by a location identifier residing in the index. The appliance may then do a byte by byte comparison of the data portion in the compression history with the shingle to ensure that a match has been found. For example this comparison may be necessary if the fingerprinting method does not produce a unique fingerprint for every possible shingle or if multiple fingerprints are consolidated into a given row of the compression index . In one embodiment when a shingle is found to match a given portion of data in the compression history an appliance may then do a run length extension of the match to determine whether subsequent portions of the data in the compression history match subsequent portions of the received input stream.

In one embodiment an appliance may utilize a strategy of checking for a plurality of fingerprint matches before accessing a compression history to confirm a match is found. In this embodiment the appliance compares the location identifiers corresponding to subsequent shingles to see if the locations pointed to are subsequent sections of a single chunk. The appliance may do this strategy to establish some likelihood that a match of a given length actually exists and is not either a false positive from the fingerprinting algorithm or a match of such a small length as to not provide significant compression benefit. The strategy may result in performance improvements in cases where a compression history is stored on a disk and thus may have slower access times than the compression index which may be stored in memory. This strategy also may result in performance improvements in cases where a compression history is being heavily used by a plurality of connections by minimizing the number of times a disk or memory region is accessed.

Still referring to an appliance may compute a fingerprint for the first shingle the in the data stream . Upon checking the compression index for entries corresponding to the fingerprint the appliance finds a large number of entries perhaps as a result of large numbers of previously transmitted data containing the byte sequence the . The appliance may then compute a fingerprint for the next shingle he q and find only a single match identifying chunk and a given offset. The appliance may then compute a fingerprint for the next shingle e qu and find only a single match identifying chunk and an offset of 6. Since chunk and chunk do not represent sequential areas in the compression history there is a very low probability that either of these chunks will contain a match for anything other than the individual shingles. The appliance may thus determine to not access either of these portions of data in the compression history and instead send the data uncompressed or compressed using a compression mechanism other than a compression history.

With respect to data stream the appliance may determine that the location identifiers associated with the consecutive shingles brev revi evit and vity identify consecutive portions of the compression history namely they identify bytes and of chunk . This indicates a substantial likelihood that a long match exists for the data stream on chunk . The appliance may then determine to access that portion of the compression history and perform a run length extension to determine a total length for the matching sequence.

Referring now to a flow chart of one embodiment of a method of determining whether to perform disk based compression by identifying in an index maintained in memory an estimated extent of a match of input data to contiguous data stored on disk is above or below a predetermined threshold is shown. In brief overview a device having a compression history establishes an index in memory that corresponds fingerprints of a plurality of portions of data of the compression history to location identifiers identifying locations in a storage element having the plurality of portions of data step . The device identifies a number of fingerprints of input data match fingerprints of a plurality of entries of the index in memory step and determines from the number of identified fingerprints in memory having entries corresponding to a first location identifier that an estimated match of input data to contiguous data on disk is extendable below a predetermined threshold step . If the match is extendable below a given threshold the device transmits the data uncompressed step . If the match is extendable above the given threshold the device uses the compression history to compress the data step . Although the method may be discussed below in the context of being performed by an appliance the device may comprise a client server appliance or any other computing device .

Still referring to now in greater detail a device having a compression history stored establishes an index in memory that corresponds fingerprints of a plurality of portions of data of the compression history to location identifiers identifying locations in a storage element having the plurality of portions of data step . In one embodiment the index may comprise a compression index as described herein. The location identifiers may also comprise location identifiers as described herein. In one embodiment the locations on disk may correspond to chunks as described herein. The index may be established and maintained at any times. In one embodiment the index may be updated each time data is stored in a compression history. The storage element may comprise any means of storage including one or more of RAM disks and flash memory. In some embodiments the storage element may reside on the device. In other embodiments the storage element may be connected to the device via a network. In one embodiment the storage element may have a higher latency than the memory containing the index.

In the embodiment shown a device identifies a number of fingerprints of input data match fingerprints of a plurality of entries of the index in memory step . The input data may comprise input data from any source. In one embodiment the input data may comprise a data stream transmitted to the device from a client or server . In one embodiment the data stream may comprise data from a TCP connection for which the device is serving as a proxy. In another embodiment the input data may comprise data sent from an application running on the device.

The device may compute fingerprints of the input data using any fingerprinting method including without limitation a shingle method as described herein. The number of fingerprints may be any number 2 or greater including 2 3 4 5 6 7 8 9 and 10. For example an appliance may compute fingerprints for four successive shingles of a given data stream. In another embodiment an appliance may compute fingerprints for five proximate non overlapping shingles in the input data. In one embodiment the number of fingerprints may be predetermined in order to balance the drawbacks of potentially skipping over small matching segments against the benefits gained by fewer disk accesses.

In the embodiment shown the method then comprises determining by the device from the number of identified fingerprints in memory having entries corresponding to a first location identifier that an estimated match of input data to contiguous data on disk is extendable below a predetermined threshold step . In one embodiment this method may comprise identifying that one or more of the fingerprints correspond to entries in the index which contain null pointers or another indication that no match exists in the compression history for the fingerprint. In another embodiment this method may comprise identifying that two or more of the fingerprints correspond to entries containing location identifiers pointing to non contiguous locations of the compression history. For example with respect to the input stream the device may determine that the locations identified by the fingerprints and are not contiguous in the compression history. This indicates that the match in the compression history corresponding to the beginning of the input stream is no longer than 5 characters.

The predetermined threshold may comprise any number of bytes. In one embodiment the predetermined threshold may be 8 12 16 32 64 128 or 256 bytes. In some embodiments the predetermined threshold may be altered in response to operational characteristics of the device. In one embodiment the threshold may be increased in response to an increase in the number of connections passing through the device an increase in the amount of data passing through the device or an increase in a connection speed relating to the input data. In another embodiment the threshold may be decreased in response to a reduction in the number of connections a decrease in the amount of data passing through the device or a decrease in connection speed relating to the input data. For example in an appliance serving as a proxy compressing a number of TCP connections the appliance may increase the threshold in response to additional TCP connections being opened in order to minimize the occurrences of compression routines for two connections needing to simultaneously access a disk containing compression histories.

In the embodiment shown the method then comprises transmitting by the device the data uncompressed in response to a determination that the match is not extendable above a given threshold step . The device may then continue to compute fingerprints for subsequently received portions of input data to identify potential matches in the compression history. The uncompressed data may be transmitted to an appliance a client or any other device. In some embodiments the transmitted data may be compressed using a compression method other than the compression history. For example the data may then be compressed using run length compression or LZW compression. In one embodiment the data may be compressed using only portions of the compression history that are available in a faster storage element. For example a device may maintain recently accessed portions of the compression history in a cache. The device may choose to compress the data using only those portions which are available in cache.

If the match is extendable above a given threshold the device may use the compression history to compress the input data. Using the compression history may comprise any method of accessing referencing or otherwise leveraging the compression history to attempt to compress the input data. For example the device may access the compression history to determine whether portions of the compression history with fingerprints corresponding to the input data are byte for byte matches of the input data. Or the device may after accessing the compression history to confirm a match replace one or more portions of the input data with references to the compression history before retransmitting the input data.

A potential problem with using shingles as indexes into compression histories is that in some cases a given shingle may occur in a large number of transmitted files or data. This may impede the ability of a compression engine to find long continuous matches in a compression history for a given input stream. These long continuous matches may be desirable for reducing the amount of transmitted data as well as reducing the number of disk accesses if a compression history is stored on a disk. For example the shingle 

Referring now to a block diagram illustrating a second embodiment of using a compression index to locate compression history matches corresponding to input data is shown. In brief overview an input stream Call me Ishmael is processed into a number of shingles. A fingerprint is computed for each shingle and the corresponding row in the index is identified. The appliance then counts the number of location identifiers in each row to determine which row to select for the purposes of accessing the disk.

Still referring to an appliance or client agent or server agent computes fingerprints for a number of shingles before accessing a compression history. After receiving the input string Call me Ishmael the appliance computes fingerprints for each of the successive overlapping four byte shingles that make up the input string. The first shingle Call has a fingerprint value of 4 and the corresponding compression index entry has a plurality of location identifiers. This may indicate that a number of chunks on disk contain the character sequence Call. Rather than attempt to access one of these chunks the appliance then proceeds to compute fingerprints for a number of successive shingles of the input string. In the example shown the appliance computes fingerprints for the next 4 shingles. The appliance then counts the number of location identifiers in each index entry. In the example shown the shingle all has a fingerprint which matches one compression history location the single ll m has a fingerprint which matches three compression history locations the shingle l me has a fingerprint which matches two compression history locations and the shingle me has a fingerprint which matches more than three compression history locations. An observation may then be made that any long compression history match containing the input string must contain matches to each of the shingles. Thus if a long match exists in the compression history it must contain a match to the shingle all which only has one location identifier in the corresponding entry. The compression engine may deduce that this location identifier is the most likely to point to an area of the compression history containing a long match and access the compression history in the specified location. The compression engine may then perform a run length expansion of the match to determine a total length of the matching sequence.

The compression engine may determine the number of location identifiers in a compression index entry using any method. In one embodiment the compression engine may count the location identifiers in a given index entry by iterating over each location identifier. In another embodiment the compression engine may count the location identifiers by determining a total size of the compression index entry. In still another embodiment each entry of a compression index may store a count of the number of location identifiers contained within the entry.

Referring now to a flow diagram of one embodiment of a method for determining a precedence for matching fingerprints of input data to an index of fingerprints identifying a plurality of instances of data in a compression history is shown. In brief overview the method comprises a device having a compression history establishing an index that corresponds fingerprints of a plurality of portions of data of the compression history to location identifiers identifying locations an a storage element having the plurality of portions of data step . The device identifies that a plurality of fingerprints of input data match a plurality of entries in the index having at least one location identifier step and selects an entry of the plurality of entries having a fewest number of location identifiers step . The device may then match a first portion of the input data to data in a first location in the compression history identified by the selected entry step . The method may be performed by any device having a compression history including a client client agent server or server agent. Further this method may be performed in combination with any of the other compression history methods and systems described herein. For example this method may be performed in combination with the method described in conjunction with . In this example a compression engine might compute fingerprints for a number of shingles identify the shingles having the fewest location identifiers in the index and then check whether the location identifiers for those shingles pointed to sequential areas of the compression history.

Still referring to now in greater detail a device establishes any type and form of index for a compression history a step . In one embodiment the index may comprise a compression index . In another embodiment the device may use a network optimization engine and or compression engine to establish the index. The index can use any data fingerprinting method and the portions of data can be chosen using any method. In one embodiment the index may correspond fingerprints taken from a plurality of overlapping shingles to chunk identifiers and offsets. In another embodiment the index may correspond fingerprints taken from a plurality of overlapping shingles to memory addresses in a compression history. The data in the compression history may be received from any source. In one embodiment the data in the compression history may comprise data previously transmitted by the device. The storage element storing the compression history may comprise any means of storage including one or more of RAM disks and flash memory. In some embodiments the storage element may reside on the device. In other embodiments the storage element may be connected to the device via a network. In one embodiment the storage element may have a higher latency than the memory containing the index.

After establishing the index the device may identify that a plurality of fingerprints of input data match a plurality of entries in the index having at least one location identifier step . The device may compute fingerprints for any number and amount of input data. In one embodiment the device may compute fingerprints for four portions of input data. In another embodiment the device may compute fingerprints for two three five six seven eight nine ten or more portions of input data. In one embodiment the device may identify that a plurality of fingerprints each corresponding to a successive overlapping shingle of input data match a plurality of entries.

In some embodiments the device may compute fingerprints for a plurality of portions of input data before checking the index for corresponding location identifiers. In other embodiments the device may compute a fingerprint for a portion of data check the index for a corresponding location identifier and then if more than one location identifier is found the device may compute fingerprints for subsequent portions of data before accessing a compression history. For example the device may continue to compute fingerprints and count corresponding location identifiers until the device computes a fingerprint for which only one location identifier is in the corresponding index entry. The device may then select this entry step and access the location in the compression history identified by the one location identifier and determine a length of the match.

The device may select an entry of the plurality of entries having a fewest number of location identifiers step . In some cases the device may select an entry having only one location identifier. In other cases the device may select an entry having more than one location identifier but has the fewest number of location identifiers of the plurality. In these cases the device may choose a location identifier to access from the entry using any method including without limitation selecting a location identifier randomly or selecting a location identifier using the method described in .

After selecting an entry the device may match a first portion of the input data to data in a first location in the compression history identified by the selected entry step . This first portion may be the portion whose fingerprint corresponded to the selected entry. The matching may be performed by any method including without limitation byte by byte comparison a second fingerprinting process checksums and run length expansion.

If a match is found the device may then compress the input data by replacing the matching sequence of data with a reference to the matching portion of the compression history in the subsequent transmission. The device may then repeat any or all of the above steps with respect to subsequent input data.

As discussed previously many benefits may be associated with identifying and using longer compression history matches as opposed to shorter matches. Potential benefits include fewer compression history accesses improved compression ratios and lower processing overhead. Another way to increase the likelihood of generating longer compression history matches is to remove from compression history consideration input data which is unlikely to be repeated. One example of data that may be unlikely to repeat is application layer protocol headers which may include session numbers timestamps and other unique data. By removing these application layer headers from compression history data longer compression history matches may be obtained and compression history space may be conserved.

Referring now to a block diagram illustrating one embodiment of a technique for removing application layer protocol headers from data stored in a compression history is shown. In brief overview an application data stream is transmitted from a client to an appliance . The application data stream comprises a number of sequences of application data generally separated by application layer protocol headers generally . The appliance stores the portions of the application data in a contiguous region of a compression history .

Still referring to now in greater detail an appliance in other embodiments this could be a client agent server agent client or server receives an application data stream via any type and form of protocol. An application data stream may comprise any stream of application layer data. As used in B C D and the accompanying description the application layer may refer to the application layer or layer 7 of the OSI model or the application layer may refer to any layer above the transport layer in the OSI model. Examples of application data streams include without limitation HTTP communications Common Internet File System CIFS communications Network File System NFS communications ICA communications and File Transfer Protocol FTP communications. In one embodiment the appliance may be serving as a proxy or as a transparent proxy for a data stream containing the application data stream . For example the appliance may be serving as a transparent proxy for a TCP connection wherein the payloads of the TCP packets comprise an application data stream.

An application data stream may comprise a number of application layer protocol headers . Application layer protocol headers may comprise any sequence used by an application protocol to format delineate or carry information with respect to application data. Application layer protocol headers may occur anywhere within an application data stream and anywhere within an application data object. The term application layer protocol header equally encompasses footers trailers and mid object sequences. For example a file access application such as CIFS may transmit portions of files interspersed with headers which indicate the size and location of the file data transmitted with the headers. Application layer protocol headers may be delineated with special characters formatting and or application specific conventions. For example an application layer protocol header may contain a size field indicating the size of a following portion of application data . Following a sequence of application data of the specified size may be another application layer protocol header .

Application data may comprise any data other than the application layer protocol headers transmitted for use by an application. Examples of application data may include without limitation text documents files images objects video streams and audio streams. In one case application data may comprise a file which is being transmitted between two computing devices using FTP. In another case application data may comprise portions of a file being transmitted between two computing devices using CIFS. In a third case application data may comprise a file or data object to be used in a virtualized application. For example a remote user may be accessing a word processing application provided by a central server. The central server may provide access to the application by transmitting a number of data objects including without limitation executable portions of the application graphical data to be displayed to the user and one or more document files.

After receiving the application data stream the appliance may parse the application data stream to identify the application layer protocol headers and the application data . In one embodiment the appliance may identify application layer protocol headers by utilizing a parsing engine or a portion of a parsing engine tailored for a given application. For example an appliance may be programmed to specifically identify CIFS headers.

Once the application data and application layer protocol headers have been identified the appliance may then store the application data in a sequential area of a compression history. In some embodiments a sequential area of a compression history may comprise a physically contiguous region of memory. In other embodiments a sequential area of a compression history may comprise a sequential area of a single compression history chunk. In still other embodiments a sequential area of a compression history may comprise portions of a plurality of chunks that are logically sequential. For example the application data may be stored in a number of chunks each chunk containing a pointer to the next chunk in the sequence. Or for example the application data may be stored in a number of chunks scattered across a compression history with an external data structure indicating the sequence of chunks including the application data .

In one embodiment the appliance may not store the application layer protocol headers . In another embodiment the appliance may store the application layer protocol headers in a separate area of the compression history from the application data .

By storing the application data sequentially in the compression history the appliance may be able to achieve longer compression history matches if the identical application data is later transmitted via the appliance. Many application layer protocols utilize headers that may be unique to each transmission of application data. For example application layer protocol headers may include information specific to a sender or recipient of the application data or specific to a particular session in which application data is transmitted. By storing the application data sequentially and subsequently searching for compression history matches only with respect to the application data longer matches may be found.

Although in the embodiment shown the application data is stored in a sequential region of a compression history in other embodiments the application data may be stored in non sequential regions of a compression history.

Referring now to a block diagram illustrating a second embodiment of removing application layer protocol headers and from data stored in a compression history is shown. In brief overview an appliance receives an application data stream comprising a plurality of application data objects which have been multiplexed over the application data stream and are separated by application layer protocol headers . The appliance parses the application data stream to identify the application data objects and stores each application data object in a separate chunk of a compression history .

Still referring to now in greater detail an application data object may comprise any discrete unit of application data. Examples of an application data object include without limitation a document a file an image a video stream and an audio stream. For example an application may transmit a plurality of files via a single transport layer connection. Portions of the plurality of files may be interspersed with each other and separated by application layer protocol headers which identify the files. In another example a server may provide access to an application to a user. The server may transmit a number of objects comprising the application or objects used by the application over a single transport layer connection.

The appliance may use any information contained in the application data stream to identify the application data objects . In one embodiment the appliance may parse one or more application layer protocol headers to identify the application data objects. In the embodiment shown the appliance identifies that an application data object has been split into two parts for transmission. The appliance then stores the two parts in a separate sequential regions of the compression history. Although shows an appliance identifying two interspersed application data objects in other embodiments an appliance may identify any number of interspersed application data objects. Also although shows an appliance storing the application data objects in separate chunks in other embodiments the application data objects may be stored in the same chunk where the first object is stored in a first contiguous region of the chunk and the second application data object is stored in a second contiguous region of the chunk.

Storing application data objects in contiguous regions of a compression history may enable longer compression history to be found if the same application data object is again transmitted via the appliance. It may be unlikely that a given application data object is interspersed in the same way and between the same other application data objects as previously occurred. Thus while a given application data object may be transmitted many times via a given appliance a search for compression history matches based on the application data stream as transmitted may only yield matches as long as the application data object fragments and . By storing and parsing the application data objects as complete units an appliance may be able to improve the length of subsequent compression history matches.

Referring now to a flow diagram of one embodiment of a method for improving compression history matches by removing application layer protocol headers from compression history data is shown. In brief overview the method comprises transmitting between a first device and a second device an application data stream the application data stream comprising at least one application layer protocol header between a first sequence of application data and a second sequence of application data step . The first device identifies the first sequence and the second sequence from the application data stream step and stores a combined sequence comprising the first sequence and the third sequence to a compression history step .

Still referring to now in greater detail the method shown comprises transmitting between a first device and a second device an application data stream the application data stream comprising at least one application layer protocol header between a first sequence of application data and a second sequence of application data step . The first and second devices may be any computing device . In one embodiment the first and second devices may be appliances . In another embodiment one or more of the first and second devices may be a client server client agent or server agent. In one embodiment the first and second devices may be WAN optimization devices. In another embodiment the first and second devices may be serving as transparent proxies for a transport layer connection between a client and a server.

The first and second sequences of application data may comprise any sequences of application data. Examples of sequences of application data include sequential portions of a file data object image text or document being transferred. For example the first sequence of application data may comprise the first 5000 bytes of a portion of a file being transmitted via CIFS. The second sequence of application data may then comprise the next 5000 bytes of the file the first and second sequences separated by a CIFS header.

In some embodiments the first device may transmit a plurality of sequences of application data with an application layer protocol header in between each sequence of application data. For example two WAN optimization devices may be serving as transparent proxies for the connection between the client and server. The server may then transmit a 10 MB file to a client using NFS wherein the file is separated into 10 1 MB portions with each portion delineated by an NFS header.

The first device identifies the first sequence and the second sequence from the application data stream by any means step . In one embodiment the first device may parse one or more application layer protocol header. In another embodiment the first device may parse one or more sequences of application data. The first device may identify any number of sequences of application data separated by any number of application layer protocol headers. In some embodiments the second device may similarly identify the first and second sequences of application data so that the second device can synchronize its compression history with that of the first device. In other embodiments the first device may transmit explicit notifications to the second device identifying the first and second sequences of application data.

The first device may then store a combined sequence comprising the first sequence and the second sequence to a compression history step . The combined sequence may be stored to a logically or physically sequential region of the compression history. In other embodiments the combined sequence may comprise any number of sequences of application data. The second device may also store a combined sequence comprising the first sequence and the second sequence to a compression history.

For example two WAN optimization devices may be serving as transparent proxies for the connection between the client and server. The server may then transmit a 10 MB file to a client using NFS wherein the file is separated into 10 1 MB portions with each portion delineated by an NFS header. Each WAN optimization device may identify the portions of the file by parsing the NFS headers. Each WAN optimization device may then store the portions in a sequential region of their respective compression histories. In this manner the file as a whole may be represented in the compression histories without the intervening protocol headers. The appliances may then be able to achieve longer compression history matches in the event that the file is transmitted again between the two devices.

Now referring to a flow diagram of a second embodiment of a method for improving compression history matches by removing application layer protocol headers from received data is shown. In brief overview the method comprises receiving by a first device an application data stream the application data stream comprising at least one application layer protocol header between a first sequence of application data and a second sequence of application data step . The device identifies the first sequence and the second sequence from the application data stream step and determines that a combined sequence comprising the first sequence and second sequence matches a portion of a compression history step . The device then transmits to a second device information identifying the matched portion of the compression history step .

Still referring to now in greater detail the method comprises receiving by a first device an application data stream the application data stream comprising at least one application layer protocol header between a first sequence of application data and a second sequence of application data step . The first device may comprise any of a client server client agent server agent appliance WAN optimization appliance and transparent proxy. The first device may receive the application data stream from any of a client server client agent server agent appliance and WAN optimization appliance. In one embodiment the first device may comprise a WAN optimization appliance receiving an application data stream from a server. In another embodiment the first device may comprise a client agent receiving an application data stream from a client. The first device may be retransmitting some or all of the application data stream to a second device. In one embodiment the first device may be serving as a transparent proxy for a client or server from which the first device is receiving the data.

The first device may then identify the first sequence and the second sequence from the application data stream step . The first device may identify the first and second sequence using any technique described herein. In some embodiments the first device may delay retransmitting the application data stream while the first device is identifying the first and second sequence. For example upon receiving a CIFS stream a WAN optimization device may wait to retransmit the stream until the appliance identifies one or more sequences of a file being transmitted via the stream so that the appliance can check for matches of the one or more of the file sequences within a compression history.

The first device may then determine that a combined sequence comprising the first sequence and second sequence matches a portion of a compression history step . In some embodiments first device appliance may determine the match by using a fingerprinting method and or a compression index as a described herein. In other embodiments the first device may use run length extension to determine the match. For example upon finding a match to an initial part of the first sequence of data the first device may do a byte by byte comparison of the received application data stream with the matched portion of the compression history but omitting any application layer protocol headers from the byte by byte comparison. The matching portion of the compression history may have been stored using the method described with respect to .

The first device may then transmit to a second device information identifying the matched portion of the compression history step . In one embodiment information identifying the matched portion of the compression history may comprise a chunk identifier a chunk identifier plus an offset and or a memory address. The second device may then reconstruct the application data stream using a corresponding portion of a compression history.

As an example of the above method the first and second devices may be WAN optimization devices serving as proxies for a transport layer connection between a client and a server with the first device on the server side and the second device on the client side. The first WAN optimization device may receive a CIFS stream comprising a file spread out over a number of sequences separated by CIFS headers. The first device identifies that the file has been previously transmitted between the first and second devices by identifying the sequences of the file and using run length expansion to match the file sequences to a sequential area of the compression history of the first device. The first device may then transmit a chunk identifier to the second device identifying the matching portion of the compression history along with the CIFS headers. The second device may then access the portion of the compression history on the second device corresponding to the chunk identifier. The second device can then reconstruct the stream from the server by inserting the appropriate file sequences from the compression history of the second device between the CIFS headers received from the first appliance. The second device may then transmit the decompressed stream to the client.

This section describes techniques and devices for synchronizing compression histories shared between two devices. By maintaining a prioritized list of data portions in a compression history and then transmitting the number of data portions in the list to the other device two devices may maintain at least rough synchronization of compression history contents. This may result in the benefit of fewer instances where a device compresses data using a reference to a data portion not held by the recipient s compression history. This also may allow a device to more efficiently delete unusable or unlikely to be used data portions from a compression history.

Now referring to a method for synchronizing compression histories shared between two devices is shown. In brief overview the method comprises storing by a first device a first compression history the compression history comprising a plurality of portions of data previously transmitted to a second device each portion of data having a location identifier step . The first device may then create an ordered list of location identifiers ordered by a time the first device last accessed a portion of data in a location corresponding to each identifier step . The second device may then delete one or more portions of data and transmit the quantity of the remaining number of portions to the first device. The first device receives from the second device information identifying a quantity of location identifiers of a corresponding second compression history on the second device step and determines the received quantity is less than a quantity of location identifiers of the first compression history by a first amount step . The first device may then select for obsolescence from the list of location identifiers the first amount of location identifiers at an end of the ordered list corresponding to least recently accessed portions of data step . The first and second devices may comprise any of a client server client agent server agent appliance WAN optimization device and or transparent proxy.

Still referring to now in greater detail the method shown comprises storing by a first device a first compression history the compression history comprising a plurality of portions of data previously transmitted to a second device each portion of data having a location identifier step . This compression history may be created and stored by any method including all the method described herein. In one embodiment the portions of data may comprise chunks and the location identifiers may comprise chunk identifiers and or chunk identifiers and offsets. The creation of the first compression history may be synchronized with the creation of a second compression history on a second device.

The first device may then create an ordered list of location identifiers ordered by a time the first device last accessed a portion of data in a location corresponding to each identifier step . The ordered list may comprise any data structure which allows the representation of ordering including without limitation an array tree heap or linked list. The ordered list may be stored in any manner including on a disk in memory or in any combination. For example a long ordered list may be stored on a disk with active portions of the list being transferred into RAM.

In one embodiment the time last accessed of a given portion of a compression history may represent the time the portion was last used to compress a data stream. In another embodiment the time last accessed may represent the time the portion was created. In still another embodiment the time last accessed may represent the time the portion was last used to compress a data stream transmitted to a given device. In this embodiment a device may maintain a separate ordered list for each of a plurality of devices to which the device transmits compressed data. In some embodiments a device may also maintain a count of the number of location identifiers in a given ordered list.

In one embodiment a device may maintain the ordered list by moving a location identifier corresponding to a portion of the compression history to the front of the list each time the portion of the compression history is accessed. As the device creates a new portion of a compression history the device may also place the location identifier for the new portion at the front of the list. For example a device may initially create a compression history comprising data portions A B C D E F G H I and J. The ordered list may then be J I H G F E D C B A reflecting the order the portions were created with J being the most recent. If the device then receives and compresses data comprising data from portion F the device may reorder the list to F J I H G E D C B A. If the device then creates a new portion K the list may again be updated to K F J I H G E D C B A. If the device then receives and compresses data from portions C and D the list may again be updated to D C K F J I H G E B A.

The device may also maintain the ordered list by moving to the end of the list a location identifier corresponding to a data portion if the device receives an indication that the data portion is corrupt. The device may also move to the end of the list a location identifier corresponding to a data portion if the device receives an indication that the data portion is no longer stored in a corresponding compression history on the second device. For example the first device may attempt to compress a data stream by replacing a given data portion with a reference to an identical portion of data in the compression history. The first device may then receive an error message from the recipient indicating that the recipient does not have the data portion in its corresponding compression history possibly because it was deleted to make room for more recently transmitted data portions. The first device may then move the location identifier corresponding to the data portion to the end of its ordered list.

The first device may receive from the second device information identifying a quantity of location identifiers of a corresponding second compression history on the second device step . This information may be received by any means. In some embodiments the information may be received via a control protocol used between the first and second devices. In one embodiment the information may be received upon establishment and or termination of communications with the second device. For example upon establishing of communications between two WAN optimization devices each may transmit the total number of chunks in a compression history corresponding to the other device. In another embodiment the information may be encoded within another data stream transmitted between the two devices.

The first device may then determine the received quantity is less than a quantity of location identifiers of the first compression history by a first amount step . For example the first device may receive an indication that the second device has a total of 1546 chunks in its compression history corresponding to the first device. The first device may then identify that it has a total of 1613 chunks in its compression history corresponding to the second device. In this example the received quantity is less than the local quantity by 67 chunks. A discrepancy in chunk amounts may be caused by any factor including differences in available disk spaces corruption of one or more data portions or differing software versions.

The first device may then select for obsolescence from the list the first amount of location identifiers corresponding to the least recently used portions of data step . For example if the first device s ordered list of chunks was the list D C K F J I H G E B A from the example above and the first device received an indication that the second device only had 8 chunks in its corresponding compression history the first device may select the chunks E B and A for obsolescence.

In some embodiments the first device may then deactivate delete or otherwise remove the selected location identifiers from the ordered list. In one embodiment the first device may also then deactivate delete or otherwise remove the data portions corresponding to the selected location identifiers. In some embodiments the first device may deactivate a data portion from a compression history only with respect to a single device but keep the data portion active with respect to other devices.

The above method may also be coupled with a general policy of always deleting the least recently used compression history data portions when portions need to be deleted. For example a WAN optimization device located at a central office may be used to accelerate and compress communications with a number of WAN optimization devices located at branch offices. The WAN optimization device at the central office may run out of disk space for compression histories before any of the branch office devices since the central office device must maintain a compression history corresponding to each of the branch office devices. As the central office device transmits data to a branch office device A the central office device may be forced to delete a number of portions of data in one of its compression histories to make room for the new portions of data being written to the compression history. In some cases the central office device may delete portions from the compression history corresponding to device A. In other cases the central office device may delete portions from a compression history corresponding to a different branch office device. However the central device may choose to delete the least recently used portions of data from whichever compression history it chooses to delete portions from. Then at a later time the central device may transmit the total number of portions remaining in the compression history from which the portions were deleted. The device receiving the updated total number may then use the above method to delete the least recently used portions of data enabling the compression histories on the central and branch office devices to be at least approximately synchronized.

H. Systems and Methods for Leveraging Shared Compression Histories and Caches Across More than Two Devices

By transmitting portions of compression histories and or compression history indexes between devices the benefit of efficient compression of data previously transmitted can be extended beyond the two devices making the initial transmission. To use a simple example if device A transfers to device B a compression history corresponding to device C devices C and B can now communicate with the ability to compress data previously transmitted between C and A. The following section discusses systems and method for leveraging compression histories to provide compression between devices other than the original transmitters.

Referring now to a block diagram illustrating one embodiment of sharing compression histories among a plurality of devices is shown. In brief overview an appliance transmits data to an appliance across a low performance network . The appliance then receives a request for similar data from another appliance . As appliance receives the response to the request the appliance may detect a match with the data stored in the compression history that was transmitted to appliance . Appliance then sends an indication of the match to appliance . This indication may take the form of compressing the response according to the compression and using location identifiers which point to appliance . Appliance may then request the matched data from a compression history maintained by appliance . After appliance receives the requested data from appliance appliance may then decompress the data received from appliance and send it to the client

Still referring to now in greater detail a number of appliances communicate over a number of networks . In some embodiments the appliances may be WAN optimization devices and network may comprise a WAN. In other embodiments the appliances may be serving as transparent proxies for communications between a number of clients and a server . The server may be on a LAN with the appliance . The two appliances may be on a LAN with the one or more clients . In one embodiment the appliance and server may be located in a central office and the appliances and clients may be located in one or more branch offices. Although depicts appliances the systems and methods described with respect to may apply equally to clients client agents servers and server agents. For example one or more of appliances or may be replaced in by a client agent executing on a client.

In the embodiment shown the appliance transmits data from the server to the appliance . This data may be sent in the course of responding to a request from the client for the data from the server . Although depicts the data as being sent from a server the data may come from any other source including another appliance or a cache in appliance . As the data is being transmitted from the appliance to the appliance the two appliances may store copies of the data in their respective compression histories. In one embodiment the appliances may store a record along with the stored data indicating the appliance to which the data was transmitted. For example the data may be stored in a chunk in the compression history of appliance where the chunk contains an indicator that the data in the chunk was transmitted to appliance

Appliance may then receive a request from appliance for the server . The request may originate from a client . In another embodiment the request may originate from the same client as the previous data. This embodiment may be applicable where more than one WAN optimization device is used to provide access for a given branch office or set of clients. The appliance passes the request to the server . In other embodiments the appliance may pass the request to any other computing device or service the request using an internal cache.

As the appliance receives the response to the request from the server the appliance may detect one or more compression history matches corresponding to the received data. The appliance may detect these matches using any method including any of the fingerprinting and indexing methods described herein. The appliance may then determine that the matches correspond to data previously transmitted to appliance

The appliance may then begin transmitting the data stream received from the server to appliance compressed according to the compression history shared with appliance . In some embodiments the appliance may determine that network is sufficiently low performance with respect to network that transmission of the requested data to appliance will be faster if it is compressed using the compression history from appliance . In other embodiments the appliance may have no information about the performance of the networks but still transmit the indication to appliance in the hopes that the transmission will be improved. In either of these embodiments appliance may also begin transmitting the requested data to appliance in uncompressed form in case that appliance is unavailable or no longer has the requested data in its compression history.

Appliance after receiving the compressed data stream may then request the indicated portions of the compression history from appliance . In some cases appliance may request a number of subsequent compression history chunks.

After appliance receives the request for the matching portions of compression history appliance may then transmit the requested portions of data to the appliance . In one embodiment appliance may then store the received portions in compression history used to accelerate communications between appliance and appliance

In another embodiment rather than sending a compressed data stream directly to appliance appliance may transmit a request to appliance to serve as an intermediary for the connection between appliance and appliance . Appliance may then begin transmitting the requested data stream to using the previous compression history to accelerate the transmission. Appliance may then forward the data stream to appliance

Now referring to a flow diagram of one embodiment of a method for sharing compression histories among a plurality of devices to improve compression of data transmitted via a plurality of connections is shown. In brief overview a first device transmits to a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device step . The first device may receive from the third device an indication that a third device is located on the same network as the second device. The first device receives a second data stream intended for the third device step . The first device identifies that a portion of the data stream matches within a predetermined threshold a portion of the first compression history step and transmits to the third device information identifying the portion of the first compression history step . The first second and third devices may be any of a client server client agent server agent appliance WAN optimization device and or transparent proxy. In one embodiment this method may reflect steps performed by the appliance in .

Still referring to now in greater detail the method comprises transmitting between a first device and a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device step . In one embodiment the data stream may be transmitted from the first appliance to the second appliance. In another embodiment the data stream may be transmitted from the second appliance to the first appliance. The data stream is compressed according to a compression history shared by the first and second devices. This compression may be performed by any manner including any described herein and the compression history may comprise any compression history including any compression history described herein. In one embodiment the shared compression history may already contain one or more data portions contained in the first data stream. In some cases the data may transmitted uncompressed if no matches are found for the data in the shared compression history. The shared compression history may be updated to include one or more data portions contained in the first data stream not already in the first compression history.

The first device may receive an indication that a third device is on the same network as the second device in any manner step . The first device may receive the indication from any source. In some embodiments the first device may receive the indication from the second or third device. In other embodiments the first device may receive the indication from another device. In still other embodiments the first device may be manually configured with the indication.

In one embodiment upon establishing a connection between two devices each device may send the other information identifying one or more other devices on the same network. For example on startup an appliance may automatically discover using any network techniques other appliances residing on a LAN or otherwise clustered with the appliance. Each appliance may on startup identify the other appliances located in the same cluster.

In one embodiment appliances in the same cluster may exchange information identifying a range of chunk identifiers corresponding to compression history portions held by each device. In another embodiment appliances in a cluster may exchange information identifying the disks held by each appliance. In this manner each appliance in a cluster may be able to identify whether a given location identifier or chunk identifier corresponds to a compression history located on another appliance in the cluster. For example in the case where chunk identifiers are created by appending a serial number to a globally unique disk identifier each appliance may send to other appliances in a cluster the identifier for each disk of the appliance and a range specifying valid serial numbers for each disk identifier. In this manner when an appliance in a cluster receives a chunk identifier the appliance may be able to check the disk identifier contained within the chunk identifier to determine whether the disk is held by an appliance in the cluster.

After this discovery step when the appliance establishes a connection with any other appliance or client agent the appliance may transmit a list of the appliances locally clustered with the appliance. The appliance may also receive upon establishing the connection a list of appliances or client agents on a LAN or otherwise clustered with the connection recipient. In this manner each appliance or client agent in communication with another appliance or client agent may know the identities of any other appliances or client agents local to the other appliance or client agent. In other embodiments any or all of this discovery of clustered devices may be accomplished via manual configuration.

To give a detailed example a central office may use a cluster of WAN optimization appliances to communicate with a number of branch offices each branch office also having a cluster of WAN optimization devices. When an appliance from the central office establishes a connection with an appliance at a branch office the central office appliance may transmit to the branch office appliance information identifying the other appliances located in the central office cluster. The branch office appliance may also transmit to the central office appliance information identifying the other appliances located in the branch office cluster. Along with this identifying information the appliances may exchange any other information relating to other appliances in their respective clusters including IP addresses capacity performance disk identifiers and configuration information.

The method shown then comprises receiving by a first device a data stream intended for the third device step . The first device may receive the data stream from any source including a client server or client agent . In one embodiment the data stream may comprise a response from a server to a client request. For example the first device may be serving as a transparent proxy to a TCP connection between a client and a server and the data stream may comprise a response to an HTTP request by the client. Or for example the data stream may comprise an ICA stream from an application server to a client agent.

The first device then identifies that a portion of the data stream matches a portion of the first compression history step . The first device may identify the matching using any technique including any of the fingerprinting and indexing techniques described herein. In one embodiment the first device may identify that one or more shingles of the data stream match portions of chunks stored in the first compression history. For example a chunk comprising the matched portion may have a header indicating that the data was sent to the second device. Or for example a compression index entry may indicate that the matching portion of data was transmitted to the second device. After determining that the matched portion of data is held by a compression history not shared with the intended recipient the first device may determine that the matched portion of data is held by a compression history shared with an appliance or other device in a cluster with the intended recipient.

In one embodiment the first device may determine that a portion of the data stream matches within a predetermined threshold a portion of the first compression history. The predetermined threshold may comprise any amount percentage or distribution of data. In one embodiment the predetermined threshold may comprise a minimum number of bytes. For example the first device may identify that at least 64 bytes of the data stream matches a portion of the first compression history. A minimum number of bytes may be any number of bytes including 4 8 16 32 64 128 256 512 1024 2048 and 3072 bytes. In some embodiments the predetermined threshold may require that a minimum number of matching bytes be sequential. In other embodiments the predetermined threshold may require that a minimum number of matching bytes be found at a given distribution throughout the data stream. For example a predetermined threshold might require that at least 50 out of three consecutive 100 byte sequences match. Or a predetermined threshold might require that at least three different matching sequences of at least 64 bytes be found. In some embodiments the predetermined threshold may require that the matching portions of the compression history are sequential. For example the predetermined threshold may require that a sequence of at least 128 bytes matches a consecutive sequence of 128 bytes in the first compression history. In some embodiments the first device may use a technique such as the ones described with respect to to efficiently determine the existence of any long sequential matches. In still other embodiments the predetermined threshold may require that a certain percentage of the data stream matches data in the first compression history. For example the predetermined threshold may require that 85 of a first number of bytes of the data stream match the first compression history.

In one embodiment the predetermined threshold may be set automatically by the first device. In other embodiments the predetermined threshold may be manually configured. In some embodiments the predetermined threshold may be calibrated to take into account the potential overhead of using compression history chunks not held by the destination device but rather the result of a successful transfer of compression history data. For example the predetermined threshold may be lowered in response to slower performance of the network . Or the predetermined threshold may be raised as the performance of the network connecting the first device to the second and third devices becomes faster. In another example the predetermined threshold may be lower if the bandwidth of the connection between the first and third devices is substantially lower than the bandwidth of the connection between the second and third devices. In some embodiments the predetermined threshold may comprise the same threshold for compression using a compression history shared with the intended recipient of the data stream. In other embodiments the predetermined threshold may be higher for cases in which the matching portion or portions are not held by the intended recipient but instead held by a device clustered with the intended recipient of the data stream.

The first device may then transmit to the third device information identifying the matching portion of the first compression history step . In one embodiment this step may comprise transmitting the data stream to the third device compressed according to the matching portions of the first compression history. The first device may perform this compression according to the matching portions of the first compression history in any manner. In one embodiment the first device may replace portions of the data stream with location identifiers identifying the matching portions of the first compression history. In this embodiment the first device may also compress the data stream using any other techniques including without limitation additionally compressing the data stream according to a second compression history shared between the first device and third device. In one embodiment this step may comprise transmitting one or more chunk identifiers to the third device. In another embodiment this step may comprise transmitting one or more location identifiers to the third device. In one embodiment the first device may also transmit information identifying the second device.

In one embodiment the first device may also include location identifiers of one or more portions of the first compression history that are subsequent to the identified matching portions. The first device may include these portions based on a speculation that the subsequent portions will also match subsequent portions of the second data stream. In some embodiments the number of subsequent portions the first device identifies may be determined by the quality or quantity of the found matches.

After the third device receives the data stream compressed according to the first compression history the third device may transmit to the second device a request for the identified portions of the first compression history. These portions may then be transmitted from the second device to the third device using any means and any protocol. In some embodiments the third device may then signal to the first device that it has received one or more portions of the compression history. In other embodiments the third device may transmit an indication to the first device that the identified portions of the compression history cannot be obtained which may occur if the second device is inoperable or busy. In these cases the first device may then retransmit the data stream to the third device without compressing it according to the first compression history.

Referring now to a flow diagram of a second embodiment of a method for sharing compression histories among a plurality of devices to improve compression of data transmitted via a plurality of connections is shown. In brief overview the method comprises transmitting between a first device and a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device step . The first device receives information identifying a third device and a portion of the first compression history step and transmits to the third device the identified portion of the first compression history step . The first second and third devices may be any of a client server client agent server agent appliance WAN optimization device and or transparent proxy. In one embodiment this method may reflect steps performed by the appliance in .

Still referring to now in greater detail the method comprises transmitting between a first device and a second device a first data stream the first data stream compressed according to a first compression history shared between the first device and the second device step . This step may correspond to step of the previous method and may be performed according to any of the embodiments discussed herein. The first device may be either the sender or the recipient of the first data stream.

The first device may then receive from a third device information identifying a portion of the first compression history step . In some embodiments the received information may comprise any of the information transmitted according to step of the previously discussed method. In one embodiment the information may also comprise a request to transmit the identified portion to the third device. In another embodiment the information may identify a plurality of portions of the first compression history to transmit to the third device. In another embodiment the first device may receive a number of chunk identifiers. In still another embodiment the first device may receive a location identifier and a byte count indicating a number of bytes following the location identifier to transmit to the third device.

In some embodiments the first device may receive a plurality of transmissions from the third device with information identifying a third device and a portion of the first compression history. For example the second device may be transmitting a long data stream to the third device and continually be identifying portions of the data stream which match portions of the first compression history and compressing the stream accordingly. As the third device receives each location identifier in the place of data from the data stream the third device may request the identified portion or portions of the first compression history from the first device. The third device may then reconstruct the data stream using the requested portions of the first compression history.

The second device may then transmit to the third device the identified portions of the first compression history step . The second device may transmit these portions of the first compression history using any protocol or protocols. In some embodiments the second device may transmit a plurality of identified portions at once. In other embodiments the second device may transmit a plurality of identified portions in a sequence.

Referring now to a flow diagram of a third embodiment of a method for sharing compression histories among a plurality of devices to improve compression of data transmitted via a plurality of connections is shown. In brief overview the method comprises a first device receiving by a first device from a second device a data stream the data stream compressed according to a compression history shared between the first device and a third device step . The first device identifies the third device step and transmits to the third device a request for a portion of the compression history step . The first device receives from the third device the requested portion of the compression history step . The first device may then decompress the data stream step and transmit the decompressed stream to the client step . The first second and third devices may be any of a client server client agent server agent appliance WAN optimization device and or transparent proxy. In one embodiment this method may reflect steps performed by the appliance in .

Still referring to now in greater detail a first device receives from a second device a data stream the data stream compressed according to a compression history shared between the first device and a third device step . This step may be performed according to any embodiment described herein. In some embodiments this step may correspond to receiving a compressed data stream transmitted according to step of the method in . In one embodiment the first device may receive a data stream comprising a number of location identifiers where the location identifiers identify portions of data to be inserted into the data stream.

The first device may identify the third device in any manner step . In one embodiment the third device may be on a LAN or otherwise clustered with the first device. The first device may use any of the discovery techniques and clustering techniques described herein to identify the third device. In some embodiments the first device may identify the third device by determining a disk identifier included in a chunk identifier in the data stream corresponds to a disk held by the third device. In another embodiment the first device may determine that a location identifier contained in the data stream falls within a range of location identifiers advertised by the third device.

The first device may then transmit to the third device a request for a portion of the compression history step . The request may be transmitted via any protocol or protocols. In some embodiments the request may request a plurality of portions of the compression history. In some embodiments the first device may transmit a separate request for each of a number of identifiers received in the data stream. In another embodiment the first device may include more than one identifier in a single request. In some embodiments the first device may request one or more portions of the compression history subsequent to the identified portions. For example if the first device receives a data stream comprising a chunk identifier identifying a chunk held by the third device the first device may transmit to the third device a request for the identified chunk as well as one or more subsequent chunks. This may be based on a likelihood that subsequent matches will occur and include the subsequent chunks. Or for example if the first device receives a data stream comprising a location identifier identifying 212 bytes of a chunk held by the third device the first device may transmit to the third device a request for the identified bytes as well as a number of subsequent bytes from the chunk. The number of subsequent bytes requested may be determined in any manner including without limitation based on a number or length of previous matches.

The first device may then receive from a third device the requested portion of the compression history step . The portion may be received via any protocol or protocols. In one embodiment the portion may be received as a result of the third device performing step of the previously described method. In some embodiments the first device may receive a plurality of portions of the compression history. In some embodiments the first device may receive entire chunks of the compression history. For example in response to a request for 514 bytes of a chunk the first appliance may receive the entire chunk containing the requested bytes. In other embodiments the first device may receive a portion of a chunk. The first device may also receive any additional information with the requested portion of the compression history including without limitation any information contained in a chunk header or compression index corresponding to the requested portion.

In some embodiments after receiving the requested portion of the compression history the first device may then insert the portion of the second compression history into one or more compression histories on the first device step . This insertion may be done by any means. In some embodiments this step may comprise incorporating one or more chunks received from the third device into the a compression history shared with the second device. In one embodiment the insertion may be done temporarily and the chunks may be removed or deactivated after completion of their use. In another embodiment the insertion may be such that the portions are incorporated into the first compression history as though they had been created in the normal course of transmitting data to or from the second device.

In some embodiments the first device may transmit an indication to the second device upon successfully receiving the portion from the third device. This indication may serve to notify the second device that it may begin or continue compressing the second data stream according to the portions of the second compression. In some embodiments the first device may transmit an indication to the second device if the requested portions were not received from the third device. This indication may server to instruct the second device to not use portions of data from the compression history to compress the data stream. The second device may also in response to the indication retransmit one or more portions of the data stream.

After receiving the requested portion of the compression history the first device may decompress the received data stream step . This decompression may be done in any manner. In one embodiment the first device may replace a number of location identifiers with portions of data identified by the location identifiers. The first device may use any number of decompression methods. For example the first device may first decompress the data stream using a run length decompression method and then decompress the data stream further by using the received portions of compression history data. In some embodiments the first device may also use portions of data from a locally stored compression history to decompress the data stream.

After decompressing the data stream the first device may transmit the data stream to a client step . In other embodiments the first device may transmit the data stream to any other device including a client server or appliance.

In some embodiments the method described can be applied continuously over the course of servicing one or more requests. For example a client at a branch office may be accessing a number of applications from an application server at a central office using ICA. The branch office and central office may each have clusters of WAN optimization appliances . The ICA connection may be proxied through a first central office appliance and a first branch office appliance. As data from the application server is transmitted through the central office WAN appliance the central office appliance may determine that portions of the data have previously been sent to a second branch office WAN optimization appliance in the cluster with the first branch office appliance. The central office appliance may compress the data as it is passing through using references to the compression history portions shared with the second branch office device. As each reference in the compressed data stream is received by the first branch office appliance it may send a request for the referenced data. As each piece of referenced data is received the first branch office appliance may use the received data to reconstruct a potion data stream and forward the portion of the reconstructed data stream to the client.

Now referring to a block diagram of one embodiment of a system for sharing compression history indexes to accelerate data transmission between two groups of devices is shown. In brief overview a first data stream is transmitted between appliance and appliance each appliance storing portions of the data stream in their respective compression histories. Appliance then shares a compression index containing entries corresponding to the transmitted first data stream with appliance . Appliance in the course of transmitting a second data stream to appliance may identify one or more matches corresponding to the index received from appliance . Appliance may then take steps to leverage the existing compression histories on appliance and to accelerate the transmission. In the embodiment shown the appliance requests the corresponding portions of the compression history from appliance and sends an indication of the match to appliance by compressing the second data stream using references to the compression history shared by appliances and . Appliance upon receiving the compressed stream may then request the corresponding portions of the compression history from appliance to decompress the data stream.

Still referring to now in greater detail a number of appliances communicate over a number of networks . In some embodiments the appliances may be WAN optimization devices and network may comprise a WAN. In other embodiments the appliances may be serving as transparent proxies for communications between a number of clients and a server . The server may be on a LAN with the appliance . The two appliances may be on a LAN with the one or more clients . In one embodiment the appliances and server may be located in a central office and the appliances and clients may be located in one or more branch offices. Although depicts appliances the systems and methods described with respect to may apply equally to clients client agents servers and server agents.

In the embodiment shown appliance sends data from server to the appliance . In some cases this may be a file or other data requested from the server by the client . In these cases the appliances may be serving as transparent proxies for the communication. As the data is transmitted the appliances may be storing data from the transmission in their respective compression histories and storing information relating to the data in a compression index.

The appliance may then transmit some or all of its compression index to the appliance . Appliance may also transmit some or all of its compression index to appliance . In some embodiments the appliances may be part of an appliance cluster containing two or more devices all of which transmit portions of their compression indexes to each other. The appliances may be clustered in any way and may discover each other using any technique. In this way any appliance in the cluster may be able to determine if a data stream the appliance is transmitting contains a number of matches to a data stream previously transmitted by any of the other appliances in the cluster. Devices in a cluster may exchange compression indexes using any method. In some embodiments devices may periodically transmit updates of their compression history indexes to other devices in the cluster. In other embodiments devices may transmit portions of their compression history to other devices in cluster upon startup or upon detecting a new device in the cluster. In some embodiments devices may transmit only a portion of a compression history index to another device in a cluster. In other embodiments devices may only transmit entries of a compression index corresponding to frequently or recently used portions of a compression history.

After receiving the compression index from appliance appliance may integrate the received compression index with one or more compression indexes maintained by appliance . In some embodiments the appliance may mark the index entries received from appliance to indicate that the index entries correspond to appliance

Sharing compression history indexes among a cluster of devices may be useful in situations where a cluster of appliances is providing acceleration to a server and in those situations where the same appliance does not always provide acceleration for the same server in the set. In some ways the system in and the method shown in may be a variation of the systems and methods shown in .

Appliance may then receive a data stream from a server destined for client via appliance . Appliance may determine that one or more portions of this data stream match portions of the compression index received from appliance . After identifying the matched portions appliance may send a request for the matching portions to appliance . Appliance may respond by transmitting the requested portions along with information identifying the appliance which may also have the requested portions of data.

After receiving the matching portions from appliance appliance may determine whether the portions actually match the data stream. This may be necessary in cases where the compression index only comprises fingerprints of data and thus byte by byte comparison of the received portions with the data stream may be necessary to confirm a match. Once a match is confirmed appliance may send an indication of the match to appliance and replace one or more portions of the data stream with references to the matched portions of compression history. Appliance may then request the matching portions of data from appliance . Appliance having similarly received corresponding portions of the compression history from appliance may then decompress the data stream and transmit the data stream to the client

Referring now to a flow diagram of a method for sharing compression indexes among a plurality of devices to improve compression of data transmitted via a plurality of connections is shown. In brief overview the method comprises receiving by a first device from a second device an index of entries for a compression history shared between the second device and a third device each index entry comprising a location identifier of data stored in the second device step . The first device receives a data stream intended for a fourth device step and identifies that a portion of the data stream matches an entry of the received index step . The first device transmits to the second device a location identifier corresponding to the matched entry step . The first device receives from the second device a portion of the compression history corresponding to the location identifier step and determines the portion of the compression history matches a portion of the data stream step . The first device may then transmit to the fourth device information identifying the portion of the compression history step . The first second third and fourth devices may be any of a client server client agent server agent appliance WAN optimization device and or transparent proxy. In one embodiment this method may reflect steps performed by the appliances in wherein the first device is the appliance the second device is the appliance the third device is the appliance and the fourth device is the appliance

Still referring to now in greater detail the method comprises receiving by a first device from a second device an index of entries for a compression history shared between the second device and a third device each index entry comprising a location identifier of data stored in the second device step The received index may comprise any type of index for the first compression history. In one embodiment the index may comprise a compression index . The received index may comprise the entirety of the index for the first compression history or the received index may comprise only a portion of the index for the first compression history. In some embodiments the index may comprise a specifically selected portion of the index for the first compression history. In other embodiments the index may comprise entries from a plurality of compression histories. In some embodiments the first device may receive the index of entries after detecting that the second device is in a cluster with the first device. In other embodiments the first device may periodically receive a number of index entries from the second device. The first device may also receive any other information from the second device including a range of valid location identifiers and or one or more disk identifiers of disks operated by the second device.

In some embodiments the received index entries may be integrated into an existing compression index on the first device. For example the received index may have been created using a same fingerprint method used by the third device and the entry numbers may correspond to entry numbers in a compression index of the third device. In one embodiment the third device may mark or otherwise note the entries that have been received from the first device. In another embodiment the location identifiers within the received index entries may point to locations known to be on the first device.

In some embodiments each device in a group of devices may periodically transmit updated compression indexes to the other devices in the group. In this way a cluster of devices may be created in which all essentially or partially share the same compression index. This may allow any individual device to leverage previous transmissions of data by any of the other devices to accelerate future communications. For example a group of devices may provide WAN optimization services for a central office to a number of branch offices. Each device in the central office may periodically transmit some or all of its compression index to the other central office devices. In this way each device at the central office may be able to leverage previous transmissions to a branch office to compress future transmissions to the branch office even if the previous transmission was from a different central office device and to a different branch office device or client.

The first device may then receive a data stream intended for a fourth device step . The first device may receive the data stream from any source including a client server or client agent . In one embodiment the data stream may comprise a response from a server to a client request. For example the first device may be serving as a transparent proxy to a TCP connection between a client and a server and the data stream may comprise a response to an HTTP request by the client. Or for example the data stream may comprise an ICA stream from an application server to a client agent.

The first device may identify that a portion of the data stream matches an entry of the received index step . In some embodiments the first device may identify that a portion of the data stream matches an entry of the received index before any data is transmitted to the fourth device. In other embodiments the third device may identify that a portion of the data stream matches an entry of the received index after some data has already been transmitted to the fourth device. The first device may identify the matching using any technique including any of the fingerprinting and indexing techniques described herein. In one embodiment the first device may identify that one or more shingles of the data stream have fingerprints corresponding to an entry in the received index.

In some embodiments the first device may identify that a portion of the second data stream matches within a predetermined threshold a portion of the received index. The predetermined threshold may comprise any amount percentage or distribution of data. In one embodiment the predetermined threshold may comprise a minimum number of bytes. For example the third device may identify that at least 64 bytes of the second data stream matches entries in the received index. A minimum number of bytes may be any number of bytes including 4 8 16 32 64 128 256 512 1024 2048 and 3072 bytes. In some embodiments the predetermined threshold may require that a minimum number of matching bytes be sequential. In other embodiments the predetermined threshold may require that a minimum number of matching bytes be found at a given distribution throughout the second data stream. For example a predetermined threshold might require that at least 50 matching byte sequences be found in at least three different locations in the second data stream. Or a predetermined threshold might require that at least three different matching sequences of at least 64 bytes be found. In some embodiments the predetermined threshold may require that the matching index entries have location identifiers corresponding to sequential portions of the first compression history. For example the predetermined threshold may require that a sequence of at least 128 bytes matches index entries identifying a consecutive sequence of 128 bytes in the first compression history. In some embodiments the third device may use a technique such as the ones described with respect to to efficiently determine the existence of any long sequential matches. In still other embodiments the predetermined threshold may require that a certain percentage of the second data stream matches received index entries. For example the predetermined threshold may require that 85 of a first number of bytes of the second data stream match received index entries.

The predetermined threshold may be set either automatically by the first device or manually configured. In some embodiments the predetermined threshold may be calibrated to balance the overhead of contacting the first device and subsequently transferring portions of a compression history against the potential increased in transmission speed as the result of a successful transfer of compression history data. For example the predetermined threshold may be lowered in response to slower performance of the network . Or the predetermined threshold may be raised as the performance of the network becomes faster. In another example the predetermined threshold may be lower if the bandwidth of the connection between the first and third devices is substantially higher than the bandwidth of the connection between the third and fourth devices.

After identifying a match the first device may transmit to the second device a location identifier corresponding to the matched entry step . In one embodiment the first device may transmit one or more chunk identifiers to the second device. In another embodiment the first device may transmit a plurality of location and or chunk identifiers to the second device. These portions may then be transmitted from the second device to the first device using any means and any protocol. In some embodiments the first device may then signal to the first device that it has successfully received the requested one or more portions of the compression history.

In one embodiment the first device may transmit a request for the second device to send the identified portion of the first compression history to the first device. The request may be transmitted via any protocol or protocols. In some embodiments the request may request a plurality of portions of the compression history. In some embodiments the first device may transmit a separate request for each of a number of identifiers received in the data stream. In another embodiment the first device may include more than one identifier in a single request. In some embodiments the first device may request one or more portions of the compression history subsequent to the identified portions. For example if the first device receives a data stream comprising a portion of data matching an index entry received from the second device the first device may transmit to the second device a request for an identified chunk as well as one or more subsequent chunks. This may be based on a likelihood that subsequent matches will occur and include the subsequent chunks. Or for example if 212 bytes of a data stream match an index entry identifying a chunk held by the second device the first device may transmit to the second device a request for the identified bytes as well as a number of subsequent bytes from the chunk. The number of subsequent bytes requested may be determined in any manner including without limitation based on a number or length of previous matches.

The first device may receive from the second device a portion of the compression history corresponding to the location identifier in any manner step . The portion may be received via any protocol or protocols. In some embodiments the first device may receive a plurality of portions of the compression history. In some embodiments the first device may receive entire chunks of the compression history. For example in response to a request for 514 bytes of a chunk the first appliance may receive the entire chunk containing the requested bytes. In other embodiments the first device may receive a portion of a chunk. The first device may also receive any additional information with the requested portion of the compression history including without limitation any information contained in a chunk header or compression index corresponding to the requested portion. In some embodiments the first device may receive information identifying other devices which also may have the chunk. In these embodiments the first device may then determine whether one of the other devices having the chunk is located in a cluster or otherwise local to the fourth device.

The first device may then determine the portion of the compression history matches a portion of the data stream step . This step may be used in embodiments where the an index match does not guarantee that data in the compression history will also match. For example if the index is implemented using a non unique fingerprinting method two distinct shingles may have the same fingerprint. A comparison to the referenced data portion in the compression history may be needed to verify that a match exists. In other embodiments this step may be omitted.

The first device may then transmit to the fourth device information identifying the portion of the compression history step . In one embodiment this step may comprise transmitting the data stream to the fourth device compressed according to the matching portions of the first compression history. The first device may perform this compression according to the matching portions of the first compression history in any manner. In one embodiment the first device may replace portions of the data stream with location identifiers identifying the matching portions of the first compression history. In this embodiment the first device may also compress the data stream using any other techniques including without limitation additionally compressing the data stream according to a second compression history shared between the first device and third device. In one embodiment this step may comprise transmitting one or more chunk identifiers to the fourth device. In another embodiment this step may comprise transmitting one or more location identifiers to the fourth device. In one embodiment the first device may also transmit information identifying the third device.

In one embodiment the first device may also include location identifiers of one or more portions of the compression history that are subsequent to the identified matching portions. The first device may include these portions based on a speculation that the subsequent portions will also match subsequent portions of the second data stream. In some embodiments the number of subsequent portions the first device identifies may be determined by the quality or quantity of found matches.

After the fourth device receives the data stream compressed according to the first compression history the fourth device may decompress the data stream in any manner. In some embodiments the fourth device may decompress the data stream using any of the techniques described with respect to steps in . In one embodiments the fourth device may transmit to the third device a request for the identified portions of the first compression history. These portions may then be transmitted from the third device to the second device using any means and any protocol. In some embodiments the fourth device may then signal to the first device that it has received one or more portions of the compression history. In other embodiments the fourth device may transmit an indication to the first device that the identified portions of the compression history cannot be obtained which may occur if the second device is inoperable or busy. In these cases the first device may then retransmit the data stream to the third device without compressing it according to the first compression history.

Now referring to a block diagram illustrating one embodiment of providing an ad hoc hierarchy of caches to serve objects is shown. In brief overview an appliance intercepts a request for an object from a client to a server. The appliance after finding that the object is not in a local cache transmits a request to the server for the object. Appliance also transmits a number of duplicate requests to devices which may have a cached copy of the object. These devices may include a client agent an appliance or any other device. Appliance may then receive the object from any of the sources to which requests were sent. The appliance may then send the object to the client from the first responder.

Still referring to now in greater detail appliances and client and reside on a network . In some embodiments the appliances may be WAN optimization devices and network may comprise a WAN. In other embodiments any of the appliances may comprise a proxy server proxy cache SSL VPN appliance firewall and or transparent proxy. In some embodiments the appliances may be serving as transparent proxies for communications between a number of clients and a server . In some embodiments the network may comprise a LAN. The two appliances may be on a LAN with the one or more clients . In one embodiment the appliances and clients may be located in one or more branch offices and the server may be located in a central office. In another embodiment there may be one or more appliances on network intercepting traffic for the server . Although depicts an appliances the systems and methods described with respect to may apply equally with a client agent executing on the client performing the functions of appliance

In the embodiment shown the appliances and the client may each contain a cache of objects previously transmitted through the appliance. A cache may comprise any type and form of storage including without limitation storage on memory or disks. A data object may comprise any discrete sequence of data. Examples of data objects include without limitation files images executables web pages audio files and video files. In one embodiment data objects may be stored in a cache on an appliance along with an index of a name of each of the data objects. For example an appliance may maintain a cache of files or portions of files transmitted through the appliance via CIFS and may keep an index of the file names such that in response to receiving a request for a given named object the appliance can retrieve the object of that name from the cache. In another embodiment data objects may be stored with any other identifiers including without limitation location identifiers chunk identifiers and fingerprints.

In some embodiments a cache may be integrated with a compression history. For example an appliance may keep an index of named objects that have been transmitted via the appliance where the index contains pointers to a portion or portions of a compression history containing the named object. In one embodiment an appliance may keep an index which matches names of objects to chunk identifiers and offsets identifying the locations of the named objects. In other embodiments a cache may be maintained separately from one or more compression histories.

The system shown may be used to create an ad hoc cache hierarchy. Since the requests sent to the devices which may have cached the object may be sent in parallel to the request to the server the system may not result in additional latency penalties if any of the devices do not have the object cached. The system may be used in cases where the appliance is not certain whether an object exists in the cache of another device or is not certain another device is available.

Referring now to a flow diagram illustrating one embodiment of a method for providing an ad hoc hierarchy of caches to serve objects is shown. In brief overview the method comprises receiving by an appliance from a client a first request for an object from a server step . The first device identifies that the object is not located in a first cache of the appliance step and forward the first request for the object to the server step . The appliance transmits prior to receiving a response to the forwarded request a second request for the object to a second device step . The appliance receives from at least one of the server or the second device the object step and then transmits the object to the client step . In some embodiments the first appliances may be any of a client server client agent server agent appliance WAN optimization device and or transparent proxy. In one embodiment this method may reflect steps performed by the appliance in .

Still referring to now in greater detail the method comprises receiving by an appliance a first request from a client to a server for an object step . In some embodiments the first appliance may intercept the first request transparently to one or more of the client the server a client agent server agent or an intermediate appliance. The first request may comprise a request transmitted via any protocol and may be received in any manner. Examples of requests for an object include without limitation HTTP requests for files FTP requests for files CIFS requests for some or all of a file NFS requests for some or all of a file and ICA requests for one or more application objects. In one embodiment the appliance may intercept at the transport layer a request for an application layer object. In another embodiment the appliance may intercept at the network layer a request for an application layer object. In some embodiments the request may be transmitted via a TCP connection the appliance is serving as an intermediary for.

In some embodiments the appliance receiving the request may be local to the client making the request. In other embodiments the appliance receiving the request may be connected to the client via a WAN. In still another embodiment the appliance receiving the request may be connected to the client via one or more intermediary devices. In this embodiment the intermediary devices may comprise any of a WAN optimization device a VPN device and or a transparent proxy device.

After intercepting the request the appliance may identify that the object is not located in a cache of the appliance in any manner step . This identification may be done by any means including without limitation performing a cache lookup based on an object name a fingerprinting method and determining that a cached copy of the object has expired or is otherwise unusable. In some embodiments this step may be omitted. For example this step may be omitted where the first appliance does not maintain a cache.

The appliance may then forward the request to the server step . The first appliance may transmit the forwarded request to the server via any protocol or protocols including protocols other than the protocols used to receive the first request. In some embodiments the forwarded request may comprise the first request. In other embodiments the first appliance may modify reformat or otherwise alter the first request. For example the first appliance may encrypt some or all of the first request. In some embodiments the appliance may transmit the request to a second appliance serving as a proxy for the server. In other embodiments the forwarded request may pass through any number of intermediary devices before reaching the server .

After receiving the second request the appliance may transmit prior to receiving a response to the forwarded request a second request for the object to a second device step . The second device may comprise any of a client server appliance or client agent . In some embodiments the second device may comprise a browser cache. In some embodiments the appliance may determine the object may be stored in a second device by searching an index of objects previously transmitted. In another embodiment the appliance may determine the object may be stored in a second device by consulting a compression history or compression history index. In some embodiments the appliance may determine whether the object has been transmitted to the second device within a predetermined time period.

The second device may reside in any location relative to the appliance. In some embodiments the second device may be on a LAN with the appliance. In one embodiment the second device may comprise a second appliance in a cluster with the appliance. In another embodiment the second device may be connected to the appliance via a lower latency connection than the server is to the appliance.

In one embodiment the appliance may transmit the second request prior to receiving any response to the request from the server. In another embodiment the application may transmit the second request prior to receiving an acknowledgement or other confirmation from the server that the request was received. In still another embodiment the appliance may transmit the second request prior to receiving any response to the request from an intermediary device between the appliance and the server.

The appliance may transmit any number of additional requests for the object prior to receiving a response to the forwarded request. In one embodiment the appliance may transmit a third request for the object to a third device. In one embodiment the appliance may transmit a request for the object to each of a number of appliances in a cluster. In another embodiment the appliance may send a request for the object to a number of client agents on a LAN with the appliance. For example an appliance at a branch office upon receiving a request for an object may forward the request to a server at a central office and also send a request for the object to any other appliances also at the branch office in addition to one or more clients located on the branch office.

In some embodiments the appliance may transmit a request for a portion of the object to a first device and a request for a second portion of the object to a second device. In other embodiments the appliance may divide the requested object into any number of portions and send out one or more requests for each portion.

The devices receiving the additional requests may service them in any manner. In some embodiments the devices may locate the object and begin transmitting the object to the appliance in any manner. In other embodiments the devices may ignore the requests. In other embodiments the devices may determine that the object is not stored in a cache on the device. In these embodiments the devices may or may not transmit an indication to the first device that the object was not found. In still other embodiments the devices may forward the requests to one or more additional devices.

The appliance may then receive from at least one of the server or the second device the object step . The object may be received in any manner and via any connection or protocol. In some embodiments the appliance may begin receiving the object from a plurality of sources. In these embodiments the appliance may select a source to use for receiving the object. In some embodiments the appliance may select the source that responded first. In other embodiments the appliance may select the source having the highest available bandwidth. In still other embodiments the appliance may select the source based on proximity to the appliance. In some embodiments the appliance may cancel the request or may reset or close the connections to other sources transmitting the object.

In some embodiments the appliance may receive a first portion of the object from a first device and a second portion of the object from a second device. In these embodiments the appliance may reassemble the portions of the object received from multiple sources into the object in any manner.

The appliance may then transmit the object to the client in any manner. In some embodiments the appliance may forward the object received from the server . In other embodiments the appliance may transmit the object received from one or more other devices.

While the invention has been particularly shown and described with reference to specific preferred embodiments it should be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.

