---

title: CPU-GPU parallelization
abstract: Embodiments described herein relate to improving throughput of a CPU and a GPU working in conjunction to render graphics. Time frames for executing CPU and GPU work units are synchronized with a refresh rate of a display. Pending CPU work is performed when a time frame starts (a vsync occurs). When a prior GPU work unit is still executing on the GPU, then a parallel mode is entered. In the parallel mode, some GPU work and some CPU work is performed concurrently. When the parallel mode is exited, for example when there is no CPU work to perform, the parallel mode may be exited.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09129394&OS=09129394&RS=09129394
owner: Microsoft Technology Licensing, LLC
number: 09129394
owner_city: Redmond
owner_country: US
publication_date: 20121214
---
Various types of software use a central processing unit CPU in combination with a graphics processing unit GPU to display graphics on a display. Examples of such software are window managers three dimensional games animation software application software and others. Typically events such as user inputs or interactions with a user interface animations video playbacks system events that require the display of information or other events require both application level logical processing to determine for example what objects may need to be displayed or moved what object portions have been hidden or exposed textures to be rendered user interface elements to draw and other logical operations that perhaps by way of an application programming interface generate code or instructions to be executed on a GPU.

Various approaches have been used to improve the flow of work between the CPU and the GPU and overall computational efficiency. For example double buffering has been used to improve speed and triple buffering has been used to allow for some CPU GPU concurrency. A technique referred to as vsync vertical synchronization which synchronizes graphics generation and painting with display refreshes has been used to avoid artifacts such as tearing. There remains a need to improve overall throughput when the vsync approach is used. Some previous approaches have improved overall throughput but at the expense of artifacts such as skipped frames or at the cost of increased hardware requirements which can be problematic for resource constrained devices. It would be beneficial if overall throughput could be improved with the vsync technique without introducing unacceptable lag delay from event to corresponding display of graphics stuttering or other undesirable side effects.

The following summary is included only to introduce some concepts discussed in the Detailed Description below. This summary is not comprehensive and is not intended to delineate the scope of the claimed subject matter which is set forth by the claims presented at the end.

Embodiments described herein relate to improving throughput of a CPU and a GPU working in conjunction to render graphics. Time frames for executing CPU and GPU work units are synchronized with a refresh rate of a display. Pending CPU work is performed when a time frame starts a vsync occurs . When a prior GPU work unit is still executing on the GPU then a parallel mode is entered. In the parallel mode some GPU work and some CPU work is performed concurrently. When the parallel mode is exited for example when there is no CPU work to perform the parallel mode may be exited.

Many of the attendant features will be explained below with reference to the following detailed description considered in connection with the accompanying drawings.

Embodiments discussed below relate to techniques for parallelizing execution of a CPU and a GPU. The following description will begin with some examples hardware and software contexts for implementing the techniques. An explanation of some prior aspects of vsync based rendering will be described next including non parallel alternating CPU GPU execution. Techniques for allowing parallel CPU GPU execution are then discussed. Finally the description will cover details of switching between a parallel mode and a non parallel mode and some advantages thereof.

When frame B completes new frame C starts executing the next CPU work unit which generates the next GPU work unit . Again GPU executes the GPU work unit in the same frame C. This process of repeatedly executing chunks of work in synchronization with refreshes of the display continues as long as there is work to be done. For example the process many continue until a user interface animation completes.

To summarize while in parallel mode GPU work units may execute in parallel with CPU work units while maintaining synchronization with the refresh signal. Parallel mode may be entered when pending or executing GPU work is detected. Parallel mode may be exited when no CPU work is pending when the software that is handling the events is idle .

While the checking for execution of prior GPU work can be performed at the start of a new frame such checking can be performed at other stages of the new frame for example when CPU work in the current frame finishes during execution of the current CPU work e.g. by a timer or as otherwise convenient for the implementation. In one embodiment in parallel mode the GPU work units start at the beginning of frames following the frames of their respective CPU work units see . shows behavior of another embodiment where GPU work units begin executing mid frame for example as soon as GPU work units are ready for processing. This approach which may require additional synchronization logic and can in some cases reduce latency increase overall concurrency or hasten the exit from parallel mode.

Embodiments and features discussed above can be realized in the form of information stored in volatile or non volatile computer or device readable media. This is deemed to exclude signals per se and rather includes physical storage media or devices such as optical storage e.g. compact disk read only memory CD ROM magnetic media flash read only memory ROM random access memory RAM or other non signal physical means of storing digital information. The stored information can be in the form of machine executable instructions e.g. compiled executable binary code source code bytecode or any other information that can be used to enable or configure computing devices to perform the various embodiments discussed above. This is also deemed to include at least volatile memory such as random access memory RAM and or virtual memory storing information such as central processing unit CPU instructions during execution of a program carrying out an embodiment as well as non volatile media storing information that allows a program or executable to be loaded and executed. The embodiments and features can be performed on any type of computing device including portable devices workstations servers mobile wireless devices and so on.

