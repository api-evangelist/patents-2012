---

title: Methods for efficient cluster analysis
abstract: Some embodiments provide a method for defining structure for an unstructured document that includes a number of primitive elements that are defined in terms of their position in the document. The method identifies a pairwise grouping of nearest primitive elements. The method sorts the pairwise primitive elements based on an order from the closest to the furthest pairs. The method stores a single value that identifies which of the pairwise primitive elements are sufficiently far apart to form a partition. The method uses the stored value to identify and analyze the partitions in order to define structural elements for the document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08892992&OS=08892992&RS=08892992
owner: Apple Inc.
number: 08892992
owner_city: Cupertino
owner_country: US
publication_date: 20120720
---
This application is a continuation application of U.S. patent application Ser. No. 12 479 843 filed Jun. 7 2009 now issued as U.S. Pat. No. 8 261 186. U.S. patent application Ser. No. 12 479 843 claims the benefit of U.S. Provisional Application 61 142 329 entitled Methods and System for Document Reconstruction filed Jan. 2 2009. U.S. Pat. No. 8 261 186 and U.S. Provisional Application 61 142 329 are incorporated herein by reference.

The invention is directed towards methods for efficient cluster analysis. Specifically the invention is directed towards methods for defining a structured document from an unstructured document for improving the efficiency of such processes and for improving display of and interaction with structured documents.

Documents are often defined as nothing more than a collection of primitive elements that are drawn on a page at defined locations. For example a PDF portable document format file might have no definition of structure and instead is nothing more than instructions to draw glyphs shapes and bitmaps at various locations.

A user can view such a document on a standard monitor and deduce the structure. However because such a file is only a collection of primitive elements a document viewing application has no knowledge of the intended structure of the document. For example a table is displayed as a series of lines and or rectangles with text between the lines which the human viewer recognizes as a table. However the application displaying the document has no indication that the text groupings have relationships to each other based on the rows and columns because the document does not include such information. Similarly the application has no indication of the flow of text through a page e.g. the flow from one column to the next or the flow around an embedded image or various other important qualities that can be determined instantly by a human user.

This lack of knowledge about document structure will not always be a problem when a user is simply viewing the document on a standard monitor. However it would often be of value to a reader to be able to access the file and edit it as though it were a document produced by a word processor image editing application etc. that has structure and relationships between elements. Therefore there is a need for methods that can reconstruct an unstructured document. Similarly there is a need for methods that take advantage of such reconstructed document structure to idealize the display of the document e.g. for small screen devices where it is not realistic to display the entire document on the screen at once or to enable intelligent selection of elements of the document.

In the modern world more and more computing applications are moving to handheld devices e.g. cell phones media players etc. . Accordingly document reconstruction techniques must be viable on such devices which generally have less computing power than a standard personal computer. However document reconstruction often uses fairly computation and memory intensive procedures such as cluster analysis and the use of large chunks of memory. Therefore there is further a need for techniques that allow for greater efficiency in document reconstruction generally and cluster analysis specifically.

Different embodiments of the invention use different techniques for analyzing an unstructured document to define a structured document. In some embodiments the unstructured document includes numerous primitive elements but does not include structural elements that specify the structural relationship between the primitive elements and or structural attributes of the document based on these primitive elements. Accordingly to define the structured document some embodiments use the primitive elements of the unstructured document to identify various geometric attributes of the unstructured document and then use the identified geometric attributes and other attributes of the primitive elements to define structural elements such as associated primitive elements e.g. words paragraphs joined graphs etc. tables guides gutters etc. as well as to define the flow of reading through the primitive and structural elements.

As mentioned some embodiments use primitive elements to identify various geometric attributes. For instance some embodiments provide a method that identifies boundaries between sets of primitive elements and regions bounded by the boundaries. The method uses the identified regions to define structural elements for the document and defines a structured document based on the primitive elements and the structural elements. In some embodiments defining structural elements includes analyzing each region separately to create associations between sets of primitive elements in the particular region. In some embodiments defining the structured document includes identifying hierarchical relationships between the identified regions.

Some embodiments provide a method that analyzes an unstructured document that includes numerous words where each word is an associated set of glyphs and each glyph has location coordinates. The method identifies clusters of location values where each location value is associated with one word is a basis for word alignment and is derived from the location coordinates of the glyphs of that word. Based on the identified clusters of location values the method defines a set of boundary elements for the words that identify a set of alignment guides for the words. The method defines a structured document based on the glyphs and the defined boundary elements. Some embodiments also define at least one region of white space between a pair of boundary elements and further define the structured document based on the region of white space. Some embodiments identify the clusters of location values by using density clustering.

Some embodiments use the identified geometric attributes and other attributes of the primitive elements to define structural elements as well as to define the flow of reading through the primitive and structural elements. For instance some embodiments provide a method that analyzes an unstructured document that includes numerous glyphs each of which has a position in the unstructured document. Based on the positions of glyphs the method creates associations between different sets of glyphs in order to identify different sets of glyphs as different words. The method creates associations between different sets of words in order to identify different sets of words as different paragraphs. The method defines associations between paragraphs that are not contiguous in order to define a reading order through the paragraphs. In order to create associations between different sets of words in order to identify different sets of words as different paragraphs some embodiments create associations between different sets of words as different text lines and create associations between different sets of text lines as different paragraphs.

Some embodiments provide a method that identifies boundaries between sets of glyphs and identifies that several of the boundaries form a table. The method defines a tabular structural element based on the table that includes several cells arranged in several rows and columns where each cell includes an associated set of glyphs. Some embodiments identify that the boundaries form a table by identifying a set of boundaries that form a larger rectangular shape and several rectangular shapes contained within the larger rectangular shape. In some embodiments at least some of the identified boundaries are inferred based on positions of the associated sets of glyphs that form the cells.

Some embodiments provide a method for analyzing an unstructured document that includes numerous primitive graphic elements each of which is defined as a single object. The document has a drawing order that indicates the order in which the primitive graphic elements are drawn. The method identifies positional relationships between successive primitive graphic elements in the drawing order. Based on the positional relationships the method defines a single structural graphic element from several primitive graphic elements. Some embodiments identify a positional relationship between a first and second primitive graphic element that are subsequent in the drawing order by calculating a size of a structural graphic element that includes the first and second primitive graphic elements.

Some embodiments provide methods to make geometric analysis and document reconstruction more effective. For instance some embodiments provide a method that provides a default set of document reconstruction operations for defining a structured document that comprises a plurality of primitive elements. The method provides a hierarchical set of profiles each profile including i a set of document reconstruction results and ii results for modifying the document reconstruction operations when intermediate document reconstruction results match the potential document reconstruction results for the profile. Instructions from a profile at a lower level in the hierarchy override instructions from a profile at a higher level. In some embodiments the instructions for a particular profile include a subset of profiles at a lower level in the hierarchical set of profiles that should be tested when the intermediate document reconstruction results match the potential document reconstruction results for the profile.

Once a structured document is defined some embodiments provide various techniques for idealizing user interaction with the structured document. For instance some embodiments provide a method for displaying a structured document that includes a hierarchy of structural elements constructed by analyzing an unstructured document. The method displays the structured document on the device e.g. a small screen device . The method receives a position of interest in the document and identifies a structural element within the hierarchy as a region of interest based on the position of interest. The method modifies the display of the document to highlight the identified region of interest. Some embodiments identify the structural element by identifying a structural element at the lowest level of the hierarchy that includes the position of interest and identifying structural elements at higher levels of hierarchy that include the structural element identified at the lowest level until a structural element qualifying as a region of interest is reached. Some embodiments also receive an input to move from the region of interest and modify the display of the document to highlight a structurally related region of interest.

Some embodiments provide a method for defining a selection of text in an unstructured document that includes numerous glyphs. The method identifies associated sets of glyphs and a reading order that specifies a flow of reading through the glyphs. The method displays the document and receives a start point and end point for a selection of text within the displayed document. The method defines the selection of text from the start point to the end point by using the identified sets of glyphs and intended flow of reading. In some embodiments the associated sets of glyphs are paragraphs and the reading order specifies a flow of reading from a first paragraph to a second paragraph that are not contiguous.

Some embodiments provide methods that enhance the efficiency of the geometric analysis and document reconstruction processes. Some embodiments use cluster analysis for geometric analysis and or document reconstruction which can be a computing intensive process. Accordingly some embodiments provide a method that defines structure for an unstructured document that includes numerous primitive elements that are defined in terms of their position in the document. The method identifies a pairwise grouping of nearest primitive elements and sorts the pairwise primitive elements based on an order from the closest to the furthest pairs. The method stores a single value that identifies which of the pairwise primitive elements are sufficiently far apart to form a partition. The method uses the stored value to identify and analyze the partitions in order to define structural elements for the document.

Some embodiments also provide methods for making use of efficient data structures. For instance some embodiments provide several different processes for analyzing and manipulating an unstructured document that includes numerous primitive elements. Some embodiments also provide a storage for data associated with the primitive elements. At least some of the data is stored in a separate memory space from the processes and is shared by at least two different processes. The processes access the data by use of references to the data. The data is not replicated by the processes.

In the following description numerous details are set forth for purpose of explanation. However one of ordinary skill in the art will realize that the invention may be practiced without the use of these specific details. For instance in some cases the techniques described below are described as taking place in a specific order. However in some embodiments the techniques are performed in an order different from that described. Furthermore while the techniques are described for languages that are read left to right e.g. English one of ordinary skill will recognize that the techniques are easily adapted for right to left languages.

Some embodiments of the invention provide novel methods for defining a structured document from an unstructured document. In some embodiments an unstructured document is a document defined to include only primitive elements such as shapes e.g. vector graphics images e.g. bitmaps and glyphs. In some embodiments a glyph is a visual representation of a text character e.g. a letter a number a punctuation mark or other inline character collection of characters or portion of a character. In some embodiments a glyph may be a pre specified collection of scalable vector graphics including path definitions for the outline of the glyph. In some embodiments a glyph may be a pre specified raster image or collection of raster images optimized for various sizes. As an example the character i could be represented by a single glyph that is a path with two sub paths one for the outline of the dot and one for the outline of the lower portion. As another example the combination of three characters ffi when occurring in sequence are sometimes represented by a single glyph called a ligature drawn in a slightly different manner than the characters occurring individually. As a third example accented characters such as are sometimes represented by more than one glyph e.g. one for the character and one for the accent and are sometimes represented by a single glyph combining accent with character .

The unstructured document of some embodiments does not specify any relationship or association between the primitive elements while in other embodiments it specifies a minimum amount of such relationships and associations. In some embodiments the unstructured document may have some amount of structure but the structure is unrecognizable or not relied upon. In some embodiments the unstructured document has an unknown structure or is assumed to be unstructured.

Some embodiments generate from the unstructured document a structured document that includes associations and relationships between the primitive elements groupings and orderings of the primitive elements and properties of the groups of primitive elements. For instance some embodiments use the primitive elements of the unstructured document to identify various geometric attributes of the unstructured document and use these identified geometric attributes along with other attributes of the primitive elements to define structural elements. Structural elements of some embodiments include associated primitive elements e.g. words paragraphs joined graphs etc. guides gutters text flow tables etc. These structural elements are related in a hierarchical manner in some embodiments e.g. a paragraph includes text lines a text line includes words and a word includes primitive glyphs . In some embodiments the structured document serves two purposes it identifies associated elements e.g. the elements making up a table and it identifies a flow order through the primitive elements i.e. the order in which a human would be expected to read through the primitive elements in the document .

Upon receiving an unstructured document some embodiments first parse the document into its constituent elements e.g. primitive elements and their associated information such as coordinate locations drawing order etc. . For instance a large block of text might be defined in the unstructured document as a number of character glyphs each having x and y coordinates at which their anchors are placed on a particular page along with a scale factor determining the size of each glyph and any other linear transforms that are to be applied each glyph to be drawn on the page in a particular order relevant to the compositing operation performed when one glyph overlays another . Some embodiments then perform geometric analysis on the primitive elements to define geometric attributes of the document. For example some embodiments analyze the primitive elements to identify boundaries between primitive elements and regions bordered by the boundaries.

In some embodiments the boundaries identified by geometric analysis modules also include alignment guides. In some embodiments an alignment guide is a vertical edge formed by the beginning or end of words e.g. at the left edge of a column of left aligned text . Similarly in some embodiments the regions identified by geometric analysis include gaps of unfilled white space between groups of glyphs e.g. between guides . These gaps are called gutters in some embodiments.

Analysis result illustrates a left alignment guide at the left edge of the first column of text and a gutter spanning the white space between the two columns of text for simplicity the other guides and the columns of text are not shown . As illustrated in the output of the semantic analysis modules of some embodiments is zones guides and gutters .

The data output from geometric analysis modules is sent to document reconstruction modules . Document reconstruction modules continue the process of analyzing the unstructured document to define a structured document. In some embodiments document reconstruction modules create associations between primitive elements in order to define contiguous structural elements such as text tables and shapes. Some embodiments also define a hierarchy of the structural elements and relationships between the structural elements.

For instance in some embodiments the document reconstruction modules create associations between glyphs sets of glyphs sets of sets of glyphs etc. Some embodiments associate individual glyphs into words words into text lines text lines into paragraphs etc. Analysis result illustrates that individual lines and paragraphs are identified within the first column of text.

The document reconstruction modules also identify the layout of glyphs in order to define the text flow through the glyphs. Specifically to define the text flow some embodiments identify a reading order through the glyphs or through the sets of glyphs which represents the order in which a human would be expected to read through the glyphs on a page e.g. from the bottom of a first column to the top of a second column then skipping a separated text box in the center etc. Analysis result illustrates that two columns are identified within the document and that the reading flow runs from the bottom of the first column to the top of the second column. In some embodiments the identification and definition of layout and flow makes use of the zone results the guide and gutter results and the glyph association results .

The document reconstruction modules also define other structural elements in a document that are associations between primitive elements other than glyphs or between structural elements. For instance in some embodiments document reconstruction modules identify tables in a document as associations between regions identified by geometric analysis modules as well as the glyphs and sets of glyphs within the regions. For example some embodiments associate regions as cells of a table and the glyphs inside each region as the table information. Analysis result illustrates the identification of a table with nine cells in document by document reconstruction modules . Some embodiments associate the primitive elements that form the table by defining a tabular structural element. Whereas in the initial document what was viewed as a table was defined as an unassociated collection of primitive elements lines and glyphs after reconstruction the cells are identified in the tabular structural element as table cells and are individually or collectively editable. As further illustrated in some embodiments the table identification and reconstruction uses zone results glyph association results and layout and flow results .

Some embodiments also identify when two or more primitive graphic elements or graphic objects e.g. shapes images photographs bitmaps etc. in the document should be grouped as one structural graphic element. For instance two objects that mostly overlap may be one element that is defined as two shapes or images in the unstructured document. The document reconstruction modules join these two objects as one object. Analysis result illustrates that the two primitive shapes a star and a hexagon from the initial document have been joined as one graphic by the document reconstruction modules .

As illustrated in examples of the output of the document reconstruction modules include semantic hierarchy data i.e. associations of glyphs layout and flow data table data and joined graph data . Furthermore in some embodiments some of this information is also passed between the several document reconstruction modules . illustrates that all of this information is used to define a structured document . Structured document has the same appearance as unstructured document but the structured document includes information about the structural elements and the associations relationships and hierarchy of elements thereby enabling editing more intuitive display etc.

The data from the document reconstruction modules as well as in some embodiments data from the geometric analysis modules is used by document display and interaction modules . Document display and interaction modules enable a user to view edit scroll through etc. a document. For example sequence illustrates a document displayed as two columns of text on a handheld device that is held upright. When the handheld device is rotated on its side the text in the two columns is rearranged into three columns. This rearrangement cannot be done with an unstructured document because it relies upon the associations between elements especially the flow of text through glyphs that is not part of the unstructured document.

In some embodiments document display and interaction modules can also recognize a structural element e.g. a paragraph graphic object etc. that has been selected by a user and intelligently zoom to display the selected element. In some embodiments the user selects a position of interest i.e. a particular location in a displayed document and the display and interaction modules identify a qualifying structural element in the hierarchy of structural elements. Some embodiments define particular types of structural elements as qualifying structural elements. The qualifying structural element is used to define a region of interest that is highlighted in the display in some embodiments.

Sequence illustrates a selection of a paragraph e.g. by a selection of a position of interest of interest within the paragraph and the subsequent intelligent display of the paragraph and nearby text. Document display and interaction modules also provide other features such as intelligent selection of text and graphic objects intelligent scrolling through a document etc.

Some embodiments use hierarchical profiling to modify how geometric analysis and document reconstruction are performed on the fly using intermediate analysis and reconstruction results. Some embodiments check the intermediate results against profiles that indicate what type of content a document includes and alter the reconstruction processes accordingly. In some embodiments the hierarchical profiles can instruct the analysis and reconstruction modules to perform more or less processes perform processes differently or re perform processes. For instance if intermediate analysis results indicate that a document is one page long has one column of text and no shapes or images then some embodiments will only perform processes to associate the glyphs into words lines and paragraphs. Table identification for instance will not be performed.

Some embodiments employ various novel efficiency techniques for more efficient memory and processing usage. For instance some embodiments perform some of the above described processes by using cluster analysis which is a technique used to identify groups of elements that are closely spaced in some way relative to other elements. Some embodiments use cluster analysis to identify guides based on numerous words starting at ending at centered on or otherwise aligned with the same or nearly the same x coordinate. Some embodiments use cluster analysis to recognize different size gaps between glyphs so as to identify gaps between words and gaps larger than those between words. Some embodiments also use cluster analysis to identify primitive graphics e.g. shapes images that should be joined into single graphics.

Some embodiments perform cluster analysis efficiently by using ordered data e.g. primitive element position data that references unsorted data and by storing partitions of the data using a single value. A partition as this term is used in the present invention divides a sequence or linearly ordered set into subsequences which are subsets of the sequence with the same order relation. Furthermore a partition has the properties that i every member of the original sequence is contained in exactly one of the partition s subsequences and ii given two of the partition s subsequences S and T either all the members of S are less than all the members of T or all the members of T are less than all the members of S according to the order relation. Storing a partition as a single value enables various cluster analysis functions such as examining multiple partitions to be performed more efficiently in some embodiments.

Some embodiments also gain efficiency in the document reconstruction process by using an application programming interface API that minimizes the amount of copying of data while appearing to the user of the API e.g. a programmer or a software application using the API as though the data is freely modifiable. Some embodiments store data in a randomly ordered array then define a sorted array of references to the data and share this sorted array among numerous collection objects e.g. character sequence objects which are collections of character data to optimize the usage of memory and processing. Both of these efficiency enhancements as well as others are used in some embodiments to enable document reconstruction to be performed on a limited resource device such as a cell phone media player etc. e.g. an iPhone .

Although the above described overview of some embodiments was provided by reference to the examples illustrated in one of ordinary skill will realize that these examples were meant only as exemplary embodiments that introduced the features and operations of some embodiments of the invention. One of ordinary skill will realize that many embodiments have features and operations that are different than those illustrated in . For instance although geometric analysis has been described as one set of modules one of ordinary skill would recognize that some embodiments do not necessarily identify all geometric attributes at once. For example some embodiments do a subset of geometric analysis first e.g. region analysis to identify one or more zones in the document and then guides and gutters are identified on a zone by zone basis.

More detailed examples of some embodiments will be described below. Section II describes the identification of regions i.e. zones of a document based on boundary primitive elements and the definition of a hierarchical structure e.g. a document object model that forms the framework of a structured document. Section III then describes the identification of boundary elements for glyphs e.g. alignment guides and particular empty spaces between alignment points gutters . Next Section IV details the creation of associations between glyphs and sets of glyphs to define structural elements such as words text lines paragraphs columns etc. as well as the definition of a flow order through these structural elements as well as other elements such as graphics tables etc. . Section V describes the identification of primitive graphic elements that should be grouped together and the creation of associations between such primitive elements to define compound graphic elements.

Section VI then describes various methods for improving the efficiency of cluster analysis techniques which among other uses are used for identification of alignment guides words and glyph spacing and compound graphics in the document reconstruction process. Next Section VII details methods and data structures that enable more efficient parsing and analysis of a document. These data structures illustrate one manner of creating associations between glyphs e.g. to form words text lines paragraphs etc. that can be used in the document reconstruction process. However one of ordinary skill in the art will recognize that many other ways of creating associations between primitive elements e.g. glyphs graphic elements etc. to define structural elements e.g. paragraphs tables compound graphics etc. are possible as is well known in the art. Next Section VIII describes the software architecture of a document reconstruction application of some embodiments and Section IX describes a computer system that implements some embodiments of the invention.

When there are multiple articles sections or categories of information on a page these are often delineated by lines images or shapes. Although a human can easily identify the manner in which graphical cues are intended to indicate how the page is broken up into zones this is a nontrivial problem for a computer particularly in the presence of a mixture of graphic primitive elements some of which are intended as page content while others are intended to delineate content zones .

Some embodiments of the invention provide methods for identifying boundaries and the regions bordered by those boundaries e.g. zones based on the primitive elements e.g. the shapes and images of an unstructured document. In some embodiments the regions are used in subsequent reconstruction of the document as well as for compartmentalization of further reconstruction processes. Some embodiments generate a region graph i.e. hierarchical structure such as a tree that is populated with content and enables the association of content with the region in which the content is located. Some embodiments perform the region identification on a page by page basis.

Next the process identifies at zones on the page. In some embodiments the identification of zones includes identifying zone borders and intersections and then traversing the zone borders to identify the zones. Referring to the example of process identifies that page includes five zones zones A B C D and E .

After identifying the zones process generates at a zone graph i.e. hierarchical structure such as a tree for the page. The zone graph illustrates the hierarchy of the zones. For instance zone tree illustrates that a zone for the page node P includes four zones A B C and D. Furthermore zone D includes zone E as zone E is fully within zone D. In some embodiments a first zone is the parent of a second zone when the second zone is wholly within the first zone. A parent and a child can share one or more borders in some embodiments.

After generating the zone graph process inserts at the content of the page into the zone graph. The process then ends. In some embodiments a page includes text graphics or other content. Each particular content grouping e.g. an image paragraph column etc. is placed as a child of the smallest zone that fully contains the particular content grouping. In some embodiments the insertion of content objects into the zone graph is performed later in the document reconstruction process once the content has been further analyzed e.g. grouping text into paragraphs identifying tables etc. . Furthermore as document reconstruction is performed some embodiments update the zone graph with content subtrees for each zone.

Zone border graphics are graphic objects e.g. shapes images lines on a page that either are narrow rectangles or have an upright bounding box that is a narrow rectangle For instance zone borders are all lines with a particular relatively narrow thickness. In some embodiments zone border graphics include relatively narrow objects all or part of the rendering of which fills all or part of a zone border. In some embodiments zone border graphics also include objects whose boundary contributes to a zone border e.g. one side of a filled polygon can indicate all or part of a zone border even though the polygon itself is not narrow and does not fit in the border bounds .

Zone borders graphics however need not be perfectly straight lines or perfectly rectilinear. For instance illustrates a page that includes zone border graphics . Zone border graphics are not perfectly vertical strips instead they are images of twigs that are aligned very close to vertically. Some embodiments will recognize the graphic as a zone border graphic whereas some embodiments will not.

Page of also includes numerous zone border intersections such as intersections and . In some embodiments a zone border intersection is a rectangular intersection of a horizontal zone border with a vertical zone border. As intersection illustrates a zone border intersection need not be at the end of a zone border. Zone border intersections in the middle of a zone border break the zone border into one or more zone border intervals in some embodiments. For instance the bottom zone border of page is broken into zone border intervals and .

A zone therefore is a closed region bounded by a collection of zone border intervals that form an upright rectilinear shape in some embodiments. Upright rectilinear shapes are any polygons that can be formed by horizontal and vertical line segments including but not limited to upright rectangles which are rectangles formed from horizontal and vertical line segments. Each zone has an upright rectilinear outer bound which is a shape formed from the outer sides of its zone border bounding rectangles. Each zone also has an upright rectilinear inner bound which is a shape formed from the inner sides of its zone border bounding rectangles.

Page includes zones P the page bounds A an arch shaped zone that includes the thin strips on the left and right side as well as the area above zones C and D B C the left zone that shares borders with zone E D the right zone that is a mirror image of zone C E and G . Zones have outer bounds and inner bounds in some embodiments defined by the outer and inner sides of the zone borders.

Some embodiments define several rotation groups on a page and analyze the zones and content of each rotation group separately. In some embodiments rotation groups are similar to zones except that they do not have any zone borders. Instead a rotation group is defined to include all content that is rotated by the same angle or nearly the same angle to within a particular threshold that is sufficiently small as to be difficult for a human viewer to distinguish . conceptually illustrates a process of some embodiments for defining rotation groups on a page. As shown process receives at a page of a document. In some cases the page is the only page of the document whereas in other cases the page is one of multiple pages. Some embodiments perform rotation group analysis for a multi page document or a multi page section all at once rather than page by page.

The process then determines at the rotation angle of each object on a page. In some embodiments irregularly shaped images are assumed to have a rotation angle of zero. For instance the image in zone E of page is irregularly shaped and would not be given a non zero rotation angle. Horizontally aligned text also has a rotation angle of zero while text that is aligned off the x axis is given a rotation angle. For example the text in region F of page would have a rotation angle of approximately 45 degrees. Similarly the text Organic and Pure in page would have its own rotation angle. In embodiments that also place graphic objects into rotation groups the rectangular image above text would have the same rotation angle as text .

Next process orders at the objects by rotation angle. The process then groups at the objects into clusters with a spread in rotation angle that is below a particular threshold. In some embodiments the spread that is compared to the particular threshold is the smallest rotation angle in the group subtracted from the largest rotation angle in the group. The use of a non zero threshold allows the grouping to account for minor errors in the content definition in the initially received document e.g. a line of text that is very slightly off of horizontal .

Process then analyzes at each rotation group separately. The process then ends. On most pages most of the analysis will involve the upright zero angle group. Some embodiments do not perform zone analysis for groups other than the upright group and instead simply classify the content of the rotated groups as children of the page as a whole. In some embodiments each rotation group has a coordinate system in which its content appears upright. In such embodiments each rotation group has its own zone tree with content that fits into the DOM for the document. Some embodiments define one rotation group for each distinguishable angle by which content on the page is rotated. The analysis on each group is described in detail below.

As shown in the process receives at a rotation group and normalizes the group to an upright coordinate system. In some embodiments normalizing the group to an upright coordinate system involves defining a coordinate system for the group such that all objects in the group are vertical or horizontal e.g. text lines are horizontal in the coordinate system . The following discussion assumes that the rotation group is the upright zero angle group. One of ordinary skill in the art would be able to apply the same techniques to rotation groups with non zero angles in a coordinate system in which their content appears upright. Some embodiments remove content from other rotation groups before performing zone identification for a particular rotation group. For instance some embodiments would remove text and image from page in before performing zone identification and analysis in the upright rectilinear coordinate system.

The process then identifies at potential zone borders. Potential zone borders in some embodiments include any horizontal or vertical graphic object that is sufficiently narrow. The determination of whether a particular graphic object is sufficiently narrow uses an absolute measure e.g. when the smaller dimension of the upright bounding rectangle of the graphic object is less than 1 24 of inch in some embodiments. In other embodiments the determination uses a relative measure e.g. the larger dimension of the upright bounding rectangle is eight times the size of the smaller dimension or a combination of absolute and relative measures e.g. the narrow dimension could be allowed to be up to 1 12 of an inch but the relative measure of 8 1 applies . Some embodiments adjust the threshold in relation to the size of the page. For instance the above examples might apply to a standard 8.5 11 inch page whereas a much larger page could have larger potential zone borders.

Referring to page includes several lines that would be classified as potential zone borders horizontal borders and vertical borders . However graphic object would generally not be considered a potential zone border because it is too thick in the x direction.

Some embodiments also identify all upright rectilinear shapes that have at least a threshold size and use the sides of these shapes as potential zone borders. In some embodiments the threshold size is a particular area whereas in other embodiments a threshold width and a threshold height must be surpassed. For instance object might have an area large enough to qualify its edges as potential zone borders but it is too narrow to be a separate zone. Star object on the other hand is not an upright rectilinear shape and as such its edges would not qualify as a zone border. As such these objects would simply be classified as content specifically graphic objects that are within one zone or another. Some embodiments set the bounds of each potential zone border identified as the side of an upright rectilinear shape as the upright rectangle bounding the side including the stroke width if stroked. Some embodiments also include the page borders as zone borders if they are upright rectilinear in the coordinate system of the rotation group.

After identifying potential zone borders process removes at borders or portions of borders that intersect with other objects on the page. For instance potential border is obscured by star object and as such would be broken into two potential zone borders the area above the star and the area below the star . Some embodiments also remove zone borders that intersect character bounding boxes. A character bounding box for a particular character in some embodiments is the smallest rectangle that completely encloses the character. For instance potential zone border crosses the characters Lorem Ipsum . As such some embodiments would remove potential zone border from consideration.

Next process merges at borders. Some embodiments merge borders that are parallel and either overlapping or close to overlapping. Borders overlap when their bounds intersect. For instance when two very narrow rectangles of different width are drawn such that one completely envelops the other the two potential zone borders would be merged. Some embodiments slightly expand the bounds both in width and length of the potential zone borders to test for overlap. Accordingly borders and in would be merged into one zone border with a thickness greater than that of borders and .

Process then determines at whether any merged borders remain unprocessed. When no borders were merged or all merged borders have been processed the process proceeds to described below. Otherwise the process selects at an unprocessed merged border. The process then determines at whether the merged border is too thick or includes too many zone border graphics. A merged border is too thick in some embodiments when its width in the narrow direction is above a particular threshold. In some embodiments the test for thickness is the same as whether a graphic object is narrow enough to be classified as a zone border initially. When the process determines that the border is not too thick the process proceeds to which is described above. Otherwise when the merged border is too thick the process removes at the merged border from the potential zone border candidates and classifies it as a single graphic object then proceeds to . For instance this could happen when an image is drawn as a series of narrow rectangles or a bar graph is drawn with narrow and closely spaced bars.

Once all merged borders are examined the process identifies at zone border intersections. As discussed above zone border intersections are identified wherever a horizontal border intersects a vertical border. Some embodiments also identify near intersections and classify these as intersections. To find near intersections borders are extended a small amount and then tested for intersection. Some embodiments extend the borders a fixed amount e.g. one fourth of an inch while other embodiments extend each borders an amount that is a percentage of the length of the particular zone border. When the lengthened borders intersect the near intersection is classified as an intersection and the two borders are extended to fully cross the thickness of the other. As an example borders and in do not quite intersect. However they are close enough that they would be classified as intersecting and are extended such that they intersect.

The process then eliminates at borders with less than two intersections. Once a border is removed any borders that intersected the removed border must be retested to determine whether they still have at least two intersections. In the example page border and the two remaining portions of border would be removed as they have no zone border intersections. Once the zone borders and intersections are identified the process trims at the zone borders to remove any portions extending past the outermost intersections. For instance the borders and extend past their intersection. These would be trimmed to extend only to the outermost bound of each other. After trimming the borders the process stores at the zone border and intersection information for future use e.g. in identifying zones . The process then ends.

At this point the zone border intervals and zone border intersections have all been determined. illustrates vertical zone border intervals and as well as horizontal zone border intervals and . also illustrates zone border intersections and .

Once the zone borders and zone border intersections are identified the zones can be identified. conceptually illustrates a process of some embodiments for identifying zones. Process will be described in conjunction with . illustrate the application of process to identify the zones of page . Each of the figures is illustrated as a sequence. illustrates a sequence to identify a first zone border. Arrows in illustrate direction vectors and dashed lines illustrate a path taken through the zone border intervals to define a zone. illustrates the zones identified by process .

As shown in process receives at zone borders and intersections for a group or page. In some embodiments the zone borders and intersections are the output of process described above. The process then determines at whether there are any zone border intervals. When there are none the process ends. Otherwise the process assigns at two direction vectors to each zone border interval i.e. horizontal intervals have vectors pointing right and left and vertical intervals have vectors pointing up and down . illustrates at that each of the border intervals for page starts with direction vectors in both directions.

Next the process selects at a border interval b an intersection i and a direction d. Some embodiments select the starting point randomly whereas other embodiments use a heuristic such as the top and left most intersection in a particular direction. illustrates a random selection of starting at intersection moving upwards along interval . Process then proceeds at in the direction d from intersection i until arriving at the next intersection.

Once the intersection is reached the process determines at whether the intersection is the starting intersection selected at . When the intersection is the original starting intersection the process proceeds to which is described below. Otherwise the process determines at whether the path through the zone border intervals can turn clockwise at the intersection. When the path can turn clockwise the path does so at . The process then proceeds to which is described below. When the path cannot turn clockwise the process determines at whether the path can continue straight through the intersection. When the path can continue straight then the path does so at . The process then proceeds to which is described below. When the path cannot continue straight the path turns at counterclockwise to the next border interval. By the choices made in steps and the process exhibits a preference for a clockwise turn at each border intersection. Some embodiments will instead exhibit a preference for counterclockwise turns which gives the same results.

The process sets at the new border interval as the current border interval b and the new intersection as the current intersection i. The process then sets at the direction d moving away from intersection i along border b. The process then proceeds to which was described above.

Once the original intersection is reached process defines at a zone Z as the set of border intervals traversed since operation . As noted above illustrates the traversal of a set of zone border intervals according to process . At after selecting interval moving up from intersection to start shown by the circle and short arrow in the figure the path comes to intersection . Turning clockwise is an option so the path turns at to interval then clockwise again at intersection to interval . The path turns at clockwise yet again at intersection to interval but then at intersection cannot either turn clockwise or continue straight through. Instead the path turns counterclockwise to interval then again at intersection to interval to proceed towards intersection . At intersection the path turns at clockwise to interval then clockwise again at intersection to interval . Interval returns to the path to the original intersection .

Process next removes at all border intervals with no remaining direction vectors. This will not occur after the first zone is identified but can happen after any of the further zones are identified. When the zone Z is an island i.e. a zone that shares no borders with its parent then the process classifies at the zone as such. In embodiments in which the preference is for clockwise turns then a zone defined by traversing its center in a counterclockwise direction will be an island.

The process then determines at whether any zone border intervals remain. When more zone border intervals remain the process proceeds to which was described above. Otherwise once all zone border intervals are used in both directions the process has defined all the zones for the page. The process then stores at the zone information. The process then ends.

Once the zones have been identified the zone graph zone tree can be generated. The zone tree is used in some embodiments in document reconstruction that is done on a zone by zone basis. conceptually illustrates a process of some embodiments for generating a zone tree. As shown the process receives at zones and content objects. In some embodiments these zones have been identified by a process such as process . The process then sorts at the zones by area. Some embodiments treat an island as larger than a non island when their areas are equal for the purposes of sorting the zones.

Next the process selects at the smallest zone as z. The process then determines at whether zone z has a node yet in the zone graph for the page. When z has a node the process proceeds to which is described below. Otherwise when z does not yet have a node the process defines at a node for zone z.

Next the process selects at the next smallest zone as zone p. The process then determines at whether zone p contains zone z i.e. whether the outer bounds of zone z are completely within the outer bounds of zone p . When zone p contains zone z the process determines at that zone z is a child of zone p. Based on this the process defines at a node for zone p in the node graph. The process then defines at an edge from zone p to zone z. The process then proceeds to which is described below.

When at the process determines that zone p does not contain zone z the process determines at whether there are any zones larger than the current zone p. When there are larger zones remaining the process proceeds to and selects the next smallest zone as zone p to test whether the new zone p is a parent of zone z. Otherwise when there are no zones larger than zone p the process determines at that zone z has no parent zones.

Next the process determines at whether there are any zones larger than zone z. When there are larger zones the process removes at zone z from the set of zones from which to select and proceeds to to select another zone for parent child analysis.

Once all zones have been analyzed the process proceeds to and determines whether there are any unprocessed content objects. When there are no content objects i.e. the document is blank except for zone borders or all content objects have been processed the process proceeds to described below. Otherwise the process proceeds to and selects a content object c. The process then defines at a node for the object c. A content object in some embodiments is a primitive object e.g. a glyph shape or image . The process then determines at the smallest zone x that contains content object c. Once the zone x containing content object c is determined the process defines at an edge in the zone graph from zone x to content object c. When all objects have been added the process stores at the zone graph. The process then ends.

In some embodiments the content in each zone is further analyzed e.g. grouping text into paragraphs identifying tables etc. . Furthermore as document reconstruction is performed some embodiments update the zone graph with content subtrees for each zone where those content subtrees include structure nodes that represent the hierarchical grouping of the primitive objects of the zone. By performing zone analysis first one ensures that content from different zones is not inappropriately grouped in the subsequent document reconstruction steps.

In some embodiments the identification of geometric attributes such as boundaries and the regions bordered by those boundaries e.g. zones sets the stage for further document reconstruction. For example profiles may depend on zone geometry and structure elements such as tables or text boxes may be recognized from the zone geometry.

In some embodiments the zone analysis processes described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates the software architecture of a zone analysis application of some embodiments for performing zone analysis on a document. In some embodiments the application is a stand alone application or is integrated into another application e.g. a document reconstruction application while in other embodiments the application might be implemented within an operating system.

Zone analysis application includes a border identification module an interval and intersection identification module a zone identification module and a zone graph builder as well as zone information storage .

The interval and intersection identification module receives zone border information from the border identification module and or the zone information storage . The interval and intersection identification module identifies zone border intersections and zone border intervals based on the potential zone borders identified by module . The identified zone border intersections and zone border intervals are passed to the zone identification module as well as storing in zone information storage . In some embodiments interval and intersection module identification performs some or all of process .

The zone identification module receives zone border information from the border identification module zone border intersection and zone border interval information from the interval and intersection identification module and or information from the zone information storage . Zone identification module identifies zones based on the information from modules and . The identified zones are passed to the zone graph builder as well as storing in the zone information storage . In some embodiments zone identification module performs some or all of process .

The zone graph builder module receives zone information from the zone identification module and or the zone information storage as well as content information from the document content . Zone graph builder defines the zone graph for a document based on the zone information and populates the zone graph with content information. In some embodiments the zone graph builder populates the zone graph as content information is identified by other reconstruction processes such as those described in the Sections below. In some embodiments zone graph builder performs some or all of process .

In some embodiments the results of the processes performed by the above described modules or other modules are stored in an electronic storage e.g. as part of a document object model . The document object model can then be used for displaying the document on an electronic display device e.g. a handheld device computer screen etc. such that a user can review and or interact with the document e.g. via touchscreen cursor control device etc. .

Some embodiments of the invention provide methods for identifying geometric attributes such as boundaries e.g. alignment guides and unfilled space e.g. gaps of unfilled white space between groups of glyphs called gutters in a document or portion of a document. In some embodiments a gutter is the white space between two alignment points e.g. between a right alignment point and a left alignment point . Identification of guides and gutters is used in subsequent reconstruction procedures such as column identification and splitting of text lines in some embodiments. Some embodiments identify guides and gutters on a zone by zone or page by page basis.

The process then applies at cluster analysis to determine guides of the received document portion. Cluster analysis enables the process to determine x coordinates where the ends or beginnings of words are grouped together making those x coordinates likely alignment guides. As mentioned illustrates a page with two columns of text. Page includes as set of guides . Some embodiments determine bottom and top lines of columns as guides whereas other embodiments only determine left and right alignment guides. Some embodiments also identify guides for other alignments such as center alignment or the alignment of decimal points in listings of numbers. Cluster analysis and the guide determination process are described in further detail below.

Next the process determines at the gutters of the document portion. Some embodiments use information from operation to determine the gutters. illustrates a gutter that is determined for page between the right alignment guide of column one and the left alignment guide of column two. Some embodiments treat the page margins as gutters while other embodiments do not. Once the guides and gutters are determined the process uses at the guides and gutters for further reconstruction of the document. The process then ends.

Some embodiments determine right and left alignment guides by searching for text lines that start or end at the same or nearly the same x coordinate on a page and determining whether sufficient evidence exists that the x coordinate is actually an alignment point. Some embodiments use a form of cluster analysis called density clustering to determine alignment guides. The density clustering of some embodiments takes advantage of the memory and processing efficiencies described below in Section VI so that it can be performed on a resource limited device e.g. an iPhone .

Density clustering is often applicable to problems in which there is a substantial amount of noise or random data mixed in with otherwise clearly visible clusters. When the data is a set of real numbers the clusters are identified as subsets that optimally meet given density constraints. The constraints are generally designed to pick out subsets that are relatively denser than others. For instance some embodiments use a minimum size of a cluster and a maximum spread of a cluster as constraints.

The process then sorts at the set of input data. Some embodiments sort the data in ascending order while other embodiments sort the data in descending order. For instance in the case of using density clustering to determine alignment guides the data x coordinate values is sorted from lowest to highest x coordinate value such that if two x coordinate values are equal they are next to each other in the sorted data unless there are other words with the same x coordinate value that fall in between the two . Some embodiments create a new array for the sorted data while some embodiments use an indirectly sorted array of indices as described below in Section VI.

Next process determines at whether the set has at least two pieces of data. If not then the process ends as there is nothing to cluster. Otherwise the process proceeds to determine at the set of differences between subsequent data in the sorted set. Such a set will have one less value than the set of input data. As an example when there are three words on a page the two values in the set of differences are the difference between the x coordinate values of the first and second words and the difference between the x coordinate values of the second and third words.

Next the process sets at a variable d to the largest unevaluated difference in the set of differences. For instance when the differences for a set of words are 0.7 inches 0.2 inches 0.0 inches and 0.4 inches then the variable d would initially be set to 0.7 inches. The process then partitions at the sorted data wherever the difference is greater than or equal to d to generate a set of subsets of the data. The first partition will always partition the sorted data only at differences equal to d because d will be set to the largest difference. In the above example of five data values with differences of 0.7 0.2 0.0 and 0.4 the partitioning would generate two subsets the first value in one subset and the other four in the other subset .

The process then determines at the set S of subsets that satisfy particular constraints for the problem being solved. In some embodiments the purpose of the constraints is to determine subsets that are relatively denser than the other subsets. Some embodiments use two density constraints a minimum cluster size i.e. the minimum number of values in the subset and maximum cluster spread i.e. the largest allowed difference between the largest and smallest values in the subset . In the case of using density clustering for determining alignment guides some embodiments use a minimum cluster size that is a fraction of the total lines in the page or zone being evaluated while other embodiments use a constant. Some embodiments use a maximum spread that is a fraction of the median font size of the first for left alignment or last for right alignment characters of words.

Once the set S of subsets that satisfy the constraints are determined the process determines at whether S is empty. When S is empty the process proceeds to which is described below. When S includes at least one subset the process evaluates at an optimization function for S. Some embodiments use an optimization function that looks for the set S that has the largest subset that meets the constraints. Other embodiments use an optimization function tries to maximize the sum of the squares of a particular value e.g. the size of the subset minus the minimum cluster size over all of the subsets that meet the constraints. Yet other embodiments use one of the above mentioned optimization functions and then use the other in case of a tie. Other optimization functions are used by other embodiments.

Next the process determines at whether the set S is the most optimal so far based on the optimization function. When S is not the most optimal the process proceeds to which is described below. Otherwise when S is the most optimal the process stores at S as the best set of clusters yet found. The first pass through in which d is the largest difference will always be the most optimal at that point if S is not empty. On subsequent passes the current S will be compared to the stored set of clusters.

The process then determines at whether there are any unevaluated differences. Some embodiments test each possible partition to find the most optimal set of clusters. Some such embodiments use the efficiency techniques described below in Section X to enable faster and more efficient processing. When the process determines that there are unevaluated differences the process proceeds to which was described above.

Otherwise once all the differences have been evaluated the process outputs at the currently stored optimal set or empty set if no clusters satisfying the constraints were found as the final set of clusters. In the case of determining alignment guides the final set of clusters would be groups of words with very close x coordinates. The process then ends. One of ordinary skill will recognize that in addition to the density constraints and optimal measure process imposes a consistency constraint on the clusters namely that intra cluster differences between successive values in a cluster will never equal or exceed inter cluster differences because the data is always partitioned at all differences that are equal to or greater than a specified gap minimum.

As mentioned above some embodiments determine right and left alignment guides by searching for associated sets of glyphs e.g. words text lines that start or end at the same or nearly the same x coordinate on a page and determining whether sufficient evidence exists that the x coordinate is actually an alignment point. Some embodiments use similar but not identical processes to find left alignment guides and right alignment guides.

The process then determines at desired cluster properties. In some embodiments the cluster properties are the constraints for density clustering described above. Some embodiments use two density constraints a minimum cluster size i.e. the minimum number of values in the subset and maximum cluster spread i.e. the largest allowed difference between the largest and smallest values in the subset . In the case of using density clustering for determining alignment guides some embodiments use a minimum cluster size that is a fraction of the total lines in the page or zone being evaluated while other embodiments use a constant. Some embodiments use a maximum spread that is a fraction of the median font size of the first for left alignment or last for right alignment characters of words. One example of constraints are that the minimum cluster size is 5 of the total number of text lines in the region and the maximum spread is 10 of the median font size.

Next the process applies at density clustering to the input data using the determined cluster properties to determine clusters of x coordinate values that may be alignment guides. Some embodiments use process as described above.

Process then determines at whether there are any unevaluated clusters. When there are no clusters or all clusters are evaluated the process ends. Otherwise the process selects at a cluster i.e. one of the clusters output from the cluster analysis . The process then sets at a left alignment guide as a rectangle with the minimum and maximum x coordinates as the smallest and largest values in the cluster and the minimum and maximum y coordinates as the top and bottom of the page. In some cases the minimum and maximum x coordinate will be the same as all the x coordinates in the cluster will have the same value. In other cases small aberrations or words that accidentally make it into the cluster will give the rectangle a non zero width.

Process then removes at the rectangle at y coordinates that do not satisfy constraints based on an analysis of words that start in the rectangle and words that cross the rectangle. The process then proceeds to described above. Some embodiments remove a portion of the rectangle anywhere that a word starts left of the rectangle and crosses into the rectangle. The rectangle is also removed at any y coordinate that is between two crossing words that do not have a sufficient number of border words between them. A border word is a word that starts in or at one of the edges of the rectangle. Some embodiments use a requirement that there be at least five border words between crossing words and at least one of those five border words must be the leftmost on its text line or separated from the previous word on its text line by more than a normal word gap. Some embodiments use processes described in United States Publication No. 2007 0250497 entitled Semantic Reconstruction by Mansfield et al. which is incorporated herein by reference to determine word gaps and larger gaps. Some embodiments use different requirements e.g. fewer or greater than five border words between crossing words to perform operation .

As mentioned above some embodiments use a process similar to process for determining right alignment guides. conceptually illustrates a process of some embodiments for determining right alignment guides. As shown the process sets at the input data for density clustering as the x coordinates of the right edge of words in a region of a document. The region is a page or a zone of a page in some embodiments. In some embodiments the right edge of a particular word is the x coordinate of the anchor of the last glyph in the particular word plus the x coordinate of the advance vector for the last glyph in the word adjusted to the right alignment position expected for the glyph.

The process then determines at desired cluster properties. In some embodiments the cluster properties are the constraints for density clustering described above. Some embodiments use two density constraints a minimum cluster size i.e. the minimum number of values in the subset and maximum cluster spread i.e. the largest allowed difference between the largest and smallest values in the subset . In the case of using density clustering for determining alignment guides some embodiments use a minimum cluster size that is a fraction of the total lines in the page or zone being evaluated while other embodiments use a constant. Some embodiments use a maximum spread that is a fraction of the median font size of the first for left alignment or last for right alignment characters of words. One example of constraints are that the minimum cluster size is 5 of the total number of text lines in the region and the maximum spread is 10 of the median font size.

Next the process applies at density clustering to the input data using the determined cluster properties to determine clusters of x coordinate values that may be alignment guides. Some embodiments use process as described above.

The process then determines at whether there are any unprocessed clusters. When there are no clusters or all clusters have been processed the process ends. Otherwise the process selects at a cluster i.e. one of the clusters output from the cluster analysis . The process then sets at a right alignment guide as a rectangle with the minimum and maximum x coordinates as the smallest and largest values in the cluster and the minimum and maximum y coordinates as the top and bottom of the page. In some cases the minimum and maximum x coordinate will be the same as all the x coordinates in the cluster will have the same value. In other cases small aberrations or words that accidentally make it into the cluster will give the rectangle a non zero width.

The process then removes at the rectangle at y coordinates that do not satisfy constraints based on an analysis of words that end in the rectangle and words that cross the rectangle. The process then proceeds to described above. Some embodiments remove a portion of the rectangle anywhere that a word crosses or starts in the rectangle and ends right of the rectangle. The rectangle is also removed at any y coordinate that is between two crossing words that do not have a sufficient number of border words between them. A border word is a word that ends in or at one of the edges of the rectangle. Some embodiments use a requirement that there be at least five border words between crossing words and at least one of those five border words must be the rightmost on its text line or separated from the next word on its text line by more than a normal word gap. Some embodiments use processes described in United States Publication No. 2007 0250497 to determine word gaps and larger gaps. Some embodiments use different requirements e.g. fewer or greater than five border words between crossing words to perform operation .

After determining the guides some embodiments then determine gutters of the region e.g. zone page etc. . Some embodiments use information from the guide determination process e.g. processes and to determine the groupings of unfilled white space between associated glyphs e.g. gutters of the region. Some embodiments also use other alignment points in addition to guides for determining gutters in a region.

As shown in the process receives at alignment information. In some embodiments this information is the guides determined by processes and . Some embodiments include other alignment points as well as guides. For instance in some embodiments the end of text lines in left aligned not justified text are treated as right alignment points. This enables gutters to be identified in column gaps even if no guide is found at the right edge of the first column. Similarly the left edge of right aligned text or both edges of centered text are considered alignment points in some embodiments.

Process then determines at whether there are any unprocessed right alignment points. When there are no right alignment points or all have been processed the process ends. Otherwise the process selects at a right alignment point. In some embodiments the process identifies the leftmost right alignment point first while in other embodiments it picks a random right alignment point.

The process then determines at whether a left alignment point exists between the selected right alignment point and the right edge of the region. When there are no left alignment points the process proceeds to which was described above. Otherwise when there is at least one left alignment point between the right alignment point and the region edge the process identifies at the next left alignment point moving right across the region from the selected right alignment point. It is the area between these two points that the process tests to determine if there is a gutter.

Once the right and left alignment points are identified the process sets at a gutter as a rectangle with the right alignment point as the minimum x coordinate and the left alignment point as the maximum x coordinate. The minimum and maximum y coordinates of the rectangle are the top and bottom of the page. illustrates the page and a rectangle that is to be tested as a possible gutter. The minimum x coordinate is the right alignment point at the right edge of the first column and the maximum x coordinate is the left alignment point at the left edge of the second column.

Next the process removes at the gutter at y coordinates that do not satisfy constraints based on an analysis of words that cross into the rectangle and border the rectangle. Some embodiments remove a portion of the rectangle anywhere that a word crosses into or starts in the rectangle. The rectangle is also removed at any y coordinate that is between two crossing words that do not have a sufficient number of border words between them. A border word for a gutter is a word that ends at the left edge of the rectangle or starts at the right edge of the rectangle. Some embodiments use a requirement that there be at least five border words between crossing words and at least one of those five border words must be either the leftmost on its text line or separated from the previous word on its text line by more than a normal word gap or the rightmost on its text line or separated from the next word on its text line by more than a normal word gap. Some embodiments use processes described in the above mentioned United States Publication No. 2007 0250497 to determine word gaps and larger gaps. Some embodiments use different requirements e.g. fewer or greater than five border words between crossing words to perform operation . The process then proceeds to which was described above.

Some embodiments use the guides and gutters throughout the semantic reconstruction process. For example gutters are used to split text lines and identify columns processes that are described below in Section IV.

In some embodiments the guide and gutter analysis processes described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates the software architecture of a guide and gutter analysis application of some embodiments for identifying guides and gutters in a document. In some embodiments the application is a stand alone application or is integrated into another application e.g. a document reconstruction application while in other embodiments the application might be implemented within an operating system.

Guide and gutter analysis application includes a guide identification module a density clustering module and a gutter identification module as well as guide and gutter information storage .

The guide identification module also passes information to and receives information from the density clustering module . Density clustering module receives input data from the guide identification module and or the guide and gutter information storage and performs density clustering on the input data in order to determine potential guides. In some embodiments density clustering module performs some or all of process .

The gutter identification module receives information from the guide identification module and the document content . The gutter identification module analyzes the received information to identify gutters in the document. The identified gutters are passed to the guide and gutter information storage and to the document content . In some embodiments gutter identification module performs some or all of process .

In some embodiments the results of the processes performed by the above described modules or other modules are stored in an electronic storage e.g. as part of a document object model . The document object model can then be used for displaying the document on an electronic display device e.g. a handheld device computer screen etc. such that a user can review and or interact with the document e.g. via touchscreen cursor control device etc. .

Documents generally have an implicit structure and flow of content. Specifically in some cases ordered sequences of characters and inline graphics make up words ordered sequences of words make up text lines or span text lines with a hyphen ordered sequences of text lines make up paragraphs ordered sequences of paragraphs make up columns or span columns ordered sequences of columns make up layouts and ordered sequences of layouts make up sections of a document. When this structure is not provided in the file format of an electronic document the structure has previously been inaccessible to software. While merely viewing a document does not necessarily require document structure applications for editing importing searching styling or otherwise repurposing a document do require knowledge of the document structure and flow in order to function properly.

Some embodiments of the invention provide methods for determining the layout and flow of a document or a region of a document. This includes determining the semantic hierarchy e.g. the words lines and paragraphs of a document as well as layout properties such as the columns and how the columns fit together for intended reading of the document. In some embodiments the goal of the processes is to identify the order in which a human would read a document from start to finish.

The process then identifies at lines of text in the received document. This includes identifying characters that share a common baseline and merging preliminary lines together when necessary e.g. subscripts and superscripts . illustrates the identification of lines and . The line identification process of some embodiments is described in further detail below in subsection A.

Next the process identifies at words in the text. Some embodiments use difference clustering as described in above mentioned United States Publication No. 2007 0250497 to identify words in the text. illustrates the identification of words on page including the word Lorem from line and the word amet from line . The word identification process is also described in further detail below in subsection B

The process then splits at the lines of text where the text is discontinuous. illustrates that line is split into lines and and line is split into lines and . The line splitting process of some embodiments is described in further detail below in subsection C.

After splitting the lines the process places at the text lines into paragraphs. illustrates paragraphs and identified on page . The paragraph identification process is described in further detail below in subsection D.

Lastly the process places at the paragraphs into columns and layouts. illustrates columns and identified on page . The column and layout identification process is described in further detail below in subsection E.

Some embodiments do not perform all of the operations of process at once. Instead some perform other document reconstruction processes in between operations of process . For example some embodiments determine lines of text and the words in the text but then identify guides and gutters prior to splitting the lines of text.

As mentioned above in some embodiments lines of text have to be identified. Because every character in a particular line of text will not necessarily always share a common baseline some embodiments attempt to merge lines together based on evidence that the characters in the two lines are intended to be read as part of the same line of text e.g. superscripts and subscripts .

As shown in the process receives at a portion of a document. In some embodiments the portion is a page of a document or a zone of a page etc. The process then determines at whether there are any characters in the document portion. When there are none the process ends. Otherwise the process associates at as preliminary text lines characters that share a common baseline. Characters share a common baseline in some embodiments when they have the same y coordinate anchor point. In general associating characters that share a common baseline will group together lines of standard text. Some embodiments use a small threshold such that the y coordinate anchor points in a preliminary text line need not be exactly equal but must be within the small threshold of each other.

Next the process identifies at groups of text lines that vertically overlap. Two lines vertically overlap in some embodiments when the bounding rectangle of the first line overlaps in y coordinate values with the bounding rectangle of the second line. illustrates the page with six groups of vertically overlapping text lines lines and lines and lines and lines and lines and and lines and . Line is associated in a group with line because both overlap with line even though they do not overlap each other. Even though there is no horizontal overlap because lines and vertically overlap they are initially grouped together in some embodiments.

The process then selects at an unevaluated group and partitions at the group into sections with no horizontal overlap between text lines of different sections. Two text lines horizontally overlap in some embodiments when the x coordinates of the bounding box of the first text line overlap with the x coordinates of the bounding box of the second text line. For instance lines and are partitioned at this point because they do not horizontally overlap and thus would not be likely to be considered the same line. Some embodiments expand the measure of horizontal overlap a small distance e.g. one half of a space character at the beginning and end of the text lines so that offset characters e.g. subscripts and superscripts at the beginning or end of a line are merged. For example there is no horizontal overlap between lines and but they are not partitioned because the end of line is close enough to the beginning of line .

After partitioning the selected group the process selects at an unevaluated section from the group and sorts at the lines in the section from top to bottom. Thus if the selected section with lines is selected the lines would be sorted with line first line second and line third. Various embodiments sort the lines by ascent descent baseline or other measure of the vertical position of a line.

The process then selects at the top most unevaluated line in the section. Next the process selects at the first reading from the left for left to right languages unevaluated character in the selected line. The process determines at whether the selected character can be merged into the next line. Some embodiments allow a character to be merged into the next line when the selected character does not horizontally overlap significantly with any character in the next line. Some embodiments allow some small amount of horizontal overlap between characters. For left to right languages some embodiments allow less overlap on the left of the character to be merged down than on the right of the character to be merged down in order to account for common spacing adjustments for offset characters.

Furthermore some embodiments allow any amount of overlap when the original insertion order of the overlapping characters is adjacent. The insertion order in some embodiments is the order in which the characters are drawn on the page. Often though not always characters are drawn in the order they are meant to be read so when two vertically and horizontally overlapping characters are adjacent in the insertion order it is likely they are intended to be read together.

When the process determines that the selected character can be merged into the next line the process merges at the selected character in to the next line. The process then proceeds to which is described below. Otherwise when the selected character cannot be merged the process keeps at the selected character in the selected line.

Next the process determines at whether the selected line includes more characters. When there are more characters in the currently selected line the process proceeds to to select the next unevaluated character in the line. Otherwise when all characters in the line have been evaluated the process determines at whether the current section includes more lines. When there are more lines in the currently selected section the process proceeds to to select the next unevaluated line.

Otherwise when all lines in the section have been evaluated the process determines at whether the selected group includes more sections. When there are more sections in the currently selected group the process proceeds to to select another section and merge lines in that section. Otherwise when all the sections in the group have been evaluated the process determines at whether there are any more groups to evaluate in the document portion. When there are more groups the process proceeds to to select another group. Otherwise when all groups have been evaluated then line merging is finished for the document portion and the process ends.

Lines cannot be fully merged. The character b in line is initially merged down into line . Then the character A in line is merged down into line as it does not overlap with the character c . However character b is not merged down into line because it completely overlaps with character c . Thus line only includes b line includes A and c and line is empty. As described above some embodiments will merge b into line if b and c are adjacent in the insertion order.

Similarly lines and are not merged. All of the characters in line significantly overlap one or more characters in line and therefore are not merged down into line . It is unlikely that the T in line would be between the h and n of line in the insertion order for page . Lastly lines and are not merged because there is no horizontal overlap between the lines and thus they are partitioned at operation .

After the lines are identified and merged words are identified in some embodiments. Some embodiments use difference clustering as described in United States Publication No. 2007 0250497 to identify words based on spacing between letters within a word and between words. In some embodiments the difference clustering also provides information about segment gaps column gaps etc. Some embodiments use the memory and processing efficiency techniques described below in Section VI to perform difference clustering.

In some embodiments cluster analysis is a set of techniques that can be applied to a collection of data points to group points into clusters that are closer to each other than to the points of another cluster. In some embodiments cluster analysis is applied to data points that represent the horizontal and vertical gaps between objects such as glyphs words and text lines. For example some embodiments use k means cluster analysis which will now be described. Starting with a collection of numbers p . . . p representing spatial gaps and a known value for k the number of clusters the technique is used to partition the numbers into k clusters C . . . Cdefined by inequalities of the form C p a p

In some embodiments a technique disclosed and referred to herein as difference clustering is used to determine the number of levels of structural relationships that exist between content elements comprising a given source content and or one or more hierarchical relationships between such levels as well as one or more characteristics that can be used to determine whether a content element is related to another content in each of the determined levels. In some embodiments difference clustering utilizes the k means technique together with other techniques. In the example shown in differences between positions of content elements spacing are analyzed using difference clustering analysis. In some embodiments by analyzing the spacing between content elements the content elements can be grouped at least in part using the grouping data of the spacing. In some embodiments each directional component of spacing is analyzed separately. For instance difference clustering analysis on the horizontal component is used to distinguish between character spacing word spacing and column spacing. Difference clustering analysis on the vertical component can be used to distinguish line spacing paragraph spacing and text box spacing in some embodiments. Process conceptually illustrates difference clustering analysis for a single directional component. The process may be used again to analyze one or more additional directional components. In some embodiments the results of performing difference cluster analysis along one or more dimensions are combined together to determine the structural relationships between content elements at one or more levels.

As shown in process receives at a portion of a document. The process then identifies at the locations of elements in the document. In some embodiments the elements include characters glyphs images lines drawings boxes cells margins and or various other content elements. In some embodiments locations of the elements include determining and or assigning one or more location coordinate components to the elements. In some embodiments the locations of the elements are organized in an order. For example when analyzing the horizontal spacing of characters the characters are organized in increasing horizontal coordinate order for each line of characters. In some embodiments the location coordinate values of the elements are desired to be associated with the spacing between the elements and the location values are compensated for the width length of the element. For example when determining a compensated horizontal coordinate x coordinate value for an element in the n th position of an organized order of elements the following formula is used 

Next the process determines at the first order differences between locations of adjacent elements. In some embodiments an element is adjacent to another element when the two elements with at least one same location coordinate component value are ordered next to each other in at least one other location coordinate component value. For instance two glyphs are adjacent to each other if both of the glyphs belong to the same text line and no other glyph exists between them. In some embodiments two elements have at least one same location coordinate component when the difference between corresponding location coordinate component values of the elements is below a limit value or within a range value. In various embodiments an element is adjacent to another element when the two elements are next to each other in an order and or organization associated with the identified locations of the elements. In some embodiments the first order difference between the locations is the difference between the width length compensated location coordinate values. For instance when determining the difference between compensated horizontal coordinate x coordinate values for the adjacent elements in the nth and n 1 position of an organized order of compensated horizontal coordinates in some embodiments the following formula is used. In some embodiments the first order difference is associated with the gap spacing between glyphs in the content.

Next process sorts at the first order differences. In some embodiments organizing the first order difference includes ordering the first order differences in an increasing order. In some embodiments organizing the first order differences includes assigning a weight value to one or more of the first order differences and organizing the first order differences at least in part by using the weight value s . For instance in some embodiments actual glyph spacing is divided by expected glyph spacing for each specific pair of glyphs given the font that is used and its font metrics including size default letter spacing and a table of kerning values stored with the font file. This ratio of actual to expected spacing is ordered by increasing value and the values of this ratio are used in place of the first order differences throughout the remainder of the difference clustering method.

The process then determines at second order differences between the sorted first order differences. For instance when determining the second order difference between first order differences in an i th and i 1 position of an organized order of first order differences the following formula is used where Xis the i th second order difference Xis the first order difference in the i th position of the sorted first order differences and Xis the first order difference in the i 1 position of the same sorted first order differences. In some embodiments the second order differences are associated with differences between the spacing of glyphs.

Next process determines at the number of cluster levels by analyzing the second order differences. In some embodiments analyzing the second order differences includes organizing the determined second order differences. In some embodiments organizing the second order difference includes ordering the second order differences in an increasing order and or plotting the second order differences in an order of increasing second order difference values. In some embodiments organizing the second order difference includes assigning a weight value to one or more of the second order difference. In some embodiments organizing the second order difference includes grouping the second order differences into one or more groups. In some embodiments the second order differences are each categorized as either an inter group difference or an intra group difference.

Intra group differences are associated with relatively smaller second order difference values and can represent second order differences of first order differences within the same clustering group. An example of an intra group difference is the relatively small variation one would expect to find in the character width compensated spacing between letters in the same word. Inter group differences are associated with relatively larger difference values and can represent second order differences of first order differences between different clustering groups. An example of an inter group difference is the relatively large difference between the space between two words on the one hand and the space between two letters in the same word on the other.

In some embodiments the categorization of second order differences into intra group and inter group values is achieved by applying 2 means cluster analysis to the ordered second order difference values specifically taking p . . . p to be X . . . X in increasing order. Similarly any other technique of cluster analysis that is sufficient to distinguish two clusters of data values can be applied to the ordered second order difference values. The intra group differences are then in the first cluster C p a p

The process then determines at characteristics of each cluster level. The process then ends. In some embodiments determining the characteristics includes determining which first order difference and or what range of first order differences is associated with which cluster level. In some embodiments determining the characteristic includes computing a statistical value associated with the first order differences associated with a cluster level. For example by determining the average minimum maximum of the portion of first order differences associated with a cluster level the average minimum and maximum spacing between glyphs in the content can be determined.

Let L be the number of levels of clustering. In some embodiments L is computed by counting the number of points in the second cluster of second order differences and adding 1. Next the groups of first order differences corresponding to each level can be identified and the clusters of compensated X values can be identified at each level for example in one of the following two ways.

One possibility is to perform L means cluster analysis on the first order differences. The resulting L clusters are the groups of first order differences corresponding to each level. Next the number Kof clusters of X at level m are computed by adding the number of points in the m 1 th m 2 th . . . and Lth clusters of first order differences plus 1. Finally perform K means analysis on the compensated X values to produce the Kclusters at level m.

A second possibility is when originally computing each first order difference X X X to store its value together with the index n that can be used to identify either one of the pair of successive X values that were subtracted to produce that difference. Store the value and the index reference in a single first order difference data structure. Similarly when originally computing each second order difference store its value together with an index reference that can be used to identify either one of the pair of successive first order difference data whose values were subtracted to produce that difference. Now for each second order difference that is in the second cluster i.e. for each inter group difference use its index reference to identify a partition point in the first order differences. This means that the index identifies a pair of first order difference values that are partitioned to be in separate clusters. Partitioning in this way produces L clusters of first order differences corresponding to the L levels of clustering in the original data. Now the clusters of X values at level n are identified as follows for each first order difference data in the m 1 th m 2 th . . . and Lth cluster of first order differences use its index reference as a partition point in the X values.

In the example shown the data are associated with horizontal spacing between glyphs. By ordering the first order difference values the example illustrates three groups of first order difference values and . First order difference value group is associated with spacing between glyphs that compose words. First order difference value group is associated with spacing between words. First order difference value group is associated with spacing between columns. For each pair of adjacent first order difference values a second order difference value i.e. the difference between one first order difference and an adjacent first order difference is determined and plotted in an increasing order on a line associated with second order difference values. Second order difference value group and each include one or more points associated with the second order difference values. In some embodiments point is a member of a group of associated second order difference points comprising a second order difference value group.

In some embodiments point is a member of a group of associated second order difference points comprising a second order difference value group. In some embodiments is identified as one cluster and together with is identified as a second cluster. Second order difference values between the first order difference values within the same single first order difference value group intra group differences are included in second order difference value group . In a text document for example typically the character width compensated spacing between characters within a word or in the spacing between different pairs of words varies only slightly. The second order difference between inter group adjacent points in group and is included in point . The second order difference between inter group adjacent points in group and is included in point . Since there exists two inter group second order difference values in the example there are two plus one three grouping levels in this example words sentences or parts thereof on a line of text within a column and columns . By determining the minimum and maximum of the first order difference values in group minimum and maximum spacing between glyphs that compose words can be determined and similarly group and can be used to determine word spacing and column spacing respectively.

In some embodiments the minimum and maximum spacing associated with each grouping level is used to group content elements e.g. glyphs accordingly such as by identifying groups of characters that comprise words group words into lines of text within a column etc. By using data determined from cluster analysis the glyphs are grouped into the determined levels of groupings. It is possible to perform the analysis quickly and automatically with respect to any arbitrary content in part because it is not necessary to know in advance how many grouping levels there are in the structure of the content or other collection of elements being analyzed. Regardless of the number of grouping levels the number of levels is determined in just two processing steps. By determining the average of the first order difference values in group the average spacing between glyphs that compose words can be determined. Similarly other statistical quantities can be determined for the glyphs that compose words. Similarly an analysis of the first order difference values in group and can be used to determine statistical quantities relevant to word spacing and column spacing.

Some embodiments split text lines after word and segment break information is generated. Text lines are split for example where the text line spans more than one column as the text in the two or more sections is probably not meant to be read together. Some embodiments use guide and gutter information derived from processes described above in Section III along with information from difference clustering e.g. segment gaps etc. in order to split the text lines.

Next the process sorts at the received text lines based on the y coordinate of their baselines. Starting at the bottom of the page the process selects at the bottom most unevaluated text line and identifies at potential splits in the selected line. Some embodiments define a potential split as any gap between two words in a line either 1 is a segment gap as defined by difference clustering or 2 has a guide or gutter passing through it. Other embodiments only use one or the other or different definitions for potential splits.

The process then determines at whether any potential splits were identified. When none were identified the process proceeds to described below. Otherwise the process selects at a potential split from the currently selected text line. The process then determines at whether the x interval of the potential split overlaps with the x interval of any potential split from the previous text line. The first text line evaluated will not have a previous text line and therefore there will be no overlapping potential splits. When the x interval of the currently selected potential split does not overlap with the x interval of a potential split from the previous line the process proceeds to which was described above. Otherwise the process associates at the overlapping potential splits. The process then proceeds to which was described above.

When there are no more unevaluated potential splits the process determines at whether there are more lines to evaluate. When more lines remain the process proceeds to to identify potential splits in the next line and test them for overlap.

When all lines have been evaluated then all the potential splits in the document portion have been identified and associated. The process then performs several operations to eliminate false positives i.e. potential splits that should not actually split a line of text . The process determines at whether any groups of potential splits were identified. When none were identified the process ends. Otherwise the process selects at a group of associated potential splits and defines at a rectangular strip passing completely through the potential splits of the selected group. The strip in some embodiments has an x interval that is the intersection of the x intervals of all the potential splits in the selected group i.e. the x interval for a strip two of whose potential splits barely overlap will be very thin .

After defining the rectangular strip for the selected group the process determines at whether the strip spans fewer than a threshold number of text lines. Strips that span one or only a few text lines are not likely to represent an actual split in reading but rather may be tabs within a line or other non breaking gaps. Sometimes segment gaps are found by difference clustering where a gap between words is very large due to justified text. When the strip spans fewer than the threshold number of lines the process removes at the group from the list of potential splits and will not split the text lines at those locations. The process then proceeds to which is described below. On page the potential splits making up strips and are removed because they do not have enough splits to be a likely column break. More likely the potential splits are tabs or large word gaps.

When the strip spans at least the threshold number of lines the process determines at whether the current strip is within a threshold distance of another strip. Some embodiments only look to prior strips that have been tested and not yet removed when determining whether another strip is within a threshold of the current strip. When the current strip is within the threshold distance of another strip the process removes at the group with a vertically shorter strip in some cases where the lines are all the same size this is the strip that spans fewer text lines . The process then proceeds to which is described below.

Strips and of page both qualify as spanning enough text lines to pass operation . However in some embodiments the strips are too close to each other to both be kept. Accordingly the group of potential splits making up strip is removed because is the longer of the two strips. This process prevents list bullets or number from being split from the items they reference in some embodiments as well as other potentially problematic splits.

When the current strip is not too close to another strip the process determines at whether the strip includes a threshold number of subsequent potential splits in a row that are not segment gaps. In some embodiments it is possible to identify a guide and or gutter where word edges accidentally align. This is especially likely if the text is displayed in a monospace font e.g. Courier . When the strip includes at least this threshold number of subsequent non segment gap potential splits the process removes at the group from the list of potential splits and will not split the text lines at those locations.

Next the process determines at whether there are more groups of potential splits that have not been tested against the various threshold requirements. When more groups remain the process proceeds to to select and evaluate the next group of potential splits. Otherwise when all groups have been evaluated the process splits at the text lines using any of the splits that have not been removed. The process then ends. In the case illustrated for page the only splits that would be used are those in the center separating the two columns of text.

While process is illustrated using three specific tests operations and to remove groups of potential splits some embodiments employ only a subset of these while other embodiments use other tests that are not shown in order to eliminate potential splits from consideration.

In some embodiments once lines of text have been merged and split the lines are grouped into paragraphs. conceptually illustrates a process of some embodiments for grouping text lines into paragraphs. Portions of process will be described in conjunction with . illustrates the identification of paragraphs on a page of a document. As shown in process receives at text lines for a portion of a document. The text lines have already been merged e.g. by process and split e.g. by process in some embodiments before process is performed. In some embodiments the document portion is an entire document a section of a document a page a zone etc.

The process determines at whether there are any lines in the document portion. When there are none the process ends. Otherwise beginning at the top of the received document portion the process selects at the first unevaluated text line in the document portion. The process then determines at whether there is more than one text line below the selected line. In some embodiments the lines must be within a particular vertical distance of each other for the lower line to be considered below the selected line for the purposes of operation . Some embodiments require at least three text lines to make judgments about whether the text lines belong to the same paragraph. In some embodiments this requirement is imposed because two spacings i.e. the spacing between the first and second text lines and between the second and third text lines are necessary in order to make a comparison.

When there are two or more lines below the selected text line the process proceeds to which is described below. Otherwise when fewer than two lines are below the selected text line the process places at the selected line in a paragraph by itself. The process then determines at whether there are more lines in the document portion. When there are no more lines e.g. when there is only one line of text in the document portion the process ends. Otherwise when there are more lines the process proceeds to and selects the next line of text.

When at there are two or more lines of text below the line selected at i.e. the first line in the current paragraph the process identifies at the next two lines below the selected text line. The process then determines at whether the spacing and alignment is consistent between the three lines. In some embodiments this determination involves examining whether the vertical distance from the first to second line is the same as the vertical distance from the second to third line. Some embodiments use the baselines of the text lines to determine the vertical spacing. Alignment differences in some embodiments are identified if one of the lines begins indented or ends left of the other lines thus signaling a likely beginning or end of a paragraph.

When the spacing and alignment is not consistent the process applies at heuristic rules to determine whether to add either of the identified fines to the paragraph with the selected first line. For instance in some embodiments when the first two lines are close together and the third line is further down the first two lines are placed in one paragraph and the third line is the start of the next paragraph. Similarly in some embodiments when the first line is further from the second and third the first paragraph is a one line paragraph and the next paragraph starts at the second line. Similar rules are used in some embodiments for alignment differences between the lines. After applying the heuristic rules the process proceeds to to select the next unevaluated text line i.e. the next line that is not yet assigned to a paragraph and start a new paragraph.

When the spacing and alignment is consistent between the three lines the process places at all three lines in the same paragraph. Some embodiments identify spacing and alignment properties of the paragraph as well. For instance some embodiments identify paragraphs as left aligned right aligned justified centered etc. Some embodiments leave open multiple possibilities e.g. a paragraph with an indented first line all three lines right aligned or very close and the lower two lines left aligned could possibly be any of the three of left aligned right aligned or justified .

After the initial phase of identifying the start of a new paragraph process attempts to add lines to the paragraph. In some embodiments the line addition is based on the spacing and alignment properties determined from the three lines making up the start of the paragraph. In other embodiments as lines are added that do not conflict with the spacing and alignment properties for the paragraph the spacing and alignment properties are refined based on any further evidence.

Next the process determines at whether there are any more lines in the document portion. When there are no more lines i.e. the document portion has exactly three lines the process ends. Otherwise the process identifies at the next text line in the document portion. The process then determines at whether there is a spacing or alignment mismatch between the current paragraph and the identified next line. When there is a mismatch the process ends the paragraph and proceeds to which was described above. In such a case the recently mismatched line will be the line selected at .

Otherwise when the spacing and alignment line up the process adds at the line to the current paragraph. The process then proceeds to which was described above. In some embodiments an alignment mismatch is found when the identified next text line does not fit one of the properties e.g. justified of the paragraph. Similarly if the spacing between the last line in the paragraph and the next line is increased as compared to that of the paragraph then a spacing mismatch is found in some embodiments.

Some embodiments employ other stopping conditions e.g. conditions resulting in the identified line not being added to the paragraph . For instance some embodiments recognize if the first word on the identified line would fit into the white space at the end of the last line of a left aligned paragraph. When this is the case the new line is assumed to be part of the next paragraph because if it were part of the current paragraph then the word would be in the white space at the end of the last line rather than starting a new line. Similarly some embodiments recognize an indent as indicating a new paragraph. A third condition of some embodiments is if the identified line is uniformly styled e.g. all bold or of a larger font size and different from the styling of any character on the previous line.

Once process has completed all of the paragraphs in the document portion are identified and all lines of text are assigned to a paragraph. Some embodiments then use the paragraphs to identify columns and layouts.

Some embodiments place paragraphs into columns and layouts after identifying the paragraphs. In some embodiments a column is a vertically ordered group of paragraphs in which the text reads coherently from the top to the bottom. A layout in some embodiments is a collection of non overlapping columns and a linear layout in some embodiments is a horizontally ordered group of columns in which the text reads coherently from the top of the left most column to the bottom of the right most column. For example some embodiments classify a simple page with unsegmented text lines and no headers or footers as a single linear layout with one column.

As shown in process receives at information for paragraphs for the portion of the document. The document portion in some embodiments is an entire document a section of a document a page a zone etc. In some embodiments the paragraph information is determined using process described above. The process then determines whether there are any paragraphs to select. When there are none the process exits.

Otherwise the process selects at a paragraph. In some embodiments the paragraphs in the document portion are selected in order starting at the top left whereas in other embodiments the paragraphs are selected in a random order.

Next the process calculates at the in order out order left order and right order as well as sets of paragraphs that accompany each of these values. The out order of a paragraph p is calculated in some embodiments by using a set B p . The set B p is initially all paragraphs below paragraph p in the document portion that overlap p horizontally i.e. that overlap x coordinates . For instance illustrates a page with eleven paragraphs including paragraph P . The set B P is initially Q R S T U. Next the paragraph closest to p is identified as q and all paragraphs that overlap paragraph q horizontally are removed from the set B P . In the case of paragraph P paragraph Q is the closest to paragraph P and paragraphs R S T and U are removed from the set B P . At this point the set B P is Q.

Some embodiments then continue onto the next closest paragraph to p that was initially in the set B p and remove any paragraphs from B p that are below and horizontally overlap this next closest paragraph. Other embodiments continue to the next closest paragraph to p that remains in the set B p and remove any paragraphs from B p that horizontally overlap this paragraph. Either way in the example of the set B P for paragraph P is Q. The out order of p is then the cardinality i.e. number of elements of the set B p . This is repeated for each paragraph in B p . Thus in this case the out order of paragraph P is 1. As an example of a paragraph with an out order greater than 1 for paragraph R the set B R is S X so that the out order of paragraph R is 2.

The in order of a paragraph p is calculated similarly to the out order in some embodiments by using a set A p . The set A p is initially all of the paragraphs in the document portion above p that overlap p horizontally. The closest paragraph top is selected as paragraph q and the paragraphs that overlap paragraph q horizontally are removed from A p . This is then repeated for each of the paragraphs in A p . In the example page the set A P for paragraph P is the empty set while the set A R for paragraph R is Q W. The in order of a paragraph p is the cardinality i.e. number of elements of the set A p .

The left order and right order of a paragraph p are also calculated similarly in some embodiments using a set L p paragraphs left of p and vertically overlapping p using the same removal rules and a set R p paragraphs right of p and vertically overlapping p using the same removal rules . Some embodiments use L p and R p for flow graphs see below when it has been determined e.g. by an external means that the language direction is top down. For page the set R P for paragraph P is V while the set L V for paragraph V is P. The sets L R and R R for paragraph R are both empty.

Once the in order out order left order and right order are calculated for the selected paragraph the process determines at whether more paragraphs remain for which the various values must be calculated. If more paragraphs remain the process proceeds to to select another paragraph.

Otherwise once the values are calculated for all paragraphs the process generates at a flow graph for the paragraphs. The flow graph of some embodiments is generated such that each paragraph in the document portion being evaluated is a node. A directed edge is drawn from the node for a paragraph p to each node for the paragraphs in the set A p . This is the same in some embodiments as drawing a directed edge from each node for the paragraphs in the set B p to the node for the paragraph p. illustrates an initial flow graph for the page .

Next process identifies at call outs. In some embodiments identified call outs are removed from the flow graph. A call out in some embodiments is a text element on a page that is meant to be read in an order independent from the rest of the text on the page. Some examples of call outs include headers and footers footnotes margin notes side bars and other blocks of text placed amongst other elements such as large font quotes in a magazine article.

Some embodiments identify call outs based on a combination of the geometry of the text element its position on the page its flow properties in order out order left order and right order and the style properties of its elements. For instance when a vertex v includes a one line paragraph that is close to the top of a page the distance from the one line paragraph to any element in A v is more than one line height L v 1 R v 1 and any vertices in L v and R v share these conditions then some embodiments classify the paragraph as a header call out. Requirements for a footer call out are similar in some embodiments except looking for the distance to the bottom of the page and to elements in B v .

Some embodiments also identify sidebars that jut into columns and are not in their own zone randomly located text boxes small bits of text with no obvious relationship to other text e.g. figure captions etc. as call outs. Some embodiments make these determinations as well as other determinations of flow properties based on a purely textual analysis whereas other embodiments incorporate images into the analysis e.g. as further evidence for a figure caption . For example in some embodiments some embodiments identify single line paragraphs distant from all elements in A p and B p as isolated small paragraphs. Captions are identified in some embodiments when a paragraph with a single text line is enclosed by the bounds of an image and is aligned in particular ways with the image bounds e.g. centered near the bottom centered near the top etc. .

When the rectangular bounding boxes of two or more paragraphs intersect some embodiments identify all but one of the paragraphs as intersection call outs. For instance suppose that two paragraphs p and q overlap and B p q r. When r has an in order of 1 or when g is in A r then q is an intersection call out in some embodiments. Some embodiments classify as an intersection call out any paragraph p whose style and or alignment properties are not consistent with the paragraphs in A p or B p . When two paragraphs intersect and none of the above rules applies some embodiments classify the paragraph with smaller area as a call out.

After generating the flow graph for the paragraphs in the document portion the process merges at nodes of the flow graph into columns. Some embodiments merge nodes for paragraphs p and q if A p q and B q p. This indicates that paragraphs p and q are in the same column in some embodiments. In some embodiments the new node pq will have A pq A q B pq B p L pq L p L q and R pq R p R q . For example in the flow graph is modified such that nodes S T and U are merged into node STU in modified flow graph . The other nodes are modified similarly.

Once call outs have been identified and in some embodiments removed from the flow graph process partitions at the flow graph into layouts. Some embodiments define labels for expansion and reduction edges as part of the partitioning process. In some embodiments if the out order of a paragraph p is greater than 1 and the in order of each paragraph q in the set B p is 1 then the edge from p to each q in B p is an expansion edge. Similarly in some embodiments if the in order of a paragraph p is greater than 1 and the out order of each paragraph q in the set A p is 1 then the edges from each q in A p to p is a reduction edge. illustrates that the edges leading into node R are both reduction edges and the edges leading out of node R are both expansion edges.

The partitioning of some embodiments examines each vertex v the edges of which are all labeled. When the in order of v is greater than 1 some embodiments define a partition the elements of which are B v so long as A p v for each p in B v . Similarly when the out order of v is greater than 1 some embodiments define a partition the elements of which are A v so long as B p v for each p in A v . When both of these partitions are possible the vertex v is defined as a partition by itself. Based on these rules the flow graph is partitioned into three partitions and .

Some embodiments place any remaining nodes into one or more partitions such that the smallest number of partitions is defined without any geometric overlap between the partitions. Due to complex page structure some embodiments use more relaxed partitioning rules than those described above. For instance when a partition could be created from a node v except that the out order of v is greater than 1 then elements of A v that are far from v and narrow relative to v are eliminated in some embodiments. When only one element remains in A v the edges from v to the removed vertices are removed and partitioning is continued. Once partitioning is complete the process ends.

In some embodiments each partition corresponds to a linear layout and each of the final merged nodes corresponds to a column. Once partitions are defined some embodiments calculate properties of the document portion such as gutter width margins in line or floating images etc.

Furthermore layout and flow information including word line paragraph and column data is used prominently in the display of the document and enabling more robust user interaction with the document as described in further detail in the concurrently filed U.S. patent application Ser. No. 12 479 849 now published as U.S. Patent Publication 2010 0174979 entitled Identification Selection and Display of a Region of Interest in a Document which is incorporated herein by reference. For instance in some embodiments a user might wish to view a complex document that includes several columns of text images call outs captions etc. and be able to copy and paste the entire text of the document into a text editor. In order for this to be accomplished a reading order is assigned to each of the elements in the document that attempts to identify the order in which a human would read through the elements of the document.

For instance some embodiments assign reading orders to columns such that the reading order follows the expected order in which a human would read the columns from the start to end of the document or page. Other embodiments assign reading orders to other structural elements e.g. paragraphs words etc. . In some embodiments when the user copies and pastes the entire text of such a document into another application the text appears in the application in the order that a human would read it. This is in contrast to copying and pasting from a standard PDF file that orders all text in a strict top down configuration.

Some embodiments also insert images and shapes into the reading order. For instance some embodiments will identify a particular image as associated with a particular column of text and insert the image either before or after depending on the evidence in the document the column of text. As an example some embodiments identify that an image is associated with the caption for the image and insert the image into the reading order immediately prior to its caption.

Some embodiments also define links between structural elements. For instance some embodiments use the reading order to define links between a paragraph at the end of a column and a paragraph at the beginning of the next column that are actually one paragraph. In some embodiments to maintain the hierarchy that has each paragraph assigned to one particular column a separate paragraph bridging the columns is not defined. Instead a link between the two paragraphs is defined indicating that they are in fact one paragraph. Some embodiments use tests similar to those for adding lines to a paragraph in order to determine whether the top paragraph from a second column is actually a continuation of the paragraph at the end of a first column i.e. examining spacing alignment font stylings etc. . The link can then be used e.g. if a user performs a selection operation e.g. a triple click intended to select a paragraph within either of the defined paragraphs the entire actual paragraph will be selected based on the link.

Some embodiments also define links between layouts e.g. linking across pages or zones. For instance some embodiments can recognize continuation text e.g. text in a newspaper indicating that a story continues on a different page and can link the text in the layout with the continuation text to the layout where the text continues. Some embodiments only attempt such linking when a profile has been matched indicating that linking should be performed. For instance if a document has been identified as a newspaper then some embodiments will search for continuation text.

In some embodiments the layout and flow analysis processes described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates the software architecture of a layout and flow analysis application of some embodiments for identifying layout and flow characteristics of a document. In some embodiments the application is a stand alone application or is integrated into another application e.g. a document reconstruction application while in other embodiments the application might be implemented within an operating system.

Layout and flow analysis application includes a line identification module a line merging module a word identification module a difference clustering module a line splitting module a paragraph identification module a column and layout identification module and an order calculator .

Word identification module also receives information from the document content . In some embodiments this information is information about the position of characters in the document. The word identification module identifies characters that should be grouped together as words. Word identification module passes information to and receives information from the difference clustering module . Difference clustering module performs difference clustering on the document characters to return different levels of gaps between characters e.g. word gaps segment gaps etc. . The word identification module uses the difference clustering results to identify the words. Word identification module passes its results as well as other difference clustering results such as segment gaps to the document content as well as to line splitting module .

Line splitting module receives line information from the line identification module and gap information from the word identification module as well as other information e.g. gutter information from the document content . Line splitting module identifies where lines should be split and outputs new line information based on the splits. The new line information is passed to document content as well as paragraph identification module . In some embodiments line splitting module performs some or all of process .

Paragraph identification module receives line information from line splitting module as well as other information e.g. alignment information from document content . Paragraph identification module identifies which lines should be grouped into paragraphs and outputs the result information. The paragraph information is passed to document content as well as to the column and layout identification module . In some embodiments paragraph identification module performs some or all of process .

Column and layout identification module receives paragraph information from paragraph identification module as well as other information e.g. zone information from document content . Column and layout identification module groups paragraphs into columns and groups columns into layouts. Column and layout information module passes information to and receives information from order calculator . The order calculator receives paragraph information from the module and calculates the in order out order left order and right order as well as the corresponding sets A B L and R for the paragraphs. This information is then returned to the module for use in generating a flow graph. The results from column and layout identification module are passed to the document content . In some embodiments column and layout identification module performs some or all of process described above.

In some embodiments the results of the processes performed by the above described modules or other modules are stored in an electronic storage e.g. as part of a document object model . The document object model can then be used for displaying the document on an electronic display device e.g. a handheld device computer screen etc. such that a user can review and or interact with the document e.g. via touchscreen cursor control device etc. .

In some embodiments unstructured document will include primitive elements e.g. shapes and images that are intended to be treated as a single element but are not defined as such in the document. When such primitive elements occupy a compact and isolated area of a document they can be associated using a novel cluster analysis technique referred to as bounds clustering. The objective of bounds clustering in some embodiments is to minimize the spread of a cluster where the spread is calculated from the bounds of the collection of primitive elements e.g. shapes in the cluster while simultaneously maximizing the number of primitive elements in the cluster. The bounds in some embodiments are based on the bounding boxes for a shape or collection of shapes.

Some embodiments of the invention provide methods for identifying graphs i.e. graphic objects of a region that should be joined. These joined graphs can then be treated as one object for the purposes of further reconstruction. Furthermore they can be treated as one object when viewed selected zoomed copied moved edited etc. Some embodiments treat joined graphs as one object for use in selection display and navigation processes described in further detail in the concurrently filed U.S. patent application Ser. No. 12 479 850 now published as U.S. Patent Publication 2010 0174980 entitled Identification of Regions of a Document which is incorporated herein by reference.

The process identifies at graphs in the document portion. illustrates a page that includes six graphs a seven pointed star a pentagon an octagon a cross a triangle and a five pointed star .

The process then uses cluster analysis to join at some of the identified graphs. The process then ends. Some embodiments use a form of cluster analysis called bounds clustering that is described in detail below by reference to process . Some embodiments apply efficiency techniques described below in Section VI to perform the cluster analysis. Some embodiments only join graphs when they are close together and do not take up too large a portion of a page or zone. illustrates that seven pointed star and pentagon are joined into a single graph and triangle and five pointed star are joined into a single graph . Because they are isolated on page octagon and cross are not joined either to each other or to any other graphs.

The process then determines at whether there are at least two graphs in the document portion. When there are one or zero graphs there is no reason to perform clustering to attempt to join graphs therefore the process ends. Otherwise the process sorts at the graphs by drawing order. The drawing order in some embodiments is the sequence in which objects are drawn on a page. Often when multiple objects are intended to be treated as a single object they will be drawn in sequence. Some embodiments however sort based on other heuristics such as the location of the object on the page.

Next the process sets at the first graph in the drawing order as the current graph g. The process then determines at whether g is the last graph in the document portion. When g is the last graph then no spread between graph g and a next graph can be calculated so the process proceeds to which is described below.

Otherwise when the graph g is not the last graph the process calculates at a spread between the graph g and the next graph in the drawing order and stores at the calculated spread in an array. A spread in some embodiments is a measure of how close together two objects are to each other. Some embodiments use the bounding boxes of the two objects to calculate the spread. For example some embodiments calculate the spread of a set of graphic objects is as the sum of the width and the height of the smallest upright bounding box into which the set of objects fits divided by the sum of the width and height of the page.

Next the process at sets the next graph as the current graph g. The process then proceeds to which was described above. Once all the spreads have been calculated the process uses at the spreads as first order differences for difference clustering in order to define clusters of graphs. Some embodiments perform difference clustering as described in the above mentioned United States Publication No. 2007 0250497. As difference clustering of some embodiments only requires the differences between the input values and does not require the actual values of the inputs the spreads can be used as the first order differences despite not arising as actual differences. Clusters that result from difference clustering will in some embodiments have relatively small spreads between consecutive graphs in the same cluster as compared to the spreads between graphs in different clusters.

One of ordinary skill in the art would recognize that the spread and thus the concept of bounds clustering is not limited to graphic objects on a page. For example spreads can be calculated among three dimensional objects by using volumes rather than areas or by summing over the bounding boxes in three dimensions rather than two and thus be used to cluster three dimensional objects e.g. in a three dimensional media editing application such as a video compositing application .

After difference clustering is used with the spreads as first order differences clusters of graphics are defined. Process selects at a cluster C from the unevaluated clusters. The process then processes at C into a set of subsequences of graphs that meet certain constraints. Different embodiments use different constraints to define the joined graphs.

Some embodiments impose the requirement that the objects in a subsequence must be consecutive in drawing order. Some embodiments require that the objects in a sequence be mutually overlapping in that there is no way to partition the cluster into two nonempty subsequences each of which is consecutive in drawing order such that the upright bounds of the group of objects in the first partition is disjoint from the upright bounds of the group of objects in the second partition. A third requirement imposed by some embodiments is that each subsequence meets density constraints which ensure that each subsequence includes a sufficient number of graphs e.g. two with a sufficiently small total spread.

Some embodiments use modified versions of the above conditions. For example instead of the upright rectangular bounds some embodiments use tighter bounds such as a path around the non transparent pixels of an image. In some embodiments the collection of objects in each of these subsequences is joined as a single graph.

Process next determines at whether there are more clusters to evaluate. When more clusters remain the process proceeds to to select another cluster and process that cluster into subsequences. Otherwise when all clusters have been processed the process ends. Now that the graphs are joined they can be treated as one object when viewed selected zoomed copied moved edited etc. Some embodiments treat joined graphs as one object for use in selection display and navigation processes such as described in detail in the concurrently filed U.S. patent application Ser. No. 12 479 845 now issued as U.S. Pat. No. 8 352 855 entitled Selection of Text in an Unstructured Document which is incorporated herein by reference.

As noted above after clusters of graphs have been identified some embodiments process each cluster into subsequences to identify the final joined graphs and then associate the primitive elements that make up each joined graph . illustrates a process of some embodiments for processing a cluster into subsequences. In some embodiments process is performed at operation of process for each cluster.

As shown process receives at a cluster of graphs. As noted in some embodiments this cluster is the output of bounds clustering that uses spreads as the first order differences for graphs that are ordered by drawing order. The process then determines at whether the cluster is empty i.e. does not include any graphs . When the cluster is empty the process ends. Otherwise the process selects at the first graph in the cluster that is not yet in a subsequence. In some embodiments the cluster is ordered by drawing order such that the first time through operation the selected graph is the first graph in the cluster that is drawn in the document that includes the graphs.

The process then defines at a new subsequence that includes the selected graph at this point the selected graph is the only graph in the subsequence . The new subsequence has the bounds of the selected graph. In some embodiments the bounds of the selected graph is the smallest upright bounding box that includes the graph. Other embodiments define the bounds of the graph differently e.g. using the smallest area path that completely encloses all of the non transparent pixels of the graph.

Next process determines at whether there are more graphs in the cluster. When there are no more graphs in the cluster the process proceeds to which is described below. Otherwise the process selects at the next graph in the cluster. In some embodiments the next graph in the cluster is the next graph in the drawing order that is in the cluster.

The process determines at whether the bounds of the new graph i.e. the graph selected at intersect with the bounds of the current subsequence. As noted above different embodiments define the bounds of a graph differently. The bounds of a subsequence that includes multiple graphs is described below. When the bounds of the new graph do not intersect the bounds of the current subsequence process stores at the current subsequence e.g. in a list of subsequences and proceeds to which is described above to begin the next subsequence. The next subsequence begins with the graph recently tested at because this is the first graph in the cluster that is not yet in a subsequence.

When the bounds of the new graph selected at intersect the bounds of the current subsequence the process adds at the new graph to the subsequence and modifies the bounds of the subsequence to be the intersection of the previous subsequence bounds and the bounds of the newly added graph. The process then proceeds to described above to continue attempting to add graphs to the subsequence.

In some embodiments the bounds of a subsequence including multiple graphs is the smallest upright bounding box that includes all of the graphs. In other embodiments the bounds is the union of all of the upright bounding boxes for the graphs in the subsequence in such embodiments the bounds of the subsequence will not necessarily be rectangular . In some embodiments that define the bounds of a graph as the smallest area path including all of the non transparent pixels of the graph the bounds might be such a path around all of the graphs in the subsequence or could be the union of such paths for each graph in the subsequence.

Once all graphs in the cluster have been placed in initial subsequences the process selects at a first subsequence S. In some embodiments each subsequence includes graphs that are contiguous in the drawing order and the subsequences are arranged based on the drawing order such that the first subsequence is that with the first graphs in the drawing order.

The process then determines at whether there are more subsequences i.e. the first time through the process determines whether there is only one subsequence or not . When there are no more subsequences the process ends. Otherwise the process selects at a next subsequence S.

Next process determines at whether the bounds of S and S intersect. As described above the bounds of the subsequences are defined differently in different embodiments i.e. they are based on upright bounding boxes in some embodiments paths around the non transparent pixels in other embodiments etc. . When the bounds of S and S do not intersect the process defines at S to be S and proceeds to to test the next subsequence against the original S.

When the bounds do intersect the process merges at the two subsequences and proceeds to to select the first subsequence as S. Some embodiments return to the first subsequence and do not finish processing until a set of subsequences that cannot be merged in any way is run through from the beginning. Other embodiments save processing time however by selecting the subsequence prior to the recently merged subsequence as S upon returning to and proceeding from that point rather than starting over at the first subsequence.

Once the clusters have been processed into subsequences the subsequences can be tested against constraints such as the density constraints described above. Some embodiments require a particular minimum number of graphs in a subsequence for the graphs to be associated in a joined graph e.g. two five etc. . Some embodiments required that the spread calculated as described above be less than a particular number e.g. 0.4 0.5 etc. .

In some embodiments the graph joining processes described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates a graph joining application of some embodiments for identifying graphs that should be joined and associating the graphs as one graphic. In some embodiments the application is a stand alone application or is integrated into another application e.g. a document reconstruction application while in other embodiments the application might be implemented within an operating system.

The graph joiner passes information e.g. locations of graphs and the position of the graphs in the drawing order to the spread calculator . The spread calculator of some embodiments calculates the spread for each successive pair of graphs and passes this information to bounds clustering module .

Bounds clustering module receives information from the graph joiner and the spread calculator e.g. an array of spreads to be treated as first order differences and performs bounds clustering on the received information. The results of the bounds clustering are passed back to the graph joiner. In some embodiments the graph joiner performs further processing of the clusters received from the bounds clustering module to identify whether particular clusters of graphs should be associated as single graphs and returns the associations to the document content .

In some embodiments the results of the processes performed by the above described modules or other modules are stored in an electronic storage e.g. as part of a document object model . The document object model can then be used for displaying the document on an electronic display device e.g. a handheld device computer screen etc. such that a user can review and or interact with the document e.g. via touchscreen cursor control device etc. .

As noted in various sections above some embodiments of the invention utilize cluster analysis to perform document reconstruction. For instance alignment guides are identified with the use of density clustering joined graphs are identified with the use of bounds clustering and gaps between characters are used to identify words and segment gaps with the use of difference clustering. However cluster analysis can be very memory intensive such that it can be difficult for a resource limited device such as a cell phone or media player to perform cluster analysis.

Accordingly some embodiments of the invention provide methods for performing efficient cluster analysis. In some embodiments the efficient cluster analysis allows cluster analysis to be performed on a resource limited device e.g. a handheld device . Resource limited devices can be limited in terms of available memory processing power both or other computing resources.

In some embodiments the cluster analysis uses indirectly sorted arrays that stores indices of an unsorted array. Some embodiments use indirectly sorted arrays to partition data at multiple different distance scales concurrently so as to more quickly find an optimal partition of the data as opposed to repeating cluster analysis at each different distance scale and comparing the results.

The process then performs at efficient cluster analysis on the document data on the resource limited device. For instance some embodiments perform difference clustering to identify words and segment gaps density clustering to identify alignment guides and bounds clustering to identify compound graphics.

Finally the process semantically reconstructs at the document on the resource limited device based on the results of the cluster analysis. The process then ends. illustrates a sequence of some embodiments by which a document is semantically reconstructed on a resource limited device . The document is initially parsed at into a set of characters with coordinates. For instance character r has coordinates X Y . Some embodiments also parse graphic objects e.g. images shapes etc. 

Next efficient cluster analysis is applied at to the document data. In some embodiments this includes using difference clustering to identify words density clustering to identify guides and bounds clustering to identify graphs to join. Other reconstruction processes are also performed at . For instance paragraphs and columns are identified in some embodiments. One of ordinary skill will recognize that in some embodiments the cluster analysis processes and other reconstruction processes are not necessarily segregated as far as the order they are performed. The result of the efficient cluster analysis and other reconstruction processes is a semantically reconstructed document that can be displayed navigated etc.

Some embodiments perform cluster analysis whether it be difference clustering density clustering or bounds clustering based on several operators that are applied to sequences of real numbers r r . . . r . Some embodiments include the following operators 

Some embodiments of difference clustering are performed in terms of the above operators. Similarly because bounds clustering uses difference clustering with spread values substituted for first order differences some embodiments of bounds clustering are performed in terms of the above operators.

For instance some embodiments apply the sorting operator S to input data followed by the difference operator D to generate first order differences. S and D are then applied to the result data to generate second order differences the differences between the differences . The second order differences are sorted with S and the second order differences are then split into two disjoint subsequences the intra level differences and the larger inter level differences .

In some embodiments the splitting includes further application of D to the second order differences to obtain third order differences followed by S to order the third differences. The split in second order differences generally occurs where there is one third order difference substantially larger than the rest. Some embodiments evaluate domain specific factors as well.

Once the split is established some embodiments apply P using a gap minimum equal to the smallest inter level second difference to partition the ordered first differences such that each partition represents a level of clustering. Some embodiments apply C to this partition while some may not. To partition the data into clusters at a particular level some embodiments apply P to the sorted input data using a gap minimum equal to the smallest difference at the particular level. Some embodiments apply C at this point as well though often with different criteria for coalescing the cluster partition than for the level partitions. Lastly some embodiments apply F to disqualify some of the clusters.

Some embodiments of density clustering are also performed in terms of the above operators. For example some embodiments apply S followed by D to the input data to generate first order differences and apply S to sort the differences. For each of the differences d some embodiments partition the ordered input data with the operator P using a gap minimum d then filter the partitions using density constraints. Each of the post filtering partitions is measured by an optimization metric and the optimal partition is selected as the final clustering. Some embodiments loop through the first order differences as gap minimums starting with the largest and moving to successively smaller values in the sorted sequence.

In some embodiments the loop can be ended early for efficiency if there is enough information. Specifically some embodiments recognize that each successive partition will be the previous partition with one of the clusters split into two clusters. Some embodiments also recognize that clusters that do not meet a minimum size density constraint will never meet such a constraint in the future so these clusters can be discarded. Once all clusters in a partition have fallen below the minimum size then the loop is ended prematurely in some embodiments.

Some embodiments perform efficient cluster analysis by using efficient data structures that allow for memory and processing savings. For instance when sorting data e.g. applying the operator S to input data rather than generating a new array for the data some embodiments define an array of indices into the array of unsorted data with the indices sorted in order of the values they reference. This is referred to as an indirectly sorted array in some embodiments. One of ordinary skill in the art will understand that while the examples use arrays any other suitable data structure may be used as well.

Next process next defines and stores at an array D A of first order differences of the array A by comparing pairs of subsequent values of array A. In some embodiments the array D A is generated by use of the operator D that is described above in subsection A. illustrates the array D that stores the first order differences between the data. For instance the value in index D is the value in index A subtracted from the value in index A of array A .

Next the process defines and stores at an indirectly sorted array S D A of the indices of D A by applying a sort function to the array D A . In some embodiments the sort function is the operator S that is described above in subsection A. illustrates the indirectly sorted array S D that sorts the values of array D . The first value in the array 3 references index of array D which is the smallest of the first order differences 1.14 . The second value in the array references index of array D which is the second smallest first order difference and so on.

The process then determines at the minimum size of the gaps between clusters to be used in partitioning the data. In some embodiments this is the gap minimum g for use with the partitioning operator P described above in subsection A. The minimum gap size is specified by a user in some embodiments or is a value inherent to the problem being solved in others. Some embodiments use multiple partitions e.g. in the case of density clustering such that different gap minimums based on the data are used.

Next process partitions at the data into clusters using consecutive indices stored in the array S D A . The process then stores at the partition. The process then ends. Some embodiments use the indices stored in the indirectly sorted array to partition the data. In some embodiments the index stored in S D A corresponding to the smallest first order difference that is larger than the gap minimum i.e. the effective gap minimum will correspond to the index in the sorted array of data after which the data should be split. All indices stored in the array S D A after the effective gap minimum will also indicate where to split the sorted data because they represent gaps larger than the gap minimum.

The above process enables multiple processing and memory efficiencies for cluster analysis. First storing the indices which are integers rather than the decimal values of the actual data in the sorted array of differences saves memory space. Second instead of actually storing the partition as multiple separate arrays it is stored as a single integer value referencing an index of the indirectly sorted array which can bring about substantial memory savings when there are numerous partitions being evaluated for large arrays of data. Third the indices at which to partition the data can be read off quickly from the indirectly sorted array which substantially saves processing time.

These efficiencies can be leveraged in numerous ways to perform cluster analysis. conceptually illustrates a process of some embodiments for performing cluster analysis at multiple distance scales concurrently. In some embodiments process takes advantage of the efficiencies offered by process . As shown process defines at an indirectly sorted array of differences of data values to be clustered. This is an array such as array of and is arrived at in some embodiments by sorting the input data values taking the first order differences and then sorting those.

Process then partitions at the data values at several different distance scales concurrently. In some embodiments this means that multiple partitions are generated for the data using different gap minimums. For instance in the case of density clustering each possible partition is generated in some embodiments. In some embodiments because the first order differences are sorted with an indirectly sorted array the partitioning locations for the data can be quickly read off as the indices stored in the indirectly sorted array.

Next the process stores at each partition as an integer value referring to an index of the indirectly sorted array. Integer value of is an example of storing a partition as a single integer value. The process then determines at the optimal distance scale and thus the optimal partition . For example some embodiments use an optimization measure such as is described for density clustering above in Section III. Furthermore some embodiments eliminate some of the clusters in a partition by using constraints before testing the partition against the optimization measure.

Finally once the optimal distance scale is determined the process stores at the partition of data derived from the optimal distance scale as the set of clusters for the problem being solved. The process then ends. In some embodiments the set of clusters is stored as a new array once it is determined that it is the optimal set.

While the above descriptions indicate the efficiencies gained for repeated use of the partitioning operator the memory and processing efficiencies from indirectly sorted arrays and storing a partition as a single value are applicable to other aspects of cluster analysis as well. For instance the coalescing operator can take advantage of the same efficiencies in some embodiments.

As noted above the coalescing operator C of some embodiments joins neighboring clusters in a partition possibly repeatedly. The joining of neighboring clusters can be represented as removing a split in a partition. Because each of these splits corresponds to one of the consecutive indices in an indirectly sorted array coalescing clusters can be defined as disqualifying particular indices from the sequence. As such the results of applying the coalescing operator to a partition can be a sequence e.g. an array of qualifying indices i.e. indices at which the new partition is split . Storing such a subsequence is much faster in some embodiments than directly moving around the data in the clusters being coalesced.

Furthermore coalescing clusters of differences which is effectively a combination of levels of differences does not adversely affect the efficiency with which the data clusters as opposed to the difference clusters can be quickly read off for a particular chosen level. Even after coalescing the clusters of differences the indices in the L th indirectly sorted cluster of differences and above are the split points for the data clusters at level L. The change due to coalescing is that there will be fewer indirectly sorted second differences that determine where each indirectly sorted first difference cluster starts.

Because the filtering operator which eliminates clusters of data based on constraints is only applied to clusters of data not to clusters of differences the data clusters have already been determined when the filtering operator is applied and thus it does not interfere with the efficiencies gained through the above implementations of the partitioning and coalescing operators.

Efficiencies can also be gained in the splitting of second differences into intra level and inter level second differences that is performed in difference clustering as described above in Section IV. In some embodiments the conditions used to determine a split point may depend on the clustering of first differences and the data that would result. Thus the evaluation of these conditions benefits directly from the efficiencies in determining partitions of differences and thus partitions of data .

For instance in the case of difference clustering as applied to document reconstruction the splitting of second differences is used to determine word breaks and segment breaks e.g. column tab etc. gaps on a text line which correspond to first order differences and greater than first order differences respectively. In some embodiments the goal is to split the second differences such that the minimum of the second cluster of first differences is not much smaller than the expected space character width for the applicable font. Furthermore a secondary goal would be that the data clusters each of which is a word have an average size typical for words in the applicable language. Potential split points can be assessed comparatively lower depending on how far the resulting clusters of first differences and the clusters of data would differ from these expectations. Such assessments can be combined in some embodiments with other measures applied directly to the second differences e.g. the relative size of the split the percentile of the split position and the percentage increase at the split in a formula that determines the optimal split point. The repeated testing of different splits in the second differences can be made significantly more efficient by the processes described above.

One of ordinary skill in the art will recognize that while cluster analysis and the specific efficiency techniques described above have primarily been described with respect to its use in document reconstruction they are applicable to any problem in which there is a set a distance function on pairs of elements of the set and a need to identify subsets of elements separated by distances that are small in terms relative to the set. For instance cluster analysis can be applied to analyzing user interaction with an application web page or video by clustering position data acquired by measuring eye movements mouse movements or touch screen interactions. As another example a raster image i.e. bitmap can be compressed by reducing the number of colors used to encode it. Cluster analysis can be used on the original set of colors to select a reduced set of colors such that each cluster of colors is replaced by a single color often equal to an average of its members . Still another example is that some image recognition techniques e.g. biometrics optical character recognition currency validation etc. and vectorization of raster images depend on clustering of pixels in a metric space defined by spatial and color coordinate axes. As a final example patterns in experimental data e.g. scientific or business data are often found by plotting data points in a space the axes of which are the parameters of interest. Cluster analysis can be applied to this data noting that all points in a given cluster have approximately the same values of all parameters of interest.

In some embodiments the cluster analysis described above is implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates the software architecture of a cluster analysis application of some embodiments for performing cluster analysis. In some embodiments the application is a stand alone application or is integrated into another application e.g. a document reconstruction application while in other embodiments the application might be implemented within an operating system.

Cluster analysis application includes density clustering module difference clustering module and bounds clustering module . The application also includes sorting module differencing module partitioning module coalescing module and filtering module as well as cluster analysis storage .

In some embodiments the five modules perform operations associated with the five operators described above in subsection A. The sorting module of some embodiments receives data from one of the modules and orders the data e.g. from lowest value to highest value . The differencing module of some embodiments receives data from one of the modules and determines the differences between adjacent pieces of data. The partitioning module of some embodiments receives data from one of the modules and partitions the data into multiple subsets. The coalescing module of some embodiments receives data as multiple subsets from one of the modules and joins adjacent subsets according to various conditions. The filtering module of some embodiments receives a partitioned sequence of data in some embodiments and filters out partitions based on various constraints.

The modules store data in cluster analysis storage as well as pass the data back to the modules . In some embodiments the sorting module stores its results in cluster analysis storage as a sorted array of indices i.e. an indirectly sorted array . The partitioning module in some embodiments stores partitions in the cluster analysis storage as a single integer value referencing an index of an indirectly sorted array.

Some embodiments of the invention provide novel methods and data structures that enable more efficient parsing and analysis of a document. Some embodiments provide an application programming interface API that minimizes redundant copies of data as the data is manipulated. An API in some embodiments is a set of functions procedures methods classes or protocols that an operating system library service or framework provides to support requests made by computer programs. In some embodiments the API is statically linked while in other embodiments an API is dynamically linked.

Typically APIs return copies of internal data or give read only access to internal data which must then be copied before being manipulated in any way. This creates many layers of redundant data which slows processing and consumes excess memory. Some embodiments solve this problem by decoupling objects from their data so that object APIs can be made optimal for a programmer at the same time that the data structures are made optimal with respect to performance and memory consumption. Some embodiments use such an API for reconstructing a document as described above in Sections II VI as well as in the concurrently filed U.S. patent application Ser. No. 12 479 850 now published as U.S. Patent Publication 2010 0174980 entitled Identification of Regions of a Document which is incorporated herein by reference. However one of ordinary skill in the art will recognize that such an API can be used for any sort of analysis of parsed input data.

Some embodiments provide an API that appears to a user e.g. a programmer or a software application using the API as if the user has their own independent modifiable copy of the class members of the API with no explicit restrictions. In other words it appears to the user as though any object returned through the API is completely modifiable by the user. However in some embodiments the objects will actually only copy themselves when absolutely necessary and in most cases will manage memory in such a way as to minimize the amount of memory actually used. The memory management of some embodiments is done by using a sorted array of pointers that has a shared memory object which keeps track of the use of the pointers by other objects. In some embodiments numerous objects can all reference the same pointer array through the shared memory object enabling substantial memory savings as compared to making copies of the data at every stage of analysis. One of ordinary skill in the art will recognize that while pointers are used to describe certain features below any sort of referential data structure could be used.

Some embodiments use an API such as is described above to reconstruct a document. conceptually illustrates a process of some embodiments for reconstructing a document efficiently. Process will be described in conjunction with . illustrates a sequence by which a document is parsed and analyzed according to process .

As shown in process receives at a portion of a document. In some embodiments the document portion is a page and the process operates on a page by page basis. In other embodiments the document portion is an entire document a section of a document or a zone on a page. The process then parses at the document to determine the characters in the document portion and stores at an array of characters for the parsed data.

Process defines at a sorted array of pointer that orders the characters for the document portion. In some embodiments the characters for a page are sorted with a primary sort of top to bottom and a secondary sort of left to right. Some embodiments that store multiple pages in a character array sort by page first. illustrates an array of pointers that is defined for the sorted characters. The first pointer points to the letter L in the array the second pointer to the letter o and so on. Defining an array of pointers to the initial character array rather than defining and storing a separate new array saves memory in some embodiments.

The process next receives at instructions to manipulate string objects. Some embodiments define a string object as a pointer to a location in the sorted array of pointers and a count of how many characters are in the string. For instance a string object for the entire page would point to the first pointer in the sorted pointer array the top leftmost character and give a count of the number of characters on the page.

In some embodiments the instructions include splitting strings joining strings adding characters removing characters and re ordering characters. These operations in some embodiments are invoked as part of the process of reconstructing a document and using the reconstructed document as described above in Sections II VI as well as in the concurrently filed U.S. patent application Ser. No. 12 479 850 now published as U.S. Patent Publication 2010 0174980 entitled Identification of Regions of a Document which is incorporated herein by reference. For instance in some cases when lines are merged the order of characters must be modified. When zones are defined some embodiments define strings for each zone which in many cases involves splitting strings joining strings or both.

After receiving the instructions the process determines at whether the instructions can be performed using only pointers that are already allocated e.g. the sorted pointer array defined at . In some embodiments splitting strings involves only the use of pointers that are already allocated. In the case of document reconstruction some processes only involve the splitting of strings e.g. line identification line splitting etc. . Furthermore joining strings that are next to each other in the sorted array of pointers will involve only the use of already allocated pointers in some embodiments.

The same pointers can then be used when words are identified. For example string objects and define two of the words in document . These words point to the same start pointers as string objects and but have different counts because the words are shorter than the lines. However no new pointers need to be allocated to define these words only new string objects. For a full document hundreds or thousands of different string objects may all reference the same pointer array such as pointers introducing large memory savings over repeatedly allocating memory for new pointer arrays.

When the received instructions can be performed using only pointers that are already allocated process performs at the instructions using the shared pointers that are already allocated in memory. The process then proceeds to which is described below. Otherwise the process determines at whether the instructions can be performed using a new collection of pointers.

Some embodiments allocate new pointers when instructions cannot be performed with only pointers that are already allocated but the instructions do not require direct data manipulation of the character array. In some embodiments joining strings that are not next to each other in a shared array of pointers requires a new allocation of pointers because a string object for the joined strings cannot be represented by pointing to one pointer in the sorted array and moving forward in that array. For instance referring to if an operation called for appending the first line to the end of the second line then string object for the appended lines could not point to array . Instead a new array of pointers would have to be allocated in the required order.

When the received instructions can be performed using a new allocation of pointers the process performs at the instructions by using a new allocation of pointers to the character array. The process then and proceeds to which is described below. Otherwise the process performs at the instructions by using a new copy of a portion or the entire character array. Directly editing the document data i.e. a user adding a word to the document is an example of instructions that could not be performed without manipulating the actual array of characters in some embodiments. However a user adding a word to the document would not require a completely new copy but instead could be handled by adding characters to the array and then defining a new array of pointers to the characters. Similarly merging text lines often requires a new array of pointers because a character from one text line may be inserted into the next text line thereby altering the order of the characters relative to each other.

Next the process determines at whether more instructions to manipulate the string objects have been received. When more instructions have been received the process proceeds to which is described above to determine the most efficient way of performing the instructions. Otherwise the process ends. This process illustrates the hierarchy of memory and processing savings that are introduced by using the shared data. The original data is shared among various pointer arrays and each pointer array is shared among many string objects. For each set of instructions received e.g. each call into an API the most efficient way of performing the instructions is used. Ideally the instructions will not require the creation of any new pointers and only new string objects need be created. If this is not possible then memory savings may still be gained by creating new pointers that share the original data as opposed to creating a new character array.

Although process has been described with reference to string objects and specifically string objects for document reconstruction one of ordinary skill in the art will recognize that the efficiencies gained by exhibiting a preference for using already allocated pointers and then for allocating new pointers as opposed to copying data are applicable to a wide range of problems where memory and processing time are at a premium.

In some embodiments each array of pointers has a shared memory object that manages the use of the pointers in the array. In some embodiments the shared memory object for a particular pointer array keeps track of the data objects e.g. string objects that reference the particular array. In some embodiments the shared memory object also keeps track of where in memory the pointer array starts as well.

The sorted array of pointers is an array of pointers to the data array . Each pointer points to a data item in the array in some embodiments. The pointers are arranged in an order based upon a sort of the data. For instance in the case of a document the pointers are arranged in the reading order of the characters to which they point in some embodiments.

Each of the data objects includes a reference to a location in the pointer array and a count. The location in the pointer array for a particular data object is the pointer that points to the first piece of data that the data object references. For instance when the data object is a string object for the word Array the data object would specify the location in the pointer array where the pointer that points to the A is found. The data object would also include a count of 5.

Some embodiments do not define the shared memory object when a first data object that points to the start of the array and has a count of the entire array is defined. However once a second data object points to the array the array is now shared and the shared memory object is defined to keep track of how many data objects share the array and where the start of the array is as each individual object does not have this information. Accordingly in some embodiments the data objects can call a function to instantiate a shared memory object for a pointer array if none exists when the data object is set to point to the pointer array. When the number of objects drops to zero the shared memory object deallocates the pointers and is then itself removed from memory.

In some embodiments each individual data object sharing the pointer array does not have any knowledge that other objects are also using the pointers in array . Furthermore the objects do not have any knowledge of the start or end of array merely referencing some point in the array . However the shared memory object of some embodiments knows where the start of the array is in memory.

In some embodiments the API described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates an API that performs document reconstruction processes while using the efficiency techniques described above in subsections A and B.

API includes geometric analysis modules. document reconstruction modules and display and interaction modules . The API is in some embodiments the set of functions procedures methods classes and or protocols that is provided for use by external applications .

The API receives requests e.g. function calls to the public methods by external applications . In some embodiments there are numerous external applications. For instance in the case where an API is provided on a handheld device e.g. an iPhone the external applications might be a PDF viewer e.g. an e book reader a word processor e.g. Microsoft Word Apple Pages etc. a web browser e.g. Microsoft Internet Explorer Apple Safari Mozilla Firefox etc. etc.

The various public methods provided by API call various private methods that perform the geometric analysis and document reconstruction access the document object model etc. The data e.g. the primitive elements that are initially identified by a parser is stored in the document reconstruction data . Although it may appear to the external applications that they can access the data e.g. while manipulating characters to identify words text lines etc. in fact the class members that are manipulated by the external applications through the API are divorced from the actual data by defining the class members to only store references to the data as described above in subsections A and B.

In some embodiments the processes described above are implemented as software running on a particular machine such as a computer a media player a cell phone e.g. an iPhone or other handheld or resource limited devices or stored in a computer readable medium . conceptually illustrates the software architecture of an application of some embodiments for reconstructing displaying and interacting with a document. In some embodiments the application is a stand alone application or is integrated into another application while in other embodiments the application might be implemented within an operating system. In still other embodiments the modules illustrated in are split among multiple applications. For instance in some embodiments one application generates the document object model while another application displays the document and interacts with the document object model see full description below .

Application includes a parser profiling modules semantic reconstruction modules cluster analysis modules user interaction modules and display adaptation modules . The application also includes document data storage profile storage cluster analysis storage and document object module storage . also illustrates an operating system that includes cursor controller driver keyboard drive and display module . In some embodiments as illustrated the cursor controller driver keyboard driver and or display module are part of operating system even when the compositing application is a stand alone application separate from the operating system.

As shown the parser receives a document . In some embodiments the document is an unformatted document that includes vector graphics e.g. a PDF . The parser parses the document information and stores the parsed data in the document data storage . In some embodiments the parsed text data is stored as an array of characters as described in Section XI of the concurrently filed U.S. patent application Ser. No. 12 479 842 now issued as U.S. Pat. No. 8 438 472 entitled Efficient Data Structures for Parsing and Analyzing a Document which is incorporated herein by reference.

The semantic reconstruction modules reconstruct the document to generate the document object model from the document data . Semantic reconstruction modules perform such processes as zone analysis guide and gutter identification layout and flow identification table identification and joined graph identification.

The output of the semantic reconstruction modules also is sent to the profiling modules . Profiling modules include a profile matching engine that matches hierarchical profiles and inform the semantic reconstruction modules how to go about performing reconstruction as described Section VII of the concurrently filed U.S. patent application Ser. No. 12 479 852 now issued as U.S. Pat. No. 8 473 467 entitled Content Profiling to Dynamically Configure Content Processing which is incorporated herein by reference.

The semantic reconstruction modules also pass information to the cluster analysis modules . Cluster analysis modules perform density clustering for guide identification difference clustering for word and segment gap information and bounds clustering for identifying graphs that should be joined in some embodiments. The cluster analysis modules use the cluster analysis storage to store arrays and indices as described in Section VI. The results of the cluster analysis are then passed back to the semantic reconstruction modules .

Once the semantic reconstruction modules have reconstructed the document they store the document object model . Document object model stores all information about the semantically reconstructed document such as the zone graph populated with content that is described above in Section II.

Display adaptation modules use the document object model to determine how to display the document. For instance display adaptation modules of some embodiments perform processes for displaying the document on a small screen device which are described in detail in concurrently filed U.S. patent application Ser. No. 12 479 849 now published as U.S. Patent Publication 2010 0174979 entitled Identification Selection and Display of a Region of Interest in a Document which is incorporated herein by reference. Display adaptation modules pass the display information to the display module which governs the actual display on the screen.

User interaction modules receive input information from the cursor controller driver and keyboard driver . The input information directs the user interaction modules to perform operations on the document such as selections as described detail in the concurrently filed U.S. patent application Ser. No. 12 479 845 now issued as U.S. Pat. No. 8 352 855 entitled Selection of Text in an Unstructured Document which is incorporated herein by reference as well as editing of the document. If the document is edited then the document object model must be modified to reflect the edits.

In some embodiments the results of the processes performed by some of the above described modules or other modules are stored in an electronic storage e.g. as part of a document object model . The document object model can then be used for displaying the document on an electronic display device e.g. a handheld device computer screen etc. such that a user can review and or interact with the document e.g. via touchscreen cursor control device etc. .

As shown process begins by defining at geometric analysis modules such as modules of . The process then defines at document reconstruction modules such as modules of . More detailed examples of such modules include in some embodiments guide identification module of word identification module of and graph joiner of . In some embodiments semantic reconstruction modules of include both geometric analysis modules and document reconstruction modules though other embodiments only include one or the other.

Process then defines at a set of hierarchical profiles such as profiles . Next the process defines at a set of modules for performing cluster analysis. The cluster analysis modules are an example of such modules. More detailed examples of such modules include sorting module differencing module partitioning module coalescing module and filtering module of . These modules in some embodiments identify a pairwise grouping of nearest primitive elements of an unstructured document sort the pairwise primitive elements based on an order from the closest to furthest pairs and store a single value that identifies which of the pairwise primitive elements are sufficiently far apart to form a partition and analyzing different partitions in order to identify an ideal optimal partition representing an optimal distance scale.

The process then defines at modules for adaptively displaying a document such as display adaptation modules . Next process defines at modules for receiving user interactions with a document such as modules . The process also defines at other modules. For instance some embodiments include modules for parsing an incoming document e.g. a document received by the application or for efficiently using memory and processing time when performing various document reconstruction operations.

Process then stores at the application on a computer readable storage medium. As mentioned above in some embodiments the computer readable storage medium is a distributable CD ROM. In some embodiments the medium is one or more of a solid state device a hard disk a CD ROM or other non volatile computer readable storage medium. The medium may be firmware of a handheld device e.g. an iPhone in some embodiments.

One of ordinary skill in the art will recognize that the various elements defined by process are not exhaustive of the modules rules and processes that could be defined and stored on a computer readable storage medium for an application incorporating some embodiments of the invention. Furthermore it is equally possible that some embodiments will include only a subset of the elements defined by process rather than all of them.

In addition the process is a conceptual process and the actual implementations may vary. For example different embodiments may define the various elements in a different order may define several elements in one operation may decompose the definition of a single element into multiple operations etc. Furthermore the process may be implemented as several sub processes or combined with other operations in a macro process.

Many of the above described features and applications are implemented as software processes that are specified as a set of instructions recorded on a computer readable storage medium also referred to as computer readable medium . When these instructions are executed by one or more computational element s such as processors or other computational elements like ASICs and FPGAs they cause the computational element s to perform the actions indicated in the instructions. Computer is meant in its broadest sense and can include any electronic device with a processor. Examples of computer readable media include but are not limited to CD ROMs flash drives RAM chips hard drives EPROMs etc. The computer readable media does not include carrier waves and electronic signals passing wirelessly or over wired connections.

In this specification the term software is meant to include firmware residing in read only memory or applications stored in magnetic storage which can be read into memory for processing by a processor. Also in some embodiments multiple software inventions can be implemented as sub parts of a larger program while remaining distinct software inventions. In some embodiments multiple software inventions can also be implemented as separate programs. Finally any combination of separate programs that together implement a software invention described here is within the scope of the invention. In some embodiments the software programs when installed to operate on one or more computer systems define one or more specific machine implementations that execute and perform the operations of the software programs.

The bus collectively represents all system peripheral and chipset buses that communicatively connect the numerous internal devices of the computer system . For instance the bus communicatively connects the processor with the read only memory the GPU the system memory and the permanent storage device .

From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of the invention. In some embodiments the processor comprises a Field Programmable Gate Array FPGA an ASIC or various other electronic components for executing instructions. Some instructions are passed to and executed by the GPU . The GPU can offload various computations or complement the image processing provided by the processor . In some embodiments such functionality can be provided using Corelmage s kernel shading language.

The read only memory ROM stores static data and instructions that are needed by the processor and other modules of the computer system. The permanent storage device on the other hand is a read and write memory device. This device is a non volatile memory unit that stores instructions and data even when the computer system is off. Some embodiments of the invention use a mass storage device such as a magnetic or optical disk and its corresponding disk drive as the permanent storage device .

Other embodiments use a removable storage device such as a floppy disk flash drive or ZIP disk and its corresponding disk drive as the permanent storage device. Like the permanent storage device the system memory is a read and write memory device. However unlike storage device the system memory is a volatile read and write memory such a random access memory. The system memory stores some of the instructions and data that the processor needs at runtime. In some embodiments the invention s processes are stored in the system memory the permanent storage device and or the read only memory . For example the various memory units include instructions for processing multimedia items in accordance with some embodiments. From these various memory units the processor retrieves instructions to execute and data to process in order to execute the processes of some embodiments.

The bus also connects to the input and output devices and . The input devices enable the user to communicate information and select commands to the computer system. The input devices include alphanumeric keyboards and pointing devices also called cursor control devices . The output devices display images generated by the computer system. The output devices include printers and display devices such as cathode ray tubes CRT or liquid crystal displays LCD .

Finally as shown in bus also couples computer to a network through a network adapter not shown . In this manner the computer can be a part of a network of computers such as a local area network LAN a wide area network WAN or an Intranet or a network of networks such as the internet. Any or all components of computer system may be used in conjunction with the invention.

Some embodiments include electronic components such as microprocessors storage and memory that store computer program instructions in a machine readable or computer readable medium alternatively referred to as computer readable storage media machine readable media or machine readable storage media . Some examples of such computer readable media include RAM ROM read only compact discs CD ROM recordable compact discs CD R rewritable compact discs CD RW read only digital versatile discs e.g. DVD ROM dual layer DVD ROM a variety of recordable rewritable DVDs e.g. DVD RAM DVD RW DVD RW etc. flash memory e.g. SD cards mini SD cards micro SD cards etc. magnetic and or solid state hard drives read only and recordable blu ray discs ultra density optical discs any other optical or magnetic media and floppy disks. The computer readable media may store a computer program that is executable by at least one processor and includes sets of instructions for performing various operations. Examples of hardware devices configured to store and execute sets of instructions include but are not limited to application specific integrated circuits ASICs field programmable gate arrays FPGA programmable logic devices PLDs ROM and RAM devices. Examples of computer programs or computer code include machine code such as is produced by a compiler and files including higher level code that are executed by a computer an electronic component or a microprocessor using an interpreter.

As used in this specification and any claims of this application the terms computer server processor and memory all refer to electronic or other technological devices. These terms exclude people or groups of people. For the purposes of the specification the terms display or displaying means displaying on an electronic device. As used in this specification and any claims of this application the terms computer readable medium and computer readable media are entirely restricted to tangible physical objects that store information in a form that is readable by a computer. These terms exclude any wireless signals wired download signals and any other ephemeral signals.

While the invention has been described with reference to numerous specific details one of ordinary skill in the art will recognize that the invention can be embodied in other specific forms without departing from the spirit of the invention. For example some embodiments receive a document in which each page is defined as a single image. However some embodiments can perform optical character recognition on the document to recognize glyphs and in some cases shapes e.g. lines rectangles etc. after which point the document can be reconstructed. Also some embodiments have been described above as performing particular geometric analysis and document reconstruction operations on particular primitive elements. However one of ordinary skill would recognize that the operations could be applied to other sorts of primitive elements. For instance guide identification is described as involving the use of density clustering to identify associations of i.e. to associate or to define associations of glyphs forming a vertical boundary. However similar operations could be applied to look for clusters of primitive shapes that form boundaries e.g. dashed lines .

Furthermore a number of the figures including and conceptually illustrate processes. The specific operations of these processes may not be performed in the exact order shown and described the specific operations may not be performed in one continuous series of operations and different specific operations may be performed in different embodiments. Furthermore the process could be implemented using several sub processes or as part of a larger macro process. Thus one of ordinary skill in the art would understand that the invention is not to be limited by the foregoing illustrative details but rather is to be defined by the appended claims.

