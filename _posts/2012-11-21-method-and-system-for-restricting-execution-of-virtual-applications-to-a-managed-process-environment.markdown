---

title: Method and system for restricting execution of virtual applications to a managed process environment
abstract: Methods and systems for restricting the launch of virtual application files. In one embodiment, a launching application is signed with a digital signature. When the launching application launches a runtime engine and instructs it to execute an application file, the runtime engine determines whether an entity identifier associated with the launching application identifies an authorized entity. If the entity identifier identifies an authorized entity and the digital signature is valid, the runtime engine executes the application file. In another embodiment, a ticket is transmitted to the launching application along with an instruction to launch the application file. The ticket includes a digital signature and an expiration date. The launching application communicates the ticket to the runtime engine, which will execute the application file only if the digital signature is valid and a current date is not later than the expiration date.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09106425&OS=09106425&RS=09106425
owner: CODE SYSTEMS CORPORATION
number: 09106425
owner_city: Seattle
owner_country: US
publication_date: 20121121
---
The present invention is directed generally to methods and systems for restricting application execution to authorized users and or authorized launching applications.

A virtual application is a virtual machine image pre configured with all of the files registry data settings components runtimes and other dependencies required for a specific application to execute immediately and without installation on a host computing device. The virtual application is partially isolated from other applications implemented on a host computing device and partially isolated from an underlying host operating system installed and executing on the host computing device. The virtual application is encapsulated from the host operating system by a virtual runtime environment which includes a virtual operating system that receives operations performed by the virtualized application and redirects them to one or more virtualized locations e.g. a virtual filesystem virtual registry and the like .

Thus the virtual application may be conceptualized as including two components a virtualization runtime and a virtual application configuration. The virtualization runtime implements the virtual runtime environment which implements various operating system application programming interfaces APIs in such a way that allows the executing virtual application to access and interact with items that may not be present on the host computer. The virtual application configuration includes data necessary to implement the virtual application within the virtualization runtime.

The virtual application is stored in and implemented by one or more data files and or executable files. Depending upon the implementation details the one or more data files and or executable files storing and implementing the virtual application may include blocks of data corresponding to each application file of a natively installed version of the application. Herein these blocks of data will be referred to as virtual application files. The one or more data files and or executable files storing and implementing the virtual application also include configuration information.

The data files and or executable files are configured to execute within a virtual runtime environment that is provided at least in part by the virtual operating system. When the virtual application is executed within the virtual runtime engine the configuration information is used to configure the virtual operating system to execute the virtual application. For example the configuration information may contain information related to the virtual application files virtual registry entries environment variables services and the like. The virtual operating system is configured to communicate with the host operating system as required to execute the virtual application on the host computing device.

Virtual applications are highly portable. Therefore a need exists for methods and systems that prevent unauthorized distribution and or execution of virtual applications. The present application provides these and other advantages as will be apparent from the following detailed description and accompanying figures.

In the embodiment illustrated the server computing device functions as an upload server receiving the application to be published from the client computing device . The server computing device copies the application to the server computing device which functions as a website server. The server computing device generates a website see from which the application may be downloaded and or executed e.g. by the client computing device . Optionally execution of the downloaded application may be profiled to generate one or more transcripts that may be used to generate a streaming model.

The server computing devices and are each connected to an Account Database and an Application Library Database . While illustrated as separate databases as is apparent to those of ordinary skill in the art the Account and Application Library Databases and may be implemented in the same database. Further the Account and Application Library Databases and may be implemented on one or more computing devices not shown .

The Account Database stores information related to each user account. The Application Library Database stores information related to each application uploaded to the server computing device .

The system may be used to distribute application files e.g. virtualized application files . Further the system may be used to track application versions and make different versions of a particular application available to users.

The system is described in detail in U.S. patent application Ser. No. 12 906 904 filed on Oct. 18 2010 entitled Method and System for Publishing Virtual Applications to a Web Server which is incorporated herein by reference in its entirety.

A diagram of hardware and an operating environment in conjunction with which implementations of the server computing device the server computing device the client computing device the client computing device the Account Database the Application Library Database and the network may be practiced is provided in and described below.

A virtual application may be implemented as an executable virtualized application file or an xlayer file configured to execute within a virtualized environment provided by a virtual machine or a virtual runtime engine . The executable virtualized application file and the xlayer file may each be characterized as being a virtualized application file. illustrates a virtual application A implemented by the execution of the xlayer file by the virtual runtime engine . also illustrates a virtual application B implemented by the execution of the executable virtualized application file . The virtual runtime engine may execute within an operating system shell process.

U.S. patent application Ser. No. 12 697 029 filed on Mar. 31 2010 entitled Method and System for Improving Startup Performance and Interoperability of a Virtual Application which is incorporated herein by reference in its entirety describes a file format that may be used to configure the xlayer file . The virtualized application file and the xlayer file may each be implemented as a binary file.

The system memory A may store one or more files implementing one or more virtual runtime engines. By way of a non limiting example the system memory A may include a plurality of virtual machine executable files that when executed each implements a different virtual machine. For example each of the virtual machine executable files may implement a different version of the same virtual machine. The virtual machine executable files may be executed individually. When executed a virtual machine executable file implements a virtualized environment.

A natively installed version of an application is configured to execute within a runtime environment provided at least in part by the host operating system A. Typically to execute within the runtime environment provided at least in part by the host operating system A the natively installed version of the application modifies the configuration and settings of the host operating system A. For example the natively installed version may install dynamic link libraries or change registry settings of the host operating system A. In contrast a virtual version of the same application may be executed on the host operating system A without installation on the host operating system A. On the other hand the virtual applications A and E do not modify the configuration or settings of the host operating system A. For example to execute the virtual applications A and B dynamic link libraries dlls data files registry settings environment variables and the like need not be modified on to the host operating system A.

The virtualized application file may include components necessary to implement a virtual runtime environment including a virtual operating system B configured to execute in the operating system A of the client computing device illustrated in . Similarly the virtual runtime engine includes components necessary to implement a virtual runtime environment including a virtual operating system A configured to execute in the operating system A of the client computing device illustrated in . The virtual operating systems A and B are configured to intercept calls to the host operating system A and route them to corresponding components of the virtual operating systems A and B respectively. The virtual operating systems A and B may also route some requests and actions to the host operating system A and B respectively for processing.

In the embodiment illustrated in the virtualized application file and the xlayer file each implement a virtualized version of the application . U.S. patent application Ser. No. 12 188 155 filed on Aug. 7 2008 U.S. patent application Ser. No. 12 188 161 filed on Aug. 7 2008 and U.S. patent application Ser. No. 12 685 576 filed on Jan. 11 2010 all of which are incorporated herein by reference in their entireties disclose systems that may be used to create and configure the virtualized application file and or the xlayer file . As described in greater detail in U.S. patent application Ser. Nos. 12 188 155 12 188 161 and 12 685 576 a virtual application constructor or authoring tool may use an application template that includes copies of files such as a configuration file application files A and the like to configure the virtualized application file or the xlayer file . However the template is not a requirement. Instead the authoring tool needs only the configuration file and copies of any applications files A necessary for a natively installed version of the application to execute to build the virtualized application file or the xlayer file . The applications files A C and the configuration file are referred to collectively as an application configuration . The authoring tool may combine the application configuration and the components of the virtual runtime engine e.g. the virtual operating system to construct or build the executable virtualized application file . Alternatively the authoring tool may use the application configuration to build the xlayer file . As described in U.S. patent application Ser. Nos. 12 188 155 and 12 188 161 the application configuration may be created using a snapshot technique or other process e.g. manually specifying the application configuration operable to capture the application configuration based on the application . The authoring tool may include a wizard described in U.S. patent application Ser. No. 12 906 904.

As explained in U.S. patent application Ser. Nos. 12 188 155 and 12 697 029 the virtualized application file and the xlayer file each store configuration information. A component of the virtual runtime engine e.g. the virtual runtime engine referred to as a reader reads the configuration information and uses that data to configure the virtual runtime environment. The configuration information may be stored in a configuration data block of the virtualized application file or within configuration data stored by the xlayer file . Among other settings the configuration information includes a digital rights management DRM indicator e.g. a Boolean value . As explained in U.S. patent application Ser. No. 12 188 155 a virtualized application file may be created using an application template that includes a virtual application configuration file e.g. a file having the extension xappl . By way of a non limiting example the configuration information including the DRM indicator may be stored in the virtual application configuration file used to create the virtualized application file.

As mentioned above the server computing device transfers or copies the uploaded file see to the server computing device . The server computing device which functions as an upload server is further operable to communicate with the Account Database for the purposes of obtaining and storing information related to the user account associated with the uploaded file see . The server computing device is also operable to communicate with the Application Library Database for the purposes of obtaining and storing information related to the uploaded file see and the virtual application s associated therewith.

The server computing device is operable to generate the website see including a link for each of the uploaded files e.g. the uploaded file illustrated in . Other computing devices e.g. the client computing device illustrated in may navigate to the website see and select the links to thereby download and or execute the uploaded files.

While illustrated as being outside the filesystem A those of ordinary skill in the art appreciate that the executable virtualized application file the xlayer file the application configuration the application the virtual machine files and the authoring tool may be conceptualized as being within the filesystem A.

The system memory B also stores application library web services components configured to communicate with the Account and Application Library Databases and e.g. using Structured Query Language SQL and perform other functions described below. The wizard communicates with the web server components A which access the application library web services components requested by the wizard . While illustrated as being outside the filesystem B those of ordinary skill in the art appreciate that the uploaded file the web server components A and the application library web services components may be conceptualized as being within the filesystem B.

As described in U.S. patent application Ser. No. 12 879 956 filed Sep. 10 2010 titled Method and System for Building a Streaming Model and incorporated herein by reference in its entirety the Sandbox Manager and the virtual runtime engine may both have read write access to a block of shared memory that may be used to send settings and state information between the Sandbox Manager and the virtual runtime engine . Thus the Sandbox Manager and the virtual runtime engine may both access the block of shared memory as a means of communicating with one another.

Virtual machine files are also stored in the system memory D. The virtual machine files may be substantially identical to the virtual machine files stored in the system memory A see . Execution of a virtual machine file e.g. one of the virtual machine files may be initiated by the Sandbox Manager using a command including a parameter e.g. a file path identifying a virtualized application file to execute. The virtualized application file may include a downloaded copy of the xlayer file or a portion thereof sufficient to initiate execution. In response to receiving the parameter the virtual machine executable file executes the identified virtualized application file inside the virtualized environment implemented by the virtual machine executable file.

Together the Client Application and the Sandbox Manager may download and or execute a virtual application. In embodiments in which the Client Application includes the plug in a user may click on a link or otherwise select an application file displayed on the website see for download and or execution. The website or selection of the application file launches the plug in which established the communication link with the Sandbox Manager . The Sandbox Manager identifies which of the virtual machine files is configured to execute the virtual runtime engine that is configured to execute the application file selected by the user and launches the virtual machine file identified. The Sandbox Manager determines whether the application is to be executed in profile mode. The selection mechanism e.g. a link clicked by the user may include a parameter value e.g. a flag that indicates whether execution of the application file is to be profiled. If the application is to be executed in profile mode the Sandbox Manager instructs the virtual runtime engine to operate in profile mode. As the virtual runtime engine executes the application file in profile mode the Sandbox Manager collects profile information supplied by the virtual runtime engine and stores it in one or more transcripts that may be used to profile a virtual application s access to the underlying original application file e.g. the xlayer file .

A profiling process and process of generating a streaming model from one or more transcript files are described in greater detail in U.S. patent application Ser. No. 12 877 918 filed on Sep. 8 2010 titled Method and System for Building and Distributing Application Profiles via the Internet which is incorporated herein by reference in its entirety.

The system see may be characterized as implementing an application library that includes the uploaded files e.g. the uploaded file illustrated in the copy of the uploaded file illustrated in and the like Application Library Web Services implemented by the application library web services components illustrated in and the Account and Application Library Databases and see .

As mentioned above the server computing device is configured to generate the website see which may include a link for at least a portion of the files identified in the application library. Other computing devices e.g. the client computing device illustrated in may navigate to the website see and select the links to thereby download and or execute the uploaded files. However it may be desirable to restrict execution of the virtualized application files before and or after they are downloaded. Execution of the virtualized application files may be restricted in one or more of the following ways 1 restricting which applications may launch the virtualized application files and 2 issuing session tickets that are required to execute the virtualized application files.

Public key cryptography uses asymmetric key algorithms to create a mathematically related pair of keys referred to as a private key and a public key. However the private key cannot be generated from the public key. The private key is generally kept secret and the public key is generally made available to others.

The private and public keys may be used to authenticate messages or data. For example the private key may be used to create a digital signature of a message or data that can be verified using the public key. In this manner anyone with the public key can verify the message or data was created by an entity associated with the public key. The keys can also be used for security purposes. For example a message or data may be encrypted using the public key which may decrypted using the private key to prevent someone other than the entity associated with the private key from decrypting the message. The entity may generate the public and private keys.

A Certificate Authority e.g. Verisign Inc. issues a public key certificate commonly referred to as a digital certificate that binds the public key with identity information using a digital signature. The digital signature may be created using a private key associated with the Certificate Authority that can be verified using a public key stored in a public key certificate associated with the Certificate Authority.

A public key certificate issued by the Certificate Authority can be used to verify that the public key belongs to the entity. For example third parties can verify the signature provided by the Certificate Authority using the public key certificate associated with the Certificate Authority. Thus the digital signature provided by the Certificate Authority that issued the public key certificate attests that the identity information and the public key included in the public key certificate are associated with one another. In other words the public key certificate associated with the Certificate Authority may be used to endorse the public key and identity information included in the public key certificate associated with the entity.

Turning to in a method the private and public keys are associated with an authorized entity tasked with providing at least in part a managed distribution environment for a virtualized application file e.g. the xlayer file illustrated in . A managed distribution environment includes one or more applications e.g. the Sandbox Manager illustrated in that among other things control the launching of virtual applications. In the method a public key certificate including the public key and identification information associated with the authorized entity may have been issued exclusively to the authorized entity by a Certificate Authority such as a globally accepted certificate authority e.g. like Verisign Inc. .

As explained above the Sandbox Manager may launch a virtualized application file e.g. the executable virtualized application file the xlayer file and the like . Some virtualized application files e.g. the xlayer file are launched by the virtual runtime engine implemented by one of the virtual machine files illustrated in which is launched by the Sandbox Manager . Thus in some implementations the Sandbox Manager may be characterized as launching the virtualized application file via the virtual runtime engine .

Access to a virtual application may be restricted by restricting the ability to launch virtualized application files to only authorized applications e.g. the Sandbox Manager . Any application capable of performing the launching function may be signed using a signing algorithm and the private key associated with the authorized entity providing the managed distribution environment for the virtualized application file. Thus applications capable of performing the launching function may include a digital signature. The virtual application or the virtual runtime engine may condition execution of the virtualized application file on whether the digital signature is valid and associated with the authorized entity that provides at least in part the managed distribution environment for the virtualized application file.

The digital signature may be included in an executable of the authorized application created by a build process. During the build process the executable may be signed using a signing algorithm and the private key associated with the authorized entity. A certificate signing tool e.g. signtool.exe developed by Microsoft Corporation may be used to create the digital signature. The public key certificate associated with the authorized entity may also be included in or associated with the executable of the authorized application.

Non limiting example implementations of portions of the method are provided below using pseudo code. In the pseudo code provided below function calls preceded by are calls to actual Windows APIs provided in a pseudo code format.

Referring to the Sandbox Manager may begin execution of the virtual runtime engine and instruct the virtual runtime engine to begin executing the virtualized application file. In such implementations the Sandbox Manager is a parent process with respect to the virtual runtime engine which is executing the virtualized application file.

Returning to in first block the virtual runtime engine is launched. In block the virtual runtime engine may be launched by a launching application e.g. the Sandbox Manager . In such implementations the launching application is the parent process of the launched virtual runtime engine which begins executing as a child process.

While the method is described as being for use with a virtualized application file the method may be used for other application files that are launched by a launching application and execute as a child processes of the launching application.

In block the virtual runtime engine reads the configuration information of the virtualized application file e.g. the configuration data of the xlayer file illustrated in . Among other settings the configuration information includes the DRM indicator that indicates whether to check a digital signature using a public key certificate associated with the parent process e.g. the Sandbox Manager . The value of the DRM indicator may be recorded during reading of the configuration information to be accessed by this process later.

Then in decision block the virtual runtime engine determines whether the value of the DRM indicator indicates a digital signature associated with the parent process is to be validated. The decision in decision block is YES when the value of the DRM indicator indicates a digital signature associated with the parent process is to be validated. On the other hand the decision in decision block is NO when the value of the DRM indicator indicates a digital signature associated with the parent process is not to be validated.

When the decision in decision block is NO in block the virtual runtime engine executes the virtualized application file. Thus when the value of the DRM indicator indicates a digital signature associated with the parent process is not to be validated the virtual application will always run. The following pseudo code provides a non limiting example of an implementation of decision block and what occurs when the decision in decision block is NO. 

In the pseudo code above the value of the DRM indicator read from the virtualized application file is stored in a Boolean variable named checkParentProcessFlag. If the value of the checkParentProcessFlag variable is FALSE the virtualized application file is executed by a function named RunApplication. 

When the decision in decision block is YES in decision block the virtual runtime engine determines whether it has a parent process.

The decision in decision block is YES when the virtual runtime engine has a parent process. Otherwise the decision in decision block is NO when the virtual runtime engine does not have a parent process. When the decision in decision block is NO in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates. The following pseudo code provides a non limiting example of an implementation of decision block and optional block .

In the above pseudo code a variable named parentProcessHandle stores a handle to a parent process e.g. the Sandbox Manager of the current process e.g. the virtual runtime engine . If the current process does not have a parent process the variable named parentProcessHandle stores a value that is not a valid process handle. If a function named IS INVALID HANDLE is called with the value stored in the variable named parentProcessHandle and returns TRUE the virtual runtime engine does not have a parent process and an error message is displayed by calling a function named DisplayError. Otherwise if the function named IS INVALID HANDLE returns FALSE the virtual runtime engine has a parent process.

When the decision in decision block is YES in decision block the virtual runtime engine determines whether the parent process has an associated digital signature. The decision in decision block is YES when the parent process is associated with a digital signature. On the other hand the decision in decision block is NO when the parent process is not associated with a digital signature. When the decision in decision block is NO in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates. The following pseudo code provides a non limiting example of an implementation of decision block and optional block .

In the above pseudo code the handle to the parent process obtained by the pseudo code implementing decision block is used to obtain the file name of a file implementing the parent process. For example if the handle to the parent process is the Sandbox Manager and the Windows API function named GetProcessImageFileName is called with the handle to the parent process the function named GetProcessImageFileName will set the value of an output parameter e.g. an output parameter named parentProcessFilename to the file name of the executable file storing the instructions implementing the parent process. A call to a Windows API function named CryptQueryObject is used to retrieve information about the contents of a digital signature stored in the executable file implementing the parent process. The function named CryptQueryObject returns an error value e.g. zero if the file does not contain a digital signature. Otherwise the function named CryptQueryObject returns a value indicating an error has not occurred e.g. a value other than zero . A function named IS ERROR is used to determine whether the function named CryptQueryObject returned an error value. If an error value was returned the function named DisplayError is called to display the error.

When the decision in decision block is YES in decision block the virtual runtime engine determines whether the digital signature stored in the executable file implementing the parent process is associated with the authorized entity. The executable file implementing the parent process may include an entity identifier that identifies an entity that created the executable file implementing the parent process or is otherwise associated with the parent process. The entity identifier may be included in a copy of the public key certificate included in the executable file implementing the parent process. The entity identifier may compared to a predetermined value associated with the authorized entity to determine whether the executable file implementing the parent process is associated with the authorized entity. If the entity identifier matches the predetermined value associated with the authorized entity the digital signature stored in the executable file implementing the parent process is associated with the authorized entity. Otherwise if the entity identifier fails to match the predetermined value associated with the authorized entity the digital signature stored in the executable file implementing the parent process is not associated with the authorized entity. The decision in decision block is YES when the digital signature stored in the executable file implementing the parent process is associated with the authorized entity. On the other hand the decision in decision block is NO when the digital signature stored in the executable file implementing the parent process is not associated with the authorized entity.

As explained above the digital signature is created using the private key associated with the authorized entity. The public key certificate is used to determine whether the digital signature is associated with the authorized entity. A copy of the public key certificate may be stored in the executable file implementing the parent process. Alternatively the virtual runtime engine may include a copy of the public key certificate.

When the decision in decision block is NO in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates. The following pseudo code provides a non limiting example of an implementation of decision block and optional block .

In the pseudo code above the virtual runtime engine calls the Windows API function named CryptMsgGetParam to obtain information related to a signer of the digital signature. This information is stored by the function named CryptMsgGetParam in an output parameter named signerInfo. A function named CertFindCertificateInStore is used to locate information stored in the public key certificate associated with the information stored in the parameter named signerInfo. The information stored in the public key certificate is stored in an output parameter named certInfo. Then a Windows API function named CertGetNameString is called using the parameter named certInfo to obtain the name of the signer from the public key certificate which is stored in an output parameter named certName. If the name of the signer is not equal to the name of the authorized entity e.g. a value stored in a variable named CodeSystemsCertName the function named DisplayError is called to display the error.

When the decision in decision block is YES in decision block the virtual runtime engine determines whether the digital signature stored in the executable file implementing the parent process is valid. The digital signature may determined by encrypting a value using the private key. The value that is to be encrypted is determined based on the executable file implementing the parent process. For example the value may be a result of a function e.g. a hash function performed on the executable file implementing the parent process or a portion thereof. As is apparent to those of ordinary skill in the art validity of the digital signature may be determined by decrypting the digital signature using the public key. The decrypted digital signature may be compared to a second value determined using the same function performed on the executable file implementing the parent process that was used to create the value encrypted in the digital signature. If the decrypted digital signature matches the second value the digital signature is valid. On the other hand if the decrypted digital signature does not match the second value the digital signature is invalid. The decision in decision block is YES when the digital signature stored in the executable file implementing the parent process is valid. The decision in decision block is NO when the certificate stored in the executable file implementing the parent process is invalid.

When the decision in decision block is NO in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates.

When the decision in decision block is YES the virtual runtime engine advances to block whereat the virtual runtime engine executes the virtualized application file.

The following pseudo code provides a non limiting example of an implementation of decision block optional block and block .

In the pseudo code above the virtual runtime engine calls the Windows API function named CertGetCertificateChain to build a certificate chain context starting from an end certificate a variable named certContext stores a pointer to the end of the certificate and going back if possible to a trusted root certificate. A pointer to the certificate chain context is stored in an output parameter named chainContext. 

A function named IS UNTRUSTED CERTIFICATE CHAIN is used to determine whether the certificate chain context is invalid. If the certificate chain context is invalid the function named IS UNTRUSTED CERTIFICATE CHAIN returns TRUE and the function named DisplayError is called to display the error. Otherwise if the certificate chain context is valid the function named IS UNTRUSTED CERTIFICATE CHAIN returns FALSE and the function named RunApplication is called to execute the virtualized application file.

As is apparent to those of ordinary skill in block and or block the digital signature of the public key certificate may be validated using the public key certificate of the Certificate Authority to confirm that the identity information stored in the public key certificate associated with the authorized entity is valid.

When the virtual runtime engine finishes executing the virtualized application file in block the method terminates.

In the method when the value of the DRM indicator indicates a digital signature associated with the parent process is to be validated the decision in decision block is YES the virtual runtime engine will try to validate a digital signature associated with the parent process at runtime and will continue executing the virtualized application file only if the digital signature is valid. If the digital signature is invalid the virtual runtime engine will terminate execution of the virtualized application file. The method may be characterized as implementing certificate based DRM.

With the security mechanisms implemented by the method it may still be possible for an unauthorized party to send signals to a certified application e.g. the Sandbox Manager that will cause the certified application to launch virtualized application files e.g. via the virtual runtime engine on behalf of the unauthorized party. Referring to this may be avoided by requiring a valid session ticket whenever the virtualized application file is launched. Methods of using the session ticket to restrict launch of the virtualized application file e.g. a method described below and illustrated in may be characterized as implementing ticket based DRM. Ticket based DRM may be used in addition to or instead of certificate based DRM.

The session ticket may be implemented as a XML blob storing an expiration date. By way of a non limiting example the session ticket may be implemented as a custom XML document designed to be parsed by both .NET languages as well as low level C code which may have limited access to libraries implementing more rich XML based digital signatures commonly referred to as XMLDSIGs .

The session ticket may be signed using a signing algorithm and the private key associated with the authorized entity tasked with providing at least in part a managed distribution environment for the virtualized application file e.g. the virtualized application file the xlayer file and the like . Thus a digital signature may be associated with the session ticket . The public key and private key used to implement the session ticket may both be generated by the authorized entity. The virtual runtime engine may include the public key so that the public key need not be included in the virtualized application file or passed to the virtual runtime engine . Thus a public key certificate is not required to validate the session ticket . The digital signature and the public key are used to determine whether the session ticket is associated with the authorized entity.

If the digital signature is invalid as determined using the public key or launch is initiated after the expiration date stored by the session ticket the Sandbox Manager and or the virtual runtime engine will not launch the virtual application file.

The Data element includes a Payload field and an Expiration field. Between a start tag and an end tag the Payload field stores an application defined payload e.g. data . By way of a non limiting example the application defined payload may be implemented as an opaque blob of bytes converted to a base64 string within the XML. Between a start tag and an end tag the Expiration field stores an expiration date. By way of a non limiting example the Expiration field may be implemented as a Windows FILETIME variable converted first into raw 8 bytes and then into a base64 string within the XML. The expiration date may be formatted as a Coordinated Universal Time UTC value. The fields stored in the Data element may be signed so that they will be tamper resistant.

The Signature element includes a Value field and may optionally include other fields not shown . Between a start tag and an end tag the Value field stores the digital signature. The digital signature is determined by encrypting a value using the private key. By way of a non limiting example the value that is encrypted may be determined as a function e.g. a hash function of the Data element of the session ticket or a portion thereof. For example the value that is encrypted may be determined based on the Payload field and or the Expiration field of the session ticket .

Due to the nature of asymmetric cryptography it is believed to be cryptographically impossible to create the session ticket without the private key. Thus by validating the digital signature stored in the Value field of the Signature element one can establish that the session ticket was created by the authorized entity e.g. operating the server computing device illustrated in .

While the method is described below as being for use with a virtualized application file the method may be used for other application files.

In block the server computing device determines whether the user is logged into a user account. The decision in decision block is YES when the user is logged into a user account. On the other hand the decision in decision block is NO when the user is not logged into a user account.

When the decision in decision block is NO in block the user enters login information that is received by the server computing device . If user is not currently logged in a login prompt is presented to the user allowing the user to enter their account information. The account information is submitted to the server computing device .

In decision block the server computing device determines whether the user entered valid account information. In decision block the account information entered by the user may be validated on a trusted backend server not shown . Further the account information may be validated by querying the Account Database . The decision in decision block is YES when the user has entered valid account information. On the other hand the decision in decision block is NO when the user has entered invalid account information.

When the decision in decision block is YES in block a login session is created. In block the session ticket is also created. Information related to the login session may be wrapped in the session ticket. The information related to the login session may be implemented as a BYTE blob passed as a payload to the session ticket . In other words the information related to the login session may be stored in the Payload field of the session ticket .

When the decision in decision block is YES the session ticket was created previously when the user logged onto a valid user account.

The following pseudo code provides a non limiting example of a method of creating the session ticket .

In block the session ticket is transmitted to the Sandbox Manager e.g. via the Client Application along with a request to download and launch the virtualized application file selected in block . The session ticket may be sent to the Sandbox Manager as one or more parameters e.g. command line parameters sent with the launch request. As described in the U.S. patent application Ser. No. 12 695 107 other parameters may also be sent to the Sandbox Manager along with the launch request.

In block the Sandbox Manager downloads and launches the virtualized application file selected in block and stores the session ticket in one or more fields within the block of shared memory illustrated in . The following pseudo code provides a non limiting example of a data structure named SSessionInfo that may be used to implement the block of shared memory including the fields configured to store the session ticket .

Returning to in block the virtual runtime engine reads the session ticket from the block of shared memory and stores the session ticket in a string variable. In block the virtual runtime engine also reads the DRM indicator from the loaded configuration information of the virtualized application file e.g. the configuration data of the xlayer file illustrated in . As explained above the loaded configuration information may be stored in a virtual application configuration file.

In decision block the virtual runtime engine determines whether the value of the DRM indicator indicates the value in the Signature element of the session ticket is to be validated. The decision in decision block is YES when the value of the DRM indicator indicates the value in the Signature element of the session ticket is to be validated. On the other hand the decision in decision block is NO when the value of the DRM indicator indicates the value in the Signature element of the session ticket is not to be validated.

When the decision in decision block is NO in block the virtual runtime engine executes the virtualized application file. When execution of the virtualized application file has finished the method terminates.

When the decision in decision block is YES in decision block the virtual runtime engine determines whether the value in the Signature element of the session ticket is valid. As is apparent to those of ordinary skill in the art the virtual runtime engine may determine the validity of the digital signature stored by the Signature element by decrypting the digital signature using the public key. As discussed above the virtual runtime engine may include a copy of the public key associated with the authorized entity. As also discussed above the digital signature may be created by encrypting a value using the private key. By way of a non limiting example the value that is encrypted may be determined as a function e.g. a hash function of the Data element of the session ticket or a portion thereof. The decrypted digital signature may be compared to a second value determined using the same function of the Data element or a portion thereof used to create the value encrypted in the digital signature. For example the value encrypted to create the digital signature may have been determined as a function of the Payload field and or the Expiration field. In this example the second value is determined using the same function of the Payload field and or the Expiration field. If the decrypted digital signature matches the second value the digital signature is valid. On the other hand if the decrypted digital signature does not match the second value the digital signature is invalid. A valid session ticket originated from the authorized entity. An invalid session ticket did not originate from the authorized entity. The decision in decision block is YES when the value in the Signature element of the session ticket is valid. On the other hand the decision in decision block is NO when the value in the Signature element of the session ticket is invalid.

When the decision in decision block is NO in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates.

When the decision in decision block is YES in decision block the virtual runtime engine determines whether the session ticket has expired. The decision in decision block is YES when the session ticket has expired. On the other hand the decision in decision block is NO when the session ticket has not expired. The virtual runtime engine determines whether the session ticket has expired by comparing the value stored in the Expiration field of the Data element of the session ticket to a current time. If the value stored in the Expiration field of the Data element of the session ticket is after the current time the virtual runtime engine determines the session ticket has not expired. Otherwise if the value stored in the Expiration field of the Data element of the session ticket is before the current time the virtual runtime engine determines the session ticket has expired.

When the decision in decision block is YES in optional block the virtual runtime engine displays an error. Next in block the virtual runtime engine terminates execution of the virtualized application file. Then the method terminates.

When the decision in decision block is NO in block the virtual runtime engine executes the virtualized application file. When execution of the virtualized application the has finished the method terminates.

The following pseudo code provides an exemplary implementation of decision blocks and . The pseudo code below includes a function named ValidateSessionTicket that returns TRUE if the digital signature stored in the Signature element of the session ticket is valid and the session ticket has not yet expired. Otherwise the function named ValidateSessionTicket returns FALSE. 

Thus when the value of the DRM indicator indicates the value in the Signature element of the session ticket is to be validated the session ticket is validated and the expiration date provided by the session ticket is checked against the current time. If session ticket is valid and has not expired the virtualized application file is allowed to execute.

Session tickets may be used to require users to execute virtual application files from the website illustrated in . Alternatively until the session ticket expires the Sandbox Manager may execute a locally stored copy of the virtual application file. However the session ticket may be configured to expire shortly after it is created to thereby restrict the launch of virtualized application file to within the managed distribution environment.

Moreover those skilled in the art will appreciate that implementations may be practiced with other computer system configurations including hand held devices multiprocessor systems microprocessor based or programmable consumer electronics network PCs minicomputers mainframe computers and the like. Implementations may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules may be located in both local and remote memory storage devices.

The exemplary hardware and operating environment of includes a general purpose computing device in the form of a computing device . Each of the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented using one or more computing devices like the computing device . By way of non limiting example the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented on the computing device . Further each of the server computing device the server computing device the client computing device the client computing device the Account Database and the Application Library Database may be implemented by computing devices substantially similar to the computing device .

The computing device includes the system memory a processing unit and a system bus that operatively couples various system components including the system memory to the processing unit . There may be only one or there may be more than one processing unit such that the processor of computing device comprises a single central processing unit CPU or a plurality of processing units commonly referred to as a parallel processing environment. The computing device may be a conventional computer a distributed computer or any other type of computer.

The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory and includes read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within the computing device such as during start up is stored in ROM . The computing device further includes a hard disk drive for reading from and writing to a hard disk not shown a magnetic disk drive for reading from or writing to a removable magnetic disk and an optical disk drive for reading from or writing to a removable optical disk such as a CD ROM DVD or other optical media.

The hard disk drive magnetic disk drive and optical disk drive are connected to the system bus by a hard disk drive interface a magnetic disk drive interface and an optical disk drive interface respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable instructions data structures program modules and other data for the computing device . It should be appreciated by those skilled in the art that any type of computer readable media which can store data that is accessible by a computer such as magnetic cassettes flash memory cards USB drives digital video disks Bernoulli cartridges random access memories RAMs read only memories ROMs and the like may be used in the exemplary operating environment. As is apparent to those of ordinary skill in the art the hard disk drive and other forms of computer readable media e.g. the removable magnetic disk the removable optical disk flash memory cards USB drives and the like accessible by the processing unit may be considered components of the system memory .

A number of program modules may be stored on the hard disk drive magnetic disk optical disk ROM or RAM including an operating system one or more application programs other program modules and program data . A user may enter commands and information into the computing device through input devices such as a keyboard and pointing device . Other input devices not shown may include a microphone joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a serial port interface that is coupled to the system bus but may be connected by other interfaces such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video adapter . In addition to the monitor computers typically include other peripheral output devices not shown such as speakers and printers.

The input devices described above are operable to receive user input and selections. Referring to the display device is operable to display the web page and other web pages generated by the server computing device illustrated in . Together the input and display devices may be described as providing a user interface.

Returning to the computing device may operate in a networked environment using logical connections to one or more remote computers such as remote computer . These logical connections are achieved by a communication device coupled to or a part of the computing device as the local computer . Implementations are not limited to a particular type of communications device. The remote computer may be another computer a server a router a network PC a client a memory storage device a peer device or other common network node and typically includes many or all of the elements described above relative to the computing device . The remote computer may be connected to a memory storage device . The logical connections depicted in include a local area network LAN and a wide area network WAN . Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computing device is connected to the local area network through a network interface or adapter which is one type of communications device. When used in a WAN networking environment the computing device typically includes a modem a type of communications device or any other type of communications device for establishing communications over the wide area network such as the Internet. The modem which may be internal or external is connected to the system bus via the serial port interface . In a networked environment program modules depicted relative to the personal computing device or portions thereof may be stored in the remote computer and or the remote memory storage device . It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.

The computing device and related components have been presented herein by way of particular example and also by abstraction in order to facilitate a high level view of the concepts disclosed. The actual technical design and implementation may vary based on particular implementation while maintaining the overall nature of the concepts disclosed.

Returning to the system memory A the system memory B the system memory C and the system memory D may each be substantially similar to the system memory . Thus the host operating system A the host operating system B the host operating system the host operating system D the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be stored as computer executable components on the system memory A C and or D. Each of the host operating system A the host operating system the host operating system C the host operating system D the virtual application file the xlayer file the Client Application the Sandbox Manager the authoring tool including the wizard the web server components A the web server components B the application library web services implemented by the application library web services components illustrated in and or the virtual runtime engine may be implemented using software components that are executable by the processing unit and when executed perform the functions described above. Further the methods and may each be implemented as computer executable instructions that are executable by the processing unit . Such instructions may be encoded on one or more non transitory computer readable mediums for execution by one or more processing units.

The foregoing described embodiments depict different components contained within or connected with different other components. It is to be understood that such depicted architectures are merely exemplary and that in fact many other architectures can be implemented which achieve the same functionality. In a conceptual sense any arrangement of components to achieve the same functionality is effectively associated such that the desired functionality is achieved. Hence any two components herein combined to achieve a particular functionality can be seen as associated with each other such that the desired functionality is achieved irrespective of architectures or intermedial components. Likewise any two components so associated can also be viewed as being operably connected or operably coupled to each other to achieve the desired functionality.

While particular embodiments of the present invention have been shown and described it will be obvious to those skilled in the art that based upon the teachings herein changes and modifications may be made without departing from this invention and its broader aspects and therefore the appended claims are to encompass within their scope all such changes and modifications as are within the true spirit and scope of this invention. Furthermore it is to be understood that the invention is solely defined by the appended claims. It will be understood by those within the art that in general terms used herein and especially in the appended claims e.g. bodies of the appended claims are generally intended as open terms e.g. the term including should be interpreted as including but not limited to the term having should be interpreted as having at least the term includes should be interpreted as includes but is not limited to etc. . It will be further understood by those within the art that if a specific number of an introduced claim recitation is intended such an intent will be explicitly recited in the claim and in the absence of such recitation no such intent is present. For example as an aid to understanding the following appended claims may contain usage of the introductory phrases at least one and one or more to introduce claim recitations. However the use of such phrases should not be construed to imply that the introduction of a claim recitation by the indefinite articles a or an limits any particular claim containing such introduced claim recitation to inventions containing only one such recitation even when the same claim includes the introductory phrases one or more or at least one and indefinite articles such as a or an e.g. a and or an should typically be interpreted to mean at least one or one or more the same holds true for the use of definite articles used to introduce claim recitations. In addition even if a specific number of an introduced claim recitation is explicitly recited those skilled in the art will recognize that such recitation should typically be interpreted to mean at least the recited number e.g. the bare recitation of two recitations without other modifiers typically means at least two recitations or two or more recitations .

