---

title: Deployment version management
abstract: Customers wanting to deploy software packages, or updates to those packages, across a group of servers or other computing resources can rely upon a component such as a resource manager to manage the deployment. The resource manager can utilize a data structure that stores deployment information by Revision number, and merges information for each verified deployment into a Mainline for those resources. Each Deployment can involve an Individual Release or a Baseline Release, and the importance of those Releases can be determined with respect to a current snapshot of the Mainline. Such an approach enables important Release and Deployment information to be quickly determined and obtained, which can help with configuring and scheduling future Deployments.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09235409&OS=09235409&RS=09235409
owner: Amazon Technologies, Inc.
number: 09235409
owner_city: Reno
owner_country: US
publication_date: 20121030
---
As an increasing number of applications and services are being made available over networks such as the Internet an increasing number of content application and or service providers are turning to technologies such as cloud computing. Cloud computing in general is an approach to providing access to electronic resources through services such as Web services where the hardware and or software used to support those services is dynamically scalable to meet the needs of the services at any given time. A customer typically will rent lease or otherwise pay for access to resources through the cloud such that the customer does not have to purchase and maintain the hardware and or software to provide access to these resources. In many cases the resources will include a fleet of host machines or servers that are operable to execute various applications and in at least some cases can run one or more virtual machines associated with those applications. The environment can be a distributed environment such that portions of the fleet of servers can be located in different geographical areas. When updates to various applications are to be deployed for a large number of servers in a variety of different areas it can be desirable to stagger the deployment to these various areas in order to be able to more easily manage and or monitor aspects of the deployment. For a large number of users who can each deploy a number of application updates to a variety of different servers across the environment managing the versions and deployments over time can be complex and failure to properly determine which versions of which applications are deployed on which servers can potentially result in errors or even data loss or corruption among other such potential problems.

Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more of the aforementioned and other deficiencies experienced in conventional approaches to managing computing resources. In particular various embodiments facilitate the updating of software on target computing devices such as host machines or servers in an electronic environment. In at least some embodiments customers can deploy and update software packages or software version entities to execute on at least a subset of a group of servers host machines or other such computing resources. When a customer wants to deploy any of these software packages or updates to the packages across at least a portion of the computing resources the customer can submit information for the deployment. A component such as a resource manager can then manage the deployment. The resource manager can utilize a data structure that stores deployment information by Revision number and merges information for each verified Deployment into a Mainline for those resources. Each Deployment can involve an Individual Release or a Baseline Release and the importance of those Releases can be determined with respect to a current snapshot of the Mainline. Such an approach enables important Release and Deployment information to be quickly determined and obtained which can help with configuring and scheduling future Deployments.

Various other applications processes and uses are presented below with respect to the various embodiments.

In various embodiments the distributed environment may include various types of resources that can be utilized by multiple users for a variety of different purposes. In at least some embodiments all or a portion of a given resource or set of resources might be allocated to a particular customer or allocated for a particular task for at least a determined period of time. The sharing of these resources from a distributed environment is often referred to as resource sharing Web services or cloud computing among other such terms and depending upon the specific environment and or implementation. In this example the distributed environment includes a plurality of resources of one or more types. These types can include for example application servers operable to process instructions provided by a user or database servers operable to process data stored in one or more data stores in response to a user request. As known for such purposes the customer can also reserve at least a portion of the data storage in a given data store. Methods for enabling a customer to reserve various resources and resource instances are well known in the art such that detailed description of the entire process and explanation of all possible components will not be discussed in detail herein.

In at least some embodiments a user wanting to utilize at least a portion of the resources can submit a request that is received to an interface layer of the multi tenant environment . The interface layer can include application programming interfaces APIs or other exposed interfaces enabling a user to submit requests to the multi tenant environment. The interface layer in this example can also include other components as well such as at least one Web server routing components load balancers and the like. When a request to provision a resource such as a virtual machine is received to the interface layer for example information for the request can be directed to a resource manager or other such system service or component configured to manage user accounts and information resource provisioning and usage and other such aspects. A resource manager receiving the request can perform tasks such as to authenticate an identity of the user submitting the request as well as to determine whether that user has an existing account or is associated with a customer having an existing account with the resource provider where the account data may be stored in at least one data store in the provider environment. A user can provide any of various types of credentials in order to authenticate an identity of the user to the provider. These credentials can include for example a username and password pair biometric data a digital signature or other such information. The provider can validate this information against information stored for the user. If the user has an account with the appropriate permissions status etc. the resource manager can determine whether there are adequate resources available to suit the user s request and if so can provision the resources or otherwise grant access to the corresponding portion of those resources for use by the user for an amount specified by the request. This amount can include for example capacity to process a single request or perform a single task a specified period of time or a recurring renewable period among other such values. If the user is not associated with a valid account with the provider an associated account does not enable access to the type of resources specified in the request or another such reason is preventing the user from obtaining access to such resources a communication can be sent to the user or associated customer to enable the user to create or modify an account or change the resources specified in the request among other such options.

Once the user and or request is authenticated the account verified and the resources allocated the user can utilize the allocated resource s for the specified capacity amount of data transfer period of time or other such metric. In at least some embodiments a user might provide a session token or other such credentials with subsequent requests in order to enable those requests to be processed on that user session. The user can receive a resource identifier specific address or other such information that can enable the client device to communicate with an allocated resource without having to communicate with the resource manager at least until such time as a relevant aspect of the user account changes the user is no longer granted access to the resource or another such aspect changes.

The resource manager or another such system or service in this example can also function as a virtual layer of hardware and software components that handles control functions in addition to management actions as may include provisioning version management scaling replication etc. The resource manager can utilize dedicated APIs in the interface layer where each API can be provided to receive requests for at least one specific action to be performed with respect to the data environment such as to provision scale clone or hibernate an instance. Upon receiving a request to one of the APIs a Web services portion of the interface layer can parse or otherwise analyze the request to determine the steps or actions needed to act on or process the call. For example a Web service call might be received that includes a request to create a data repository.

An interface layer in at least one embodiment includes a scalable set of customer facing servers that can provide the various APIs and return the appropriate responses based on the API specifications. The interface layer also can include at least one API service layer that in one embodiment consists of stateless replicated servers which process the externally facing customer APIs. The interface layer can be responsible for Web service front end features such as authenticating customers based on credentials authorizing the customer throttling customer requests to the API servers validating user input and marshalling or unmarshalling requests and responses. The API layer also can be responsible for reading and writing database configuration data to from the administration data store in response to the API calls. In many embodiments the Web services layer and or API service layer will be the only externally visible component or the only component that is visible to and accessible by customers of the control service. The servers of the Web services layer can be stateless and scaled horizontally as known in the art. API servers as well as the persistent data store can be spread across multiple data centers in a region for example such that the servers are resilient to single data center failures.

As mentioned a component or service such as a resource manager can be tasked with managing the provisioning of resources as well as the updating of those resources. In at least some embodiments a customer can submit a request to the resource manager to begin updating one or more deployments across the distributed environment. In many instances the customer will not want to have to deal with various functional aspects of the deployment such as where the deployment is to occur and when to deploy at each of those locations. The customer may instead prefer to provide the information necessary to update an application or other such package and rely upon the functionality of the distributed environment to manage the physical deployment. Such an approach can be complex for the resource management component however as there can be multiple customers at any given time who are interested in performing deployments across the environment. The resource manager then must not only be able to track and schedule all of these deployments but must also keep track of the versions deployed at each location such that no deployment inadvertently impacts another deployment.

Approaches in accordance with various embodiments utilize a deployment data structure for purposes of tracking the deployment instructions of various users. When a component such as a resource manager wants to perform a deployment the resource manager can analyze the information stored according to the data structure to determine important deployment information such as which versions of which packages were deployed in which locations. The resource manager can obtain from the data structure a snapshot of the current deployment which can be used as a starting point for the update. Each update can be associated with an updated revision number of the deployment state which can be used to ensure each future revision builds on the current revision. As deployments occur those deployments can be updated with information for revisions implemented since the start of that deployment process. Such a data structure can be efficient for a computing process to access and utilize in at least some embodiments.

An example data structure in accordance with various embodiments builds upon at least two concepts a Release and a Deployment. A Release as used herein refers to a set of changes as may include version information for one or more packages that is to be deployed to appropriate locations across a distributed environment. The Release does not include information about where or when to deploy but instead includes information such as upgrade information that is to be deployed to each host machine or other such component within the scope of the deployment. A Deployment as used herein refers to the action of causing the release to be installed or otherwise made available on a particular host or set of host machines. A Deployment thus includes information such as which Release to deploy and where to deploy the Release e.g. which hosts as well as when to start at least portions of the deploying. In at least some embodiments a Deployment can include a list or other identification of a subset of hosts of the environment as well as timing information as to when each host or set of hosts is to receive the corresponding Release.

The data structure also defines at least three different types of Releases. A first type is referred to herein as a Mainline Release. A Mainline refers to a repository that records the state of a set of software deployments. A Mainline can contain information about the latest version of each of several deployed packages. A resource manager or other entity can determine the current state of the fleet or at least the latest version of each package deployed on at least a portion of that fleet by obtaining a copy of the Mainline. The Mainline thus can provide information about the current deployment and is not used to deploy future packages. There also can be at least two deployable releases referred to herein as Baseline and Individual Releases. A Baseline Release enables a customer to bundle updates to be deployed in a single action. The Baseline Release utilizes a Baseline as a starting point where the Baseline functions as a snapshot of the Mainline release providing information about the most recent version of any package previously deployed across a respective fleet. A Baseline in some embodiments can be used to deploy the current latest version of each package that accumulated in the past to a new set of host machines in the environment. The Baseline also can be used as a starting point for an additional deployment or upgrade. For example a customer can obtain a copy of a Baseline and store a local copy of the baseline for purposes of testing and or configuration an update for deployment. Such an approach allows the update to be tested against a specific state of the fleet without actually affecting or impacting the fleet. A customer then can make changes using the Baseline and schedule deployment against the Baseline as well.

Once the update is ready to be deployed the Deployment can be scheduled by the resource manager. As discussed the Deployment could be scheduled at different times for different locations across the distributed environment. In at least some embodiments the resource manager or another appropriate component must first verify the Deployment before proceeding. During the verification process the resource manager might choose to merge the changes from the Mainline into the Deployment such that the update can occur with respect to any updates since the Baseline for the update was obtained. After the Deployment is verified and the update passes any quality control processes the changes from the Baseline can be merged into the Mainline such that the Mainline represents the most current version of any package updated by the Baseline Release. Thus the Baseline once deployed becomes a permanent part of the Mainline.

The data structure also includes an Individual Release type. It might be the case that the customer wants to deploy a single package and may not care about the state of other packages. Accordingly the customer can create a small space for working on the Individual type of release without first obtaining a Baseline from which to work. The customer can create and deploy Individual Releases independent of how other Releases are deployed to the same group of machines. Once the software is properly verified the information for the Individual Release can be merged with the Mainline and become a permanent part of the Mainline.

In order for the resource manager to be able to manage all these deployments the data structure needs to be able to store the information for all the Releases and Deployments but be able to surface only those Deployments that are important for a future Deployment at any time. The resource manager can examine the data in the data structure and provide the customer with a small number of important Release deployments even though there may have been thousands of deployments or more across the distributed environment. The data structure then needs to include information about when certain events occurred and the relative importance of those events. Specifically if a customer creates a Baseline Release and deploys that Baseline to every host machine in the environment the Mainline should reflect the information from that Baseline release and a customer should not have to worry about any deployments before that Baseline release as the Baseline release builds upon the Mainline at the time the Baseline was created. Thus all previous events e.g. deployments will be reflected in the latest Baseline and thus the Mainline after the Baseline is merged.

Accordingly the data structure includes branching and versioning information in at least some embodiments. The data structure can utilize a Revision number or other versioning information to reflect each time a change is made to the Mainline such as when an Individual or Baseline Release is deployed. The Revision number can assist in determining effective releases and or determining which releases are important. For example consider the portions of a Revision timeline illustrated in and . In this example there is a first Revision that corresponds to the initial deployment of three different packages a b and c. As illustrated the version number for packages a b and c for Revision 1 are each 1.0. While the state of the system is in Revision 1 an Individual Release for customer A is started. Because the Release is an Individual Release the Release does not need to start with a Baseline and thus can be assigned a Revision value of 0. Each Individual Release can start with a value of 0 indicating that the update is not with respect to any Baseline or other state of the system. When the Individual Release is deployed and verified information for the Individual Release can be merged back into the Mainline . As illustrated the Revision version of package a has gone from 1.0 to 2.0 although other update values can be used as well within the scope of the various embodiments. Further to reflect the update the Revision number for the Mainline has been updated to 2.0.

As also illustrated Customer A performed another Individual Release which again starts with Revision value 0. When the Release is deployed and verified information for the Individual Release is merged with the Mainline creating Revision 4. When customer B wants to implement a Baseline Release the Baseline will start at Revision 4 including the value from the Individual Release . In this example the Baseline Release is still ongoing and does not reflect that Revision 5 has occurred as the Revision of the Baseline Release will not be updated until time of a merge with the Mainline.

Such a data structure can be used to track versions of different software packages and can enable a quick accounting of each version that is currently deployed across the distributed environment. As can be seen from these figures however it is possible that for a given time a Deployment will only be partially completed and or completed for certain regions. Further there can be multiple Deployments occurring at the same time. Thus it can be desirable to be able to quickly determine which deployments should be evaluated for a specific point in time.

As illustrated the current time falls sometime towards the end of the day on Friday. Baseline Release A was scheduled to be deployed in Dublin on Monday and everywhere else on Tuesday which completed on Wednesday. Each location indicated by a box can correspond to the location of a data center or server farm in at least some embodiments. Assuming that the initial Revision version was 1 this Deployment when verified would increment the Revision number for the Mainline to 2. Another Release Baseline Release B began deployment first in Northern Europe Nrt then in Dublin then everywhere else. When the Deployment was verified the Revision number incremented to 3. Thus if a Mainline is generated for a request at the current time the Revision number would be 3 and the Mainline could ignore anything from Revision 2 back which means that the Mainline does not need to worry about any of the deployments of Baseline Release A. The changes from Baseline Release A will already be merged into Baseline Release B.

It is not as simple as merely looking at the most recent verified Deployment everywhere however as there are two other Baseline Deployments in process across the environment as well as an Individual Deployment. For example Deployments of Baseline Release C have been deployed in three regions and Deployments of Baseline Release D have been deployed in two regions but neither of these Baseline Releases have been verified and merged back into the Mainline. Accordingly the important Releases and or Deployments that must be examined in order to initiate a deployment at the current time are indicated by the shaded boxes. The important regions correspond to the most recent fully verified Deployment for Baseline Release B which was deployed everywhere. The other important Deployments include the portions of Baseline Release C and Baseline Release D that have been implemented but not yet verified and released back into the Mainline. Any Individual Release with a Revision number of 0 should also be considered to be important. Any Deployments scheduled in the future are also not considered to be important in at least some embodiments. If a customer wants to update one or more packages using a Baseline Release the customer should consider the updates or changes in each of these important Release and Deployment portions. Using a data structure as discussed herein enables the customer a resource manager or another appropriate component or entity to quickly determine the important information to be analyzed while being able to ignore the other information which could include substantially more data than the important information.

It should be understood that other information can be stored using such a data structure and considered during deployments as well. For example there might be multiple fleets of machines where a customer might only want to deploy a Release to one or more of those fleets. Accordingly the data structure can manage different concurrent versions of a release by location or other such information. In some embodiments there can be multiple Mainlines with one Mainline for each fleet. An advantage to a data structure as described herein is that the structure is scalable and supports multiple versions and deployments. The number of Deployments in the past does not affect future Deployments as those Deployments only rely on the important Deployments as discussed herein. A component such as a resource manager can query for the important information stored according to the data structure without worrying about the other deployment information. The system can also allow the customer to specify various information about each Release to be deployed such as what to a desired host state delta changes for software packages and when and where deployments are to be effective. A customer can also have the ability to suspend resume and move deployments at any time.

When determining the important information a matching algorithm can be used to compare Revisions and Release types or other information. In at least some embodiments the matching algorithm is lightweight enough for the system to quickly figure out effective releases for an arbitrary host or set of hosts. To find the effective Releases for a given host for example the matching algorithm in at least some embodiments can iterate over the Baseline Releases from new to old and for each Release iterate over the started deployments from new to old to attempt to match the host with the deployment destination. An initial match can determine the Baseline Release of the host given that there can only be one Baseline Release for a host at a time. The algorithm then can iterate over the Individual releases with Revision 0 or a Revision value greater than the Revision of the Baseline Release found the from previous step. The algorithm then can iterate over the started deployments from new to old and attempt to match a host with the deployment destination. Any matching Individual Release should be returned as an effective Individual Release for that host. Such an approach enables the limited number of relevant releases to be quickly and easily obtained. Similarly for the Baseline Releases the Baseline Releases can be iterated over from new to old by deployment until the first deployment with a destination corresponding to the entire fleet is located. All Baselines iterated over until that point then can be considered to be relevant. All other Baseline Releases before the one with first entire fleet deployment are then considered to be irrelevant to the system. Based at least in part upon the large Baseline Release X with entire fleet deployment all Individual Releases with a Revision value of 0 greater than X can be determined to be relevant to system. Individual releases with revision between 1 and X can be determined to be irrelevant to system.

Example environments discussed herein for implementing aspects in accordance with various embodiments are primarily Web based as relate to Web services and cloud computing but it should be appreciated that although a Web based environment is used for purposes of explanation different environments may be used as appropriate to implement various embodiments. Client devices used to interact with various embodiments can include any appropriate device operable to send and receive requests messages or information over an appropriate network and convey information back to a user of the device. Examples of such client devices include personal computers smart phones handheld messaging devices laptop computers set top boxes personal data assistants electronic book readers and the like. The network can include any appropriate network including an intranet the Internet a cellular network a local area network or any other such network or combination thereof. Components used for such a system can depend at least in part upon the type of network and or environment selected. Protocols and components for communicating via such a network are well known and will not be discussed herein in detail. Communication over the network can be enabled by wired or wireless connections and combinations thereof.

It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks as discussed and suggested herein. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HTML XML or another appropriate structured language in this example. The handling of all requests and responses as well as the delivery of content between a client device and a resource can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein.

A data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. The data store is operable through logic associated therewith to receive instructions from a server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device. Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a non transitory computer readable medium storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depictions of various systems and services herein should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

Various aspects can be implemented as part of at least one service or Web service such as may be part of a service oriented architecture. Services such as Web services can communicate using any appropriate type of messaging such as by using messages in extensible markup language XML format and exchanged using an appropriate protocol such as SOAP derived from the Simple Object Access Protocol . Processes provided or executed by such services can be written in any appropriate language such as the Web Services Description Language WSDL . Using a language such as WSDL allows for functionality such as the automated generation of client side code in various SOAP frameworks.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

