---

title: Method for providing multiple mouse inputs in a remote desktop session
abstract: A computer (host), which is communicating with an interactive whiteboard projector (client) through a remote desktop connection, launches third-party applications supporting multiple mice (i.e. drawing pens) and provides these applications with virtual mouse device and input event signals for each pen device connected on the projector. The applications will behave as if the host system were configured with multiple installed mice, though no added driver or physical connected hardware is present.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788950&OS=08788950&RS=08788950
owner: Seiko Epson Corporation
number: 08788950
owner_city: Tokyo
owner_country: JP
publication_date: 20120215
---
This application is related to commonly owned U.S. patent application Ser. No. 13 332 751 filed Dec. 21 2011 which is hereby incorporated by reference in its entirety.

This method relates generally to the Remote Desktop Service components formerly Terminal Services and Raw Input APIs application programming interfaces of the Microsoft Windows operating systems and pertains specifically to providing input events for multiple client mouse devices to applications running within a remote desktop session.

Conventional projectors generally need to be positioned at far distances from display surfaces to create an adequately large projection area. And without proper mounting and placement the light path emitted may not remain obstruction free. Presenters passing in front of or near those display surfaces often face bright projector light shining into their eyes or they may be colored with the projection image while adding their shadow to the display surface.

Short throw projectors help alleviate these problems and are especially necessary for interactive projection systems. These projectors are ideally positioned on a wall or ceiling above the target display surface. The short throw technology enables the projector to output a sufficiently large screen image onto the wall below and the high mounting provides an unobstructed screen image which can be approached easily by interactive users. Short throw projectors mounted above and close to the target surface also offer diminished light projection into the eyes of presenters attendees and reduce shadows caused when users intersect the light output path. For these reasons many interactive whiteboard systems use short throw projectors for their display component.

In an interactive electronic whiteboard system a digital pen replaces ink and provides an input interface to draw content onto a virtual whiteboard. Traditionally the digital pens are physical hardware elements modeled after their ink counterparts to offer a natural user experience. They may transmit their location or are otherwise remotely monitored for their position over a display surface. Buttons orientations or other unique identifying characteristics of each pen may also be detected by supporting applications and can be used to affect an operation modify or manipulate a drawing feature or change an activity. Computer applications can generate different outputs on the whiteboard surface using such pen interaction. For example the moving pen position information is monitored by a computer application which in turn paints electronic color pixel elements onto a virtual canvas at the corresponding pen position in an application window. The canvas being simultaneously displayed by the application makes it appear as if the electronic ink was deposited and drawn using the virtual pen. This type of technology is not new and electronic painting applications using tablets mice as pen surrogates or other inputs sources are quite popular and readily available.

As interactive whiteboard systems have gained in popularity systems offering support for multiple pen inputs are becoming more desirable. Multiple inputs allow simultaneous users to share in the interaction or provide an easy way to distinguish differing interactive elements with particular input devices. Unfortunately multi input aware application support is limited. Application developers must use system vendor provided APIs for particular hardware or rely on generic operating system support when vendors configure pen inputs to function as mouse devices to maximize application operability. Even the developer APIs in operating systems that allow applications to gain access to multiple devices and their inputs are relatively new or have not been well defined. And operating systems themselves are typically configured for a single user interaction at a time and treat multiple devices of the same type as a single unified device. Multiple mice for example can be attached and recognized by many computers and their operating systems. However manipulation of each individual mouse generally functions to control the single provided system pointer. The result is that multiple connected mice are unified to control share a single screen element.

Some low level developer APIs within various operating systems do allow applications access to the individual unique mouse devices. But it is often the application s responsibility to create separate pointers and position functions for each mouse device that may only operate with the application s GUI graphical user interface . Therefore applications supporting multiple pens are usually specialized for a particular purpose or to a particular set of devices. In other cases applications choose to support only the limited single device operating system APIs.

Microsoft operating systems provide a low level Raw Input APIs to developers through which an application can obtain information regarding any human interface device HID connected to the system. Microsoft also developed a managed code solution with the MultiPoint Mouse SDK software development kit that exposes a common application environment supporting multiple mouse devices. This SDK offers an application a window platform for tracking the multiple devices and includes helpful support for managing cursor icons position and other mouse related GUI and tracking events.

Epson s BrightLink 475Wi Interactive Projector for example is configured as a short throw projector with an electronic whiteboard application that creates an interactive whiteboard projector IWP . This all in one product solution seeks to replace the traditional whiteboard by providing dual electronic pens operating over a drawing region output by the projector. The pens are detected and managed by a receiver and provide input to an internal whiteboard application. Providing similar input to any application on a host PC that might be configured to use the IWP and pens is an object of the present invention.

In effect a network projector can be harnessed to output display content gained from some remote source device. Device inputs on the network projector may too have use by a remote target device.

A key challenge with providing so many input devices is sharing the device hardware with applications on a host PC connected to the IWP. In prior product solutions the supplied input hardware was physically connected to the host PC where drivers were installed to interpret the pen inputs. However since the IWP is a network based product additional cabling for connecting input devices is unreasonable. Transmitting the hardware signals across the existing network is one solution. This could require a network based USB driver for the devices for example to be installed on the PC. However users generally do not like to install device drivers on their systems.

With a network projector sending application screen content from a host PC across the network to the projector display already requires some transmission method. As discussed in co pending application Ser. No. 13 332 751 Microsoft s remote desktop services can be ideally suited for this situation in a Windows operating system environment. Sending input devices through this transmission interface is possible. Unfortunately in a hosted remote desktop session only a single mouse and keyboard device is provided by the remote desktop connection client application. Multiple mice on the client projector would be unified into a single mouse device through the remote desktop protocols. Applications running the remote desktop session would only recognize the single mouse device.

Physical connection of additional devices on the host already demonstrated as undesirable for cabling and driver reasons is also problematic when operating in a remote desktop session. This is because a host machine s local HID devices are restricted in operation to the input desktop which will be the Windows Logon screen desktop during the remote desktop connection. This means that multiple HID devices cannot be seen or utilized in applications running within a hosted remote desktop session.

What is desirable is a solution that allows the IWP and interface box client to connect with a host PC using remote desktop services to gain the display output performance expected for desktop applications. Further the desirable solution would also allow the multiple pen devices on the IWP and interface box client to be available to any multi input applications launched on the host PC within the remote desktop session. Ideally this would not require extensive additional software or driver installation. Additionally it would be desirable to share pen devices of a IWP with applications on a host PC when the IWP display is not being utilized by the same PC. The present invention is directed to achieving these and other objectives.

The method and apparatus of the present invention transmits input events from multiple mice attached to a client device using a remote desktop connection to target applications running in a remote desktop session on the host. The present invention does not require mouse drivers be installed on the host system and yet enables targeted applications using Microsoft s Raw Input or MultiPoint Mouse SDKs to identify and interoperate with mouse input from a set of virtual mouse devices each associated with a mouse on the client device.

Specifically the present invention enables a Microsoft Window s based computer host which is communicating with an EPSON interactive whiteboard projector client through a remote desktop connection to launch third party applications supporting multiple mice i.e. drawing pens and provide these applications with virtual mouse device and input event signals for each pen device connected on the projector. The applications will behave as if the host system were configured with multiple installed mice though no added driver or physical connected hardware is present.

The present invention provides a system method and or computer readable media for providing multiple human interface device inputs in a remote desktop session between a client projector and a host computer the client projector and the host computer being connected by a network. The method for example comprises establishing a remote desktop session between the client projector and the host computer in the client projector using the processor to capture inputs from multiple human interface devices and forward the human interface device inputs to the host computer in the host computer using a processor to receive the human interface device inputs from the client projector and store and maintain information for each client projector human interface device as a virtual device intercept raw input function calls from an application running on the host computer collect information for each host computer human interface device and return information for each host computer human interface device and information for each virtual device to the application running on the host computer.

In a preferred embodiment intercepting raw input function calls comprises processing the function call with a hook handler. Another embodiment further comprises simulating system events for each virtual device including device arrival and device removal events.

An embodiment further comprises maintaining virtual device objects used to name and identify each client projector human interface device. In another embodiment the information returned to the application includes a count and list of host computer human interface device handles and virtual device handles.

In an embodiment the inputs from the client projector human interface device include at least one of flags button states and coordinate information and in another embodiment the client projector human interface devices are electronic whiteboard pens.

In a further embodiment the method of the present invention further comprises establishing a remote desktop services virtual channel between the host computer and the client projector and receiving by the host computer human interface device inputs forwarded from the client projector across the remote desktop services virtual channel. In yet another embodiment a virtual device is a virtual mouse.

Other objects and attainments together with a fuller understanding of the invention will become apparent and appreciated by referring to the following description and claims taken in conjunction with the accompanying drawings.

Providing the hardware pen input devices essentially computer mice on an IWP interactive whiteboard projector to an application in a host computer is only useful if their hardware inputs can be detected and used by the application. Applications running within Microsoft Windows operating systems have access to several APIs application programming interfaces that can provide the application with details concerning each connected mouse and its inputs. Raw Input API is one that offers a small collection of C functions structures and messages conveniently located in the core Windows operating system s User API client dynamic link library DLL user32.dll. Raw Input is the preferred interface for low level access to device and events from registered top level collection classes. Microsoft also provides a higher level MultiPoint Mouse SDK software development kit but internally it is constructed on top of the Raw Input interfaces. Therefore applications supporting multiple mouse input devices are likely to be utilizing the Raw Input APIs.

If one could easily replace the Raw Input API with his own custom version one object of the present invention could be achieved. This custom version could be implemented to mimic expected Raw Input API behavior for each exposed interface function while also providing necessary modifications to support custom requirements. For example a custom version could ensure that returned results from each API method excludes all mice devices. From the using application point of view the API methods would be operating correctly and the application would report that no mouse devices are connected. In another example a custom version could respond with more devices than are actually available. The using application would respond accordingly convinced that more devices exist because the API responded accordingly and within the interface guidelines. Therefore the custom version could receive input from the IWP across the network say event data for each pen device and relay this information to applications through the modified Raw Input API in which the application is interacting.

One problem with the replacement approach is that user32.dll exposes a significant set of APIs not just Raw Input methods. It would be a daunting and unlikely prospect to replace them all. Also this user32.dll is a core Windows operating system file which is prone to inspection by various system utilities that can ensure its originality.

To overcome this problem another option has been chosen for the present invention intercepting or hooking. Hooking allows one to alter or augment software components by intercepting function calls or message events at interfaces between such components. With this approach arbitrary functions can be intercepted and extended by rewriting in memory code for the target functions. The original target functions may even be preserved so that extended versions can call original target implementations to obtain original results. While convenient for API monitoring methods user mode hooking may also be used to change or alter function outcomes. Products such as Microsoft Detour APISpy32 or the open source EasyHook engine provide libraries with hooking functions and frameworks to developers wishing to create applications that utilize a hooking approach in their products.

There are many API hooking methods that may be implemented. They include approaches such as import table patching extended import table patching export table patching simple code overwriting and extended code overwriting. This present invention is not concerned with nor limited to a particular hooking approach or its methods except that hooking will be used to gain access to core Raw Input API functions and is a necessary requirement.

In many hooking methods an injector component loads and installs a custom hook library code module into the process of a target application and at an appropriate time. In one approach the injector modifies at runtime the import descriptor table for desired target functions in a shared library loaded in the process memory. These modifications provide calls to hook handlers in the custom hook library which intercept the desired target functions when an application attempts to call the methods using the import table mapping. Code implemented within the hook handlers may simply monitor and log the action and forward execution to the original native target implementation. Alternately code could be crafted to change the intended function behavior customize or filter original results or replace the method completely. Ultimately the hook returns execution back to the calling application. Using the hooking approach a target solution can be achieved which is similar to full API library replacement.

The present invention provides virtual mice to third party applications that use the Microsoft s Raw Input APIs in the Microsoft Windows operating systems to support one or more mouse devices. The method of the present invention operates even when the third party application is running within a remote desktop session. One of the goals of the present invention is to securely provide input from multiple unique pen devices on an IWP across a network to applications running on a host PC. The present invention allows virtual mice from other source locations to be included in the applications operation.

 Virtual mice are distinguished from actual mouse devices in that the operating system has no knowledge of them. Applications on the other hand will be using the operating system API services to obtain them so the virtual mice must appear as actual mouse devices to the application layer i.e. Raw Input . The intent is to not require any custom application modification to support pen devices that operate with the interactive whiteboard projector such as Epson s BrightLink 475Wi IWP. It is not desirable to install or use mouse drivers in the operating system even if such drivers operate with remote physical hardware. While this would provide applications with access to the devices automatically through native Raw Input or related APIs the devices would be exposed to all applications and be available for use by the system. Most importantly when operating within a remote desktop session all mice exposed to the operating system are directed to the input desktop. The remote desktop session is limited to only a single remote desktop mouse a kind of virtual mouse and provided by the remote desktop connection client. Therefore exposing pen devices to the operating system will not be desirable in this situation.

A network projector as described herein may be referred to as the client or the projector. This projector will provide a client side application to a virtual network connection for displaying remote desktop content. A host as described herein is defined as a networked computer laptop or handheld device which can provide among other things the serving function in a virtual networking connection with the client. In an embodiment the network projector incorporates a Windows embedded operating system providing Remote Desktop Connection Client application support. The host is a networked computer that provides the server component of Microsoft s Remote Desktop Services called Remote Desktop Terminal Server.

The Remote Desktop Connection Client is an application that executes in the client projector to communicate with the host computer using the Remote Desktop Protocol RDP which is an interface through which the host computer provides the desktop display to the client projector and the client projector provides keyboard mouse events to the host computer . The Remote Desktop Connection Client provides the user interface on the client for access and interaction with a remote desktop session. This component manages the loading of any external dynamic link libraries such as those necessary for extending a remote desktop service virtual channel like the Multi Pen Input Redirection Component .

The Multi Pen Input Capture Module of client projector is responsible for enumeration and access to connected pen devices i.e. electronic whiteboard pens maintaining individual pen device identification data and ultimately gathering each pen s event data. The captured data and device information is sent to the Multi Pen Input Redirection Component for forwarding to components of host computer across network . Capturing of event data from hardware devices may require that this component be part of a driver or other low level interface. Or it may be configured to receive this information from another module.

Event data leaving the Multi Pen Input Capture Module will take the form of a structure that includes general mouse related activity information. Multi Pen Input Capture Module will ensure that the structure is appropriate for the exchange. In one embodiment event data follows a form similar to Microsoft s  MOUSE INPUT DATA structure and includes flags button states and coordinate motion information.

In one embodiment communication with the Multi Pen Input Redirection Component is provided through a message queue using CreateMsgQueue or similar API. Other forms of inter process communication may be used. Alternately the Multi Pen Input Capture Module could be included as a sub component of the Multi Pen Input Redirection Component .

The Multi Pen Input Redirection Component of client projector creates a client side endpoint for a remote desktop services virtual channel and transmits multi pen input events received by the Multi Pen Input Capture Module . The Multi Pen Input Redirection Component is packaged as a dynamic link library that is loaded by remote desktop services when a new remote desktop connection is established.

In an alternate embodiment the Multi Pen Input Redirection Component is launched separately and uses its own network link to a Multi Pen Input Receiver Component configured also to use the separate network link. In this way remote desktop components are not required for transmitting Multi Pen Input Events as they are instead sent on the separate network link.

The Remote Desktop Terminal Server of host computer communicates with clients using the Remote Desktop Protocol RDP . It provides the hosting component for a remote desktop session such as Remote Desktop and allows client machines i.e. client projector to connect with the host computer for access to a user desktop.

The Multi Pen Input Receiver Component of host computer creates a server side endpoint for a remote desktop services virtual channel and awaits transmission of input events from Multi Pen Input Redirection Component provided by the Multi Pen Input Capture Module . The Multi Pen Input Receiver Component dispatches received pen device events to a Virtual Mouse Device Interface as they are received.

In an alternate embodiment the Multi Pen Input Receiver Component can receive input events from other sources including a separate network connection. To avoid unnecessary data marshalling Multi Pen Input Receiver Component could be incorporated as a module of the Virtual Mouse Device Interface .

The Virtual Mouse Device Interface of host computer provides methods for preparing or discarding virtual mice devices from input events it collects. The basic interface provides DeviceAdd DeviceRemove and DeviceEvent interface functions that use a device identification handle and optional event data. The Virtual Mouse Device Interface component stores and maintains information for each logical virtual mouse and dispatches or provides interfaces to obtain event data it receives.

The Virtual Mouse Device Interface may be incorporated within the Quick Launch Hook Injector Application or it may be an integrated part of the Raw Input Hook Handler .

The Quick Launch Hook Injector Application of host computer manages injection of the Raw Input Hook Handler component into a running target application. The target application is optionally launched by the Quick Launch Hook Injector Application and hooked immediately after application loading and before execution.

The Quick Launch Hook Injector Application may display a toolbar application window or other GUI graphical user interface element and can be used to aid user selection of raw input aware target applications that are desired to incorporate the virtual mice inputs. For example a GUI may be presented similar to a toolbar containing icons of installed applications in the system. The user need simply select an icon to optionally launch and then inject the application with the Raw Input Hook Handler component. In another embodiment a list of running applications can be selected. Selecting one from the list will allow dynamic hooking of the already running process. In another embodiment the application icons on the toolbar are configurable. The user may for example drag and drop an application shortcut or executable file into the toolbar area that will cause the application icon to be added the GUI. Alternately a file selection dialog may be provided and used to identify applications elements for the toolbar. Selecting an icon will launch the related application.

Injection will occur according to the hooking framework and method used. The Quick Launch Hook Injector Application can be configured to report the status of the injection process like informing the user of any difficulties in establishment of the hooking process i.e. the application chosen is not using Raw Input protocols .

The Quick Launch Hook Injector Application is typically launched automatically into the desktop of a new remote desktop session. Alternately it may be invoked directly by the user. As a toolbar the application can be configured as a normal component in the user desktop. In either case the Quick Launch Hook Injector Application is available to provide bookmarks to applications for which the present invention s hooking operations will be supplied and can save the state of any configured applications or injection status events for future use.

In one embodiment the Quick Launch Hook Injector Application maintains the Virtual Mouse Device Interface and provides a conduit for communication with all launched Raw Input Hook Handlers . In this way the Quick Launch Hook Injector Application can manage all virtual mice in the system.

The Raw Input Applications A . . . N are existing multi device aware applications on the host computer that may benefit from multiple independent mouse devices. Each application is configured to use the native operating system s Raw Input API .

The Raw Input Hook Handler of the host computer is injected into the running process space of each selected target application and begins execution in an attempt to hook the required Raw Input APIs provided by Microsoft s user32.dll. The primary role of this component is to intercept all Raw Input API function calls used by the Raw Input aware application where it was injected and replace them with a custom implementation. This custom implementation provides virtual mice and associated input events of a Virtual Mouse Device Interface to the application that is configured to communicate with the native Raw Input API methods. To complete this custom implementation the Raw Input Hook Handler must also simulate some system events and messages for the application in a manner consistent with the native Raw Input API mechanism. For example posting events into application window message queues and otherwise reporting device arrival and device removal events as if reporting and management for the virtual mice devices was carried out by the host operating system processes.

In one implementation there are several components in Raw Input Hook Handler . They will be outlined below.

A RawInputHooks module provides the hook handler intercept entry points with replacement methods for each Raw Input API function that is hooked. When a Raw Input API function is called by the application the hook handler processes the function call.

The GetRawInputBuffer Hooked function returns virtual mouse events data pertaining to the calling threads Windows message queue. It adds this information to any data retrieved from the native GetRawInputBuffer method.

The GetRawInputData Hooked function examines the incoming passed data event handle and if it matches a unique handle previously provided and used for the virtual mice methods appropriate data associated with the event handle and the information request command is returned. Otherwise the method simply invokes the native GetRawInputData to let the system process according to its data event handles.

The GetRawInputDeviceInfoW Hooked Unicode and GetRawInputDeviceInfoA Hooked ANSI provide hook methods for related Raw Input GetRawInputDeviceInfoW and GetRawInputDeviceInfoA functions. The hooked handlers examine the incoming passed device handle and if it matches the device handle of any known virtual mice the method returns appropriate information gathered for the device from the Virtual Mouse Device Interface . Otherwise as the device handle is unknown results from calling the native Raw Input method are returned.

The GetRawInputDeviceList Hooked function first collects the set of known devices counts etc. by calling the native GetRawInputDeviceList method. Then the hooked function adjusts the returned result according to the information in the Virtual Mouse Device Interface . For example the returned result supplies both a count and list of system HID human interface device handles and the virtual mouse device handles for all virtual mice .

The RegisteredRawInputDevices Hooked function simply calls the native RegisteredRawInputDevice method executes a monitoring method and returns the native result. The monitor method is tasked at examining the application s registration in the Raw Input API to detect which application windows or thread queues are requesting mouse event information. A notification process will use this information for sending virtual mice event data to the appropriate window target in a similar fashion as the Raw Input control methods. The GetRegisteredRawInputDevices method is called during the hook injection process to initialize the notification state.

A RawInputNotifier module provides the event notification thread that is responsible for transmitting virtual mice event data to the application on behalf of the Raw Input API which is not aware of the virtual mice . This module also provides hook entry points to common message queue functions to support this process.

The GetMessage Hooked and PeekMessage Hooked functions intercept native GetMessage and PeekMessage functions. The hook method first calls the native function to monitor Windows message queue removal of the Raw Input APIs WM INPUT message prior to processing by the application. If the message targets a virtual mouse as indicated by a uniquely provided Raw Input Handle given when the message was posted by this RawInputNotifier module into the queue it signals removal of the next virtual mouse event in the virtual mouse thread buffer. If the next event is old or has been processed by other methods i.e. GetRawInputBuffer then the hooked function loops on the GetMessage or PeekMessage functions as appropriate until the next event is valid.

A notification thread is configured to awaken when virtual mice events are dispatched by the Virtual Mouse Device Interface . This thread collects any pending events and notifies the application. It may call PostMessage to insert WM INPUT messages for the event using a unique Raw Input Handle. The application will later receive this message and call appropriate Raw Input methods to obtain event data and other details. The notification method may also call SendMessageTimeout to provide WM INPUT DEVICE CHANGE notification and PostMessage to insert WM INPUT DEVICE CHANGE messages for new arrivals or pending departures of virtual mice . The Virtual Mouse Device Interface is called as necessary to maintain state or perform final teardown of pending device changes. Lastly the notification thread may use SendInput to change a Windows message queue status which are unavailable for direct for modification to reflect a raw input event pending state. This allows any application threads that wait for the queue status state to awaken.

VirtualMouse objects are maintained by a unique DeviceHandle and DeviceId. These are chosen to not interfere with those already generated for other devices by the operating system and are also used to name and identify the particular mouse to an application.

A VirtualDeviceManager module possibly implementing the Virtual Mouse Device Interface provides storage for a list of the VirtualMouse objects. It maintains mappings to VirtualMouse objects by the unique device handle and by an external virtual mouse device identifier. MouseEvents containing the notification window when posted mouse device handle mouse event data arrival departure data state etc. are maintained in MouseEventBuffers that are unique to a particular application thread id. The buffers and a mapping by thread are in the VirtualDeviceManager. Notification messages of incoming virtual mice events are posted to the application and the event is stored in the appropriate MouseEventBuffer. When the application processed the notification message these buffers are accessed to retrieve the event data.

The upper half of illustrates the problem that the present invention solves. The interactive whiteboard projector IWP i.e. client projector is connected to a remote PC i.e. host computer via a remote desktop protocol RDP connection. With an RDP connection without the solution of the present invention the inputs of multiple projector input devices i.e. electronic whiteboard pens are merged across the RDP so that the system host computer and applications running on the host computer see only one RDP mouse.

The solution of the present invention consists of three primary parts. Referring now to the first part collects pen device inputs i.e. Multi Pen Input Capture Module on an IWP client projector and transmits them as mouse events to a receiver Multi Pen Input Receiver Component on a host PC host computer . The second part manages an interface Virtual Mouse Device Interface that maintains a pool of virtual mice and their associated event queues for the mouse input data. The third part hooks the Raw Input API methods being used by a target application Quick Launch Hook Injector Application injects Raw Input Hook Handler into the application process space and inserts the virtual mice and related events into hooked method results.

The present invention starts with the client projector IWP and host computer e.g. laptop connected to a local area network and interconnected by a remote desktop connection from the client to the host. Pen input devices are monitored or connected to the client projector which is configured to enumerate these input devices and maintain a list of unique identifiers for each. Input devices and events generated are captured in the client s Multi Pen Input Capture Module using appropriate drivers APIs or other notification interfaces.

The present invention continues by converting by the Multi Pen Input Capture Module the pen events into mouse device events as necessary and transmitting them i.e. multi pen input events across the network to the host computer . A remote desktop service virtual channel created and connected between the client and host is one preferred path for this data. The security and encryption provided automatically by remote desktop services through the remote desktop protocol is advantageous.

The present invention continues on the host computer where the mouse data for multiple pen devices is received by the Multi Pen Input Receiver Component . Modules required on the host computer may be pre installed and launched just prior to the remote desktop connection from the client as discussed in greater detail in commonly owned U.S. patent application Ser. No. 13 332 751 filed Dec. 21 2011 which is hereby incorporated by reference in its entirety. Alternatively these modules may be downloaded or otherwise pre installed and configured. The receiver component may optionally be integrated with a hooking component launched by the user.

The received input is passed to the Virtual Mouse Device Interface that will construct or deactivate virtual mice and information queues that will be processed by hook handlers overriding Raw Input API methods used by host applications . The virtual mice events will be dispatched to any Raw Input Hook Handlers and added to method results. Applications will thus receive API method results containing event data from virtual mice as if the information were provided by operating system mouse drivers connected to physical mouse devices.

The present invention continues when a user identifies and launches an application that requires one or more mouse inputs through the Raw Input API . An optional GUI interface like a toolbar or similar application element may be provided to launch the application or enumerate existing applications. The present invention continues when a signal to inject the launched application with a hooking module of the present invention is provided. The signal may be provided by the optional GUI toolbar as a step in the application launch process or it may occur during a separate action. The RawInputHooks module of the Raw Input Hook Handler is described in greater detail above. An injector Quick Launch Hook Injector Application loads the hooking module RawInputHooks into the process space of the target application and begins execution.

The hooking module locates the Raw Input API methods and sets up hooks to intercept application calls to Raw Input methods with replacement implementations that the hooking module provides. The present invention then continues by allowing normal application execution.

The hooking module creates a thread to obtain and monitor incoming virtual mice events including device arrivals and departures from the Virtual Mouse Device interface . Related messages are constructed and inserted into the application s Windows message queues according to application Raw Input calls that setup registered device classes receiving event windows etc. As the Application makes Raw Input API calls they are intercepted by hook methods in Raw Input Hook Handler which invoke native Raw Input methods to receive operating system OS results which are then modified to include the virtual mice data.

The lower half of illustrates the general process of the present invention. Generally applications running within Microsoft Windows operating systems have access to several APIs application programming interfaces that can provide the application with details concerning each connected mouse and its inputs. The Application running on the host computer is shown on the left side of the figure and the Raw Input Hook of the present invention is on the right side of the figure. In step the dynamic link library DLL injection installs the Raw Input Hook Handler of the present invention for the Raw Input methods in SDK software development kit libraries loaded by the Application . In step the Application calls a Raw Input API function. In this example the application intends to invoke the GetRawInputDeviceList SDK method to gather any connected input devices. In step the Raw Input Hook Handler intercepts the Application call to a Raw Input API function call and redirects it to a hook handler method according to the present invention. For example in step the GetRawInputDeviceList hooked version is called which should obtain all registered HIDs Human Interface Devices in the system. In step the original native Raw Input SDK library method is called and the operating system OS returns two devices i.e. the remote desktop keyboard and mouse device . In step the hooking module of the present invention then adds the virtual mice it is aware i.e. three mice of from the Virtual Mouse Interface and in step returns the modified result of the method i.e. a total of five devices to the Application .

The method steps of the present invention described above are preferably performed by one or more processors in the host computer and or the client projector executing computer executable instructions programs software firmware that is stored or loadable in memory in host computer and or client projector and or in accessible external memory. is a very simplified block diagram illustrating generally the processors and memory in host computer and client projector . Host computer processors may include for example a central processing unit CPU and one or more graphical processing units GPU . The internal memory may include for example RAM and ROM . I O interface enables communication with keyboard mouse and external memory for example. Client projector may similarly include a CPU RAM and ROM .

Various embodiments can be implemented in digital electronic circuitry or in computer hardware firmware software or in combinations of them. Apparatus can be implemented in a computer program product tangibly embodied in a non transitory machine readable storage device for execution by a programmable processor and method steps can be performed by a programmable processor executing a program of instructions to perform functions by operating on input data and generating output. Embodiments can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from and to transmit data and instructions to a data storage system at least one input device and at least one output device. Each computer program can be implemented in a high level procedural or object oriented programming language or in assembly or machine language if desired and in any case the language can be a compiled or interpreted language. Suitable processors include by way of example both general and special purpose microprocessors. Generally a processor will receive instructions and data from a read only memory and or a random access memory. Generally a computer will include one or more mass storage devices for storing data files such devices include magnetic disks such as internal hard disks and removable disks magneto optical disks and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non volatile memory including by way of example semiconductor memory devices such as EPROM EEPROM and flash memory devices magnetic disks such as internal hard disks and removable disks magneto optical disks and CD ROM disks. Any of the foregoing can be supplemented by or incorporated in ASICs application specific integrated circuits .

While the invention has been described in conjunction with several specific embodiments it is evident to those skilled in the art that many further alternatives modifications and variations will be apparent in light of the foregoing description. For example the hooking modules proposed provide a way to insert virtual mice not installed or otherwise configured within the operating system into a chosen application. The event data for these virtual mice need not arrive from a client of a remote desktop connection. Instead in another embodiment the remote desktop service virtual channels are not used and mouse event data arrives from an alternate network connection. For example another computer could generate events or share events from a locally connected mouse with the application on the host PC. In this way remote desktop services are an independent and unrelated optional component of this method.

In yet another embodiment no network connections are used and the mouse event data arrives from another application running within the host. This application may simulate real mouse devices offer additional selectable mice with some mechanism to choose the active one provide an interface between some other mouse like hardware device that transposes that data into mouse data and sent to the Virtual Mouse Device Interface for the hooked application or simply provide any number of input events and according to a demonstration script. Thus the invention described herein is intended to embrace all such alternatives modifications applications and variations as may fall within the spirit and scope of the appended claims.

