---

title: Buffer for RAID controller with disabled post write cache
abstract: Enhancing management of controllers in a RAID system when a post-write-cache of a is disabled, by supplying a stripe buffer that stores sequential write requestsâ€”and before such requests are actually written in to the physical disc drives. The stripe buffer can temporarily store data, until the data level reaches the stripe buffer size. Thereafter, contents of the stripe buffer can be flushed onto disc.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08914576&OS=08914576&RS=08914576
owner: Hewlett-Packard Development Company, LP.
number: 08914576
owner_city: Houston
owner_country: US
publication_date: 20120730
---
Various storage device configurations and geometries are commonly applied to meet the demands for higher storage capacity while maintaining or enhancing reliability of the mass storage subsystems. For example one category of disk arrays is referred to as Redundant Array of Inexpensive Independent Drives RAID . Within a RAID system varying levels of data storage redundancy can be employed to enable reconstruction of stored data in the event of data corruption or disk failure. These various types of redundant storage strategies is represented by the RAID system.

With the advent of high performance and low latency of solid state drives SSD in RAID storage systems the performance bottleneck may shift from operation at the back end drives to processing capabilities of the controller CPU itself. For example when employing SSDs and in case of high thread workload levels having the post write cache in the RAID controller can substantially increase associated CPU cycles hence burdening the controller CPU and degrading overall operations.

To overcome such bottlenecks and improve efficiency some users may select to disable the controller cache in order to reach the maximum Input Output Operations Per Second IOPS throughput. Nonetheless such disabling of the post write cache itself can cause additional problems in parity blocks such as the RAID 5 RAID 6 distributed parity set up.

For example the RAID 5 parity handling employs block level striping with parity data distributed across all member disks and RAID 6 extends RAID 5 by adding an additional parity block thus employing block level striping with two parity blocks distributed across all member disks. For such parity storing arrangements when a host engages in sequential processes employing full stripe operations can significantly reduce number of read write tasks e.g. in order of magnitudes depending on the operation . It is noted that such benefits can occur in parity volumes regardless of the actual type of physical disk e.g. SSD or not wherein full stripe is considered the optimized operation which can significantly improve processes in parity blocks as compared to non full stripe writes. Similarly for the case of sequential writes combining all writes to create full stripes can substantially improve efficiency.

Indeed when a post write cache is not disabled sequential operations continuous data may in fact be already combined. However disabling the post write cache may potentially introduce inefficiencies that are not intended.

Various aspects of the subject disclosure improve sequential write performance for a RAID controller when an associated controller post write cache is disabled by supplying a buffer s that buffers sequential write requests in a flash or battery backed buffer. Accordingly before the sequential write requests are actually written in to the physical disc such buffer hereafter referred to as a stripe buffer can store sequential write requests until data level reaches its storage capacity. Subsequently and upon reaching storage capacity of the stripe buffer content of the stripe buffer can be flushed as a whole stripe on to the disc hence the term stripe buffer . Hence for a sequential write request flushing of content from the stripe buffer to the disc drives occurs upon storage capacity of the stripe buffer becoming full e.g. for sequential write requests flushing of the stripe buffer is delayed until its content reaches full capacity. 

In particular when the controller post write cache is disabled such buffering by the stripe buffer can have relatively low impact on performance related to other types of workload because associated metadata can be deemed negligible e.g. searching dirty and valid data is substantially rapid. Yet it can still achieve a full benefit of parity volume full stripe write.

Moreover the host can include personal computers such as a laptop or desktop a workstation a server or any device having a central processing unit CPU and requiring access to the disk array for processing various of its requests e.g. a plurality of client computers conveying read write requests over the network to disk array via the RAID controller . As illustrated in the RAID controller includes the CPU program memory e.g. ROM RAM devices for storing program instructions and variables for the operation of CPU and memory for storing data and control information related to the data stored in disk array .

It is noted that the RAID storage system can employ any of the well known RAID levels e.g. levels 1 5 . In this regard the various RAID levels can be distinguished by the manner in which RAID controller logically subdivides or partitions the disk drives in the disk array . For example when implementing RAID level 1 features approximately half of the disk drives of disk array can be employed to store and retrieve data while the other can be is operated by RAID controller to mirror the data storage contents of the first half.

Likewise when implementing RAID level 4 features RAID controller can employ a portion of the disk drives in disk array for the storage of data and the remaining disk drives can be employed for the storage of error checking correcting information e.g. parity information .

According to an implementation of the subject disclosure during a post write cache disable case the RAID controller employs the stripe buffer that manages a sequential write data being combined therein to become a full stripe size before writing to the disc array . Accordingly data can be temporarily placed in the stripe buffer wherein if received data remains sequential the combining continues until a full stripe is reached. Furthermore the stripe buffer can be connected to a power source e.g. battery backed and can be allocated on per volume base of memory wherein one stripe buffer can be assigned to each volume for example.

In this regard when the controller post write cache is disabled for the RAID controller the stripe buffer can buffer sequential write requests in a flash or memory that is backed by power source until data level reaches the buffer size and subsequently it writes the whole stripe on to the disk array .

Furthermore a size of the stripe buffer can be equal to the maximum stripe size that the control supports for each volume of the disk array . For example if a control can support a maximum of 64 volumes a predetermined memory representing 64 stripe buffers can then be allocated wherein each stripe buffer is equal to the maximum size for a volume.

In this regard the verification component can further be communicatively coupled to a comparator component which can compare e.g. in real time the size of data placed in the buffer with that of a full stripe size and dynamically update the verification component regarding status of available space in the stripe buffer. Hence the sequential write requests that are actually written into the buffer are monitored and if a full stripe size buffer is not reached data associated with a sequential write request continues to be placed in the stripe buffer as described in further detail below.

Initially and at a stripe buffer can be allocated for each storage space wherein a storage space of a RAID group can be represented as a logical volume each logical volume can be mapped to a volume identifier that is associated with a respective stripe buffer . When an associated controller post write cache is disabled for the RAID controller the assigned stripe buffer for each logical volume can improve processes associated with a sequential write data. In this regard the size of the stripe buffer for each logical volume of the physical disc can be deemed equal to the maximum stripe size which the control supports. Subsequently and at a determination is made regarding type of new request that is received from the host and related to activities for accessing the disk array. For example different types of requests corresponding to accessing a storage sector can be received wherein at a preliminary stage the requests can initially be categorized as either a read request or a write request.

If it is determined that the new request is a write request at the methodology proceeds to block . At a determination is made whether such write request is sequential e.g. writing along a predetermined sequential path or alternatively whether such write request is random e.g. requires scattered block . If the write is not sequential content of the stripe buffer can be flushed to the disc at . Such occurs even though the stripe buffer may have not reached its full capacity of a full stripe. The methodology then proceeds to block wherein content of the stripe buffer can be replaced with the new write request that was earlier deemed not to be sequential.

Alternatively and if at a determination is made that the write request is sequential such sequential write can be placed in the stripe buffer at and the methodology proceed to block . At a determination is performed as to whether the buffer is full and if not the methodology reverts to block wherein another incoming request can be evaluated. Alternatively and if at a determination is made that the buffer has indeed become full the methodology proceed to act wherein content of the buffer stripe is flushed to disc.

Alternatively and if at a determination is made that the request overlaps with data that is already in the stripe buffer the methodology proceeds to block . At content of the stripe buffer can be flushed to the disc even though the stripe buffer may have not reached its full capacity of a stripe buffer size . Subsequently the request can be processed and data read from the disc at .

The system can represent a representation for wiring each row column together and to allow each individual bit position to be read. In this regard the circuits connecting each row can be referred to as word lines while the ones for each column can be referred to as bit lines. Read operations can simply include applying a voltage to each word line and the bit lines will then show a voltage or not depending on whether each cell stores a 0 or a 1.

For example in the grid of cells the word lines can be connected to the transistors gates. And the bit lines can be attached to their drains. One can read the contents of the cell can be by applying a low voltage to the gates and determining if a current flows. As such the word line to which that cell is connected can be energized to a voltage level below V.

In this regard current can flow through the cell from the source line to its connected bit line if and only if the cell s float gate contains no charge a 1 . If the float gate contains a charge a 0 the voltage threshold of the whole cell is deemed too high for the small voltage to overcome. The bit line connected to that cell is then checked for current. If it has a current it can be treated as a logical 1 and alternatively if such is not the case a reading of logical 0 can be interpreted.

Moreover the stripe buffer can be associated with a flash memory grid that includes 32 to 256 columns and hence 32 to 256 bit lines and 4 096 to 65 536 rows and hence 4 096 to 65 536 word lines . The total grid can be referred to as a block and each row referred as a page wherein for the SSD a read write may occur in in pages yet erase can occur only in blocks for example.

As explained earlier the stripe buffer can be connected to a power source e.g. battery backed and can be allocated per volume base of memory and hence assigned to each volume. In this regard a size of the buffer can be equal to the maximum stripe size that the control can support for each memory volume of the disk array.

As used herein the term inference refers generally to the process of reasoning about or inferring states of the system environment and or user from a set of observations as captured via events and or data. Inference can identify a specific context or action or can generate a probability distribution over states for example. The inference can be probabilistic that is the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher level events from a set of events and or data. Such inference results in the construction of new events or actions from a set of observed events and or stored event data whether or not the events are correlated in close temporal proximity and whether the events and data come from one or several event and data sources.

The inference component can employ any of a variety of suitable AI based schemes as described supra in connection with facilitating various aspects of the herein described subject matter. For example a process for learning explicitly or implicitly how parameters are to be created for training models based on similarity evaluations can be facilitated via an automatic classification system and process. Classification can employ a probabilistic and or statistical based analysis e.g. factoring into the analysis utilities and costs to prognose or infer an action that a user desires to be automatically performed. For example a support vector machine SVM classifier can be employed. Other classification approaches include Bayesian networks decision trees and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.

The subject application can employ classifiers that are explicitly trained e.g. via a generic training data as well as implicitly trained e.g. via observing user behavior receiving extrinsic information so that the classifier is used to automatically determine according to a predetermined criteria which answer to return to a question. For example SVM s can be configured via a learning or training phase within a classifier constructor and feature selection module. A classifier is a function that maps an input attribute vector x x1 x2 x3 x4 xn to a confidence that the input belongs to a class that is f x confidence class .

Each computing object etc. and computing objects or devices etc. can communicate with one or more other computing objects etc. and computing objects or devices etc. by way of the communications network either directly or indirectly. Even though illustrated as a single element in communications network can include other computing objects and computing devices that provide services to the system of and or can represent multiple interconnected networks which are not shown. Each computing object etc. or computing objects or devices etc. can also contain an application such as applications that might make use of an application programming interface API or other object software firmware and or hardware suitable for communication with or implementation of the various examples of the subject disclosure.

There are a variety of systems components and network configurations that support distributed computing environments. For example computing systems can be connected together by wired or wireless systems by local networks or widely distributed networks. Currently many networks are coupled to the Internet which provides an infrastructure for widely distributed computing and encompasses many different networks though any network infrastructure can be used for exemplary communications made incident to the systems as described in various examples.

Thus a host of network topologies and network infrastructures such as client server peer to peer or hybrid architectures can be utilized. The client can be a member of a class or group that uses the services of another class or group. A client can be a computer process e.g. roughly a set of instructions or tasks that requests a service provided by another program or process. A client can utilize the requested service without having to know all working details about the other program or the service itself.

As used in this application the terms component module system and the like are intended to refer to a computer related entity either hardware software firmware a combination of hardware and software software and or software in execution. For example a component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and or a computer. By way of illustration both an application running on a computing device and or the computing device can be a component. One or more components can reside within a process and or thread of execution and a component can be localized on one computer and or distributed between two or more computers. In addition these components can execute from various computer readable storage media having various data structures stored thereon. The components can communicate by way of local and or remote processes such as in accordance with a signal having one or more data packets e.g. data from one component interacting with another component in a local system distributed system and or across a network such as the Internet with other systems by way of the signal .

In a client server architecture particularly a networked system a client can be a computer that accesses shared network resources provided by another computer e.g. a server. In the illustration of as a non limiting example computing objects or devices etc. can be thought of as clients and computing objects etc. can be thought of as servers where computing objects etc. provide data services such as receiving data from client computing objects or devices etc. storing of data processing of data transmitting data to client computing objects or devices etc. although any computer can be considered a client a server or both depending on the circumstances. Any of these computing devices can process data or request transaction services or tasks that can implicate the techniques for systems as described herein for one or more examples.

A server can be typically a remote computer system accessible over a remote or local network such as the Internet or wireless network infrastructures. The client process can be active in a first computer system and the server process can be active in a second computer system communicating with one another over a communications medium thus providing distributed functionality and allowing multiple clients to take advantage of the information gathering capabilities of the server. Any software objects utilized pursuant to the techniques described herein can be provided standalone or distributed across multiple computing devices or objects.

In a network environment in which the communications network bus can be the Internet for example the computing objects etc. can be Web servers file servers media servers etc. with which the client computing objects or devices etc. communicate via any of a number of known protocols such as the hypertext transfer protocol HTTP . Computing objects etc. can also serve as client computing objects or devices etc. as can be characteristic of a distributed computing environment.

Computer typically includes a variety of computer readable media and can be any available media that can be accessed by computer . The memory can include computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and or random access memory RAM . By way of example and not limitation memory can also include an operating system application programs other program modules and program data.

A user can enter commands and information into the computer through input devices non limiting examples of which can include a keyboard keypad a pointing device a mouse stylus touchpad touch screen trackball motion detector camera microphone joystick game pad scanner video camera or any other device that allows the user to interact with the computer . A monitor or other type of display device can be also connected to the system bus via an interface such as output interface . In addition to a monitor computers can also include other peripheral output devices such as speakers and a printer which can be connected through output interface .

The computer can operate in a networked or distributed environment using logical connections to one or more other remote computers such as remote computer . The remote computer can be a personal computer a server a router a network PC a peer device or other common network node or any other remote media consumption or transmission device and can include any or all of the elements described above relative to the computer . The logical connections depicted in include a network such local area network LAN or a wide area network WAN but can also include other networks buses e.g. cellular networks.

As mentioned above while examples have been described in connection with various computing devices and network architectures the underlying concepts can be applied to any network system and any computing device or system in which it is desirable to publish or consume media in a flexible way.

Also there are multiple ways to implement the same or similar functionality e.g. an appropriate API tool kit driver code operating system control standalone or downloadable software object etc. which enables applications and services to take advantage of the techniques detailed herein. Thus examples herein are contemplated from the standpoint of an API or other software object as well as from a software or hardware object that implements one or more aspects described herein. Also various examples described herein can have aspects that are wholly in hardware partly in hardware and partly in software as well as in software.

Computing devices typically include a variety of media which can include computer readable storage media and or communications media in which these two terms are used herein differently from one another as follows. Computer readable storage media can be any available storage media that can be accessed by the computer can be typically of a non transitory nature and can include both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable storage media can be implemented in connection with any method or technology for storage of information such as computer readable instructions program modules structured data or unstructured data. Computer readable storage media can include but are not limited to RAM ROM electrically erasable programmable read only memory EEPROM flash memory or other memory technology compact disc read only memory CD ROM digital versatile disk DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or other tangible and or non transitory media which can be used to store desired information. Computer readable storage media can be accessed by one or more local or remote computing devices e.g. via access requests queries or other data retrieval protocols for a variety of operations with respect to the information stored by the medium.

On the other hand communications media typically embody computer readable instructions data structures program modules or other structured or unstructured data in a data signal such as a modulated data signal e.g. a carrier wave or other transport mechanism and include any information delivery or transport media. The term modulated data signal or signals refers to a signal that has one or more of its characteristics set or changed in such a manner as to encode information in one or more signals. By way of example and not limitation communication media include wired media such as a wired network or direct wired connection and wireless media such as acoustic radio frequency RF infrared and other wireless media.

It is to be understood that the examples described herein can be implemented in hardware software firmware middleware microcode or any combination thereof. For a hardware implementation the processing units can be implemented within one or more application specific integrated circuits ASICs digital signal processors DSPs digital signal processing devices DSPDs programmable logic devices PLDs field programmable gate arrays FPGAs processors controllers micro controllers microprocessor and or other electronic units designed to perform the functions described herein or a combination thereof.

When the examples are implemented in software firmware middleware or microcode program code or code segments they can be stored in a machine readable medium or a computer readable storage medium such as a storage component. A code segment can represent a procedure a function a subprogram a program a routine a subroutine a module a software package a class or any combination of instructions data structures or program statements. A code segment can be coupled to another code segment or a hardware circuit by passing and or receiving information data arguments parameters or memory contents. Information arguments parameters data etc. can be passed forwarded or transmitted using any suitable means including memory sharing message passing token passing network transmission etc.

For a software implementation the techniques described herein can be implemented with modules or components e.g. procedures functions and so on that perform the functions described herein. The software codes can be stored in memory units and executed by processors. A memory unit can be implemented within the processor or external to the processor in which case it can be communicatively coupled to the processor via various structures. In one example the techniques of the present application can be employed using a memory that stores computer executable or computer readable instructions and a processor or computer communicatively coupled to the processor or computer that facilitates execution of the computer executable or computer readable instructions or a computer readable medium e.g. non transitory to perform functionality of the present application.

What has been described above includes examples of one or more examples. It is of course not possible to describe every conceivable combination of components or methodologies for purposes of describing the aforementioned examples but one of ordinary skill in the art can recognize that many further combinations and permutations of various examples are possible. Accordingly the described examples are intended to embrace all such alterations modifications and variations that fall within the spirit and scope of the appended claims.

In addition to the various examples described herein it is to be understood that other similar examples can be used or modifications and additions can be made to the described example s for performing the same or equivalent function of the corresponding example s without deviating there from. Still further multiple processing chips or multiple devices can share the performance of one or more functions described herein and similarly storage can be affected across a plurality of devices.

