---

title: Method and system for application-based policy monitoring and enforcement on a mobile device
abstract: A method and system for application-based monitoring and enforcement of security, privacy, performance and/or other policies on a mobile device includes incorporating monitoring and policy enforcement code into a previously un-monitored software application package that is installable on a mobile device, and executing the monitoring and policy enforcement code during normal use of the software application by a user of the mobile device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08844036&OS=08844036&RS=08844036
owner: SRI International
number: 08844036
owner_city: Menlo Park
owner_country: US
publication_date: 20120302
---
This invention was made in part with government support under grant number CNS 0716612 awarded by the National Science Foundation and contract number W911NF 06 1 0316 awarded by The United States Army Research Laboratory. The Government has certain rights in this invention.

Traditionally products such as music players cameras video recorders video games web browsers Global Positioning System GPS locators navigators clocks telephones and messaging systems were enabled by different electronic devices. More recently many features of these products have converged onto unitary mobile devices such as smartphones e readers and tablet computers. As a result software applications exploiting these features have been and continue to be designed for mobile devices. These applications are often capable of storing large amounts of potentially sensitive or private information on a mobile device and communicating with other devices or remote systems over public and or unsecured networks with or without the user s knowledge.

The number of software applications that can be downloaded to mobile devices from public application stores or markets has exploded in recent years. In particular the amount of downloadable malware masquerading as legitimate applications is on the rise and new forms of malware seem to appear every day. It can be extremely difficult for users to distinguish benign applications from those that have a malicious intent. Even if an application is not intended as malware it may perform activities that would be considered objectionable by some users. For these and other reasons mobile devices are increasingly vulnerable to security attacks and or privacy breaches as a result of application downloads.

According to at least one aspect of this disclosure a method includes with at least one computing device processing a software application executable by a mobile device to obtain a plurality of components of the software application and associating at least one second component with at least one of the components of the software application. The at least one second component is configured to during execution of the software application and without modifying the components of the software application determine whether the software application is attempting to perform a potentially unauthorized activity. The method also includes creating a software application package comprising the components of the software application and the at least one second component where the software application package is adapted for installation on the mobile device.

In some embodiments where the mobile device includes at least one computer accessible medium and an operating system stored in the at least one computer accessible medium the method may include installing the at least one second component on the mobile device without modifying the operating system.

The components of the software application may include unsecured compiled components and the at least one second component may include at least one compiled component configured to secure the software application against potentially unauthorized activity. The method may include creating a single executable file based on the components of the software application and the at least one second component without modifying the components of the software application.

The method may include configuring the software application package so that after the software application starts at least one of the second components executes prior to executing the software application. In some embodiments where the software application is embodied in a first software application package that includes a manifest file the method may include updating the manifest file to cause at least one of the second components to execute after the software application is started and prior to execution of the software application. In some embodiments where the software application is embodied in a first software application package and the first software application package includes a first digital certificate the method may include signing the software application package with a second digital certificate. In some embodiments where the mobile device includes a device specific security system the method may include installing the second software application package on the mobile device without modifying the device specific security system.

The method may include defining at least one policy for determining whether the software application is attempting to perform a potentially unauthorized activity and using the at least one policy to configure at least one of the second components. The method may include receiving input from a user of the mobile device and defining the at least one policy based on the input from the user. The method may include defining at least policy relating to at least one of application security application performance device security privacy network security privilege escalation a sequence of events native code and non native code.

Also according to at least one aspect of this disclosure a method includes after a software application including code interpretable as a system call to an operating system object is started and loaded into memory for execution by a mobile device and prior to execution of the software application by the mobile device at least temporarily associating the operating system object with a security and or privacy monitoring routine such that during execution of the software application the security and or privacy monitoring routine is executed prior to execution of the at least one system call.

The method may include determining a memory address of the operating system object and at least temporarily associating the operating system object with a memory address of the security and or privacy monitoring routine. In embodiments where the mobile device includes a device specific security system the method may include associating the operating system object with a memory address of the security and or privacy monitoring routine independently of the device specific security system. The method may include using dynamic linking to associate at least temporarily the operating system object with a memory address of a security and or privacy monitoring routine.

Further according to at least one aspect of this disclosure a method includes detecting during execution of a software application by a mobile device on which an operating system is running by a non operating system software routine interfacing with the software application and without modifying the operating system the software application initiating a system call to the operating system. The method also includes prior to execution of the system call by the operating system determining by the non operating system software routine interfacing with the software application based on the system call whether the software application is attempting to perform a potentially unauthorized activity and determining by the non operating system software routine interfacing with the software application whether to execute the system call in response to determining whether the software application is attempting to perform a potentially unauthorized activity.

In embodiments where the mobile device operating system includes a device specific security system the method may include determining whether the software application is attempting to perform a potentially unauthorized activity independently of the device specific security system. The method may include determining whether the software application is attempting to perform a potentially unauthorized activity based on at least one security and or privacy policy. The at least one security and or privacy policy may be associated with at least one of the system call the software application and a user of the mobile device.

The method may include analyzing at least one argument associated with the system call and determining whether the software application is attempting to perform a potentially unauthorized activity based on the at least one argument. Where the system call may be associated with an inter process communication the method may include processing the at least one argument of the system call to determine at least one parameter associated with the inter process communication and determining whether the software application is attempting to perform a potentially unauthorized activity based on at least one of the parameters associated with the inter process communication.

The method may include determining whether an argument of the system call is associated with an application that is known or suspected to be malicious by referring to a remote service. The method may include determining whether the system call comprises one of connect ioctl fork execvp and dlopen . The method may include associating the system call with at least one policy for blocking the execution of system calls and determining whether to execute the system call based on the at least one policy. The method may include determining whether the system call is configured to initiate one or more of loading native code establishing a communication connection to a remote device sending a message executing a computer program requesting an input or output creating a child process and linking of a library.

The method may include receiving input relating to the system call from a user of the mobile device prior to executing the system call and determining whether to execute the system call continue executing the software application without executing the system call or discontinue execution of the software application in response to the input from the user of the mobile device. The method may include not executing the system call in response to the input from the user of the mobile device. The method may include storing the input from the user detecting the software application initiating a second system call to the operating system accessing the stored input in response to detecting the second system call and determining whether to execute the second system call based on the stored input.

The method may include displaying a message relating to the system call at the mobile device during execution of the software application. The method may include displaying at the mobile device an indicator representing a degree of maliciousness of the system call.

Additionally according to at least one aspect of this disclosure an electronic device includes at least one processor at least one memory device coupled to the at least one processor the at least one memory device having stored therein a plurality of instructions that when executed by the at least one processor cause the at least one processor to process a first application package including a software application executable by a second electronic device to obtain at least one compiled component of the software application and associate at least one security and or privacy monitoring routine with the at least one compiled component of the software application. The at least one security and or privacy monitoring routine is configured to during execution of the software application by the second electronic device and without modifying the at least one compiled component of the software application determine whether the software application is attempting to perform a potentially unauthorized activity. The electronic device is also configured to create a second application package comprising the software application and the at least one security and or privacy monitoring routine where the second application package is adapted for installation by the second electronic device.

The electronic device may include a network interface adapted to initiate sending of the second software application package to the second electronic device over a network configured to facilitate electronic communications between electronic devices. The electronic device may be configured to receive the first application package from the second electronic device via the network interface.

Further according to at least one aspect of this disclosure at least one computer accessible medium includes a plurality of instructions that in response to being executed result in a mobile computing device in response to a request to download an application package including at least one executable software application to the mobile computing device initiating the creation of a new application package comprising the at least one software application and at least one security and or privacy monitoring routine. The at least one security and or privacy monitoring routine is configured to during execution of the software application determine whether the software application is attempting to perform a potentially unauthorized activity. The instructions may include initiating the installation of the new application package on the mobile computing device. The instructions may include initiating creation of the new application package at a second computing device communicatively coupled to the mobile computing device by a network and initiating downloading of the new application package to the mobile computing device.

While the concepts of the present disclosure are susceptible to various modifications and alternative forms specific exemplary embodiments thereof have been shown by way of example in the drawings and will herein be described in detail. It should be understood however that there is no intent to limit the concepts of the present disclosure to the particular forms disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the invention as defined by the appended claims.

In the following description numerous specific details are set forth in order to provide a more thorough understanding of the present disclosure. It will be appreciated however by one skilled in the art that embodiments of the disclosure may be practiced without such specific details. In some instances details such as control structures and full software instruction sequences have not been shown in order not to obscure the invention. Those of ordinary skill in the art with the included descriptions will be able to implement appropriate functionality without undue experimentation.

References in the specification to one embodiment an embodiment an illustrative embodiment etc. indicate that the embodiment described may include a particular feature structure or characteristic but every embodiment may not necessarily include the particular feature structure or characteristic. Moreover such phrases are not necessarily referring to the same embodiment. Further when a particular feature structure or characteristic is described in connection with an embodiment it is submitted that it is within the knowledge of one skilled in the art to effect such feature structure or characteristic in connection with other embodiments whether or not explicitly described.

Embodiments of the invention may be implemented in hardware firmware software or any combination thereof. Embodiments of the invention may also be implemented as instructions carried by or stored on a transitory or non transitory machine readable medium which may be read and executed by one or more processors. A machine readable medium may be embodied as any device mechanism or physical structure for storing or transmitting information in a form readable by a machine e.g. a computing device . For example a machine readable medium may be embodied as read only memory ROM random access memory RAM magnetic disk storage media optical storage media flash memory devices mini or micro SD cards memory sticks electrical signals and others.

In the drawings specific arrangements or orderings of schematic elements such as those representing devices instruction blocks and data elements may be shown for ease of description. However it should be understood by those skilled in the art that the specific ordering or arrangement of the schematic elements in the drawings is not meant to imply that a particular order or sequence of processing or separation of processes is required. Further the inclusion of a schematic element in a drawing is not meant to imply that such element is required in all embodiments or that the features represented by such element may not be included in or combined with other elements in some embodiments.

In general schematic elements used to represent instruction blocks may be implemented using any suitable form of machine readable instruction such as software or firmware applications programs functions modules routines processes procedures plug ins applets widgets code fragments and or others and that each such instruction may be implemented using any suitable programming language library application programming interface API and or other software development tools. For example some embodiments may be implemented using Java C C a combination of any of these and or other programming languages.

Similarly schematic elements used to represent data or information may be implemented using any suitable electronic arrangement or structure such as a database data store table record array index hash map tree list graph file of any file type folder directory or other grouping of files header web page meta tag and or others.

Further in the drawings where connecting elements such as solid or dashed lines or arrows are used to illustrate a connection relationship or association between or among two or more other schematic elements the absence of any such connecting elements is not meant to imply that no connection relationship or association exists. In other words some connections relationships or associations between elements may not be shown in the drawings so as not to obscure the invention. Also for ease of illustration a single connecting element may be used to represent multiple connections relationships or associations between elements. For example where a connecting element represents a communication of signals data or instructions it should be understood by those skilled in the art that such element may represent one or multiple signal paths as may be needed to effect the communication.

Referring now to a security privacy performance and or other policy monitoring and enforcement system is configured to operate in relation to a software application package that includes at least one machine executable software application the execution of which may be initiated by an end user. The illustrative security privacy performance and or other policy monitoring and enforcement system includes an application repackager and one or more security privacy performance and or other policies . As explained in more detail below the application repackager can be initiated by a user of a mobile computing device for example to apply monitoring code to the software application package in accordance with one or more of the security privacy performance and or other policies prior to during or after download or installation without making any changes to source code for the software application and without modifying the operating system or other programs that may be running on the mobile computing device .

As indicated by the dotted arrows the application repackager creates a new e.g. secured optimized or monitored software application package based on the software application package . In addition to the software application the illustrative application package includes security privacy performance and or other monitoring and enforcement code MEC . As described below the application repackager converts the application package to one or more component software files of the software application uses the policies to configure the MEC associates the MEC with the software application and creates the new application package . Once the application package is downloaded to or otherwise made available for use by the mobile computing device or another electronic device the MEC monitors the software application as it runs and can at least temporarily prevent the software application from engaging in potentially unauthorized activities without the user s permission or from engaging in potentially unoptimized program flow and or other activities that may be desirable to be monitored depending on the particular requirements and or features of the software application and or other factors.

The illustrative application package may be embodied as a self contained application package which includes one or more software components such as files programs libraries resources utilities and or other items that may be needed by the software application during execution. For instance in embodiments where the software application may be configured for use by an ANDROID or similar device the software application may include Activity Service Content Provider and or Broadcast Receiver software components. In some embodiments the application package may include a number of software component files that are zipped or otherwise grouped together and or compressed. For example in some embodiments the application package may include a combination of compiled and uncompiled software components. In embodiments where the software application may be configured for use by an ANDROID or similar device the application package may include one or more JAVA bytecode files which may be converted into a single executable file e.g. a classes.dex file one or more compiled application resources which may include an application manifest file e.g. AndroidManifest.xml or similar file one or more resource files e.g. resources.arsc a digital certificate e.g. cert.rsa and or one or more other uncompiled files e.g. native code libraries and or routines implemented using a lower level programming language such as C or C .

In some embodiments downloading and or installation of the application package may be initiated by a user. For example in some embodiments the application package may be downloaded from e.g. the computing device to the mobile computing device and or installed on the mobile computing device prior to during or after operation of the application repackager . Downloading and or installation may be accomplished by a user selecting clicking or otherwise activating an icon graphic or text representative of the application package which may be displayed on a graphical user interface of the mobile computing device e.g. via a network connection to an app store or market . Once the application package is downloaded and installed the software application can be executed on the mobile computing device e.g. by a user selecting or clicking on an icon graphic or text displayed on a user interface of the mobile computing device .

In the illustrative application package resides in one or more computer accessible media e.g. memory of the computing device . In some embodiments the computing device is embodied as an electronic device that has computing capabilities such as a smartphone e reader tablet computer netbook portable media player or recorder smart TV smart appliance and or others and the application package is configured to install the software application on such a device. In some embodiments the computing device and the mobile computing device may be the same device. In other embodiments the computing device may be embodied as a networked computer system or as a laptop desktop server enterprise system and or others on which the application package is stored.

In some embodiments where the software application may be specially configured to run on a certain type of device the application package may be stored on the computing device but the software application may not be executable thereby. Such may be the case for example in embodiments where the software application may be specially configured to run on a mobile computing device and the computing device is not such a device but operates as an application store or market that makes software application packages available for downloading to mobile devices.

For ease of discussion assumes that the software application can be executed by the computing device and depicts components of the computing device during execution of the software application e.g. at runtime . In embodiments where the software application is specially configured to run on a certain type of computing device such as the mobile computing device and the computing device is not such a device the following discussion applies to execution of the software application on a device for which it has been specially configured.

To initiate execution of the software application a user starts or launches the software application by clicking on or otherwise activating using e.g. voice or touch an icon graphic or text label representing the software application . After the software application is started the software application as well as any applicable application programming interfaces APIs operating system O S interface objects and the operating system are loaded into at least one memory with at least the operating system typically having been already loaded into memory prior to the start of the software application e.g. at boot up of the computing device .

At runtime the software application may interact with one or more of the APIs . Generally speaking the APIs are configured to interact with one or more of the operating system interface objects to execute computer logic and or operations specified by the software application . The operating system interface object s interact directly with the operating system to cause at least one processor of the computing device to execute machine readable instructions e.g. logic and or operations corresponding to one or more features of the software application . For the purposes of this disclosure the features of the software application can be arbitrary and may include digital media players or recorders cameras video cameras games web browsers Global Positioning System GPS locators navigators clocks telephones messaging systems electronic mail calendaring systems social networking systems e commerce systems search engines content retrieval and or delivery systems personal productivity applications and or lifestyle applications to name a few and or any combination of any of the foregoing and or others. As described below the illustrative embodiments of the application repackager and the MEC are configured to operate independently of or irrespective of the particular features of the software application . Also in the illustrative embodiments the application repackager and the MEC are not part of or associated with the operating system .

In some embodiments the operating system may be embodied as an open source operating system such as LINUX. In other embodiments the operating system may be embodied as a proprietary operating system such as MICROSOFT WINDOWS or APPLE IOS. In some embodiments the software application may be embodied as higher level programming code using for example a device independent programming language such as JAVA which may be compiled to bytecode or other executable form or a combination of higher level programming code and lower level e.g. native programming code using for example a processor or operating system specific version of a programming language such as C or C . In some embodiments the APIs may include both higher level e.g. JAVA API libraries and or objects and lower level e.g. C or C API libraries and or objects. In some embodiments the operating system interface objects may include one or more operating system specific libraries and or objects for example a C library such as libc or WINDOWS API. The operating system interface objects can be accessed during execution of the software application using a low level programming mechanism known as a system call. Additional aspects of the computing device including exemplary embodiments of the memory and the processor are described below with reference to .

The illustrative application repackager is embodied as one or more computer executable instructions routines programs or processes. The application repackager may in one or more computer accessible media e.g. memory on one or more of the computing devices or on one or more other computing device s that may be coupled to one or more of the computing device s e.g. via a communications network as shown in . The application repackager configures the security privacy performance and or other monitoring and enforcement code which includes illustratively a MEC redirecter a MEC system call intercepter and a MEC policy enforcer and associates the MEC with the software application . During this process the illustrative application repackager accesses the policies and configures the MEC based on one or more of the policies .

The policies may be embodied as one or more databases data files look up tables or other suitable data structure s . The policies may reside in one or more computer accessible storage media e.g. memory on one or more of the computing devices or on one or more other computing device s that may be coupled to one or more of the computing device s e.g. via a communications network as shown in . As described below the policies include information relating to security privacy performance and or other parameters that may be used by the application repackager to configure the MEC so that during execution of the software application the MEC executes policy logic to determine whether the software application is attempting to engage in a potentially unauthorized activity unoptimized execution and or other activity that may be monitored. Some or all of the policies may be pre defined or pre configured e.g. as default policies or may be automatically configured based on for example one or more aspects of the computing device the software application and or other factors.

The illustrative application repackager includes a user interface e.g. the exemplary user interface which allows the user to create and or customize one or more of the policies to be used in connection with the securing optimizing or other monitoring of the software application . Any or all of the policies may be specified for a particular software application or may be applicable to one or more other software applications alternatively or in addition.

Referring to the illustrative user interface the user can specify whether the software application is permitted to engage in certain specific activities with or without the user s permission or whether any or all system calls described below initiated by the software application should be permitted or blocked. For example if the user selects Yes for any of the configurable activities the software application may perform the activity without informing the user or prompting the user for permission. If the user selects No for any of the configurable activities the MEC may cause the software application to quit if the software application attempts to perform the activity. If the user selects Custom then the user may further fine tune the permission setting e.g. by identifying only certain instances in which the software application is or is not permitted to engage in the activity by specifying that the user is to be prompted before the software application proceeds with the activity by indicating that the software application may continue executing without performing the activity rather than quitting altogether or otherwise. It should be appreciated by those skilled in the art that the list of activities shown in the illustrative user interface is not intended to be an exhaustive list and that other activities may similarly be configured alone or in combination with others.

For example one or more policies may be defined e.g. by a user or an automated process to prevent the software application from accessing certain types of data and or to prohibit the software application from executing certain commands without the user s permission. This includes not only attempts by the software application to access sensitive information that may be stored on the computing device and communicating sensitive information to unauthorized recipients but also attempts by the software application to escalate privilege or gain root access on the computing device e.g. by running suspicious system calls and or loading native libraries .

Some examples of privacy policies that may be implemented using the policies database include policies to protect sensitive or private data of the user which may include the International Mobile Equipment Identity IMEI the International Mobile Subscriber Identity IMSI phone number s associated with or stored on the computing device and or other devices geographic location information and or associations of location information with other information obtained by e.g. a GPS application stored on the computing device and or other devices date and or time information and or associations of date time information with other information stored SMS messages status updates e mail messages voice messages and or other messages calendar entries task list entries contact list or address book entries phone conversations photographs videos and or others.

Some examples of security policies that may be implemented using the policies database include policies to prevent the software application from sending SMS messages or other types of messages from activating the device s camera e.g. photo or video voice recorder Internet browser and or other peripheral devices or applications. Some examples of network policies that may be implemented using the policies database include policies to regulate how the software application is permitted to interact with one or more communication networks to which it may connect or be connected e.g. wired or wireless Ethernet WIFI cellular and or other networks . For example network policies can be defined to restrict the software application s Internet access to only a particular web domain or set of IP addresses and or restrict the software application s ability to connect to one or more remote Internet Protocol IP addresses that are known or suspected to be malicious. In some embodiments this may be done by consulting an IP address registry or blacklist using e.g. a utility such as BOTHUNTER during repackaging by the application repackager and or at runtime e.g. by the MEC policy enforcer . In some embodiments one or more network policies may be set to indicate to the user a relative degree of maliciousness of a suspect IP address and or prompt the user for input as to whether to proceed with the remote connection based on the degree of maliciousness. In some embodiments this may be done by for example color coding the warning messages using audible and or other visual cues or signals and or other suitable techniques.

In some embodiments one or more privilege escalation policies may be defined in the policies to warn the user when the software application is attempting to invoke a suspicious system call or sequence of system calls that appears to be suspicious. For example a privilege escalation policy may require the user to be notified before the software application is permitted to execute a su super user command or similar command to gain greater control over the computing device or may prevent such attempts altogether. Similarly one or more policies may be defined to prevent the software application from loading a native code library executing native code without the user s permission.

Further the present invention is not necessarily limited to security and privacy applications. In some embodiments the MEC and or the one or more of the policies may be configured to monitor execution of the software application with respect to one or more other concerns such as performance. For example in some embodiments the MEC may be configured to intercept system calls that are commonly associated with certain scarce computing resources e.g. bandwidth or power consumption and deny execution of the intercepted system calls if it is determined pursuant to an applicable policy that the system calls should not be permitted to execute e.g. if too many of a certain system call or type or group of system calls are being made by the software application . It will be appreciated by those skilled in the art that many other policies and or combination of policies including any combination of any of the foregoing and or others may be implemented as policies in a similar fashion.

Once the policies are defined for the software application the application repackager configures the MEC to implement the policies in the repackaged application . For example the MEC may include computer logic configured to allow certain activities e.g. certain system calls input output I O requests inter process communication IPC requests requests to connect to remote servers and or others to proceed while disallowing others based on the type of system call and or one of its arguments for example. As explained further below with reference to the policies are enforced by the MEC policy enforcer during execution of the repackaged software application .

The application repackager may be embodied as a stand alone software application or may be embedded in or accessed by one or more other applications. For example all or portions of the application repackager may be incorporated into other computing systems or software applications that provide security privacy performance and or other monitoring or enforcement or that process software applications. Such applications or systems may include for example tools for creating user executable application packages application downloading services such as application markets or app stores anti virus software packages performance monitoring tools application testing tools code analysis tools security privacy authentication accreditation and or certification services e.g. Verisign Better Business Bureau BBB etc. .

All or portions of the application repackager may be local to a particular computing device or may be distributed across multiple computing devices . For example in some embodiments application repackager may be installed on a mobile device e.g. mobile device and executed directly by an end user to secure an application installed on the device or an application that is about to be downloaded to or installed on the device. In other embodiments the application repackager may reside in one or more computer accessible media e.g. memory on one or more remote servers e.g. one or more physical or logical servers or storage devices accessible by multiple users an Internet site e.g. a server hosting a web page or web based application and or other suitable locations depending on the type and or configuration of the particular embodiment. For example the application repackager may be offered as a service by a third party provider. In some embodiments a user interface portion of the application repackager may reside in one or more computer accessible media e.g. memory on a local device e.g. the mobile computing device while the remainder of the application repackager resides on one or more remote computing devices. Additional details relating to the application repackager are described below in connection with .

Referring now to the mobile computing device depicts components of the illustrative mobile computing device during execution of the software application e.g. at runtime on the mobile computing device after the software application has been repackaged by the application repackager . The same reference numeral is used to refer to the software application both prior to and after repackaging in order to show that in the illustrative embodiments the software application itself is not modified by the repackaging process. As noted above the illustrative application package created by the application repackager includes the software application the MEC redirecter the MEC system call intercepter and the MEC policy enforcer .

In some embodiments the mobile computing device may be any type of electronic device having the aforementioned computing capabilities. As mentioned above in some embodiments the mobile computing device may be the same device as the computing device and or the APIs O S interface objects operating system one or more memory and one or more processors may be the same or similar to the APIs O S interface objects operating system memory and processor respectively described above.

For discussion purposes an illustrative embodiment in which the mobile computing device is embodied as an ANDROID device e.g. a device running the GOOGLE ANDROID operating system or similar open source mobile operating system will now be described. In the illustrative embodiment the operating system includes a LINUX kernel e.g. LINUX 2.6 which interfaces with the one or more processors to enable software applications such as the software application to run on the mobile computing device . To do this the illustrative operating system includes one or more device drivers that can allow software applications installed on the mobile device to for example interface with one or more peripheral devices such as a camera music player voice recorder display keypad and or others to access memory or network interfaces and or communicate with other processes. In the architecture of the illustrative operating system the APIs include a number of higher level e.g. JAVA APIs and lower level e.g. C APIs some or all of which may be referred to as an application framework. The operating system provides a native code interface e.g. JAVA NATIVE INTERFACE which enables software applications that are written in JAVA to utilize the lower level APIs. Thus software applications configured for the mobile device including the software application can be written using a combination of higher level e.g. JAVA and lower level e.g. C or C programming code. In addition due to its open architecture the illustrative operating system provides a variety of different APIs including a number of APIs that can be used by an application to accomplish the same end result in different ways.

The illustrative operating system also provides a number of O S interface objects or libraries which include one or more functions that can be invoked by a system call made by an application or by an API to interface directly with the operating system e.g. with the LINUX kernel . The illustrative O S interface objects include an ANDROID specific version of the standard C library which may be referred to as the Bionic libc. No matter which API an application developer decides to use the operating system is configured so that any API requesting a service of the operating system e.g. the LINUX kernel will compile down to or be interpreted as a system call to a native function in the Bionic libc. For example in some embodiments if an application wants to download a file from the Internet it can choose from a number of APIs that may include HttpURLConnection HttpConnection Socket PlainSocketlmpl and or others but each of these are ultimately interpreted down to the connect method in the native C library e.g. Bionic libc or libc.so which issues the system call to the LINUX kernel.

The operating system also provides an application isolation mechanism by which different software applications and system services are isolated from each other at runtime. When a software application e.g. the software application is started the operating system allocates a unique uid e.g. a unique application process identifier to the application so that it runs in its own process. The operating system assigns memory space to the application loads the application into its memory space loads a copy of the applicable APIs and the O S interface objects into the application s memory space and dynamically links the APIs and the O S interface objects with the application. As applications and system services are isolated from each other at runtime e.g. they each run in their own process in the illustrative embodiments a system level mechanism known as an inter process communication IPC is invoked any time an application wants to communicate with another application or system service. The operating system provides a mechanism which may be referred to as a binder by which IPCs are handled by the LINUX kernel and communicated by the kernel to the intended recipient of the communication. So for example if an application wants to send a text message it can use a high level API such as SMSManager but internally this is converted to an IPC call using the O S binder and is ultimately interpreted down to the ioctl method in the native C library e.g. Bionic libc or libc.so which initiates the IPC communication via the LINUX kernel. Examples of functions included in the O S interface objects in the illustrative embodiments include not only connect libc.so ioctl libc.so but also dlopen fork and execvp each libc.so however this is intended to be an exemplary not exhaustive list.

The illustrative operating system also provides an install time application permission system e.g. a device specific security system as shown in . The install time permission system provides that when an application is installed on the mobile device the operating system identifies to the user any security privileges and or permissions that are requested by the application and the user either grants or denies the privileges and or permissions prior to installation of the application. If the user denies the requested privileges and or permissions the application cannot be installed. As the application is not installed unless the requested privileges and or permissions are agreed to the application repackager and the MEC do not interfere with the device level install time permission system. Rather the application repackager and the MEC allow the user to accept the privileges and or permissions requested by the application at install time and then enable the user to supplement or fine tune those privileges and or permissions during repackaging of the application via the policies .

This is illustrated by the exemplary user interface which may appear at runtime if the MEC system call intercepter encounters a suspicious system call such as in the illustrative example a system call that is trying to send the user s IMEI to an unknown recipient . That is the fact that the repackaged application is installed on the mobile computing device with the MEC associated therewith indicates that the user has agreed to the security privileges and or permissions requested by the software application at install time via the operating system s application permission system e.g. the device specific security system . Then as explained further below at runtime of the repackaged application the MEC redirecter causes system calls e.g. calls to functions in the Bionic libc or libc.so to be redirected to the MEC system call intercepter without modifying the software application or the operating system . The MEC system call intercepter pre processes the redirected system call and its arguments and passes that information on to the MEC policy enforcer . The MEC policy enforcer having been configured according to the policies by the application repackager determines whether to execute the system call. In some embodiments as shown by the exemplary user interface the MEC policy enforcer prompts the user for input relating to the intercepted system call and determines whether to execute the system call based on the user s input. Also in some embodiments the MEC policy enforcer may store the user s input e.g. in cache memory for future use if the software application attempts to invoke the same system call again for example .

Referring now to an illustrative method which may be implemented as one or more computer executable instructions routines or processes by which the application repackager may add privacy and security monitoring and enforcement code e.g. MEC to an application package is shown. At block the method identifies the software application to be repackaged. To do this in some embodiments the method may process and or interpret one or more arguments or inputs received by the application repackager which may include the application name location e.g. directory or folder and or other information identifying the application to be repackaged. In the illustrative embodiments the application to be repackaged is the unsecured version of the software application contained in the application package .

At block the method determines which of the policies are applicable to the application to be repackaged e.g. the software application contained in the application package . This may be done in some embodiments based on the type of computing device on which the software application is intended to be installed the type of software application user specified preferences and or other criteria. For example in some embodiments computer game applications may have different policies than information retrieval applications. Also in some embodiments the policies may be stored in the cloud e.g. on one or more remote servers and at least some of the policies may be applicable to certain types of devices but not others. As an illustration a user may own multiple types of computing devices e.g. a smartphone a tablet and a media player or two different brands of smartphones and may specify some policies that are applicable to one or more of those devices but not to the others. The information linking the policies and the applicable applications and or devices may be stored with the policies or in a look up or mapping table or other suitable data structure which may be accessed by the method at block .

At block the method processes the original application package which includes the software application identified at block to convert or disassemble it into its constituent components. Using the ANDROID example the application package may be embodied as a single archive file called an ANDROID APPLICATION PACKAGE or APK file. The APK file includes a compiled manifest file e.g. AndroidManifest.xml the compiled application code e.g. a classes.dex file which contains the application s code in the form of a single dex bytecode file compiled XML resources such as window layout and string constant tables uncompiled resources such as image and sound files and native libraries and a digital signature. The method uses a disassembling tool such as APKTOOL or SMALI to disassemble or decode the classes.dex file into a directory tree structure that maps each constituent bytecode file of the application package to a single JAVA class and maps its directory path to the directory hierarchy. All of the other components of the application package are also stored in the same directory structure.

At block the method adds e.g. by copying or moving the MEC to the directory created at block which contains the components of the application package . At block the method ensures that the MEC will be invoked at runtime ahead of the software application by assigning a higher priority to the MEC than the software application . In the ANDROID example the compiled e.g. dex bytecode manifest file for the application package is modified to define at least the MEC redirecter as the Application class which will be instantiated by the ANDROID runtime environment when the repackaged software application is started. If there is already an Application class defined in the software application s compiled manifest file then the existing class is maintained but its definition is modified so that it inherits from the Application class defined for the MEC redirecter . It should be appreciated that at block modifications are made only to a compiled manifest file and not to any executable files of the software application or to any source code of the software application .

At block the method creates the new application package including the MEC and the updated application priority information. In the ANDROID example the method uses an assembling tool e.g. APKTOOL or SMALI to assemble the disassembled bytecode files back to dex bytecode form and create the new application package . The application package includes the updated manifest file and the MEC in the form of a new APK file. It should be appreciated that at block the MEC is added to the application package without modifying the executable files or source code of the software application .

At block the new application package is authenticated with a digital signature. In at least the ANDROID example the method creates a new digital certificate and signs the application package with the new certificate. The signed application package e.g. the secured version of the application package is then ready to be installed on a computing device e.g. the mobile device .

Referring now to an illustrative method which may be implemented as one or more computer executable instructions routines or processes by which the MEC redirecter may cause low level system calls made by the repackaged software application to be redirected to privacy security performance and or other monitoring and enforcement code at runtime is shown. Generally speaking the MEC redirecter operates after the software application is started but before the software application begins executing to during execution of the software application cause system calls to functions in the O S interface objects to be at least temporarily redirected to the MEC system call intercepter . Thus in the blocks and depicted with dashed lines are not part of the MEC redirecter but are processes that occur before and after the MEC redirecter operates. At block the repackaged software application is started as described above. At block the repackaged software application and the MEC are assigned to a process memory space and loaded into memory and the APIs and the O S interface objects are loaded into the process memory space and are dynamically linked to the repackaged software application . Typically these steps are performed by operating system utilities which may be referred to as a loader and a linker after the software application is started. In the illustrative embodiments the dynamic linking creates a mapping table which may be referred to as a global offset table or GOT . The mapping table includes an array of function pointers of all of the dynamically linked external functions e.g. functions accessible via the APIs and or the O S interface objects that are referenced by the software application during its execution. For example in some embodiments the mapping table may include a table or listing of function names or identifiers names or identifiers of the corresponding objects or libraries in which the functions are located and the memory addresses assigned to the functions by the loader at runtime.

The MEC redirecter begins executing after the dynamic linking is complete and before the software application begins executing by virtue of it having been assigned a higher runtime priority than the software application e.g. by having been declared as the base Application class by the application repackager at block of . At block the MEC redirecter preserves the memory addresses allocated by the loader at block to the functions in the O S interface objects . In some embodiments this may be done by simply making a copy of the mapping table and storing it in one or more computer accessible media e.g. cache memory .

At block the MEC redirecter associates the system level functions in the O S interface objects e.g. the native C library or libc.so functions with the memory address es assigned to the MEC system call intercepter by the loader at runtime. In the illustrative embodiments this may be done by replacing the original mapping table or creating a new mapping table and replacing the memory addresses of the O S interface objects with the memory address es of the MEC system call intercepter . In effect the MEC redirecter simply re dos the dynamic linking to cause the O S interface objects to be associated with the MEC system call intercepter . The end result of this is that during execution of the repackaged software application which begins at block system calls to functions in the O S interface objects are redirected to the MEC system call intercepter before they are executed. It should be appreciated that in some embodiments the MEC redirecter and MEC system call intercepter may be configured e.g. by the application repackager according to the policies so that only certain system calls are intercepted and redirected at runtime or so that every system call is intercepted and redirected. So as to be able to modify the process memory the illustrative embodiments of the MEC redirecter are written in a lower level programming language such as C and compiled to native code.

Referring now to an illustrative method which may be implemented as one or more computer executable instructions routines or processes by which the MEC system call intercepter may pre process system call information at runtime is shown. As a result of the work of the MEC redirecter prior to execution of the repackaged software application the MEC system call intercepter is invoked during execution of the repackaged software application each time the repackaged software application initiates a system call that has been redirected by the MEC redirecter . Thus block is shown with dashed lines to indicate that it is the repackaged software application not the MEC system call intercepter that performs block . When the repackaged software application invokes a system call at block the program flow is redirected to the MEC system call intercepter before the system call is executed as a result of the dynamic linking done earlier by the MEC redirecter .

At block the MEC system call intercepter pre processes the intercepted system call and or its arguments to determine the nature or intent of the system call. For example if the intercepted system call is a call to the connect function in the native C library e.g. libc.so the arguments may include a target IP address and port and or others. The MEC system call intercepter may parse or otherwise reformat or process the argument s to put them into a form that can be fed to and used by the MEC policy enforcer . When the MEC system call intercepter encounters a system call that involves an inter process communication e.g. a call to the ioctl function in libc.so the arguments may include the type of IPC requested e.g. a call to the camera application and embedded in the IPC request the arguments for the call to the camera application e.g. instructions for the camera application such as whether to turn the camera on off take a picture etc. . Thus additional pre processing may be needed to extract the IPC parameters from the system call arguments and reconstruct them in a form that can be passed to and used by the MEC policy enforcer . In the illustrative embodiments the MEC system call intercepter is written in a lower level programming language such as C and compiled to native code. The pre processed system call and arguments are passed e.g. as parameters to the MEC policy enforcer at block .

Referring now to an illustrative method which may be implemented as one or more computer executable instructions routines or processes by which the MEC policy enforcer may enforce application based privacy security performance and or other policies during execution of the repackaged software application is shown. In the illustrative embodiments the MEC policy enforcer is invoked by the MEC system call intercepter . At block the method receives the intercepted system call and its arguments from the MEC system call intercepter e.g. as parameters .

At block the method analyzes the intercepted system call and argument information and determines which policy logic applies to the system call and or arguments. For example in some embodiments a user may have defined e.g. during the repackaging done by the application repackager a policy that connect system calls can be permitted for certain target IP addresses but not for others or that for this particular application no connect system calls should be permitted at all. Alternatively or in addition the policy logic may pass the target IP address information to a domain registry or blacklisting service e.g. BOTHUNTER to determine at runtime whether the target IP address is known or suspected to be malicious. As another example in some embodiments a user may have defined e.g. during the repackaging done by the application repackager a policy that ioctl system calls can be permitted for certain target applications but not for others or for certain features of the target application but only with the user s consent for example to turn on the camera but to prompt the user before taking any pictures . In some embodiments the MEC policy enforcer s policy logic is configured during repackaging by the application repackager in accordance with the policies . Thus in those embodiments there may not be any need to access the policies database at runtime but only to execute the policy logic. In other embodiments the MEC policy enforcer may be configured to access the policies at runtime.

At block the method determines based on the policy logic whether to proceed with the intercepted system call without user input. If the method determines that the system call should not be executed without user input then at block the method determines whether to prompt the user for input as to whether to continue with the system call or to simply quit the system call. If the policy logic indicates that the user should be prompted for input then at block a warning message and prompt is displayed e.g. via the user interface . After receiving user input at block the method returns to block and either proceeds with the system call based on the user input or skips over or aborts or otherwise does not execute the system call.

In some embodiments as shown by the exemplary user interface the method may ask the user whether to store the user s input for future use. Thus if at block the user answers Yes to proceed with the system call and Yes to remember that decision then the next time the repackaged application attempts to invoke the same system call and or other similar or related system calls the MEC policy enforcer may proceed directly from block to block based on the stored user input.

If at block the policy logic indicates that the system call should be aborted without user input then the method proceeds to block . At block the method determines based on the policy logic whether to not execute the system call or to quit executing the entire application. If the method determines that the entire application should be ended then at block execution of the repackaged software application is ended. If the method determines that the system call should not be executed but the execution of the repackaged software application may otherwise continue then at block the method skips or aborts the system call or otherwise does not execute the system call and continues the normal execution of the repackaged software application at block .

If at block the method determines based on the policy logic and or user input that the system call can be executed then at block the method jumps to the system call and executes the system call as originally invoked by the repackaged software application . At block the method may access the preserved original copy of the mapping table created by the MEC redirecter at block of to determine the actual memory location of the system call. The method returns control to the repackaged software application at blocks and and the repackaged software application continues normal execution at block . In the illustrative embodiments the MEC policy enforcer is written in a higher level programming language such as JAVA and compiled to executable code e.g. dex bytecode .

Referring now to an illustrative embodiment of a computing device in connection with which aspects of the security privacy performance and or other monitoring and enforcement system may be implemented is shown. For example either and or both of the computing devices may be implemented with one or more of the features of the computing device . The illustrative computing device includes at least one processor and an input output I O subsystem . The processor includes one or more processor cores e.g. microprocessors . The I O subsystem typically includes among other things an I O controller a memory controller and one or more I O ports not shown . The processor and the I O subsystem are communicatively coupled to a memory . The memory may be embodied as any type of suitable memory device such as a dynamic random access memory device DRAM synchronous dynamic random access memory device SDRAM double data rate dynamic random access memory device DDR SDRAM and or other volatile memory device.

The I O subsystem is communicatively coupled to at least one input device at least one data storage at least one output device one or more peripheral devices optional and at least one network interface . The input device may include a keyboard keypad touch screen microphone or other suitable device for accepting input from a user e.g. via user interfaces . The output device may include a text graphics and or video display screen speaker or other suitable device for presenting output e.g. warning messages and prompts such as shown by user interface to the user. The peripheral device s may include for example cameras media players or recorders GPS devices graphics sound and or video adapters and or others depending upon for example the intended use of the computing device .

The network interface communicatively couples the computing device to one or more networks which may include a local area network wide area network personal cloud enterprise cloud public cloud and or the Internet. Accordingly the network interface may include a wired or wireless Ethernet adapter WIFI adapter or other suitable device as may be needed pursuant to the specifications and or design of the particular network .

The illustrative data storage includes one or more computer accessible media such as one or more hard drives or other suitable data storage devices e.g. memory cards memory sticks and or others . In the illustrative embodiment an operating system and a device specific security system reside in the data storage . The operating system is for example a MICROSOFT WINDOWS LINUX IOS or other operating system or other similar set of instructions which may be designed specifically for a particular type of computing device for example a discrete handheld or portable electronic device or smartphone. The device specific security system is for example an application permission system such as the ANDROID install time application permission system described above or other similar set of code or instructions which may be designed specifically for a particular type of computing device for example a discrete handheld or portable electronic device or smartphone.

In the illustrative example the security privacy performance and or other monitoring and enforcement system includes an application security manager an application repackager and one or more security privacy performance and or other policy ies . At least a portion of each of the application security manager and the policy ies is stored in the data storage . Portions of the operating system application security manager and the policy ies may be copied to the memory during operation for faster processing or for other reasons.

In some embodiments the application security manager may be embodied as a client application or front end user interface for the security privacy performance and or other policy monitoring and enforcement system while a back end or server application e.g. the application repackager may reside on the network . Similarly the policy ies may include some policies that are local to the computing device such as user device and or application specific policies while other aspects of the policy ies which may be user device and or application independent for example may reside on the network . In other embodiments the entire security privacy performance and or other monitoring and enforcement system may be stored in the data storage of the computing device .

In some embodiments the application security manager may be launched automatically each time a user of the computing device attempts to or has already downloaded an application . In other embodiments the application security manager may be invoked to upload an application to the network to be repackaged by the application repackager . The application security manager may invoke the application repackager to create the repackaged application and replace the original application on the computing device and or the network with the repackaged application as shown in .

The computing device may include other components sub components and devices not illustrated in for clarity of the description. In general the components of the computing device are communicatively coupled as shown in by one or more signal paths which are represented schematically as bidirectional arrows. Such signal paths may be embodied as any type of wired or wireless signal paths capable of facilitating communication between the respective devices.

While aspects of this disclosure have been illustrated and described in detail in the drawings and in the foregoing description such illustrations and description are to be considered as exemplary and not restrictive in character it being understood that only illustrative embodiments have been shown and described and that all changes and modifications that come within the spirit of the disclosure are desired to be protected. Further while certain aspects of the present disclosure have been described in the context of an exemplary smartphone implementation it will be understood that the various aspects are applicable to other mobile device configurations including ANDROID APPLE IOS and or others and have other applications for example any application in which it is desired to provide security privacy performance and or other monitoring at the application level. Such applications may include for example application vetting services and or application developer solutions such as performance rating systems security validation systems and vulnerability testing systems as well as application store or market services and other consumer oriented services including trusted application indicators and anti virus software for example.

In addition aspects of this disclosure are applicable to electronic devices other than smartphones including devices that may not typically be considered mobile. For example the computing device may be embodied in or as any type of computing device capable of performing the functions described herein. For example the computing device may be embodied as a cellular phone a smartphone a mobile Internet device a handheld laptop or tablet computer a personal digital assistant a telephony device or other portable electronic device. Also while not typically considered mobile in so far as that term may be inferred by some as referring to a handheld device it should be understood that aspects of this disclosure are applicable to other types of electronic devices such as desktop computers servers enterprise computer systems networks of computers Internet enabled televisions or other electronic appliances or other electronic device s that are capable of performing the functions described herein depending on the particular implementation of the security privacy performance and or other policy monitoring and enforcement system .

