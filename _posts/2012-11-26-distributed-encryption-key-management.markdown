---

title: Distributed encryption key management
abstract: Secure information is managed for each host or machine in an electronic environment using a series of key identifiers that each represent one or more secure keys, passwords, or other secure information. Applications and services needing access to the secure information can specify the key identifier, for example, and the secure information currently associated with that identifier can be determined without any change to the code or manual input or exposure of the secure information on the respective device. Functionality such as encryption key management and rotation are inaccessible and transparent to the user. In a networked or distributed environment, the key identifiers can be associated with host classes such that at startup any host in a class can obtain the necessary secure information. Updates and key rotation can be performed in a similar fashion by pushing updates to host classes transparent to a user, application, or service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08848922&OS=08848922&RS=08848922
owner: Amazon Technologies, Inc.
number: 08848922
owner_city: Reno
owner_country: US
publication_date: 20121126
---
This application is a continuation of U.S. Pat. No. 8 321 925 filed Feb. 17 2009 entitled DISTRIBUTED ENCRYPTION KEY MANAGEMENT and is a continuation of U.S. Pat. No. 8 245 037 filed on Feb. 17 2009 entitled ENCRYPTION KEY MANAGEMENT both of which are hereby incorporated herein by reference.

As an increasing amount of information is being stored electronically and as the number of transactions performed electronically increases there is an ever increasing need to protect sensitive information in an electronic environment. This includes not only securing the storing and transmitting of information but also securing access to the information. A common approach is to encrypt information using an encryption algorithm or cipher to encode information such that the information can only be decrypted or otherwise interpreted using the same cryptographic key. Managing these cryptographic keys has been a challenge for many organizations for years. In order to improve security and minimize the risk that information will be accessed by an unauthorized user obtaining one of these keys a unique key can be used for each instance of information. For example a first unique key might be used to transmit a piece of information a second unique key might be used to store the information and a third unique key might be needed to obtain access to the information. Alternatively a separate key can be used for each piece of data that is stored or transmitted. Such an approach generally does not scale well and presents further challenges with managing the keys in this scenario. Further there can be several such pieces of information in any given system such as credit card information user data database passwords access keys etc.

A potential problem presents itself in that these keys and other such security items must be stored and maintained in a secure fashion. Essentially the keys themselves become the equivalent classification of the sensitive information those keys are protecting. Some previous approaches hardcoded passwords into application binaries that needed to securely access a resource such as a database but this is a weak and ineffective obfuscation technique with the password then viewable not only by the programmer entering the password into the application but also to any user able to access the source code. Such approaches also typically require manual entry of each password on each device as well as manual rotation of the passwords on each device. Various insecurities arise as the number of people having access to secure objects including keys or passwords increases. Further if material is to be re encrypted at various times using different secure objects then the re encryption also has to be done manually and generally increases the number of people having access to the secure objects. Certain programming languages such as Java provide functionality that allows a user to store sensitive information in a relatively secure fashion. Unfortunately such approaches tend to be tightly coupled to the programming language or technology and cannot easily be used with outside technology and are still largely ineffective.

Another problem with managing sensitive information is that generating code to implement cryptography effectively is very difficult. There are a number of different cryptographic approaches and algorithms and it is difficult to know when it is advantageous to use each approach. While certain third party toolkits are available that assist with such coding and encryption these toolkits are still relatively complex and require managing several toolkits to obtain all the desired functionality. Further not all toolkits have been subjected to lengthy cryptanalysis so may prove to be a poor implementation once an expensive investment has been made to use the toolkit.

Even if an encryption solution is selected there still are disadvantages to many such approaches in that higher security levels require a periodic rotation or changing of encryption keys. Thus it is typically necessary to manually adjust the keys used for encryption. Such an approach can be particularly complex in a distributed environment with a number of devices that each must obtain the key.

Systems and methods in accordance with various embodiments of the present disclosure may overcome one or more of the aforementioned and other deficiencies experienced in conventional approaches to managing sensitive information and or resources in an electronic environment. In particular a key identifier sometimes known as a token or other such secure identifier can be used to represent one or more secure keys passwords or other secure objects or pieces of sensitive information. A secure object may not only include an encryption key or secure password for example but in some embodiments can also include information about how to use the key or password as well as information identifying an algorithm or other process or procedure to be used with the key or password. By using a token for example to represent the secure information that information can be updated rotated or otherwise changed without any significant impact on the services applications hosts or users relying on that information. Further the tokens can be discoverable without exposing the underlying secure objects associated therewith. For example a key identifier can correspond to a key ring that includes a set of encryption keys or other such secure keys. A version number or other identifier can be used to specify one of those keys to be used at any given time for that key identifier without the specifying entity having to provide or even know the actual key being specified. In other embodiments one of the keys of the ring can be set as a default key for a period of time such that a secure operation can be performed by specifying just the key identifier without a version number or other such information. A security related task operation or function can be performed using the key identifier whether or not a service application device or user performing the task is aware of the current key. In many cases the entity performing the task may be unaware that the security information has changed and may have no way of determining the secure information. The changes and maintenance relating to the secure information can be performed transparent to the user or other such entity. Such an approach allows the secure objects to be maintained rotated etc. without being exposed to a user.

Further the sensitive information can be handled for multiple hosts or other such entities in a distributed or networked environment. A security service or application for example can store and manage sensitive information in a centralized manner. Each host for which sensitive information is being managed can be assigned to one or more host classes and each host class can have one or more key identifiers associated therewith. In this way each host can obtain the appropriate information simply by sending a request identifying the host class es to which that host belongs. Hosts can easily be added to the system as each host can send a request to a security service at startup for example and can automatically receive the necessary security information for the appropriate host class es . The host class information also can be used to automatically push updates or rotates keys for the various identifiers in an automatic manner that can be transparent to any users applications or services.

The illustrative environment includes at least one application server and a data store . It should be understood that there can be several application servers layers or other elements processes or components which may be chained or otherwise configured which can interact to perform tasks such as obtaining data from an appropriate data store. As used herein the term data store refers to any device or combination of devices capable of storing accessing and retrieving data which may include any combination and number of data servers databases data storage devices and data storage media in any standard distributed or clustered environment. The application server can include any appropriate hardware and software for integrating with the data store as needed to execute aspects of one or more applications for the client device handling a majority of the data access and business logic for an application. The application server provides access control services in cooperation with the data store and is able to generate content such as text graphics audio and or video to be transferred to the user which may be served to the user by the Web server in the form of HTML XML or another appropriate structured language in this example. The handling of all requests and responses as well as the delivery of content between the client device and the application server can be handled by the Web server. It should be understood that the Web and application servers are not required and are merely example components as structured code discussed herein can be executed on any appropriate device or host machine as discussed elsewhere herein. Further the environment can be architected in such a way that a test automation framework can be provided as a service to which a user or application can subscribe. A test automation framework can be provided as an implementation of any of the various testing patterns discussed herein although various other implementations can be used as well as discussed or suggested herein.

The environment also includes a development and or testing side which includes a user device allowing a user such as a developer data administrator or tester to access the system. The user device can be any appropriate device or machine such as is described above with respect to the client device . The environment also includes a development server which functions similar to the application server but typically runs code during development and testing before the code is deployed and executed on the production side and is accessible to outside users for example. In some embodiments an application server can function as a development server and separate production and testing storage may not be used.

The data store can include several separate data tables databases or other data storage mechanisms and media for storing data relating to a particular aspect. For example the data store illustrated includes mechanisms for storing production data and user information which can be used to serve content for the production side. The data store also is shown to include a mechanism for storing testing data which can be used with the user information for the testing side. It should be understood that there can be many other aspects that may need to be stored in the data store such as for page image information and access right information which can be stored in any of the above listed mechanisms as appropriate or in additional mechanisms in the data store . The data store is operable through logic associated therewith to receive instructions from the application server or development server and obtain update or otherwise process data in response thereto. In one example a user might submit a search request for a certain type of item. In this case the data store might access the user information to verify the identity of the user and can access the catalog detail information to obtain information about items of that type. The information then can be returned to the user such as in a results listing on a Web page that the user is able to view via a browser on the user device . Information for a particular item of interest can be viewed in a dedicated page or window of the browser.

Each server typically will include an operating system that provides executable program instructions for the general administration and operation of that server and typically will include a computer readable medium storing instructions that when executed by a processor of the server allow the server to perform its intended functions. Suitable implementations for the operating system and general functionality of the servers are known or commercially available and are readily implemented by persons having ordinary skill in the art particularly in light of the disclosure herein.

The environment in one embodiment is a distributed computing environment utilizing several computer systems and components that are interconnected via communication links using one or more computer networks or direct connections. However it will be appreciated by those of ordinary skill in the art that such a system could operate equally well in a system having fewer or a greater number of components than are illustrated in . Thus the depiction of the system in should be taken as being illustrative in nature and not limiting to the scope of the disclosure.

An environment such as that illustrated in can be useful for a provider such as an electronic marketplace wherein multiple hosts might be used to perform tasks such as serving content authenticating users performing payment transactions or performing any of a number of other such tasks. Some of these hosts may be configured to offer the same functionality while other servers might be configured to perform at least some different functions. The electronic environment in such cases might include additional components and or other arrangements such as those illustrated in the configuration of . In this example an end user device is able to connect through a network to access at least one host or server . The server might have access to at least one data repository for use in serving requests from the user device . As discussed elsewhere herein there can be several types of security used with respect to the user device and the server or database which may be controlled by a security administrator device able to configure and manage security for the server host and any related components. For example the user might send a request for content or a resource that needs to be decrypted by the server . In another example the server might require secure authentication of the user device in order to provide access to services or functionality provided by the server and may require different security criteria to access and or store data in the data repository . Further any service and or application may also require separate security criteria. Various other types of security can be utilized as discussed and suggested elsewhere herein.

Systems and methods in accordance with various embodiments can provide for the management of various security aspects for such components. In one embodiment objects such as secure keys for a variety of services hosts users etc. can be stored securely utilizing a key identifier for each such object. By using a key identifier applications and services can be developed without exposing the actual secure key information to anyone. Once the secure key is stored in a secure location and a corresponding key identifier is defined the secure key information can be accessed only through managed software outside human intervention although in some embodiments an authorized user may be able to obtain access in certain situations. Such an approach can provide a hands off and language agnostic way of dealing with matters such as cryptography and sensitive keys.

Another advantage to such an approach is that the actual secure key associated with a key identifier can be changed without the need to change the key identifier used by an application service or user for example as such a change would otherwise require pushing change information to a large number of locations and ensuring that each location successfully received and implemented the change. In one example each key identifier includes version information that can be used to specify the current secure key associated with that identifier. For example illustrates a table wherein several key values are specified for a single key identifier . As can be seen each key value corresponds to a version of the corresponding key identifier . Thus one of the key values can be specified by passing the key name and the appropriate version number. In this embodiment one of the versions and or key values is specified as the default . Thus the current key value might be accessible simply by specifying the key name for the key identifier without further specifying a version number.

Further such an approach allows for large amounts of data or information to be periodically re encrypted without manual intervention. In some embodiments data can be re encrypted upon the changing of a default key although any other appropriate period or time point can be used as should be apparent. In any case the information can be re encrypted without manual intervention or exposing a secure object outside the software and or system.

In one example a user can ask to perform a task such as encrypting or decrypting content simply by passing the appropriate key name as a parameter value from a command line or an appropriate user interface. In some embodiments an application programming interface API can be defined such that an application can pass the appropriate key name and or version number to the key management service or module without the user of the application ever having to know anything about the key information. As discussed a call can be made through the API that does not include a serial number and in such a case either the default or preferred value can be used or in some cases the appropriate value with be otherwise determined or specified. For example an application can be configured to always use the key available with the highest version number or using any similar approach.

Once the keys and key identifiers are entered into and or available to the security service any appropriate request for a secure operation using that key identifier can be processed by the service. In this example a request is received to encrypt a file using a specific key identifier . In some embodiments the request itself will specify the key identifier while in other embodiments the key identifier could be identified by the host service or another appropriate source such that the user or source of the request does not need to be aware of the key identifier. A determination can be made as to whether the key identifier has a version or particular key identified . If no version or key is identified then the current default key for the key identifier can be selected . If a version is identified then the identified key can be selected . The file identified by the request then can be encrypted using an appropriate encryption algorithm and the selected key . In some embodiments the algorithm is specified by the security service while in other embodiments the algorithm used can be selected by the user algorithm service or any other entity operable and authorized to select algorithms offered by the security service. Identification information for the algorithm and the key used for the encryption can be stored in the metadata or other content of the encrypted file such that any host or service having access to the key and algorithm can decrypt the file.

Thus an advantage of such an approach is that the encryption information does not need to be passed back to the user or application. When an encrypted document or file is returned to a user or otherwise stored for access information such the encryption algorithm and key identifier used to encrypt the document can be included with the file itself. This not only saves the effort of having to send the information to the user for the user to maintain but also allows any authorized recipient of the document such as another host to decrypt the document if that recipient device system or application has the appropriate algorithm and access to the key specified in the metadata. A user or application can therefore cause a document or other such object to be decrypted simply by providing the document to a host or other receiving device having the necessary information without separately providing a key identifier or version information as the information is already included in the metadata and the content is thus able to be automatically decrypted. Such an approach can be particularly beneficial when the key associated with a key identifier changes as the host can automatically determine the current key value and perform the decryption. A security application or service thus can provide a simply set of APIs that can be used to encrypt and or decrypt arbitrary blocks of data.

As discussed it can be desirable to change the key values that are used to encrypt content provide access or otherwise secure information. Another advantage to the use of key identifiers and version numbers is that a security service or application can provide for the management of key rotation. A user such as a security administrator can specify that new keys are to be introduced at specific intervals and at least some of these keys can be reused at different times in some cases. Using an approach such as that discussed with respect to new key values can be added updated and or deleted from an association with a key identifier such that the actual key value can be rotated or changed at any appropriate time. In other technologies that store keys by name logic must be developed to rotate keys or the rotation must be done manually. In various embodiments discussed herein keys are identified by both an identifier and a version number whereby the version number can be configured to be incremented or otherwise rotated automatically. Such an approach allows a set of keys passwords or other secure objects to be associated with a single name or identifier typically to be used to a single function or set of functions such that the actual objects can be rotated and or updated periodically with minimal effort.

A security application or service in accordance with one embodiment organizes secret information such as passwords or keys into logical groups referred to herein as key rings. A key ring might include a password for a data repository as well as all of the past passwords and any known future passwords. Any of these passwords then can be set as the default or preferred password at any time. A key ring in one embodiment is stored on each host belonging to a specified host class for that key ring. If the key ring stores eight different passwords for example each of these passwords can be given a number such as a number from zero to seven. Any of these passwords then can be specified for purposes of encryption or decryption for example simply by supplying the key ring identifier. If desired a corresponding key number can be specified to indicate which key on the ring to be used. Otherwise a preferred default or current key on the ring can be used such as may be tagged by a security administrator or administration application.

When changing the key of the ring to be used or otherwise performing key rotation or updating a new key can be pushed out to each host or other appropriate component as necessary. The new key can be used once that key is distributed to all the appropriate hosts. In conventional systems using key names it is difficult and complex to make sure each necessary host receives and implements the key as hosts can be offline or there can be any of a number of other reasons. In embodiments described herein even hosts in a large distributed systems can continue to use the old key associated with the key identifier until the new key is distributed. Thus a host can start decrypting information using key seven for example while other hosts without the latest key continue using key six in the meantime. The system advantageously does not need to track or be aware of the version or key each host is using as all hosts simply continue to use the same key identifier. Further the previous key can remain the preferred key in some embodiments until all hosts have the new key at which point the new key can be designated the preferred key. Some hosts allow querying such that it is possible to determine which key rings each host has as well as the current keys and or versions for each ring. Functionality such as key monitoring and snap shots can be provided in order to quickly determine which hosts have which keys and the states of those keys at any given time. While many examples discussed herein refer to hosts and host implementation it should be understood that this is merely an example and that various other devices components applications and services can utilize such functionality as described and suggested herein.

As discussed a user can encrypt content simply by passing the content to a host that can extract the algorithm and key information from the metadata and decrypt the content accordingly without the user providing such information or even necessarily being aware of the security information. An approach in accordance with one embodiment also allows a user to perform specific functionality in a similar fashion without providing the necessary security information. For example just as a user can use an API to ask an application or service to encrypt a file for example a user can use an API to request a connection to a data repository Web service or any other component with which the user can establish a connection. The user does not have to enter or submit a script to be executed but can simply submit a request for connection and the application or service can utilize the appropriate security information to establish a connection on behalf of the user as the application or service knows the current password needed to establish the connection. The user thus does not need to know anything about the encryption or security criteria used.

In some embodiments the keys for each key identifier are each manually entered once on each machine and the software manages the keys from that point forward. Each machine thus acts as a standalone security terminal receiving and storing the keys and maintaining the local copy. In order to ensure that the security software is on each machine the software in some embodiments is manually installed. In other embodiments the software can be distributed or pushed out to any new machines across a network cluster or other grouping of devices. In some embodiments a new machine will ask for configuration information at startup. Updates to the security software can be pushed out or distributed in a similar fashion.

Since the hosts or other machines on the network are able to receive software and updates in a distributed manner approaches in accordance with several embodiments take advantage of and build on such functionality to provide for automatic and transparent key distribution. The ability to automatically distribute and maintain keys across a group of devices can be particularly desirable for applications such as cloud computing where services are offered from a scalable set of devices and the number of devices can be increased or decreased as needed. Such an approach also allows for all keys to be stored at a centralized location with each host or machine only receiving and storing a local copy of those keys needed by or approved for that machine.

In one embodiment each existing host is assigned to at least one host class. An example of a host class corresponds to all servers for the United States serving display pages for items in an electronic marketplace. If a host offers a specified set of services for example then that server can be assigned to a specific host class. Each server can belong to one or more host classes. The security server can maintain at least one host class access control list ACL that can be used to specify which hosts are to have access to each key identifier. Thus a security administrator can enter each key into central security data store and can specify at least one host class to receive or have access to the key. A developer or administrator can assign each new host to at least one host class such that at startup the new host can contact the security service with a list of its host classes. The security server then can use the ACL to determine which keys to transmit to the new host. Such an approach allows only the necessary keys to be distributed to each server while the keys do not have to be manually entered on each device. In the example new host might belong to the class that is able to serve the request from the end user device and thus would have received the necessary key s after startup. If new host does not belong to the class able to serve the request then host would not have the key needed unless the key was also used for another class and thus could not serve the request from the end user device. In one embodiment each host might belong to a common class such as a class that enables each host to receive the key s needed to access a central data repository such as an Lightweight Directory Access Protocol LDAP database . An LDAP database can include for example all information needed to manage the hosts across the network and thus can also include the class data information shown to be stored separately in . When a new host is provisioned the host can contact a set of services at startup to receive configuration information such as the host name Internet Protocol IP address users or user groups authorized to have access host class and other such information that makes the host unique. At least one of the services contacted at start time can be a security service offered by the security server that is able to receive the host class information from the host and return the necessary key information to the host. This can include for example a set of key rings and or key identifiers such as is discussed above with respect to .

A system in accordance with one embodiment is operable to push out the updated information to each host to which the change applies. For example as described with respect to a security administrator can update an ACL which can cause different keys to be associated with different key classes. illustrates steps of an example process for first associating the key information and pushing that information out to the appropriate hosts. As discussed at least one host class is designated and at least one key identifier is associated with each class . The associations and information can be maintained by a security service or application as discussed herein and the secure information such as keys or passwords can be stored for each key identifier . A service request subsequently can be received from a host for which secure information is being maintained. Such a request can be received at any appropriate time such as when a server is first brought online restarts checks for periodic updates or at any other such time. Using information such as an IP address from which the request is received the host classes for the host from which the request is received can be identified such as by making a call into a centralized LDAP database. Using the determined host class identification s the security service can determine the key identifier s for each host class and can send the corresponding secure information for each of the key identifiers to the host .

After the host receives the secure information it can be desirable to update the information as necessary. In one embodiment any change saved to an ACL can cause a request or other communication to be sent to each host of an affected host class that includes the changes applicable to that host. illustrates steps of an example process for pushing out such information in accordance with one embodiment. In this example a new key is determined for a key identifier such as when a security administrator adds or rotates a key for a key identifier. Other changes can also occur such as a new key ring being made available to a host class or a key being no longer available to a host class. The security service or application can determine the relevant host class es affected by the change and can send the new key or other update change or delete information to each of the hosts of the identified host class es . In some embodiments it is desirable to ensure that each host in a host class receives the updated information before activating or relying upon the updated information. Thus the security service can be configured to receive a confirmation from each of the hosts to which the updates were sent . The confirmation can be any appropriate confirmation such as a confirmation message or other such communication. After a confirmation is received from each of the hosts a subsequent message or communication can be sent to each of the hosts indicating that the new key can be set as default or otherwise utilized accordingly . In the meantime hosts can continue to use the current value s .

In some cases the security service can include logic that allows a security administrator to configure a rotation of keys for a given host class at particular times. The rotation can be done automatically and or manually and the system can include logic to help determine when to rotate keys. In some embodiments certain actions can cause keys to be changed automatically such as unauthorized access or other such events. The changing of keys can be transparent to the average user such that no one other than a security administrator or other such person need to even know that a rotation occurred. The change is done behind the scenes in a way that is not only transparent to the user but also to most applications and or services that use the key information. The key identifiers do not change so no change is necessary in the code etc. to adapt to the change. Further no manual intervention is needed in most cases.

Such an approach can be advantageous for environments such as cloud computing for example where additional servers can be added into a group or cluster of servers at any time to provide a specified service or function. In conventional systems each new server requires the passwords for a database service etc. to be entered manually at startup. If each server at startup is instead given at least one host class name then each server can contact the security service to obtain the necessary security information as part of an automatic deployment process. The security service can store the secure information in any appropriate manner such as by using a redundant and or distributed data repository that is able to securely store sensitive material such as encryption keys passwords credentials etc. The security service provides an interface and or application layer on top of this data repository that includes logic to specify and or determine which keys belong to which classes hosts devices users etc. As discussed secure objects such as secure keys passwords or credentials can be used to perform any of a variety of secure functions or security related functions such as encrypting or decrypting content providing secure digital signatures obtaining secure connections accessing secure information and securely storing information.

In some embodiments host classes can be nested and or part of a class hierarchy. For example a host class might include servers of Web pages while a child class might includes servers of Japanese Web pages. Thus a host might be assigned to a host class that actually includes multiple sub classes that are part of that host class. In such a case child class can inherit any appropriate keys from the respective parent class. Such an approach can simplify management of each host reduce the amount of storage needed for key information and reduce the amount of bandwidth and or network traffic needed to distribute updates to the various host classes. Hosts can inherit and or be assigned host class membership in various ways described herein or apparent to one of ordinary skill in the art. Each host in a given class then can automatically receive the same information. Further hosts outside that class do not receive the information and are not able to access the information or resources.

In one embodiment the security service is provided as a service to which outside users can subscribe. For example a user or party might want the service to maintain specific security information. The user or party then might be presented with a special ACL control screen Web interface or other such user interface that allows the user to enter and update the distribution of the secure information. Such a service then can be billed to the user or party in any appropriate manner such as by the amount of secure data stored amount and or type of access bandwidth number of users or hosts or any other appropriate billing approach known or used in the art for subscriptions and or services.

As discussed above the various embodiments can be implemented in a wide variety of operating environments which in some cases can include one or more user computers computing devices or processing devices which can be used to operate any of a number of applications. User or client devices can include any of a number of general purpose personal computers such as desktop or laptop computers running a standard operating system as well as cellular wireless and handheld devices running mobile software and capable of supporting a number of networking and messaging protocols. Such a system also can include a number of workstations running any of a variety of commercially available operating systems and other known applications for purposes such as development and database management. These devices also can include other electronic devices such as dummy terminals thin clients gaming systems and other devices capable of communicating via a network.

Various aspects also can be implemented as part of at least one service or Web service such as may be part of a service oriented architecture. Services such as Web services can communicate using any appropriate type of messaging such as by using messages in extensible markup language XML format and exchanged using an appropriate protocol such as SOAP derived from the Simple Object Access Protocol . Processes provided or executed by such services can be written in any appropriate language such as the Web Services Description Language WSDL . Using a language such as WSDL allows for functionality such as the automated generation of client side code in various SOAP frameworks.

Most embodiments utilize at least one network that would be familiar to those skilled in the art for supporting communications using any of a variety of commercially available protocols such as TCP IP OSI FTP UPnP NFS CIFS and AppleTalk. The network can be for example a local area network a wide area network a virtual private network the Internet an intranet an extranet a public switched telephone network an infrared network a wireless network and any combination thereof.

In embodiments utilizing a Web server the Web server can run any of a variety of server or mid tier applications including HTTP servers FTP servers CGI servers data servers Java servers and business application servers. The server s also may be capable of executing programs or scripts in response requests from user devices such as by executing one or more Web applications that may be implemented as one or more scripts or programs written in any programming language such as Java C C or C or any scripting language such as Perl Python Ruby or TCL as well as combinations thereof. The server s may also include database servers including without limitation those commercially available from Oracle Microsoft Sybase and IBM .

The environment can include a variety of data stores and other memory and storage media as discussed above. These can reside in a variety of locations such as on a storage medium local to and or resident in one or more of the computers or remote from any or all of the computers across the network. In a particular set of embodiments the information may reside in a storage area network SAN familiar to those skilled in the art. Similarly any necessary files for performing the functions attributed to the computers servers or other network devices may be stored locally and or remotely as appropriate. Where a system includes computerized devices each such device can include hardware elements that may be electrically coupled via a bus the elements including for example at least one central processing unit CPU at least one input device e.g. a mouse keyboard controller touch screen or keypad and at least one output device e.g. a display device printer or speaker . Such a system may also include one or more storage devices such as disk drives optical storage devices and solid state storage devices such as random access memory RAM or read only memory ROM as well as removable media devices memory cards flash cards etc.

Such devices also can include a computer readable storage media reader a communications device e.g. a modem a network card wireless or wired an infrared communication device etc. and working memory as described above. The computer readable storage media reader can be connected with or configured to receive a computer readable storage medium representing remote local fixed and or removable storage devices as well as storage media for temporarily and or more permanently containing storing transmitting and retrieving computer readable information. The system and various devices also typically will include a number of software applications modules services or other elements located within at least one working memory device including an operating system and application programs such as a client application or Web browser. It should be appreciated that alternate embodiments may have numerous variations from that described above. For example customized hardware might also be used and or particular elements might be implemented in hardware software including portable software such as applets or both. Further connection to other computing devices such as network input output devices may be employed.

Storage media and computer readable media for containing code or portions of code can include any appropriate media known or used in the art including storage media and communication media such as but not limited to volatile and non volatile removable and non removable media implemented in any method or technology for storage and or transmission of information such as computer readable instructions data structures program modules or other data including RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disk DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by the a system device. Based on the disclosure and teachings provided herein a person of ordinary skill in the art will appreciate other ways and or methods to implement the various embodiments.

The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense. It will however be evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the claims.

