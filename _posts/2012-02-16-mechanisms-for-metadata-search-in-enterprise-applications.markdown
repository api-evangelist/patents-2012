---

title: Mechanisms for metadata search in enterprise applications
abstract: Metadata search is enhanced by utilizing relationship data indicating relationships between metadata items. A server generates an index mapping metadata items to terms associated with the metadata items and a graph describing relationships between each of the metadata items. When the server receives a search request, the server locates a candidate set of the metadata items based on the search term(s) and the index. The server performs a link analysis of the graph to determine a relationship score for each metadata item. For each particular metadata item in the candidate set of the metadata items, the server calculates a ranking score based at least on the relationship score for the particular metadata item. The server generates a ranked result set based on comparing the ranking scores for the candidate set of metadata items. The server then provides information indicating the ranked result set in response to the search request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08700673&OS=08700673&RS=08700673
owner: Oracle International Corporation
number: 08700673
owner_city: Redwood Shores
owner_country: US
publication_date: 20120216
---
This application is related to U.S. patent application Ser. No. 13 398 794 filed Feb. 16 2012 entitled MECHANISMS FOR SEARCHING ENTERPRISE DATA GRAPHS by Raghavan et al. and U.S. patent application Ser. No. 13 398 799 filed on Feb. 16 2012 entitled DISPLAYING RESULTS OF KEYWORD SEARCH OVER ENTERPRISE DATA by Raghavan et al. the entire contents of each of which are hereby incorporated by reference for all purposes as if fully set forth herein.

Embodiments relate generally to data search and more specifically to techniques for enhancing search results for metadata.

The approaches described in this section are approaches that could be pursued but not necessarily approaches that have been previously conceived or pursued. Therefore unless otherwise indicated it should not be assumed that any of the approaches described in this section qualify as prior art merely by virtue of their inclusion in this section.

The data within databases document repositories and other data sources are often structured in accordance with a common underlying format. The common underlying format is typically well understood by general purpose data access components such as database servers or extended markup language XML parsers. Examples of such formats include without limitation relational tables hierarchical trees and XML.

For many of these underlying formats conforming structures may be characterized abstractly as sets of hierarchical nodes. For example in XML and other hierarchical mark up languages nodes are delimited by a pair of corresponding start and end tags which not only delimit the node but also specify the name of the node. For example in the following structured data fragment 5 10 the start tag and the end tag delimit a node having name A. The data between the corresponding tags is referred to as the node s content. A node s content can either be a scalar value e.g. integer text string or one or more other nodes. A node that contains only a scalar value is referred to herein as a scalar node. A node that contains another node is referred to herein as a structured node. The contained nodes are referred to herein as descendant nodes. In addition to containing one or more nodes a structured node s content may also include a scalar value. Such content in a node is referred to herein as mixed content.

A structured node thus forms a hierarchy of nodes with multiple levels the structured node being at the top level. A node at each level is linked to one or more nodes at a different level. Each node at a level below the top level is a child node of a parent node at the level above the child node. Nodes having the same parent are sibling nodes. A parent node may have multiple child nodes. A node that has no parent node linked to it is a root node and a node that has no child nodes linked to it is a leaf node. For example in structured node A node A is the root node at the top level. Nodes B and D are descendant and child nodes of A and with respect to each other nodes B and D are sibling nodes. Nodes B and D are also leaf nodes.

In some embodiments relational tables may be representative of node based structures. For example a node may be represented by rows in one or more tables that share a same unique identifier or key. Attributes may be represented by the values for various fields of those rows. Links may be represented by object identifying values in other columns of those rows. Various other representations may also be used.

Structured data may further be organized in accordance with schemas and or other information that define structural and content constraints for the structured data beyond those constraints inherent in the underlying structure of that data. Even within the same data source different structural and content constraints may apply to data objects such as nodes that have the same abstract structures. For example each row of data in a relational database is already subject to constraints inherent to all relational databases. Yet rows within one table of a database may further conform to schema dictated constraints for data used to represent customers while rows within another table in the same database may instead further conform to schema dictated constraints for data used to represent purchase orders.

The term metadata is used herein to refer to any information including schemas that defines structures and or constraints for structured data. Metadata may comprise one or more units of varying complexity and granularity which are hereinafter referred to as items of metadata or metadata items. Metadata items may comprise reference or embed other metadata items. Each metadata item may be described as a node and each metadata item may be mapped to one or more specific data objects for which it defines constraints. This disclosure may at times refer to a set of metadata items as a collection of metadata metadata collection or simply metadata. 

Metadata serves in one aspect as a blueprint of how data objects are to be constructed. There are many practical applications of metadata including without limitation the validation of data input and the optimization of processes such as data parsing data encoding and data compression. In an embodiment metadata may comprise a set of formulas sentences rules objects or other elements expressed in a formalized language which in turn specify integrity constraints imposed upon one or more data sources.

Metadata may be created explicitly in a variety of manners including importations of comprehensive top down schemas by dedicated data architects or piecemeal input from end users providing decentralized bottom up definitions of individual metadata items. Metadata may further be discovered through analyses processes that utilize pattern matching machine learning and or other techniques to classify data objects. The metadata that describes a given structured data object may be identified using a variety of mechanisms including explicit mappings in the form of markup language or type identifiers internal to the data objects explicit mappings in external tables that map data objects to metadata by references and mappings determined using structure recognition processes.

One example of metadata is enterprise application metadata such as may be used for an extended markup language XML application platform. Enterprise application metadata may be used to describe a model for a variety of types of data including XML and database objects as discussed in the following paragraphs. In an embodiment the enterprise application metadata model comprises metadata items that are collectively defined by at least three constructs elements types and states. Elements provide a name and semantic meaning to a data item whereas types and states provide data validation rules. However in other embodiments the metadata model may comprise additional or fewer constructs. In an embodiment enterprise application metadata is stored in representative form within a database system. For example enterprise application metadata may be represented by tables or objects columns or fields and relationships between tables and columns or links .

Another example of metadata is an XML schema. An XML schema is a description of a type of XML document. In an embodiment an XML schema is expressed in terms of constraints on the structure and content of documents of that type above and beyond the basic syntactical constraints imposed by XML itself. These constraints are generally expressed using some combination of grammatical rules governing the order of elements Boolean predicates that the content must satisfy data types governing the content of elements and attributes and more specialized rules such as uniqueness and referential integrity constraints. In an embodiment an XML Schema is itself comprised of a variety of inter related metadata items including element type declarations attribute declarations entity declarations notation declarations. An XML schema may be expressed in an XML schema language. Specific examples of an XML schema language include without limitation Document Type Definition DTD XML Schema as defined by XML Schema Part 0 Part 1 Part 2 W3C Recommendation 2 May 2001 XML Schema Part 1 Structures Second Edition W3C Recommendation 28 Oct. 2004 XML Schema 1.1 Part 2 Datatypes W3C Working Draft 17 Feb. 2006 and XML Schema Part 2 Datatypes Second Edition W3C Recommendation 28 Oct. 2004 the entire contents of each of which are incorporated herein by reference for all purposes and RELAX NG.

A database schema is yet another example of metadata. A database schema may comprise metadata items that describe any or all of tables fields relationships views indexes packages procedures functions queues triggers types sequences materialized views synonyms database links directories and so forth. The database schema may be stored in for example a data dictionary within the database. Other types of metadata are also within the scope of this disclosure including without limitation Java object models and other object based frameworks.

It is at times desirable to locate specific items of metadata for any of a variety of reasons. To this end in an embodiment specific items of metadata may be located using keyword searches on item names and or descriptions. For example a data administrator may need to identify the structure of a database or even reorganize the database. Or a data administrator may wish to re use pre existing metadata items or link to existing data objects when developing the structure of a new data repository.

In an embodiment metadata is developed in a decentralized manner by a number of end users forming a community. For example a community of scientists or doctors may subscribe and or maintain shared metadata and or data repositories that are accessible via a variety of applications at any number of locations. In such communities many diverse end users may create many types of data objects. Other end users may wish to locate use or even build on top of metadata items already defined by the community. An example of decentralized metadata is described in U.S. application Ser. No. 13 221 832 entitled Validating XML Documents Based on Decentralized Schemas and filed Aug. 31 2011 the entire contents of which are herein incorporated by reference for all purposes.

In the following description for the purposes of explanation numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent however that the present invention may be practiced without these specific details. In other instances well known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.

Approaches techniques and mechanisms are disclosed for enhancing metadata search by utilizing relationship data indicating relationships between metadata items. In an embodiment a server generates an index that maps metadata items to terms associated with the metadata items. The server generates a graph describing relationships between each of the metadata items. When the server receives a search request comprising at least one or more search terms the server locates a candidate set of the metadata items based on the one or more search terms and the index. The server performs a link analysis of the graph to determine a relationship score for each particular metadata item in at least the candidate set of metadata items. For each particular metadata item in the candidate set of the metadata items the server calculates a ranking score based at least on the relationship score for the particular metadata item. The server generates a ranked result set based on comparing the ranking scores for the candidate set of metadata items. The server then provides information that describes the ranked result set in response to the search request.

In an embodiment the server also determines one or more term scores for at least each particular metadata item in the candidate set of metadata items the one or more term scores being based on at least one of the frequency with which the term appears in the particular metadata item or the frequency with which the term appears in all of the metadata items. Calculating the ranking score for each particular metadata item is further based on the one or more term scores for the particular metadata item. In an embodiment for each particular metadata item in the candidate set of the metadata items the server further determines an instance frequency score based at least in part on how many data objects in the data repository conform to the particular metadata item. Calculating the ranking score for each particular metadata item is further based on the instance frequency score for the particular metadata item.

In an embodiment calculating the ranking score for each particular metadata item comprises inputting at least the relationship score for the particular metadata item the one or more term scores for the particular metadata item and or the instance frequency score into a parameterized ranking function. The server may further adjust weights for the parameterized ranking function based on implicit or explicit user feedback data.

In an embodiment the server identifies the relationships described in the graph based on reference data associating certain metadata items with other certain metadata items. In an embodiment the relationships include one or more of child of relationships parent of relationships descendant of relationships or ancestor of relationships. In an embodiment the graph comprises nodes and edges the nodes corresponding to metadata items and the edges corresponding to the relationships wherein at least some of the edges have different weights corresponding to different types of relationships that are represented by the edges.

In an embodiment the relationship score for each particular metadata item is based at least in part on how many of the metadata items depend upon the particular metadata item. In an embodiment the graph is a directed graph wherein the relationship score for each particular metadata item is a function of how many edges lead into the node corresponding to the metadata item.

In an embodiment the server revises the set of one or more search terms prior to locating the candidate metadata items based on or more of a spelling correction engine an auto complete engine or a query reformulation engine.

In an embodiment the techniques are performed in a system comprising a client with a user interface configured to redefine add or otherwise manage the metadata in the data repository. The server receives via this client definition data for a new metadata item that references a first metadata item in the result set. The server adds the new metadata item to the data repository. The server then enforces one or more constraints described by the new metadata item and the first metadata item on a particular data object within the data repository.

In an embodiment a server generates an index that maps metadata items to terms associated with the metadata items. When the server receives a search request comprising at least one or more search terms the server locates a candidate set of the metadata items based on the one or more search terms and the index. For each particular metadata item in the candidate set of the metadata items the server determines an instance frequency score based at least in part on how many data objects in the data repository conform to the particular metadata item. For each particular metadata item in the candidate set of the metadata items the server calculates a ranking score based at least on the instance frequency score for the particular metadata item. The server generates a ranked result set based on comparing the ranking scores for the candidate set of metadata items. The server then provides information describing the ranked result set in response to the search request.

In other aspects the invention encompasses computer apparatuses and a computer readable media configured to carry out the foregoing steps.

Data repository includes data objects and metadata . Data repository may comprise any type s of data source s including without limitation a relational database an XML document collection a multidimensional database flat files and so forth. Data repository may be stored in a central location or distributed amongst multiple locations. Data objects may conform to any of a variety of underlying formats including XML and or relational database objects. Metadata may likewise take any one or more of the forms described elsewhere in this application. In an embodiment data repository is little more than a storage system that communicates conventional data blocks to data server via conventional I O operations. In embodiments data repository may comprise data handling components such as an XML parser or database server.

Data server comprises a search execution component for receiving processing and returning search results to clients . In some embodiments the search execution component may be assisted by an ingestion component graphing component candidate nominating component indexing component link analysis component term analysis component instance frequency analysis component and or ranking component . The varying functions of each of these components are described in subsequent sections. An example information flow for communications between the components is depicted in however many other information flows are also possible. Each of these components may be logically separate and distinct components some or all of these components may be part of the same component and or the functionality performed by these components may be divided amongst other components.

Though not depicted data server may further include a variety of other components. For example data server may include data access components that communicate with data repository via conventional I O operations. Data server may further include components such as an XML parser state machine or database server if appropriate. Data server may further include components such as a web server or application server. For example data server may utilize a web server to respond to search requests from one of clients . Some embodiments may include additional data servers which in turn include their own copies or versions of some or all of the components described above.

Clients may include standalone clients such as web browsers integrated development environments and or other desktop applications executing at end user workstations. Clients may also or instead include middleware applications executing at application servers which may themselves be in communication with end user workstations or other clients . System may include any number of clients and some or all of clients may execute on some of the same computing devices as server .

Clients may issue a variety of data oriented requests to data server including search requests. Depending on the embodiment clients may issue search requests to data server in any of a variety of suitable forms using any of a variety of protocols including HTTP SQL XML and so forth. In an embodiment each of the search requests indicates a search operation that data server is to perform by searching metadata . Clients also receive responses to the search requests from data server in any of variety of suitable forms using any of a variety of protocols. For example a first client may receive a web page containing table formatted search results while another client may receive search results in the form of a ResultSet JSON object XML stream or any other suitable structure.

As a practical matter the use of a computer system in claimed embodiments is required. For example data server may be implemented by one or more computer systems executing collectively as a server. The components thereof may for example be implemented by one or more hardware processors of those one or more computer systems configured to execute instructions for performing the various functions described herein. The techniques described herein should not be construed in any way as being amendable to being performed mentally or manually. Example computer systems that may be used to implement an embodiment include the computer systems described with respect to and the servers configured to execute XAP applications described in U.S. patent application Ser. No. 12 782 591 entitled TYPE SYSTEM FOR BUILDING EXTENSIBLE BUSINESS APPLICATIONS filed on May 18 2010 by Eric Sedlar et al. the contents of which are incorporated herein by reference for all purposes as if set forth in their entirety and referred to hereafter as the XAP patent application.

At block the server reads data structures from a data repository and interprets those structures as a collection of metadata items. The server determines which data structures to read as metadata by searching for tables documents or document collections in or external to the data repository that have been marked as metadata. For example the metadata may be in a designated system table or folder. Or the metadata may be a collection of XML defined within a common namespace. The ingested metadata may be the entire set of metadata for the data repository. Or the read metadata may just be a subset of the available metadata filtered by any of a variety of implicit or explicit search criteria including without limitation permissions identifiers categorical information type data user groups re usability criteria and so forth. The server may utilize for example ingestion component to perform the reading and interpretation. For each metadata item the search execution component extracts constituent contents tags and or links. The reading and extraction may involve for instance an XML parser and or one or more queries.

At block the server builds an index that maps metadata items to terms associated with the metadata items. The server may utilize for example indexing component to perform the indexing. In an embodiment the index is an inverted index in which each term is linked to a set of metadata items. The terms linked to a particular metadata item are selected from the particular metadata item s constituent contents and or tags. In an embodiment the indexed terms are selected only from content associated with certain fields or tags. For example the indexed terms may be selected from content associated with descriptive tags such as user annotations categorical information labels and names. In an embodiment indexed terms may further be selected from certain types of related metadata items.

The index may be built using any suitable indexing technique. For example in one embodiment the metadata items are transformed into a vector of indexable documents and composed into fields and values. Fields can be stored indexed or any combination thereof. To limit the amount of space used by the indexing the number of indexed fields is minimized. The documents are then added to the inverted index.

At block the server generates a graph describing relationships between each of the metadata items. The server may utilize for example a graphing component to generate the graph.

As used herein a graph is a description of a collection of items that has been optimized for the purpose of identifying relationships between those items during a link analysis of the collection. In an embodiment a graph of a collection of metadata item comprises simply a node for each metadata item and for each particular node one or more edges that each identify another node to which the particular node is related. However the graph may comprise additional information as well. For example edges or sets of edges may be associated with a relationship type indicator that indicates the type of relationship that exists between the source and destination nodes.

In an embodiment the graph is stored entirely in memory for fast traversal during a link analysis. However the graph may also or instead be stored in other mediums. The graph may be stored in any suitable structures including without limitation object collections arrays and or hash tables. For example the graph may comprise a top level array indexed to unique identifiers for each metadata item with each particular element of the array comprising a separate second level array listing unique identifiers of the metadata items that are related to the particular metadata item represented by the particular element.

Block may involve identifying the relationships between each metadata item so as to construct the edges of the graph. Depending on the embodiment two metadata items may be identified as related for any of a variety of reasons. In an embodiment a metadata item is identified as being related to another metadata item if the metadata item explicitly links to the other metadata item. For example an XML based metadata item may explicitly reference an identifier of another metadata item in a href attribute XLink or other field. In an embodiment a metadata item is identified as being related to another metadata item if the other metadata item is embedded within inherits from or is a container of the metadata item. In an embodiment a metadata item is identified as being related to another metadata item if the metadata item is a state or type of the other metadata item. In an embodiment a relationship may be discovered by following multiple links. For example if a parent metadata item explicitly references a child metadata item which in turn explicitly references its own child metadata item the parent metadata item may be identified as related to the child s child by dependency even if the parent metadata item does not directly reference the child s child.

In an embodiment each relationship is typed depending on the manner in which it was identified. For example some examples of relationship types include child of parent of descendent of ancestor of state of and type of. Each type is not necessarily weighted equally. For example a Sibling of type may be weighted much lower than a Child of relationship type. Some types of relationships may not be included in the graph at all. In an embodiment all identified relationships are weighted equally and therefore need not necessarily be typed.

In an embodiment only relationships that indicate dependencies are graphed. That is a metadata item is indicated as related to another metadata item only if the definition of that metadata item relies upon the definition of the other metadata item. For example processing rules for a metadata item corresponding to a shipping order may depend upon information in defined for a metadata item corresponding to a shipping address but the inverse may not be true.

In an embodiment the edges in the graph are directional originating from a referencing object to a referenced object. For example a parent metadata item that is required to have a child metadata item would have an edge to the child metadata item but the child metadata item would not have an edge to the parent metadata item. As another example a first metadata item that inherits a definition from second metadata item would have an edge to the second metadata item but the second metadata item would not have an edge to the first metadata item.

At block the server identifies a set of candidate metadata items responsive to the search request. The server or a candidate nominating component thereof utilizes the terms received in block to locate candidate items in the index of block using any suitable information retrieval technique. For example the server may look up each of the terms in the index and add to the set of candidate items those metadata items that are indexed under any of terms. Terms may be single words or sets of words. In an embodiment the search criteria may include conventional search directives to indicate how the terms should be utilized. For instance one or more directives may indicate that only metadata items indexed to each of a certain combination of search terms are considered candidates.

In an embodiment the server may modify the set of terms before looking up candidate items so as to eliminate terms not likely to be of interest add additional terms of potential interest correct spelling errors and so forth. Example modification techniques are as follows.

Search requests are sometimes expressed using terms that are semantically similar to the terms found in the metadata items but nonetheless different. To account for semantic similarity the search request may be reformulated by adding or replacing terms with synonyms hypernyms hyponyms and so forth. In an embodiment the terms may be further reformulated using a tagger implemented as a Hidden Markov Model or a Conditional Random Field trained apriori to provide a part of speech tag to each query term. Desired parts of speech such as nouns or noun phrases may be located by calling into a WordNet index to apply the correct tense based on query expansion to the original terms in the query.

In an embodiment the original terms and the reformulated terms may be used to retrieve two different sets of results. Results retrieved from the expanded query may be down weighted during the ranking of block in comparison to results returned from the original query.

In an embodiment terms for the search request may be automatically passed into a suitable spelling correction engine composed of a dictionary of terms and phrases used in the existing metadata items. Misspelled words may be automatically replaced or proper spellings may be added to the set of search terms. Spelling correction may further rely on the availability of query logs for highly relevant corrections. In the absence of query log information during a system bootstrap a manually curated list of queries may be injected into the query log. For example the list of candidate queries may be the titles of each metadata item. Each of these titles is treated as if it were a real query posed by a real user and injected at system bootstrap time into the spelling dictionary and the query logs. In an embodiment a candidacy test is performed on terms that have been identified as misspelled. If those terms do in fact produce results within the collection of metadata the terms may also be added to the dictionary.

In an embodiment a query log index maintained for spelling correction may be further leveraged for providing suggestions for query completion. Auto completion is an interactive process whereby a list of suggested query completions is continuously refined with each typed keystroke in the search box. If resources are available results may also be provided based on the highest ranking suggestion. Query completions may be used to reduce the amount of typing activity and the rate of misspellings. They also serve as a quick preview into the available concepts or constructs in the metadata.

At block the server performs a link analysis of the graph of block to produce a relationship score for at least each candidate metadata item. The link analysis may be performed by a component such as link analysis component . In an embodiment the link analysis is configured to measure the relative importance of each item in a set of items which in this case is the metadata collection or in some embodiments just the candidate set thereof . Metadata items that are more heavily used or reused within the metadata collection have higher scores than lesser used metadata items. In an embodiment the link analysis involves in part assigning weights to the edges and nodes in the graph with a node s weight being proportional to that node s indegrees. The weights are then used to calculate a score reflecting the relative importance of each node.

Any technique or combination of techniques that return a numerical score for items based on a graph may be utilized for the link analysis. Examples of algorithms for link analysis include without limitation Hyperlink Induced Topic Search PageRank CheiRank TrustRank and variations thereof. For example in an embodiment scores are calculated by executing an iterative or algebraic PageRank algorithm such as described in L. Page S. Brin R. Motwani and T. Winograd. The PageRank citation ranking Bringing order to the web. Stanford Digital Libraries Working Paper 1998 the entire contents of which are hereby incorporated by reference for all purposes as if set forth herein.

At block the server generates one or more term scores for each of the candidate metadata items. The term scoring which may be performed for instance by term analysis component may involve any suitable term based scoring technique that generates one or more scores for each particular metadata item based at least on the search terms and the particular item. For example the server may assign term frequency scores for each term based on how many times each term appears in the metadata item. The scores are optionally weighted and then combined to produce a final term score for the metadata item. In an embodiment the final term score may be a function of an inverse document frequency score for each term which may or may not have been determined in advance. The inverse document frequency indicates the uniqueness of the term in the metadata collection or the likelihood that it will appear in a given metadata item. In an embodiment the term score for each particular metadata item is a vector space scoring based on the term frequency score and the inverse document frequency score for each term.

At block the server generates an instance frequency score for each of the candidate metadata items. The server may generate this score for instance using instance frequency analysis component .

The instance frequency score for each particular metadata item reflects the number of data objects within a certain data set that are instances of the particular metadata item. In other words the instance frequency score reflects the number of data objects in a data repository to which the constraints imposed by a particular metadata item apply. The score may be an exact number of data objects or the score may be a function of the number of data objects. The score may reflect the number of data objects within an entire data repository or a more limited set of data objects such as data objects belong to a particular user group or created within a certain time period. Additionally the score may be a function of time based and other optimizing factors such as how recently each data object instance of the particular metadata item was accessed or created.

At block the server utilizes some or all of the various scores calculated in blocks to calculate a ranking score for each candidate metadata item. The server may utilize for instance ranking component to calculate the ranking. Any suitable ranking technique may be utilized. For example the final ranking score may simply be a total of each score in blocks .

In an embodiment each score of block is weighted as part of a parameterized ranking function. For instance the relationship score for a metadata item may contribute more or less significantly to the ranking score than the term based score. In an embodiment the ranking score is S n Lambda V n 1 Lambda P n where S n is the combination score of an item or node n V n is a vector space score of n P n is a relationship score of n and Lambda is a combination co efficient that essentially weights V n and P n . The combination score could either be additive of multiplicative.

In an embodiment weights are assigned by an expert and modified throughout deployment as needed. In an embodiment the weights are learned and or relearned using any suitable machine learning mechanism including without limitation linear regression algorithms gradient descent algorithms expectation maximization algorithms and or Dynamic Bayesian Networks. The machine learning mechanisms may utilize for instance logs of search requests and corresponding click through data for search results.

In an embodiment additional scores reflecting other relevance signals may also be incorporated into the ranking function.

At block the server generates a final result for the search request and provides data indicating each metadata item in the result set to the user. The server may do so for instance by comparing the ranking scores for each candidate metadata item. The candidate metadata items are sorted by their ranking scores and returned as the final result. In an embodiment the final result may comprise less than the number of candidate items. For example candidate metadata items below a pre defined threshold score may be pruned. As another example only a top predefined number of candidate metadata items may be returned.

The result set may be returned in a variety of forms including XML tables web pages and so forth. In an embodiment the result set is returned in a web page comprising a name and description of each metadata item in the result set and further featuring controls for performing various actions with each metadata item such as locating data object instances of the metadata item or seeing an XML representation of the metadata item. In an embodiment the result set is returned as a list of metadata item identifiers by which a client may look up and retrieve any information necessary to generate its own display of information about the metadata items in the result set.

Flow is but one example of a flow for executing searches using the described techniques. Other flows may feature fewer or additional elements in varying orders. For example some flows may omit the calculation of any of the scores determined in blocks . Generation of a graph that is separate from the metadata itself may also be optional in embodiments that omit the link analysis or perform the link analysis by traversing references in the metadata collection directly. As another example some or all of blocks and may be performed at any time relative to the search request. For instance the server may execute background processes for building indices and graphs in advance of the search request and then cache the index and graph for use in any number of search results. The indices and graphs may be updated or rebuilt periodically or in response to trigger events such as significant changes to the metadata. Depending on the resources available to the server blocks and even portions of block may also be performed in advance for quicker search request response time. Other variations may include without limitation calculating multiple different relationship scores or instance frequency scores for each metadata item.

In an embodiment other search criteria received in the initial search request may also affect the search. For example the initial search request may specify constraints on the metadata that is searched additional ranking factors sort orders and so forth.

For example node labeled Demo.Address is indicated by the directional arrow of edge to have a Parent of relationship with node labeled Demo.City and is accordingly dependent upon node . Similarly node labeled Eastwood. Address is indicated by the directional arrow of edge to be a Parent of node and is accordingly also dependent upon node . As another example node labeled Demo.EUAddress is indicated by the directional arrow of edge to have an Inherits From relationship with node labeled Demo.Address and is accordingly dependent upon node .

In an embodiment a simple link analysis of graph would produce a relationship score for each node that is equal to the number of edges that are directed into the node. For instance Demo.Address node has four edges and that are directed into it. Demo.Address node would thus have a relationship score of 4. Meanwhile Eastwood.Address node would only have a relationship score of 1 since only node is directed into it. All other factors being equal then a search for the term address would return Demo.Address node ahead of Eastwood.Address node .

In other embodiments more complex link analyses would produce different relationship scores for each node. For instance in an embodiment each node begins with an equal relationship score and the link analysis involves iteratively transferring a portion of each node s relationship score to all nodes that the node transitions into. In an embodiment the relationship score for each node is also a function of weights assigned to the different types of edges leading into the node.

According at an embodiment metadata for a repository such as data repository may be specified using an XML syntax set forth within a namespace known as XAP as discussed in the XAP patent application. The XAP syntax comprises three main constructs an element construct a type construct and a state construct. As an example the metadata item corresponding to the Demo.Address node of graph depicted in may be an element construct described by the following XML 

Among other aspects the various tags attributes and contents of the above description provide the Address metadata item with a name address namespace http xap.oracle.com demo and a description A address has the following fields addressline city state zipcode . The xap defaultType tag further provides a type definition of the internal structure to expect by default from any data object conforming to this metadata item. In this particular case the type definition is provided by way of an xap href attribute which is a reference to type construct having an internal identifier of B3. The type construct B3 is therefore said to have a Type Of relationship with the element construct set forth above.

The above XML description provides a variety of information similar in nature to that set forth in the element construct for the Address metadata item. Of further interest the xap elementRef tag may be used to provide backwards relationship information by which element constructs that refer to the type construct may be located. The xap defaultState tag further provides a description of a default state for constraints that should be applied to any data object conforming to the type construct. The state definition is provided by way of reference to a state construct having an XAP identifier of BA. A State Of relationship is therefore established between the B3 type construct and the BA state construct.

The above XML description provides a variety of information similar in nature to that set forth in the previous element and type constructs. Of further interest the xap constraint tag is used four times to specify constraints for data objects when in the state specified by the BA construct. In particular four xap subelement constraints are defined describing children nodes that are to exist when the data object is in the state specified by the BA construct. The children nodes are described by references to yet other element constructs thereby establishing Subelement of relationships between the BA state construct and each of the other element constructs.

The required child nodes of data objects that conform to the Address metadata item while in the default type and state may be described by the following XML representations 

The above XML sets forth definitions for the metadata items AddressLine Element City Element State Element and Zipcode Element corresponding to nodes of graph . These elements are scalar data type elements subject to the constraints imposed by yet another metadata item having the XAP identifier of 82 which is not described herein but corresponds to simple strings.

An XML representation of a single data object that conforms to the constraints set forth by the above metadata items is as follows 

An XML parser would recognize that the above data object is to conform to the above metadata using the reference to the namespace set forth by the xmlns demo attribute of demo address and the reference to specific element construct definitions set forth by each tag s name.

In an embodiment some or all of the information in the above XML definitions of metadata items may be subject to a indexing per the techniques described herein. In an embodiment only description name and label may be indexed. In an embodiment a search is only performed on element constructs and thus only element constructs are indexed. Relationships between element constructs such as Child of Descendent of and Parent of may be derived from following references from one element construct to another element construct. However metatdata searching need not be limited to any particular type of construct or any particular type of relationship.

The above example is but one way that data and metadata may be represented. A variety of other representations are also possible including other XML based representations. Other kinds of relationships and constraints may also be defined using any suitable technique.

Depending on the embodiment a user may perform any of a variety of actions with search results displayed by a client. For example in an embodiment a user may drag and drop any of the metadata items depicted in search results into an adjacent graphical metadata builder. The user may then construct new metadata items which are added to the data repository.

In an embodiment selecting a particular search result instructs the client to display additional information about the metadata item represented by the particular search result and or provide interface controls for performing additional actions related to the metadata item represented by the particular search result. For example is a screenshot of an information pane that is displayed upon a user selecting search result from search interface according to an embodiment. Information pane displays the following information about the demo.Address metadata item a name complete namespace description default display name namespace prefix data type child columns including subelements and referencing elements . Items may be made directly editable. The search interface may be configured to perform additional actions upon selection of any of the items. For example a user may click on name to obtain access to source XML for the Address metadata item. A user may access information panes for subelements of the Address metadata item by clicking on any of items . Button further allows the user to create a new metadata item that references the demo.Address metadata item.

The sub object depicted in row is itself comprised of among other elements a collection of Address sub objects. The collection is viewable in the Address grid . Address grid comprises a row having an address object corresponding to the employee depicted in row . The address object corresponds to the previously depicted demo.Address metadata item. Consequently the address object comprises among other elements data values for the subelements required by the demo.Address metadata item.

As is seen from the above example metadata items that utilize as part of their definition references to other metadata items provide for tremendous flexibility and re usability. For example each of the above described metadata items may be referenced by other metadata items so that metadata items such as address or city do not need to be redefined for every construct in which they are used. Among other advantages of the searching techniques described herein is the ability to more conveniently locate such metadata items so that they may be re used re defined or otherwise utilized. Many other benefits are also realized.

According to one embodiment the techniques described herein are implemented by one or more special purpose computing devices. The special purpose computing devices may be hard wired to perform the techniques or may include digital electronic devices such as one or more application specific integrated circuits ASICs or field programmable gate arrays FPGAs that are persistently programmed to perform the techniques or may include one or more general purpose hardware processors programmed to perform the techniques pursuant to program instructions in firmware memory other storage or a combination. Such special purpose computing devices may also combine custom hard wired logic ASICs or FPGAs with custom programming to accomplish the techniques. The special purpose computing devices may be desktop computer systems portable computer systems handheld devices networking devices or any other device that incorporates hard wired and or program logic to implement the techniques.

For example is a block diagram that illustrates a computer system upon which an embodiment of the invention may be implemented. Computer system includes a bus or other communication mechanism for communicating information and a hardware processor coupled with bus for processing information. Hardware processor may be for example a general purpose microprocessor.

Computer system also includes a main memory such as a random access memory RAM or other dynamic storage device coupled to bus for storing information and instructions to be executed by processor . Main memory also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor . Such instructions when stored in non transitory storage media accessible to processor render computer system into a special purpose machine that is customized to perform the operations specified in the instructions.

Computer system further includes a read only memory ROM or other static storage device coupled to bus for storing static information and instructions for processor . A storage device such as a magnetic disk or optical disk is provided and coupled to bus for storing information and instructions.

Computer system may be coupled via bus to a display such as a cathode ray tube CRT for displaying information to a computer user. An input device including alphanumeric and other keys is coupled to bus for communicating information and command selections to processor . Another type of user input device is cursor control such as a mouse a trackball or cursor direction keys for communicating direction information and command selections to processor and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes a first axis e.g. x and a second axis e.g. y that allows the device to specify positions in a plane.

Computer system may implement the techniques described herein using customized hard wired logic one or more ASICs or FPGAs firmware and or program logic which in combination with the computer system causes or programs computer system to be a special purpose machine. According to one embodiment the techniques herein are performed by computer system in response to processor executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory from another storage medium such as storage device . Execution of the sequences of instructions contained in main memory causes processor to perform the process steps described herein. In alternative embodiments hard wired circuitry may be used in place of or in combination with software instructions.

The term storage media as used herein refers to any non transitory media that store data and or instructions that cause a machine to operation in a specific fashion. Such storage media may comprise non volatile media and or volatile media. Non volatile media includes for example optical or magnetic disks such as storage device . Volatile media includes dynamic memory such as main memory . Common forms of storage media include for example a floppy disk a flexible disk hard disk solid state drive magnetic tape or any other magnetic data storage medium a CD ROM any other optical data storage medium any physical medium with patterns of holes a RAM a PROM and EPROM a FLASH EPROM NVRAM any other memory chip or cartridge.

Storage media is distinct from but may be used in conjunction with transmission media. Transmission media participates in transferring information between storage media. For example transmission media includes coaxial cables copper wire and fiber optics including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves such as those generated during radio wave and infra red data communications.

Various forms of media may be involved in carrying one or more sequences of one or more instructions to processor for execution. For example the instructions may initially be carried on a magnetic disk or solid state drive of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system can receive the data on the telephone line and use an infra red transmitter to convert the data to an infra red signal. An infra red detector can receive the data carried in the infra red signal and appropriate circuitry can place the data on bus . Bus carries the data to main memory from which processor retrieves and executes the instructions. The instructions received by main memory may optionally be stored on storage device either before or after execution by processor .

Computer system also includes a communication interface coupled to bus . Communication interface provides a two way data communication coupling to a network link that is connected to a local network . For example communication interface may be an integrated services digital network ISDN card cable modem satellite modem or a modem to provide a data communication connection to a corresponding type of telephone line. As another example communication interface may be a local area network LAN card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation communication interface sends and receives electrical electromagnetic or optical signals that carry digital data streams representing various types of information.

Network link typically provides data communication through one or more networks to other data devices. For example network link may provide a connection through local network to a host computer or to data equipment operated by an Internet Service Provider ISP . ISP in turn provides data communication services through the world wide packet data communication network now commonly referred to as the Internet . Local network and Internet both use electrical electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link and through communication interface which carry the digital data to and from computer system are example forms of transmission media.

Computer system can send messages and receive data including program code through the network s network link and communication interface . In the Internet example a server might transmit a requested code for an application program through Internet ISP local network and communication interface .

The received code may be executed by processor as it is received and or stored in storage device or other non volatile storage for later execution.

In the foregoing specification embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus the sole and exclusive indicator of what is the invention and is intended by the applicants to be the invention is the set of claims that issue from this application in the specific form in which such claims issue including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence no limitation element property feature advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are accordingly to be regarded in an illustrative rather than a restrictive sense.

