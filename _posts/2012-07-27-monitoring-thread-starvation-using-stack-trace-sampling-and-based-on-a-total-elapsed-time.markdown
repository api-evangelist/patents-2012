---

title: Monitoring thread starvation using stack trace sampling and based on a total elapsed time
abstract: The present disclosure includes methods and systems for monitoring thread starvation. A number of embodiments include determining an amount of time a thread is not runnable, determining an amount of CPU consumption time for the thread, and determining an amount of thread starvation time based on the amount of time the thread is not runnable and the amount of CPU consumption time for the thread.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158651&OS=09158651&RS=09158651
owner: Hewlett-Packard Development Company, L.P.
number: 09158651
owner_city: Houston
owner_country: US
publication_date: 20120727
---
Applications can use multiple threads to handle the workload on a server. There can be hundreds or thousands of active threads on a server which can attempt to use more central processing unit CPU resources than are available to operate at a given time. When a thread is runnable but not able to be run thread starvation occurs. Thread starvation can occur when a thread is temporarily incapable of making progress due to a temporary lack of necessary resources such as CPU resources for example.

In some examples applications can use a number of threads to handle the workload received by a number of users on a network. The number of active threads associated with a number of applications can be dependent on the type of application and the workload on the applications. In some examples there can be hundreds or thousands of active threads on applications and the number of active threads can cause thread starvation. Thread starvation can occur when the available CPU resources cannot handle the number of active threads simultaneously. Another cause of thread starvation can be inefficient and or incorrect thread scheduling due to the language specific runtime systems and the operating system OS kernel sharing thread scheduling responsibilities. Also virtualization such as in cloud computing for example can cause thread starvation due to applications scheduling threads on emulated CPUs while the threads are scheduled and run on actual CPUs.

Previous approaches of monitoring thread starvation included attempting to find a cause of thread starvation after a performance issue caused by thread starvation had been detected. Thread starvation detection included monitoring CPU consumption for saturation and or near saturation conditions.

In a number of embodiments thread starvation can be monitored by determining the amount of time a thread is not runnable and the amount of CPU consumption time for the thread. The amount of time a thread is not runnable and the amount of CPU consumption time for the thread can be subtracted from a total elapsed time in a particular time period to determine the amount of thread starvation for the thread.

The present disclosure includes methods and systems for monitoring thread starvation. A number of embodiments include determining an amount of time a thread is not runnable determining an amount of CPU consumption time for the thread and determining an amount of thread starvation time based on the amount of time the thread is not runnable and the amount of CPU consumption time for the thread.

In a number of embodiments of the present disclosure the amount of time a thread is not runnable can be determined by instrumentation to detect when the thread is blocked on a lock and by stack trace sampling to estimate the amount of time the thread state has caused the thread to be not runnable.

In the following detailed description of the present disclosure reference is made to the accompanying drawings that form a part hereof and in which is shown by way of illustration how examples of the disclosure can be practiced. These examples are described in sufficient detail to enable those of ordinary skill in the art to practice the examples of this disclosure and it is to be understood that other examples can be utilized and that process electrical and or structural changes can be made without departing from the scope of the present disclosure.

The figures herein follow a numbering convention in which the first digit corresponds to the drawing figure number and the remaining digits identify an element or component in the drawing. Elements shown in the various figures herein can be added exchanged and or eliminated so as to provide a number of additional examples of the present disclosure. In addition the proportion and the relative scale of the elements provided in the figures are intended to illustrate the examples of the present disclosure and should not be taken in a limiting sense.

In some examples a thread can be determined to be not runnable when the thread is in a thread lock. Instrumentation can be provided to determine when a thread is in a thread lock. The instrumentation can be used to monitor and report when the thread is not runnable due to being in a thread lock.

In some examples a thread can be determined to be not runnable when thread stack sampling determines that the thread state caused the thread to be not runnable. Thread stack sampling can periodically determine thread state for the thread and these determinations can be used to estimate the time the thread was not runnable due its thread state. Also missing samples during thread stack sampling can indicate that the thread was runnable and possibly starving. Therefore missing samples during thread stack sampling can be used to estimate the amount of time the thread was not runnable.

At an amount of CPU consumption time for thread is determined. A thread can be in a starving state when it is runnable but not running. Therefore during a particular time period determining CPU consumption time e.g. the time that the thread was running for the thread can be used as part of determining thread starvation e.g. when a thread is runnable but not running.

In some examples an amount CPU consumption time for a thread can be determined from the runtime environment such as the OS and or a Java virtual machine for example. A Java application programming interface API can be used to monitor and report the amount of CPU consumption time for a thread.

At an amount of thread starvation time is determined based on the amount of time the thread is not runnable and the amount of CPU consumption time for the thread. The amount of thread starvation can be determined by subtracting the amount to time a thread is not runnable and the amount of CPU consumption time for a thread over a particular time period from the total elapsed time of the particular time period.

In some examples threads can be monitored continuously for thread starvation while a calculation of the amount of thread starvation can be for a particular time period. For example a calculation of thread starvation can be for a 1 second time period that thread was being monitored to determine the amount of thread starvation during the 1 second time period.

In some examples a calculation to determine the amount of thread starvation can use the amount of time the thread was not runnable. Instrumentation can be used to determine that the thread was not runnable for 150 milliseconds ms due being in a lock during a 1 second time period. The determination that the thread was in a lock and not runnable for 150 ms can be used in a calculation of the amount of thread starvation. Stack trace sampling can be used estimate that the thread was not runnable for 200 ms due to the thread being in a thread state that was not runnable during the 1 second time period. Also the process of stack trace sampling can be missing samples that are used to estimate the thread was not runnable for 50 ms during the 1 second time period. The estimate that the thread was not runnable for 250 ms using stack trace sampling can be used in a calculation of the amount of thread starvation.

In some examples a calculation to determine the amount of thread starvation can use the amount of CPU consumption time for the thread. A Java API can be used to determine that the thread used 100 ms of CPU consumption time during the 1 second time period. The determination that the thread used 100 ms of CPU consumption time can be used in a calculation of the amount of thread starvation.

In some examples a calculation to determine the amount of thread starvation can include subtracting the amount of time the thread was not runnable and the amount of CPU consumption time from a particular time period. For example the particular time period can be the 1 second time period. The calculation to determine the amount of thread starvation during the 1 second time period can include subtracting the 150 ms that the thread was not runnable due to being in a lock the 250 ms that the thread was estimated to be not runnable using stack trace sampling and the 100 ms of CPU consumption time from the 1 second time period. This calculation results in the amount of thread starvation during the 1 second time period to be 500 ms. The amount of thread starvation can also be reported as a percentage where thread starvation is 50 during the 1 second time period.

In some examples thread starvation can be reported to a user. Thread starvation reports can include the amount of thread starvation of a number of threads over a particular period of time that is of interest to the user based on a request from the user. For example a user may request the amount of thread starvation of a number of threads from 1 pm to 2 pm on Apr. 15 2012. Also thread starvation reports can sent to a user at period intervals that report the amount of thread starvation in the time since the previous thread starvation report was sent to a user. For example a thread report can be sent to a user every 5 minutes that includes the amount of thread starvation of a number of threads during the previous 5 minutes. In some examples thread starvation can be continuously monitored and reported to a user.

In some examples the amount of not runnable time for a thread can include the amount of time the thread is in a lock as determined by thread lock detection and the amount of time the thread is in a not runnable thread state as determined by stack trace sampling .

Thread lock detection can include instrumentation to determine monitor and or report when the thread is not runnable due to being in a thread lock. Thread lock detection can detect an entry event into a lock e.g. lock acquisition attempt and an exit event out of a lock e.g. actual lock acquisition to determine the amount of not runnable time a thread spend in the lock.

Stack trace sampling can include sampling each thread to determine the thread state such as runnable and or not runnable of each thread at periodic intervals. Stack trace sampling can determine if the thread is in a blocked state that is causing the thread to be not runnable by reading only the top most stack frame of each thread therefore the stack frames below the topmost stack frame do not need be read during stack trace sampling The top most stack trace frame represents the currently executing Java method and since the set of Java APIs causing the thread to block is known the currently executing method name e.g. corresponding to an input output IO operation can be used to determine thread state. Stack trace sampling can sample thread state at periodic intervals such as once every 100 ms for example. Stack trace sampling can include estimating the amount of time the thread is not runnable during a particular time period based on the samples that indicate the thread state.

The computing device can be a combination of hardware and program instructions configured to perform a number of functions. The hardware for example can include one or more processing resources computer readable medium CRM memory resource etc. The program instructions e.g. computer readable instructions CRI can include instructions stored on the CRM to implement a desired function e.g. determine thread starvation.

The processing resources can be in communication with the tangible non transitory CRM storing the set of CRI executable by one or more of the processing resources as described herein. The CRI can also be stored in remote memory managed by a server and represent an installation package that can be downloaded installed and executed. The computing device can include memory resources and the processing resource can be coupled to the memory resource .

Processing resource can execute CRI that can be stored on internal or external non transitory CRM . The processing resource can execute CRI to perform various functions including the functions described with respect to and among others.

The number of modules and can include CRI that when executed by the processing resource can perform a number of functions. The number of modules and can be sub modules of other modules. For example a lock detection module and a sampling module can be sub modules and or contained within a single module. Furthermore the number of modules and can comprise individual modules separate and distinct from one another.

A lock detection module can comprise CRI and can be executed by the processing resource to detect a thread entering and exiting a lock. The lock detection module can detect and report the amount of time the thread was not runnable due to being in a lock by detecting when a thread enters and exits a lock. The lock detection modules can implement lock detection using instrumentation at the process level.

A sampling module can comprise CRI and can be executed by the processing resource to sample a thread at periodic intervals to determine the thread state. The thread state that is determined by sampling the thread at periodic intervals can be used to estimate the amount of time a thread is not runnable due to its thread state.

A CPU consumption module can comprise CRI and can be executed by the processing resource to determine an amount CPU consumption time for a thread. The amount of CPU consumption time for a thread can be determined from the runtime environment such as the OS and or a Java virtual machine for example. The Java API can be used to monitor and report the amount of CPU consumption time for a thread.

A starvation module can comprise CRI and can be executed by the processing resource to determine the amount of thread starvation for a thread. The amount of thread starvation can be determined by subtracting the amount of time a thread is not runnable and the amount of CPU consumption time for a thread over a particular time period from the total elapsed time of the particular time period.

A reporting module can comprise CRI and can be executed by the processing resource to report the amount of thread starvation for a thread. The amount of thread starvation for each thread of a number of threads can be reported as a unit of time and or as a percentage of time. The reporting module can also report information such as the time day month and year that thread starvation occurred.

A non transitory CRM as used herein can include volatile and or non volatile memory. Volatile memory can include memory that depends upon power to store information such as various types of dynamic random access memory DRAM among others. Non volatile memory can include memory that does not depend upon power to store information. Examples of non volatile memory can include solid state media such as flash memory electrically erasable programmable read only memory EEPROM phase change random access memory PCRAM magnetic memory such as a hard disk tape drives floppy disk and or tape memory optical discs digital versatile discs DVD Blu ray discs BD compact discs CD and or a solid state drive SSD etc. as well as other types of computer readable media.

The non transitory CRM can be integral or communicatively coupled to a computing device in a wired and or wireless manner. For example the non transitory CRM can be an internal memory a portable memory and a portable disk or a memory associated with another computing resource e.g. enabling CRIs to be transferred and or executed across a network such as the Internet.

The CRM can be in communication with the processing resource via a communication path . The communication path can be local or remote to a machine e.g. a computer associated with the processing resource . Examples of a local communication path can include an electronic bus internal to a machine e.g. a computer where the CRM is one of volatile non volatile fixed and or removable storage medium in communication with the processing resource via the electronic bus. Examples of such electronic buses can include Industry Standard Architecture ISA Peripheral Component Interconnect PCI Advanced Technology Attachment ATA Small Computer System Interface SCSI Universal Serial Bus USB among other types of electronic buses and variants thereof.

The communication path can be such that the CRM is remote from a processing resource e.g. processing resource such as in a network connection between the CRM and the processing resource e.g. processing resource . That is the communication path can be a network connection. Examples of such a network connection can include local area network LAN wide area network WAN personal area network PAN and the Internet among others. In such examples the CRM can be associated with a first computing device and the processing resource can be associated with a second computing device e.g. a Java server. For example a processing resource can be in communication with a CRM wherein the CRM includes a set of instructions and wherein the processing resource is designed to carry out the set of instructions.

As used herein logic is an alternative or additional processing resource to perform a particular action and or function etc. described herein which includes hardware e.g. various forms of transistor logic application specific integrated circuits ASICs etc. as opposed to computer executable instructions e.g. software firmware etc. stored in memory and executable by a processor.

As used herein a or a number of something can refer to one or more such things. For example a number of widgets can refer to one or more widgets.

The above specification examples and data provide a description of the method and applications and use of the system and method of the present disclosure. Since many examples can be made without departing from the spirit and scope of the system and method of the present disclosure this specification merely sets forth some of the many possible embodiment configurations and implementations.

