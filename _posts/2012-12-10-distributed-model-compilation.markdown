---

title: Distributed model compilation
abstract: Methods and systems are provided for partitioning and distributing the model processing of a graphical model to provide an executable form of the graphical model. The methods and systems determine tasks of the model processing that can be processed separately and concurrently from other tasks. A distribution scheme for distributing the model processing tasks is determined that considers the characteristics of the model processing tasks in view of the characteristics of available computing resources. Variations of partitioning and distributing the model processing tasks can be determined to provide for distributed processing in an optimized or desired manner. The results of the distributed processing of the model processing tasks are obtained and combined to provide an executable form for the graphical model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09195445&OS=09195445&RS=09195445
owner: The MathWorks, Inc.
number: 09195445
owner_city: Natick
owner_country: US
publication_date: 20121210
---
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention generally relates to technical computing and more particularly to distributed model compilation of a graphical model.

Various types of graphical models and methods are used extensively in the modeling of computations algorithms and operations that can be performed on computational hardware devices such as a computer microcontroller FPGA and custom hardware. Graphical modeling can be used for the design analysis code generation and synthesis and testing of many systems including dynamic and engineered systems. Types of such graphical models include time based block diagrams such as those found within Simulink from The MathWorks Inc. of Natick Mass. state based and flow diagrams such as those found within Stateflow from The MathWorks Inc. of Natick Mass. data flow diagrams circuit diagrams and software diagrams such as those found in the Unified Modeling Language. A common characteristic among these various forms of graphical models is that they define semantics on how to execute the graphical model. For example a block diagram model provided by Simulink can be processed via a model compilation process to convert the model into an executable form. The executable form of the block diagram model can then be executed to simulate the model over a span of time. The simulation uses information provided by the system s representation in the block diagram model to simulate the system behavior of the model.

Graphical models can be used to solve complex engineering and scientific problems by developing mathematical models that simulate the problem. Graphical modeling environments can provide an extensive set of building blocks that represent mathematical operations logic constructs and other specific modeling and design tasks for modeling simulating and testing a wide range of dynamic systems. A model is prototyped tested and analyzed by running the model under multiple boundary conditions data parameters or just a number of initial guesses. Many engineering and scientific problems require larger and more complex modeling. For example graphical modeling may be used to model design and simulate the many systems integrated into an aircraft or automobile. With the types of problems that can be modeled and simulated in a graphical modeling environment graphical models have reached a remarkable level of complexity and so has the simulation of such models.

Graphical models such as a block diagram model can be hierarchical and reference and organize a multitude of graphical models each representing an additional system. In turn these referenced graphical models may also be large or complex and also may reference additional graphical models. In this manner a top view of a hierarchical block diagram model can provide a high level view of the system with one or more blocks of this top view each representing a sub system block diagram model. One can drill down into the subsystem view from the top level to view the details of this sub system model. The block diagram model of the sub system can also include a multitude of blocks and in turn some of these blocks may represent additional block diagram models and details of further sub systems. As such a hierarchical model may be constructed with hundreds or more block diagram models in a multitude of levels with hundreds of thousands of blocks representing primitive and aggregate computations algorithms and operations.

In the design of graphical models partitioning of the model and design tasks may be necessary considering the design and development of the overall system on a large project is beyond the capability of a single designer or engineer. Partitioning of the design tasks allows multiple engineers and designers or groups or teams of engineers and designers to work on portions of the system design. This can be facilitated through partitioning of the system graphical model into a hierarchy of multiple models representing portions or sub systems of the overall system. Each sub system model may be considered to be a unit model that may be independent of or dependent on other unit models. Each engineer or teams of engineers can focus on the design of one or more of these unit models. The overall system model then includes the combination and integration of all the unit models to form the overall system model.

With respect to design the partitioning of models in a hierarchical manner facilitates teams of engineers to design complex models that may have hundreds of thousands of blocks. However the overall graphical model needs to come together as a whole to be compiled into an executable form for execution of the entire system. Execution is used to determine and test the behavior of the system as designed by the aggregate of the graphical models. The compilation of a model with hundreds of thousands of blocks can be a task of significant size and complexity. As the size and complexity of the model increases the model compilation process also becomes more resource intensive and time consuming. The time and resources needed to compile a large or complex model is further compounded by the fact that execution and modeling is intended to be an interactive and iterative process. A graphical model is processed into an executable form for execution to learn and discover the system behavior of the designed model. Through execution the designed model may be changed or refined to obtain the desired system behavior. As such the design model is updated and the model compiled for execution repeatedly until reaching a desired solution. The benefit of the interactive and iterative nature between modeling and execution is reduced as the time to compile a model for execution increases.

Graphical models can also contain non graphical language such as executable instructions for a programming language. For example a block diagram model in Simulink can include instructions in the technical computing programming language of MATLAB . Typically these graphical models are compiled or converted into an executable form in a sequential manner on a single computer. That is a hierarchical graphical model is compiled into an executable form by compiling each of the unit models subsequently one at a time on the same computer. The compilation process completes when the last unit model has completed its compilation process. Additionally a single computer can be limiting to the size of the problem that can be solved because of the relationship of the computing power of the computer to the computing power necessary to execute computing intensive iterative processing of complex problems in a reasonable time such as compiling a large or complex model. With model compilation becoming a computing and time intensive task that may not be completed in a reasonable amount of time on a single computer a solution to decrease the time for model loading compilation simulation and code generation is desired.

The present invention provides systems and methods for partitioning the model compilation of a graphical model such as a block diagram model to distribute the processing of the tasks of the model compilation. The model compilation process provides an executable form of the graphical model that may be used for simulating and testing the design of the graphical model. The model compilation may be partitioned into tasks that can be performed concurrently on sections of the graphical model and separately and concurrently on the same computer or on different computers. The tasks can then be distributed to one or more computers for processing. The results from the distributed processing of the tasks are obtained and combined to produce an executable form of the graphical model. In this manner the model compilation process of graphical models can be distributed to facilitate decreasing the time to form an executable of the graphical model for simulation and testing. For example the model compilation of a large or complex graphical model may be broken down into model processing tasks the tasks distributed for processing across multiple computers and task results combined to provide an executable form for execution of the graphical model.

The present invention determines from a graphical model the portions of a model compilation that can be processed separately and or concurrently from other portions to compile the model into executable form. In one embodiment a graphical view of the model compilation process can show a representation of separate and concurrent paths of model compilation processing that may occur. In another embodiment the paths of model compilation may be evaluated to estimate model processing complexity of processing each path. This information may be used to determine a distribution scheme for distributing the processing of these portions in a desired manner.

Additionally some embodiments of the present invention determine the availability and characteristics of computing resources that may be available on a network to perform model compilation processing on portions of the model. For example computers with the lowest load and highest processing power may be identified. By comparing the processing characteristics of the model compilation paths to the characteristics of the available computing resources another embodiment of the present invention determines a distribution scheme for processing the model compilation in a distributed and desired manner. Furthermore in some embodiments of the present invention the results of each distributed portion of model compilation may be obtained and combined to provide an executable form of the graphical model representing the aggregate of all the portions.

In summary the distributed model processing of the present invention produces an executable form that can execute a simulation of the graphical model in a similar manner as an executable form that may be provided by a non distributed model compilation of the same graphical model. However the present invention can leverage additional computing resources and concurrent execution of portions of the model compilation process to facilitate reducing the time for model loading compilation simulation and code generation of the graphical model.

In one aspect the present invention provides a method for model processing a graphical model. The method includes the step of receiving a graphical model for model processing into an executable form. The method then determines a first section of the graphical model to perform a first portion of the model processing and a second section of the graphical model to perform a second portion of the model processing. The first portion of the model processing can be processed concurrently with the second portion of the model processing.

In one aspect of the present invention the graphical model may be a block diagram model and may include non graphical or textual language. In another aspect the method of the present invention determines the first section of the graphical model that is disjoint from the second section of the graphical model. The first section and the second section of the graphical model may be disjoint in one or more characteristics of model processing the graphical model. In another aspect the first section and the second section may reference or identify a second graphical model associated with the graphical model. Furthermore either the first portion or second portion of the model processing may include the model processing of the second graphical model. Additionally the method may include the step of providing a graphical representation of portions of model processing that can be performed concurrently on sections of the graphical model.

In a further aspect either the first or second portion of the model processing may include propagation of a signal identified in the graphical model. The propagation of the signal may include propagating an attribute of the signal of one or more of the following types 1 a data type 2 a dimension 3 a sample time 4 a frame type and 5 a complex number type. In one aspect the first or second portion of the model processing may provide executable instructions code or a shared library to form a portion of the executable form of the graphical model. Furthermore the method may combine a result of the first portion of the model processing and a result of the second portion of the model processing to form the executable of the graphical model.

In another aspect the present invention relates to a device readable medium having device readable instructions to execute the steps of the method as described above related to the model processing of a graphical model. In an additional aspect the present invention relates to transmitting via a transmission medium computer data signals having device readable instructions to execute the steps of the method as described above related to the model processing of a graphical model.

In one aspect the present invention relates to a method to distribute tasks for processing a graphical model into an executable form. The method includes the step of receiving a graphical model for model processing into an executable form. A first portion of the model processing on a first section of the graphical model can be processed concurrently with a second portion of the model processing on a second section of the graphical model. The method also includes identifying a first task of the first portion of the model processing to distribute for processing and a second task of the second portion of the model processing to distribute for processing.

In one aspect of the present invention the graphical model may be a block diagram model and may include non graphical or textual language. In a further aspect the method of the present invention also determines one or more computing devices suitable to process one of the first task and the second task. The method also includes the step of distributing the first task and the second task for processing to either a first computing device or a second computing device. The first computing device may execute an operating system different than an operating system executing on the second computing device. The method then may process at least a portion of the first task concurrently with a processing of a portion of the second task. In an additional aspect the first task and the second task includes propagating an attribute of a signal identified in the graphical model. The attribute represents one or more of the following attribute types of the signal 1 a data type 2 a dimension 3 a sample time 4 a frame type and 5 a complex number. Furthermore the method combines a result of processing of the first task with a result of processing of the second task. The combining of the results provide at least a portion of the executable form of the graphical model.

In a further aspect of the present invention either the first section or the second section of the graphical model may have a reference to a second graphical model. Additionally either the first task or the second task includes at least a portion of model processing of the second graphical model.

In another aspect the present invention relates to a device readable medium having device readable instructions to execute the steps of the method as described above related to a method to distribute tasks for processing a graphical model into an executable form. In an additional aspect the present invention relates to transmitting via a transmission medium computer data signals having device readable instructions to execute the steps of the method as described above related to a method to distribute tasks for processing a graphical model into an executable form.

In one aspect the present invention relates to a system for model processing of a graphical model. The system comprises a modeling environment and a mechanism. The modeling environment has a graphical model to model process into an executable form. The mechanism determines a first section of the graphical model and a second section of the graphical model that can be model processed concurrently. The graphical model of the present invention may be a block diagram model and may include non graphical or textual language.

In another aspect of the present invention the mechanism determines the first section of the graphical model is disjoint from the second section of the graphical model in one or more characteristics of model processing the graphical model. Also the mechanism determines a first portion of model processing of the first section of the graphical model and a second portion of model processing of the second portion of the graphical model that can be processed concurrently. Additionally the system may include a graphical user interface representing portions of model processing that can be processed concurrently on sections of the graphical model.

In a further aspect the system of the present invention may include one or more model compilers to model process at least a section of the graphical model by performing one or more of the following signal type propagations 1 data type propagation 2 dimension propagation 3 sample time propagation 4 frame type propagation and 5 complex number type propagation. The system may also include a model compiler or a code generator to provide at least one of the following to form a portion of the executable form of the graphical model 1 executable instructions 2 code and 3 a shared library or any suitable file format for the executable form. In another aspect the system may be distributed. Each or any of the modeling environment the mechanism the model compiler and the code generator may execute on one or more computing devices such as a first computing device and a second computing device. The first computing device may execute an operating system different than an operating system executing on the second computing device.

In another aspect of the present invention the first section or the second section of the graphical model may include a reference to a second graphical model. The model processing of the graphical model may also include the model processing of the second graphical model. Additionally the modeling environment provides the executable form of the graphical model by combining at least a portion of results from model processing the first section and the second section of the graphical model.

In one aspect the present invention relates to a system to distribute tasks of processing a graphical model into an executable. The system includes a modeling environment receiving a graphical model for model processing into an executable form. A first portion of the model processing on a first section of the graphical model can be processed concurrently with a second portion of the model processing on a second section of the graphical model. The system also includes a mechanism to identify a first task of the first portion of the model processing to distribute for processing. The mechanism also identifies a second task of the second portion of the model processing to distribute for processing.

In one aspect of the present invention the graphical model may be a block diagram model and may include non graphical or textual language. In another aspect the mechanism of the present invention determines one or more computing devices suitable for processing a distribution of one of the first task and the second task. Additionally the system may include a model compiler or a code generator to process either the first or second task to generate a result associated with providing a portion of the executable form of the graphical model. The system distributes the first task or the second task to either the model compiler or code generator. Either the model compiler or the code generator generates a result that includes one or more of the following 1 executable instructions 2 code and 3 a shared library.

In a further aspect the system of the present invention processes at least a portion of the first task concurrently with a processing of a portion of the second task. Furthermore the modeling environment combines a result of processing of the first task with a result of processing of the second task. The combined results provide at least a portion of the executable form of the graphical model.

In an additional aspect of the present invention either the first or second task includes propagating an attribute of a signal identified in the graphical model. The signal attribute represents one or more of the following 1 a data type 2 a dimension 3 a sample time 4 a frame type and 5 a complex number. Furthermore the first section and the second section nay provide a reference to a second graphical model and either the first or second task includes at least a portion of model processing of the second graphical model.

In an additional aspect of the present invention the system may be distributed. Each and any of the modeling environment the mechanism the model compiler and the code generator may execute on one or more computing devices such as a first computing device and a second computing device. The first computing device may execute an operating system different than an operating system executing on the second computing device.

The details of various embodiments of the invention are set forth in the accompanying drawings and the description below.

Certain embodiments of the present invention are described below. It is however expressly noted that the present invention is not limited to these embodiments but rather the intent is that additions and modifications to what is expressly described herein also are included within the scope of the invention. Moreover it is to be understood that the features of the various embodiments described herein are not mutually exclusive and can exist in various combinations and permutations even if such combinations or permutations are not expressly made herein without departing from the spirit and scope of the invention.

The illustrative embodiment of the present invention provides systems and methods for partitioning and distributing the compilation of a block diagram model to provide an executable form of the block diagram model. Model compilation converts translates or otherwise processes the block diagram model to provide an executable form that may be used to execute and test the block diagram model. The present invention determines from a block diagram model which tasks of a model compilation process can be processed separately and or concurrently from other tasks. The tasks can be broken down and divided by various perspectives and granularities. In one case a model compilation task may be the propagation of one or more attributes of a signal represented in the block diagram model. The signal attributes may be propagated across one or more blocks in the block diagram model or across multiple block diagram models representing sub systems sharing signals. In another case a model compilation task may include the compilation of a unit block diagram model that is a sub system of a hierarchical block diagram model. A first unit block diagram model may be disjoint from a second block diagram model associated with the same top level block diagram model. That is they may not have any dependencies or relationships to each other such as sharing signals or data that may prevent them from being compiled separately. In this case each of these unit block diagram model may be model compiled separately and or concurrently to each other. A graphical tree view of model compilation of the block diagram model can be shown with the branches of the tree representing separate and or concurrent model compilation paths.

Additionally the illustrative embodiment of the present invention determines a distribution scheme for distributing the processing of the model compilation tasks to form an executable for the block diagram model. The model compilation tasks or branches of the graphical tree representation can be evaluated to determine the computational and spatial complexity in performing or otherwise processing the model compilation task. For example the present invention may consider the number of blocks and signals to process for the task the size and complexity of the code to represent the functionality of each block and the signal attributes to be propagated and to what extent. Furthermore the present invention determines the availability and characteristics of computing resources that may be available on a network to perform model compilation processing. For example the speed of processors and current loading of a computing device may be considered. A distribution scheme can be determined that considers the processing characteristics of the model compilation tasks in view of the characteristics of the available computing resources. Variations of distribution schemes can be determined to distribute model compilation tasks for processing in an optimized or desired manner.

Furthermore the present invention provides for obtaining and combining the results of the distributed processing of the model compilation tasks to provide an executable form for the block diagram model. In this manner although the model compilation of the block diagram model was divided into tasks and distributed the end result is that an executable form for the block diagram model is provided. The results of the distributed tasks can be loaded in a suitable manner in order to provide the executable form. Then the executable form can be executed to simulate the block diagram model to view and test the behavior of the design of the block diagram model.

The illustrative embodiment will be described solely for illustrative purposes relative to the technical computing environment of MATLAB and the Simulink product family including Stateflow from The MathWorks Inc. of Natick Mass. Although the illustrative embodiment will be described relative to a MathWorks based application one of ordinary skill in the art will appreciate that the present invention may be applied to other graphical modeling environments and technical computing environments such as any graphical modeling or technical computing environments using software products of LabVIEW MATRIXx from National Instruments Inc. Mathematica from Wolfram Research Inc. Mathcad of Mathsoft Engineering Education Inc. Maple from Maplesoft a division of Waterloo Maple Inc. Dymola from Dynasim AB of Lund Sweden or MSC.Adams from MSC.Software Corporation of Santa Ana Calif. Furthermore one ordinarily skilled in the art will appreciate that the present invention may apply to any graphical or text based modeling environment such as one providing modeling with a Unified Modeling Language UML Hardware Descriptive Language HDL or that provides a physics modeling domain.

Additionally the computing device may include a network interface to interface to a Local Area Network LAN Wide Area Network WAN or the Internet through a variety of connections including but not limited to standard telephone lines LAN or WAN links e.g. 802.11 T1 T3 56kb X.25 broadband connections e.g. ISDN Frame Relay ATM cluster interconnection Myrinet peripheral component interconnections PCI PCI X wireless connections or some combination of any or all of the above. The network interface may comprise a built in network adapter network interface card PCMCIA network card card bus network adapter wireless network adapter USB network adapter modem or any other device suitable for interfacing the computing device to any type of network capable of communication and performing the operations described herein. Moreover the computing device may be any computer system such as a workstation desktop computer server laptop handheld computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.

The illustrative embodiment of the present invention is directed towards a technical computing environment having a graphical modeling environment and a code building tool. Referring now to an illustrative embodiment of a system for practicing the present invention is depicted. In brief overview the technical computing environment includes a graphical modeling environment and code building tool which are capable of and configured to execute on the computing device . The computing device may be any type of computing device as described above and as depicted in may be a standalone system or a single node in a computer network.

The graphical modeling environment may comprise a platform for multi domain simulation and model based design of dynamic systems algorithms computations implementations of software and or hardware and any other naturally occurring or man made system. In the graphical modeling environment customizable functional blocks are used to create a block diagram model that may represent one or more computations algorithms or operations that can be performed on a computational hardware device such as a computer embedded system processor or any other type of integrated circuit. The graphical modeling environment includes a graphical user interface for interactively creating and working with a block diagram model and may also provide for simulating testing and verifying a block diagram model . In an exemplary embodiment the graphical modeling environment is a graphical modeling environment like Simulink from the MathWorks Inc. of Natick Mass.

The graphical modeling environment may also provide for a non graphical language to be included in the block diagram model . For example a block diagram model created in Simulink may contain programming language statements or instructions in the technical computing language of MATLAB . In another embodiment a non graphical or textual language such as embedded MATLAB may be used to implement one or more elements of the block diagram model . In this manner a graphical model such as the block diagram model may comprise graphical and non graphical elements and the non graphical elements may include any type of suitable text such as any programming language. One ordinarily skilled in the art will recognize and appreciate that the present invention can be practiced with any type of graphical model from any graphical modeling environment and that the graphical model may also include a non graphical language of any type.

The graphical modeling environment includes a model compiler for compiling the block diagram model to convert translate or otherwise process the block diagram model into an executable form. The executable form may be used to execute a simulation of the block diagram model to test and verify the system behavior of computations algorithms or operations of the block diagram model . In one embodiment the model compiler provides an interpretative language executable representation of the block diagram model . This may be referred to as normal or interpretative mode of execution or simulation. The model compiler may process the block diagram model to execute in an interpretative language or any other executable instructions readable and executable by the graphical modeling environment or another execution environment suitable for executing the executable instructions. For example the model compiler may provide executable instructions for the block diagram model in the technical computing programming language of MATLAB in a Virtual Hardware Description Language VHDL or any other interpretative language. These executable instructions would represent the functionality of the block and signals of the block diagram model in a suitable manner to execute the block diagram model .

The technical computing environment may also include an execution engine for executing the executable instructions provided by the model compiler . In one embodiment the execution engine is included in or associated with the graphical modeling environment . The execution engine may allocate any memory on the computing device needed for execution of the executable form of the block diagram model . The execution engine may also allocate and initialize memory for any data structures that store run time information for each block represented in the executable form. For example some of these data structures may include pointers to a block s input and output buffers and state vectors. In general the execution engine may be any type of run environment capable of providing an execution environment to read and execute any of the executable instructions provided by the model compiler as the executable form of the block diagram model .

The model compiler may convert translate or otherwise process the block diagram model as may be necessary to form an executable that will simulate or execute the system represented by the block diagram model . A simulation or execution will compute the system s inputs outputs and states as they may vary over a span of time. In one embodiment the input to the system may be provided via an interfacing mechanism. By way of example of the exemplary embodiment of the graphical modeling environment of Simulink the model compiler may perform one or more of the following steps 1 evaluate the block diagram model s block parameter expressions to determine their values 2 determine signal attributes e.g. name data type numeric type and dimensionality not explicitly specified by the block diagram model and checks that each block can accept the signals connected to its inputs 3 perform attribute propagation to determine unspecified attributes 4 perform block reduction optimizations 5 flatten the block diagram model hierarchy by replacing subsystems with blocks 6 sort the blocks into an execution order for execution simulation 7 determine samples time for blocks in the block diagram model which do not have explicitly defined sample times and 8 determine a block update order for updating the blocks during execution. One ordinarily skilled in the art will appreciate the steps performed by the model compiler in the graphical environment of Simulink and will further appreciate the wide range of different steps that a model compiler in any graphical modeling environment may need to perform in order to process the block diagram model into an executable form an intermediate form or any desired and suitable form.

The technical computing environment may also have a code building tool to generate code such as source code object code a compiled executable or library for forming an executable of the block diagram model . This may be referred to as an accelerated mode of execution or simulation. Generally this non interpretative form of code will execute faster than the interpretative executable form. However it may take longer to generate code for the accelerated mode thereby increasing model compilation time for simulation execution speed. In an exemplary embodiment the code building tool may comprise a code building tool like Real Time Workshop from The MathWorks Inc. of Natick Mass. or any portion thereof that may be necessary to generate executable code instructions etc. in a programming language such as C. The code building tool can generate source code for the execution of the block diagram model compile the source code into object code and build an executable program library or any other form of executable instructions. The code may be designed to run on any processor microprocessor operating system computational hardware device or component of a computational hardware device. In one embodiment the code may comprise embedded code targeted to run on any type of embedded system. Additionally the code may be customized to run on a specific target hardware platform.

In an exemplary illustration of code building operations the code building tool reads in the block diagram model to translate the block diagram model into one or more source code files. The code building tool may receive or obtain the block diagram model stored in memory of the graphical modeling environment via any suitable interface mechanism. Alternatively the code building tool may read the block diagram model from storage such as a model file i.e. .mdl file stored by Simulink or any other representation of the block diagram model such as an intermediate block diagram model representation in an .rtw file of Real Time Workshop . The code building tool may use any form of input files to generate code for translating the blocks and signals of the block diagram model into one more or source code files. The source code files may include program instructions of any suitable programming language such as C which may further be in a format and style following the ANSI ISO C standard. Additionally the source code files may be generated to comprise fixed point or floating point source code. In a further embodiment the programming instructions of the source code may be optimized for performance or versatility and or for a specific target hardware platform. In another embodiment the code building tool can be configured via any input or configuration files to generate custom source code comprising a style and format. The code building tool can be also configured via input files to provide customized source code to support such customizations as error handling optimization code and data reduction code reusability scoping of variables and other characteristics of the source code that may be modified during the source code generation process.

The code building tool also provides for the building of the source code files into object code to generate one or more programs libraries or other forms of executable instructions to run an executable form of the block diagram model . The build process may include compiling the code and linking libraries drivers and other programs via a make program or some other compiling utility. In some embodiments the code building tool may include linking of a user provided device driver or other user provided executable instructions when compiling the source code into object code. Although this illustrative example of the code building tool is discussed in terms of source code files and object code from a programming language like C the code building tool may generate any type of programming related output such as an interpreted programming language and or scripting language. For example the code generator may generate code for perl awk VBscript Javascript tcl or the technical computing programming language of MATLAB . One ordinarily skilled in the art will recognize the various types of languages the code building tool may apply in generating code and how the code generator may build the code based on the type of language to provide an executable form of the block diagram model .

The executable instructions from the code building tool may be provided in such a manner as to allow the graphical modeling environment to invoke the executable instructions. For example the executable instructions may be linked into the graphical modeling environment via a function or an application programming interface call or by linking in or loading in a library. In accelerated mode the graphical modeling environment may not require the execution engine as the executable instructions are not written in an interpretative language. One ordinarily skilled in the art will appreciate the various ways that the graphical modeling environment may invoke executable instructions representing the block diagram model .

The graphical modeling environment model compiler execution engine and or the code building tool can be an application module software component library service process task or any other form of executable instructions which is designed to and capable of executing the functionality as described herein. Furthermore the model compiler may be separated from the graphical modeling environment and may comprise an application module service software component or any other type of computer program. Additionally the graphical modeling environment may be configured to and capable of running any of the modules libraries or software components of the MATLAB and Simulink product families. As such the graphical modeling environment may have all or a portion of the software components of MATLAB and or Simulink installed on the computing device or alternatively accessible from another computing device on a network.

The computers can connect to the network through a variety of connections including standard telephone lines LAN or WAN links e.g. T1 T3 56 kb X.25 SNA DECNET broadband connections ISDN Frame Relay ATM Gigabit Ethernet Ethernet over SONET cluster interconnections Myrinet peripheral component interconnections PCI PCI X and wireless connections or some combination of any or all of the above. Connections can be established using a variety of communication protocols e.g. TCP IP IPX SPX NetBIOS Ethernet ARCNET Fiber Distributed Data Interface FDDI RS232 IEEE 802.11 IEEE 802.11a IEEE 802.11b IEEE 802.11g and direct asynchronous connections . The network connection and communication protocol may be of any such network connection or communication protocol capable of supporting the operations of the present invention described herein.

In the network each of the computers are configured to and capable of running at least a portion of the present invention. As a distributed application the present invention may have one or more software components that run on each of the computers and work in communication and in collaboration with each other to meet the functionality of the overall operations of the present invention as described herein. Each of the computers can be any type of computing device as described in connection with and respectively configured to be capable of computing and communicating the operations described herein. For example any and each of the computers may be a server a multi user server server farm or multi processor server. In another example any of the computers may be a mobile computing device such as a notebook or PDA. One ordinarily skilled in the art will recognize the wide range of possible combinations of types of computing devices capable of communicating over a network.

The network and network connections may include any transmission medium between any of the computers such as electrical wiring or cabling fiber optics electromagnetic radiation or via any other form of transmission medium capable of supporting the operations of the present invention described herein. The methods and systems of the present invention may also be embodied in the form of computer data signals program code or any other type of transmission that is transmitted over the transmission medium or via any other form of transmission which may be received loaded into and executed or otherwise processed and used by any of the computers to practice the present invention.

Each of the computers may be configured to and capable of running the graphical modeling environment and or the code building tool . The graphical modeling environment and the code building tool may run together on the same computer or may run separately on different computers and . Furthermore the graphical modeling environment and or the code building tool can be capable of and configured to operate on the operating system that may be running on any of the computers and . Each computer can be running the same or different operating systems. For example computer can be running Microsoft Windows and computer can be running a version of UNIX and computer a version of Linux. Or each computer can be running the same operating system such as Microsoft Windows. In this manner the present invention may be distributed and performed across multiples computers in a heterogeneous or homogenous networked system to practice the operations of the present invention as described herein.

Additionally the graphical modeling environment and code building tool can be capable of and configured to operate on and take advantage of different processors of any of the computing device. For example the graphical modeling environment can run on a 32 bit processor of one computing device and a 64 bit processor of another computing device . Furthermore the graphical modeling environment and or code building tool can operate on computing devices that can be running on different processor architectures in addition to different operating systems. One ordinarily skilled in the art will recognize the various combinations of operating systems and processors that can be running on any of the computing devices. In summary one ordinarily skilled in the art will appreciate that the graphical modeling environment and code building tool may be deployed across a wide range of different computing devices different operating systems and different processors in various network topologies and configurations.

In one aspect the present invention is directed towards the distribution of model compilation processing. As depicted in the networked system of multiple model compilers and multiple code building tools may be deployed to computing devices in order to support distributed processing of a model compilation of the block diagram model . As such each of the model compilers and code building tools can be capable of and configured to perform one or more tasks of model compilation to support the interpretative and accelerated modes of simulation execution. Although computing device are shown with model compilers and code building tools the computing devices may each have a graphical modeling environment or technical computing environment of the present invention or any portions thereof.

Each of the model compilers may be in communication with the model compiler the graphical modeling environment or the technical computing environment on the computing device . Likewise each of the code building tools may be in communication with the code building tool the graphical modeling environment or the technical computing environment on the computing device . Any suitable interface means or mechanisms may be used for the communications between the graphical modeling environment the technical computing environment and the model compiler on the computing device over the network to any of the model compilers and the code building tools on computing devices . One ordinarily skilled in the art will appreciate the various ways the present invention may be distributed in a networked system and how any of the components of the present invention may communicate with each other.

In an exemplary embodiment as depicted in the system may also include additional components for distributing and managing distributed model processing tasks in accordance with the operations of the present invention described herein. In some embodiments the technical computing environment is a distributed MATLAB environment as disclosed in co pending U.S. patent application Ser. No. 10 896 784 titled Methods And Systems For Distributing Technical Computing Tasks To Technical Computing Workers and filed Jul. 21 2004 and co pending U.S. patent application Ser. No. 10 940 151 titled Interfaces To Job Managers In Distributed Computing Environments and filed Sep. 13 2004 both of which are incorporated herein by reference in their entirety. In one embodiment as depicted in system of the technical computing environment of the present invention includes the Distributed Computing Toolbox or distributed computing toolbox and the MATLAB Distributed Computing Engine of the MATLAB product family. The MATLAB Distributed Computing Engine comprises a job manager and a technical computing worker or worker . In brief overview of system of the computing device includes a distributed computing toolbox and a job manager and each of the computing devices include a technical computing worker or worker 

The distributed computing toolbox and job manager works with the worker to distribute tasks related to processing models in the graphical modeling environment such as a graphical modeling environment provided by Simulink to a cluster of computing devices . As such models and applications can be developed in the technical computing environment of MATLAB and the Distributed Computing Toolbox can be used to divide them into independent tasks and distribute the tasks to workers for evaluation or execution. The workers can perform these tasks on remote computing devices . The distributed computing toolbox together with the workers can substantially reduce the overall execution time for distributing and processing tasks of the present invention as described herein.

The distributed computing toolbox job manager and workers manage distribute process and obtain results using jobs and tasks. A job may be a complete operation such as the model compilation or processing of a block diagram model to perform in the technical computing environment . The job comprises a set of tasks where a task is one portion of the job to be evaluated or performed by the worker . In the graphical modeling environment jobs and tasks can be defined using the distributed computing toolbox . The distributing computing toolbox provides functions and or an application programming interface API for example an object oriented interface to define jobs and tasks to submit tasks and jobs for distribution and to receive results from an executed task or job. For example a job object comprising tasks or tasks objects can be defined via the distributed computing toolbox . The distributed computing toolbox can run on any computing device on the network from which a graphical modeling environment is provided to define and submit jobs. Additionally multiple distributed computing toolboxes can be running on the network and on any type of hardware and operating system platform. For example one technical computing toolbox can be running on a Windows platform with the graphical modeling environment and another distributed computing toolbox can be running on a Linux platform with another graphical modeling environment .

The job manager can run on any computing device on the network and coordinates job execution. The job manager can accept jobs from any distributed computing toolbox and asynchronously distributes tasks to workers for execution. On startup workers can be registered with a job manager and have a unique name associated with the worker . In the case of processing tasks related to model processing or compilation or generating an executable form from a model each of the workers may be in communication with a model compiler and or code building tool in order to perform the task. In other embodiments the model compiler and or code building tool is included in or a part of the worker . Once the workers complete their tasks the workers send results to the job manager where the results can be obtained or made available via the distributed computing toolbox . For example the graphical modeling environment can obtain the results of a job to compile a model from the job manager via the distributed computing toolbox .

Multiple job managers can be running on the network to service one or more distributed computing toolboxes . Additionally the multiple job managers can be on any type of hardware and operating system platform and each of the job managers can be running on the same or a different platform from the other job managers . Furthermore the distributed computing toolbox the job manager and each of the workers can each be on different hardware and operating system platforms. That is the distributed computing toolbox the job manager and each of the workers do not need to be on the same type of operating system or hardware platform in order to work in conjunction with each other.

Although the distributed computing toolbox job manager and workers are illustrated by an example of a technical computing environment of MATLAB using the Distributed Computing Toolbox and the MATLAB Distributed Computing Engine one ordinarily skilled in the art will recognize and appreciate that any suitable distribution tool mechanisms and means may be used.

Referring now to an example block diagram model is shown for an embodiment of the present invention. Although this block diagram model will be generally discussed and used as a reference for discussions herein any block diagram model may be used to practice the invention. For example any block diagram model that may be generated with the graphical modeling environment such as Simulink may be used. In the block diagram model represents an illustrative graphical model of an engine controller for an automotive power train. This controller represented by the design in the block diagram model may also include a design for an ignition controller and a fuel rate controller. For example the ignition controller may be designed in the block diagram model to compute the actual engine throttle setting and the spark advance to control performance of the engine. The fuel rate controller may be designed in the block diagram model to set the rate of fuel supply to the engine to minimize pollution of the vehicle from the combustion process.

Since the design of the ignition controller and the fuel rate controller can be disjoint from each other the designs for these controllers can be separated into different unit or stand alone block diagram models. In the overall engine controller design the block diagram model is the top model or top view model. The model block can provide a model reference to a second block diagram model representing the design of the subsystem of the ignition controller. Likewise the model block can provide a model reference to a third block diagram model representing the design of the subsystem of the fuel rate controller. These second and third block diagram models could be stand alone block diagram models but they are sub systems in that they are referenced by the top block diagram model of the engine controller. As such the top block diagram model forms a hierarchical or multi layer block diagram model structure in that there is a top model i.e. engine controller which references two additional disjoint unit block diagram models i.e. the ignition and fuel rate controllers. Although blocks and are referred to as model reference blocks they can also be subsystem blocks as they are known in the graphical modeling environment of Simulink . One ordinarily skilled in the art will recognize the various elements may be used in the block diagram model to reference represent or otherwise identify a sub system or unit block diagram model that forms a second or higher layer to the top level hierarchy of the block diagram model .

Referring now to an illustrative hierarchical view of the example block diagram model is shown. The block diagram model includes a first model reference block referencing a block diagram model A and a second model reference block referencing a block diagram model B . In turn the A block diagram model may include one or more model reference blocks and . For example model reference block may also reference the B block diagram model and a third block diagram model C may be referenced by model reference block . Alternatively the A block diagram model may comprise two functional blocks and that do not reference any additional block diagram models. Likewise the B block diagram model may include one or more model reference blocks . For example model reference block may reference a third block diagram model of C and model reference blocks and may each reference a fourth block diagram model D and a fifth block diagram model E. Alternatively any of the blocks of may represent functional blocks of the block diagram model . In this manner the block diagram model represents the top level of the model hierarchy and each of block diagram models and are unit block diagram models representing a sub system of the top model and a second layer to the hierarchy. Block diagram models C D E referenced by model reference blocks could represent additional unit models and a third layer to the hierarchy. As mentioned above although referred to as a model reference block the block diagram model may comprise any element that identifies a sub system unit block diagram model another block diagram model or any portion of a block diagram model. Additionally one ordinarily skilled in the art will recognize that the block diagram model can have a multitude of layers unit block diagram models and sub systems.

Referring back to the block diagram model of the model reference blocks and are integrated into the top view by a shared throttle input represented via a signal element . In the block diagram model the signals are identified by lines with arrow heads and represent inputs and outputs to the model reference blocks and . Additionally the signals can represent input and output signals to any types of blocks of the block diagram model . A signal as used herein will be in reference to signals used in the graphical modeling environment of Simulink although one ordinarily skilled in the art will appreciate that other graphical modeling environments may have other representations for signal like functionality as described herein. Signals represent streams of information such as data data types timing information and control information flowing into out of and between various blocks in the block diagram model . For example signal can represent attributes related to the application of a brake to the ignition controller while signal provided attributes related to an engine throttle output.

In the graphical modeling environment signals can be specified with a wide range of attributes including signal name data type e.g. 8 bit 16 bit or 32 bit integer numeric type complex or real and dimensionality. A signal type refers to a signal that is a member of a class or classes of signals. The dimensionality attribute of a signal has a value or values that identify the maximum dimensions of the data represented by the signal. The data can be organized into a one dimensional data structure for example a vector or can be organized into a two dimensional data structure for example a matrix or can be organized into a three dimensional or four dimensional data structure. Additionally the data dimensionality of a signal can vary during execution of a block diagram in the graphical model environment . As such the data dimensions of a signal may vary to accommodate the dimensionality requirements of data a function or to comply with the attributes of the signal as configured in the block diagram model .

Many blocks of the block diagram model can accept input signals or provide output signals of any data numeric or dimensionality type. Each distinct input or output on a block is referred to as a port. A port provides a link of the signal to the block i.e. an input port or out from the block i.e. an output port. Signals correspond to the time varying quantities represented by each line connection and are assumed to have values at each time instant. The destination of the signals corresponds to blocks that read from the signal during execution of the block . The source of the signals correspond to the blocks that write to the signal during block execution. Furthermore processing of these signals within a graphical model environment is adaptable to recognize the signal attributes and any variability to the signals during execution such as variable data dimensionality.

During model compilation the graphical modeling environment such as through the model compiler uses a process called signal propagation to represent the traversal of the signal and associated attributes via the connectivity of the blocks. This may be needed for creating the executable form of the block diagram model to simulate the behavior of the signal through the blocks of the block diagram model . As such the propagation of signal attributes through the connectivity represented in the block diagram model drive the execution of the simulation. In reference to an exemplary embodiment of Simulink as the graphical modeling environment signal propagation is the process used to determine attributes of signals and blocks such as data types labels sample time dimensionality and so on that are determined by connectivity. Since a signal can have different types of associated attributes there are also different types of signal propagation that may occur when compiling the model.

One type of signal propagation is data type propagation. This processing step involves determining the types of signals whose data type is not otherwise specified and checking the data types of signals and input ports of blocks to ensure that they do not conflict. This is to make sure the data type of the signal propagating through the connected blocks can be handled and processed by the blocks in accordance with the functionality or operations of the block. For example certain blocks may only receive as input a certain data type but nevertheless may be connected to a signal with data type attributes that cannot be processed by the block. In some embodiments of data type propagation data types may be typecast or converted from one data type to the required data type for use by certain blocks. Additionally the values of signals can be complex numbers. As such a signal whose values include a complex number is called a complex signal. Accordingly complex type propagation is the process of determining which blocks can and or cannot accept as input or provide as output the complex type values associated with a signal.

Dimension type propagation is the process of determining which blocks can accept or output the signals connected to and from the signal in accordance with the dimension attributes of the signal. Blocks of the block diagram model such as blocks and may vary in the dimensionality of the signals they can accept or output during simulation. A one dimensional signal may include a stream of one dimensional arrays output at a frequency of one array per sample time. A two dimensional signal may include a stream of two dimensional arrays emitted at a frequency of one array per block sample time. A one dimension signal is generally referred to as a vectors and a two or more dimension signal as a matrix. A one element array may be referred to as a scalar. A row vector is two dimensional array that has one row and a column vector is a two dimensional array with one column. Some blocks can accept or output signals of any dimension. Others can accept or output only scalar or vector signals.

Other types of signal propagations are sample time and frame type propagation. Sample time is the time interval between samples to be applied as input to a port of a block or as output from a block. The graphical modeling environment of Simulink uses a process called sample time propagation to determine the sample times of blocks which inherit their sample times. Simulink assigns an inherited sample time to a block based on the sample times of the blocks connected to its inputs. If all the inputs have the same sample time the graphical modeling environment assigns that sample time to the block. In some cases if the inputs have different sample times then a block without an explicit sample time may be assigned the sample time of the fastest input. A frame based signal has a time interval between consecutive vector or matrix inputs to a block or outputs from a block. That is an input frame rate indicates how many inputs are applied consecutively over a time period and in what time intervals. Similarly an output frame rate indicates that a block will update an output signal at the output port at specified intervals over a specified time period. Accordingly frame type propagation determines how a frame type signal will be applied to the inputs and outputs it traverses based on block connectivity.

Although signal propagation is discussed above in terms of data type dimension type complex type and sample and frame type propagation other types of propagation may occur with respect to any other attribute associated with a sample. Generally the process of propagation determines how the attributes of the signal will be applied as input and or output to from and between blocks from which the signal traverses in accordance with the block connectivity of the block diagram model . The propagation process may evaluate or compare the configuration of the signal attribute with the configuration and attributes of the block to determine the suitability of the block to process or otherwise use the signal. During propagation of any signal the propagation process may perform any type of integrity consistency or any other form of checking that is suitable for the type of attribute being propagated. Furthermore it may perform any type of transformation conversion configuration or other processing that makes the propagation of the attribute suitable for execution or simulation. One ordinarily skilled in the art will recognize the different types of propagation and the different steps a propagation process may perform and will further appreciate the propagation of the signal is to process the block diagram model into an executable form that may be suitable for simulation of the block diagram model .

Additionally one ordinarily skilled in the art will recognize that dependencies between blocks and block diagram models may occur from the connectivity between blocks with respect to signals and signal propagations. As such a model compilation process needs to check and take into consideration the traversal of the signal the corresponding attributes and the order of execution of blocks and updates to attributes in order to make a suitable executable form for simulation.

In one aspect the present invention is directed towards the distributed processing of the model compilation of a block diagram model to process the block diagram model into an executable form. depicts an illustrative method of practicing an embodiment of the present invention. The illustrative method can be practiced and will be discussed in conjunction with the exemplary system shown in using the block diagram model example of . Furthermore the illustrative method will generally be discussed in terms of the graphical modeling environment of Simulink . As discussed above with respect to the system may have a graphical modeling environment with model compiler and code building tool on one computing device and have other model compilers and or code building tools deployed on multiple computing devices on the network . The graphical modeling environment communicates with and works with the distributed model compilers and or code building tools to perform the distributed operations described herein.

In operation the graphical modeling environment of the system obtains receives or otherwise provides a block diagram model at step of the illustrative method . The block diagram model may be a hierarchical block diagram model having references to one or more other unit or sub system block diagram models . For example the block diagram model may represent the engine controller design as depicted in . Furthermore as depicted in the model block references and may reference block diagram models and as shown in . In turn the block diagram models and reference additional block diagram models such as block diagram models C D and E as described in . Although the illustrative method is described using this block diagram model as an example one ordinarily skilled in the art will recognize that any block diagram model may be used and in other graphical modeling environments . In the graphical modeling environment a request command or other action may be taken to initiate the simulation of the block diagram model . Any suitable mechanism may be used to trigger the model compilation of the block diagram model into an executable form. For example simulation may be initiated from a menu item selection or command button in the graphical modeling environment . This starts the model compilation processing of the block diagram model to form an executable either in interpretative mode or accelerated mode.

At step of the illustrative method the graphical modeling environment determines which portions of the block diagram model can be processed separately and or concurrently. That is it is determined which portion of the model compilation can be processed separately from another portion. Additionally the separate portions may be processed concurrently by invoking executable instructions in different threads programs or processors to perform the model processing for each portion. This determination can be performed from a vertical distribution or horizontal distribution perspective. From the vertical distribution perspective the block diagram model and any unit models and are evaluated to determine what types of propagation may be performed separately from other portions of the block diagram model . For example a block diagram model may only be using complex signal attributes while block diagram model does not use complex signal attributes. Therefore in model compilation only complex type signal propagation needs to be performed on block diagram model . This step may be performed concurrently with another type of propagation. From the horizontal distribution perspective any block diagram models incorporated in or referenced by a top level block diagram model are evaluated to determine if they are disjoint from each other. One unit block diagram model may be considered disjoint from another unit block diagram model if there are no dependencies between the two with respect to signals attributes data or otherwise. In these cases the model compilation process or a portion thereof can be performed on the unit block diagram model as if it were a stand alone block diagram model . That is all the steps of the model compilation process are performed sequentially on the block diagram model as a whole until an executable form for the unit model or a desired portion thereof is created.

In one embodiment the illustrative step finds all the model reference blocks and therefore any unit models in a block diagram model by invoking a command available in the technical computing environment of the present invention. For example in the graphical modeling environment of Simulink there is a find systems function that determines any subsystems blocks signals ports or other elements of the block diagram model and returns references to such elements for example in a matrix or array format. The find systems function is an illustrative example and there may be other suitable means available from the graphical modeling environment or technical computing environment to determine the parts elements and relationships of the block diagram model including unit block diagram models and and any signals . For example the block diagram model may be stored in a medium readable by the graphical modeling environment and the graphical modeling environment may read parse translate or otherwise obtain information from the block diagram model to determine the parts of the block diagram model in accordance with the present invention.

In determining the parts of the block diagram model step may present the hierarchy in a representation such as the graphical tree view shown in . The graphical tree view shows a tree view of the top level block diagram model and any unit models. The top node represents the top level block diagram model and the other nodes represent unit block diagram models or subsystems referred directly or indirectly via the top level block diagram model . The nodes of the graphical tree view has branches showing the model reference relationship in the hierarchy of the block diagram model . Although the parts of the block diagram model from a hierarchical perspective are shown in a graphical tree view other views of the block diagram model may be used in accordance with the present invention. As one ordinarily skilled in the art will appreciate other views may include an object oriented implementation diagram a finite state machine behavioral model a scenario model or any another graphical representation that is suitable for showing relationships parts or portions of the block diagram model .

At step the illustrative method identifies the separate and or concurrent paths of model processing from the graphical tree view or any other suitable view as discussed above. In one embodiment of this step the graphical user environment or technical computing environment uses a search algorithm to traverse the branches of the graphical tree view to determine the separate and concurrent portions of model compilation for the entire block diagram model . In performing step the algorithm may search any computer data related representative forms of the graphical tree view such as a representation of the graphical tree view that may be stored in any data data structures objects in memory storage or otherwise or in any form accessible by in or from the graphical modeling environment . Additionally the algorithm may be written in the technical computing language of MATLAB or in any other suitable language or form of executable instruction.

The problem of identifying these separate and concurrent paths may be considered a Non deterministic Polynomial time NP complete type problem. One ordinarily skilled in the art will recognize NP complete type problems relate to the domain of complex computational theory and will appreciate the types of approaches to algorithmically solving these problems. Generally algorithms for solving these types of problems require computing time that is exponential to the size of the problem. In one embodiment a heuristic approach may be applied to aid in the identification of the separate and concurrent paths of model processing. A heuristic approach would apply some guidelines or rules of thumbs to the problem. For example the algorithm may have rules on which types of signal propagation is processed in what order or will have a rule that indicates that the largest of the unit block diagram models are processed first. One ordinarily skilled in the art will appreciate that there is a wide range of heuristics that can be applied to determine the separate and concurrent model compilation paths of a block diagram model . Other types of algorithms such as probabilistic or approximation may be applied. One ordinarily skilled in the art will further appreciate that there are a wide range of algorithms that may be applied to determining the separate and concurrent paths for model compilation.

In one embodiment of a horizontal distribution approach to step an algorithm would be performed on the graphical tree view or any data representation thereof to determine the different types of signal propagations that may occur separately and or concurrently on portions of the block diagram model . For example an order of propagation for each portion of the block diagram model may be identified for each type of signal propagation. A portion may be identified at the granularity of a unit block diagram model or at the level of a block of a block diagram model or any other identifiable portion of the block diagram model . In another embodiment of the vertical distribution approach to step an algorithm would be performed to determine the block diagram models or portions thereof that may be considered disjoint and which can be processed separately and or concurrently. For example each of the unit block diagram models may be identified for separate and concurrent model processing.

At step of the illustrative method the graphical modeling environment establishes and shows a model processing graph representing the separate and or concurrent paths of model compilation that have been identified in accordance with step . In a model processing graph shows an example of a model processing graph established at step . The model processing graph shows portions of the block diagram model identified for horizontal distribution of model compilation. As described above the horizontal approach searches for disjoint block diagram models in the hierarchy of the block diagram model which may independently be processed for modeling compilation. By way of example the horizontal distribution model processing graph shows two branches and that may be performed separately and concurrently from each other. Branch connects to the tree node representing the block diagram model referenced by model in . Branch connects to the tree node representing the block diagram model referenced by model in . As such by this example block diagram models and may be processed separately. Additionally branch connects tree node to tree node which represents a third block diagram model C reference by the model reference block . The branch indicates that the model processing of block diagram model C is dependent on and should occur after the model processing of block diagram model . However the model processing of block diagram model C can occur separately and concurrently from any of the model processing in the sub tree of branch e.g. the model process of block diagram models B D and E Likewise the branches of and leading from tree node for block diagram model identify that model processing for block diagram models D and E associated with tree nodes and can occur concurrently from each other concurrently from the processing of block diagram models A and C but before the model processing of block diagram model B. 

Although the vertical distribution model processing graph shows five types of signal propagation in separate trees and the vertical distribution model processing graph may show any type of signal propagation and may combine two or more types into a single branch. For example at step of the illustrative method the vertical distribution approach may determine which block diagram models may be able to perform both data type and dimensional signal propagation together but separately and concurrently from other block diagram models. Accordingly this would be reflected in the vertical distribution model processing graph .

Additionally the horizontal and vertical approaches may be combined in any suitable manner at steps to determine the separate and concurrent branches and displayed accordingly at step . In other embodiments the tree nodes of any of the graphical models of may represent blocks of block diagram models instead of block diagram models. As such at step it would be determined for either of the horizontal or vertical approaches which blocks may be compiled separately and or concurrently from each other. One ordinarily skilled in the art will appreciate the steps at and can be performed for any granularity of identifiable portions of the block diagram model .

Furthermore although the horizontal and vertical distribution model processing graphs of are shown in tree view form any other type of graphical form can be used as discussed with regards to the tree view of . Additionally one skilled in the art will appreciate that any of the branches and tree nodes of the graphical models in may take any form and further may be user selectable movable configurable or editable to change the respective models in a desired manner. In further embodiments the graphical models of may have additional identification and configuration information associated with the model such as with any branch or tree node. Any of the branches and tree nodes in may be selectable clickable or otherwise provide any type of information identifying any aspects of model processing of the block diagram model . For example a tree node may include one or more details of the corresponding block diagram model and the branches may include information on any model processing dependencies between nodes. Additionally one may be able to drill down on a tree node to see the details of the underlying block diagram model and to get a tree view as if the unit block diagram model was the top view block diagram model . One ordinarily skilled in the art will appreciate how the graphical models of may include and provide additional information associated with model processing related to the operations of the present invention described herein.

At step of the illustrative method the graphical modeling environment evaluates the model processing graphs or data representations thereof to estimate computational and spatial complexity of the identified branches of the graphs i.e. the paths of model processing identified in accordance with step . The graphical modeling environment may use any suitable means to estimate the computational and spatial complexity of the separate and concurrent paths as identified in the examples of . For example computational complexity may be estimated by considering the number of block diagram models the number of blocks the functionality operations or algorithms of the blocks or any data or attributes associated with or processed by any of the blocks. In other embodiments the graphical modeling environment may consider for computational complexity the complexity or size of the code that needs to be generated to process the block diagram model into an executable form. In further embodiments the graphical modeling environment may consider for computation complexity if there is any external interfacing performed by any of the blocks of the block diagram models.

With respect to spatial complexity the graphical modeling environment at illustrative step may consider the number of trees sub trees nodes and branches that can be performed separately and concurrently. Furthermore the graphical modeling environment may consider the relationships and dependencies between nodes and branches such as those depicted in . For example the number of recursive references to blocks or block diagram models may be considered. Additionally the graphical modeling environment may consider for spatial complexity the number and types of signal propagation and their respective extent of traversal through each of the blocks of the hierarchical block diagram model. For any computational and spatial complexity estimations the graphical modeling information may have business rules guidelines or other forms of information configured in or accessible in any type of medium by the graphical modeling environment to assist in providing estimations. One ordinarily skilled in the art will appreciate there is a wide range of suitable means for estimating complexities to the identified model processing paths in accordance with the present invention.

At step the graphical modeling environment partitions the model compilation into processing tasks based on the model processing paths identified at step and the estimated complexities determined at step . Examples of model processing tasks to be performed by the model compiler and or the code building tool may include any tasks or sub tasks related to 1 propagating any signals 2 generating code for any of the blocks signals or other elements of the block diagram model 3 setting up any run time environment overhead global or general data structures memory allocation etc. 4 setting up any debug environments to debug the executable form of the block diagram model 5 compiling any code and 6 loading any code to provide the executable form of the block diagram model . These processing tasks will depend on and vary according to if the executable form is being generated for an interpretative or accelerated mode. In interpretative mode the model compiler may be used to process the block diagram model and in accelerated mode the code building tool may be used to generate code for the block diagram model . As such different tools for model processing may have different tasks and sub tasks. For example in interpretive mode the code may not need to be compiled as illustrated in the above task list. One ordinarily skilled in the art will recognize that there may be other types of tasks and subtasks for compiling a model under a graphical modeling environment of Simulink and these tasks may vary across different types of graphical modeling environments . Furthermore one ordinarily skilled in the art will appreciate that the tasks may depend on the types of model compilers and code building tools used for providing an executable form of the block diagram model .

At illustrative step the graphical modeling environment may use any suitable scheme for partitioning the model processing of the block diagram model . For example the graphical modeling environment may partition the model processing tasks according to a ranking order of complexities assigned to model processing paths. In these cases the most complex signal propagation and code generation tasks may occur first. In another example the graphical modeling environment may partition the model processing by which paths are the most independent from other paths or in other words has the least dependencies on the model processing of other portions of the block diagram model . Or in another cases the graphical modeling environment may first process the path or portion of the block diagram model that has the highest number of other paths or portions of the block diagram model depending on it. In a further example it may partition that tasks based on a ranking of the computation burden length of processing time or other resource considerations. As such the graphical modeling environment may partition the model processing tasks such that the tasks taking the longest time to process will be worked on first. One ordinarily skilled in the art will recognize and appreciate the multitude of ways that tasks of model processing can be subdivided for either the interpretative or accelerated modes.

At step of the illustrative method the graphical modeling environment determines a distribution scheme. The graphical modeling environment determines the computing devices available on the network of system in to process the tasks for processing the block diagram model into an executable form. For example the graphical modeling environment on computing device may determine the other model compilers and or code building tools that are available on the network to perform model processing tasks. As discussed above with regards to system of the model compilers and or code building tools may each be running on different computing devices with different operating systems and processors. The graphical modeling environment may determine any of the capabilities of any of the available computing devices . For example the number type speed and other operational characteristics of the processors of the computing device may be considered. In another example the type bandwidth availability latency and any other operational characteristics of the computing devices network connectivity may be considered. Additionally the resource and user load of any of the computing devices may be considered by the graphical modeling environment in determining how to distribute the model processing tasks identified at illustrative step . The graphical modeling environment may perform any type of algorithm to determine and or optimize the distribution scheme. Additionally the graphical modeling environment may provide any type of configuration mechanism for a user to identify and configure a custom distribution scheme to have the processing tasks distributed in a desired manner. One ordinarily skilled in the art will appreciate there are wide range of factors and characteristics that can be considered for determining a way to distribute processing tasks to one or more computing devices in an optimized or desired manner.

At step of the illustrative method the graphical modeling environment distributes the tasks to one or more computing devices in the illustrative system in accordance with the distribution scheme determined at step . The distribution may depend on whether the model compilation is for an interpretative or accelerated executable form of the block diagram model . In the case of interpretative mode the model compiler on computing device and model compilers on computing devices in the illustrative system of may perform one or more of the distributed model processing tasks. Likewise in the case of accelerated mode the code building tool on computing device and code building tool on computing devices may perform one or more of the distributed tasks. Either of the technical computing environment the graphical modeling environment the model compiler or the code building tool on computing device may have a distribution mechanism to distribute the processing tasks to corresponding model compilers or code building tools identified by the determination of the distribution scheme at step .

The corresponding model compilers and code building tools may interface and communicate over the network using any suitable means or mechanisms in order to receive and process any model processing tasks communicated from any other model compiler or code building tool or from the graphical modeling environment . The model compilers or code building tools receiving model processing tasks will process the tasks in a manner suitable to provide a portion of the executable form of the block diagram model . Furthermore the model compilers or code building tools will perform the model processing tasks in a manner so that the results from processing of the tasks may be combined aggregated or otherwise used to provide an executable form for executing the block diagram model in the desired manner.

Although the illustrative system of is shown with one model compiler and code building tool per computing device there may be multiple model compilers and code building tools running on each computing device . Additionally there may be multiple model compilers and code building tools running on a plurality of computing devices on the network . Furthermore each of the computing devices running either a model compiler and or code building tool may have a different operating system and processor architecture than any other computing device running either a model compiler and or code building tool . On each computing device the model processing task may be executed by the respective model compiler or code building tool as a task service process thread program or any other form of executable instructions. In one embodiment there may be one or more model processing tasks model compilers or code building tools executing on each processor of a multi processor computing device or on the same processor of either a single or multiple processor computing device . One ordinarily skilled in the art will appreciate how the model compilers and code building tools may process tasks concurrently and separately on the same computing device and over the network on multiple computing devices .

At step of the illustrative method the graphical modeling environment obtains the results from the distributed tasks to process the block diagram model into an executable form. The graphical modeling environment may determine by any suitable means that the distributed tasks for model processing have all been completed performed or otherwise executed. In one embodiment each of the model compilers or code building tools performing the model processing tasks may communicate a result status or other communication associated with the task to the graphical modeling environment . For example such communication may identify the success or error status of processing the task. As there are multiple model processing tasks each task makes up a portion of the overall model compilation to form an executable for the block diagram model . Therefore the results from each of the tasks each may make up a portion of the desired executable form. The graphical modeling environment obtains each result from each distributed task and combines them in a suitable manner in order to facilitate providing the final executable form of the block diagram model which will be discussed below.

In one exemplary embodiment the results of each task performed by one of the model compilers or code building tools may be placed in a directory accessible over the network . The location and name of the directory may be configurable in the graphical modeling environment and provided by the graphical modeling environment with the distributed task so that the model compiler or code building tool knows of the directory. The directory may further follow a naming convention so that results may be placed in the directory or in sub directories in a logical fashion. For example for a horizontal distribution the results of model processing for each unit block diagram model may be placed in a sub directory name that identifies the name of the unit block diagram model . Further in the example of the accelerated mode of compilation a compiled shared library having executable instructions representative of the functionality of the unit block diagram model may be placed in the sub directory named for the unit block diagram model 

In this manner all the results of the model processing tasks may be collected under a root or top level directory with sub directories holding the results from the distributed model processing tasks. One ordinarily skilled in the art will recognize the various alternatives to obtaining the results from distributed processing using a directory mechanism. For example each model compiler or code building tool may place the results of processing tasks into a directory on the computing device from which they execute. Although generally discussed as using a directory structure to obtain and collect the results from processing tasks any other suitable mechanism such as a database or a message passing and application programming interface may be used. In another embodiment for example for the accelerated mode the code generated from the code building tools such as source code object code or libraries may be placed in directory for building one or more programs to form an executable. Then one of the code building tools may perform a build of one or more of the programs such as compiling and or linking the code to form an executable. One ordinarily skilled in the art will further appreciate that there are a multitude of alternative ways to obtain and collect the results from the processing the distributed model compilation tasks.

In an exemplary embodiment of the present invention steps and may be performed in accordance with the illustrative embodiment of system of . That is the steps of determining a distribution scheme distributing model processing tasks and obtaining model processing tasks results can be performed using the distributed computing toolbox job manager and workers as described in conjunction with system of . In this embodiment at step the distribution scheme would be determined by the job manager which coordinates and manages the distribution of tasks to one or more workers on the network . In one embodiment the job manager may use any of the methods of determining a distribution scheme as described above with respect to step . As such the job manager may have any configurable loadable or built in functionality to determine how to distribute tasks to workers 

The graphical modeling environment or technical computing environment may find a job manager from one or more job managers that may be available on the network . A function or application programming interface API call such as findresource of the distributed computing toolbox of MATLAB may be used to find a job manager by name type properties host name internet protocol address or by a uniform resource locator URL . For example the following set of MATLAB executable instructions may be used to find all the job managers available on the network 

In this exemplary embodiment at illustrative step jobs and tasks would be created via the distributed computing toolbox in either the graphical modeling environment or technical computing environment to distribute the model processing tasks determined at step of the illustrative method . One or more jobs can be created to hold the model processing tasks necessary to complete the operation of providing or generating an executable form of the block diagram model . In one embodiment one job can be created to comprise all the tasks of model processing and in another embodiment multiple jobs may each comprise a subset of the tasks needed for model processing. Via the distributed computing toolbox a job can be created by calling the function or API of createjob. For example the following MATLAB executable instruction creates a job named job1 on the job manager named jm 

To submit a job for distribution and execution the one or more jobs are submitted to a job manager by calling the following illustrative MATLAB executable instruction for each of the jobs 

At illustrative step of this embodiment the results of the distributed processing of tasks are obtained. When all the tasks of the one or more jobs representing the operation of the model processing of the block diagram model are completed the job is completed and results can be obtained from one or more task objects of each job. For example the following MATLAB executable instructions shows how results from a job may be obtained in one embodiment 

In one embodiment the results from each of the tasks comprise a name a pointer or reference to one or more files generated by a worker in performing a model processing task. The files may be generated provided and or stored on the computing device of the worker or any other accessible location or computing device on the network . In another embodiment the task results are zipped or otherwise compressed into a set of one or more files produced by performing the model processing tasks. For example the worker may have processed a task to generate ANSI C code for a portion of the block diagram model such as one or more blocks of the block diagram model . As such the worker in conjunction with the code building tool may have generated one or more source code files representative of the functionality of the blocks of the block diagram model . As part of the same task or as another task in the same job or another job the one or more source code files may be zipped by the worker using any suitable compression utility.

The graphical modeling environment via the distributed computing toolbox can obtain the results from the job manager and combine the results of the model processing tasks. In one embodiment each worker provides one or more files either zipped or uncompressed and the graphical modeling environment obtains all the sets of files. In another embodiment the results are obtained from the job manager in one zipped file comprising all the files generated from all the distributed tasks. The graphical modeling environment may combine the results by storing arranging or otherwise placing the files resulting from the tasks in one or more directories either on the computing device of the graphical modeling environment or any other computing device accessible on the network .

In one embodiment each of the workers performing model processing tasks at illustrative steps may each be on a different hardware and or operating system platform from any other worker job manager or the graphical modeling environment and distributed computing toolbox . In accelerated mode of model processing each of the workers may be assigned one or more model processing tasks to generate source code for a portion of the block diagram model . The workers may work in conjunction with the code building tools to generate source code files such as ANSI C source code files which generally are portable across different operating systems and or hardware platforms. Since the files are ANSI C compliant or following any other suitable cross platform standards the source code files obtained and combined by the graphical modeling environment at illustrative step can then be compiled on the same computing device as the graphical modeling environment or compiled together on any other platform.

In another embodiment of the interpretative mode of model processing each of the workers may work in conjunction with the model compiler to generate interpretative code in files such as in the MATLAB programming language or in any other suitable form for a portion of the block diagram model . Although the interpretative code may have been generated on different operating systems or hardware platforms the interpretative code is portable to other graphical modeling environments which are capable of and configured to execute the MATLAB programming language. In this manner the graphical modeling environment can obtain and combine interpretative code files generated by any worker to provide an executable form of the block diagram model in the graphical modeling environment . In summary either in accelerated mode or interpretative mode the graphical modeling environment can obtain files resulting from tasks distributed to workers on heterogeneous platforms and combine the results to provide an executable form of the block diagram model .

At step of the illustrative method the graphical modeling environment is capable of loading the results obtained and combined from step in such as manner as to provide a final executable form of the block diagram model . The interpretative or accelerated model compilation process may have been initiated by a request to simulate or execute the block diagram model in the graphical modeling environment . Therefore after the graphical modeling environment performs steps to of the illustrative method the graphical modeling environment may further respond to the simulation or execution request by providing the executable form of the block diagram model . In order to provide the executable form of the block diagram model the graphical modeling environment may load the results from the distributed model processing tasks. In one exemplary embodiment the graphical modeling environment may load in or link to various forms of executable instructions such as shared libraries or files having interpretive programming language statements that are stored in the directory structure as discussed above in conjunction with step . In one embodiment of the interpretative mode of simulation the graphical modeling environment may read and load files having interpreted executable instructions into the execution engine for execution. The graphical modeling environment may load all the files on start of the simulation or on an on going and as needed basis. In another embodiment of simulation in accelerated mode the graphical modeling environment may call a function application programming interface or link to and load a library or use any other suitable interface to invoke execution of the executable instructions generated in a compiled form by the code building tools 

In view of the structure functions and operations of the graphical modeling environment model compiler code building tool and other components of the present invention as described herein the present invention provides systems and methods for partitioning the model compilation of a block diagram model into separate or concurrent model processing tasks that can be executed independently. This allows portions of the model compilation process to occur concurrently on the same or multiple computing devices rather than subsequently. Furthermore the separate model processing tasks may be distributed to multiple computing devices or processors in order to leverage additional computing resources in performing model compilation. This distributed approach facilitates the reduction in model compilation time.

Many alterations and modifications may be made by those having ordinary skill in the art without departing from the spirit and scope of the invention. Therefore it must be expressly understood that the illustrated embodiments have been shown only for the purposes of example and should not be taken as limiting the invention which is defined by the following claims. These claims are to be read as including what they set forth literally and also those equivalent elements which are insubstantially different even though not identical in other respects to what is shown and described in the above illustrations.

