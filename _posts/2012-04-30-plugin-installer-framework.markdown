---

title: Plug-in installer framework
abstract: There is provided a system and method for providing a plug-in installer framework. The method includes creating an installer plug-in and reading configuration information with the installer plug-in. An application server may be contacted by the installer plug-in to determine which plug-in files to update in local storage. The updated plug-in files may be downloaded from an application server to local storage, and additional plug-ins may be created within the installer plug-in from the plug-in files in local storage. The additional plug-ins may be loaded through the installer plug-in within a host application.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09223594&OS=09223594&RS=09223594
owner: ExxonMobil Upstream Research Company
number: 09223594
owner_city: Houston
owner_country: US
publication_date: 20120430
---
This application is the National Stage entry under 35 U.S.C. 371 of PCT US2012 035858 that published as Intl. Patent App. Publication No. 2013 006226 and was filed on 30 Apr. 2012 which claims the benefit of U.S. Provisional Application No. 61 503 992 filed on 1 Jul. 2011 each of which is incorporated herein by reference in its entirety for all purposes.

The present technique relates to a plug in installer framework. In particular an embodiment of the present technique relates to a system and method for alleviating the restrictions imposed by plug in frameworks.

This section is intended to introduce various aspects of the art which may be associated with embodiments of the disclosed techniques. This discussion is believed to assist in providing a framework to facilitate a better understanding of particular aspects of the disclosed techniques. Accordingly it should be understood that this section is to be read in this light and not necessarily as admissions of prior art.

The developers of a software application may allow the application to have its functionality enhanced or modified after its original creation. The enhancements or modifications may be realized using a plug in framework. The additional libraries of a plug in may be dynamically loaded into memory at runtime by the executable application or one of its dependent libraries. Once loaded into memory the plug ins may interact with the software application via a series of pre defined interfaces provided by the software application also known as an Application Programming Interface API . Software applications that provide a plug in capability may also provide a mechanism whereby plug in libraries added to the software application subsequent to its original creation can be discovered. Discovering a plug in library may entail some type of configuration whereby the executable file or one of its dependent libraries can read the location of additional plug in libraries and dynamically load those libraries into memory.

Because plug in frameworks can be implemented using many different methods often there are restrictions that place constraints on third parties wishing to implement a plug in. These restrictions may be problematic in managed computing environments such as large corporate computing environments where an end user s ability to make updates to a local computing system is limited. Instead a member of an Information Technology IT staff with elevated privileges manually installs plug ins onto end users workstations. This solution may become time consuming and cost prohibitive if the number of users is large if the user base is geographically dispersed or if there are frequent updates to the plug ins to be installed. Moreover this solution can lead to further issues if the configuration information for multiple plug ins is commingled in a single configuration location such as a single configuration file. In such cases the updates to plug in configuration can carry additional risk of corrupting other plug ins or the host application itself. Another solution may include redeploying the entire host software application along with its associated plug ins each time a plug in is added or updated in the environment. While redeployment may help alleviate some of the potential corruption issues it does not overcome the issues of large disperse user groups and frequent updates. It may also carry the additional burden of requiring extensive retesting of the host application whenever a plug in update is performed.

U.S. Pat. No. 7 458 062 by Coulthard et al. hereinafter Coulthard discloses a framework for accessing a remote system from an integrated development environment. A connection registry contains objects and subsystem objects and the connection objects have attribute information for the remote system whereas the subsystem objects contain information specific to a particular tool and connection. Additionally the framework may include a common user interface by which tools can be registered within a connection or by which a new connection can be created. The framework may maintain connections and tools within an integrated development environment independent of the type of operating system used by the remote systems and the programming language of the tools.

The previously described methods may not function in the absence of a networked environment. Further these methods may allow use of plug ins only when the plug in meets a particular privilege level. Additionally these methods may not allow a user to select particular plug ins.

An embodiment of the present techniques provides a method for a plug in installer framework. An installer plug in may be created and configuration information may be read with the installer plug in. An application server may be contacted by the installer plug in to determine which plug in files to update in local storage. The updated plug in files may be downloaded from an application server to local storage and additional plug ins may be created within the installer plug in from the plug in files in local storage. The additional plug ins may be loaded through the installer plug in within a host application.

Another embodiment of the present techniques provides a system for a plug in installer framework including a processor an installer plug in module and a tangible machine readable storage medium. The system may read configuration information with the installer plug in module and contact an application server with the installer plug in module to determine which plug in files to update in local storage. The system may also download updated plug in files from an application server to local storage create additional plug ins within the installer plug in from the plug in files in local storage and load the additional plug ins through the installer plug in module in a host application.

Another embodiment of the present techniques provides a non transitory computer readable medium comprising code configured to direct a processor to provide a plug in installer framework. An installer plug in may be created and configuration information may be read with the installer plug in. An application server can be contacted with the installer plug in to determine which plug in files to update in local storage and updated plug in files may be downloaded from an application server to local storage. Additional plug ins may be created within the installer plug in from the plug in files in local storage and loaded through the installer plug in in a host application.

In the following detailed description section specific embodiments are described as examples. However to the extent that the following description is specific to a particular embodiment or a particular use this is intended to be for exemplary purposes only and simply provides a description of the exemplary embodiments. Accordingly the present techniques are not limited to embodiments described herein but rather it includes all alternatives modifications and equivalents falling within the spirit and scope of the appended claims.

At the outset and for ease of reference certain terms used in this application and their meanings as used in this context are set forth. To the extent a term used herein is not defined below it should be given the broadest definition persons in the pertinent art have given that term as reflected in at least one printed publication or issued patent.

The term Application Programming Interface API refers to a series of predefined interfaces provided by a software application. An API can be used to provide a particular set of rules and specifications that allow software programs to communicate with each other.

The term computer component refers to a computer related entity hardware firmware software a combination thereof or software in execution. For example a computer component can be but is not limited to being a process running on a processor a processor an object an executable a thread of execution a program and a computer. One or more computer components can reside within a process or thread of execution and a computer component can be localized on one computer or distributed between two or more computers.

The term file refers to a block of arbitrary information or resource for storing information such as executable instructions.

The term library file or library refers to a collection of executable instructions encompassing a portion of the overall software application.

The terms non transitory computer readable medium tangible machine readable medium or the like refer to any tangible storage that participates in providing instructions to a processor for execution. Such a medium may take many forms including but not limited to non volatile media and volatile media. Non volatile media includes for example NVRAM or magnetic or optical disks. Volatile media includes dynamic memory such as main memory. Computer readable media may include for example a floppy disk a flexible disk hard disk magnetic tape or any other magnetic medium magneto optical medium a CD ROM DVD ROM a holographic memory or any other optical medium a RAM a PROM and EPROM a FLASH EPROM a solid state medium like a memory card or any other memory chip or cartridge or any other physical medium from which a computer can read. When the computer readable media is configured as a database it is to be understood that the database may be any type of database such as relational hierarchical object oriented and or the like. Accordingly exemplary embodiments of the present techniques may be considered to include a tangible storage medium or tangible distribution medium and prior art recognized equivalents and successor media in which the software implementations embodying the present techniques are stored.

The term plug in may refer to a set of software components that adds specific abilities to a larger software application and may allow customizing the functionality of the application.

The term software includes but is not limited to one or more computer or processor instructions that can be read interpreted compiled or executed and that cause a computer processor or other electronic device to perform functions actions or behave in a desired manner. The instructions may be embodied in various forms like routines algorithms modules methods threads or programs including separate applications or code from libraries. Software may also be implemented in a variety of executable and or loadable forms including but not limited to a stand alone program a function call local and or remote a servelet an applet instructions stored in a memory part of an operating system or other types of executable instructions. It will be appreciated by one skilled in the art that computer readable and or executable instructions can be located in one logic and or distributed between two or more communicating co operating and or parallel processing logics and thus can be loaded or executed in serial parallel massively parallel and other manners.

The term system refers to any computer information or control device computing device devices or network of devices of hardware or software comprising processor means data storage means program means or user interface means. For example a system can refer to a phone tablet or any other computing device.

An embodiment provides a method of providing a plug in framework and may provide a system capable of alleviating the restrictions imposed by plug in frameworks. The system may function when end users do not have the ability to install software as is the case with managed computing systems. While for purposes of simplicity of explanation the illustrated methodologies are shown and described as a series of blocks it is to be appreciated that the methodologies are not limited by the order of the blocks as some blocks can occur in different orders and or concurrently with other blocks from that shown and described. Moreover less than all the illustrated blocks may be required to implement an example methodology. Blocks may be combined or separated into multiple components. Furthermore additional and or alternative methodologies can employ additional not illustrated blocks. While the figures illustrate various serially occurring actions it is to be appreciated that various actions could occur concurrently substantially in parallel and or at substantially different points in time.

At block the installer plug in may contact the application server to determine which plug in files should be updated in local storage. A file may be updated in local storage if the plug in files on the application server have been changed. At block updated plug in files are downloaded to local storage which can be any location on the end user s machine that does not require elevated privileges. At block the installer plug in creates each of the additional plug ins. The installer plug in may keep each additional plug in in its internal collection allowing each of those plug ins the chance to add its functionality to the host application whenever the installer plug in is called. Further the plug in files including files for the installer plug in and the additional plug ins may remain on local storage after the execution of the plug ins is terminated. At block additional plug ins may be loaded through the installer plug in within a host application. In this manner the additional plug ins function seamlessly within the host application.

The installer plug in conforms to the host application s defined application programming interface API and may be installed as prescribed by the host application. The host application plug in framework may define methods such as Initialize Register and Dispose . As the name suggests Initialize may create a plug in module. Register may allow the plug in module to add its functionality to the host application while Dispose may release the resources used by the plug in module. At runtime the host application may first create the installer plug in and call Initialize on the installer plug in.

The installer plug in may read the known configuration information . The configuration information may define the additional plug ins that will be loaded into the host application and where those additional plug ins are located on the application server . Moreover the installer plug in may contact the application server to determine which files need to be updated in local storage . For example if a change has occurred to the files for plug in A in the plug in package then the files for plug in A may need to be updated. Similarly if the files for a particular plug in do not exist on local storage then the files should be loaded from the plug in package to local storage . As discussed herein if the application server is not available the plug in files previously loaded to local storage will be available for use.

Updated files from the plug in package may be downloaded to local storage which can be any location on the end user s computer that does not require elevated privileges. For example on a Windows based machine this location could be a user specific folder in a local profile. On a Linux based machine this location could be a folder in the user s home directory. The installer plug in may load and create each of the additional plug ins with the plug in files downloaded from the plug in package . The installer plug in maintains an internal collection of the additional plug ins and is responsible for all interaction between the additional plug ins and the host application which is unaware of the additional plug in libraries. For ease of description only two additional plug ins are described however the present techniques may be used with many more additional plug ins.

When the host application calls the Register method on the installer plug in it will forward the request on to each of the additional plug ins plug in A and plug in B in its internal collection. Each of additional plug in A and additional plug in B may add its functionality to the host application through the installer plug in . To the end user of the host application additional plug in A and additional plug in B function normally as if they had been installed and configured directly by the host application . When the host application is terminated it may call Dispose on the installer plug in which will then forward the Dispose call to each additional plug in A and additional plug in B in its collection and then remove all entries from that collection.

The user may be able to use the storefront application to remove additional plug ins that have been previously had installed. When the user removes an additional plug in using the storefront application the storefront application may update the local configuration information to remove all references to the removed plug in. The storefront application may then delete the plug in files associated with those particular plug ins from the local storage. On subsequent launch of the host application the installer plug in finding no reference to the previously used additional plug ins in the configuration information may not invoke those particular plug ins as part of the host application .

The present techniques may automatically download and install plug in updates each time the host application is executed by the user. In such a scenario the application server may hold configuration information for each of the plug ins which lists the files required for that plug in and the versions of those files. Similarly the configuration information on the local store may hold this same information for the previous version of downloaded plug ins. After launch of the host application and creation of the installer plug in the installer plug in may compare the copy of the plug in configuration information in local storage with the current copy on the application server for each desired additional plug in. By performing a comparison of the list of files and their versions the installer plug in can determine which files have been updated on the application server and download only those specific updated files to the local storage prior to loading the plug ins. In this manner the user of the software application may receive automatic version updates to plug ins each time the host application is launched. As a result IT staff may be involved in merely updating of plug in files on the application server while not performing any action on the end user s system.

When particular plug ins are required the user may still have the ability to select which plug ins they desire to have installed within their local copy of the host software application. For a variety of reasons IT staff may want some plug ins to be required. Accordingly those required plug ins may not be able to be uninstalled by the end user. Referring again to in such an implementation of required plug ins the application server configuration may include a list of required plug ins. This list may be maintained on the application server by IT staff. Upon execution of the host application the installer plug in may read the list of required plug ins from the application server configuration and copy that configuration into the local device configuration information . The host application may then download and execute the required plug ins in the same manner that it downloaded and executed the user selected plug ins. The required plug ins may not appear in the storefront configuration information as required plug ins could neither be added nor removed by the user. Rather the required plug in configuration may appear on the application server .

The present techniques may allow software applications to continue to use plug ins installed by the installer plug in in situations where the local system on which the host software application is running is not connected to a network capable of reaching the application server. In such a scenario the local system is connected to the application server using a network when the user wishes to change the list of desired plug ins. However after an initial update to the list of available plug ins such a network connection may not be required. When the host software application invokes the installer plug in the installer plug in may determine whether the application server was reachable by the network. If the application server is available the installer plug in can proceed with checking for plug in updates as described herein. If the application server is not available the installer plug in may skip updating the plug ins and proceed to launch the installed plug ins available on the local system. The installer plug in may perform these steps on each launch of the host software application and automatic updates to each plug in may occur whenever the application server is available however updates can be skipped when the application server is not available. In this manner use of plug ins in a disconnected state may be efficiently provided.

By allowing IT staff to manage files and configurations on a centralized application and storefront servers and not manually updating the local system installations of the host application the techniques described herein may greatly reduce the time and effort required by IT staff. Further the present techniques may reduce the burden placed upon the end user. They receive automatic updates to their plug ins and the ability to self service the installation of new plug ins and uninstall plug ins they no longer need.

An example of an implementation of the present techniques is an installer plug in built for reservoir simulation. Reservoir simulation may be accomplished through various host applications including Windows based .NET applications for use by geoscientists in the oil and gas industry. Such applications typically have a plug in based architecture along with an API through which plug ins may provide a variety of functionality and extension points to the host application.

A host application may require a plug in to implement the APIModule interface shown in the code below.

The methods in the APIModule interface may be called in the order shown in the sample code above. Once the plug in implements the APIModule interface it may be installed into the host application by copying all the files required by the plug in into a sub directory of host application s installation directory. A file such as host.exe.config file an XML file located in the host application installation directory may be modified to include the new plug in. Installing files into a sub directory of the host application and modifying a configuration file shared by all installed plug ins as well as the host application itself causes adding plug in functionality to some host applications to be time consuming and cost prohibitive.

In an example implementation of the present techniques a PluginInstaller implementation of the APIModule interface is created. This PluginInstaller implementation may be installed into the host application using the host application plug in installation method described herein. When the host application calls the Initialize method on the PluginInstaller the PluginInstaller may first copy a list of required plug ins from an XML configuration file located on the application server to the local configuration directory defined by 

The PluginInstaller may load all of the configuration information for both the user defined and required plug ins into memory. Next the PluginInstaller may download any updates to the user defined or required plug ins that have occurred since the last download. The PluginInstaller may iterate through the list of plug ins to be initialized and load them into memory. Additionally the PluginInstaller can take the path to the root library called an assembly in .NET and loads that assembly into memory. By adding the path to the assembly to the codebase of the assembly name it enables the normal .NET assembly loading process to find and load any additional libraries required by the plug in provided they are installed in the same directory as the root assembly.

Once loaded into memory an instance of the concrete implementation of the APIModule interface for that plug in is created and returned as shown by the code below.

The PluginInstaller may then call the Inititalize method on each of the loaded plug ins. When Initialize is called on each of the plug ins they perform their normal initialization routine which may include interaction with the host application API. The plug ins may interact with the host application API directly and the plug ins have no knowledge of the PluginInstaller. Further the plug ins do not have to be written specifically for the PluginInstaller. The PluginInstaller may call the API method Initialize on the plug ins and at that point the plug ins have access to all services or modules that are made available by the host application. Similarly the PluginInstaller may call Incorporate and IncorporatePresentation on each of the plug ins. The plug ins may then perform individual Incorporate and IncorporatePresentation routines that may include interaction with the host application API.

After Incorporate and IncorporatePresentation have been called on each of the plug ins the plug ins are installed into the host application and function normally. However they are installed outside of the host application s application directory and perform no modification to the host.exe.config XML file. When the host application is closed the PluginInstaller can call Terminate on each of the plug ins. The APIModule interface itself implements IDisposable from the .NET framework. This interface provides a Dispose method for performing final cleanup. When the host application calls Dispose on the PluginInstaller the PluginInstaller may iterate through the plug ins in its internal collection and call the Dispose method of each plug in.

The computer system may also include computer components such as non transitory computer readable media. Examples of computer readable media include a random access memory RAM which may be SRAM DRAM SDRAM or the like. The computer system may also include additional non transitory computer readable media such as a read only memory ROM which may be PROM EPROM EEPROM or the like. RAM and ROM hold user and system data and programs as is known in the art. The computer system may also include an input output I O adapter a communications adapter a user interface adapter and a display adapter .

The I O adapter may connect additional non transitory computer readable media such as a storage device s including for example a hard drive a compact disc CD drive a floppy disk drive a tape drive and the like to computer system . The storage device s may be used when RAM is insufficient for the memory requirements associated with storing data for operations of embodiments of the present techniques. The data storage of the computer system may be used for storing information and or other data used or generated as disclosed herein. For example storage device s may be used to store configuration information or additional plug ins in accordance with an embodiment of the present techniques. Further user interface adapter couples user input devices such as a keyboard a pointing device and or output devices to the computer system . The display adapter is driven by the CPU to control the display on a display device to for example present information to the user regarding available plug ins.

The architecture of system may be varied as desired. For example any suitable processor based device may be used including without limitation personal computers laptop computers computer workstations and multi processor servers. Moreover embodiments may be implemented on application specific integrated circuits ASICs or very large scale integrated VLSI circuits. In fact persons of ordinary skill in the art may use any number of suitable structures capable of executing logical operations according to the embodiments. In an embodiment input data to the computer system may include various plug ins and library files. Input data may additionally include configuration information.

The present techniques may be susceptible to various modifications and alternative forms and the exemplary embodiments discussed above have been shown only by way of example. However the present techniques are not intended to be limited to the particular embodiments disclosed herein. Indeed the present techniques include all alternatives modifications and equivalents falling within the spirit and scope of the appended claims.

