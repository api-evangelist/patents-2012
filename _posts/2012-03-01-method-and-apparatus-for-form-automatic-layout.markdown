---

title: Method and apparatus for form automatic layout
abstract: A method and apparatus are provided for determining the layout of a form automatically to accommodate text in the form. Under the method and apparatus, a set of parameters define the sizing and alignment of elements of the form. Sizing and positioning instructions that are separate from the sizing and alignment parameters set the sizing and positioning of elements of the form based on the sizing and alignment parameters. The instructions determine the minimum size for the form, based in part on text in the form. The difference between the minimum size for the form and a desired size for the form is then distributed across the form to size and position the elements in the form.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09250929&OS=09250929&RS=09250929
owner: CALLAHAN CELLULAR L.L.C.
number: 09250929
owner_city: Wilmington
owner_country: US
publication_date: 20120301
---
This application is a continuation of and claims priority to each of U.S. patent application Ser. No. 12 546 240 now U.S. Pat. No. 8 151 181 filed Aug. 24 2009 entitled METHOD AND APPARATUS FOR FORM AUTOMATIC LAYOUT which is a continuation of U.S. patent application Ser. No. 11 035 666 filed on Jan. 14 2005 now U.S. Pat. No. 7 581 169 entitled METHOD AND APPARATUS FOR FORM AUTOMATIC LAYOUT the entireties of which applications are incorporated herein by reference.

The present invention relates to forms displayed on computing systems. In particular the present invention relates to the layout of elements in these forms.

In computerized systems forms are used to provide a graphical user interface that allows users to type in text select entries and control operation of an application by manipulating displayed controls. Designing such forms involves placing controls such as text boxes check boxes combo boxes buttons and labels on the form and programming the operations of each control.

Many of the controls include text. For example a button may have the word Cancel on it and a label may have the text Topic. 

To support the distribution of software in multiple languages the text that is applied to controls is often stored in a resource file. This allows the text to be converted to a different language without requiring recompiling of the code that defines the form.

Ideally the text for each control would occupy the same amount of space on the display regardless of the language it is written in. However translation of the text from one language to another often involves a change in the number of characters that represent the word. As a result a word in one language will require more display space than the same word in another language.

One technique for accommodating the increase in character length that can occur during translation of the text is to layout the form to accommodate the largest text strings of any of the languages that will be used in the form. This is undesirable because it requires the developer to consider every language that the form may be used in and it results in a form that has a great deal of wasted space.

Another technique for handling changes in text sizes due to translations is to change the layout of each form for each language so that the form is optimized for each language. For applications that have a large number of forms this involves a great deal of work in order to make the application available for a large number of languages.

A third technique is to build a custom layout engine for the form that will move controls within the form based on the size of the text associated with the controls. The parameters for controlling this change in the layout are programmed and compiled with the form. As a result it is very difficult to change the alignment and growth properties that are used by the automatic layout process. In particular in order to change the layout formed by the automatic layout engine the alignment and growth properties associated with various controls on the form must be changed in the programming source code for the form. This source code is then recompiled and re tested. This is time consuming and requires expertise in the programming source code.

Thus it is desirable to have a system that allows for automatic layout of forms to accommodate different text lengths due to language translations while at the same time facilitating changes in how the automatic layout is performed without requiring recompiling of the source code for the form.

A method and apparatus are provided for determining the layout of a form automatically to accommodate text in the form. Under the method and apparatus a set of parameters define the sizing and alignment of elements of the form. Sizing and positioning instructions that are separate from the sizing and alignment parameters set the sizing and positioning of elements of the form based on the sizing and alignment parameters. The instructions determine the minimum size for the form based in part on text in the form. The difference between the minimum size for the form and a desired size for the form is then distributed across the form to size and position the elements in the form.

The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems environments and or configurations that may be suitable for use with the invention include but are not limited to personal computers server computers hand held or laptop devices multiprocessor systems microprocessor based systems set top boxes programmable consumer electronics network PCs minicomputers mainframe computers telephony systems distributed computing environments that include any of the above systems or devices and the like.

The invention may be described in the general context of computer executable instructions such as program modules being executed by a computer. Generally program modules include routines programs objects components data structures etc. that perform particular tasks or implement particular abstract data types. The invention is designed to be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment program modules are located in both local and remote computer storage media including memory storage devices.

With reference to an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer may include but are not limited to a processing unit a system memory and a system bus that couples various system components including the system memory to the processing unit . The system bus may be any of several types of bus structures including a memory bus or memory controller a peripheral bus and a local bus using any of a variety of bus architectures. By way of example and not limitation such architectures include Industry Standard Architecture ISA bus Micro Channel Architecture MCA bus Enhanced ISA EISA bus Video Electronics Standards Association VESA local bus and Peripheral Component Interconnect PCI bus also known as Mezzanine bus.

Computer typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer and includes both volatile and nonvolatile media removable and non removable media. By way of example and not limitation computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Computer storage media includes but is not limited to RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical disk storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions data structures program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term modulated data signal means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation communication media includes wired media such as a wired network or direct wired connection and wireless media such as acoustic RF infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.

The system memory includes computer storage media in the form of volatile and or nonvolatile memory such as read only memory ROM and random access memory RAM . A basic input output system BIOS containing the basic routines that help to transfer information between elements within computer such as during start up is typically stored in ROM . RAM typically contains data and or program modules that are immediately accessible to and or presently being operated on by processing unit . By way of example and not limitation illustrates operating system application programs other program modules and program data .

The computer may also include other removable non removable volatile nonvolatile computer storage media. By way of example only illustrates a hard disk drive that reads from or writes to non removable nonvolatile magnetic media a magnetic disk drive that reads from or writes to a removable nonvolatile magnetic disk and an optical disk drive that reads from or writes to a removable nonvolatile optical disk such as a CD ROM or other optical media. Other removable non removable volatile nonvolatile computer storage media that can be used in the exemplary operating environment include but are not limited to magnetic tape cassettes flash memory cards digital versatile disks digital video tape solid state RAM solid state ROM and the like. The hard disk drive is typically connected to the system bus through a non removable memory interface such as interface and magnetic disk drive and optical disk drive are typically connected to the system bus by a removable memory interface such as interface .

The drives and their associated computer storage media discussed above and illustrated in provide storage of computer readable instructions data structures program modules and other data for the computer . In for example hard disk drive is illustrated as storing operating system application programs other program modules and program data . Note that these components can either be the same as or different from operating system application programs other program modules and program data . Operating system application programs other program modules and program data are given different numbers here to illustrate that at a minimum they are different copies.

A user may enter commands and information into the computer through input devices such as a keyboard a microphone and a pointing device such as a mouse trackball or touch pad. Other input devices not shown may include a joystick game pad satellite dish scanner or the like. These and other input devices are often connected to the processing unit through a user input interface that is coupled to the system bus but may be connected by other interface and bus structures such as a parallel port game port or a universal serial bus USB . A monitor or other type of display device is also connected to the system bus via an interface such as a video interface . In addition to the monitor computers may also include other peripheral output devices such as speakers and printer which may be connected through an output peripheral interface .

The computer is operated in a networked environment using logical connections to one or more remote computers such as a remote computer . The remote computer may be a personal computer a hand held device a server a router a network PC a peer device or other common network node and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in include a local area network LAN and a wide area network WAN but may also include other networks. Such networking environments are commonplace in offices enterprise wide computer networks intranets and the Internet.

When used in a LAN networking environment the computer is connected to the LAN through a network interface or adapter . When used in a WAN networking environment the computer typically includes a modem or other means for establishing communications over the WAN such as the Internet. The modem which may be internal or external may be connected to the system bus via the user input interface or other appropriate mechanism. In a networked environment program modules depicted relative to the computer or portions thereof may be stored in the remote memory storage device. By way of example and not limitation illustrates remote application programs as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.

Memory is implemented as non volatile electronic memory such as random access memory RAM with a battery back up module not shown such that information stored in memory is not lost when the general power to mobile device is shut down. A portion of memory is preferably allocated as addressable memory for program execution while another portion of memory is preferably used for storage such as to simulate storage on a disk drive.

Memory includes an operating system application programs as well as an object store . During operation operating system is preferably executed by processor from memory . Operating system in one preferred embodiment is a WINDOWS CE brand operating system commercially available from Microsoft Corporation. Operating system is preferably designed for mobile devices and implements database features that can be utilized by applications through a set of exposed application programming interfaces and methods. The objects in object store are maintained by applications and operating system at least partially in response to calls to the exposed application programming interfaces and methods.

Communication interface represents numerous devices and technologies that allow mobile device to send and receive information. The devices include wired and wireless modems satellite receivers and broadcast tuners to name a few. Mobile device can also be directly connected to a computer to exchange data therewith. In such cases communication interface can be an infrared transceiver or a serial or parallel communication connection all of which are capable of transmitting streaming information.

Input output components include a variety of input devices such as a touch sensitive screen buttons rollers and a microphone as well as a variety of output devices including an audio generator a vibrating device and a display. The devices listed above are by way of example and need not all be present on mobile device . In addition other input output devices may be attached to or found with mobile device within the scope of the present invention.

The present invention provides a method and apparatus for automatically laying out forms based on the size of text in the form by utilizing a set of automatic layout parameters that are separate from the automatic layout code.

Once form tree has been constructed form code triggers an ON LAYOUT event. This event causes a procedure in the form to call auto layout code . Auto layout code uses form tree and a set of auto layout parameters to position and align the controls within the form. Auto layout parameters define the alignment and growth parameters of the various controls in the forms. In one embodiment auto layout parameters are provided as an eXtensible Markup Language XML document.

Since auto layout parameters are separate from auto layout code and form code auto layout code and form code do not need to be recompiled in order to change the manner in which auto layout code aligns the control elements of the form during the automatic layout process.

In the example above the auto layout parameters for an application are defined within tags. Within the tags three types of entities are defined. A container entity defined between tags is an entity that may hold a collection of control elements. Examples of such entities include forms and panels. The second type of entity defined in the form auto layout definition is a grid entity defined within tags. A grid entry is a virtual entity that does not appear on the rendered form. Instead a grid entity defines a set of rows and columns that are used to position child entities defined within the tags. Such child entities can include child grid entities. The third type of entity defined in the form auto layout definition is a control entity. Each control entity is associated with a control element in the form such as a panel a button a label or a box.

The position of a grid entity or a control entity is defined within a set of and tags within the entities outer tags. The value between the tags indicates the virtual column that the entity begins in and the value in the tags indicates the virtual row that the entity begins in. Grid and control entities may span more than one column or row. The number of columns spanned by an entity is designated by a value between tags and the number of rows that the entity spans is designated between tags. Under one embodiment of the present invention the rows and columns are numbered beginning with the value of zero and increasing with each column in a left to right manner and increasing with each row in a top to bottom manner. In addition an entity that occupies a single row or a single column is said to span zero columns or rows. Thus an entity that occupies three columns will have a SPANX value of 2.

The space where an entity may be located within the rows and columns it occupies can be limited by setting padding values that define pads or margins along the edges of the rows and columns occupied by the entity. In particular a value between tags indicates the size of a pad in pixels that extends from the top most edge of the top most row spanned by the entity the value in the tags indicates the size of a pad in pixels that extends upward from the bottom edge of the bottom most row spanned by the entity the value in the tags indicates the size of a pad in pixels extending to the right from the left edge of the left most column and the value in the tags indicates the size of a pad in pixels extending to the left from the right edge of the right most column spanned by the entity. Note that although the sizes of the pads are described above in terms of pixels in other embodiments other distance measures may be used including logical measures that allow scaling.

Within the space defined by the inner edges of the padding the entity may be aligned horizontally in one of four different ways and vertically in one of four different ways. The horizontal and vertical alignments are designated in tags and tags respectively. The possible values for the horizontal and vertical alignments are 

Grid entities include tags and tags which are used to designate those rows and columns within the grid that are to be expanded when distributing excess space across the grid. This excess space is the difference between the minimum size for the grid and the desired size for the grid. When rows or columns are designated as growing rows or growing columns only those rows or columns are expanded when assigning excess space. If no rows are designated as growing rows the excess space in the vertical direction is distributed evenly across all rows of the grid. If no columns are designated as growing columns the excess space in the horizontal direction is distributed evenly across all columns of the grid.

The grid definition also includes tags for and . Rows or columns that are found between a set of group rows or grouped columns are forced to have the same size as each other. Thus if one column in a set of group columns has its size increased all of the other columns in the group must have their size increased to match. Multiple sets of grouped rows and grouped column tags may be present in a grid definition.

For a control entity a set of tags is provided for determining the minimum size of the control. One set of tags and designate the minimum vertical and horizontal size respectively in terms of pixels for the control entity. The tag takes Boolean values and indicates whether the minimum size of the control is to be set based on the text associated with the control. When this Boolean value is true auto layout code determines the minimum size of the control by requesting the size of the text that has been associated with the control in form tree . Many operating systems provide functions that return the size of text given the text its font and its font size. The size of the text is returned in terms of pixels.

Control nodes may also include tags for defining padding between the edges of the text and the edges of the control. This padding is defined in terms of pixels by designating values between the tags and the tags .

Each control includes a pair of tags that have a name value that associates the control with its definition in form tree . Thus the name of the control in the tags corresponds to the name of the control in form tree .

As shown in the example above grid nodes may be nested within each other to form a hierarchy of grids. Containers are not nested within each other.

In step the size for the entire form is obtained. This size is typically set in the instructions that instantiate the form. At step the minimum size for the form is determined. This minimum size is based on the minimum size of the controls in the form. For those controls that use the text size as their minimum the minimum size of the controls is determined based on the text assigned to the controls. The process for determining the minimum size of a control is discussed further below in connection with . After the minimum size of the form has been determined the difference between the desired size for the form determined in step and the minimum size determined in step is distributed as excess size within the form at step . Once the excess space has been distributed within the form the process ends at step .

When a child entity selected at step is a control entity at step the process of determines if the minimum size for the control can be determined within the current container definition at step . The minimum size for a control is determinable within a current container definition if values are provided for the and tags or if the tags are set to True. If the tags are set to False and no or value has been set for the control the minimum size for the control cannot be determined from the current container definition. This can occur when the control represents a container and the minimum size of that container can only be determined through the container definition associated with that control. For example a panel will appear as a control in a container definition. However the minimum size of the panel will often be defined through the panel s own container definition.

In if the minimum size is not determinable within the current container definition at step the process continues at step where the container referenced by the control is set as the current container and as the parent entity. The process then returns to step to select a child entity of the referenced container. For example in the layout above when the control definition for the Panel control is selected at step its minimum size cannot be determined. As a result the container definition for Panel which is found between tags that include a pair of tags with the value of Panel is set as the current container and is set as the parent entity in step . A child entity of that container definition is then selected at step . Thus using steps and the present invention is able to perform a recursion into imbedded containers defined within a larger container.

If the minimum size of the selected control node can be determined at step its minimum size is determined at step . To determine the minimum size of a control node the method first looks at the value to see if it has been set to False. If it has been set to False the initial minimum sizes of the control are determined by the sizes set in the and tags.

If the value is True the process requests the minimum size required for the text associated with the control. For example for HELP button the process would request the text associated with the button from the form tree . This text would then be passed to an operating system method that will return the vertical and horizontal dimensions of the text in terms of pixels. Once the dimensions of the text have been returned to the process the vertical dimensions of the text are compared to the minimum size set in the tags and the horizontal dimensions are compared to the minimum size set in the tags. The larger of the two horizontal values is then selected as the initial minimum horizontal dimension for the control and the larger of the two vertical dimensions is selected as the initial minimum vertical dimension for the control.

The initial minimum horizontal dimension for the control is then added to the value provided in the tags if any and to the values provided in the and tags if any to determine the final minimum horizontal dimension of the control. Similarly the initial minimum vertical dimension for the control is added the value in the tags if any and to the values in the and tags if any to determine the final minimum vertical dimension for the control.

After the minimum size has been determined for the control at step the process of continues at step where it determines if there are more child entities in the parent entity. If there are more child entities the next child entity is selected at step . If there are no more entities in the parent entity the process continues at step where it determines if the parent entity is a grid. If the parent entity is grid the process continues at step where the minimum sizes of the child entities in the grid are used to determine the minimum size of the parent grid. The parent grid is then set as the current entity.

Thus if three columns were grouped together and a zero span child entity has a horizontal dimension of 10 in the first column and a zero span child entity has a horizontal dimension of 25 in a second column all of the columns in the group would have their horizontal dimension set to 25. Similarly in a group of rows if a zero span child entity has a vertical dimension of 15 in a first row and a zero span child entity in a second row has a vertical dimension of 8 all of the vertical dimensions for the rows in the group would be set to 15. Steps and are repeated until all of the groups for the grid have been processed.

At step a non zero span child entity of the grid is selected. At step all of the growable columns and rows spanned by the child entity are expanded uniformly to meet the minimum size required for the child entity. For example if a child entity spans two columns but only one of the columns is growable only that column will be grown horizontally to accommodate the minimum required for the child entity. Note that columns are grown horizontally and rows are grown vertically and that all columns extend the entire length of the grid and all rows extend the entire width of the grid.

At step rows and columns grouped with rows and columns that were expanded in step are also expanded so that their size matches the size of the rows and columns that were expanded at step . This ensures that all grouped rows and columns have the same dimensions. At step the process determines if there are more non zero span child entities of the grid. If there are more non zero span child entities the next non zero span child entity is selected at step and steps and are repeated.

When there are no more non zero span child entities at step the process continues at step where the horizontal dimensions of all of the columns in the grid are summed to provide the horizontal dimension of the grid and the vertical dimensions of all of the rows in the grid are summed to provide the vertical dimension of the grid. At step padding values associated with the and tags of the grid are added to the vertical dimension of the internal size of the grid and padding values associated with the and tags of the grid are added to the horizontal dimension of the internal size of the grid to provide the final size for the grid at step .

Returning to after the minimum size of the grid has been determined at step and the grid has been set as the current entity the process returns to step to determine if there are more child entities for the parent of the grid. If there are more child entities the process returns to step . Through steps and the process of FIG. is able to step back up to the parent entity after performing the recursion for the grid.

When the parent entity of the current entity is not a grid node at step the process continues at step where it determines if the current container is top container. Note that the only time a parent entity will not be equal to a grid in step is when the parent entity is a container. If the current container is not the top container for example if the current container represents a panel that is found within a form container the process continues at step where the minimum size of the control that references the current container is set equal to the size of the current container. In addition the control that references the current container is set as the current entity. The parent container of the current container is then set as the current container and the process returns to step . Thus through steps and after determining the minimum size recursively for a nested container the process returns to processing the parent entity in which the nested container is referenced.

When the process reaches step and the current container is the top container the minimum size for the form is set equal to the minimum size determined for the root grid entity of the form. This is shown as step in .

The size of the columns and rows define a space that is reduced based on the padding associated with the child entity. Within the space left after padding the child entity can be positioned at the edges of the space if the alignment properties are MAX or MIN or in the center of the space if the alignment properties are CENTER. In addition the child entity can be positioned across the entire space after padding if the alignment properties are set to STRETCH.

After the position and size of the selected entity has been determined at step the process determines if the selected entity is a grid entity at step . If the selected entity is not a grid entity but instead a control entity the process determines if the control entity has an associated container definition and therefor represents an embedded container at step . If the entity is a container its container definition is set as the current container at step and the process returns to step to set the current container as the parent entity. In this manner the process of is able to recursively move down through container entities that are embedded into other container nodes. If the control entity does not represent a container at step the process returns to step to select the next child entity of the parent entity.

If the entity selected at step is a grid at step the process continues at step where the difference between the size determined for the entity at step and the minimum size for the grid is distributed as extra space uniformly over all the growable columns rows of the grid. If none of the columns or rows are listed as growable the extra space is distributed uniformly across all columns and rows. For example if rows and were growable the vertical extra space would be divided in two and assigned equally to rows and . The vertical dimensions of rows and would be left at the minimum vertical space. However if none of the rows were designated as being growable the extra vertical space would be distributed evenly across all four of the rows.

After the extra space for the grid has been distributed across the growable columns rows the grid entity is set as the parent entity at step . The process then determines if there are child entities for the new parent entity at step . If there are child entities the process returns to step to select one of the child entities. The newly sized rows and columns of the grid are then used to resize the child entity through step .

When there are no more child entities at step the process continues at step where it determines if the parent grid is the root grid entity for a container. If parent grid is not a root grid entity the process continues at step where it sets the parent of the grid entity which is the grandparent of the current child entity as the parent entity. Thus when a grid appears as a child entity of another grid step will return to the processing of the upper level grid after the lower level grid has been expanded.

When the parent grid is the root grid entity for a container at step the process continues at step where it determines if the root grid entity is in a form container. If it is not in a form container the parent container to the current container is set as the current container at step . The process then returns to step to set the current container as the parent entity. This allows the process to return to the expansion of a parent container after expanding an embedded container.

When the parent root grid is in a form container at step all of the nested grids and containers have been expanded and all of the control nodes have been sized and positioned in the form. The process then ends at step .

In some embodiments the minimum size of form is determined for the horizontal dimension and then the vertical dimension. The excess space is then distributed along the horizontal dimension and then the vertical dimension. In other embodiments the minimum size is determined for the horizontal dimension and then the excess horizontal space is distributed along the horizontal dimension. The minimum size along the vertical dimension is then determined followed by the distribution of excess space along the vertical dimension.

In one embodiment tags are provided for control entities that allow the minimum size of the vertical dimension to be based on the final horizontal dimension of the control. In particular these tags allow controls to be sized to accept lines of text that have the property of wrapping to fill a space. Such text will form multiple lines of text that fill the horizontal space provided for the text. Under such embodiments the final horizontal size for the control is determined first by determining the minimum horizontal size of the form and distributing the excess horizontal space as discussed above. Once this size is set a routine is called to determine how many lines the text will occupy given the horizontal space it occupies. The number of lines of text and the size of the text are then used to derive the minimum vertical size for the text. This minimum size is then used to determine the minimum vertical size of the form as discussed above. The excess vertical size can then be distributed.

Although the present invention has been described with reference to particular embodiments workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention.

