---

title: Method for compiling a parallel thread execution program for general execution
abstract: A technique is disclosed for executing a compiled parallel application on a general purpose processor. The compiled parallel application comprises parallel thread execution code, which includes single-instruction multiple-data (SIMD) constructs, as well as references to intrinsic functions conventionally available in a graphics processing unit. The parallel thread execution code is transformed into an intermediate representation, which includes vector instruction constructs. The SIMD constructs are mapped to vector instructions available within the intermediate representation. Intrinsic functions are mapped to corresponding emulated runtime implementations. The technique advantageously enables parallel applications compiled for execution on a graphics processing unit to be executed on a general purpose central processing unit configured to support vector instructions.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09361079&OS=09361079&RS=09361079
owner: NVIDIA Corporation
number: 09361079
owner_city: Santa Clara
owner_country: US
publication_date: 20120130
---
The invention relates generally to compiler systems and more specifically to a method for compiling a parallel thread execution program for general execution.

Certain computer systems include a parallel processing subsystem that may be configured to concurrently execute multiple program threads that are instantiated from a common application program. Such systems are able to execute multiple instances of at least a portion of the application program in parallel to achieve execution speedup. CUDA is a parallel programming model known in the art for application programs that may be compiled to execute on parallel processing subsystems. An application program written for CUDA may include sequential C language programming statements and calls to a specialized application programming interface API used for configuring and managing parallel execution of program threads. A function associated with a CUDA application program that is destined for concurrent execution on a parallel processing subsystem is referred to as a kernel function. An instance of a kernel function is referred to as a thread and a set of concurrently executing threads may be organized as a thread block. A set of thread blocks may further be organized into a grid. Each thread is identified by an implicitly defined set of index variables. Each thread may access their instance of the index variables and act independently with respect to other threads based on the index variables.

An application program may include certain compiled functions for execution on a general purpose central processing unit CPU and other functions compiled for execution on a parallel processing subsystem. The functions compiled for execution on the CPU typically include native CPU instructions. The functions compiled for execution on the parallel processing subsystem typically include instructions for a virtual machine instruction set architecture ISA that may be mapped to a native ISA associated with the particular parallel processing subsystem. One virtual machine ISA known in the art is the parallel thread execution PTX ISA which is designed to provide a stable programming model and instruction set for general purpose parallel processing. When an application program comprising compiled PTX kernel functions is loaded for execution within a computer system the PTX kernel functions are mapped to the ISA of a parallel processing subsystem within the computer system. Certain parallel processing constructs are provided by the parallel processing subsystem such as thread synchronization thread identification and certain specialized graphics operations such as texture map sampling.

In certain scenarios a user may wish to execute an existing application program that is compiled for distribution to customers on a general purpose central processing unit CPU rather than on a parallel processing subsystem. Unfortunately conventional CPUs are typically configured to execute only native instructions and do not include parallel processing constructs for execution of PTX operations. As a consequence the existing application program may not be conventionally executed on a general purpose CPU.

As the foregoing illustrates what is needed in the art is a technique for executing a compiled parallel application program on a general purpose CPU.

One embodiment of the present invention sets forth a computer implemented method for executing a multi threaded program on a general purpose processor comprising translating the multi threaded program into an intermediate representation including at least one parallel function partitioning each parallel function within the intermediate representation into at least one operation group classifying each operation group as either scalar or vectorizable transforming each vectorizable operation group into vector instructions corresponding to computations performed by two or more threads when executing the multi threaded program and generating native executable code for the general purpose processor to process.

Other embodiments of the present invention include without limitation a computer readable storage medium including instructions that when executed by a processing unit cause the processing unit to perform the techniques described herein.

One advantage of the disclosed technique is that programs compiled for multi threaded execution on a parallel processing subsystem may be efficiently and advantageously executed instead on a general purpose processor.

In the following description numerous specific details are set forth to provide a more thorough understanding of the invention. However it will be apparent to one of skill in the art that the invention may be practiced without one or more of these specific details. In other instances well known features have not been described in order to avoid obscuring the invention.

In one embodiment the graphics subsystem incorporates circuitry optimized for graphics and video processing including for example video output circuitry and constitutes a graphics processing unit GPU . In another embodiment the graphics subsystem may be integrated with one or more other system elements such as the memory bridge CPU and I O bridge to form a system on chip SoC .

It will be appreciated that the system shown herein is illustrative and that variations and modifications are possible. The connection topology including the number and arrangement of bridges the number of CPUs and the number of graphics subsystems may be modified as desired. For instance in some embodiments system memory is connected to CPU directly rather than through a bridge and other devices communicate with system memory via memory bridge and CPU . In other alternative topologies graphics subsystem is connected to I O bridge or directly to CPU rather than to memory bridge . In still other embodiments I O bridge and memory bridge might be integrated into a single chip. Certain embodiments may include two or more CPUs and two or more graphics subsystems . The particular components shown herein are optional for instance any number of add in cards or peripheral devices might be supported. In some embodiments switch is eliminated and network adapter and add in cards connect directly to I O bridge .

A GPU code translator module translates the parallel thread execution code to corresponding native executable GPU code comprising native instructions for the graphics subsystem of . Any synchronization barriers within the parallel thread execution code are implemented using native constructs available within the graphics subsystem . Furthermore any special operations such as texture sampling operations are implemented by corresponding functional units within the graphics subsystem . In one embodiment the GPU code translator module resides within the software device driver which is configured for execution by the CPU . In alternative embodiments the GPU code translator module resides within a developer tool chain such as an offline compiler. The GPU code translator module may implement just in time JIT compilation to generate the native executable GPU code . The path from parallel application source code through execution on the graphics subsystem represents a conventional technique for executing a parallel application.

Embodiments of the present invention define a technique for translating parallel thread execution code to native executable CPU code for execution on the CPU . A CPU translator module translates the parallel thread execution code to corresponding native executable CPU code comprising native instructions for the CPU . Certain special operations such as texture sampling operations are implemented as function calls to a library of corresponding methods. Furthermore synchronization barriers within the parallel thread execution code are transformed for serial execution as corresponding synchronization barriers within the native executable CPU code . Computations that depend on a thread identification number threaded may be remapped for execution as vector operations on the CPU while computations that do not depend on threaded are remapped as scalar computation. The parallel thread execution code may be mapped to one or more cores within the CPU . When two or more cores are available within the CPU the mapped threads may execute concurrently for higher performance.

The CPU code translator implements a PTX parser which interprets the parallel thread execution code to generate an intermediate representation of the parallel thread execution code . The intermediate representation comprises generic instructions for specifying computations and control flow for the parallel thread execution code . In one embodiment an intermediate representation is implemented based on the well known low level virtual machine LLVM system. In this embodiment the CPU code translator uses LLVM optimization and code generation to generate the native executable CPU code . The CPU code translator implements certain transforms on the parallel thread execution code to generate the intermediate representation. These include without limitation identification of each parallel kernel function and construction of a corresponding LLVM function local variable and storage allocation and translation of each PTX instruction to one or more LLVM instructions. For certain types of parallel thread computation constructing an LLVM function from a given parallel kernel involves transforming computations associated with a set of parallel threads to a loop that sequentially executes the computations while changing one or more thread ID variables. Vectorization allows computation associated with four corresponding original threads to execute within an SSE regime per loop iteration. Scalar operations are computed redundantly by each parallel thread. Because results of these scalar operations are identical across the parallel threads scalar operations need only be computed once by CPU in the native executable code .

In addition to translating PTX code to an LLVM intermediate representation certain LLVM intrinsic functions are added as part of a runtime environment to enable complete and correct execution of the parallel thread execution code . Intrinsic functions comprise native operations implemented within the graphics subsystem that have no direct mapping to a particular instruction implemented within the CPU . These include without limitation built in variable access functions for thread identification block identification block dimension and grid dimension certain transcendental operations thread synchronization texture sampling and atomic memory access. Persons skilled in the art will recognize that different techniques may be used to perform the above transformations and translations from PTX to an intermediate representation and from the intermediate representation to the native executable CPU code without departing the scope and spirit of the present invention.

The method begins in step where the CPU code translator parses the parallel thread execution code comprising PTX instructions. In step the CPU code translator translates parsed PTX instructions to an LLVM intermediate representation for the instructions. In step the CPU code translator partitions the intermediate representation into groups of parallel operations associated with a particular kernel function. Each kernel function may comprise scalar operations parallel vectorizable operations or any combination thereof. In one embodiment vectorizable operations are transformed from individual parallel thread operations to vector computations to be performed in groups of operations that are structured as SSE vector instructions. Persons skilled in the art will recognize that a given group may be executed without requiring a synchronization step. However synchronization should be performed across different groups. In step the CPU code translator classifies operations within the intermediate representation as either vector or scalar operations. As described previously in the vector instructions compute results for a set of operations otherwise computed separately by individual parallel threads. Operations that receive thread identification information as an input are generally vectorizable while operations that do not take thread identification information as an input are generally scalar operations. In step the CPU code translator optimizes operations comprising vector instructions and scalar instructions using any technically feasible optimization techniques. Each group of operations is transformed into a loop construct for execution. Each loop construct encompassing a given group of transformed operations is structured to represent an equivalent set of arithmetic or logical operations on equivalent input data that could otherwise be performed by individually executing threads. In step intrinsic functions specified in the parallel thread execution code are bound to corresponding run time implementations. These intrinsic functions include without limitation built in variable access functions for thread identification and configuration information certain transcendental operations thread synchronization texture sampling and atomic memory access. At this point the intermediate representation is complete and ready to be converted into executable code for a target CPU such as CPU .

In step the CPU code translator generates native executable CPU code for execution on CPU . The code may include constructs for executing on multiple CPU cores and executing multiple simultaneous arithmetic operations via vector instructions such as SSE instructions. In particular the native executable CPU code is generated to include CPU instructions for a CPU thread that performs operations associated with a thread block originally specified within the parallel thread execution code e.g. PTX code . In this way operations associated with a given thread block may execute as a set of operations within a single CPU thread. The CPU thread may require a synchronization barrier for synchronization with a different CPU thread that is executing operations associated with a different thread block. Each CPU thread may represent a mapping from a plurality of individual vectorizable operations within a thread block into a smaller number of vector instructions such as SSE instructions within an appropriate loop construct formed by CPU instructions. The loop construct is configured to perform a set of operations that identically correspond to operations performed by a thread block within the parallel thread execution code . Similarly each CPU thread may also represent a mapping from a plurality of individual scalar operations within a thread block to corresponding CPU instructions within the CPU thread. In general mapping scalar instructions associated with threads comprising a thread block to a CPU thread may be a many to one mapping because identical results are typically computed by each original scalar operation. A plurality of CPU threads may execute concurrently to perform operations associated with multiple thread blocks which may be concurrent thread blocks. Persons skilled in the art will recognize that a given operation specified within the parallel thread execution code may correspond to one or more PTX instructions and the operation may map to one or more CPU instructions. Any technically feasible technique may be implemented to optimize CPU instructions generated from the intermediate representation of the PTX instructions. Such optimization may include mapping vectorizable instructions into SSE instructions within a loop construct and the like. In step the CPU code generator saves the native executable CPU code . In one embodiment the CPU code generator saves the native executable CPU code within a fat binary such as fat binary of . The method terminates in step .

In sum a technique for transforming a compiled multi threaded program into an executable vectorized program for execution on a general purpose processor is disclosed. The technique includes translating the compiled multi threaded program into a generic intermediate representation that remaps certain individual thread computations into a set of vector operations for execution on a general purpose central processing unit configured to execute vector instructions.

One advantage of the disclosed technique is that programs compiled for multi threaded execution on a parallel processing subsystem may be efficiently and advantageously executed instead on a general purpose processor.

While the foregoing is directed to embodiments of the invention other and further embodiments of the invention may be devised without departing from the basic scope thereof. For example aspects of the present invention may be implemented in hardware or software or in a combination of hardware and software. One embodiment of the invention may be implemented as a program product for use with a computer system. The program s of the program product define functions of the embodiments including the methods described herein and can be contained on a variety of computer readable storage media. Illustrative computer readable storage media include but are not limited to i non writable storage media e.g. read only memory devices within a computer such as CD ROM disks readable by a CD ROM drive flash memory ROM chips or any type of solid state non volatile semiconductor memory on which information is permanently stored and ii writable storage media e.g. floppy disks within a diskette drive or hard disk drive or any type of solid state random access semiconductor memory on which alterable information is stored. Such computer readable storage media when carrying computer readable instructions that direct the functions of the present invention are embodiments of the invention.

