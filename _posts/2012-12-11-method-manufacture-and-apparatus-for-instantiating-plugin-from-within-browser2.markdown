---

title: Method, manufacture, and apparatus for instantiating plugin from within browser
abstract: A method, apparatus, and manufacture for instantiating a browser plugin is provided. A client web browser of a client is employed to instantiate a browser plugin for the client web browser. Next, the client web browser is employed to obtain a reference to the browser plugin. Then, a command is given to the browser plugin via the reference to the browser plugin. The browser plugin is used by the client web browser rather than the web page.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09542368&OS=09542368&RS=09542368
owner: Google Inc.
number: 09542368
owner_city: Mountain View
owner_country: US
publication_date: 20121211
---
This application is a utility patent application based on previously filed U.S. Provisional Patent Application Ser. No. 61 569 755 filed on Dec. 12 2011 the benefit of which is hereby claimed under 35 U.S.C. 119 e and incorporated herein by reference.

The invention is related to computer software and in particular but not exclusively to a method manufacture and apparatus for using the web browser rather than the web page to instantiate a browser plugin for the web browser.

Today HTML5 media tags such as and tags are available to provide content providers with a simple way to deliver their audio and video content onto the web and have it play on any web browser or browser based device. The underlying functionality of the HTML media tags are referred to as HTML media elements. The and tags enable an ecosystem where plugins are no longer required to play this content and end users have consistent access to it across their web enabled devices. To date content protection mechanisms to enable use of content that its owner wants to protect from unauthorized use are not supported in the context of HTML media tags.

Various embodiments of the present invention will be described in detail with reference to the drawings where like reference numerals represent like parts and assemblies throughout the several views. Reference to various embodiments does not limit the scope of the invention which is limited only by the scope of the claims attached hereto. Additionally any examples set forth in this specification are not intended to be limiting and merely set forth some of the many possible embodiments for the claimed invention.

Throughout the specification and claims the following terms take at least the meanings explicitly associated herein unless the context dictates otherwise. The meanings identified below do not necessarily limit the terms but merely provide illustrative examples for the terms. The meaning of a an and the includes plural reference and the meaning of in includes in and on. The phrase in one embodiment as used herein does not necessarily refer to the same embodiment although it may. Similarly the phrase in some embodiments as used herein when used multiple times does not necessarily refer to the same embodiments although it may. As used herein the term or is an inclusive or operator and is equivalent to the term and or unless the context clearly dictates otherwise. The term based in part on based at least in part on or based on is not exclusive and allows for being based on additional factors not described unless the context clearly dictates otherwise. The term coupled means at least either a direct electrical connection between the items connected or an indirect connection through one or more passive or active intermediary devices. The term signal means at least one current voltage charge temperature data or other signal.

Briefly stated the invention is related to a method apparatus and manufacture for instantiating a browser plugin. A client web browser of a client is employed to instantiate a browser plugin for the client web browser. Next the client web browser is employed to obtain a reference to the browser plugin. Then a command is given to the browser plugin via the reference to the browser plugin.

One embodiment of client devices is described in more detail below in conjunction with . Generally however client devices may include virtually any portable computing device capable of receiving and sending a message over a network such as wireless network or the like. Client devices may also be described generally as client devices that are configured to be portable. Thus client devices may include virtually any portable computing device capable of connecting to another computing device and receiving information. Such devices include portable devices such as cellular telephones smart phones display pagers radio frequency RF devices infrared IR devices Personal Digital Assistants PDAs handheld computers laptop computers wearable computers tablet computers integrated devices combining one or more of the preceding devices and the like. As such client devices typically range widely in terms of capabilities and features. For example a cell phone may have a numeric keypad and a few lines of monochrome LCD display on which only text may be displayed. In another example a web enabled mobile device may have a touch sensitive screen a stylus and several lines of color LCD display in which both text and graphics may be displayed.

Client device may include virtually any computing device capable of communicating over a network to send and receive information. The set of such devices may include devices that typically connect using a wired or wireless communications medium such as personal computers multiprocessor systems microprocessor based or programmable consumer electronics network PCs or the like. In one embodiment at least some of client devices may operate over wired and or wireless network.

A web enabled client device may include a browser application that is configured to receive and to send web pages web based messages and the like. The browser application may be configured to receive and display graphics text multimedia and the like employing virtually any web based language including a wireless application protocol messages WAP and the like. In one embodiment the browser application is enabled to employ Handheld Device Markup Language HDML Wireless Markup Language WML WMLScript JavaScript Standard Generalized Markup Language SMGL HyperText Markup Language HTML eXtensible Markup Language XML and the like to display and send a message. In one embodiment a user of the client device may employ the browser application to perform various activities over a network online . However another application may also be used to perform various online activities.

Wireless network is configured to couple client devices and its components with network . Wireless network contains at least one Access Point not shown in . Wireless network may include any of a variety of wireless sub networks that may further overlay stand alone ad hoc networks and the like. Such sub networks may include mesh networks Wireless LAN WLAN networks cellular networks and the like.

Wireless network may further include an autonomous system of terminals gateways routers and the like connected by wireless radio links and the like. These connectors may be configured to move freely and randomly and organize themselves arbitrarily such that the topology of wireless network may change rapidly.

Wireless network may further employ a plurality of access technologies including 2 2G 3 3G 4 4G 5 5G generation radio access for cellular systems WLAN Wireless Router WR mesh and the like. Access technologies such as 2G 3G 4G and future access networks may enable wide area coverage for mobile devices such as client devices with various degrees of mobility. For example wireless network may enable a radio connection through a radio network access such as Global System for Mobil communication GSM General Packet Radio Services GPRS Enhanced Data GSM Environment EDGE Wideband Code Division Multiple Access WCDMA and the like.

Network is configured to couple network devices with other computing devices and through wireless network to client devices . Network is enabled to employ any form of computer readable media for communicating information from one electronic device to another. Also network can include the Internet in addition to local area networks LANs wide area networks WANs direct connections such as through a universal serial bus USB port other forms of computer readable media or any combination thereof. On an interconnected set of LANs including those based on differing architectures and protocols a router acts as a link between LANs enabling messages to be sent from one to another. In addition communication links within LANs typically include twisted wire pair or coaxial cable while communication links between networks may utilize analog telephone lines full or fractional dedicated digital lines including T1 T2 T3 and T4 Integrated Services Digital Networks ISDNs Digital Subscriber Lines DSLs wireless links including satellite links or other communications links known to those skilled in the art. Furthermore remote computers and other related electronic devices could be remotely connected to either LANs or WANs via a modem and temporary telephone link. In essence network includes any communication method by which information may travel between computing devices.

Additionally communication media typically embodies computer readable instructions data structures program modules or other transport mechanism and includes any information delivery media. By way of example communication media includes wired media such as twisted pair coaxial cable fiber optics wave guides and other wired media and wireless media such as acoustic RF infrared and other wireless media.

Server device is a network device. Devices that may operate as server include various network devices including but not limited to personal computers desktop computers multiprocessor systems microprocessor based or programmable consumer electronics network PCs server devices network appliances and the like. It should be noted that while various devices are shown in a particular quantity for example server is shown as one device in various embodiments there may a different quantity of such devices such two or more servers. There may even be two or more separate networks of servers. Thus the invention is not to be construed as being limited to a single environment and other configurations and architectures are also envisaged.

As shown in the figure client device includes a processing unit CPU in communication with a mass memory via a bus . Client device also includes a power supply one or more network interfaces an audio interface a display a keypad an illuminator an input output interface a haptic interface and an optional global positioning systems GPS receiver . Power supply provides power to client device . A rechargeable or non rechargeable battery may be used to provide power. The power may also be provided by an external power source such as an AC adapter or a powered docking cradle that supplements and or recharges a battery.

Client device may optionally communicate with a base station not shown or directly with another computing device. Network interface includes circuitry for coupling client device to one or more networks and is constructed for use with one or more communication protocols and technologies including but not limited to global system for mobile communication GSM code division multiple access CDMA time division multiple access TDMA user datagram protocol UDP transmission control protocol Internet protocol TCP IP SMS general packet radio service GPRS WAP ultra wide band UWB IEEE 802.16 Worldwide Interoperability for Microwave Access WiMax SIP RTP or any of a variety of other wired or wireless communication protocols including WiFi Ethernet and or the like. Network interface is sometimes known as a transceiver transceiving device or network interface card NIC .

Audio interface is arranged to produce and receive audio signals such as the sound of a human voice. For example audio interface may be coupled to a speaker and microphone not shown to enable telecommunication with others and or generate an audio acknowledgement for some action. Display may be a liquid crystal display LCD gas plasma light emitting diode LED or any other type of display used with a computing device. Display may also include a touch sensitive screen arranged to receive input from an object such as a stylus or a digit from a human hand.

Keypad may comprise any input device arranged to receive input from a user. For example keypad may include a push button numeric dial or a keyboard. Keypad may also include command buttons that are associated with selecting and sending images. Illuminator may provide a status indication and or provide light. Illuminator may remain active for specific periods of time or in response to events. For example when illuminator is active it may backlight the buttons on keypad and stay on while the client device is powered. Also illuminator may backlight these buttons in various patterns when particular actions are performed such as dialing another client device. Illuminator may also cause light sources positioned within a transparent or translucent case of the client device to illuminate in response to actions.

Client device also comprises input output interface for communicating with external devices such as a headset or other input or output devices not shown in . Input output interface can utilize one or more communication technologies such as USB infrared Bluetooth or the like. Haptic interface is arranged to provide tactile feedback to a user of the client device. For example the haptic interface may be employed to vibrate client device in a particular way when another user of a computing device is calling.

Mass memory includes a RAM a ROM and other storage means. Mass memory illustrates an example of computer readable storage media devices for storage of information such as computer readable instructions data structures program modules or other data. Mass memory stores a basic input output system BIOS for controlling low level operation of client device . The mass memory also stores an operating system for controlling the operation of client device . It will be appreciated that this component may include a general purpose operating system such as a version of UNIX or INUX or a specialized client communication operating system such as Windows Mobile or the Symbian operating system. The operating system may include or interface with a Java virtual machine module that enables control of hardware components and or operating system operations via Java application programs.

Memory further includes one or more data storage which can be utilized by client device to store among other things applications and or other data. Applications may include computer executable instructions which when executed by client device perform actions. Other examples of application programs include calendars search programs email clients IM applications SMS applications VOIP applications contact managers task managers transcoders database programs word processing programs security applications spreadsheet programs games search programs and so forth. In some embodiments applications may include web browser a media stack for the web browser a content decryption module CDM for inter alia decrypting media content for the media stack and an application running on browser such as a web application.

Various embodiments of client device may include applications . These stored applications are processor executable code encoded on a processor readable medium which when executed by CPU enable actions to performed in accordance with the processor executable code. In some embodiments web browser and or other applications may perform steps such as those illustrated in the flowcharts below.

Although the discussion of various embodiments above has described the performance of actions implemented in software for example by means of processor executable code encoded on a processor readable medium which when executed by CPU enable actions to performed in accordance with the processor executable code in various embodiments actions may in some embodiments rather than being performed only by executed software may instead be performed based on hardware only or by a combination of hardware and software.

Network device may include processing unit video display adapter and a mass memory all in communication with each other via bus . The mass memory generally includes RAM ROM and one or more permanent mass storage devices such as hard disk drive tape drive optical drive and or floppy disk drive. The mass memory may store operating system for controlling the operation of network device . Any general purpose operating system may be employed. Basic input output system BIOS may also be provided for controlling the low level operation of network device . As illustrated in network device also can communicate with the Internet or some other communications network via network interface unit which may be constructed for use with various communication protocols including the TCP IP protocol. Network interface unit is sometimes known as a transceiver transceiving device or network interface card NIC .

The mass memory as described above illustrates another type of computer readable processor readable media namely computer readable storage media. Computer readable storage media devices may include volatile nonvolatile removable and non removable media implemented in any method or technology for storage of information such as computer readable instructions data structures program modules or other data. Examples of computer readable storage media include RAM ROM EEPROM flash memory or other memory technology CD ROM digital versatile disks DVD or other optical storage magnetic cassettes magnetic tape magnetic disk storage or other magnetic storage devices or any other physical medium which can be used to store the desired information and which can be accessed by a computing device.

Data stores may include a database text spreadsheet folder file or the like. Data stores may further include program code data algorithms and the like for use by a processor such as central processing unit CPU to execute and perform actions. In one embodiment at least some of data and or instructions stored in data stores might also be stored on another device of network device including but not limited to cd rom dvd rom hard disk drive or other computer readable storage device resident on network device or accessible by network device over for example network interface unit .

The mass memory also stores program code and data. One or more applications may be loaded into mass memory and run on operating system . Examples of application programs may include transcoders schedulers calendars database programs word processing programs Hypertext Transfer Protocol HTTP programs customizable user interface programs IPSec applications encryption programs authentication programs security programs SMS message servers IM message servers email servers account managers and so forth. In some embodiments as discussed in greater detail below application may include applications for providing a content authorization service and may provide a license to an authorized requesting client application.

In various embodiments the browser plugin may be a browser plugin for performing virtually any web feature or browser feature. The browser plugin is instantiated by the web browser not the web page. The browser plugin is a plugin for the browser not a media engine plugin. The browser plugin is providing functionality for the browser rather than providing part of the page content. The browser plugin is an in page plugin that is invoked by HTML. In some embodiments the browser may instantiate the plugin by injecting code into the web page but this is still the browser instantiating the browser plugin. By having the browser rather than the web page instantiate the browser plugin there is no need for the web pages to include such elements or scripts within them in some embodiments the browser injects such elements or scripts into the web page but in this case the web page did not need to include such elements before the browser injects them into the web page . Because the browser rather than the web page instantiates the browser plugin the pluggable functionality can be used on any web pages without modifications to the web pages.

In other various embodiments rather than injecting the appropriate code into the page the appropriate elements may instead instantiate a plugin directly by instantiating the native browser code that represents and manages the plugin may inject the elements into the shadow DOM and or may include elements in a separate hidden web page or frame.

In some embodiments the browser plugin is not accessible by the web page. In some embodiments the web page is not able to detect the presence of the browser plugin.

As discussed above in some embodiments the browser may inject the appropriate HTML JavaScript JavaScript variables and or objects etc. into the web page appropriate elements into the DOM page representation or representations of the appropriate elements into the browser s internal representation of the page.

In some embodiments the element it may be injected in a more global location such as a or tag. In some embodiments the browser may inject and or run script that instantiates the browser plugin.

As discussed above at block the client web browser obtains a reference to the browser plugin. In some embodiments the reference is a pointer to the browser plugin such as a C pointer. In other embodiments the reference to the plugin may be a name type or other identification to find and access the browser plugin at a subsequent time.

At block the browser gives one or more commands to the browser plugin using the reference obtained at block . The nature of the command s varies in different embodiments depending on the nature of the browser plugin and the functions performed by the browser plugin which may vary considerably in different embodiments.

The pluggable functionality of the browser plugin may extend capabilities for or related to one or more elements or even non element capabilities in the web browser.

As discussed above in some embodiments the browser instantiates the browser plugin directly by instantiating the native browser code e.g. C or other suitable native browser code that represents and manages the browser plugins. This would also load the plugin code e.g. DLL SO .

In some embodiments the appropriate item may be injected within the element for which the plugin functionality is used. As discussed above in some embodiments this may be done by injecting the item into the shadow DOM of an element. By injecting the item into the shadow DOM of an element the item is not accessible by other elements and script in the page and they may not even be able to detect its presence.

In these embodiments if an element has a shadow DOM by default e.g. elements in the layout rendering engine software e.g. WebKit it may be injected into the existing shadow DOM.

In some embodiments the browser may use mechanisms to hide the element or script from the web page s application s elements and or scripts. In some embodiments this might include supporting a non standard element or naming scheme that the browser uses to indicate that the element or script should not be accessible to elements and or scripts in the page application. For example in some embodiments elements may be named in a certain manner to indicate that elements named in that manner are not accessible to elements and or scripts in the page application.

In some embodiments the browser may block every call that might access the hidden element and for any call that would otherwise access the element the access may be blocked an exception may be thrown or an indication that the element cannot be found may be provided in response to the call.

Even in embodiments in which elements are injected into the DOM to instantiate the plugin the process is still such that it is entirely transparent to the web page that a plugin is being used in the background and all of the normal functionality of the web page still works as normal.

In some embodiments the browser plugin may be implemented using a plugin architecture such as Active X Netscape Plugin Application Programming Interface NPAPI Pepper Plugin API PPAPI or the like.

The process then advances to block where a command is given to the browser plugin via the reference to the browser plugin. In some embodiments there is a set of APIs employed in the plugin framework for which to give commands to the browser plugin via the reference. The process then moves to decision block where a determination is made as to whether the browser plugin is still needed. If so the process returns to block where another command is given to block and the process then advances to decision block again.

At decision block if it is determined that the browser plugin is no longer needed the process proceeds to block where the sub tree of the DOM is destroyed. Destroying the sub tree causes the sub tree to be unrendered so that the browser plugin instance is destroyed. The process then proceeds to a return block where other processing is resumed.

In some embodiments there is no step of destroying the sub tree. For example in some embodiments an internal representation of the browser plugin is used.

The process then moves to block where the sub tree is rendered which causes the browser plugin to be rendered. The process then advances to block where the browser gets a reference to the browser plugin. In some embodiments the reference is provided in a callback as the browser plugin is being rendered. The process then proceeds to a return block where other processing is resumed.

In some embodiments the sub tree in the DOM created at block is in the shadow DOM. The code for rendering the shadow DOM is implemented inside the browser. In other embodiments the sub tree is created in the DOM of a separate hidden secret document e.g. web page or frame that is hidden and inaccessible from the primary web page web application and that is not visible to the user. In some embodiments the separate hidden web page may be as simple as just for example nothing more than .

In some embodiments there is nothing regarding the browser plugin in the main page of the DOM so that the only references to the browser plugin are in some portion of the browser.

At decision block the need for a browser plugin is different in various embodiments. In some embodiments the browser plugin could be required for any web page. In some embodiments the need for the browser plugin could be triggered by the mark up on the web page or because of some action the script took on the web page. The need may be triggered based on one or more specific actions happening or not happening in various embodiments.

In some embodiments the browser plugin is a content decryption module CDM and at decision block the determination is positive when an addKey function is called in a script of the web page indicating that decryption content protection is needed. In other embodiments the determination may be based on some other step. For example the determination may be a determination of whether the first step in the license request has occurred where this first step is different in different embodiments. For example in some embodiments the process may be started by generateKeyRequest or the creation of a MediaKeys object may begin the process.

Further the invention is not limited to a determination related to the license request process because this is just one specific embodiment of a browser plugin and the browser plugin may be used for virtually any web function or browser function in various embodiments. For example in some embodiments the browser plugin provides the browser function of web syncing that syncs a user s bookmarks and or tabs between computers. In other embodiments the browser plugin may provide functionality for various web functions such for the image tag in some embodiments. Further even in the example of an embodiment in which the browser plugin is a CDM in some embodiments the addKey function is not necessarily required for indicating the need for the browser plugin for example it could be any cryptography tag that indicates the need for the CDM browser plugin.

In some embodiments the browser plugin may only use or be allowed to use by design and or policy a subset of the plugin infrastructure. For example in some embodiments certain browser plugin s may be denied network access. In some embodiments some browser plugin s may be allowed to be run only by particular restricted APIs within the browser. A browser plugin is still a browser plugin even if functionality is restricted and or the set of supported APIs is changed in some way.

As discussed above at block the browser plugin is registered with the client web browser. The browser plugin is registered with the client web browser in such a way that the browser can load the browser plugin given a type string. In some embodiments the browser maintains or populates a table of key system names which may be strings in some embodiments to plugin types which may be strings in some embodiments .

In various embodiments key system names could be something else entirely. For example instead of a key system name it some embodiments the table may store a list of codes for the image tags. In some embodiments a table is not needed.

Client device includes application content decryption module CDM platform and browser . Browser includes media stack and network stack Net .

CDM may be employed as an embodiment of a browser plugin that is instantiated by a process such as one of the processes discussed above with regard to and or . In some embodiments CDM may be instantiated after a cryptographic function such as addKey or the like is called.

CDM performs decryption of media content in communication with media stack . Application is a media playback control application.

Media stack performs and or controls decoding of media content in conjunction with CDM which performs the actual decoding in some embodiments . In some embodiments media stack is a set of connected media processing and rendering modules used for converting digital media data into human perceptible representations e.g. moving pictures and or sound . Media stack performs and or controls functions such as de multiplexing decryption and rendering in some embodiments in conjunction with CDM in some embodiments . In some embodiments media stack has substantially no other logic but just renders what it is fed and can therefore be used for all types of media playback applications in an interchangeable fashion. In some embodiments certain functions such as decryption are not performed directly by media stack itself but by CDM which is a separate module that performs certain functions such as decryption under the control of media stack .

Application instructs media stack to playback media content. In some embodiments application includes computer executable code that implements substantially all of the logic required to play back media in a particular context including user interface logic subtitle control information control of the acquisition of keys and or the like but not processing and rendering. The processing and rendering is instead performed by media stack and or by separate modules under the control of media stack including CDM . In some embodiments the rendering is performed by a part of browser other than media stack . In other embodiments the rendering is performed by another part hardware or software of the client. Together media stack and application both reside in client device and operate as a client media player. Media stack and application are distinct programs or binaries or libraries or scripts etc. where media stack can be re used. Media stack stack is part of an application framework together with other modules that implement user input graphics output network O etc. The application framework exposes standard abstract interfaces for these functions to application . Application may be a web application for playback of media using the HTML media elements identified in HTML5 and or future versions of HTML by HTML media tags such as and and or future HTML media elements where the web application includes a scripting language e.g. JavaScript and HTML or a mark up language derived from HTML e.g. mark up languages based on supersets subsets slices extensions of HTML .

This particular separation between media stack as part of the application framework and application is useful because the media stack implementation is typically specific to the type of computer hardware platform it executes on and therefore is implemented in a way that is strongly connected to the operating system. The same holds for user input graphics output network I O etc. In some embodiments media stack is specific to a particular type of content protection. Application however can be the same across many different computer platforms when the underlying application framework abstracts access to user input network graphics media stack etc.

In some embodiments when application acquires a license it does so in communication with one or more servers. In some embodiments web server may handle requests or send directly to license server . In some embodiments application may communicate directly with license server .

In some embodiments media stack may acquire media content specified by application via network stack where network stack acquires the media content from CDN .

A content encryption key may be generated employing any of a number of encryption decryption symmetric mechanisms including but not limited to Advanced Encryption Standard AES RSA RC6 IDEA DES RC2 RC5 Skipjack and any other symmetric encryption algorithm. Moreover such encryption algorithms may use where appropriate cipher block chaining mode cipher feedback mode CBC cipher text stealing CTS CFB OFB counter mode and or any other block mode. In some embodiments content encryption keys are generated employing an at least 128 bit AES encryption decryption algorithm. However content encryption key generation is not limited to symmetric key mechanisms and asymmetric key mechanisms may also be employed without departing from the scope of the present invention. Typically where the content encryption key is a symmetric encryption key such content encryption keys are also referred to as decryption keys as the same key may be used to both encrypt and to decrypt the content.

In additional to decryption in various embodiments CDM may also perform such functions as DRM content protection license exchange or processing including e.g. license request generation decoding de multiplexing and or the like. In some embodiments CDM performs decoding for codecs not supported by browser . While media stack generally performs rendering in many embodiments in some embodiments CDM is employed to perform secure rendering.

In terms of DRM and or content protection in some embodiments CDM may protect the buffers and protect the decryption key through software methods. In some embodiments CDM has a secret key that CDM uses to decrypt the license and obtain the content key and CDM protects CDM s secret key. In some embodiments CDM employs the content key to decrypt the corresponding media. In some embodiments CDM must also protect the content key once CDM has decrypted the content key from the license. In some embodiments CDM also protects the compressed decrypted frames. In some embodiments the memory is scrambled such that the decrypted but compressed frames are not available in memory at any time. In some embodiments the decompressed frames may also be protected. In some embodiments CDM may also protect and or enforce other license provisions such as the length of time the license allows particular video content to be viewed. In some embodiments. CDM determines when the license has expired and that a new license is needed when the license has expired.

Media stack controls various functions of CDM such as when to decrypt and decode when to render if CDM performs rendering when to generate a license request and the like. However in some embodiments CDM may also perform DRM and or content protection functions that are not necessarily directly controlled or initiated by media stack such as those DRM and or content protection functions discussed in the previous paragraph.

In some embodiments CDM performs decryption but not decoding. In some of these embodiments media stack may provide encrypted data to CDM CDM decrypts the media and provides the decrypted media to media stack and media stack then performs decoding on the decrypted media. In other embodiments as previously discussed CDM performs both decryption and decoding. In some embodiments after media stack sends CDM encrypted media CDM decrypts and decodes the encrypted media and then sends the decrypted media to secure hardware e.g. a secure surface rather than returning the decrypted media to media stack . In some embodiments CDM uses a secure pipeline for decryption decoding and or rendering.

In some embodiments CDM is sandboxed. In some embodiments CDM is sandboxed but can perform particular unsandboxed operations via a special channel. In some embodiments CDM is sandboxed but can perform particular unsandboxed operations via a broker.

Content protection can involve accessing the system in ways web content usually should not need which could lead to system vulnerabilities. If CDM is sandboxed these system vulnerabilities can be prevented. Also sandboxing can provide privacy protection so that CDM cannot grab personal identifiable information or the like. By employing a sandboxed CDM that is a separate binary from browser secure decryption and or DRM may be performed without polluting browser or using platform capabilities platform independent decryption DRM may be performed both in the logical OS independent and architecture binary sense and content protection decryption and or the like can be separate from browser and the application all while browser handles playback.

Sandboxing only allows code execution that cannot make persistent changes to the computer and sandboxed code execution cannot access information that is confidential. With sandboxing code that is running cannot make changes to the system and no matter what it does does not have access to change the system. A sandboxed program typically cannot run commands that are not authorized and might also be able to change the system but only via strict APIs the sandboxed code is unable create modify or delete a file using normal system calls. The sandboxed code can only change the system through an API and the sandboxing entity can decide which kinds of accesses to allow.

In some embodiments CDM may be a sandboxed browser plug in and implemented as a Pepper PPAPI plug in. Traditionally plug ins including Pepper are used to display content on the page. However in some embodiments Pepper is just used as a framework to execute code separate from the web browser within a sandbox.

Use of PPAPI provides an architecture that enables running out of process sandboxing run time loading DLL shared object loading browser provided functionality sandbox escape functionality and other capabilities for the browser plugin.

In some embodiments CDM is not sandboxed and CDM can write out to a secure pipeline. In some embodiments CDM is not sandboxed and it does decryption and decoding in a secure pipeline. Secure pipelines may also be used when the CDM is sandboxed .

In other embodiments CDM may be a browser plug in implemented for example in Netscape Plugin API NPAPI or ActiveX.

The process then advances to block where the web application instructs the media stack of the client browser to initiate playback of the media content. In some embodiments the web application may contain an autoplay attribute in which case the browser parses the web application discovers the autoplay attribute and causes the media stack to autoplay the media content. In other embodiments there is no autoplay attribute for the media content and the web application instructs the media stack when to play media content. The media stack is instructed to play the media content in a time and manner that is in accordance with the web application. For example in some embodiments the web application instructs the media stack to play the media content when a play button is pressed by the user.

The process then proceeds to block where the media stack starts to procure the media content that the media stack was instructed to play back e.g. through file reading or progressive or adaptive streaming .

The process then advances to block where the media stack fires an event to the web application where the event indicates that a license is needed to begin or continue playback of the media content. The process then proceeds to block where the CDM browser plugin is instantiated and a reference to the CDM browser plugin is obtained. In one embodiment the process at block occurs substantially as process of .

The process then advances to block where the license request process occurs. In some embodiments the web application sends a request for a license request to the media stack and then the media stack sends the request for a license request to the CDM. In some embodiments the CDM sends a license request to the media stack in response to receiving the license request from the media stack. In some embodiments the license request must come from the CDM because in these embodiments for security purposes the license server requires a signature that only the CDM can provide in order to provide the license. Then the media stack sends the license request to the web application.

In some embodiments the step of block may occur after or during the step of block . For example in some embodiments the step at block may be caused in response to a request to generate a license request or addKey within the step at block that causes the step at block to occur.

The process then moves to block where the web application gets the license. As discussed in greater detail below the web application may get the license in a variety of different ways in different embodiments. For example in some embodiments the application acquires the license via communication with one or more servers. In some embodiments the license may be found locally or on a local network. In some embodiments the license is acquired in accordance with a digital right management DRM scheme or other content protection system. In other embodiments the license could be stored in the web application. In some embodiments a license is used to establish the content key in the media stack in content protection mechanisms where the key is not transmitted in the clear and the key is extracted from or derived from the license data.

The web application is configurable to different types of content protection through the same framework. The web application defines a protocol or process and standardizes the interfaces so that the process could be configured to work with any of a variety of like underlying sort of technologies but the interface is the same regardless of the content protection system used.

Since the license acquisition occurs not in the media stack but in the web application the web application has control over the error handling for the license acquisition and the web application can handle error conditions and the like.

The process then advances to block where the web application sends the license to the media stack. The process then proceeds to block where the media stack receives the license. The process then advances to block where the media stack sends the license to the CDM. In some embodiments the step at block may be accomplished by commands given to the CDM via the reference. The media stack and the CDM are distinct binaries from each other. The process then moves to block where the media stack sends encrypted data to the CDM. The encrypted data may be accompanied by parameters including which license the encrypted data is associated with.

The process then proceeds to block where the encrypted data is decrypted and decoded by the CDM. This may be accomplished by commands given to the CDM browser plugin via the reference. In some embodiments the media content is first decrypted and then decoded and in other embodiments the media content is first decoded then decrypted. In some embodiments the encrypted media content it sent from the media stack to the CDM one frame at a time and the CDM decrypts and decodes the media content one frame at a time. In some embodiments the CDM performs the decryption but not the decoding and the decoding is instead performed by the media stack after the decrypted media is sent back to the media stack. What happens to the decrypted data varies in various embodiments. In some embodiments the decrypted data is provided to the media stack for rendering. In some embodiments the decrypted data is provided to a secure pipeline.

The process then advances to block where the sub tree of the DOM is destroyed. As previously discussed in some embodiments this step does not occur. The processing then proceeds to a return block where other processing is resumed.

Many variations to the exact process flow illustrated in are within the scope and spirit of the invention. For example in some embodiments the web application may determine that the media is encrypted. Accordingly rather than the web application instructing the media stack to initiate playback right away in this case the web application can instead get the license and after the web application gets the license the web application can instruct the media stack to initiate playback along with sending the media stack the data that includes the license. In some embodiments the media tags may specify that the media is encrypted. As previously discussed the steps may happen in a different order than shown in for example the step of block may occur earlier or later than shown as previously discussed. Further in some embodiments the application may determine without notification that a license is needed rather than having to encounter something in the file before determining that a license is needed.

In some embodiments such as a key rotation scheme the media stack can fire an event each time a new key is needed and the application can provide the new key to the media stack.

Process may be applied to local content to content that is downloaded and then played and or to streaming content. Process is not specific to any particular form of content protection but may be applied to various forms of DRM and other forms of content protection in different embodiments. Process can support a wide range of control system types including traditional DRM systems conditional access systems simple key establishment without the need for DRM servers and key distribution systems based on DRM systems.

In some embodiments process may be used for viewing commercial content including commercial content protected by a content protection mechanism such as DRM where the commercial content may include movies or the like. In some embodiments the media may be accessed via a webpage employing HTML5 or a future version of HTML that also supports media tags where the media content is accessed in an HTML media tag such as or . The media content which is protected by some sort of content protection such as encryption DRM and or the like can be accessed in a browser with an HTML media tag with the media accessible controllable and configurable by the web application where the media content can be streamed to the browser downloaded provided by the application or local. In some embodiments the web application provides application level flexibility to implement the authorization exchange and all of the HTML5 security mechanisms may be used for network transactions.

In some embodiments one attribute authorizationData and one event authorizationNeeded is added to the HTML5 media elements as follows. In some of these embodiments the design adds one new attribute to media elements named authorizationData. In some embodiments the purpose of this attribute is to provide the CDM with the necessary information to initialize itself and enable playback of the requested content e.g. a decryption key . In some embodiments authorizationData may be a method that provides the data to the media element. The attribute authorizationData and the event authorizationNeeded may have different names in different embodiments. For example in they are referred to as addKey as a called function rather than an attribute and needkey respectively.

The authorizationNeeded event fires when the media stack underneath the media element discovers the need for fresh authorization data to start or continue playback. This event is accompanied by one or more blobs of data generated by the media stack that is potentially opaque to the application. The format of the data may be dependent on the content control mechanism s in the CDM and or content format.

The authorizationNeeded event is an embodiment of the event fired at block of process . In some embodiments the authorizationNeeded event also contains supplemental data that is specific to the content control mechanism and or content. The supplemental data can be opaque to the application it only needs to be understood by the entity that creates the license data which could be a network service in some embodiments.

The web application uses the information mentioned above to procure the required content control data either through an application specific mechanism or through a content control specific mechanism . This could happen through in client processing querying e.g. a password retrieval from storage or a network request to a service. The authorizationNeeded event can fire multiple times during a single playback session e.g. for key rotation.

The acquired content control data is provided to the media element via the authorizationData attribute. Once the data is present and correctly verified by the media stack playout starts. In order to avoid playout delays due to latencies incurred when acquiring content control data existing preload mechanisms can be used.

In some embodiments the authorizationNeeded event contains an array of the following tuple type and data where type is an identifier of content control mechanism and data is a byte array containing contents dependent on content control mechanism to enable application to acquire authorization data. In some embodiments the authorizationData attribute includes a byte array in which the contents are dependent on content control mechanism which enables the media stack to play content and or content data format.

In one possible embodiment of an application of the authorization data acquisition mechanism content is encrypted using a content key and a secure key distribution system stores the key. In some embodiments the media stack contains client code of this secure key distribution system though a pluggable mechanism or platform capabilities in some embodiments and the content provider runs a key distribution service as a counterpart.

In some of these embodiments the content control system uses a challenge data structure generated on the client and a license data structure generated on the server using the content key and the client public key. The challenge data structure typically contains information about the content to be played for retrieval of the correct key and information about the client CDM client ID client type public key for encryption of the content key for transport .

In these embodiments the media stack detects that the content is encrypted and can be decrypted using the secure key distribution system s client CDM. The content key is acquired through a network transaction. Since the application has not yet set the authorizationData attribute of the media element to a valid license data structure the media stack generates a challenge data structure and serializes it into a byte stream.

In these embodiments the authorizationNeeded event gets the following two attributes 1 type and 2 data and fires.

In these embodiments the application catches the event using a handler for this event. In the handler the web application generates a request to the streaming service s license server using an existing authentication mechanism e.g. domain cookie to authorize the request on the server and the opaque data generated by the CDM. In some embodiments the content control mechanism may choose to invalidate the authorization data after a certain number of uses therefore disallowing replay of previously issued authorization data and in consequence enforcing a requirement of fresh authorization for each playback.

In these embodiments authorization depends on the streaming service s business rules. At the minimum licenses could be handed out to everyone. In a service like this the content still cannot be copied and giving out rights to play back can be stopped at any time e.g. when the service s distribution rights for this content end . Other services may require customer authentication and even others may impose restrictions on number of devices and concurrent usage.

In these embodiments if authorization is successful the license server may use the content identification data in the challenge data structure to retrieve the content key for the content to be played from its database and use the client key to generate a license data structure which is handed back to the application in the response. The application installs the opaque license data into the authorizationData attribute of the media element and playout starts after successful verification of the license data and extraction or derivation of the content key from the license data by the media stack. In some embodiments the CDM is responsible for the security of the decrypted content the security of the content key the security of the client CDM keys that can be used to decrypt license data and secure disposal of the content key after playback has ended. In some embodiments the opaque license data contains all of the necessary information to play all streams of the content in question that are authorized to the requesting user on the target device. For example if different streams of some particular content are encrypted with different keys the license contains all of the keys and the necessary information to associate it with the correct streams.

In some of these embodiments the system can be extended to allow offline playback without changing the media stack implementation of the content control system e.g. by retrieving the license from storage.

In these embodiments a simple offline playback system allows the user to pin content to the client device while the device is connected. The content data one embodiment thereof e.g. at appropriate bitrate and quality for the target device is downloaded from the server in its entirety and stored in local storage. The application uses a media element to initiate preload of playback for the content data in local storage which triggers the authorization data retrieval mechanism. The authorization data is retrieved by the application as in the streaming use case but not installed in the authorizationData attribute yet. It is cached in local storage until offline playback is initiated.

In these embodiments if required for management of the stored authorization data the content protection system can support the transmission of additional information on top of the opaque authorization data blob to the web application e.g. content ID expiration date etc. e.g. through the network protocol that also serves to transmit the authorizationData blob. This mechanism can be proprietary to the content protection system in some embodiments.

In these embodiments when playback is initiated the application retrieves the authorization data from its internal storage and installs it in the media element allowing playout to proceed.

Returning to as discussed above the event authorizationNeeded and the attribute authorizationData are instead replaced by the event needkey and the function addKey respectively. Application may use Get Key to acquire a key from a server which may in turn respond with an encrypted key via Key from the server to application . The key may be provided from application to media stack via addKey and from media stack to CDM via SetKey.

In some embodiments canPlayType is extended to provide basic information about content control systems supported by the browser.

Media stack may provide an encrypted frame for CDM to decrypt via Decrypt Frame. CDM then decrypts the encrypted frame and provides the decrypted frame back to media stack via Frame.

In some embodiments a generateKeyRequest function may be employed from Application to media stack . A Key Request may be sent from media stack to application in response to the generateKeyRequest function.

When tag of DOM is rendered the rendered element has controls that are not accessible via DOM although the user can see the controls. The elements that render these controls which are inaccessible to DOM are provided during rendering by implementation which inserts the controls in the shadow DOM.

When AddKey is called by page DOM implementation intercepts the AddKey call. The implementation then inserts a tag e.g. an object tag for the plugin in the shadow DOM containing the controls which causes instantiation of the browser plugin. The implementation then provides the browser plugin with the key.

In this way in some embodiments the tag for instantiating the browser plugin may be placed in existing shadow DOM that is already implemented for media control and the tag e.g. tag for instantiating the browser plugin reference can exist in the shadow DOM like a normal object tag but that is inaccessible by the DOM or the web application or the script.

The above specification examples and data provide a description of the manufacture and use of the composition of the invention. Since many embodiments of the invention can be made without departing from the spirit and scope of the invention the invention also resides in the claims hereinafter appended.

