---

title: Methods and apparatus for protocol independent model to provide event-based discovery
abstract: Methods and apparatus for providing a storage resource management application having a protocol independent model for event-based discovery. In response to an event, discovery is performed using a protocol independent ontology model.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09491056&OS=09491056&RS=09491056
owner: EMC Corporation
number: 09491056
owner_city: Hopkinton
owner_country: US
publication_date: 20121228
---
As is known in the art storage area networks SANs can include a variety of different components and those components can be provided by different vendors. For example storage network elements provide management information through various protocols CISCO switches communicate via SNMP protocol NAS e.g. EMC Celerra components communicate via Celerra XML API and arrays communicate via SMI S. It can be challenging to communicate with components in the network using the different protocols.

In one aspect of the invention a method comprises receiving an event creating a discovery job in response to the event initiating the discovery job with a discovery collector and performing discovery of a device using a protocol independent ontology model wherein the device comprises a first one of an array in a storage layer a switch in a network layer a host in a compute layer and a NAS device wherein the device can be accessed by different protocols.

In another aspect of the invention an article comprises a computer readable medium containing non transitory stored instructions that enable a machine to perform receiving an event creating a discovery job in response to the event initiating the discovery job with a discovery collector and performing discovery of a device using a protocol independent ontology model wherein the device comprises a first one of an array in a storage layer a switch in a network layer a host in a compute layer and a NAS device wherein the device can be accessed by different protocols.

In a further aspect of the invention a system comprises at least one processor and at least one memory coupled to the at least one processor the at least one processor and the at least one memory configured to receive an event create a discovery job in response to the event initiate the discovery job with a discovery collector and perform discovery of a device using a protocol independent ontology model wherein the device comprises a first one of an array in a storage layer a switch in a network layer a host in a compute layer and a NAS device wherein the device can be accessed by different protocols.

In general exemplary embodiments of the invention support multiple protocols for management of storage network elements in a virtualized storage resource management SRM application that provides an end to end view across abstraction layers. A protocol independent ontology model enables focused discovery and management of the storage network elements. In exemplary embodiments using an ontology model each request method call to a data provider is modeled as an operation for any protocol.

The discovery component entities reside on the discovery appliance . Domain manager DM components transform source information models into a DMTF Common Information Model CIM based information model maintaining their data in memory. This data is then migrated to the SRM appliance . DMs periodically persist their data in repository files .rps . Some components that are written in java for example collect discovered data and do not persist it locally. In exemplary embodiment each data collection component supports a specific protocol e.g. CIM XML SNMP configured to collect information instances in the source format e.g. CIM XML and transfer that data stream to the appliance with no transformation or inspection of the data other than syntax checking e.g. testing for well formed XML . In some cases as with SNMP where there is no standard or de facto standard for a serialization format of the information model. In this case the data is transformed into a specific format before transfer e.g. jSON . This simple pull and post pattern enables data collections to be written quickly as very little processing is required before the write. This also allows for high scalability as each component is specifically written to minimize CPU and memory utilization. The methods used to achieve this include data streaming which enables more instances and threads to run in parallel to achieve high throughput for discovery. These components are based on a flexible framework which also facilitates the creation of new components by third parties e.g. service organizations . Discovery components post their results to the appliance using SSL enabled HTTP i.e. HTTPS connections. In the appliance the data is serialized to disk with multiple threads parsing and transforming the discovered elements into Resource Description Framework RDF statements that are then persisted in a topology service which maintains an embedded RDF database. This results in information that is mapped and normalized to a standard data model. This enables flexible and efficient support for any source data model e.g. SMI S SNMP MIB .

The following simple example shows how SMI S CIM XML data is translated into an RDF statement. The CIM XML comes from an instance of a CIM ComputerSystem class which describes a host.

The resulting RDF statement creates a host object in the topology service with a name of Iglor229.1ss.xxx.com . The response for an RDF database query for instances of host objects would have this host included in its list of host objects. The appliance surfaces the discovered information to the application components through the topology service. Discovery profiles support two types of profiles to enable discovery access and discovery. Access profiles encapsulate the credentials used to authenticate and authorize access to a SAN element. This access profile is then associated with a discovery profile that specifies the hostname s IP e.g. SAN element or the element s management host . The combination is then used to detect and discover an element. Discovery may be scheduled to occur on a regular interval. Discovery will also occur based on asynchronous events that are generated as the result of changes to the elements. These events include SNMP traps and CIM indications. By default full rediscoveries occur on a static schedule daily for hosts and weekly for switches and storage arrays .

Data collection includes a detection phase and a discovery phase. The detection phase validates the ability of the discovery engine to communicate with the software representing the element. The discovery phase collects the element information. The SAN element needs to be associated with the discovery and access profiles appropriate for their type. For example SMI S access profiles are required for the array discovery components that provide an SMI S interface. The discovery engine uses the information provided to enumerate and report the name and type of elements it has discovered. Discovery services then assign components responsibility for discovering the detected elements.

In general the SRM application is standards based meaning that technologies leveraged internally and exposed externally should be standards based. The primary protocols in use are SMI S for storage element discovery SNMP for network devices and WMI and SSH for host discovery. The standards used in the implementation cover both standard protocols HTTP SSL as well as commonly deployed architectural principles e.g. REST . The primary communication protocol in a RESTful architecture is HTTP with SSL i.e. HTTPS implemented to provide secure communication and authorization between network endpoints. Components communicate via HTTPS. The formats used in the exposure of information are also based on standards such as Atom and JSON.

Managed objects from a storage array to a user are resources that are modeled discovered managed and exposed using the most appropriate technology. A HTTP URI Uniform Resource Identifier uniquely identifies resources. Note that a URL is a network locator reference or address of the resource. A resource name is just the name or identifier of the resource. The term URI applies to both of these terms as both the location of the URL and the name of the URN are unique. HTTP URIs exists in Semantic Web applications that leverage RDF. An HTTP URI is used to identify an object uniquely within the context of the application. Each resource in the system has a type which is again uniquely identified by another URI. This includes storage elements e.g. storage volume storage port HBA switch port as well as application infrastructure entities e.g. log file service process . All of the instances of these resource types comprise the information model.

Properties expressed as URIs are used to associate types and instances of these types. When instances are discovered e.g. storage array a unique HTTP URI is created which identifies this new instance a resource URI. With this newly minted URI the resource instance can now be associated with other instances and statements may be made about the resource e.g. storageArray1 is Located in Houston .

Information about resources is exposed using the standards based representation e.g. Atom feeds etc. most appropriate for the task to be accomplished. For example a list of storage arrays is easily acquired and then divided into discrete pages by using Atom Feed pagination. A collection of performance metrics for an entire day is most compactly expressed using JSON or CSV.

The system utilizes an event driven architecture related to Service Oriented Architecture SOA to promote the coordination of loosely coupled components to provide intelligent data processing and enable highly scalable systems. In an event driven architecture messages representing events are communicated point to point or across a shared bus. Components use these messages to trigger analysis and other processes usually emitting additional messages to communicate state changes.

By decoupling the message and the processing related to the message components can be distributed and aggregated to provide high availability and scalability. Because the interface to the component is a message any number of components or threads can be deployed to process these messages concurrently thus increasing the throughput of the system.

Complex Event Processing CEP services can be layered over this foundation to create a highly scalable and flexible framework to analyze events generated in a data center in near real time to provide greater insight and clarity into storage related events. In exemplary embodiments CEP technology is used to analyze large volumes of performance metrics against performance thresholds in order to produce events that ultimately result in the creation of alerts. The event driven architecture and CEP allow large volumes of events thousands per second to be processed. This enables near realtime results that can notify a storage administrator as soon as a problem is detected regardless of the size of the environment under management.

In exemplary embodiments the SRM application is distributed as a virtual appliance vApp that can be deployed and managed through industry standard tools provided by VMware or other virtualization application. Scaling the system is as simple as deploying additional virtual machines VMs and distributing the processing among them. Data is federated among VMs using a simple but secure mechanism that runs over HTTP using SSL i.e. HTTPS and standard TCP ports.

The data center has a number of objects that can be discovered as shown in . A host layer includes first and second host bus adapters coupled to respective first and second FC switches in the fabric layer. A disk array enclosure includes first and second storage processors having respective interfaces coupled to the FC switches

It is understood that any practical number of arrays switches hosts and other components can be coupled in a variety of configuration to meet the needs of a particular application.

The data collector analyzes the model and extracts operations from the model to generate the commands. The requested operations are executed based on input from the requestor and the model. The data collector collects data from the providers and sends the information back to the requestor.

In the non parallel sequential path in step commands are executed sequentially. In step the first command is invoked. In step the response is extracted to generate new commands. In step the next command is executed after which processing continues in step

This arrangement provides a number of advantages such as enabling the use of a custom domain logic parser and custom command generator. In one embodiment the model domain logic is implemented in RDF with domain logic parsed from RDF. Commands are generated based on input parameters and collected data is sent only if all commands are executed successfully.

It is understood that an event can be considered as change in the existing environment e.g. switch port goes offline a disk failure cause a volume to inactive etc. . In one embodiment an indication DM receives the event for notification to a discovery service as described more fully below. Based on the event type e.g. switch port offline appropriate actions discovery can be invoked.

Referring to in conjunction with the above it can be seen that the Operation Argument model comprises a unified model that can address a wide variety of device protocol discovery use cases. The operation has set of attributes including 

Data collector responsibilities include analyzing the model and extracting operations from the model. With the model information the command generator generates commands for operations that are executed based on the input. Data from the provider is collected and sent back to the requester .

As will be appreciated in conventional systems when a volume goes offline all storage pools have to be discovered first and then all volumes have to rediscovered.

Below model is an example of Discovery of Volume on receiving a VOLUME INACTIVE event. Here VOLUME INACTIVE is being modeled as a namespace. getVolumeInformation is the corresponding method which lies under namespace and includes necessary input Arguments and the reference on which the method needs to get executed.

For an event based discovery model discovery of a switch for example can be split into multiple phases 

Each phase is modeled as a namespace below. Say in a Brocade SWITCHPORT DISCOVERY phase listed the below sequence of Steps performed.

This model focuses on modeling the entire sequence of SMI S extrinsic calls for specific namespace i.e. each SMI S call to a provider is treated as an operation.

An exemplary ontology based model for FC switch discovery such as the FC switch of is set forth below. This .owl specifies the list of classes and relations needed for completing a namespace discovery. In the illustrative embodiment the model supports SMI S

A discovery appliance is coupled to the discovery services . In one embodiment the discovery appliance includes a path DM host DM a SAN DM a trap DM an array DM an OI DM an indication DM a TES topology edit service and TS topology service populator .

A thread manager is coupled between the discovery services and the protocol independent discovery module . A plug in repository is coupled to the protocol independent discovery module . In the illustrative embodiment the plug ins include a universal remote REST plug in a WS plug in an CLARiiON ECOM Provider plug in and a Celerra XML API plug in . It is understood that a variety of other plug ins can also be included.

It is understood that a variety of topology tasks can be created. For example for an array toplogy task the following are discovered.

The task manager processes the topology data for the transformation service which provides transformation status to the task manager. The transformation data is processed for the topology service which sends a processing done notification to the task manager. The processed data is sent to the capacity server which sends a done notification to the task manager. Capacity data is then collected and sent to the transformation service which generates a success notification after which the task is updated . The capacity data is processed after which a success notification is sent to the task manager. Performance data is then collected and sent to the performance data collection server . A success notification is sent to the collector and the task is updated .

Processing may be implemented in hardware software or a combination of the two. Processing may be implemented in computer programs executed on programmable computers machines that each includes a processor a storage medium or other article of manufacture that is readable by the processor including volatile and non volatile memory and or storage elements at least one input device and one or more output devices. Program code may be applied to data entered using an input device to perform processing and to generate output information.

The system can perform processing at least in part via a computer program product e.g. in a machine readable storage device for execution by or to control the operation of data processing apparatus e.g. a programmable processor a computer or multiple computers . Each such program may be implemented in a high level procedural or object oriented programming language to communicate with a computer system. However the programs may be implemented in assembly or machine language. The language may be a compiled or an interpreted language and it may be deployed in any form including as a stand alone program or as a module component subroutine or other unit suitable for use in a computing environment. A computer program may be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network. A computer program may be stored on a storage medium or device e.g. CD ROM hard disk or magnetic diskette that is readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium or device is read by the computer. Processing may also be implemented as a machine readable storage medium configured with a computer program where upon execution instructions in the computer program cause the computer to operate.

Processing may be performed by one or more programmable processors executing one or more computer programs to perform the functions of the system. All or part of the system may be implemented as special purpose logic circuitry e.g. an FPGA field programmable gate array and or an ASIC application specific integrated circuit .

Having described exemplary embodiments of the invention it will now become apparent to one of ordinary skill in the art that other embodiments incorporating their concepts may also be used. The embodiments contained herein should not be limited to disclosed embodiments but rather should be limited only by the spirit and scope of the appended claims. All publications and references cited herein are expressly incorporated herein by reference in their entirety.

