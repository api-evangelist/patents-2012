---

title: Ordering and presenting a set of data tuples
abstract: An approach for managing a set of data tuples is provided. A search tuple is received and a comparison relation is determined. The set of data tuples is ordered based on the comparison relation. A placement of the search tuple is determined between two consecutive data tuples in the ordered set of data tuples so that the search tuple is ordered among the ordered set of data tuples in accordance with the comparison relation. A presentation is generated based on the placement of the search tuple between the two consecutive data tuples. The presentation includes a sequence of data tuples included in the ordered set of data tuples. The sequence includes the two consecutive data tuples and the search tuple between the two consecutive data tuples.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08892576&OS=08892576&RS=08892576
owner: International Business Machines Corporation
number: 08892576
owner_city: Armonk
owner_country: US
publication_date: 20121026
---
The present invention relates to a data processing method and system for managing a data set and more particularly to a technique for ordering and presenting a search tuple among ordered data tuples from a data set.

A user interface providing a known search of a data set includes a filter form and a paginated table. The user enters values on the filter form which is either predefined or dynamic i.e. governed by rules . The user makes a selection to initiate the search of the data set by transforming the values entered on the filter form into a SQL query and executing the query in a database. The database returns the results of the search which includes data that matches the query. Results of the search are displayed in the paginated table. The returned data is a subset of the entire data set i.e. all the data present in the database on which the filter form may be applied . The execution of the SQL query selects subsets of data from a data set under strict conditions that may not fit how a human thinks about a search for data from the data set. The strict conditions enforced by known search approaches leads to searching iterations i.e. a user repeatedly updates search conditions in the filter form and re executes the query until the user s desired result is found.

In a first embodiment the present invention provides a method of managing a set of data tuples. The method includes a computer receiving a search tuple including k elements where k is an integer and k 1. The method further includes the computer determining a comparison relation specifying an ordering of tuples. Each tuple includes k elements. The method further includes the computer ordering the set of data tuples by using the comparison relation and based on value s of k elements included in each data tuple and corresponding to the k elements included in the received search tuple. The method further includes based on the comparison relation the computer determining a placement of the search tuple between two consecutive data tuples in the ordered set of data tuples so that the search tuple is ordered among the ordered set of data tuples in accordance with the comparison relation. The method further includes based on the placement of the search tuple between the two consecutive data tuples so that the search tuple is ordered among the ordered set of data tuples in accordance with the comparison relation the computer generating a presentation of the search tuple among a sequence of data tuples included in the ordered set of data tuples. The sequence includes at least the two consecutive data tuples.

A system program product and a process for supporting computing infrastructure where the process provides at least one support service are also described and claimed herein where the system program product and process for supporting computing infrastructure correspond to the aforementioned method.

Embodiments of the present invention provide a user interface component that enables users to perform a more natural and fuzzy search of a structured data set and generate a display of the user interface component among an ordered version of the structured data set resulting from the search. The user can see the data tuples in the ordered data set that are closest to the user s search query even if an exact match is not found and without regard to a threshold degree of closeness of the data tuples to the values in the search query. In one embodiment the data tuples are displayed in tables in a user interface component where the height of the tables remains consistent so that there are never multiple pages of data tuples. By avoiding multiple pages of data tuples and by keeping the height of the tables consistent the user interface component is well suited to mobile applications.

Embodiments of the present invention provide a complex user interface UI component using a specific data source that enables users to perform natural and fuzzy searches of a structured data set where the data set can be ordered and queried. The UI component may combine a search form together with search result tables into a single component. Value s entered by a user into a search tuple in the search form automatically orders all of the data tuples in the structured data set. The UI component displays in order the search tuple along with data tuples from the ordered data set that most closely match the search tuple. The UI component is not limited to a subset of the data set that is strictly defined by matching values of data tuples to values of the search tuple instead the UI component displays data tuples that are negative as compared to the search tuple and displays other data tuples that are positive as compared to the search tuple taking into consideration how the data set is currently ordered. The data tuples are displayed in the UI component even if an exact match to the search tuple is not found and without requiring any threshold degree of closeness to the search tuple. Embodiments of the present invention may allow the UI component to perform a closest match search on large data pools and structured data streams while allowing the user to avoid searching iterations that include updating search conditions in a filter form in a traditional approach.

Tuple management engine orders the set of data tuples according to the comparison relation . In one embodiment tuple management engine determines a placement of search tuple in the ordered set of data tuples so that the search tuple and the ordered set of data tuples are in an order specified by the comparison relation . Using the placement of the search tuple tuple management engine generates a UI component that includes a presentation of the search tuple placed within a sequence of at least some of the ordered data tuples included in the ordered set of data tuples .

1. Ruler also known as a.k.a. ruler table includes a header search form controls and informational indicators.

2. Negative table a table displayed above the ruler in the UI component where each row of the table includes value s of a corresponding data tuple included in the set of data tuples . The columns of the negative table are associated with domains in the data source in a one to one correspondence. The negative table includes negative information compared to the value s that are currently present in the search form in the ruler. Negative information indicates that value s in each row of the negative table are less than corresponding value s that are currently present in the search form in the ruler.

3. Positive table a table displayed below the ruler in the UI component where each row of the table includes value s of a corresponding data tuple included in the set of data tuples . The columns of the positive table are associated with domains in the data source in a one to one correspondence. The positive table includes positive and equal information compared to the value s that are currently present in the search form in the ruler. Positive and equal information indicates that value s in each row of the positive table are greater than or equal to corresponding value s that are currently present in the search form in the ruler.

In the special case in which the search tuple is a 0 tuple the negative table does not include data tuples in any of its rows i.e. its rows are empty whereas the positive table includes data tuples in rows as long as the data source includes at least some data.

In one embodiment the negative and positive tables include the same number of rows where the number of rows is denoted as depth. That is both the negative and positive tables include depth rows. Having the same number of rows in the negative and positive tables simplifies the implementation because fewer parameters are passed to the data source and there is no need for different caches with different sizes. If the search tuple includes values that order the set of data tuples in such a way that there is less than depth data tuples in the data source on the negative or on the positive side of the ruler then the table i.e. negative or positive table that has less than depth data tuples is not filled in completely thereby including one or more empty rows in which there is no data. Unless the data source is empty there must be at least one data tuple in one row next to the ruler either on the negative or on the positive side of the ruler.

The header consists of header cells. Each header cell includes a name of a domain and is selectable by a user e.g. by clicking or another action to generate an ordering of the set of data tuples . The user manually chooses an ordering of the set of data tuples only if the search form is empty e.g. the search tuple is a 0 tuple . The manual ordering of the set of data tuples is based on data in the domain indicated by a user selection of a header cell. If the search form is filled in by the user with at least one value and the search tuple exists then the ordering of the set of data tuples is determined automatically based on the filled in value s in the search form and the comparison relation . The order in which the search form values are filled in by the user matches the order of the search tuple elements used by the comparison relation . In one embodiment the header cell s selected to determine the ordering include corresponding indicator s where different indicators distinguish between the manual ordering the set of data tuples when the search form is empty and automatic ordering of the set of data tuples based on value s entered in the search form.

The search form includes entry fields labeled by the corresponding header cell where each entry field can receive a value from a user to define and determine a search on the set of data tuples in the data source. Input controls for each domain in the data source determine the type of data that can be entered in each entry field in the search form. As the user enters value s in the search form the search tuple is defined. Elements of the search tuple are ordered in the same order in which the values are entered in the search form.

The search form is sensitive to user changes so that every change to a value in the search form e.g. keystrokes on strings and value changes on other data types is reflected in the search tuple and the search action or data fetch is initiated without a substantial delay. A search action or data fetch is made on the data source to order the data source according to the search tuple . Finding a placement within the ordered data source at which the search tuple belongs is based on the order of data in the data source.

The controls allow a user to perform operations on the UI component . The controls are user selectable buttons or other graphical user interface GUI elements that when selected may perform one or more of the following actions 

Activating the move data tuples down control pushes the search tuple in a negative direction i.e. towards the data tuples that are less than the search tuple so that d data tuples in the negative table move from the negative table to the positive table the d most positive data tuples in the positive table are removed from UI component and the next d data tuples that follow the most negative data tuple in the negative table are fetched from the ordered set of data tuples and added to the negative table. If there are less than d data tuples in the ordered set of data tuples that follow the most negative data tuple currently in the negative table then the remaining i.e. less than d data tuples in the ordered set of data tuples are added to the negative table.

Activating the move data tuples up control pushes the search tuple in a positive direction i.e. towards the data tuples that are greater than or equal to the search tuple so that d data tuples in the positive table move from the positive table to the negative table the d most negative data tuples in the negative table are removed from UI component and the next d data tuples that follow the most positive data tuple in the positive table are fetched from the ordered set of data tuples and added to the positive table. If there are less than d data tuples in the ordered set of data tuples that follow the most positive data tuple currently in the positive table then the remaining i.e. less than d data tuples in the ordered set of data tuples are added to the positive table.

While using the move data tuples up and or move data tuples down controls the user changes the offset of data displayed in the positive and negative tables as compared to the content of the search tuple . Activating the return to offset 0 control clears the current offset and returns the search tuple to its original position in the ordered set of data tuples as determined by the comparison relation . For example if the user activates the move data tuples up control so that the search tuple is pushed from its original position 6 places in the positive direction then the offset changes from 0 to 6. If the user then activates the return to offset 0 control then the search tuple is returned to its original position and the offset is changed from 6 to 0. In one embodiment the offset is displayed on the ruler.

Activating the clear search form control clears the search form and the search tuple so that all the entry fields in the search form are empty.

In one embodiment the negative and positive tables include events that allow user actions on a particular row in the negative or positive table to be propagated for further processing.

If a search action or data fetch from the set of data tuples results in an error then the error is displayed on the ruler indicating the type of problem to the user i.e. problem in communication with the data source or the data source itself encountered an error .

If a search action or data fetch from the set of data tuples results in a specific case that warrants a warning then a warning is displayed on the ruler indicating to the user that the data source encountered a problem of a kind defined by the specific case. For example if the data source is empty a warning is displayed.

The purpose of UI component is providing a specific kind of search on large data pools or streams. One of the innovative features is that UI component is not aware of its current position in the underlying data source. Also the UI component does not need to show any kind of positioning other than the offset as discussed above.

Implementation of UI component provides a caching mechanism. The initial data fetch from the data source or a subsequent search action or data fetch from the data source attempts to provide 2 depth rows in both the positive and negative tables or in a single direction if the UI component specifically asks for rows in a single direction. Moving data tuples up or down may deplete the cache in a particular direction. In response to lacking sufficient data in the cache in one direction i.e. negative or positive then tuple management engine initiates an additional data fetch from the data source to obtain more data for the one direction. Obtained data is added to the cache and displayed if needed. If one of the tables i.e. positive table or negative table is empty i.e. including only empty rows every user action that tries to move data further in the direction of the empty table initiates an additional data fetch from the data source. If the additional data fetch from the data source does not result in obtaining more data for the direction of the move then UI component ensures that there is at least one populated row next to the ruler unless the data source is completely empty. The caching mechanism is tightly coupled with how the data source works with data.

If the source of data is a database then the data source implementation avoids retrieving a large amount of data from the database and uses an optimized search on the database by using techniques offered by the database in order to make the search fast and consume the least possible amount of resources.

UI component is implemented in a way that allows developers and designers to define styling which seamlessly fits the UI component into a larger graphical user interface.

In one embodiment UI component includes structure that specifies the ruler positive table and negative table where the structure is supported by the data source of the UI component . The data source must have the capability of ordering and re ordering data according to a user s request and performing searches on the ordered data and re ordered data.

In one embodiment the data source takes into account the specific ordering of data tuples as requested by a user and indicated on the header and performs a search to find data tuples that are closest to the value s in the search form in the ruler. The closest data tuples found by the data source provide a starting point from which the negative and positive tables are populated. The negative table includes data tuples that are negative compared to the value s in the search form based on the comparison relation . The positive table includes data tuples that match the value s in the search form and further includes other data tuples that are positive compared to the value s in the search form based on the comparison relation . In one embodiment the negative and positive tables are populated from the ruler outwards based on the specific ordering of the data tuples specified by the search form in the ruler.

Details of the functionality of components of system are described below relative to the discussion of and .

In this section relational algebra is used to provide a description of the data source that provides the set of data tuples . A set of domains D is defined as a basis for the data source D D . . . Dn where n 1. The data source DS is described as a number of n tuples i.e. data tuples whose elements are members of the set of domains D 1 111

Every search is defined on a subset of the set of domains as SD with the remainder defined as S D S D S S S S D .

The random elements x and y are related by comparison relation as 11 11x22 . . . 11x22and 11 11x22 . . . 11x22

The search tuple provided by the user is denoted as s s s . . . sk . The search tuple s fits in the ordered data source in a particular place . . . . . . 

The ordered data source specified above can be obtained by multiple SQL queries or with a single more complex SQL query.

In one embodiment the data source is implemented to receive only 1 the search tuple even if S 2 the number of rows the data source must deliver in the negative table and 3 the number of rows the data source must deliver in the positive table. Alternatively the data source receives the search tuple and one number that indicates both the number of rows in the negative table and the number of rows in the positive table.

In one embodiment the data source implementation is constrained by a requirement to support partial matching of string fields. That is a string value in a data tuple in the set of data tuples that begins with a sequence of characters that exactly matches the corresponding string value in the search tuple then the string values are partially matched and the data source implementation considers the string values to be equal when using the comparison relation . For example with partial matching supported Da in the search tuple and Dalibor in a data tuple the data source implementation evaluates Da Dalibor as true.

In the special case in which S it means that the search is not used and is not defined. The data source is DS s e e . . . s which indicates that all members of the data source are positive in comparison to the search tuple which is the 0 tuple in this special case.

In step tuple management engine see determines comparison relation see which specifies an ordering of the set of data tuples see . Each data tuple in the set of data tuples see includes k elements that correspond to the k elements included in search tuple see . Each data tuple in the set of data tuples see may include more than k elements.

In step tuple management engine see orders the complete set of data tuples see i.e. the full data store by using the comparison relation see determined in step . The ordering of the set of data tuples see in step includes comparing the value s of the k elements in the search tuple see received in step to value s of the corresponding k elements included in each data tuple in the set of data tuples see . Hereinafter in the discussion of the result of ordering the set of data tuples see in step is referred to as the ordered set of data tuples. Since step orders an entire data set based on a search tuple the ordering is different from filtering based on search conditions.

Ordering of data in a data source may depend on the implementation of the data source and the developer. A data store e.g. database may order Jo 

In step based on the comparison relation see determined in step and using the value s of the k elements in the search tuple see received in step tuple management engine see determines a placement of the search tuple see between two consecutive data tuples in the ordered set of data tuples so that the search tuple see is ordered among the ordered set of data tuples in accordance with the comparison relation see .

In step based on the placement of the search tuple see determined in step tuple management engine see generates UI component see that includes a presentation of the search tuple see within a sequence of data tuples where the sequence of data tuples is included in the ordered set of data tuples. The aforementioned sequence of data tuples includes at least the two consecutive data tuples between which is the placement determined in step .

In one embodiment the UI component see includes a ruler table that includes entry fields that receive value s in search tuple see . The ruler table may include a row of field names corresponding to the entry fields.

In step tuple management engine see another component of computer system see or another computer system displays and manages the UI component see that includes the presentation of the search tuple see included within the sequence of data tuples included in the ordered set of data tuples.

In step tuple management engine see determines a second ordered subset of data tuples included in the ordered set of data tuples created in step see so that the second ordered subset includes data tuples that are greater than or equal to the search tuple see . The data tuples in the second ordered subset are greater than or equal to the search tuple see based on the comparison relation see determined in step see which is used by tuple management engine see to determine a value of an element in each of the data tuples in the second ordered subset is greater than or equal to a value of a corresponding element in the search tuple see . The aforementioned element in each data tuple in the second ordered subset is the corresponding element of the element in each data tuple in the first ordered subset which is discussed above relative to step .

In an alternate embodiment in step based on the comparison relation see tuple management engine see determines a second ordered subset of data tuples included in the ordered set of data tuples created in step see so that the second ordered subset includes data tuples that are greater than but not equal to the search tuple see . In this alternate embodiment in step based on the comparison relation see tuple management engine see determines a first ordered subset of data tuples included in the ordered set of data tuples created in step see so that the first ordered subset includes data tuples that are less than or equal to the search tuple see .

In step tuple management engine see generates a display having the first ordered subset displayed in one portion of the display the second ordered subset displayed in another portion of the display and the search tuple displayed in between the first and second ordered subsets. In one embodiment step includes generating a display that includes the first ordered subset in an upper portion of the display the second ordered subset in a lower portion of the display and the search tuple in between the upper and lower portions of the display.

In an alternate embodiment step includes generating a display that includes the first ordered subset in a first portion of the display the second ordered subset in a second portion of the display and the search tuple in a third portion of the display. The first and second portions are distinguished from each other by a graphical element and or a graphical attribute.

In step tuple management engine see determines whether a user selection is received where the selection is an instruction to manage the display by moving the display up by d data tuples i.e. move up or moving the display down by d data tuples i.e. move down . If the user selection is received in step and the selection is to move up then the process of continues with step in . If the user selection is received in step and the selection is to move down then the process of continues with step in . If no user selection is received in step then the process of ends at step .

In step in which follows the determination in step see that a user selection to move up d data tuples is received tuple management engine see FIG. updates the display of the search tuple see within a sequence of data tuples included in the set of data tuples see ordered in step see by 

In step which follows the determination in step see that a user selection to move down d data tuples is received tuple management engine see updates the display of the search tuple see within a sequence of data tuples included in the set of data tuples see ordered in step see by 

Step follows step and step . In step tuple management engine see determines whether a user selection is received to return the search tuple see to its original position in the presentation generated in step see . If tuple management engine see determines in step that the aforementioned user selection is received then the Yes branch of step is followed and step is performed.

In step tuple management engine see updates the display by returning the search tuple to its original position in the presentation generated in step see . Step follows step .

Returning to step if tuple management engine see determines that the user selection to return the search tuple to its original position is not received then the No branch of step is followed and step is performed.

In step which follows step and the No branch of step tuple management engine see determines whether management of the display of the search tuple see within the sequence of data tuples is continuing. If step determines that the management of the display is continuing then the Yes branch of step is followed and the process of loops back to step see . If step determines that the management of the display is not continuing then the No branch of step is followed and the process of ends at step .

In the examples presented in this section a ruler table is implemented as a Dojo widget using a Representational State Transfer REST service call with a JAVASCRIPT Object Notation JSON content type as an interface to a JAVA data source implementation. The data source implementation was made for a DB2 database. A Dojo widget is included in a Dojo Toolkit which is an open source modular JAVASCRIPT Toolkit offered by The Dojo Foundation located in Mountain View Calif. The examples in this section use depth 8 and structure field id name ID field name name Name field surname name Surname field birthdate name Birth date type date dateFormat dd.MM.yyyy field height name Height type integer field weight name Weight type decimal .

Ruler table does not yet include values for a search and therefore does not yet order the set of data tuples see based on search tuple see . Instead a positive portion of UI component includes data tuples included in the set of data tuples see and a negative portion of UI component includes no data tuples. The data tuples are ordered in portion depending on the implementation of the underlying data source. In this example the data source implementation uses a DB2 database therefore the data tuples are initially ordered in portion according to the defined primary key which is the id field.

UI component provides options that can be selected by a user including a return to offset 0 button a clear search form button a move data tuples down button and a move data tuples up button . Activating return to offset 0 button returns the search tuple in search form to its original position after the user has activated the move data tuples down button and or the move data tuples up button . Activating the clear search form button clears search form so that all the entry fields in search form are empty. Activating the move data tuples down button pushes the ruler table in a negative direction i.e. towards data tuples that are less than the search tuple so that data tuples in negative portion move from the table in negative portion to the table in positive portion . Activating the move data tuples up button pushes the ruler table in a positive direction i.e. towards data tuples that are greater than the search tuple so that data tuples in positive portion moves from the table in positive portion to the table in negative portion .

In response to the user entry of Da tuple management engine see calls the data source to fetch data tuples from the set of data tuples see and automatically orders the fetched data tuples according to the comparison relation see determined in step see using the value Da in the search tuple. The automatic ordering is denoted by a different indicator e.g. a red arrow to distinguish the ordering from the manual ordering indicated by indicator in .

Tuple management engine see determines in step see a placement of the search tuple see between the data tuple that has Crnko in the Name field and the data tuple that has Damir in the Name field because Da is ordered between Crnko and Damir according to the comparison relation see .

Tuple management engine see generates the presentation in step see included in UI component so that the search tuple see having Da in the Name field is within the sequence of data tuples beginning with the data tuple having Adalbert in the Name field and ending with the data tuple having Ivan in the Name field and in particular is positioned in the placement determined in step see i.e. between the data tuple having Crnko in the name field and the data tuple having Damir in the Name field .

More particularly the presentation resulting from step see includes the search tuple see between one sub sequence of data tuples in a positive portion of UI component and another sub sequence of data tuples in a negative portion of UI component .

In response to the user entry of 197 in entry field tuple management engine see calls the data source to fetch data tuples from the set of data tuples see and automatically orders the fetched data tuples according to the comparison relation see determined in step see using the values Da and 197 in the search tuple. The automatic ordering is denoted by indicators and e.g. red arrows which distinguish the type of ordering from the manual ordering indicated by indicator in .

Tuple management engine see determines in step see a placement of the search tuple see between the data tuple that has Daniel in the Name field and the data tuple that has Darije in the Name field based on the comparison relation see . Because in this example the comparison relation see considers Da in the Name field to be equal to the Name field values in the data tuples having Damir Daniel and Darije the comparison relation next orders the data tuples having equal Name field values based on the values in the Height field. Since the height of 195 in the data tuple having Damir in the Name field and the height of 185 in the data tuple having Daniel in the Name field are less than the height of 197 in the search tuple the data tuples having Damir and Daniel in the Name field are placed in the negative portion along with the data tuples that had been in portion in . Furthermore because the height of 201 in the data tuple having Darije in the Name field is greater than the height of 197 in the search tuple the data tuple having Darije in the Name field is placed in the positive portion along with the data tuples that had been greater than the data tuple having Darije in portion in along with two additional data tuples i.e. the data tuples having Ivana in the Name field fetched from the ordered set of data tuples see to fill up the rows in the table in portion .

Tuple management engine see generates the presentation in step see included in UI component so that the search tuple see having Da in the Name field and 197 in the Height field is within the sequence of data tuples beginning with the data tuple having Adalbert in the Name field and ending with the data tuple having Ivana in the Name field and 16 in the id field and in particular is positioned in the placement determined in step see i.e. between the data tuple having Daniel in the Name field and the data tuple having Darije in the Name field .

More particularly the presentation resulting from step see includes the search tuple see between one sub sequence of data tuples in positive portion of UI component and another sub sequence of data tuples in negative portion of UI component .

To change UI component from the display in to the display in the user activates the move data tuples up button to change the offset from 0 to 6 in step see . The value of d in step is 6 because the offset changes by 6 i.e. 6 0 6 . In response to the user activating the move data tuples up button with d 6 tuple management engine see updates the display of the search tuple within the sequence of data tuples previously shown in by 

 1 removing any data tuples in the 6 uppermost rows of the table in negative portion see i.e. removing the uppermost null data tuple and the five data tuples with the following values in the Name field Adalbert Albert Alberto Bero and Crnko 

 2 moving the six least data tuples from the positive portion see to the negative portion i.e. moving to negative portion the data tuples that have the following values in the Name field Darije Dragica Hrvoje Hrvoje Irena and Ivan and

 3 adding to the positive portion the next six data tuples from the set of data tuples see that had been ordered in step see . The next six data tuples are greater than the previously greatest data tuple in the positive portion see . That is the next six data tuples have the following values in the Name field Marko Tvrtko Velimir Zoltan Zoran and Zoran which are greater than the data tuple that has 16 in the id field and Ivana in the Name field which had been the greatest data tuple in the previous positive portion see .

If the user activates the return to offset 0 button in step see then the display in UI component in is updated in step see by changing back to the display in UI component in where the offset 0.

CPU performs computation and control functions of computer system including carrying out instructions included in program code for tuple management engine hereinafter referred to as program code . The instructions included in program code are carried out by CPU via memory . CPU may comprise a single processing unit or be distributed across one or more processing units in one or more locations e.g. on a client and server . In one embodiment program code includes program code in tuple management engine see .

Memory may comprise any known computer readable storage medium which is described below. In one embodiment cache memory elements of memory provide temporary storage of at least some program code e.g. program code in order to reduce the number of times code must be retrieved from bulk storage while instructions of the program code are carried out. Moreover memory may reside at a respective single physical location comprising one or more types of data storage or be distributed across a plurality of physical systems in various forms. Further memory can include data distributed across for example a local area network LAN or a wide area network WAN .

I O interface comprises any system for exchanging information to or from an external source. I O devices comprise any known type of external device including a display device e.g. monitor keyboard mouse printer speakers handheld device facsimile etc. Bus provides a communication link between each of the components in computer system and may each comprise any type of transmission link including electrical optical wireless etc.

I O interface also allows computer system to store information e.g. data or program instructions such as program code on and retrieve the information from computer data storage unit or another computer data storage unit not shown . Computer data storage unit may comprise any known computer readable storage medium which is described below. For example computer data storage unit may be a non volatile data storage device such as a magnetic disk drive i.e. hard disk drive or an optical disc drive e.g. a CD ROM drive which receives a CD ROM disk .

Memory and or storage unit may store program code that includes instructions that are carried out by CPU via memory to manage a set of data tuples. Although depicts memory as including program code the present invention contemplates embodiments in which memory does not include all of program code simultaneously but instead at one time includes only a portion of program code .

Further memory may include other systems not shown in such as an operating system that runs on CPU and provides control of various components within and or connected to computer system .

Storage unit and or one or more other computer data storage units not shown that are coupled to computer system may store search tuple see comparison relation see set of data tuples see and or UI component see .

As will be appreciated by one skilled in the art the present invention may be embodied as a system method or computer program product. Accordingly an aspect of an embodiment of the present invention may take the form of an entirely hardware aspect an entirely software aspect including firmware resident software micro code etc. or an aspect combining software and hardware aspects that may all generally be referred to herein as a module . Furthermore an embodiment of the present invention may take the form of a computer program product embodied in one or more computer readable medium s e.g. memory and or computer data storage unit having computer readable program code e.g. program code embodied or stored thereon.

Any combination of one or more computer readable mediums e.g. memory and computer data storage unit may be utilized. The computer readable medium may be 1 a computer readable storage medium or 2 a computer readable signal medium. As used herein a computer readable storage medium is not a computer readable signal medium. In the context of this document a computer readable storage medium is a physical tangible storage medium that can contain or store a program e.g. program code for use by or in connection with a system apparatus or device for carrying out instructions in the program and which is not a signal per se and is not a transitory form of signal transmission.

In one embodiment the computer readable storage medium is a physical tangible computer readable storage device or physical tangible computer readable storage apparatus that is not a signal per se and is not a transitory form of signal transmission. A computer readable storage medium may be for example an electronic magnetic optical electromagnetic or semiconductor system apparatus device or any suitable combination of the foregoing that is not a signal per se and is not a transitory form of signal transmission. A non exhaustive list of more specific examples of the computer readable storage medium includes an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing where the aforementioned more specific examples do not include a signal per se or a transitory form of signal transmission.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electromagnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium as described above and that can communicate propagate or transport a program for use by or in connection with a system apparatus or device for carrying out instructions.

Program code e.g. program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable radio frequency RF etc. or any suitable combination of the foregoing.

Computer program code e.g. program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as JAVA Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. Instructions of the program code may be carried out entirely on a user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server where the aforementioned user s computer remote computer and server may be for example computer system or another computer system not shown having components analogous to the components of computer system . In the latter scenario the remote computer may be connected to the user s computer through any type of network not shown including a LAN or a WAN or the connection may be made to an external computer e.g. through the Internet using an Internet Service Provider .

Aspects of the present invention are described herein with reference to flowchart illustrations e.g. and and or block diagrams of methods apparatus systems e.g. and and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions e.g. program code . These computer program instructions may be provided to one or more hardware processors e.g. CPU of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which are carried out via the processor s of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium e.g. memory or computer data storage unit that can direct a computer e.g. computer system other programmable data processing apparatus or other devices to function in a particular manner such that the instructions e.g. program code stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer e.g. computer system other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions e.g. program code which are carried out on the computer other programmable apparatus or other devices provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

Any of the components of an embodiment of the present invention can be deployed managed serviced etc. by a service provider that offers to deploy or integrate computing infrastructure with respect to managing a set of data tuples. Thus an embodiment of the present invention discloses a process for supporting computer infrastructure wherein the process comprises a first computer system providing at least one support service for at least one of integrating hosting maintaining and deploying computer readable code e.g. program code in a second computer system e.g. computer system comprising one or more processors e.g. CPU wherein the processor s carry out instructions contained in the code causing the second computer system to manage a set of data tuples.

In another embodiment the invention provides a method that performs the process steps of the invention on a subscription advertising and or fee basis. That is a service provider such as a Solution Integrator can offer to create maintain support etc. a process of managing a set of data tuples. In this case the service provider can create maintain support etc. a computer infrastructure that performs the process steps of the invention for one or more customers. In return the service provider can receive payment from the customer s under a subscription and or fee agreement and or the service provider can receive payment from the sale of advertising content to one or more third parties.

The flowcharts in and and the block diagrams in and illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present invention. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code e.g. program code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be performed substantially concurrently or the blocks may sometimes be performed in reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustrations and combinations of blocks in the block diagrams and or flowchart illustrations can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

While embodiments of the present invention have been described herein for purposes of illustration many modifications and changes will become apparent to those skilled in the art. Accordingly the appended claims are intended to encompass all such modifications and changes as fall within the true spirit and scope of this invention.

