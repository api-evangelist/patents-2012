---

title: Endpoint-based parallel data processing in a parallel active messaging interface of a parallel computer
abstract: Endpoint-based parallel data processing in a parallel active messaging interface (‘PAMI’) of a parallel computer, the PAMI composed of data communications endpoints, each endpoint including a specification of data communications parameters for a thread of execution on a compute node, including specifications of a client, a context, and a task, the compute nodes coupled for data communications through the PAMI, including establishing a data communications geometry, the geometry specifying, for tasks representing processes of execution of the parallel application, a set of endpoints that are used in collective operations of the PAMI including a plurality of endpoints for one of the tasks; receiving in endpoints of the geometry an instruction for a collective operation; and executing the instruction for a collective operation through the endpoints in dependence upon the geometry, including dividing data communications operations among the plurality of endpoints for one of the tasks.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08804488&OS=08804488&RS=08804488
owner: International Business Machines Corporation
number: 08804488
owner_city: Armonk
owner_country: US
publication_date: 20121109
---
This application is a continuation application of and claims priority from U.S. patent application Ser. No. 12 963 671 filed on Dec. 9 2010.

This invention was made with Government support under Contract No. B554331 awarded by the Department of Energy. The Government has certain rights in this invention.

The field of the invention is data processing or more specifically methods apparatus and products for endpoint based parallel data processing in a parallel active messaging interface PAMI of a parallel computer.

The development of the Electronic Discrete Variable Automatic Computer EDVAC computer system of 1948 is often cited as the beginning of the computer era. Since that time computer systems have evolved into extremely complicated devices. Today s computers are much more sophisticated than early systems such as the EDVAC. Computer systems typically include a combination of hardware and software components application programs operating systems processors buses memory input output devices and so on. As advances in semiconductor processing and computer architecture push the performance of the computer higher and higher more sophisticated computer software has evolved to take advantage of the higher performance of the hardware resulting in computer systems today that are much more powerful than just a few years ago.

Parallel computing is an area of computer technology that has experienced advances. Parallel computing is the simultaneous execution of the same application split up and specially adapted on multiple processors in order to obtain results faster. Parallel computing is based on the fact that the process of solving a problem usually can be divided into smaller jobs which may be carried out simultaneously with some coordination.

Parallel computers execute parallel algorithms. A parallel algorithm can be split up to be executed a piece at a time on many different processing devices and then put back together again at the end to get a data processing result. Some algorithms are easy to divide up into pieces. Splitting up the job of checking all of the numbers from one to a hundred thousand to see which are primes could be done for example by assigning a subset of the numbers to each available processor and then putting the list of positive results back together. In this specification the multiple processing devices that execute the individual pieces of a parallel program are referred to as compute nodes. A parallel computer is composed of compute nodes and other processing nodes as well including for example input output I O nodes and service nodes.

Parallel algorithms are valuable because it is faster to perform some kinds of large computing jobs via a parallel algorithm than it is via a serial non parallel algorithm because of the way modern processors work. It is far more difficult to construct a computer with a single fast processor than one with many slow processors with the same throughput. There are also certain theoretical limits to the potential speed of serial processors. On the other hand every parallel algorithm has a serial part and so parallel algorithms have a saturation point. After that point adding more processors does not yield any more throughput but only increases the overhead and cost.

Parallel algorithms are designed also to optimize one more resource the data communications requirements among the nodes of a parallel computer. There are two ways parallel processors communicate shared memory or message passing. Shared memory processing needs additional locking for the data and imposes the overhead of additional processor and bus cycles and also serializes some portion of the algorithm.

Message passing processing uses high speed data communications networks and message buffers but this communication adds transfer overhead on the data communications networks as well as additional memory need for message buffers and latency in the data communications among nodes. Designs of parallel computers use specially designed data communications links so that the communication overhead will be small but it is the parallel algorithm that decides the volume of the traffic.

Many data communications network architectures are used for message passing among nodes in parallel computers. Compute nodes may be organized in a network as a torus or mesh for example. Also compute nodes may be organized in a network as a tree. A torus network connects the nodes in a three dimensional mesh with wrap around links. Every node is connected to its six neighbors through this torus network and each node is addressed by its x y z coordinate in the mesh. In a tree network the nodes typically are connected into a binary tree each node has a parent and two children although some nodes may only have zero children or one child depending on the hardware configuration . In computers that use a torus and a tree network the two networks typically are implemented independently of one another with separate routing circuits separate physical links and separate message buffers.

A torus network lends itself to point to point operations but a tree network typically is inefficient in point to point communication. A tree network however does provide high bandwidth and low latency for certain collective operations message passing operations where all compute nodes participate simultaneously such as for example an allgather.

There is at this time a general trend in computer processor development to move from multi core to many core processors from dual tri quad hexa octo core chips to ones with tens or even hundreds of cores. In addition multi core chips mixed with simultaneous multithreading memory on chip and special purpose heterogeneous cores promise further performance and efficiency gains especially in processing multimedia recognition and networking applications. This trend is impacting the supercomputing world as well where large transistor count chips are more efficiently used by replicating cores rather than building chips that are very fast but very inefficient in terms of power utilization.

At the same time the network link speed and number of links into and out of a compute node are dramatically increasing. IBM s BlueGene Q supercomputer for example will have a five dimensional torus network which implements ten bidirectional data communications links per compute node and BlueGene Q will support many thousands of compute nodes. To keep these links filled with data DMA engines are employed but increasingly the HPC community is interested in latency. In traditional supercomputers with pared down operating systems there is little or no multi tasking within compute nodes. When a data communications link is unavailable a task typically blocks or spins on a data transmission in effect idling a processor until a data transmission resource becomes available. In the trend for more powerful individual processors such blocking or spinning has a bad effect on latency.

Methods parallel computers and computer program products for endpoint based parallel data processing in a parallel active messaging interface PAMI of a parallel computer the parallel computer including a plurality of compute nodes that execute a parallel application the PAMI composed of data communications endpoints each endpoint including a specification of data communications parameters for a thread of execution on a compute node including specifications of a client a context and a task the compute nodes coupled for data communications through the PAMI including establishing by an application level entity for collective operations of the PAMI a data communications geometry the geometry specifying for tasks representing processes of execution of the parallel application a set of endpoints that are used in collective operations of the PAMI including a plurality of endpoints for one of the tasks receiving in one or more endpoints of the geometry an instruction for a collective operation the instruction specifying communications of transfer data among the endpoints of the geometry and executing the instruction for a collective operation through the endpoints in dependence upon the geometry including dividing data communications operations among the plurality of endpoints for one of the tasks.

The foregoing and other objects features and advantages of the invention will be apparent from the following more particular descriptions of example embodiments of the invention as illustrated in the accompanying drawings wherein like reference numbers generally represent like parts of example embodiments of the invention.

Example methods computers and computer program products for endpoint based parallel data processing in a parallel active messaging interface PAMI of a parallel computer according to embodiments of the present invention are described with reference to the accompanying drawings beginning with . sets forth a block and network diagram of an example parallel computer that implements endpoint based parallel data processing in a PAMI according to embodiments of the present invention. The parallel computer in the example of is coupled to non volatile memory for the computer in the form of data storage device an output device for the computer in the form of printer and an input output device for the computer in the form of computer terminal . The parallel computer in the example of includes a plurality of compute nodes .

The parallel computer in the example of includes a plurality of compute nodes . The compute nodes are coupled for data communications by several independent data communications networks including a high speed Ethernet network a Joint Test Action Group JTAG network a tree network which is optimized for collective operations and a torus network which is optimized point to point operations. Tree network is a data communications network that includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree. Each data communications network is implemented with data communications links among the compute nodes . The data communications links provide data communications for parallel operations among the compute nodes of the parallel computer.

In addition the compute nodes of parallel computer are organized into at least one operational group of compute nodes for collective parallel operations on parallel computer . An operational group of compute nodes is the set of compute nodes upon which a collective parallel operation executes. Collective operations are implemented with data communications among the compute nodes of an operational group. Collective operations are those functions that involve all the compute nodes of an operational group. A collective operation is an operation a message passing computer program instruction that is executed simultaneously that is at approximately the same time by all the compute nodes in an operational group of compute nodes. Such an operational group may include all the compute nodes in a parallel computer or a subset all the compute nodes. Collective operations are often built around point to point operations. A collective operation requires that all processes on all compute nodes within an operational group call the same collective operation with matching arguments. A broadcast is an example of a collective operations for moving data among compute nodes of an operational group. A reduce operation is an example of a collective operation that executes arithmetic or logical functions on data distributed among the compute nodes of an operational group. An operational group may be implemented as for example an MPI communicator. 

 MPI refers to Message Passing Interface a prior art applications messaging module or parallel communications library an application level messaging module of computer program instructions for data communications on parallel computers. Such an application messaging module is disposed in an application messaging layer in a data communications protocol stack. Examples of prior art parallel communications libraries that may be improved for use with parallel computers that implement endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention include IBM s MPI library the Parallel Virtual Machine PVM library MPICH OpenMPI and LAM MPI. MPI is promulgated by the MPI Forum an open group with representatives from many organizations that define and maintain the MPI standard. MPI at the time of this writing is a de facto standard for communication among compute nodes running a parallel program on a distributed memory parallel computer. This specification sometimes uses MPI terminology for ease of explanation although the use of MPI as such is not a requirement or limitation of the present invention.

Most collective operations are variations or combinations of four basic operations broadcast gather scatter and reduce. In a broadcast operation all processes specify the same root process whose buffer contents will be sent. Processes other than the root specify receive buffers. After the operation all buffers contain the message from the root process.

A scatter operation like the broadcast operation is also a one to many collective operation. All processes specify the same receive count. The send arguments are only significant to the root process whose buffer actually contains sendcount N elements of a given datatype where N is the number of processes in the given group of compute nodes. The send buffer will be divided equally and dispersed to all processes including itself . Each compute node is assigned a sequential identifier termed a rank. After the operation the root has sent sendcount data elements to each process in increasing rank order. Rank receives the first sendcount data elements from the send buffer. Rank receives the second sendcount data elements from the send buffer and so on.

A gather operation is a many to one collective operation that is a complete reverse of the description of the scatter operation. That is a gather is a many to one collective operation in which elements of a datatype are gathered from the ranked compute nodes into a receive buffer in a root node.

A reduce operation is also a many to one collective operation that includes an arithmetic or logical function performed on two data elements. All processes specify the same count and the same arithmetic or logical function. After the reduction all processes have sent count data elements from computer node send buffers to the root process. In a reduction operation data elements from corresponding send buffer locations are combined pair wise by arithmetic or logical operations to yield a single corresponding element in the root process s receive buffer. Application specific reduction operations can be defined at runtime. Parallel communications libraries may support predefined operations. MPI for example provides the following predefined reduction operations 

In addition to compute nodes the example parallel computer includes input output I O nodes coupled to compute nodes through one of the data communications networks . The I O nodes provide I O services between compute nodes and I O devices . I O nodes are connected for data communications to I O devices through local area network LAN . Computer also includes a service node coupled to the compute nodes through one of the networks . Service node provides service common to pluralities of compute nodes loading programs into the compute nodes starting program execution on the compute nodes retrieving results of program operations on the computer nodes and so on. Service node runs a service application and communicates with users through a service application interface that runs on computer terminal .

As the term is used here a parallel active messaging interface or PAMI is a system level messaging layer in a protocol stack of a parallel computer that is composed of data communications endpoints each of which is specified with data communications parameters for a thread of execution on a compute node of the parallel computer. The PAMI is a parallel interface in that many instances of the PAMI operate in parallel on the compute nodes of a parallel computer. The PAMI is an active messaging interface in that data communications messages in the PAMI are active messages active in the sense that such messages implement callback functions to advise of message dispatch and instruction completion and so on thereby reducing the quantity of acknowledgment traffic and the like burdening the data communication resources of the PAMI.

Each data communications endpoint of a PAMI is implemented as a combination of a client a context and a task. A client as the term is used in PAMI operations is a collection of data communications resources dedicated to the exclusive use of an application level data processing entity an application or an application messaging module such as an MPI library. A context as the term is used in PAMI operations is composed of a subset of a client s collection of data processing resources context functions and a work queue of data transfer instructions to be performed by use of the subset through the context functions operated by an assigned thread of execution. In at least some embodiments the context s subset of a client s data processing resources is dedicated to the exclusive use of the context. A task as the term is used in PAMI operations refers to a canonical entity an integer or objection oriented programming object that represents in a PAMI a process of execution of the parallel application. That is a task is typically implemented as an identifier of a particular instance of an application executing on a compute node a compute core on a compute node or a thread of execution on a multi threading compute core on a compute node.

In the example of the compute nodes as well as PAMI endpoints on the compute nodes are coupled for data communications through the PAMI and through data communications resources such as collective network and point to point network . The implementation of endpoint based parallel data processing by the parallel computer of is further explained with reference to a send buffer of a root task a set of transfer data a data communications geometry a set of endpoints of the geometry and a plurality of endpoints for one task. The parallel computer of operates generally to carry out endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention by establishing by an application level entity that is an application as such or an application messaging module for collective operations of the PAMI a data communications geometry . The geometry specifies for tasks representing processes of execution of the parallel application a set of endpoints that are used in collective operations of the PAMI including a plurality of endpoints for one of the tasks. Other PAMI tasks can have one or more endpoints in the geometry but at least one of the tasks has a plurality of endpoints in the geometry. The parallel computer of further operates generally to carry out endpoint based parallel data processing in a PAMI by receiving in one or more endpoints in this example endpoint of the geometry an instruction for a collective operation. The instruction specifies communications of transfer data among the endpoints of the geometry in this example from a send buffer of a root task as in a BROADCAST or SCATTER collective operation. The instruction is receives as a post by application or application messaging module into a work queue of a context of the endpoint . The parallel computer of further operates generally to carry out endpoint based parallel data processing in a PAMI by executing the instruction through the endpoints in dependence upon the geometry including dividing data communications operations among the plurality of endpoints for one of the tasks.

Examples of instruction types include SEND instructions for data transfers through networks PUT instructions for data transfers through DMA GET instructions for data transfer through segments of shared memory and others. Data communications instructions including instructions for collective operations processed by the parallel computer here can include both eager data communications instructions receive instructions DMA PUT instructions DMA GET instructions and so on. Some data communications instructions typically GETs and PUTs are one sided DMA instructions in that there is no cooperation required from a target processor no computation on the target side to complete such a PUT or GET because data is transferred directly to or from memory on the other side of the transfer. In this setting the term target is used for either PUT or GET. A PUT target receives data directly into its RAM from an origin endpoint. A GET target provides data directly from its RAM to the origin endpoint. Thus readers will recognize that the designation of an endpoint as an origin endpoint for a transfer is a designation of the endpoint that initiates execution of a DMA transfer instruction rather than a designation of the direction of the transfer PUT instructions transfer data from an origin endpoint to a target endpoint. GET instructions transfer data from a target endpoint to an origin endpoint.

In any particular communication of data an origin endpoint and a target endpoint can be any two endpoints on any of the compute nodes on different compute nodes or two endpoints on the same compute node. Collective operations can have one origin endpoint and many target endpoints as in a BROADCAST for example or many origin endpoints and one target endpoint as in a GATHER for example. A sequence of data communications instructions including instructions for collective operations resides in a work queue of a context and results in data transfers among endpoints origin endpoints and target endpoints. Data communications instructions including instructions for collective operations are active in the sense that the instructions implement callback functions to advise of and implement instruction dispatch and instruction completion thereby reducing the quantity of acknowledgment traffic required on the network. Each such data communications instruction or instruction for a collective operation effects a data transfer or transfers from one or more origin endpoints to one or more target endpoints through some form of data communications resources networks shared memory segments network adapters DMA controllers and the like.

The arrangement of compute nodes networks and I O devices making up the example parallel computer illustrated in are for explanation only not for limitation of the present invention. Parallel computers capable of data communications in a PAMI according to embodiments of the present invention may include additional nodes networks devices and architectures not shown in as will occur to those of skill in the art. For ease of explanation the parallel computer in the example of is illustrated with only one data buffer one set of transfer data and only a few endpoints readers will recognize however that practical embodiments of such a parallel computer will include many buffers send buffers and receive buffers many sets of transfer data and many endpoints. The parallel computer in the example of includes sixteen compute nodes some parallel computers that implement endpoint based parallel data processing in a PAMI according to some embodiments of the present invention include thousands of compute nodes. In addition to Ethernet and JTAG networks in such data processing systems may support many data communications protocols including for example TCP Transmission Control Protocol IP Internet Protocol and others as will occur to those of skill in the art. Various embodiments of the present invention may be implemented on a variety of hardware platforms in addition to those illustrated in .

Endpoint based parallel data processing in a PAMI according to embodiments of the present invention is generally implemented on a parallel computer that includes a plurality of compute nodes. In fact such computers may include thousands of such compute nodes with a compute node typically executing at least one instance of a parallel application. Each compute node is in turn itself a computer composed of one or more computer processors its own computer memory and its own input output I O adapters. For further explanation therefore sets forth a block diagram of an example compute node for use in a parallel computer that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. The compute node of includes one or more computer processors as well as random access memory RAM . Each processor can support multiple hardware compute cores and each such core can in turn support multiple threads of execution hardware threads of execution as well as software threads. Each processor is connected to RAM through a high speed front side bus bus adapter and a high speed memory bus and through bus adapter and an extension bus to other components of the compute node. Stored in RAM is an application program a module of computer program instructions that carries out parallel user level data processing using parallel algorithms.

Also stored RAM is an application messaging module a library of computer program instructions that carry out application level parallel communications among compute nodes including point to point operations as well as collective operations. Although the application program can call PAMI routines directly the application program often executes point to point data communications operations by calling software routines in the application messaging module which in turn is improved according to embodiments of the present invention to use PAMI functions to implement such communications. An application messaging module can be developed from scratch to use a PAMI according to embodiments of the present invention using a traditional programming language such as the C programming language or C for example and using traditional programming methods to write parallel communications routines that send and receive data among PAMI endpoints and compute nodes through data communications networks or shared memory transfers. In this approach the application messaging module exposes a traditional interface such as MPI to the application program so that the application program can gain the benefits of a PAMI with no need to recode the application. As an alternative to coding from scratch therefore existing prior art application messaging modules may be improved to use the PAMI existing modules that already implement a traditional interface. Examples of prior art application messaging modules that can be improved to implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention include such parallel communications libraries as the traditional Message Passing Interface MPI library the Parallel Virtual Machine PVM library MPICH and the like.

Also represented in RAM in the example of is a PAMI . Readers will recognize however that the representation of the PAMI in RAM is a convention for ease of explanation rather than a limitation of the present invention because the PAMI and its components endpoints clients contexts and so on have particular associations with and inclusions of hardware data communications resources. In fact the PAMI can be implemented partly as software or firmware and hardware or even at least in some embodiments entirely in hardware.

Also represented in RAM in the example of is a segment of shared memory. In typical operation the operating system in this example compute node assigns portions of address space to each processor and to the extent that the processors include multiple compute cores treats each compute core as a separate processor with its own assignment of a portion of core memory or RAM for a separate heap stack memory variable storage and so on. The default architecture for such apportionment of memory space is that each processor or compute core operates its assigned portion of memory separately with no ability to access memory assigned to another processor or compute core. Upon request however the operating system grants to one processor or compute core the ability to access a segment of memory that is assigned to another processor or compute core and such a segment is referred to in this specification as a segment of shared memory. 

In the example of each processor or compute core has uniform access to the RAM on the compute node so that accessing a segment of shared memory is equally fast regardless where the shared segment is located in physical memory. In some embodiments however modules of physical memory are dedicated to particular processors so that a processor may access local memory quickly and remote memory more slowly a configuration referred to as a Non Uniform Memory Access or NUMA. In such embodiments a segment of shared memory can be configured locally for one endpoint and remotely for another endpoint or remotely from both endpoints of a communication. From the perspective of an origin endpoint transmitting data through a segment of shared memory that is configured remotely with respect to the origin endpoint transmitting data through the segment of shared memory will appear slower that if the segment of shared memory were configured locally with respect to the origin endpoint or if the segment were local to both the origin endpoint and the target endpoint. This is the effect of the architecture represented by the compute node in the example of with all processors and all compute cores coupled through the same bus to the RAM that all accesses to segments of memory shared among processes or processors on the compute node are local and therefore very fast.

Also stored in RAM in the example compute node of is an operating system a module of computer program instructions and routines for an application program s access to other resources of the compute node. It is possible in some embodiments at least for an application program an application messaging module and a PAMI in a compute node of a parallel computer to run threads of execution with no user login and no security issues because each such thread is entitled to complete access to all resources of the node. The quantity and complexity of duties to be performed by an operating system on a compute node in a parallel computer therefore can be somewhat smaller and less complex than those of an operating system on a serial computer with many threads running simultaneously with various level of authorization for access to resources. In addition there is no video I O on the compute node of another factor that decreases the demands on the operating system. The operating system may therefore be quite lightweight by comparison with operating systems of general purpose computers a pared down or lightweight version as it were or an operating system developed specifically for operations on a particular parallel computer. Operating systems that may be improved or simplified for use in a compute node according to embodiments of the present invention include UNIX Linux Microsoft XP AIX IBM s i5 OS and others as will occur to those of skill in the art.

The example compute node of includes several communications adapters for implementing data communications with other nodes of a parallel computer. Such data communications may be carried out serially through RS 232 connections through external buses such as USB through data communications networks such as IP networks and in other ways as will occur to those of skill in the art. Communications adapters implement the hardware level of data communications through which one computer sends data communications to another computer directly or through a network. Examples of communications adapters for use in computers that implement endpoint based parallel data processing in a parallel active messaging interface PAMI according to embodiments of the present invention include modems for wired communications Ethernet IEEE 802.3 adapters for wired network communications and 802.11b adapters for wireless network communications.

The data communications adapters in the example of include a Gigabit Ethernet adapter that couples example compute node for data communications to a Gigabit Ethernet . Gigabit Ethernet is a network transmission standard defined in the IEEE 802.3 standard that provides a data rate of 1 billion bits per second one gigabit . Gigabit Ethernet is a variant of Ethernet that operates over multimode fiber optic cable single mode fiber optic cable or unshielded twisted pair.

The data communications adapters in the example of includes a JTAG Slave circuit that couples example compute node for data communications to a JTAG Master circuit . JTAG is the usual name for the IEEE 1149.1 standard entitled Standard Test Access Port and Boundary Scan Architecture for test access ports used for testing printed circuit boards using boundary scan. JTAG is so widely adapted that at this time boundary scan is more or less synonymous with JTAG. JTAG is used not only for printed circuit boards but also for conducting boundary scans of integrated circuits and is also used as a mechanism for debugging embedded systems providing a convenient back door into the system. The example compute node of may be all three of these It typically includes one or more integrated circuits installed on a printed circuit board and may be implemented as an embedded system having its own processor its own memory and its own I O capability. JTAG boundary scans through JTAG Slave may efficiently configure processor registers and memory in compute node for use in data communications in a PAMI according to embodiments of the present invention.

The data communications adapters in the example of includes a Point To Point Adapter that couples example compute node for data communications to a data communications network that is optimal for point to point message passing operations such as for example a network configured as a three dimensional torus or mesh. Point To Point Adapter provides data communications in six directions on three communications axes x y and z through six bidirectional links x x y y z and z . For ease of explanation the Point To Point Adapter of as illustrated is configured for data communications in three dimensions x y and z but readers will recognize that Point To Point Adapters optimized for point to point operations in data communications in a PAMI of a parallel computer according to embodiments of the present invention may in fact be implemented so as to support communications in two dimensions four dimensions five dimensions and so on.

The data communications adapters in the example of includes a Collective Operations Adapter that couples example compute node for data communications to a network that is optimal for collective message passing operations such as for example a network configured as a binary tree. Collective Operations Adapter provides data communications through three bidirectional links two to children nodes and one to a parent node .

The example compute node includes a number of arithmetic logic units ALUs . ALUs are components of processors and a separate ALU is dedicated to the exclusive use of collective operations adapter for use in performing the arithmetic and logical functions of reduction operations. Computer program instructions of a reduction routine in an application messaging module or a PAMI may latch an instruction for an arithmetic or logical function into instruction register . When the arithmetic or logical function of a reduction operation is a sum or a logical OR for example collective operations adapter may execute the arithmetic or logical operation by use of an ALU in a processor or typically much faster by use of the dedicated ALU .

The example compute node of includes a direct memory access DMA controller a module of automated computing machinery that implements through communications with other DMA engines on other compute nodes or on a same compute node direct memory access to and from memory on its own compute node as well as memory on other compute nodes. Direct memory access is a way of reading and writing to and from memory of compute nodes with reduced operational burden on computer processors a CPU initiates a DMA transfer but the CPU does not execute the DMA transfer. A DMA transfer essentially copies a block of memory from one compute node to another or between RAM segments of applications on the same compute node from an origin to a target for a PUT operation from a target to an origin for a GET operation.

For further explanation illustrates an example of a Point To Point Adapter useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. Point To Point Adapter is designed for use in a data communications network optimized for point to point operations a network that organizes compute nodes in a three dimensional torus or mesh. Point To Point Adapter in the example of provides data communication along an x axis through four unidirectional data communications links to and from the next node in the x direction and to and from the next node in the x direction . Point To Point Adapter also provides data communication along a y axis through four unidirectional data communications links to and from the next node in the y direction and to and from the next node in the y direction . Point To Point Adapter in also provides data communication along a z axis through four unidirectional data communications links to and from the next node in the z direction and to and from the next node in the z direction . For ease of explanation the Point To Point Adapter of as illustrated is configured for data communications in only three dimensions x y and z but readers will recognize that Point To Point Adapters optimized for point to point operations in a parallel computer that implements endpoint based parallel data processing according to embodiments of the present invention may in fact be implemented so as to support communications in two dimensions four dimensions five dimensions and so on. Several supercomputers now use five dimensional mesh or torus networks including for example IBM s Blue Gene Q .

For further explanation illustrates an example of a Collective Operations Adapter useful in a parallel computer that implements endpoint based parallel data processing in a PAMI according to embodiments of the present invention. Collective Operations Adapter is designed for use in a network optimized for collective operations a network that organizes compute nodes of a parallel computer in a binary tree. Collective Operations Adapter in the example of provides data communication to and from two children nodes through four unidirectional data communications links . Collective Operations Adapter also provides data communication to and from a parent node through two unidirectional data communications links .

For further explanation sets forth a line drawing illustrating an example data communications network optimized for point to point operations useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes. The data communications links are implemented with point to point data communications adapters similar to the one illustrated for example in with data communications links on three axis x y and z and to and fro in six directions x x y y z and z . The links and compute nodes are organized by this data communications network optimized for point to point operations into a three dimensional mesh . The mesh has wrap around links on each axis that connect the outermost compute nodes in the mesh on opposite sides of the mesh . These wrap around links form a torus . Each compute node in the torus has a location in the torus that is uniquely specified by a set of x y z coordinates. Readers will note that the wrap around links in the y and z directions have been omitted for clarity but are configured in a similar manner to the wrap around link illustrated in the x direction. For clarity of explanation the data communications network of is illustrated with only 27 compute nodes but readers will recognize that a data communications network optimized for point to point operations in a parallel computer that implements endpoint based parallel data processing according to embodiments of the present invention may contain only a few compute nodes or may contain thousands of compute nodes. For ease of explanation the data communications network of FIG. is illustrated with only three dimensions x y and z but readers will recognize that a data communications network optimized for point to point operations may in fact be implemented in two dimensions four dimensions five dimensions and so on. As mentioned several supercomputers now use five dimensional mesh or torus networks including IBM s Blue Gene Q .

For further explanation illustrates an example data communications network optimized for collective operations by organizing compute nodes in a tree. The example data communications network of includes data communications links connected to the compute nodes so as to organize the compute nodes as a tree.

In the example of dots represent compute nodes of a parallel computer and the dotted lines between the dots represent data communications links between compute nodes. The data communications links are implemented with collective operations data communications adapters similar to the one illustrated for example in with each node typically providing data communications to and from two children nodes and data communications to and from a parent node with some exceptions. Nodes in a binary tree may be characterized as a root node branch nodes and leaf nodes . The root node has two children but no parent. The leaf nodes each has a parent but leaf nodes have no children. The branch nodes each has both a parent and two children. The links and compute nodes are thereby organized by this data communications network optimized for collective operations into a binary tree . For clarity of explanation the data communications network of is illustrated with only 31 compute nodes but readers will recognize that a data communications network optimized for collective operations for use in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention may contain only a few compute nodes or hundreds or thousands of compute nodes.

In the example of each node in the tree is assigned a unit identifier referred to as a rank . The rank actually identifies an instance of a parallel application that is executing on a compute node. That is the rank is an application level identifier. Using the rank to identify a node assumes that only one such instance of an application is executing on each node. A compute node can however support multiple processors each of which can support multiple processing cores so that more than one process or instance of an application can easily be present under execution on any given compute node or in all the compute nodes for that matter. To the extent that more than one instance of an application executes on a single compute node the rank identifies the instance of the application as such rather than the compute node. A rank uniquely identifies an application s location in the tree network for use in both point to point and collective operations in the tree network. The ranks in this example are assigned as integers beginning with 0 assigned to the root instance or root node 1 assigned to the first node in the second layer of the tree 2 assigned to the second node in the second layer of the tree 3 assigned to the first node in the third layer of the tree 4 assigned to the second node in the third layer of the tree and so on. For ease of illustration only the ranks of the first three layers of the tree are shown here but all compute nodes or rather all application instances in the tree network are assigned a unique rank. Such rank values can also be assigned as identifiers of application instances as organized in a mesh or torus network.

For further explanation sets forth a block diagram of an example protocol stack useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. The example protocol stack of includes a hardware layer a system messaging layer an application messaging layer and an application layer . For ease of explanation the protocol layers in the example stack of are shown connecting an origin compute node and a target compute node although it is worthwhile to point out that in embodiments that effect DMA data transfers the origin compute node and the target compute node can be the same compute node. The granularity of connection through the system messaging layer which is implemented with a PAMI is finer than merely compute node to compute node because again communications among endpoints often is communications among endpoints on the same compute node. For further explanation recall that the PAMI connects endpoints connections specified by combinations of clients contexts and tasks each such combination being specific to a thread of execution on a compute node with each compute node capable of supporting many threads and therefore many endpoints. Every endpoint typically can function as both an origin endpoint or a target endpoint for data transfers through a PAMI and both the origin endpoint and its target endpoint can be located on the same compute node. So an origin compute node and its target compute node can in fact and often will be the same compute node.

The application layer provides communications among instances of a parallel application running on the compute nodes by invoking functions in an application messaging module installed on each compute node. Communications among instances of the application through messages passed between the instances of the application. Applications may communicate messages invoking function of an application programming interface API exposed by the application messaging module . In this approach the application messaging module exposes a traditional interface such as an API of an MPI library to the application program so that the application program can gain the benefits of a PAMI reduced network traffic callback functions and so on with no need to recode the application. Alternatively if the parallel application is programmed to use PAMI functions the application can call the PAMI functions directly without going through the application messaging module.

The example protocol stack of includes a system messaging layer implemented here as a PAMI . The PAMI provides system level data communications functions that support messaging in the application layer and the application messaging layer . Such system level functions are typically invoked through an API exposed to the application messaging modules in the application messaging layer . Although developers can in fact access a PAMI API directly by coding an application to do so a PAMI s system level functions in the system messaging layer in many embodiments are isolated from the application layer by the application messaging layer making the application layer somewhat independent of system specific details. With an application messaging module presenting a standard MPI API to an application for example with the application messaging module retooled to use the PAMI to carry out the low level messaging functions the application gains the benefits of a PAMI with no need to incur the expense of reprogramming the application to call the PAMI directly. Because however some applications will in fact be reprogrammed to call the PAMI directly all entities in the protocol stack above the PAMI are viewed by PAMI as applications. When PAMI functions are invoked by entities above the PAMI in the stack the PAMI makes no distinction whether the caller is in the application layer or the application messaging layer no distinction whether the caller is an application as such or an MPI library function invoked by an application. As far as the PAMI is concerned any caller of a PAMI function is an application.

The protocol stack of includes a hardware layer that defines the physical implementation and the electrical implementation of aspects of the hardware on the compute nodes such as the bus network cabling connector types physical data rates data transmission encoding and many other factors for communications between the compute nodes on the physical network medium. In parallel computers that implement endpoint based parallel data processing with DMA controllers according to embodiments of the present invention the hardware layer includes DMA controllers and network links including routers packet switches and the like.

For further explanation sets forth a functional block diagram of an example PAMI for use in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. The PAMI provides an active messaging layer that supports both point to point communications in a mesh or torus as well as collective operations gathers reductions barriers and the like in tree networks for example. The PAMI is a multithreaded parallel communications engine designed to provide low level message passing functions many of which are one sided and abstract such functions for higher level messaging middleware referred to in this specification as application messaging modules in an application messaging layer. In the example of the application messaging layer is represented by a generic MPI module appropriate for ease of explanation because some form of MPI is a de facto standard for such messaging middleware. Compute nodes and communications endpoints of a parallel computer on are coupled for data communications through such a PAMI and through data communications resources that include DMA controllers network adapters and data communications networks through which controllers and adapters deliver data communications.

The PAMI provides data communications among data communications endpoints where each endpoint is specified by data communications parameters for a thread of execution on a compute node including specifications of a client a context and a task. In the particular example of application has mapped thread to advance work on context of endpoint and the combination of client task and context effectively specify data communications parameters for thread . Similarly application has mapped thread to advance work on context of endpoint and the combination of client task and context effectively specify data communications parameters for thread . Application has mapped thread to advance work on context of endpoint and the combination of client task and context effectively specify data communications parameters for thread . And application has mapped thread to advance work on context of endpoint and the combination of client task and context effectively specify data communications parameters for thread . In these examples a separate thread is assigned to advance work on each context of an endpoint but that is not a requirement of the invention. In embodiments one thread can advance work on more than one context or endpoint and more than one thread can be permitted to post work to a same context of an endpoint.

The PAMI in this example includes PAMI clients tasks contexts and endpoints . A PAMI client is a collection of data communications resources dedicated to the exclusive use of an application level data processing entity an application or an application messaging module such as an MPI library. Data communications resources assigned in collections to PAMI clients are explained in more detail below with reference to . PAMI clients on enable higher level middleware application messaging modules MPI libraries and the like to be developed independently so that each can be used concurrently by an application. Although the application messaging layer in is represented for example by a single generic MPI module in fact a PAMI operating multiple clients can support multiple message passing libraries or application messaging modules simultaneously a fact that is explained in more detail with reference to . sets forth a functional block diagram of an example PAMI useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention in which the example PAMI operates on behalf of an application with multiple application messaging modules simultaneously. The application can have multiple messages in transit simultaneously through each of the application messaging modules . Each context carries out through post and advance functions data communications for the application on data communications resources in the exclusive possession in each client of that context. Each context carries out data communications operations independently and in parallel with other contexts in the same or other clients. In the example each client includes a collection of data communications resources dedicated to the exclusive use of an application level data processing entity one of the application messaging modules 

Again referring to the example of The PAMI includes tasks listed in task lists and identified to the application . A task as the term is used in PAMI operations is a platform defined integer datatype that identifies a canonical application process an instance of a parallel application . Very carefully in this specification the term task is always used to refer only to this PAMI structure not the traditional use of the computer term task to refer to a process or thread of execution. In this specification the term process refers to a canonical data processing process a container for threads in a multithreading environment. In particular in the example of the application is implemented as a canonical process with multiple threads assigned various duties by a leading thread which itself executes an instance of a parallel application program. Each instance of a parallel application is assigned a task each task so assigned can be an integer value for example in a C environment or a separate task object in a C or Java environment. The tasks are components of communications endpoints but are not themselves communications endpoints tasks are not addressed directly for data communications in PAMI. This gives a finer grained control than was available in prior message passing art. Each client has its own list of tasks for which its contexts provide services this allows each process to potentially reside simultaneously in two or more different communications domains as will be the case in certain advanced computers using for example one type of processor and network in one domain and a completely different processor type and network in another domain all in the same computer.

The PAMI includes contexts . A context as the term is used in PAMI operations is composed of a subset of a client s collection of data processing resources context functions and a work queue of data transfer instructions to be performed by use of the subset through the context functions operated by an assigned thread of execution. That is a context represents a partition of the local data communications resources assigned to a PAMI client. Every context within a client has equivalent functionality and semantics. Context functions implement contexts as threading points that applications use to optimize concurrent communications. Communications initiated by a local process an instance of a parallel application uses a context object to identify the specific threading point that will be used to issue a particular communication independent of communications occurring in other contexts. In the example of where the application and the application messaging module are both implemented as canonical processes with multiple threads of execution each has assigned or mapped particular threads to advance work on the contexts including execution of local callbacks . In particular the local event callback functions associated with any particular communication are invoked by the thread advancing the context that was used to initiate the communication operation in the first place. Like PAMI tasks contexts are not used to directly address a communication destination or target as they are a local resource.

Context functions explained here with regard to references on include functions to create and destroy contexts functions to lock and unlock access to a context and functions to post and advance work in a context. For ease of explanation the context functions are illustrated in only one expanded context readers will understand however that all PAMI contexts have similar context functions. The create and destroy functions are in an object oriented sense constructors and destructors. In the example embodiments described in this specifications post and advance functions on a context are critical sections not thread safe. Applications using such non reentrant functions must somehow ensure that critical sections are protected from re entrant use. Applications can use mutual exclusion locks to protect critical sections. The lock and unlock functions in the example of provide and operate such a mutual exclusion lock to protect the critical sections in the post and advance functions. If only a single thread posts or advances work on a context then that thread need never lock that context. To the extent that progress is driven independently on a context by a single thread of execution then no mutual exclusion locking of the context itself is required provided that no other thread ever attempts to call a function on such a context. If more than one thread will post or advance work on a context each such thread must secure a lock before calling a post or an advance function on that context. This is one reason why it is probably a preferred architecture given sufficient resources to assign one thread to operate each context. Progress can be driven with advance functions concurrently among multiple contexts by using multiple threads as desired by an application shown in the example of by threads which advance work concurrently independently and in parallel on contexts .

Posts and advances on are functions called on a context either in a C type function with a context ID as a parameter or in object oriented practice where the calling entity possesses a reference to a context or a context object as such and the posts and advances are member methods of a context object. Again referring to Application level entities application programs and application messaging modules post data communications instructions including SENDs RECEIVEs PUTs GETs and so on to the work queues in contexts and then call advance functions on the contexts to progress specific data processing and data communications that carry out the instructions. The data processing and data communications effected by the advance functions include specific messages request to send RTS messages acknowledgments callback execution transfers of transfer data or payload data and so on. Advance functions therefore operate generally by checking a work queue for any new instructions that need to be initiated and checking data communications resources for any incoming message traffic that needs to be administered as well as increases in storage space available for outgoing message traffic with callbacks and the like. Advance functions also carry out or trigger transfers of transfer data or payload data.

In at least some embodiments a context s subset of a client s data processing resources is dedicated to the exclusive use of the context. In the example of context has a subset of a client s data processing resources dedicated to the exclusive use of the context and context has a subset of a client s data processing resources dedicated to the exclusive use of the context . Advance functions called on contexts therefore never need to secure a lock on a data communications resource before progressing work on a context because each context has exclusive use of dedicated data communications resources. Usage of data communications resources in this example PAMI however is not thread safe. When data communications resources are shared among contexts mutual exclusion locks are needed. In contrast to the exclusive usage of resources by contexts contexts share access to their client s data communications resource and therefore do not have data communications resources dedicated to exclusive use of a single context. Contexts therefore always must secure a mutual exclusion lock on a data communications resource before using the resource to send or receive administrative messages or transfer data.

For further explanation here is an example pseudocode Hello World program for an application using a PAMI 

This short program is termed pseudocode because it is an explanation in the form of computer code not a working model not an actual program for execution. In this pseudocode example an application initializes a client and a context for an application named PAMI. PAMI Client initialize and PAMI Context createv are initialization functions exposed to applications as part of a PAMI s API. These functions in dependence upon the application name PAMI pull from a PAMI configuration the information needed to establish a client and a context for the application. The application uses this segment 

For further explanation of data communications resources assigned in collections to PAMI clients sets forth a block diagram of example data communications resources useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. The data communications resources of include a gigabit Ethernet adapter an Infiniband adapter a Fibre Channel adapter a PCI Express adapter a collective operations network configured as a tree shared memory DMA controllers and a network configured as a point to point torus or mesh like the network described above with reference to . A PAMI is configured with clients each of which is in turn configured with certain collections of such data communications resources so that for example the PAMI client in the PAMI in the example of can have dedicated to its use a collection of data communications resources composed of six segments of shared memory six Gigabit Ethernet adapters and six Infiniband adapters . And the PAMI client can have dedicated to its use six Fibre Channel adapters a DMA controller a torus network and five segments of shared memory. And so on.

The DMA controllers in the example of each is configured with DMA control logic in the form of a DMA engine an injection FIFO buffer and a receive FIFO buffer . The DMA engines can be implemented as hardware components logic networks of a DMA controller in firmware as software operating an embedded controller as various combinations of software firmware or hardware and so on. Each DMA engine operates on behalf of endpoints to send and receive DMA transfer data through the network . The DMA engines operate the injection buffers by processing first in first out descriptors in the buffers hence the designation injection FIFO and receive FIFO. 

For further explanation here is an example use case a description of the overall operation of an example PUT DMA transfer using the DMA controllers and network in the example of An originating application which is typically one instance of a parallel application running on a compute node places a quantity of transfer data at a location in its RAM . The application then calls a post function on a context of an origin endpoint posting a PUT instruction into a work queue of the context the PUT instruction specifies a target endpoint to which the transfer data is to be sent as well as source and destination memory locations. The application then calls an advance function on the context . The advance function finds the new PUT instruction in its work queue and inserts a data descriptor into the injection FIFO of the origin DMA controller the data descriptor includes the source and destination memory locations and the specification of the target endpoint. The origin DMA engine then transfers the data descriptor as well as the transfer data through the network to the DMA controller on the target side of the transaction. The target DMA engine upon receiving the data descriptor and the transfer data places the transfer data into the RAM of the target application at the location specified in the data descriptor and inserts into the target DMA controller s receive FIFO a data descriptor that specifies the target endpoint and the location of the transfer data in RAM . The target application or application instance calls an advance function on a context of the target endpoint . The advance function checks the communications resources assigned to its context for incoming messages including checking the receive FIFO of the target DMA controller for data descriptors that specify the target endpoint . The advance function finds the data descriptor for the PUT transfer and advises the target application that its transfer data has arrived. A GET type DMA transfer works in a similar manner with some differences including of course the fact that transfer data flows in the opposite direction. Similarly typical SEND transfers also operate similarly some with rendezvous protocols some with eager protocols with data transmitted in packets over the a network through non DMA network adapters or through DMA controllers.

The example of includes two DMA controllers . DMA transfers between endpoints on separate compute nodes use two DMA controllers one on each compute node. Compute nodes can be implemented with multiple DMA controllers so that many or even all DMA transfers even among endpoints on a same compute node can be carried out using two DMA engines. In some embodiments at least however a compute node like the example compute node of has only one DMA engine so that that DMA engine can be use to conduct both sides of transfers between endpoints on that compute node. For further explanation of this fact sets forth a functional block diagram of an example DMA controller operatively coupled to a network in an architecture where this DMA controller is the only DMA controller on a compute node and an origin endpoint and its target endpoint are both located on the same compute node . In the example of a single DMA engine operates with two threads of execution on behalf of endpoints on a same compute node to send and receive DMA transfer data through a segment of shared memory. A transmit thread injects transfer data into the network as specified in data descriptors in an injection FIFO buffer and a receive thread receives transfer data from the network as specified in data descriptors in a receive FIFO buffer .

The overall operation of an example PUT DMA transfer with the DMA controllers and the network in the example of is An originating application that is actually one of multiple instances of a parallel application running on a compute node in separate threads of execution places a quantity of transfer data at a location in its RAM . The application then calls a post function on a context of an origin endpoint posting a PUT instruction into a work queue of the context the PUT instruction specifies a target endpoint to which the transfer data is to be sent as well as source and destination memory locations. The application then calls an advance function on the context . The advance function finds the new PUT instruction in its work queue and inserts a data descriptor into the injection FIFO of the DMA controller the data descriptor includes the source and destination memory locations and the specification of the target endpoint. The DMA engine then transfers by its transmit and receive threads through the network the data descriptor as well as the transfer data .

The DMA engine upon receiving by its receive thread the data descriptor and the transfer data places the transfer data into the RAM of the target application and inserts into the DMA controller s receive FIFO a data descriptor that specifies the target endpoint and the location of the transfer data in RAM . The target application calls an advance function on a context of the target endpoint . The advance function checks the communications resources assigned to its context for incoming messages including checking the receive FIFO of the DMA controller for data descriptors that specify the target endpoint . The advance function finds the data descriptor for the PUT transfer and advises the target application that its transfer data has arrived. Again a GET type DMA transfer works in a similar manner with some differences including of course the fact that transfer data flows in the opposite direction. And typical SEND transfers also operate similarly some with rendezvous protocols some with eager protocols with data transmitted in packets over the a network through non DMA network adapters or through DMA controllers.

By use of an architecture like that illustrated and described with reference to a parallel application or an application messaging module that is already programmed to use DMA transfers can gain the benefit of the speed of DMA data transfers among endpoints on the same compute node with no need to reprogram the applications or the application messaging modules to use the network in other modes. In this way an application or an application messaging module already programmed for DMA can use the same DMA calls through a same API for DMA regardless whether subject endpoints are on the same compute node or on separate compute nodes.

For further explanation sets forth a functional block diagram of example endpoints useful in parallel computers that implement endpoint based parallel data processing in a PAMI according to embodiments of the present invention. In the example of a PAMI is implemented with instances on two separate compute nodes that include four endpoints . These endpoints are opaque objects used to address an origin or destination in a process and are constructed from a client task context tuple. Non DMA SEND and RECEIVE instructions as well as DMA instructions such as PUT and GET address a destination by use of an endpoint object or endpoint identifier.

Each endpoint in the example of is composed of a client a task and a context . Using a client a component in the specification of an endpoint disambiguates the task and context identifiers as these identifiers may be the same for multiple clients. A task is used as a component in the specification of an endpoint to construct an endpoint to address a process accessible through a context. A context in the specification of an endpoint identifies refers to or represents the specific context associated with a the destination or target task because the context identifies a specific threading point on a task. A context offset identifies which threading point is to process a particular communications operation. Endpoints enable crosstalk which is the act of issuing communication on a local context with a particular context offset that is directed to a destination endpoint with no correspondence to a source context or source context offset.

For efficient utilization of storage in an environment where multiple tasks of a client reside on the same physical compute node an application may choose to write an endpoint table on in a segment of shared memory . It is the responsibility of the application to allocate such segments of shared memory and coordinate the initialization and access of any data structures shared between processes. This includes any endpoint objects which are created by one process or instance of an application and read by another process.

Endpoints on compute node serve respectively two application instances . The tasks in endpoints are different. The task in endpoint is identified by the task ID of application and the task in endpoint is identified by the task ID of application . The clients in endpoints are different separate clients. Client in endpoint associates data communications resources e.g. on dedicated exclusively to the use of application while client in endpoint associates data communications resources dedicated exclusively to the use of application . Contexts in endpoints are different separate contexts. Context in endpoint operates on behalf of application a subset of the data communications resources of client and context in endpoint operates on behalf of application a subset of the data communications resources of client .

Contrasted with the PAMIs on compute node the PAMI on compute node serves only one instance of a parallel application with two endpoints . The tasks in endpoints are the same because they both represent a same instance of a same application both tasks therefore are identified either with a same variable value references to a same object or the like by the task ID of application . The clients in endpoints are optionally either different separate clients or the same client. If they are different each associates a separate collection of data communications resources. If they are the same then each client in the PAMI on compute node associates a same set of data communications resources and is identified with a same value object reference or the like. Contexts in endpoints are different separate contexts. Context in endpoint operates on behalf of application a subset of the data communications resources of client regardless whether clients are the same client or different clients and context in endpoint operates on behalf of application a subset of the data communications resources of client regardless whether clients are the same client or different clients. Thus the tasks are the same the clients can be the same and the endpoints are distinguished at least by different contexts each of which operates on behalf of one of the threads of application identified typically by a context offset or a threading point.

Endpoints being as they are on the same compute node can effect DMA data transfers between endpoints through DMA controller and a segment of shared local memory . In the absence of such shared memory endpoints can effect DMA data transfers through the DMA controller and the network even though both endpoints are on the same compute node . DMA transfers between endpoint on compute node and endpoint on another compute node go through DMA controllers and either a network or a segment of shared remote memory . DMA transfers between endpoint on compute node and endpoint on another compute node also go through DMA controllers and either a network or a segment of shared remote memory . The segment of shared remote memory is a component of a Non Uniform Memory Access NUMA architecture a segment in a memory module installed anywhere in the architecture of a parallel computer except on a local compute node. The segment of shared remote memory is remote in the sense that it is not installed on a local compute node. A local compute node is local to the endpoints located on that particular compute node. The segment of shared remote memory therefore is remote with respect to endpoints on compute node if it is in a memory module on compute node or anywhere else in the same parallel computer except on compute node .

Endpoints being as they are on the same compute node can effect DMA data transfers between endpoints through DMA controller and a segment of shared local memory . In the absence of such shared memory endpoints can effect DMA data transfers through the DMA controller and the network even though both endpoints are on the same compute node . DMA transfers between endpoint on compute node and endpoint on another compute node go through DMA controllers and either a network or a segment of shared remote memory . DMA transfers between endpoint on compute node and endpoint on another compute node go through DMA controllers and either a network or a segment of shared remote memory . Again the segment of shared remote memory is remote with respect to endpoints on compute node if it is in a memory module on compute node or anywhere else in the same parallel computer except on compute node .

For further explanation sets forth a flow chart illustrating an example method of endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention. sets forth a data flow diagram that illustrates data flows effected according to the method of . The method of is described below in this specification therefore with reference both to and also to using reference numbers from both .

The method of is implemented in a PAMI of a parallel computer composed of a number of compute nodes on that execute a parallel application like those described above in this specification with reference to . The PAMI includes data communications endpoints and e.g. on with each endpoint specifying data communications parameters for a thread e.g. on of execution on a compute node including specifications of a client e.g. on a context on and a task e.g. on all as described above in this specification with reference to . The endpoints are coupled for data communications through the PAMI and through data communications resources e.g. on . The endpoints can be located on the same compute node or on different compute nodes.

The method of includes establishing by an application level entity for collective operations of the PAMI a data communications geometry . The geometry specifies for tasks representing processes of execution of the parallel application a set of endpoints that are used in collective operations of the PAMI including a plurality of endpoints for one of the tasks. Of course these are PAMI tasks where each task represents a canonical process of execution of the parallel application and data communications in support of collective operations are from process to process traditionally with one endpoint per task although ultimately as will be seen the addition of additional endpoints for one of the tasks will represent a strong additional parallelism. Incidentally the phrasing of plurality of endpoint for one of the tasks is only for convenience of explanation. The phrase actually means plurality of endpoints for one or more of the tasks. The need for this easing of the difficulty of explanation is clear when one considers that in an IBM BlueGene Q supercomputer for example with a million tasks organized in a rectangular mesh with a thousand tasks on a side one way to perform a collective BROADCAST is for the root task to incorporate into its geometry a thousand new endpoints each of which is assigned responsibility for transmitting transfer data down one of the one thousand rows of the mesh. One can quickly see why this example at least is described in terms of thirty tasks and three rows instead of millions and thousands. The principles illustrated are the same.

As mentioned the geometry specifies for tasks representing processes of execution of the parallel application a set of endpoints that are used in collective operations of the PAMI including a plurality of endpoints for one of the tasks. Each endpoint specifies communications parameters for a combination of a task a client and a context a fact further explained with reference to Table 1.

Each row in Table 1 represents an endpoint of a PAMI with each of N endpoints identified by an endpoint identifier ep. . . ep. Similarly M tasks are identified as t. . . t. In this example N is greater than Ml there are more endpoints than tasks because the first three endpoints ep. . . ep are a plurality of endpoints for only one task task t. Possibly N can be quite a bit larger than M because there is no limitation of the pluralization of endpoints to only one task. Tasks other than talso can have more than one endpoint providing data communications on behalf of each such task. In this example the endpoint are composed with only two clients cland cl two collections of data communication resources dedicated to the use of the application. Each endpoint includes a separate context co. . . co the number of contexts N being the same as the number of endpoints in the geometry illustrated by Table 1 with each context co. . . cocomposed of a separate subset of one of the two collections of data processing resources of the clients cland cl.

An application level entity is an application an instance of a parallel application or an application messaging module sometimes referred to in this discussion simply as an application. To establish a geometry an application level entity either at PAMI initialization or later dynamically at run time can call a PAMI initialization function on configured to establish a geometry by reading the geometry on from a PAMI configuration on or by using such configuration information as a prototype of a geometry to be configured at run time. The application can include in the geometry the endpoints defined for it in the PAMI configuration on or the application can dynamically add additional endpoints to augment parallel operations in a manner that will in fact be transparent to the application at run time. Clearly if an application messaging module initializes the PAMI then the geometry of endpoints will always be transparent to the actual application but the application itself will not administer endpoints at run time even if it were the actual application itself that initialized the PAMI and the geometry.

In the method of establishing a data communications geometry includes associating with the geometry a list of collective algorithms valid for use with the endpoints of the geometry. The list is for use with the endpoints of the geometry in the sense that when an advance function finds a collective instruction in its work queue the advance function makes a determination which collective algorithm to apply by consulting the list . Constructing such a list of algorithms can be carried out at PAMI initialization by for example a call by an application level entity to a PAMI initialization function on that either reads the list from a PAMI configuration on or constructs the list from a prototype list on . The collective algorithms are presented here in a structure that uses a geometry identifier value as a foreign key to associate the algorithm list and the geometry . The algorithm list in the example of for ease of illustration includes only the collective algorithms for a BROADCAST and a SCATTER but readers will recognize that such lists in actual embodiments also can include algorithms for other additional types of collective operations also GATHERs REDUCEs ALLGATHERs ALLREDUCEs including many variations according to particular collective operations computer architectures availability of tree networks or mesh networks whether shared memory segments are available whether data buffers are disposed upon memory boundaries whether the number of endpoints in a geometry is even odd or a power of two and so on. Because collective operations involve data communications configuration of a list of collective algorithms for a geometry also depends upon the nature of underlying data communications available to carry out any particular collective operation. Available data communications types include but are not limited to the following examples 

The method of also includes receiving in one or more endpoints of the geometry an instruction for a collective operation. It is said that the collective instruction is received in one or more endpoints because of the active nature of messaging in support of collective operations in the PAMI. In an embodiment in a traditional way all instances of a parallel application call a collective operation at about the same time and endpoints of the geometry all receive a corresponding collective instruction at the same time some parameterized for a root other parameterized for non roots. In other embodiments all endpoints are configured with dispatch callback function for messaging in support of collective operations and only endpoints operating on behalf of a root task actually receive and execute a corresponding collective instruction possible because all the endpoints will carry out the proper data processing through callbacks upon receiving messaging from the root tasks through one or more endpoints serving the root tasks as in a BROADCAST or SCATTER for example. In other embodiments one or more endpoints serving a root tasks are configured with a dispatch callback function for messaging in support of collective operations and only endpoints operating on behalf of non root tasks actually receive and execute a corresponding collective instruction possible because the endpoints serving the root tasks will carry out the proper data processing through callbacks upon receiving messaging from the non root tasks through one or more endpoints serving the non root tasks as in a GATHER or REDUCE for example.

In this example the received instruction is characterized by an instruction type that specifies communications of transfer data among the endpoints of the geometry. Types of such a collective instruction include but are not limited to the following example instruction types 

In the example of an originating application typically an instance of a parallel application running on a compute node places a quantity of transfer data at a location in its RAM and includes the memory location and the quantity of transfer data in parameters of the instruction for a collective operation. The instruction then is received in an endpoint of a root tasks through operation of a post function called by the originating application on a context of the endpoint posting the instruction to a work queue of a context of the endpoint . The instruction parameters also typically specify one or more callback functions a dispatch callback a done callback or the like to support and implement data communications in support of the instruction . Any done callback is registered in the PAMI for later use upon completion of the overall execution of the collective instruction . Such a done callback function is an application level instruction called by an advance function of the PAMI when execution of the data communications instruction is fully complete. Such a done callback can carry out any actions desired by the application at that point but readers will recognize that a typical purpose of the done callback is to advise the calling application or a corresponding application messaging function of completion of the data transfer pursuant to the collective instruction. The application s post of the instruction is non blocking so that the application continues other work while the PAMI executes the collective instruction . Not blocking to wait for the data communications instruction to complete it is common for the application to want a callback to advise of completion of data transfers pursuant to the collective instruction.

The method of also includes executing the collective instruction through the endpoints in dependence upon the geometry . Executing a collective instruction involves data communications among the endpoints and in the example method of executing the collective instruction includes dividing such data communications operations among a plurality of endpoints for one of the tasks. In this example endpoints 0 1 and 2 are taken as three endpoints of a single root tasks for a collective operation such as a BROADCAST. In the method of dividing data communications operations includes assigning to each of the plurality of endpoints for one of the tasks a single root task in this example a separate subset of the endpoints in the geometry. Here endpoint 0 is assigned subset endpoint 1 is assigned subset and endpoint 2 is assigned subset .

Also in the method of dividing data communications operations includes transferring by each of the plurality of endpoints for one of the tasks the transfer data to each of the endpoints in the subset assigned to that endpoint. That is all endpoints in the geometry receive all of the transfer data including each of the plurality that carries out the actual transfer. Thus each of the endpoints in the plurality of endpoints of the root tasks receives a transfer of all the transfer data redundancy because these three endpoints 0 1 and 2 are all directed at a single task and therefore at a single receive buffer . The term geometry is chosen to represent a collection of endpoints and tasks because it implies a shape for data communications. In it is seen that among a collection of receive buffers there is a receive buffer for each task in the geometry. In the example of it is taken that each task has a single target receive buffer including the task served by endpoints 0 1 and 2. Because all the transfer data is sent to all endpoints of the geometry endpoints 0 1 and 2 each receive all the transfer data but two of these receptions are redundant and therefore discarded placing only one of the receptions of transfer data into the receive buffer served by endpoints 0 1 and 2.

Also in the example of the transfers of data are carried out by the three plural endpoints 0 1 and 2 in parallel operations. Thus instead of N transfers required to be carried out by a single advance function of a single context of a single endpoint of a root task now the transfers are divided by three among the three endpoints 0 1 and 2 a proceed in parallel on three separate sets of data communications resources of three separate contexts from three separate endpoints increasing throughput of the pertinent data communications by a factor of three. Readers will recognize that the benefit of such parallelism is not limited to the factor of three illustrated here but is limited only by the quantity of data communications resources available for assignment to contexts in the endpoints of the geometry. In addition there is no limitation of such a plurality of endpoints for a single task that achieve such parallelism to the data communications resources of a single compute node. On the contrary an application or application messaging module that implements such a geometry of endpoints and tasks that includes a plurality of endpoints for one of the tasks in the geometry can instantiate endpoints of the geometry on compute nodes other than the compute node upon which the task having the plurality of endpoints is installed. In this way availability of data communications across compute nodes is still a limiting factor but the limit is not defined by the data communications resources on any single compute node. There is a present trend among supercomputer installations for torus or mesh networks to be implemented in five dimension so that it is expected that each compute node could support five endpoints transmitting and five endpoints receiving data at the same time. An application or application messaging module operating on such a supercomputer however can instantiate endpoints that are physically located on neighboring compute nodes however so that any particular data transfer can gain the parallelism of five or ten or fifteen or more endpoints physically located across several or even many compute nodes.

For further explanation sets forth a flow chart illustrating a further example method of endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention. sets forth a data flow diagram that illustrates data flows effected according to the method of . The method of is described below in this specification therefore with reference both to and also to using reference numbers from both . The method of like the method of is implemented in a PAMI of a parallel computer composed of a number of compute nodes on that execute a parallel application like those described above in this specification with reference to . The PAMI includes data communications endpoints and e.g. on with each endpoint specifying data communications parameters for a thread e.g. on of execution on a compute node including specifications of a client e.g. on a context on and a task e.g. on all as described above in this specification with reference to . The endpoints are coupled for data communications through the PAMI and through data communications resources e.g. on . The endpoints can be located on the same compute node or on different compute nodes.

The method of is also like the method of including as it does establishing by an application level entity for collective operations of the PAMI a data communications geometry receiving in one or more endpoints of the geometry an instruction for a collective operation and executing the collective instruction through the endpoints in dependence upon the geometry including dividing data communications operations among a plurality of endpoints for one of the tasks. In the method of however unlike the method of dividing data communications operations among a plurality of endpoints for one of the tasks includes assigning portions of the transfer data to each of the plurality of endpoints for one of the tasks. That is the send buffer is segmented into individual portions and the number of portions is equal to the number M of tasks of endpoints of the geometry with each portion 0 . . . M 1 of the transfer data corresponding to one of 0 M 1 tasks of the geometry and therefore to one of the 0 . . . M 1 receive buffers. Because at least one of the tasks has a plurality of endpoints there are more endpoints than tasks in the geometry so that N the number of endpoints in the geometry is greater than M.

These portions of the transfer data are then assigned to the plurality of endpoints for one of the tasks for transfer to the endpoints of the geometry. In this example there are P such endpoints 0 . . . P 1 representing the plurality of endpoints for one task and the portions of the transfer data are assigned to the plurality in P segments 0 . . . P 1. So each of the P endpoints 0 . . . P 1 in the plurality of endpoints for one task the root task in the collective operation is assigned for transfer a corresponding subset 0 . . . P 1 respectively of the transfer data in the send buffer .

Also in the method of dividing data communications operations includes transferring in parallel operations by the plurality of endpoints for one of the tasks to one endpoint for each task of the geometry a corresponding portion of the transfer data. Because the transfers are to one endpoint for each task of the geometry only one of the plurality of endpoints for the root tasks in this example endpoint 0 receives a transmission of a segment of the transfer data. The plurality of endpoints effecting the transfer have access to the geometry for example information like that in Table 1. In such a geometry at least one but possibly many of the tasks have more than one endpoint. Each of the plurality of endpoints effecting the transfer observes the geometry and for each task with more than one endpoint selects one of those endpoints to receive the segment of the transfer data corresponding to the task.

In this example endpoint 0 selects itself to receive the transfer of segment 0 of the send buffer although it could have selected any one of the P endpoints in the plurality of endpoints of task tto receive segment 0 of the transfer data. In this example all the remaining P 1 endpoints of the root task receive no transmission of transfer data therefore having no redundant transmissions and no need to discard any redundant packets. In this way segment 0 of the transfer data is transferred to receive buffer 0 of task tin the geometry segment 1 of the transfer data is transferred to receive buffer 1 of task tin the geometry segment 2 of the transfer data is transferred to receive buffer 2 of task tin the geometry and so on until segment M 3 of the transfer data is transferred to receive buffer M 3 of task Tin the geometry segment M 2 of the transfer data is transferred to receive buffer M 2 of task Tin the geometry and segment M 1 of the transfer data is transferred to receive buffer M 1 of task Tin the geometry.

Also in the example of the transfers of data are carried out by the P plural endpoints 0 . . . P 1 in parallel operations. Thus instead of M transfers required to be carried out by a single advance function of a single context of a single endpoint of a root task now the transfers are divided by P among the P endpoints in the plurality of endpoints of the root task and proceed in parallel on P separate sets of data communications resources of P separate contexts from P separate endpoints increasing the overall throughput rate of the pertinent data communications by a factor of P. In a geometry with a million tasks arranged in a square mesh with one thousand tasks in each of a thousand rows an application or application messaging module can instantiate P one thousand endpoints for the root task each with separate data communications resources running in parallel and transfer in a collective SCATTER operation for example a million segments of its send buffer in one thousand parallel transmissions across one thousand endpoints of the root task. The benefit of such parallelism is limited only by the quantity of data communications resources available for assignment to contexts in the endpoints of the geometry and there is no limitation of such a plurality of endpoints for a single task to the data communications resources of a single compute node.

For further explanation sets forth a flow chart illustrating a further example method of endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention. sets forth a data flow diagram that illustrates data flows effected according to the method of . The method of is described below in this specification therefore with reference both to and also to using reference numbers from both . The method of like the method of is implemented in a PAMI of a parallel computer composed of a number of compute nodes on that execute a parallel application like those described above in this specification with reference to . The PAMI includes data communications endpoints and e.g. on with each endpoint specifying data communications parameters for a thread e.g. on of execution on a compute node including specifications of a client e.g. on a context on and a task e.g. on all as described above in this specification with reference to . The endpoints are coupled for data communications through the PAMI and through data communications resources e.g. on . The endpoints can be located on the same compute node or on different compute nodes.

The method of is also like the method of including as it does establishing by an application level entity for collective operations of the PAMI a data communications geometry receiving in one or more endpoints of the geometry an instruction for a collective operation and executing the collective instruction through the endpoints in dependence upon the geometry including dividing data communications operations among a plurality of endpoints for one of the tasks. In the method of however unlike the method of dividing data communications operations among a plurality of endpoints for one of the tasks includes assigning to each of the plurality of endpoints for one of the tasks a single root task in this example a separate subset of the tasks in the geometry. Here endpoint 0 is assigned subset endpoint 1 is assigned subset and endpoint 2 is assigned subset . In the method of it is the endpoints of the geometry that are divided among the plurality not as here the tasks.

Also in the method of dividing data communications operations among a plurality of endpoints for one of the tasks also includes transferring by one endpoint of each task in the geometry a different portion of the transfer data to one of the plurality of endpoints for one of the tasks. In this example there are M send buffers for M tasks t. . . t. The tasks as such are not shown in but there is one send buffer per task of the geometry . The geometry include a plurality of endpoints 0 1 2 for one task t the root task so that there are more endpoints in the geometry than there are tasks. The transfer data is the separate data segments in each of the send buffer so that only one endpoint per send buffer that is only one endpoint per tasks need to effect a data transfer to one of the plurality of endpoints of the root task. Because endpoints 0 1 2 are endpoints of the same task t each of them can serve send buffer 0 although only one needs to do so for this data transfer. In this example advance functions in contexts of each endpoint check the geometry upon receiving the collective instruction in their work queues and if they find more than one endpoint for their task agree that the lowest ranking endpoint is to transfer the data while the other endpoints of the task do nothing further. In this example advance functions of endpoints 0 1 and 2 note from the geometry that each of them is an endpoint of the same task tand agree that only endpoint 0 will effect the transfer of data from their send buffer 0 .

The advance functions also note from the geometry the number of endpoints in the plurality of endpoints of the root task and infer from that which of the plurality is to receive their transfer data. Each task is identified by a sequential integer 0 . . . M 1 and in this example each advance function notes that there are three tasks 0 1 2 in the plurality divides the M number of send buffers or tasks into three subranges observes in which of the three subranges falls its task ID and sends the contents of its send buffer to the corresponding one of the plurality of endpoints of the root task. Endpoint 0 for task tfinds that its task ID falls in the first third of the range 0 . . . M 1 and therefore sends the contents of its send buffer to endpoint 0 which in this example happens to be itself. Endpoint M 3 1 finds that its task ID falls in the second third of the range 0 . . . M 1 and therefore sends the contents of its send buffer to endpoint 1. And so on.

Also in the method of dividing data communications operations among the plurality of endpoints for one of the tasks here the root task includes gathering in parallel operations by the plurality of endpoints for one task the root task all of the transfer data into a single receive buffer . The receive buffer is divided into segments corresponding to portions of the transfer data transferred from endpoints in the geometry. Here with each of the three endpoints 0 1 2 in the plurality of endpoints of the root task assigned a separate subset of the tasks in the geometry respectively the M tasks and M send buffers are effectively divided into three subranges 0 . . . M 3 M 3 1 . . . 2 M 3 and 2 M 3 1 . . . M 1. Endpoint 0 receives the data transfers from send buffers of tasks in the first third and places each in a corresponding segment of the first third of the receive buffer according to task ID the transfer data for task tfrom send buffer 0 is placed in segment 0 of the receive buffer the transfer data for task tfrom send buffer 1 is placed in segment 1 of the receive buffer and so on. Similarly endpoint 1 receives the data transfers from send buffers of tasks in the second third of the tasks and send buffers and places each in a corresponding segment of the second third of the receive buffer according to task ID. And endpoint 2 receives the data transfers from send buffers of tasks in the third third of the tasks and send buffers and places each in a corresponding segment of the third third of the receive buffer according to task ID ending with segments M 3 M 2 and M 1 corresponding to the contents of send buffers for tasks t t and t.

The method of effects a data flow in a direction opposite to that of the methods of but the benefits of additional parallelism are the same. In the methods of the data flow is from a send buffer of a root task through endpoints of the root task to endpoints of all tasks in the geometry. In the method of the data flow is endpoints of all tasks in the geometry through endpoints of a root task into a receive buffer of the root task.

In the example of the gathering of the data is carried out by the three plural endpoints 0 1 2 in parallel operations. Thus instead of M transfers required to be gathered into the receive buffer by a single advance function of a single context of a single endpoint of the root task now the transfers are divided received and gathered among the three endpoints of the root task and proceed in parallel on three separate sets of data communications resources of three separate contexts across three separate endpoints increasing the overall throughput rate of the pertinent data communications by a factor of three. Of course three is an example not a limitation of the invention embodiments of which can use any number of endpoints in a plurality for a task. In a geometry with a million tasks arranged in a square mesh with one thousand tasks in each of a thousand rows an application or application messaging module can instantiate one thousand endpoints for the root task each with separate data communications resources running in parallel assign to each a row containing a thousand tasks with a thousand send buffers and gather into a receive buffer of a root task in a collective GATHER operation for example the contents of a million send buffers through one thousand parallel receptions across one thousand endpoints of the root task a thousand fold gain in throughput compared with gathering the transfer data through a single link of the root task. Again readers should note that the benefit of such parallelism is limited only by the quantity of data communications resources available for assignment to contexts in the endpoints of the geometry and there is no limitation of such a plurality of endpoints for a single task to the data communications resources of a single compute node.

Retransmitting such gathered data to endpoints of all tasks can implement a PAMI level collective ALLGATHER operation. Adding a mathematical or logical operation on the gathered data can implement a PAMI level collective REDUCE operation. Retransmitting the contents of the receive buffer to endpoints of all tasks after such a REDUCE operation can implement a PAMI level collective ALLREDUCE operation. And so on. All these collective operations can gain significant speed from the massive parallelism that is possible with endpoint based parallel data processing in a PAMI of a parallel computer according to embodiments of the present invention. Moreover all these advantages which do come at some cost in terms of complexity are effected in a manner that can be entirely invisible to a calling application which has simply issued a collective instruction to an application messaging module such as an MPI. As far as the application is concerned it will effect a single BROADCAST to all ranks of an MPI communicator and all the additional parallelism of embodiments of the present invention will be brought to bear on behalf of the application with no awareness of it on the part of the application. The application will only know that its BROADCAST went much faster that it would go on prior art messaging middleware without the benefits of endpoint based parallel data processing in a PAMI according to embodiments of the present invention.

Example embodiments of the present invention are described largely in the context of a fully functional parallel computer that implements endpoint based parallel data processing in a PAMI. Readers of skill in the art will recognize however that the present invention also may be embodied in a computer program product disposed upon computer readable storage media for use with any suitable data processing system. Such computer readable storage media may be any storage medium for machine readable information including magnetic media optical media or other suitable media. Examples of such media include magnetic disks in hard drives or diskettes compact disks for optical drives magnetic tape and others as will occur to those of skill in the art. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a computer program product. Persons skilled in the art will recognize also that although some of the example embodiments described in this specification are oriented to software installed and executing on computer hardware nevertheless alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention.

As will be appreciated by those of skill in the art aspects of the present invention may be embodied as method apparatus or system or computer program product. Accordingly aspects of the present invention may take the form of an entirely hardware embodiment or an embodiment combining software and hardware aspects firmware resident software micro code microcontroller embedded code and the like that may all generally be referred to herein as a circuit module system or apparatus. Furthermore aspects of the present invention may take the form of a computer program product embodied in one or more computer readable media having computer readable program code embodied thereon.

Any combination of one or more computer readable media may be utilized. Such a computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device.

A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein for example in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms including but not limited to electro magnetic optical or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate propagate or transport a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present invention are described in this specification with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowcharts and block diagrams in the Figures illustrate the architecture functionality and operation of possible implementations of computer apparatus methods and computer program products according to various embodiments of the present invention. In this regard each block in a flowchart or block diagram may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustrations and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.

