---

title: Converting dependency relationship information representing task border edges to generate a parallel program
abstract: According to an embodiment, based on task border information, and first-type dependency relationship information containing N number of nodes corresponding to data accesses to one set of data, containing edges representing dependency relationship between the nodes, and having at least one node with an access reliability flag indicating reliability/unreliability of corresponding data access; task border edges, of edges extending over task borders, are identified that have an unreliable access node linked to at least one end, and presentation information containing unreliable access nodes is generated. According to dependency existence information input corresponding to the set of data, conversion information indicating absence of data access to the unreliable access nodes is output. According to the conversion information, the first-type dependency relationship information is converted into second-type dependency relationship information containing M number of nodes (0≦M≦N) corresponding to data accesses to the set of data and containing edges representing inter-node dependency relationship.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09043803&OS=09043803&RS=09043803
owner: Kabushiki Kaisha Toshiba
number: 09043803
owner_city: Tokyo
owner_country: JP
publication_date: 20120110
---
This application is based upon and claims the benefit of priority from Japanese Patent Application No. 2011 004159 filed on Jan. 12 2011 the entire contents of which are incorporated herein by reference.

Embodiments described herein relate generally to an information processing apparatus and a computer program product.

A technology is known in which a computer program written for a sequential computing device is parallelized in such a way that it can be processed in parallel by a plurality of cores or processors. While performing parallelization of such a computer program it is common to parallelize the loops accounting for the majority of the computation time in the computer program. While parallelizing a program containing loops if it is not clear whether there is dependency between iterations of a loop a technology is already known that enables performing parallelization when the developer determines that there exists no dependency between the iterations of the loop.

However in the conventional technology parallelization of a computer program having data dependency between iterations of a loop is a difficult task. On the other hand it can also be an option to perform parallelization while ignoring the dependency between iterations. However in that case the developer has to insert synchronizations manually by taking into account the dependency relations of all of the data. That puts a lot of burden on the developer. Besides the method in which the developer determines whether or not to perform parallelization is not practical unless the instructions for parallelization issued by the developer are confined to a loop by loop basis. In that regard there has been a demand for a method or an apparatus that would generate a sophisticated parallel program at a low cost.

According to an embodiment an information processing apparatus includes an input unit a generating unit an instructing unit and a converting unit. The input unit is configured to receive task border information about task borders of a plurality of tasks and receive first type dependency relationship information that contains N number of nodes N is an integer equal to or greater than 1 corresponding to data accesses to a single set of data and that contains edges representing a first type dependency relationship expressing restrictions on an order of data accesses between the nodes. At least one of the nodes has an access reliability flag that indicates whether corresponding data access is reliable or unreliable. The generating unit is configured to based on the first type dependency relationship information identify task border edges out of edges extending over the task borders which have an unreliable access node with unreliable data access linked to at least one end thereof and configured to generate presentation information containing at least one of the unreliable access nodes that are linked to the task border edges. The instructing unit is configured to receive dependency existence information which indicates existence of a dependency relationship among the data accesses corresponding to the single set of data and configured to according to the dependency existence information output to the unreliable access node conversion information that contains information indicating absence of data access to the unreliable access node. The converting unit is configured to according to the conversion information convert the first type dependency relationship information into second type dependency relationship information that contains M number of nodes 0 M N corresponding to the data accesses to the single set of data and contains edges representing a second dependency relationship between the nodes.

Subsequently based on the task border information and based on the first type dependency relationship information analyzed by the analyzing unit the generating unit generates presentation information for the purpose of presentation S . The instructing unit determines whether dependency existence information has been input S and when the dependency existence information is determined to have been input the system control moves to S. The instructing unit refers to the dependency existence information and generates or updates conversion information S and the system control returns to S. The generating unit reflects in the presentation information the conversion information that has been updated based on the dependency existence information .

On the other hand when it is determined that the input of the dependency existence information has completed and that there is no input of the dependency existence information at Step S the system control moves to S. The converting unit refers to the conversion information that is generated or updated by the instructing unit and converts the first type dependency relationship information that is analyzed by the analyzing unit into second type dependency relationship information S . Subsequently the parallelizing unit refers to the second type dependency relationship information that is obtained by conversion by the converting unit and generates a parallel program having synchronizations inserted therein S .

In the following description the explanation of each functional block of the parallelization apparatus is given for the most basic configuration in which the functional blocks are tandemly connected in the sequence illustrated in . However the first embodiment is not limited to that case. Alternatively for example the first embodiment can be implemented for a configuration in which a plurality of functional blocks operate in a coordinated manner or can be implemented for a configuration in which the sequence of some functional blocks is interchanged or can be implemented for a configuration in which a particular functional block is divided into a plurality of functional blocks or can be implemented for a configuration having a combination of the abovementioned three configurations. Besides the first embodiment can also be implemented by dividing the functional blocks into a plurality of units.

Explained below in detail are the operations performed by various constituent elements of the parallelization apparatus . The input unit receives the program code and the task border information into the parallelization apparatus . illustrates an example of the program code and illustrates an example of the task border information .

The program code illustrated in is written in a pseudo language imitating C language which is a commonly used programming language. In the program code a digit and a colon written at the start of each line represent a line number that is assigned to enable identification of that line during the explanation. In the example illustrated in the program code has data access expressions a b c s t u v p q p and q has the assignment operator and has the addition operator . The data access expressions are broadly divided into direct access expressions and indirect access expressions. In the following example each indirect access expression has an asterisk attached thereto. Thus the indirect access expressions can be distinguished from the direct access expressions.

Herein the direct access expressions represent those data access expressions which do not make use of dynamic data for determining the position of data to be accessed. For example with the direct access expression a data a is accessed without the use of dynamic data. In contrast the indirect access expressions represent those data access expressions which make use of dynamic data for determining the position of data to be accessed. For example with the indirect access expression p written in the fifth line such data is accessed that is present at the position indicated by dynamic data p . Herein the data present at the position indicated by dynamic data p means for example that the memory address of that particular data is held by the dynamic data p .

With a direct access expression the data to be accessed is certainly identifiable. In contrast with an indirect access expression there are times when the data to be accessed is not identifiable. Hence the data accessed with the indirect access expression p is sometimes abstractly expressed as data p .

The task border information illustrated in indicates that labels label  and label  which are respectively written in the sixth and tenth lines in the program code illustrated in represent task borders. schematically illustrates an example when the program code illustrated in is divided into tasks using the task border information illustrated in . In this example according to the task border information the operations of the program code are divided into a task a task and a task . Meanwhile a task represents a unit of operations executed by a central processing unit CPU and includes one or more operations. Moreover a task border represents information that indicates a border for dividing an operation such as data accesses expressed by the program code into tasks.

In the program code illustrated in the operations are performed in the order of the task the task and the task . For convenience of diagrammatic illustration and explanation the following explanation is given under the assumption that a task border is present at the border between any two different tasks. In the example illustrated in a task border is present as the border between the task and the task a task border is present as the border between the task and the task and a task border is present as the border between the task and the task . Meanwhile in the task border information in the information corresponding to the task border is not included. Thus it is not necessary to include information corresponding to all task borders in the task border information and it is also possible that a task border is present in an implicit manner.

Herein the task border information is input for example by the user the developer from a user interface UI . However alternatively based on an analysis result obtained by analyzing the program code the task border information can be generated automatically for the input purpose.

The analyzing unit analyzes the program code and outputs dependency relationship information. illustrates an example of the dependency relationship information obtained by analyzing the program code illustrated in . Herein as described above the dependency relationship information output by the analyzing unit is referred to as the first type dependency relationship information .

With respect to each set of data written in the program code the analyzing unit considers as nodes the data access expressions which are likely to access that set of data and generates a dependency graph that expresses with edges between the nodes the order that needs to be followed in order to obtain a correct execution result. Herein as long as it is not analyzed that any particular data will not be accessed it is analyzed that the particular data is likely to be accessed.

A node represents information corresponding to the data accesses to a single set of data and having an access reliability flag that indicates whether the particular data access is reliable or unreliable. For a single set of data N number of nodes where N is an integer equal to or greater than 1 is present. An edge represents information expressing restrictions on the order of data access that needs to be followed in order to obtain a correct execution result.

In the data a data b and data c in the program code are respectively illustrated by a dependency graph a dependency graph and a dependency graph . For convenience of explanation it is assumed that the dependency relationships between the other data do not become dependency relationships between tasks. In and in similar diagrams referred to hereinafter if a node has the alphabet W written therein that node indicates a write access and a node has the alphabet R written therein that node indicates a read access.

In as edges are illustrated a true dependence representing reading after writing an anti dependence representing writing after reading and an output dependence representing writing after writing. For example a 0 written in the first line and a 2 written in the fourth line indicate that values 0 and 2 are respectively substituted in the data a . In the dependency graph the output dependence representing writing after writing is illustrated as an edge that links the node corresponding to a 0 with the node corresponding to a 2 .

The analyzing unit analyzes the data accessed by each node of a dependency graph and accordingly sets the access reliability flag to each node. The access reliability flag is set to have either a value indicating reliable or a value indicating unreliable . A node that is assigned with the value indicating reliable in the access reliability flag is referred to as a reliable access node and a node that is assigned with the value indicating unreliable in the access reliability flag is referred to as an unreliable access node. In and in similar diagrams referred to hereinafter the reliable access nodes are illustrated with a filled circle and the unreliable access nodes are illustrated with a open circle . Moreover in the following explanation when a value indicating reliable or unreliable is set in an access reliability flag it is described as setting of a value of an access reliability flag to reliable or unreliable .

When it can be regarded that with respect to the at least one external input value of the program code being analyzed a node accesses the data corresponding to the external input value and the analyzing unit sets the node to have reliable as the value of the access reliability flag while on the other hand when it cannot be regarded that a node accesses the data the analyzing unit sets the node to have unreliable as the value of the access reliability flag. Herein an external input points to data for which the values are input from the outside of the program code and an external input value points to the value of the data that is input by means of the external input. In the example of the program code illustrated in the data p and data q written in the fifth and eighth line respectively are input by means of the external input.

In a direct access expression since the data to be accessed is identifiable irrespective of the external input values the access reliability flag is set to the value reliable . In contrast in an indirect access expression the value of the access reliability flag is set according to the analysis result of the dynamic data that is used in deciding the access destination. In the example illustrated in regarding the access reliability flag of the nodes corresponding to indirect access expressions it cannot be determined whether the dynamic data p and the data q which are used in deciding the access destinations take arbitrary values or take limited values. Hence in each of the data a the data b and the data c the node corresponding to the data access expression p as well as the node corresponding to a data access expression q is generated as an unreliable access node.

Meanwhile in a case when the dynamic data used in deciding the access destination of an indirect access expression could be analyzed it is possible either to generate the node corresponding to that indirect access expression as a reliable access node or not to generate that node. Since a dependency graph is constructed for each set of data there is a possibility that with respect to a single indirect access expression the type or the existence criterion is different for the node corresponding to each set of data.

In response to an instruction issued by the user in an interactive manner using the generating unit and the instructing unit the parallelization apparatus generates the conversion information which is put to use by the converting unit . Herein the user points either to a person using the parallelization apparatus or to another apparatus. For example the user can be the developer of the parallel program or can be a dependency existence determining apparatus that automatically determines existence of dependency in the data accesses of data.

The generating unit generates the presentation information by referring to the first type dependency relationship information generated by the analyzing unit and by referring to the task border information input from the input unit . illustrate examples in which the first type dependency relationship information and the task border information is combined regarding the data a the data b and the data c respectively. Thus in the task border information is added while expressing the dependency graphs and that are illustrated in corresponding to the data a the data b and the data c respectively.

In the example illustrated in regarding the dependency graph related to the data a nodes and respectively represent the data access expression a of a 0 written in the first line in the program code the data access expression a of a 2 written in the fourth line in the program code the data access expression p of s p written in the fifth line in the program code the data access expression q of q 4 written in the eighth line in the program code the data access expression a of t a written in the 11 th line in the program code and the data access expression a of v a c written in the 13 th line in the program code .

In an identical manner in the example illustrated in regarding the dependency graph related to the data b nodes and respectively represent the data access expression b of b 1 written in the second line in the program code the data access expression p of s p written in the fifth line in the program code the data access expression q of q 4 written in the eighth line in the program code and the data access expression b of u b written in the 12 th line in the program code .

Moreover in the example illustrated in regarding the dependency graph related to the data c nodes and respectively represent the data access expression p of s p written in the fifth line in the program code the data access expression c of c 3 written in the seventh line in the program code the data access expression q of q 4 written in the eighth line in the program code the data access expression c of c 5 written in the ninth line in the program code and the data access expression c of v a c written in the 13 th line in the program code .

The generating unit does not convert all of the first type dependency relationship information into the presentation information but limits the first type dependency relationship information that is to be converted into the presentation information . That enables the user to easily or speedily conclude the task of issuing instructions for generating the conversion information .

Explained below is a method for limiting the first type dependency relationship information that is to be converted into the presentation information . Hereinafter an edge extending over a task border is referred to as a task border edge a node linked to a task border edge is referred to as a task border node and an edge having at least one unreliable access node linked thereto is referred to as an unreliable edge. Besides an edge that is not only a task border edge but also an unreliable edge is referred to as an unreliable task border edge.

In order to enable the user to easily or speedily conclude the task of issuing instructions the generating unit generates such presentation information that is related to at least one unreliable access node linked to at least one unreliable task border edge. Thus if the user goes on sequentially issuing instructions regarding at least one unreliable access node linked to at least one unreliable task border edge it becomes possible to eliminate the unreliable task border edges with the least number of user instructions.

On the other hand as far as an unreliable access node not linked to an unreliable task border edge is concerned a corresponding instruction may go to waste depending on the result of an instruction issued regarding a node lying closer to the task border than that particular unreliable access node.

Explained below is an example in which the generating unit generates presentation information related to the dependency graph . In the dependency graph illustrated in the nodes and are present as unreliable access nodes. Besides as a task border edge that extends over a task border and that is linked to at least one of the nodes and there exist three unreliable task border edges namely a single unreliable task border edge that intersects the task border and two unreliable task border edges that intersect the task border .

Meanwhile the presentation information is for example display information generated from a rendering application programming interface API of an operating system OS while the parallelization apparatus is running as a computer program. For example the presentation information is transmitted to the user in the form of image information that is displayed on a display. Alternatively the presentation information can also be transmitted in the form of data in a file or in a memory.

As described above it is only necessary to generate the presentation information related to at least one unreliable access node that is linked to an unreliable task border edge. Hence as illustrated in the example in the node and the node that are positioned on either side of the unreliable task border edge are not presented. Rather for example the presentation information can be generated related only to the node while excluding the node

Even regarding the nodes that are not directly linked to an unreliable task border edge the generating unit can be configured to recognize the nodes that may get involved with task border edges and the nodes that will not get involved with task border edges and to accordingly provide different methods of generating the presentation information.

For example the node illustrated in or the node illustrated in is not linked to any task border edge and does not get involved in any task border edge. For that reason the method of presentation can be so changed that the node or the node is excluded from the presentation information or the node or the node is displayed in a different display color than the display color of the other nodes. In this way if the method of presentation for the nodes not involved with a task border edge is set to be different than the method of presentation for the nodes that are likely to get involved with a task boarder edge it becomes possible to generate such presentation information that is helpful to the user in issuing instructions.

Explained below is an exemplary method that enables the generating unit to detect nodes that do not get linked to task boundary edges. The generating unit identifies all reliable write nodes which point to the reliable access nodes performing the write operation. In the example illustrated in the nodes and are reliable write nodes.

When there exists at least a single node identified as a reliable write node in at least a single path from a node N which is included in a task T into another task T it is determined that the node N would not get linked to the task border edge between the task Tand the task T.

For example in the example illustrated in in a path that reaches the task from the node via the nodes and there exists the node identified as a reliable write node. Hence the node is not linked to the task border edge of the task border . In an identical manner it can be determined that the node is not linked to any of the task borders included in the dependency graph illustrated in . Similarly it can also be determined that the node illustrated in is not linked to any of the task borders included in the dependency graph

Herein a path can be followed only via the edges having the same orientation. In the example illustrated in while reaching the node from the node via the nodes and the node can be reached via only those edges which have the same orientation. Hence that case confirms with the abovementioned explanation of a path. In contrast while reaching the node from the node via the node illustrated in the node needs to be reached from the node and the node needs to be reached from the node via the node . In this case the edge heading from the node toward the node and the edge heading from the node toward the node via the node have different orientations. Hence that case does not confirm with the above mentioned explanation of a path.

Regarding a method for the generating unit to detect a node that does not get linked to a task border edge as described above the following method can be considered if the attention is paid to two threads and a task border therebetween. That is in this method firstly with respect to one task direction adjacent to a task border edge a reliable write node having the least task border distance is identified. It is determined whether or not at least a single reliable write node that has been identified is present on at least one of the paths leading to task border edges from each node included in the first type dependency relationship information dependency graph . If no reliable write node that has been identified is determined to be present it is determined that there is a possibility of a link between the identified node and a task border edge. On the other hand if a reliable write node that has been identified is determined to be present it is determined that the identified node does not get linked to a task border edge.

Herein the task border distance which is the distance from a single node or from a single edge up to a single task border is defined as the least number of nodes that are passed while reaching the task border from the single node or from the single edge. With respect to a single node the task border distance is defined to be equal to the number of task borders. For example in the example illustrated in from the node up to the task border the task border distance is 0 while from the node up to the task border the task border distance is 2 .

The instructing unit receives the dependency existence information and generates the conversion information . Herein the dependency existence information represents the information regarding the existence of nodes or edges that are elements of dependency graphs. The conversion information represents the information illustrating a method for the converting unit to convert the first type dependency relationship information into the second type dependency relationship information .

From the dependency existence information the instructing unit generates the conversion information so as to enable reversal of values of the access reliability flags of the nodes that are included in the dependency existence information . illustrates an example of the conversion information generated from the dependency existence information illustrated in . In the example illustrated in from the dependency existence information illustrated in change flag node A is generated as the conversion information that enables reversal of value of the access reliability flag of the node A the node . For example depending on the information related to the task border nodes of the unreliable task border edge extending over the task border the user operates the UI of the instructing unit and selects a node for which the value of the access reliability flag is to be reversed.

In the examples illustrated in the dependency existence information and the conversion information is illustrated to be having different formats. However alternatively it is also possible to have the same format for the dependency existence information and the conversion information .

Until the generating unit and the instructing unit finish inputting the dependency existence information to the instructing unit the user keeps on communicating with the parallelization apparatus . Thus the conversion information generated by the instructing unit is input to the generating unit . By reflecting that conversion information in the presentation information the generating unit updates the presentation information . illustrates an example of new presentation information that is updated by reflecting the conversion information illustrated in in the presentation information illustrated in . In this example it is illustrated that the conversion information illustrated in reverses the value of the access reliability flag of the node A the node . Thus in the new presentation information illustrated in the node A the node is updated to a reliable access node from an unreliable access node.

Moreover as illustrated in assume that no access node B is input to the instructing unit as the dependency existence information indicating that the node B the node does not access the data a . According to the dependency existence information that has been input the instructing unit adds a command for deleting the node B the node in the conversion information illustrated in and updates the conversion information . The updated conversion information is input to the generating unit which reflects that conversion information in the presentation information and updates the presentation information .

With the update of the presentation information as illustrated in the unreliable task border nodes related to the data a are eliminated. Hence the focus is moved to performing the operation of generating the conversion information and the presentation information for the subsequent set of data for example the data b . Depending on the presentation information the user sequentially inputs the dependency existence information . Once inputting of the dependency existence information for the dependency graphs of all sets of data in the example illustrated in for the data a the data b and the data c and updating of the conversion information is complete it is determined that the dependency existence information has been completely input. That marks the end of the communication with the user.

With the use of the conversion information generated by the instructing unit the converting unit converts the first type dependency relationship information into the second type dependency relationship information . That is according to the conversion information the converting unit converts the first type dependency relationship information into the second type dependency relationship information that contains M number of nodes 0 M N corresponding to the data accesses to a single set of data and that contains edges indicating a second dependency relationship between those nodes.

In the conversion information the nodes indicated with a change flag instruction are subjected to a reversal in the values of the respective access reliability flags. For example if an access reliability flag has the value unreliable that value is changed to the value reliable due to the change flag instruction. Moreover the nodes indicated with a delete instruction are deleted. In the example illustrated in regarding the data a in the conversion information it is illustrated that the access reliability flag of the node A the node is reversed and the node B the node is deleted. Regarding the data b it is illustrated that the access reliability flag of a node C the node is reversed and a node D the node is deleted. Regarding the data c it is illustrated that a node E the node is deleted.

With reference to regarding the data a the access reliability flag of the node illustrated in is reversed to have the value reliable a node according to change flag node A written in the conversion information illustrated in . Moreover the node illustrated in is deleted see the task in according to delete node B . Along with the reversal of the value of the access reliability flag of the node and the deletion of the node edge information related to the node and the node is also changed. Where a node corresponds to the node illustrated in .

With reference to regarding the data b the access reliability flag of the node illustrated in is reversed to have the value reliable node according to change flag node C written in the conversion information illustrated in . Moreover the node illustrated in is deleted see the task in according to delete node D . Along with the reversal of the value of the access reliability flag of the node and the deletion of the node edge information related to the node and the node is also changed.

With reference to regarding the data c the node illustrated in is deleted see the task in according to delete node E written in the conversion information illustrated in and edge information related to the node is also changed. Where a node corresponds to the node illustrated in and a node corresponds to the node illustrated in .

In this way the parallelizing unit makes use of the second type dependency relationship information that obtained by conversion by the converting unit based on the conversion information and determines the positions of synchronizations and generates the parallel program having synchronizations inserted therein.

The parallelizing unit extracts the task border edges included in the second type dependency relationship information and analyzes execution order restrictions that need to be followed at the time of execution. illustrates an example in which the task border edges illustrated in and are associated with the program code illustrated in .

Herein task border edges and are the edges between the task and the task . The task border edge links a node and a node from the node toward the node the task border edge links the node and a node from the node toward the node and the task border edge links a node and a node from the node toward the node . Besides a task border edge is the edge between the task and the task and links a node and a node from the node toward the node

The execution order restrictions are applied according to the orientations of the task border edges. Since no task border edge is present in between the task and the task no execution order restrictions are applied. In contrast between the task and the task are present the execution order restrictions of the task border edges and . Similarly between the task and the task is present the execution order restriction of the task border edge . In order to obtain a correct calculation result such order restrictions need to be followed.

Meanwhile the parallelizing unit can also be configured to perform optimization of the synchronizations that are output. For example a method of inserting the requisite minimum synchronizations is known. The execution order restrictions have an inclusion relation between them. Thus there are times when a particular execution order restriction is satisfied the other execution order restrictions are also satisfied. In the example illustrated in if the execution order restriction represented by the task border edge is followed the execution order restrictions represented by the task border edges and are also followed. Hence as illustrated in the requisite minimum execution order restrictions between tasks are only regarding the task border edges and

Explained below is an example of an inclusion relation detecting algorithm for detecting the inclusion relation between such execution order restrictions. Consider the case of the task A the task B and two dependency relationships Dand Doriented from the task A toward the task B. Compare the start points and the end points of the two dependency relationships Dand D. When the execution order of the start point of the dependency relationship Dis either same as or later than the execution order of the start point of the dependency relationship Dand when the execution order of the end point of the dependency relationship Dis either same as or earlier than the execution order of the end point of the dependency relationship D the dependency relationship Dincludes the dependency relationship D. As a result once the execution order restriction represented in the dependency relationship Dis satisfied the execution order restriction represented in the dependency relationship Dalso gets satisfied.

This represents the inclusion relationship detecting algorithm for a simple example as illustrated in . However in a case when the tasks are divided at a plurality of locations as illustrated in or when taking into consideration the local variables of the C language it is necessary to implement an inclusion relationship detecting algorithm according to the input output information supported by the parallelization apparatus.

The parallelizing unit outputs the parallel program having synchronizations inserted therein that satisfy the execution order restrictions represented by the task border edges. illustrates an example of the parallel program that is generated by extracting the requisite minimum task border edges from the task border edges illustrated in . An execution order restriction is expressed by transfer of a token TOKID x where ID x is an identifier and the task border edge corresponds to a token and the task border edge corresponds to a token . The tokens correspond to commands put token and get token having the same identifier and after the command put token is executed it is guaranteed that the corresponding command get token is spared from execution.

According to the first embodiment in the generating unit and the instructing unit such dependency relationship information is provided which enables the user to determine the positions for inserting synchronizations not by having to refer to all of the information but only by referring to the individual information. That makes it possible to easily insert synchronizations of high quality.

As compared to the parallel program illustrated in according to the first embodiment the parallel program illustrated in has fewer parts that can be subjected to parallel execution. In the parallel program illustrated in a part R and a part S can be subjected to parallel execution a part T and a part U can be subjected to parallel execution the part T and the part S can be subjected to parallel execution and the part S and the part U can be subjected to parallel execution. Moreover the part T and v a c in the task can also be subjected to parallel execution. In contrast in the parallel program not according to the first embodiment only a part V and a part W illustrated in can be subjected to parallel execution. Hence as compared to the parallel program not according to the first embodiment the parallel program according to the first embodiment can be said to be sophisticated from the perspective of parallelization.

Meanwhile the first embodiment is not confined to the abovementioned example. Alternatively the program code can be provided as a text file having stored therein text data written in a programming language such as C language or Java registered trademark . Besides the program code can be provided as a file of text data written in an independent programming language. Moreover the program code need not be text data having easily comprehensible structure for a person but can be a binary file having binary data stored therein.

Furthermore all the information of the program code need not be stored in a single file but can be dividedly stored in a plurality of files. Moreover the program code need not be in the format of a file and can be in the form of data stored in a memory. For example as the program code it is possible to input a syntactic tree that represents data generated in a memory by a syntactic parsing apparatus of C language. Meanwhile the program code need not have the description of all the necessary operations but can also be a part of a larger program code.

The task border information is provided for example as a text file having stored therein text data indicating the task border positions in the program code . However the task border information need not be a file of text data having easily comprehensible structure for a person but can be a binary file having binary data stored therein.

Moreover the task border information need not be in the format of a file and can be in the form of data stored in a memory. For example a task border position specifying apparatus with a graphical user interface GUI can be provided for generating the task border information . In that case for example the task border position specifying apparatus displays the program code on a screen so that intended positions of the task borders can be specified using a pointing device such as a mouse and the specified positions can be output as task borders to the memory. Meanwhile the task border information need not be specified by the user but can be output by a different apparatus upon analyzing the program code . For example with the use of a task border information generating apparatus a label  the label label  and the label label  illustrated in can be recognized as task borders and the positions thereof can be output to the memory. Moreover for example the program code written in C language can be analyzed and searched for the positions of loops and the task borders can be recognized to be at such positions that are half of the loop iteration frequency and those positions can be output to the memory.

Meanwhile the program code and the task border information can be combined to be a single set of data. For example in an example in which a portion of the program code is bracketed off in a labeled curly bracket and the curly bracket is used to separate a task the program code and the task border information get combined.

A task is a portion of the operation for expressing the program code . One task can contain a plurality of discontinuous operations. For example in the example illustrated in the task and the task are illustrated to be different tasks. However alternatively as illustrated in the task and the task can also be considered to be a single task . When the task and the task are considered to be the single task it is not possible to perform parallel execution of the task and the task . In that case there is no need to take into consideration the dependency between the task and the task . Hence the task border which is the border between the anterior half of the task and the task as well as the task border which is the border between the task and the posterior half of the task serve as the task borders in the program code .

Besides the program code or the task border information can also hold parent child information of the tasks included therein. For example in the case of parallelizing only the loop portions of the program code including pre processing loops and post processing child tasks for performing parallel execution of the loops are started from parent tasks including pre processing and post processing. By taking into consideration the dependency relationships only between the child tasks to be subjected to parallel execution the parallelizing unit either can be spared from optimizing the dependency relationships between the parent tasks and the child tasks or can be configured to perform optimization by taking into consideration the dependency relationships between the parent tasks and the child tasks. Meanwhile the relationship between the parent tasks and the child tasks is not confined to two levels but can be of an arbitrary number of levels. That is the child tasks can further start grandchild tasks.

A task border partitions not the program code but the operations expressed by the program code . There are examples as illustrated in the example in when partitioning of the program code and partitioning of the operations expressed by the program code is equivalent. However there are times when partitioning of the program code and partitioning of the operations expressed by the program code is not equivalent. For example if loops of C language are included with respect to the program code partitioning of the program code and partitioning of the operations expressed by the program code becomes not equivalent. The inside of a loop written in C language represents operations for only a single iteration in the program code . However in actuality the operations may be performed for a plurality of iterations. Hence it is also possible to specify a task border midway of loop iteration. For example if the loop has 100 iterations a task border can be specified at the end of the fiftieth iteration. By specifying the task border in this way it becomes possible to implement data partitioning parallelization using arrays.

As long as the task borders represent the information that enables identification of the tasks to which the data accesses belong there is no restriction on the format of the task borders. For example by holding the information of the task to which the data accesses belong the portion at which the belonging task changes can be considered to be the task border edge.

There are various types to data access expressions. Apart from the data access expressions used in the example illustrated in for example function calls of C language can also become a type of data access expression. In a case when the data a and the data b are accessed in a function f either the function call f can be considered to be a data access expression of the data a and the data b or instead of considering the function call f as a data access expression a data access expression in the function can be directly used. As in the case of considering the function call f to be a data access expression of the data a and the data b it is possible that a single data access expression accesses a plurality of sets of data.

A direct access expression and an indirect access expression differ according to the type of the program code . In the example illustrated in the data access expression a is classified as a direct access expression. However it is not the only case. Alternatively for example in C language depending on the type definition of a variable a the data access expression a illustrated in may be an indirect access expression.

Meanwhile it is not necessary that the identifier constituting a data access expression has a correspondence relation of 1 1 with the data to be accessed. In the example illustrated in although the data access expression a is assumed to access the data a the same correspondence relation is not present in C language. Rather in C language the identifier a itself does not enable determining whether the data access expression a access a local variable a or a global variable a . Hence it is also necessary to analyze the variable declaration given in the program code . If the analyzing unit is configured to be capable of analyzing C language it becomes possible to determine without having to using dynamic data whether the data access expression a accesses a local variable a or a global variable a . With that the data access expression and the data can be related to each other.

In the description given above a dependency graph is expressed with a structure in which the true dependence the anti dependence and the output dependence are represented as edges. However that is not the only possible case. Alternatively as long as a dependency graph that is the first type dependency relationship information is expressed equivalently to the structure thereof it is also possible to express a stricter dependence. For example in a definition usage tree expressing the relationship between definitions of data and usage of data as well as expressing the order relation of definitions the anti dependence is not demonstratively represented as edges. However it is possible to derive the anti dependence from the order relation of definitions. For example in an order array in the program code that represents the order relation of data accesses in addition to the fact that the order relation of read accesses are expressed it is also possible to insert synchronizations either by deriving the dependency relationship from that order relation or by using only the order relation.

In the description given above as illustrated in dependency graphs are constructed regarding the data that is accessed only by direct access expressions. However that is not the only case. That is dependency graphs can also be constructed regarding the data that is accessed by indirect access expressions. For example in there is a possibility that the data access expression p written in the fifth line as well as the data access expression q written in the eighth line reads data z that is not expressed in the program code. Hence by constructing dependency graphs related to the data p and the data q a correct parallel program can be generated even when the data z is accessed by the data p and the data q .

Meanwhile the nodes of a dependence graph may not hold the information that indicates a write access or a read access. Even when there is no read write information there are times when the generating unit or the parallelizing unit can make use of the read write information depending on the method of presenting the information or depending on the method of parallelizing. For example using the order relation as the dependency relationship information falls under that case.

The edges of a dependency graph can also be made to express loop dependency or control dependency. The parallelizing unit can recognize the edges representing loop dependency or control dependency and insert synchronizations in an appropriate manner.

In a dependency graph it is sufficient if at least one node has the access reliability flag. If a particular node does not have the access reliability flag it is possible to treat that node to be equivalent to a node having the access reliability flag or to supplement the information about the access reliability flag from other information. For example regarding a read access node not having the access reliability flag a read access node in the dependency graph for an indirect access expression can be treated to be the node having unreliable as the access reliability flag. In this example as the dependency existence information it is also possible to input the data corresponding to each read access node in the dependency graphs for indirect access expressions.

Regarding the access reliability flag depending on an external input value that has not been analyzed the analyzing unit can set reliable as that access reliability flag. For example as compared to the program code illustrated in a program code illustrated in has the following if statement added therein if data z has value 0 data p points to data a . According to the program code illustrated in FIG. if the data z has the value 0 the data access expression p accesses the data a . In that case in a precise sense the value 0 of the external input z may not be obtained. Hence in the dependency relationship information of the data a unreliable is set as the access reliability flag of the node corresponding to the data access expression p . However since the if statement in the program code illustrated in can be interpreted to have been written under the assumption that the condition of having 0 as the value of the data z is satisfied the node corresponding to the data access expression p of the data a can also be considered to be a reliable access node.

In the description given above the presentation information and the first type dependency relationship information express the same structure. However that is not the only case and it is also possible that the presentation information and the first type dependency relationship information express different structures. For example as a dependency graph illustrated in the first type dependency relationship information related to the data a is held as the order array of data accesses and in the presentation information can be converted into a dependency graph divided on a task by task basis as illustrated in . In this way when the presentation information and the first type dependency relationship information express different structures the instructing unit can receive the dependency existence information with respect to the presentation information but needs to appropriately convert the dependency existence information into the conversion information .

The generating unit may not contain some portion held by the first type dependency relationship information in the presentation information . For example even if the first type dependency relationship information is holding the read write information of nodes it is possible for the generating unit not to contain that read write information in the presentation information . For example by limiting the elements of a dependency graph that can provide the dependency existence information it becomes possible to not contain the access reliability flags in the presentation information and to make them function as the parallelization apparatus . More particularly even if the information about nodes is not directly included in the presentation information as illustrated in a program code can be included in the presentation information and the edges linking the data access expressions in the program code can be included in the presentation information . As another example without including the information about edges in the presentation information only the information about nodes can be included.

Besides supplementary information of the presentation information can be received from the input unit and the generating unit can include that supplementary information in the presentation information . The examples of the supplementary information with respect to the presentation information include critical path information and execution path information.

The generating unit can identify at least one node and at the time of generating the presentation information of each node depending on whether or not the identified node is present in at least one of the paths leading to task border edges from the nodes included in the first type dependency relationship information can treat the identified node to be different from a reliable write node. Irrespective of the type of the identified node the method of generating the presentation information can be changed with the identified node considered to be a border. For example only the nodes on the task border side of the identified node can be included in the presentation information . Meanwhile instead of identifying nodes the same result can be achieved by identifying edges.

Regarding the method that is employed by the generating unit for identifying at least one node and generating the presentation information depending on whether or not the identified node is present in at least one of the paths leading to a task border edge from the nodes included in the first type dependency relationship information the method of expression differs depending on what type of data structure is used at the time of holding the first type dependency relationship information and there are a plurality of methods which in essence perform the same operations.

For example when the order relation is used as the first type dependency relationship information the presentation information can be generated depending on the order relation between each node and the task border. That method is same as the method of generating the presentation information depending on whether or not an identified node is present in at least one of the paths. Thus if the order relation is in the order of a particular node at least one of the identified nodes and the task border the identified node lies in at least one of the paths leading to the task border from the particular node. In contrast if the order relation is in the order of all identified nodes a particular node and the task border the identified nodes do not lie on any of the paths leading to the task border from the particular node.

Meanwhile the generating unit can generate the presentation information by selecting the information to be presented as well as selecting the method of presentation. As a first example thereof a presentation policy can be considered in which only the information related to a single selected unreliable task border edge is presented. As a second example a presentation policy can be considered in which all of the dependency relationship information related only to the data a is not presented. As a third example a presentation policy can be considered in which the task border edges are displayed in an accented color such as red and the other edges are displayed in an unaccented color such as black. As a fourth example a presentation policy can be considered in which only those nodes or edges are presented for which the dependency existence information needs to be input from the instructing unit . As a fifth example a presentation policy can be considered in which the sizes of nodes are changed according to the distances from task borders. These five presentation policies are only exemplary and it is also possible to implement other presentation policies or implement a combination of a plurality of presentation policies. Besides a presentation policy either can be incorporated in the generating unit or can be input from outside.

Moreover the generating unit can also be configured to implement a combination of the method of identifying at least one node and generating the presentation information depending on whether or not the identified node is present in at least one of the paths leading to a task border edge from the nodes included in the first type dependency relationship information and the method of generating the presentation information of each node according to the presentation policy. For example it is possible to think of a method in which only the unreliable access nodes on the inside of the identified task are included in the presentation information .

Herein whether or not the identified node is present corresponds to distinguishing the operations with respect to the node between portions requiring human judgment and portions not requiring human judgment. Besides by distinguishing between portions requiring human judgment and portions not requiring human judgment according to the presentation policy it becomes possible to perform the operations in an easier and speedier manner.

Meanwhile as the dependency existence information the instructing unit can receive the dependency existence information not of the nodes but of the edges. For example in the dependency graph illustrated in by issuing an instruction that the two edges extending over the task border are not present it becomes possible to analyze the fact that the node does not access the data a .

Alternatively as the dependency existence information the instructing unit can receive the dependency existence information of a plurality of nodes or edges. For example the instructing unit can receive dependency existence information which indicates that none of the unreliable access nodes in the dependency graph illustrated in is involved in dependency. In that case from the dependency graph the node and the node can be deleted.

Still alternatively as the dependency existence information the instructing unit can input data and correspondence information of the data. For example if data p and data a do not have correspondence relation is input as the dependency existence information the converting unit can remove the node of the data access expression p from the dependency graph of the data a and remove the node of the data access expression a from the dependency graph of the data p .

In the instructing unit the input of the dependency existence information can be completed while in the state of not receiving an instruction related to any unreliable task border edge and the system control may proceed to the conversion of dependency relationship information performed at S illustrated in . In this case there is a possibility that a task border edge has an unreliable access node linked thereto. The manner in which that unreliable access node is treated depends on the mounting policy of the entire apparatus. For example if it is to be considered that data is accessed from the unreliable access node that unreliable access node is converted into a reliable access node. On the other hand if it is to be considered that data is not accessed from the unreliable access node that unreliable access node is deleted and the dependency relationship information is reconstructed. Moreover in this case since there is a possibility of incorrect operations a warning can also be issued.

Meanwhile the parallel program is for example an executable file. Alternatively the parallel program can also be a text file in which is stored the text data written in a programming language such as C language or Java registered trademark or a text file in which is stored the text data written in an independent programming language of the parallelization apparatus . Regarding the parallel program all of the information need not be stored in a single file but can be dividedly stored in a plurality of files. Moreover the parallel program need not be in the format of a file and can be in the form of data stored in a memory. For example the parallel program can be executable data that has been output by a compiler during execution and that is stored in memory. Furthermore the parallel program need not have the description of all the necessary operations. Rather the parallel program can be an object file that is used in combination with other object files.

As described above according to the first embodiment from among a huge amount of data access related information that is included in the program code the requisite minimum information is selected and presented. That enables the user to easily and speedily issue a change instruction regarding the dependency relationship of data accesses between tasks. As a result a sophisticated parallel program can be generated at a low cost.

Moreover according to the first embodiment only the requisite minimum nodes are presented and the information on the respective surrounding nodes is also presented. That enables the user to know the information related to the surrounding nodes as well.

Subsequently based on the task border information and based on the first type dependency relationship information analyzed by the analyzing unit the generating unit generates the presentation information for the purpose of presentation S . The instructing unit determines whether the dependency existence information has been input S and when the dependency existence information is determined to have been input the system control moves to S. The instructing unit refers to the dependency existence information and generates or updates the conversion information S and the system control returns to S. The generating unit reflects in the presentation information the conversion information that has been updated based on the dependency existence information .

On the other hand when it is determined that the input of the dependency existence information has completed and that there is no input of the dependency existence information at Step S the system control moves to S. The converting unit refers to the conversion information that is generated or updated by the instructing unit and converts the first type dependency relationship information that is analyzed by the analyzing unit into the second type dependency relationship information S . Subsequently the repositioning unit refers to the second type dependency relationship information that is obtained by conversion by the converting unit and generates and outputs the parallel program having repositioned synchronizations S .

In the following description the explanation of each functional block of the synchronization optimization apparatus is given for the most basic configuration in which the functional blocks are tandemly connected in the sequence illustrated in . However the second embodiment is not limited to that case. Alternatively for example the second embodiment can be implemented for a configuration in which a plurality of functional blocks operate in a coordinated manner or can be implemented for a configuration in which the sequence of some functional blocks is interchanged or can be implemented for a configuration in which a particular functional block is divided into a plurality of functional blocks or can be implemented for a configuration having a combination of the above mentioned three configurations. Besides the second embodiment can also be implemented by dividing the functional blocks into a plurality of units.

The input unit receives the program code and the task border information into the synchronization optimization apparatus . Herein the program code represents a parallel program that is already divided on a task by task basis using some known method and that has the tasks subjected to parallelization. Thus the program code contains the task border information .

The analyzing unit analyzes the program code and the task border information and outputs the first type dependency relationship information .

The analyzing unit refers to synchronization information specified in the program code and analyzes execution order restrictions applied on the computer program by the program code . In the example illustrated in the synchronization information contains the commands put token and get token and contains identifiers for identifying tokens that are transferred using those commands. The command put token is a command for delivering a token while the command get token is a command for receiving a token. The analyzing unit analyzes that the commands put token and get token having the same identifier are in a corresponding relation.

Herein the term block refers to consecutive processing not containing a synchronization code. The analyzing unit extracts such a block from each task in the program code . In the example illustrated in the 17 th to 20 th lines in the task constitute a single block . Similarly the third line and the fourth line in the task constitute a single block while the sixth line in the task constitutes a single block . Moreover the 11 th line and the 12 th line in the task constitute a single block while the 14 th line in the task constitutes a single block .

In the command put token and the command get token that are in a correspondence relation are linked with arrows indicating synchronization positions. The analyzing unit refers to the correspondence relation of the synchronization information illustrated in and analyzes execution order restrictions in the program code illustrated in .

For example the block included in the task and the block included in the task are included in different tasks. Hence between the block and the block the execution order restriction 2 is applied by the commands put token and get token having TOKID  as the identifier. In contrast between the blocks and that are included in the same task the execution order restriction 1 is applied in which execution is performed in downward sequence from above.

In this way by analyzing the execution order restrictions in the program code the execution order restrictions among the blocks are obtained as illustrated in . There the execution is performed in the sequence of the block and the block . After executing the block the block and the block are executed. After executing the blocks and the block is executed.

The analyzing unit refers to the execution order restrictions that have been analyzed and analyzes the first type dependency relationship information . illustrates an example of the first type dependency relationship information that is analyzed by referring to the execution order restrictions illustrated in . In the program code illustrated on the left side is given only for the purpose of enabling greater understanding of the correspondence relation of each node. In actuality the first type dependency relationship information does not hold the information regarding the program code.

Once the data access expressions are executed in the order of the execution order restrictions the analyzing unit generates a dependency graph by referring to the execution order of the data access expressions. For example in the block a 0 a 2 and s p are accessed in that particular order then in the block q 4 is accessed then in the block t a is accessed and then in the block v a c is accessed. From such an access order a dependency graph illustrated in is generated. Regarding the data b and the data c dependency graphs and are respectively generated in an identical manner.

When the nodes that are linked to the edges specified in the first type dependency relationship information belong to different tasks the analyzing unit analyzes that task borders are present at such edges. In the example illustrated in as described above the task border between the tasks and is referred to as the task border the task border between the tasks and is referred to as the task border and the task border between the tasks and is referred to as the task border .

Meanwhile the generating unit the instructing unit and the converting unit have identical functions to the functions of the generating unit the instructing unit and the converting unit respectively illustrated in according to the first embodiment. Moreover the operations are also identical to the operations performed in the parallelization apparatus according to the first embodiment. Hence the explanation thereof is not repeated.

The repositioning unit refers to the second type dependency relationship information obtained by conversion by the converting unit re determines the positions of synchronizations and generates the parallel program having the re determined synchronizations inserted therein. The operations performed by the repositioning unit differ from the operations performed by the parallelizing unit in the parallelization apparatus in the following points 

For example the dependency existence information identical to that explained in the first embodiment is provided to the program code containing the task border information and the conversion information illustrated in is generated based on the dependency existence information . With respect to the second type dependency relationship information which is obtained by the converting unit by converting the first type dependency relationship information on the basis of the conversion information the repositioning unit analyzes necessary synchronizations in an identical manner to that explained in the first embodiment and outputs the parallel program having optimized synchronizations as illustrated in .

In this way according to the second embodiment instead of inputting a sequential program even if a parallel program that has already been subjected to parallelization is input it is still possible to perform meaningful processing. That is with respect to the parallel program that has been input synchronizations are optimized so as to enable achieving enhancement in the performance of the parallel program.

In a third embodiment while a parallel program is running a runtime library is configured to change dependency relationship information that indicates the dependency relationship of data accesses in a parallel program.

If the parallelization system illustrated in is compared to the parallelization apparatus according to the first embodiment some constituent elements of the parallelization apparatus are included in the code converting unit and the other constituent elements are included in the runtime library unit . The interface included in the parallel program is for example an API of the runtime library unit . Via the interface the parallel program can communicate with the runtime library unit .

Moreover as compared to the parallelization apparatus illustrated in the parallelization system illustrated in has an interface I F inserting unit and an information generating unit added therein.

In the third embodiment in the code converting unit the parallelizing unit refers to task border information and generates a parallel program A by parallelizing a program code . The interface inserting unit refers to the first type dependency relationship information which is analyzed by the analyzing unit on the basis of the program code and the task border information as well as refers to the presentation information which is obtained by the generating unit by converting the first type dependency relationship information and generates the parallel program by inserting the interface in the parallel program A that is generated by the parallelizing unit .

Moreover between the program code that is input as a sequential program and the parallel program A that is obtained by conversion of the program code mutually and functionally equivalent memory access is performed. For example in the program code if the indirect access expression p accesses the data a even in the parallel program A that is obtained by parallelizing the program code the indirect access expression p refers to the same data a .

The synchronization interface inserting unit refers to the first type dependency relationship information and inserts a synchronization interface in the parallel program . The relationship information generating unit receives the presentation information and generates relationship information that expresses a correspondence relation between write accesses for the dynamic data which is used in deciding the access destinations of indirect access expressions and nodes corresponding to indirect access expressions for which the existence of access is determined by the write accesses. Based on the relationship information the dependency existence information updating interface inserting unit inserts a dependency existence information updating interface in the parallel program .

The interface includes the synchronization interface and the dependency existence information updating interface that are inserted in the parallel program by the interface inserting unit .

The first type dependency relationship information generated in the code converting unit is delivered to the runtime library unit via a first type dependency relationship information file that expresses the dependency relationship between data accesses using the extensible markup language XML format. The first type dependency relationship information generated by the analyzing unit is first stored in the first type dependency relationship information file by a dependency information output unit and delivered to the runtime library unit and input to a converting unit .

In the first embodiment the user generates the dependency existence information and inputs it using the instructing unit . In contrast in the third embodiment the dependency existence information is generated by the information generating unit via the dependency existence information updating interface of the parallel program and is input to an instructing unit .

The runtime library unit and the parallel program are compiled to an executable state and are executed in a program execution environment of a processor. The parallel program is executed along with the runtime library unit in for example an execution environment that is partially or entirely common with the runtime library unit . Once the execution starts the converting unit in the runtime library unit reads the first type dependency relationship information that is stored in the first type dependency relationship information file .

Meanwhile along with the execution of the parallel program the execution result of the dependency existence information updating interface that has been inserted is delivered to the information generating unit in the runtime library unit . The execution result of the dependency existence information updating interface contains for example the information indicating whether or not the interface has been executed. Depending on the execution result for the interface the information generating unit generates the dependency existence information . That dependency existence information is input to the instructing unit .

From the dependency existence information input thereto the instructing unit generates the conversion information . Subsequently based on the conversion information the converting unit converts the first type dependency relationship information which has been read from the first type dependency relationship information file into the second type dependency relationship information . The second type dependency relationship information is input to the synchronization interface in the parallel program . The synchronization interface reflects the second type dependency relationship information during synchronization of tasks of the parallel program .

The parallelization system according to the third embodiment can have a number of variations. For example the code converting unit can be included in the execution environment of the parallel program . Besides regarding the method of transferring the first type dependency relationship information between the code converting unit and the execution environment various methods can be implemented. For example the first type dependency relationship information can be transferred not only by storing it in a file but also as data in a memory. Similarly regarding the method of inserting the interface in the parallel program various methods can be implemented. For example the interface can be inserted not only on a line by line basis in the program code but also on a block by block basis where each block has a plurality of lines in the program code.

Moreover the operations of the interface and the runtime library unit which serves as the function of the interface can also be performed in many ways. For example there can be separate interfaces for deleting unreliable access nodes and for changing unreliable access nodes into reliable access nodes or there can be a single interface performing both of those functions.

According to the third embodiment the parallelization system monitors the execution of the parallel program by inserting the interface . However that is not the only possible case. That is the execution of the parallel program can also be monitored by implementing some other method. For example a method can be implemented in which instead of inserting anything in the parallel program the OS is instructed to monitor the execution of the program code of the parallel program and when a CPU command under monitoring is executed synchronization or dependency existence is updated. In the case of instructing the OS to monitor the execution status the relationship information is referred to for setting in the OS the commands to be monitored by the OS and the operations to be performed in response to the execution of those commands.

Meanwhile the functions of the parallelization system illustrated in can also be implemented using hardware or using software running in the CPU. Alternatively the functions can be implemented by a combination of hardware and software. Moreover regarding the program code the task border information the input unit the analyzing unit the first type dependency relationship information and the information generated and used by those components a number of variations are possible as described in the first embodiment.

Besides the method of using the second type dependency relationship information which is obtained by conversion by the runtime library unit is also not limited to the explanation given above. For example each time the second type dependency relationship information is updated the updating details can be stored as trace information which can be put to use at the time of generating the parallel program as dependency relationship information that reflects dynamic information.

Explained below with reference to a sample code is the configuration of the parallel program or the operations of the runtime library unit . illustrates an example of the program code that is input to the code converting unit . In the program code the data represents the dynamic data used in deciding the access destination of the indirect access expression p and a data access by the indirect access expression p points to an unreliable access node. In this program code the data accessed by the data p is decided depending on the branching of the if statement condition written between the second line and the sixth line.

When the if statement yields true the code p a is executed and the indirect access expression p accesses the data a . In contrast when the if statement yields false the code p b is executed and the indirect access expression p accesses the data b . Thus the access to the node of the indirect access expression p can be decided according to the result of the if statement condition.

By referring to the edges extending over the task borders to the analyzing unit can identify the dependency relationship between the respective tasks. At that time if no node of the target data exists in a particular task even if an edge is present at the task border related to that particular task there is no dependency relationship between that particular task and the data. For example in the example illustrated in regarding the data a it is illustrated that an unreliable task border edge is present between the task Task and the task Task. Regarding the data c it is illustrated that an unreliable task border edge is present between the task Task and the task Task.

On the basis of the task border information the parallelizing unit converts the program code into the parallel program A. For example the parallelizing unit converts the program code into the parallel program A that is divided on a task by task basis. In the parallel program A the tasks Task Task and Task are defined by codes Task Task and Task respectively along with curly brackets . . . .

With respect to the parallel program A generated by the parallelizing unit the interface inserting unit inserts commands or functions valid node invalid node post sync and wait sync and generates the parallel program . illustrates an example of the parallel program generated on the basis of the program code illustrated in . In the following explanation for the sake of convenience the commands or functions valid node invalid node post sync and wait sync are explained as commands.

The commands valid node and invalid node represent dependency existence information updating interfaces. The commands post sync and wait sync represent synchronization interfaces. A dependency existence information updating interface inserted in the parallel program A is the dependency existence information updating interface . In an identical manner a synchronization interface inserted in the parallel program A is the synchronization interface . These commands are the interfaces APIs that are used in communicating with the runtime library unit and that constitute the interface .

The dependency existence information updating interface monitors the write accesses to the dynamic data that is used in deciding the access destinations of indirect access expressions included in the parallel program and sends the monitoring result to the runtime library unit .

The commands valid node and invalid node that constitute the dependency existence information updating interface are interfaces for updating the dependency existence information related to the unreliable task border nodes. The commands valid node and invalid node update the information regarding unreliable nodes as well as change the unreliable nodes into reliable nodes or delete unreliable nodes. The commands valid node and invalid node are inserted by the interface inserting unit at the access locations for those variables which are responsible for unreliable task border nodes. Herein variables affecting the state of unreliable task border nodes are the variables used in deciding the access destinations of the abovementioned indirect access expressions. More particularly in a programming language such as C language pointers or array indices represent such variables.

The relationship information generating unit generates the relationship information that is related to the existence of accesses between unreliable task border nodes included in the presentation information and the data accesses that decide the existence of accesses of those unreliable task border nodes. Herein the relationship information is referred to for inserting the commands valid node and invalid node .

The relationship information that is generated by the relationship information generating unit contains position information indicating the positions in the parallel program A for inserting the commands valid node and invalid node and contains arguments to be assigned to those commands. An argument contains identifiers for identifying the node to which the corresponding command points to. Herein a variable access represents for example substitution of an address in a pointer variable that is an indirect access expression.

The dependency existence information updating interface inserting unit analyzes the accesses with respect to the variables in the program code and extracts such data accesses that exert influence on the existence of the data accesses with respect to those variables or affect changing of the access reliability flag from unreliable to reliable of unreliable access nodes. At that time the dependency existence information updating interface inserting unit performs this type of analysis regarding all types of accesses such as a direct access expression and an indirect access expression related to a particular variable.

The following explanation is given with reference to the program code that is a sequential program illustrated in . As is the case in the third line in the program code when the code is written so as to set the data a in the indirect access expression p the interface inserting unit refers to the relationship information illustrated in . More particularly from the relationship information illustrated in the dependency existence information updating interface inserting unit can obtain the information regarding the commands valid node and invalid node that are to be inserted as dependency existence information updating interfaces. The dependency existence information updating interface inserting unit refers to the relationship information and for example inserts the dependency existence information updating interfaces that are associated with the monitoring position information on the code p a .

As illustrated in regarding the data a there exist two unreliable task border nodes namely a node identified by the identifiers VAR ID  and NODE ID  and a node identified by the identifiers VAR ID  and NODE ID  . Thus as written in the fourth and fifth lines in the parallel program illustrated in commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  are inserted with the aim of changing those nodes into reliable access nodes. Similarly regarding the data b there exist two unreliable task border nodes namely a node identified by the identifiers VAR ID  and NODE ID  and a node identified by the identifiers VAR ID  and NODE ID  . Regarding these nodes as written in the sixth line in the parallel program in commands invalid node VAR ID  NODE ID  and invalid node VAR ID  NODE ID  are inserted with the aim of deleting those nodes.

Meanwhile in the third embodiment the explanation is given for an example in which the substitution with respect to the indirect access expression p is monitored by the insertion performed by the dependency existence information updating interface . However it is not the only possible case. Alternatively it is possible to monitor the reference with respect to the indirect access expression p or to monitor the substitution as well as the reference with respect to the indirect access expression p .

The commands post sync and wait sync constituting the synchronization interface are synchronization interfaces for controlling inter task synchronization. When there exists an edge starting from a particular access node the command post sync is inserted immediately after the code statement specifying that access. In contrast when there exists an edge leading to a particular access node the command wait sync is inserted immediately prior to the code statement specifying that access.

In comparison with the first type dependency relationship information illustrated in or in in the example of the parallel program illustrated in a command post sync VAR ID  NODE ID  is inserted immediately after an access with respect to the data a by a direct access expression as written in the 15 th line. Moreover commands post sync VAR ID  NODE ID  post sync VAR ID  NODE ID  and post sync VAR ID  NODE ID  are inserted immediately after an access with respect to the data c by the indirect access expression p as written in the 17 th line.

Regarding the command wait sync immediately prior to an access with respect to the data c by a direct access expression as written in the 24 th line a command wait sync VAR ID  NODE ID  is inserted. Similarly immediately prior to an access with respect to the data b by a direct access expression as written in the 26 th line a command wait sync VAR ID  NODE ID  is inserted. Moreover immediately prior to an access with respect to data t by the indirect access expression p as written in the 33 rd line a command wait sync VAR ID  NODE ID  and a command wait sync VAR ID  NODE ID  are inserted.

Explained below in a schematic manner are the functions performed by each command constituting the interface .

Sends to the converting unit via the information generating unit and the instructing unit of the runtime library unit the conversion information used in changing the node specified in the argument into a reliable access node.

More particularly when the command valid node is executed in the interface to the information generating unit are delivered an argument containing an identifier that identifies data and a node and an identifier that identifies the node and an instruction for changing the node that has been specified in the argument into a reliable access node. The information generating unit refers to the information received from the command valid node and generates the dependency existence information . The instructing unit refers to the dependency existence information and generates the conversion information that is used in changing the node that has been specified in the argument into a reliable access node and sends that conversion information to the converting unit . Meanwhile in an identical manner execution results of the commands invalid node post sync and wait sync described later are also sent to the converting unit .

The converting unit refers to the conversion information sent thereto and accordingly updates the second type dependency relationship information . In a case such as at the time of executing the parallel program for the first time when the second type dependency relationship information does not exist the second type dependency relationship information can be generated on the basis of the first type dependency relationship information read from the first type dependency relationship information file . Meanwhile when there is an access with respect to an indirect access expression the command valid node is inserted for a number of times that is equal to the number of unreliable task border nodes corresponding to the data set in that indirect access expression. In the command valid node the unreliable task border nodes corresponding to the data set in the indirect access expression are specified in the arguments.

Sends to the converting unit via the information generating unit and the instructing unit of the runtime library unit the conversion information used in deleting the node specified in the argument. The converting unit refers to the conversion information and deletes unreliable access nodes from the second type dependency relationship information . In a case such as at the time of executing the parallel program for the first time when the second type dependency relationship information does not exist the second type dependency relationship information can be generated on the basis of the first type dependency relationship information read from the first type dependency relationship information file . Meanwhile when there is an access with respect to an indirect access expression the command invalid node is inserted for a number of times that is equal to the number of unreliable task border nodes corresponding to the data not set in that indirect access expression. In the command invalid node the unreliable task border nodes corresponding to the data not set in the indirect access expression are specified in the arguments.

Checks the second type dependency relationship information and when a node specified in the argument is present sends the conversion information used in deleting the edge starting from that particular node to the converting unit via the information generating unit and the instructing unit of the runtime library unit . In a case such as at the time of executing the parallel program for the first time when the second type dependency relationship information does not exist the second type dependency relationship information can be generated on the basis of the first type dependency relationship information read from the first type dependency relationship information file . Meanwhile the command post sync is inserted when the edge starting from the target node is a reliable task border edge or an unreliable task border edge.

Refers to the second type dependency relationship information checks when the node specified in the argument is present whether or not there exists an edge reaching that node and sends to the converting unit via the information generating unit and the instructing unit of the runtime library unit a request to determine whether to start execution or to wait for synchronization. In response to that request the converting unit refers to the second type dependency relationship information based on the conversion information . At that time the converting unit uses the conversion information only for the purpose of referring to the second type dependency relationship information and does not make any changes in the dependency relationship information. In a case such as at the time of executing the parallel program for the first time when the second type dependency relationship information does not exist the second type dependency relationship information can be generated on the basis of the first type dependency relationship information read from the first type dependency relationship information file . Meanwhile the command wait sync is inserted when the edge leading to the target node is a reliable task border edge or an unreliable task border edge.

With the commands inserted into the parallel program by the dependency existence information updating interface inserting unit the execution results of the dependency existence information updating interface are delivered to the information generating unit . Based on those execution results the information generating unit generates the dependency existence information . By referring to the dependency existence information the data accesses in the running parallel program are monitored. In other words it can be said that the dependency existence information updating interface inserting unit the dependency existence information updating interface and the information generating unit constitute a monitoring unit for monitoring the data accesses in the parallel program . Meanwhile in the case of instructing the OS to monitor the data accesses as described above the functional components constituting a monitoring unit are different than in the third embodiment.

Firstly explained below with reference to is an execution image in chronological order when the if statement yields true .

 1 Each of the task Task the task Task and the task Task starts execution. The task Task need not wait for synchronization and thus starts operations. The task Task executes the command wait sync VAR ID  NODE ID  . Herein as illustrated in the node specified in the argument is present. Thus firstly it is checked whether there exists an edge starting from the node specified in the argument. Since such an edge exists the task Task falls into a synchronization waiting mode. The task Task executes the command wait sync VAR ID  NODE ID  . In this case since the node specified in the argument is present it is checked whether there exists an edge leading to that node. Since such an edge exists the task Task also falls into the synchronization waiting mode. Meanwhile the tasks Task and Task which cannot start operations while in the synchronization waiting mode perform polling and repeatedly check the respective conditions.

 2 The task Task continues with the processing of the computer program and finishes processing of the if statement. In this example it is assumed that the if statement yields true . There the task Task executes the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  written in the fourth and fifth lines respectively and updates the target nodes to reliable access nodes in the second type dependency relationship information . Moreover the task Task executes the commands invalid node VAR ID  NODE ID  and invalid node VAR ID  NODE ID  written in the sixth and seventh lines respectively and deletes not only the target nodes but also the edges linked to those nodes.

Thus for example when the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  are executed the information generating unit generates the dependency existence information according to the arguments. The conversion information which is used in changing the nodes that are specified in the arguments into reliable access nodes is sent to the converting unit via the instructing unit of the runtime library unit .

The same is the case regarding the commands invalid node VAR ID  NODE ID  and invalid node VAR ID  NODE ID  . The converting unit refers to the conversion information sent thereto and updates the second type dependency relationship information . The interface reflects the updated second type dependency relationship information in the execution of the parallel program .

 3 The task Task continues with the execution and after setting the value 2 in the direct access expression a written in the 15 th line executes the command post sync VAR ID  NODE ID  written in the 16 th line. Since the target node VAR ID  NODE ID  is present the edge starting from that node VAR ID  NODE ID  is deleted. illustrates an example of the second type dependency relationship information after deleting that edge. In comparison with it can be seen that the edge starting from the node VAR ID  NODE ID  and leading to the node VAR ID  NODE ID  is deleted dependency graph .

 4 The task Task continues with the execution and sets the value of the indirect access expression p that is the value 2 of the data a in the data c written in the 17 th line. Subsequently with respect to the node related to the indirect access expression p the command post sync VAR ID  NODE ID  written in the 18 th line and the command post sync VAR ID  NODE ID  written in the 19 th line are executed. Since the target nodes VAR ID  NODE ID  and VAR ID  NODE ID  are present the edges starting from those nodes are deleted. is an example of the second type dependency relationship information after deleting those edges. In comparison with it can be seen that the edge starting from the node VAR ID  NODE ID  and leading to the node VAR ID  NODE ID  as well as the edge starting from the node VAR ID  NODE ID  and leading to the node VAR ID  NODE ID  is deleted dependency graph dependency graph .

 5 The task Task continues with the execution and executes the command post sync VAR ID  NODE ID  written in the 20 th line. In this case since the target node VAR ID  NODE ID  has already been deleted no operation is performed in actuality.

 6 Meanwhile the task Task which is performing polling in response to the command wait sync VAR ID  NODE ID  refers to the second type dependency relationship information illustrated in and detects that the edge leading to the target node VAR ID  NODE ID  has been deleted. Hence the task Task starts the execution.

 7 In an identical manner the task Task which is performing polling in response to the command wait sync VAR ID  NODE ID  refers to the second type dependency relationship information illustrated in and detects that the edge leading to the target node VAR ID  NODE ID  has been deleted. Thus the task Taks also starts the execution.

 8 The task Task executes the command wait sync VAR ID  NODE ID  written in the 32 nd line. However since the edge leading to the target node VAR ID  NODE ID  has already been deleted no operation is performed. Subsequently according to the code written from the 33 rd line to the 35 th line the task Task sets the value of the data t in the data accessed by the indirect access expression p and sets a value obtained by adding the value of a direct access expression v and the value 3 in a direct access expression u . Moreover in the value of the direct access expression v the task Task sets a value obtained by adding the value of a direct access expression s and the value 5 .

 9 The task Task sets the value 3 in the direct access expression c written in the 24 th line and executes the command wait sync VAR ID  NODE ID  written in the 25 th line. However as illustrated in since the edge leading to the target node VAR ID  NODE ID  does not exist the task Task continues with the execution.

 10 Subsequently the task Task sets the value 4 in the direct access expression b written in the 26 th line and executes the command post sync VAR ID  NODEID2 . However as illustrated in since the edge leading to the target node VAR ID  NODE ID  does not exist no operation is performed in actuality. The task Task sets the value 5 in the direct access expression c .

Explained below with reference to is an execution image in chronological order when the if statement yields false .

 1 Each of the task Task the task Task and the task Task starts the execution. The task Task can start the operations. The task Task executes the command wait sync VAR ID  NODE ID  . Herein as illustrated in since there exists an edge starting from the node specified in the argument the task Task falls into the synchronization waiting mode. The task Task executes the command wait sync VAR ID  NODE ID  . In that case too since the node specified in the argument is present it is checked whether there exists an edge leading to that node. Since such an edge exists the task Task also falls into the synchronization waiting mode. The tasks Task and Task which cannot start operations while in the synchronization waiting mode perform polling and repeatedly check the respective conditions.

 2 The task Task continues with the processing of the computer program and finishes processing of the if statement. In this example it is assumed that the if statement yields false . There the task Task executes the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  written in the 10 th and 11 th lines respectively and updates the target nodes to reliable access nodes in the second type dependency relationship information . Moreover the task Task executes the commands invalid node VAR ID  NODE ID  and invalid node VAR ID  NODE ID  written in the 12 th and 13 th lines respectively and deletes not only the target nodes but also the edges linked to those nodes. Subsequently the task Task continues with the execution.

 3 Meanwhile the task Task which is performing polling in response to the command wait sync VAR ID  NODE ID  refers to the second type dependency relationship information illustrated in and confirms that no unreliable task border edge exists related to the indirect access expression p of the data a . Hence the task Task comes out of polling and starts operations.

 4 The task Task executes the command wait sync VAR ID  NODE ID  written in the 32 nd line. Since the node VAR ID  NODE ID  that is specified in the argument is present it is checked whether there exists an edge leading to that node. Since such an edge exists the task Task falls in the synchronization waiting mode.

 5 The task Task sets the value 2 in the direct access expression a written in the 15 th line and executes the command post sync VAR ID  NODE ID  written in the 16 th line. However since the target node VAR ID  NODE ID  has already been deleted no operation is performed.

 6 In the data c written in the 17 th line the task Task sets the value of the indirect access expression p that is the value of the data b . Subsequently the task Task executes the command post sync VAR ID  NODE ID  written in the 18 th line. Since the target node VAR ID  NODE ID  is present the task Task deletes the edge starting from that node VAR ID  NODE ID  . illustrates an example of the second type dependency relationship information after deleting that edge. In comparison with it can be seen that the edge linking the node VAR ID  NODE ID  to the node VAR ID  NODE ID  has been deleted dependency graph .

 7 Meanwhile the task Task which is performing polling in response to the command wait sync VAR ID  NODE ID  refers to the second type dependency relationship information illustrated in and detects that the edge leading to the target node VAR ID  NODE ID  has been deleted. Hence the task Task starts the execution.

 8 The task Task executes the command post sync VAR ID  NODE ID  written in the 19 th line. However since the target node VAR ID  NODE ID  has already been deleted no operation is performed.

 9 The task Task executes the command post sync VAR ID  NODE ID  written in the 20 th line. Since the target node VAR ID  NODE ID  is present the task Task deletes the edge starting from that node VAR ID  NODE ID  . illustrates an example of the second type dependency relationship information after deleting that edge. In comparison with it can be seen that the edge linking the node VAR ID  NODE ID  to the node VAR ID  NODE ID  has been deleted dependency graph . The task Task ends the execution.

 10 The task Task sets the value 3 in the direct access expression c written in the 24 th line and executes the command wait sync VAR ID  NODE ID  written in the 25 th line. Since the edge leading to the target node VAR ID  NODE ID  does not exist the task Task continues with the execution.

 11 The task Task sets the value 4 in the direct access expression b written in the 26 th line and executes the command post sync VAR ID  NODE ID  written in the 27 th line. Since the target node VAR ID  NODE ID  is present the task Task deletes the edge starting from the node VAR ID  NODE ID  . is an example of the second type dependency relationship information after deleting that edge. In comparison with it can be seen that the edge linking the node VAR ID  NODE ID  to the node VAR ID  NODE ID  has been deleted dependency graph . The task Task sets the value 5 in the direct access expression c written in the 28 th line and ends the execution.

 12 Meanwhile the task Task which is performing polling in response to the command wait sync VAR ID  NODE ID  refers to the second type dependency relationship information illustrated in and detects that the edge leading to the target node VAR ID  NODE ID  has been deleted. Hence the task Task starts the execution. Subsequently according to the code written from the 33 rd line to the 35 th line the task Task sets the value of the data t in the data accessed by the indirect access expression p and sets a value obtained by adding the value of the direct access expression v and the value 3 in the direct access expression u . Moreover in the value of the direct access expression v the task Task sets a value obtained by adding the value of the direct access expression s and the value 5 .

In this way according to the third embodiment the runtime library unit modifies the parallel execution status of the tasks in accordance with the execution result of the parallel program . As far as the execution image illustrated in is concerned the unreliable access nodes are updated during the execution. Hence it becomes possible to perform a greater number of parallel executions as compared to the execution image illustrated in . Meanwhile although not explained in this example depending on the parallel program it is necessary to insert synchronizations also with respect to the inter task dependency in the dynamic data that is used in deciding the access destinations of indirect access expressions.

According to the method explained in the third embodiment the runtime library unit refers to the dependency relationship information of the parallel program and depending on the reference result can control the parallel execution status. Moreover by updating the dependency relationship on the access by access basis of data the parallel execution management can be performed at a granular level.

The configuration of the parallelization system according to the third embodiment is not limited to the configuration illustrated in . Rather there are various other configurations that can be implemented. For example the code converting unit can be partially or entirely incorporated in the runtime library unit .

Moreover regarding the program code the task border information the input unit the analyzing unit and the first type dependency relationship information as well as all of the above mentioned information and the information generated and used by the components a number of variations are possible in a similar manner as already described in the first embodiment.

Besides regarding the method of transferring the first type dependency relationship information between the code converting unit and the runtime library unit various methods can be implemented other than transferring the first type dependency relationship information using the first type dependency relationship information file . For example to the code converting unit can be appended a binary converting unit that converts the parallel program into a binary code and the first type dependency relationship information can be embedded in the binary code of the parallel program . Moreover even in the case of transferring the first type dependency relationship information in a file various methods such as using a normal text file or expressing the information in the binary form are possible.

Furthermore regarding the insertion of the interface in the parallel program various methods can be implemented. Moreover regarding the functions provided in the runtime library unit or regarding the interfaces APIs a number of variations are possible. For example in the third embodiment the operation for updating the second type dependency relationship information or dissolving synchronizations is carried out by inserting an API in the parallel program . However alternatively a program code written to perform those operations can be directly inserted in the parallel program . Besides as far as the insertion of APIs for achieving synchronization is concerned it is not the only option to insert an API on a variable by variable basis. Rather various methods of insertion can be implemented. For example only the requisite minimum APIs can be inserted so as to satisfy the dependency relationship between threads. Moreover the two APIs corresponding to the commands valid node and invalid node can be combined into a single API. Similarly for example the same API that is inserted in succession in the fourth and fifth lines illustrated in can also be combined into a single API.

Meanwhile the entire system or the individual functional blocks constituting the system can be implemented using hardware using software or using a combination of hardware and software.

As described above in contrast to the case when the task border information is not referred to and when the dependency existence information is updated regarding all unreliable access nodes including those unreliable access nodes which do not exert any influence on the task borders according to the third embodiment the dependency existence information is updated regarding only those unreliable access nodes which are linked to the task border edges. For that reason it becomes possible to curb updating overhead at runtime thereby enabling achieving reduction in the runtime overhead. Besides since the dependency relationship information is updated by referring to the latest information during the execution and since the analysis is performed by referring to the updated dependency relationship information it becomes possible to perform parallelization that is determined to be the most appropriate at that point of time during the execution.

In a fourth embodiment while the sequential program is running a runtime library is configured to change the dependency relationship information that indicates the dependency relationship of data accesses. That makes it possible to perform detailed analysis of reliable dependency relationship.

Explained below in a schematic manner are the differences between the analysis system according to the fourth embodiment and the parallelization system according to the third embodiment. In the parallelization system according to the third embodiment the code converting unit outputs the parallel program . In contrast in the analysis system according to the fourth embodiment a code converting unit outputs a program code referred to as a profile program . Moreover in the parallelization system according to the third embodiment the second type dependency relationship information output by the runtime library unit is input to the interface in the parallel program . In contrast in the analysis system according to the fourth embodiment a runtime library unit outputs the second type dependency relationship information to the outside and does not include it to the profile program .

More specifically in the analysis system according to the fourth embodiment an interface inserting unit in the code converting unit receives a program code A from the input unit . The interface inserting unit generates an interface by referring to the program code A and generates the profile program by inserting the interface in the program code A. Herein the interface in the profile program does not receive the second type dependency relationship information .

The runtime library unit includes an output unit for outputting the second type dependency relationship information to the outside. Thus the output unit outputs the second type dependency relationship information which is input thereto from the converting unit to the outside of the runtime library unit i.e. to the outside of the analysis system . Meanwhile there is no particular restriction on the data format of the second type dependency relationship information that is output. That is the second type dependency relationship information can be in any of the various data formats such the text data format the binary data format the image data format or the XML format.

In an identical manner to the interface inserting unit according to the third embodiment the interface inserting unit analyzes the presentation information and the program code A and generates relationship information that holds a dependency existence information updating interface in a corresponding manner with monitoring position information indicating the positions for inserting the dependency existence information updating interface.

The interface inserting unit generates the profile program by inserting the interface which is generated by referring to the relationship information into the program code A that is a sequential program. illustrates an example of the program code of the profile program generated in the abovementioned manner.

The example in is for the profile program generated by inserting the interface in the program code illustrated in . In the profile program illustrated in a task border is defined between the 11 th line and the 12 th line and a task border is defined between the 14 th line and the 15 th line. The code from the first line to the 11 th line is referred to as the task Task the code from the 12 th line to the 14 th line is referred to as the task Task and the code from the 15 th line to the 17 th line is referred to as the task Task.

As illustrated in the profile program is generated in the following manner. According to the relationship information illustrated in at the position of the code p a the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  are inserted as the interface . Similarly at the position of the code p b the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  are inserted as the interface .

Meanwhile in the fourth embodiment although the explanation is given for the example of inserting an interface for monitoring only the substitution in the pointer variable p it is not the only possible case. Alternatively it is also possible to monitor the access to the other pointer variables p . For example it is also possible to monitor the access to the pointer variable p written as c p in the 11 th line in .

When the profile program has the program code illustrated in the first type dependency relationship information that is not yet changed due to the execution of the profile program is explained above with reference to . illustrates an example of the second type dependency relationship information that is output as a result of executing the profile program . The dependency relationship is analyzed regarding each of the data a the data b and the data c in the first type dependency relationship information and dependency graphs and respectively are obtained. Meanwhile illustrates an example in which the if statement that is written in the profile program illustrated in yields true .

In the profile program illustrated in the commands valid node VAR ID  NODE ID  and valid node VAR ID  NODE ID  that constitute the interface are executed and the unreliable access nodes identified by the identifiers VAR ID  NODE ID  and VAR ID  NODE ID  are changed to reliable access nodes. Meanwhile if a node specified in an argument is already changed to a reliable access node no operation is performed in response to the command valid node .

In the third embodiment described earlier the interface inserting unit analyzes the parallel program A for generating and inserting the relationship information. Alternatively as described in the fourth embodiment a sequential program can be configured to analyze the program code for generating and analyzing the relationship information.

As described above in contrast to the case when the task border information is not referred to and when the dependency existence information is updated regarding all unreliable access nodes including those unreliable access nodes which do not exert any influence on the task borders according to the fourth embodiment the dependency existence information is updated regarding only those unreliable access nodes which are linked to the task border edges. For that reason it becomes possible to curb updating overhead at runtime thereby enabling achieving reduction in the runtime overhead.

If the computer program is optimized by referring to the dependency relationship information in which the information during the execution is reflected it becomes possible to generate a computer program having superior performance. For example as the first type dependency relationship information of the parallelization apparatus according to the first embodiment it is possible to use the second type dependency relationship information that is output by the output unit in the analysis system according to the fourth embodiment. With that the unreliable access nodes can be changed to reliable access nodes by reflecting the information during the execution and the presentation information can be reduced. Along with that a decrease in the dependency existence information can also be expected. As a result the first type dependency relationship information can be converted into the second type dependency relationship information with fewer operations.

Explained below with reference to is a configuration that can be commonly implemented in the first to four embodiments. As illustrated in the information processing apparatus according to the first to fourth embodiments can be put to practice with for example a commonly used computer.

With reference to a CPU a random access memory RAM a read only memory ROM a display control unit and a communication interface I F are connected to a bus . In addition a hard disk drive HDD a drive device and an input I F are also connected to the bus .

The CPU follows instructions from computer programs stored in the ROM or the HDD and controls the entire computer while using the RAM as the work memory. The display control unit converts display control signals which are generated by the CPU into signals displayable on a display device and outputs those signals to the display device .

The HDD is used to store the computer programs executed by the CPU or to store the data referred to by the computer programs. The drive device can have a recording medium attached thereto in a detachable manner and is configured to perform reading and writing of data with respect to the recording medium . Herein the recording medium compatible to the drive device can be a disk recording medium such as a compact disk CD a digital versatile disk DVD or a flexible disk or can be a readable writable and nonvolatile semiconductor memory.

The input I F receives data from the outside. For example the input I F has a predetermined interface such as a universal serial bus USB or an IEEE1394 interface IEEE1394 stands for Institute of Electrical and Electronics Engineers 1394 through which data is received from an external device. To the input I F is connected an input device such as a keyboard or a mouse . For example in response to the display on the display device the user can operate the input device and issue instructions to the computer.

The communication interface communicates with an external communication network using a predetermined protocol.

Meanwhile with the computer programs running in the CPU it is possible to implement the functional blocks constituting the parallelization apparatus according to the first embodiment implement the functional blocks constituting the synchronization optimization apparatus according to the second embodiment implement the functional blocks constituting the parallelization system according to the third embodiment and implement the functional blocks constituting the analysis system according to the fourth embodiment. The computer programs for implementing the abovementioned embodiments can be provided in the form of installable or executable files on a computer readable recording medium such as a compact disk read only memory CD ROM a flexible disk or a DVD. Alternatively computer programs for implementing a program parallelization system can be stored in advance in the ROM .

Still alternatively the computer programs for implementing the abovementioned embodiments can be saved on a computer connected to a network and downloaded from that computer via the network. Moreover the computer programs for implementing the program parallelization system can be made available for distribution through the network such as the Internet.

Herein the computer programs for implementing the abovementioned embodiments contain units for implementing the functions of the abovementioned constituent elements for example with reference to the first embodiment the input unit the analyzing unit the generating unit the instructing unit the converting unit and the parallelizing unit . Regarding the actual hardware the CPU retrieves the computer programs from for example the HDD and runs them so that the computer programs are loaded in the RAM . As a result the functions of the abovementioned constituent elements are implemented in the RAM .

Meanwhile in the embodiments described above it is only a single computer in which the functional blocks of the apparatus or the system according to the embodiments are implemented. However that is not the only possible case. Alternatively for example one or more of the functional blocks can be implemented in a different computer. In that case the communication of data between the functional blocks can be performed using the recording medium or via the network.

While certain embodiments have been described these embodiments have been presented by way of example only and are not intended to limit the scope of the inventions. Indeed the novel embodiments described herein may be embodied in a variety of other forms furthermore various omissions substitutions and changes in the form of the embodiments described herein may be made without departing from the spirit of the inventions. The accompanying claims and their equivalents are intended to cover such forms or modifications as would fall within the scope and spirit of the inventions.

