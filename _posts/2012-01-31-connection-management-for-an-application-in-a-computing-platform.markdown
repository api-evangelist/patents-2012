---

title: Connection management for an application in a computing platform
abstract: A computing device detects an event generated by a first component that publishes a connection endpoint, the event indicating that the connection endpoint of the first component has been modified. The computing device determines a second component that subscribes to the connection endpoint. The computing device updates a location of the connection endpoint in a data structure associated with the second component to maintain a connection between the first component and the second component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262238&OS=09262238&RS=09262238
owner: Red Hat, Inc.
number: 09262238
owner_city: Raleigh
owner_country: US
publication_date: 20120131
---
Embodiments of the present invention relate to managing an application and its execution environment and more specifically to automatically configuring an application and support components and to automatically deploying the application and its support components. Some embodiments of the present invention relate to a flexible computing platform that is configured to be a platform as a service PaaS .

Most web applications typically implement multiple layers of functionality to operate. For example a common web application may use a database layer an application server layer and the actual web application layer. Components within each of these layers may have their own resource preferences dependencies and so forth. Additionally these components may operate on a single machine or may operate on different machines. In traditional computing platforms to launch a new application an administrator writes application code selects support components determines nodes that the application and components will run on installs the application and components on the nodes and configures the application and components to work with each other. To launch an application using traditional computing platforms accordingly may be time consuming and prone to error. Moreover when services relied upon by the application change the administrator typically manually reconfigures the application and its support components to account for such changes.

Described herein are methods and systems for automatically configuring deploying and managing an application in a computing platform. An application also referred to as a program may depend on several support components. Embodiments of the present invention provide a computing platform also referred to herein as a runtime environment or simply as a platform that provides these support components. The application may be received by the computing platform along with an application descriptor. The application descriptor may have minimal or extensive information for configuring and deploying the application in the platform. For example the application descriptor may include identification of one or more capabilities that will be used by of the application e.g. PHP MySQL Mongo etc. with no other information. Alternatively the application descriptor may specify particular configuration details such as a particular MySQL component and configuration to use specific nodes that the application and its support components are to run on specific connections to establish between components and so forth. The application and application descriptor may be received with no additional information and may be used to automatically set up and execute a distributed application that includes the received application and one or more support components that the application will use.

The computing platform uses the application descriptor to configure and deploy the application. Configuring the application may include identifying components for the platform that provide specified capabilities to the application and configuring the application and the identified components. Configuring and or deploying the application may additionally or alternatively include determining nodes to install the application and components on installing the application and or some components on a first node or nodes and installing the application and or other components on a second node or nodes . Configuring and or deploying the application may additionally include establishing connections between components and or the application. In one embodiment the platform manages connections between components and or the application using a publish subscribe model. Components and or the application may publish connection endpoints and other components and or the application may subscribe to those connection endpoints. When a connection endpoint is modified the platform may automatically update the subscribers to that connection endpoint to maintain connections.

For conventional hosted applications such as web applications designing configuring deploying and maintaining the application can be quite complex. Accordingly application providers typically invest considerable resources into manually developing configuring and deploying such applications. Often the application deployment is sufficient for a current version of an application but will not work for a next version of the application or will not work if parameters deviate from assumptions. Embodiments of the present invention provide a platform execution environment that automatically handles the configuring deploying managing scaling etc. of an application including its support components . The platform can take user provided application code and set up an entire distributed application based on the provided code and a provided application descriptor with no additional user input. The platform can additionally adapt to changing demands and input parameters to continually provide an optimal configuration and deployment for an application and support components of the application. This enables the application provider to focus efforts on the business logic of the application without having to worry about any of the underlying infrastructure.

Note that a multi tenant architecture may be used instead of or in addition to a virtualization architecture. A multi tenant architecture provides a software application that is designed to virtually partition its data and configuration and provide a customized virtual application instance to different clients. In a multi tenancy environment multiple customers may share the same application running on the same operating system on the same hardware or virtual machine and or with the same data storage mechanism. A multi tenant architecture may be combined with virtualization to provide insulating facilities that support one or multiple levels of multi tenancy. For example each virtual machine may host an application that provides a multi tenant application. If a multi tenant platform or environment is used in addition to virtual machines then parts of virtual machines may be arranged into a cluster or clusters as well as entire virtual machines. For the sake of clarity the example of virtual machines will be discussed herein. However it should be understood that the principles discussed herein may also be applied to multi tenant architectures.

Clients and are connected to hosts and the cloud provider system via a network which may be may be a private network e.g. a local area network LAN a wide area network WAN intranet or other similar private networks a public network e.g. the Internet or a combination thereof. Each client may be a mobile device a personal digital assistant PDA a laptop a desktop computer or any other computing device. Each host may be a server computer system a desktop computer or any other computing device. The cloud provider system may include one or more machines such as server computers desktop computers etc.

In one embodiment the cloud provider system is coupled to a cloud controller via the network . The cloud controller may reside on one or more machines e.g. server computers desktop computers etc. and may manage the execution of applications in the cloud . In one embodiment the cloud controller provides platform packages associated with different applications to the cloud provider . A platform package is a pre generated image containing code for a platform that can be provided to the cloud provider and stored in an image repository . This image may be a virtual machine image or an image of a physical system. The platform package may provide a complete computing platform on which application code and or code for support components can run. The platform may provide an infrastructure that enables applications and support components to communicate scale backup use shared or distributed file systems and so forth. This computing platform may be provided to clients in a platform as a service PaaS model.

Upon receiving a command identifying a specific platform package the cloud provider may retrieve the corresponding image from the image repository create an instance of it and load it on the host to run on top of a hypervisor not shown . The command may be received from the cloud controller or a user e.g. a system administrator via a console computer or a client machine. The hosts may execute the platform package to provide a computing platform on which applications can run.

The image repository may reside locally or remotely and may represent a single data structure or multiple data structures databases repositories files etc. residing on one or more mass storage devices such as magnetic or optical storage based disks solid state drives SSDs or hard drives. In addition to storing platform packages the image repository may also store application packages and or support component packages which may be loaded onto a host and run on a hypervisor in a similar manner as the platform packages. The cloud provider or the cloud controller may also load an application package on the host to run on top of the platform package or on top of a component package. Additionally application packages and or component packages may be stored in one or more other repositories not shown residing locally or remotely instead of or in addition to the image repository .

As used herein a component package is a reusable software package that can run on the platform. A component is a smallest unit of encapsulated code that is usable on the platform. Component packages may include executable code that provides a capability such as a service or may include instructions for accessing one or more underlying capabilities of the platform e.g. services such as a distributed file system . A component may declare inputs and outputs and a capability or capabilities of the component. These inputs and outputs may be exposed as connectors that can be connected to for providing inputs into the component and or for receiving outputs from the component. A component can be used e.g. by an application without any knowledge of what is inside the component or how it works. Accordingly a component package may be developed independent of any specific application package. Examples of component packages include component packages that provide a PHP functionality a Java runtime functionality a MySQL master capability a MySQL slave capability a read capability a write capability and so on. A component may have multiple different profiles each of which provide a different mode of operation for the component.

One example of support component packages are cartridges. Cartridges are component packages that include one or multiple support components along with additional information identifying abstract features provided by the support components. Cartridges may share a similar construction such that cartridges can be loaded and unloaded from the platform core during execution in accordance with needs of the application or other installed components. A cartridge can expose one or multiple different components for use by other components and or by applications. One cartridge may include multiple components and provide multiple capabilities. Additionally the same capability may be exposed by multiple different cartridges. For example a PHP capability may be exposed by a PHP cartridge and by a Zend Server cartridge.

In one embodiment cartridges include one or multiple profiles each of which may cause the cartridge to run in a particular mode of operation. Each profile provides a different base configuration for deploying a cartridge. Different profiles for a cartridge may enable different support components included in that cartridge may specify functional and or resource requirements of the cartridge and so forth. A profile may internally cause components to instantiate and connect together to provide a specific capability or capabilities. For example a first profile for a MySQL cartridge may cause the cartridge to run in a single server mode and a second profile for the My SQL cartridge may cause the cartridge to run in a master slave mode with a single master and multiple slaves. In the second example the profile may cause the master node and the slave nodes to be instantiated and then connected together.

When an application is to be created for execution on the platform e.g. on hosts a client may provide application code e.g. an application package to cloud provider system . In one embodiment the user provides the application code using an upload mechanism such as running the git push command. Alternatively the user may provide the application code for example using file transfer protocol ftp a representation state transfer REST application programming interface API etc. Cloud provider system may assign a virtual machine e.g. VM to the client. The virtual machine may then create an application container for the new application that will maintain state information for that application e.g. in an application descriptor runtime state . The application container may include a default application descriptor that may be edited by an administrator. Additionally the application container may be associated with an application name and or version number which may be provided by a user. In addition to creating the application container the virtual machine may create a repository and or directory for that application which may reside on the virtual machine. The application descriptor is a comprehensive metadata structure that can be used to describe how to connect components and applications how to duplicate components and applications ways to run components in different modes how to handle high availability scaling and or backup or any other feature of an application. The application descriptor is described in greater detail below with reference to .

The virtual machine may use the application descriptor to determine support components that will be used for the application and profiles of the support components to use. The virtual machine may configure the application and the support components and may determine a deployment arrangement for the application e.g. a number of node to use which components will run on which nodes etc. . The virtual machine may then cause additional virtual machines to be assigned to running the application and may cause the application and or components to be installed on those virtual machines. The virtual machines may start their components and the application may then be made available to clients .

The platform core may include a guest OS with a kernel distributed services a data transport data services monitors and or other functionality. Distributed services allow communication between nodes when the application runs on multiple nodes arranged in a cluster executing on one or more hypervisors in one or more hosts. Each node may include a separate instance of the platform or may include a different subset of the platform e.g. a specific component or components of the platform . Some embodiments of the platform core are described with reference to below.

The components form a layer or multiple layers that provides a variety of middleware framework and other support software for the application . In various embodiments the middleware framework components can include such components as Java Apache MySQL PHP JBoss and Tomcat .

Application includes an application package containing an application descriptor . The application descriptor may be a description of the architecture for a particular application and may include information that can be used to assemble the application . The application descriptor may include for example information on a configuration of application parts support components and or an underlying platform core. The application descriptor may specify capabilities that will be used by the application e.g. functional requirements of the application services to be relied upon by the application etc. . The application descriptor may additionally include or may rely on the platform to determine additional configuration and deployment parameters. For example the application descriptor may additionally include an instruction that a supplier of a capability is to communicate with suppliers of other capabilities. The application descriptor can provide detailed information for configuring the application or may include minimal information. The less information that is provided the more application relies on the platform to automatically choose an optimal configuration for the application . Accordingly the application descriptor may describe a multi tiered application on the cloud including flexible scaling flexible routing load balancing high availability clustering scaling etc.

In addition to the application descriptor the application package may include one or more application parts which may correspond to different individually deployable modules of the application . For example a first application part may include application code or logic and another application part may include static data that will be farmed out to a content delivery network. Application may be an n tiered web application based on languages such as Java Ruby Python PHP or the like. An application package may be provided by a user or created automatically based on information about the application that is provided by a user via a user interface or by other means.

The platform core and components may be provided by the PaaS provider. Components are not packaged with the application . Instead the application package expresses in the application descriptor a dependency on services also referred to herein as capabilities provided by components . The platform may then import the appropriate components at deployment time.

In one embodiment components include component descriptors that describe capabilities of the components as well as connectors also referred to as connection endpoints that identify ways of connecting to the components e.g. types of data that the component may receive address port and or protocol information that can be used to access the component types of data that the component outputs and so forth . The component descriptor may also define capabilities e.g. services that the component relies upon. The component descriptor may have a similar structure and include similar types of data to the application descriptor . For example a MySQL component may include a component descriptor that describes the component s MySQL capabilities and ways of accessing those MySQL capabilities.

The platform automates the process of configuring deploying and managing the application . The platform may parse the application descriptor to determine capabilities relied upon by the application . The platform may then identify components that can provide those capabilities and select components for providing those capabilities. Once components are selected for the application the platform may connect and configure those components and the application parts based on information included in the application descriptor and or the component descriptors . Accordingly the platform may be an application level dependency injection system in which individual components are built without any knowledge about other components or how to connect to them. The application and any component may declare what it needs and the platform my select and provide components that satisfy the declared needs.

The dependency injection may function at the application level without any regard to programming languages operating systems execution environments etc. used by any individual components. Accordingly the different components that run in the platform may be written in different programming languages may run in different memory spaces may run on different nodes may have separate runtimes etc. For example a MySQL component may not know how a Tomcat component connects to it and the Tomcat component may not know how to connect to the MySQL component. The MySQL component may publish three different connection endpoints e.g. that may each provide the same data but formatted in different ways . If the Tomcat component expects a particular connection e.g. a Java database connectivity JDBC connection it may specify that it can communicate via a JDBC connection. The platform may analyze the component descriptor of the Tomcat component and the component descriptor of the MySQL component and may match a JDBC connection of the MySQL component to the JDBC connection of the Tomcat component based on the connection endpoints that these components are both exposing. The platform may additionally start VMs for the application install components and or application parts on the various VMs and start the components and or application parts.

Note that the PaaS environment may also include external services that are external to the platform on which the application may depend. The platform may identify external services that are relied upon by the application and may connect application parts and or components to the external services .

Components may each provide support functionality capabilities used by the application and or by other components . Examples of components include a Java component a Tomcat component an Apache component a JBoss component a PHP component and a MySQL component . However many other types of components are also possible. Each component provides specific capabilities and may be associated with multiple profiles. Application may include an application descriptor that identifies specific capabilities that application will use to run. In one embodiment at least some components are provided by cartridges not shown . Components may also be built into the platform and or may be included in an application package.

The platform core provides a framework that enables components and the application to communicate with one another and that enables the platform instance to communicate with and form clusters with other platform instances running on other nodes. The platform core also includes functionality for configuring and deploying the application and components for managing the application and components and for scaling the numbers and types of platform instances. The platform core additionally includes a guest OS .

In one embodiment platform core includes a messaging manager that communicates with a cloud controller. When a node is to be instantiated the platform notifies messaging manager of the decision. Messaging manager then sends a message to the cloud controller to cause the cloud controller to communicate with the IaaS layer to provision a new node.

In one embodiment platform core includes a configuration manager . Configuration manager may parse the application descriptor to identify capabilities that the application will rely upon. The configuration manager may then identify those components that provide the specified capabilities and may load those components in the platform instance or in another platform instance that may communicate with platform instance . The configuration manager may also identify particular profiles to use for configuring the selected components. Additionally some of the components may specify additional capabilities that those components rely upon. If any such components will be loaded into platform instance then configuration manager may determine the additional capabilities that the components will rely upon and find additional components that will provide those capabilities. The configuration manager may then load those additional components into the platform instance or into another platform instance .

In one embodiment platform core includes a deployment manager . Deployment manager may determine a number of nodes to use for an application and may further determine which application parts and or components will run on those different nodes. Once new nodes are brought online deployment manager adds the new nodes to an appropriate cluster.

In one embodiment each VM includes the same platform instance and an instance of the application . Accordingly each machine runs an instance of all components provided to the application by the platform. Therefore when the system scales up the application a new VM includes a new copy of the application and all components .

In another embodiment different VMs include distinct platform instances. For example a first platform instance may include a Java component and host the application and a second platform instance may include a MySQL component . Deployment manager may group nodes that include the first platform instance into a first cluster and may group nodes that include the second platform instance into a second cluster. This first cluster and second cluster may further be arranged into a larger cluster. This division of the platform into multiple different platform instances which may communicate with one another increases the flexibility and level of control over the platform.

Components may include or be associated with a constraint or set of constraints . The constraints may specify minimum resources architecture specifications capabilities relied upon and or other preferences of the component. Examples of constraints include minimum processor power minimum number of processor cores minimum memory minimum bandwidth maximum allowed packet loss rate minimum security settings additional required components other components that cannot run with a component in a platform instance and so forth. Deployment manager may use the constraints to provision the virtual machine and or an underlying host.

In one embodiment deployment manager compares constraints of the components and application parts to each other. Based on the constraints deployment manager may determine a number of nodes to provision and which components will run on which nodes. Those components that are to run together on a node may be defined as a group. Deployment manager may also determine which nodes the application or application parts will be active on. Based on the constraints deployment manager may determine that some components and or the application are to be run on the same node. Alternatively deployment manager may determine that some components are to run on different nodes. Note that deployment manager may modify groups and relocate components and or applications dynamically as system preferences and or conditions change.

In one embodiment platform core includes a connection manager . As part of configuration configuration manager may determine how components and or application parts will communicate. Once connections communication channels are established connection manager may maintain those connections . The components can issue commands to request system information such as information about the architecture and packages installed and can further communicate with the platform and each other via communication channels such as the file system inter process communication IPC and a network.

Connection manager manages connections between components . Connection manager also manages connections between the application or application components and various components . Each component and the application or application component may expose one or multiple connection endpoints. Components or an application or application component that provides a connection endpoint may provide it as a subscription service. Any other component or application or application component may subscribe to that subscription service. For example a server may publish a network connection endpoint. Any client may then subscribe to that network connection endpoint to connect to the server. The connection manager sits in the middle and manages the connection between the endpoints. For example if one connection endpoint connection publisher moves then the connection manager may inform or update either actively or passively the other endpoints connection subscribers of the new address for the moved connection endpoint.

Connection manager may manage multiple different types of connections. One type of managed connection is a network connection which may include a network address and a port or network addresses and ports . The network connection may further include a protocol such as MySQL hypertext transport protocol HTTP transmission control protocol TCP user datagram protocol UDP real time streaming protocol RTSP real time transport protocol RTP etc. Another connection type is a connection via a file system. For example one endpoint may write a file or a library to a location in the file system and the other endpoint may read that file or library. As one endpoint moves around or begins using a different directory the connection manager can inform the other endpoint of the move or different directory. The connection manager may also manage in process connections such as loading of a shared object pipes inter process communications IPC shared memory connections and so on. All of these and other types of connections may be managed by connection manager using the publish subscribe system.

Note that components and or application may extend connection types by sending additional information than what is specified by the connection type. For example a MySQL component may extend a transmission control protocol internet protocol TCP IP connection type to send a username and password in addition to standard TCP IP information. The MySQL component may alternatively or additionally extend the TCP IP connection type to send a JDBC connection string in addition to the standard TCP IP information.

Components and application can trigger events such as threshold violations scaling events notification triggers state change events migration events transition events etc. These events can modify connection endpoints. Connection manager may receive such events and may determine components and or application parts that subscribe to a connection endpoint that generated the event. Connection manager may then reconfigure those subscribing components and or application parts to maintain their connection to the modified connection endpoint. For example a component may be a server that is resource constrained. Deployment manager may migrate the component to a new node that has additional resources. The component may generate a migration event to indicate that will be migrated or has been migrated to the new node. The connection manager may receive the migration event and update any components that subscribe to a connection endpoint of that component. These updates may be performed by modifying a portion of the application descriptor runtime state that relates to the subscribing components.

The deployment includes a collection of components and an application . The components and application communicate via a series of connections. In the illustrated example component communicates with component via connection . Component communicates with application via connection and with component via connection . Additionally application communicates with component via connection . Multiple different types of connections may be used such as network connections shared memory connections shared directory connections and so forth. Additionally two components or a component and the application may form multiple different types of connections between them. The application and or components may also form connections e.g. connection with an external component . The external component may be for example a web service utilized by the application . The connections enable components and the application to utilize services and functionality provided by other components.

The deployment includes a grouping . The grouping is an arrangement of components and application in the deployment into one or more provisioning groups . Grouping may also include policies . Each provisioning group may represent a tier of the application deployment . Each provisioning group may be a cluster of nodes that each include the same platform instance and thus that each includes the same component or components. In one embodiment each node in a provisioning group is identical to each other node in the provisioning group. For example all nodes in provisioning group may include a machine with four processor cores and 2 GB of RAM and may host a platform instance that includes component . A group may be formed by determining constraints of the different components and then resolving which components can run together on a node based on those constraints. In one embodiment the group is installed onto nodes in a first cluster group is installed onto nodes in a second cluster and the first cluster and second cluster together are arranged into a larger third cluster. In one example deployment provisioning group may be a web serving tier and component may be a web server. Provisioning group may be a second tier that includes an application server component application code that is deployed into that application server application and a database component . Note that multiple groups may run on a single node in some instances.

The deployment may include an application descriptor runtime state . The application descriptor runtime state may include all information describing the deployment . The application descriptor and component descriptors may be static metadata. The application descriptor runtime state may include initial information included in an application descriptor and in component descriptors . The application descriptor runtime state may additionally include runtime state configuration and deployment information. When the application is assembled and loaded into memory the application descriptor is expanded and loaded into memory as well. As the application and its components change the application descriptor runtime state keeps track of where each component is running which group is running on which nodes which components are in which nodes the addresses of nodes and of components running on those nodes how many nodes there are how components are connected when and how to scale groups etc. The application descriptor runtime state may additionally identify cartridges that are loaded which profiles the cartridges are running which components the cartridges are providing how many copies of cartridges are running the runtime resources that are being used and so on. The application descriptor runtime state may include information on all connections . If any connection is modified then the application descriptor runtime state may be updated to reflect that modification. A copy of the application descriptor runtime state may be maintained on each node hosting group and on each node hosting group .

At block processing logic determines whether the received application code has already been built or still needs to be compiled e.g. for a Java application or may exist uncompiled e.g. for a PHP application or other type of application . If the application code has not been built or compiled then it may be received along with an indication of a building or compiling capability that the application code will rely upon. This indication may be included in the application descriptor. If the application code has not been built or compiled the method continues to block . Otherwise the method proceeds to block .

At block processing logic selects a component that can provide the specified building or compiling capability e.g. a build tool or compiler that can build or compile the application code . Once the component is selected processing logic compiles or builds the application code using the selected component. The method then proceeds to block .

At block processing logic resolves capabilities specified in the application descriptor. Resolving the capabilities may include determining components and or cartridges that can provide the capabilities determining profiles to use for those components and or cartridges and loading those components and or cartridges using the selected profiles.

At block processing logic attempts to establish connections between the components and or application or application parts . This may include identifying which components and or applications should be connected together identifying communication mechanisms supported by components that are to be connected and then attempting to connect those components via the identified communication mechanisms. Processing logic may determine that a connection should be established between any component or application that relies upon a capability and a component that provides that capability. Additionally the application descriptor may include information specifying that components that provide some capabilities are to connect to components that provide other capabilities. For example processing logic may figure out which components are to be connected call the components providing the connection endpoints collect information from the components and provide the collected information to subscribing components. Note that some connections may not be established at this point and or some established connections may not yet be valid e.g. due to lack of information on specific IP addresses and ports e.g. for network connections memory addresses for shared memory space connections and so forth .

At block processing logic configures the application including all application parts and the components. Configuration may be the process of resolving variables for a component cartridge application or application part that is being configured. In one embodiment processing logic determines a configuration order for the application parts and or components. The configuration order may be based on dependencies between the components and or application parts. In one embodiment those components that depend on other components are started after the other components on which they depend. Therefore additional information on the other components from which they depend will be available when it comes time to configure the dependant components. Note that some components may be configured before those other components that they will depend on. For example a PHP cartridge may be configured before another component that it depends from and may push its configuration information down to those other components from which it depends. Those other components may then be configured using information passed along by the PHP cartridge.

In one embodiment configuration order is maintained in a dependency tree. Each node in the dependency tree may represent a component cartridge application or application part. Leaves of the dependency tree which do not depend on any of the components or applications may be configured first followed by nodes at a next level of the dependency tree and finally by a root or roots of the dependency tree.

Configuration may be a multi step process. Each component and application may come with a set of configuration files which may be written into an application descriptor runtime state. The configuration files may include variable place holders. At block processing logic may update place holder values associated with a configured component or components with runtime values. These variable place holders may be replaced with runtime state information as configuration commences. Examples of variable place holders include environment variables such as place holders for log file locations port numbers IP addresses node identifiers etc.

After a component cartridge application or application part is configured and the placeholder values have been replaced with runtime values at block processing logic may reattempt to establish connections between components and or the application. Since place holder values have been replaced with runtime values some connections that were not previously valid or established can now be set up or updated.

At block processing logic determines nodes to which the application and components will be deployed and deploys the components or cartridges and application or application components to the designated nodes. The assignment of components to nodes may be made based on constraints specified for those components. Note that processing logic may set up multiple different nodes in a cluster each of which may run different components and perform different tasks. Processing logic may determine which components to deploy where in an automated fashion without an administrator having to manually specify which components will be started where. At this point the application is created and deployed but stopped.

At block processing logic may then start the components and application in a start order. The start may be performed in response to receiving a start instruction. The start order may be determined based on dependencies between components and or the application. In one embodiment the start order is the same as the configuration order. Alternatively the start order may vary from the configuration order. In one embodiment the start order is determined based on a dependency tree.

Not all place holder values may be replaced with runtime data at the time of configuration. Some such place holder values may not be replaced until a component has started. Accordingly at block processing logic may update some placeholder values with runtime state information. At block processing logic again reattempts to establish connections between the components and or the application. Some connections may not be set up until the dependant and dependee have both been started and place holder values have been replaced with runtime state information generated after the components have started . Such connections may be set up at this time. The application is then up and running.

Note that there may be two different levels for application creation. Application creation may be performed at a cluster level and at a node level. At the cluster level creating the application may include creating an application container that maintains state information for the application and all its components. When an application container is created at a cluster level processing logic will additionally create at least one node level application object associated with the cluster level application container. The node level application object may create local users that will be used to run the application. This may include setting up security policies to ensure that the application is isolated from other applications. Processing logic may additionally assign the node level application object a range of internet protocol IP addresses so avoid any conflict of IP addresses and or ports between multiple applications running on the same nodes. The node level application object may additionally include a repository created by processing logic to provide source code management on that node.

At block processing logic determines whether the application descriptor specifies particular components cartridges and or profiles. If so the method continues to block . Otherwise the method proceeds to block .

At block processing logic identifies capabilities to be used by the application based on the application descriptor. At block processing logic determines a component or cartridge that can provide one of the identified capabilities based on the component descriptor. At block processing logic determines a communication mechanism supported by the application and by the component. This may include determining connection endpoints of the application and endpoint and identifying connection endpoints that share the same type e.g. network connection an inter process connection a file system connection etc. and protocol. At block processing logic configures the application an the component to communicate via the communication mechanism. Note that at block processing logic may additionally or alternatively determine a communication mechanism supported by two components or cartridges and at block processing logic may configure the two applications to communicate via that communication mechanism.

At block processing logic determines whether the application will use any additional capabilities that have not been resolved for which components or cartridges that provide the capabilities have not been set up . If so the method returns to block . Otherwise the method continues to block .

At block processing logic configures the application and its components for execution on a computing platform. This may include updating a runtime state of the application descriptor based on the component descriptors of the determined components block . Such updating may include copying information from the component descriptors into the application descriptor runtime state for example. The method then ends.

The application descriptor runtime state allows that among several components if multiple components share a dependency to a sub component that subcomponent can provide capabilities to the multiple components. Accordingly at block processing logic determines whether a single instance of the second component can be used by both the application and the first component. If so the method continues to block . Otherwise the method proceeds to block .

At block processing logic suggests and or designates a single instance of the second component to be shared by the first component and by the application. Accordingly a single instance of the second component may be run which may conserve resources.

At block if a single instance of the second component cannot provide a capability to both the application and the first component then processing logic designates two separate instances of the second component to be run. This may occur for example if the application relies on a cartridge running a first profile and the first component relies on the same cartridge but running a second profile.

At block processing logic determines a configuration order for the application first component and second component based on dependencies. Those components that do not depend on any other components may be started first followed by those components and or the application that depends on them. At block processing logic configures the application the first component and the second component in the configuration order. The method then ends.

At block processing logic determines one or more groups for the application and the components. Processing logic may determine the groups based on resource requirements and or other constraints of the application and the components. For example the constraints may specify that a first component and a second component are to run on separate nodes. The constraints may also specify that the first component and a third component are to run on the same node.

At block processing logic determines an amount of resources that should be provided to the groups. At block processing logic determines resources of available nodes that can be provisioned. The available nodes may be virtual machines that can be brought online with specified resource parameters e.g. specified amounts of memory processing power network bandwidth etc. .

At block processing logic determines whether the application and all components can run on a single node. If so the method continues to block and processing logic assigns all groups to that node. Otherwise the method continues to block and processing logic assigns the first group to run on a first node of the computing platform. At block processing logic assigns the second group to run on a second node of the computing platform. At block processing logic installs the groups on the specified nodes. Subsequently at block processing logic may determine a start order for the components and the application. A different start order may be determined for each node. Additionally a cluster wide start order may be determined. For example a first component may be started on a first node followed by a second component on a second node followed by the application on the first node. At block processing logic starts the components on the nodes in the start order. The method then ends.

At block for each connection processing logic identifies a first endpoint of the connection as a publisher of the connection and a second endpoint of the connection as a subscribed of the connection. Processing logic may additionally identify the second endpoint as a publisher of the connection and the first endpoint as a subscriber of the connection.

At block processing logic monitors endpoint parameters of the first endpoint and or the second endpoint for each connection. The nature of the endpoint parameters may depend on the type of connection. For example endpoint parameters for a network connection may include an network address and port number. At block processing logic determines whether the parameters of the first endpoint has changed. Processing logic may also determine whether the parameters of the second endpoint has changed. If the parameters of the first endpoint have changed the method continues to block and the processing logic updates the second endpoint that subscribes to the connection with the changed parameters. If an address of the second endpoint has changed the method continues to block and processing logic updates the first endpoint that subscribes to the connection with the changed parameters. If the first endpoint s parameters and or second endpoint s parameters have not changed the method ends.

At block processing logic installs the application update to nodes one at a time and performs a rolling restart of the nodes. This may include stopping one node updating the application code for that node and restarting that node and then repeating this process on a next node. This process may be performed one node at a time until all nodes have been updated.

At block processing logic stops the application and components on all nodes. The application and components may be stopped in a stop order which may be based on dependencies between the components and application. The stop order may be a reverse of a start order that may have been used to start the application and components.

At block processing logic reconfigures the application and its components. In one embodiment processing logic performs any of methods for the reconfiguration. In one embodiment at block processing logic determines whether any connections are to be changed. If so processing logic continues to block . Otherwise the method proceeds to block .

At block processing logic unsubscribes a component or components to a first published subscription endpoint. At block processing logic then subscribes those components to a second published endpoint or endpoints. This process may be performed for multiple different connection endpoints.

At block processing logic determines whether any groups are to be changed or relocated based on the update. If so the method continues to block . Otherwise the method proceeds to block . At block processing logic migrates one or more components or the application from one node to another node. At block processing logic restarts the application and the components in a start order. The method then ends.

The exemplary computer system includes a processing device a main memory e.g. read only memory ROM flash memory dynamic random access memory DRAM such as synchronous DRAM SDRAM or DRAM RDRAM etc. a static memory e.g. flash memory static random access memory SRAM etc. and a secondary memory e.g. a data storage device in the form of a drive unit which may include fixed or removable computer readable storage medium which communicate with each other via a bus .

Processing device represents one or more general purpose processing devices such as a microprocessor central processing unit or the like. More particularly the processing device may be a complex instruction set computing CISC microprocessor reduced instruction set computing RISC microprocessor very long instruction word VLIW microprocessor processor implementing other instruction sets or processors implementing a combination of instruction sets. Processing device may also be one or more special purpose processing devices such as an application specific integrated circuit ASIC a field programmable gate array FPGA a digital signal processor DSP network processor or the like. Processing device is configured to execute the instructions for performing the operations and steps discussed herein.

The computer system may further include a network interface device . The computer system also may include a video display unit e.g. a liquid crystal display LCD or a cathode ray tube CRT connected to the computer system through a graphics port and graphics chipset an alphanumeric input device e.g. a keyboard a cursor control device e.g. a mouse and a signal generation device e.g. a speaker .

The secondary memory may include a machine readable storage medium or more specifically a computer readable storage medium on which is stored one or more sets of instructions embodying any one or more of the methodologies or functions described herein. In one embodiment the instructions include instructions for one or more modules of a platform core . The instructions may also reside completely or at least partially within the main memory and or within the processing device during execution thereof by the computer system the main memory and the processing device also constituting machine readable storage media.

The computer readable storage medium may also be used to store the instructions persistently. While the computer readable storage medium is shown in an exemplary embodiment to be a single medium the term computer readable storage medium should be taken to include a single medium or multiple media e.g. a centralized or distributed database and or associated caches and servers that store the one or more sets of instructions. The term computer readable storage medium shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine and that cause the machine to perform any one or more of the methodologies of the present invention. The term computer readable storage medium shall accordingly be taken to include but not be limited to solid state memories and optical and magnetic media.

The instructions components and other features described herein can be implemented as discrete hardware components or integrated in the functionality of hardware components such as ASICS FPGAs DSPs or similar devices. In addition the instructions can be implemented as firmware or functional circuitry within hardware devices. Further the instructions can be implemented in any combination hardware devices and software components.

In the above description numerous details are set forth. It will be apparent however to one skilled in the art that the present invention may be practiced without these specific details. In some instances well known structures and devices are shown in block diagram form rather than in detail in order to avoid obscuring the present invention.

Some portions of the detailed description which follows are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here and generally conceived to be a self consistent sequence of steps leading to a result. The steps are those requiring physical manipulations of physical quantities. Usually these quantities may take the form of electrical or magnetic signals capable of being stored transferred combined compared and otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to these signals as bits values elements symbols characters terms numbers or the like.

It should be borne in mind however that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout the description discussions utilizing terms such as receiving determining updating subscribing configuring installing storing accessing or the like refer to the actions and processes of a computer system or similar electronic computing device that manipulates and transforms data represented as physical e.g. electronic quantities within the computer system s registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage transmission or display devices.

Thus a method and apparatus for automatically establishing a support environment for a program is described. It is to be understood that the above description is intended to be illustrative and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. The scope of the invention should therefore be determined with reference to the appended claims along with the full scope of equivalents to which such claims are entitled.

