---

title: Software bus
abstract: The present invention relates to the field of methods of communication between software modules and more particularly software buses. There is described a software bus which allows communication between software modules. This communication occurs within a machine and between machines and operates interchangeably for the software module whether one is dealing with a process, a thread or a simple task. The communication relies on mechanisms adapted to the multitask level at which the sender and receiver software modules operate. It is based on a hierarchical architecture, phases of discovery and of recording of the various software modules having to communicate via the bus.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09052951&OS=09052951&RS=09052951
owner: SAGEMCOM BROADBAND SAS
number: 09052951
owner_city: Rueil-Malmaison
owner_country: FR
publication_date: 20121214
---
The present invention is concerned with the field of methods for communication between software modules and more particularly software buses.

Information processing devices work under the control of an operating system. These operating systems are multitask and enable the scheduling of a plurality of software modules. These software modules may be of several types according to the scheduler that organises the multitasking and the possibilities of a hierarchy of modules.

Historically operating systems enable the scheduling of processes. A process is defined as a software module having its own control and its own memory space. The scheduling of processes is typically performed today in a pre emptive manner. That is to say the scheduler decides in an arbitrary fashion on the times to switch context between the processes. The context of the current process typically the content of memory caches the content of the processor registers and the pointer instructing the control is then saved. Another process that is waiting is selected and the context thereof is restored. It can then continue its execution.

Context switching is a relatively complex process. The need to drive lighter parallel software modules has arisen. The concept of threads has therefore been created. Typically a set of threads is scheduled in a common memory space it is generally a case of one process.

In some cases it is possible to implement a supplementary level and to schedule a set of tasks actually within a thread. The scheduling may then be pre emptive or not. The other scheduling family cooperate scheduling takes place at the time of specific system calls where the task passes control explicitly to the scheduler. The main difference relates to the fact that in such scheduling a task entering an infinite loop may prevent the system from taking over and block the complete system. The advantage being that since a task cannot be interrupted at any time it is not necessary to protect the resources shared by mutual exclusion mutex mechanisms.

We shall therefore consider the software executed on an information processing device as one or more processes each process being able itself to consist of one or more threads each thread being able to consist of one or more tasks. The scheduling of the processes and threads will be considered to be pre emptive while the scheduling of the tasks may be pre emptive or not. We generically use the term software module to designate all these processes threads and tasks.

This hierarchy of software modules is illustrated by . An information processing device . can be seen therein. This device enables three processes . . and . to be executed in parallel. These processes are scheduled by the operating system .. The process . contains several threads . . . and . executed in parallel scheduled by the operating system .. The process . does not contain any threads. The process . contains a first thread . and a second thread .. This second thread . itself contains several tasks . . and . executed in parallel under the control of a scheduler . itself executed within the thread .. The device has at least one communication port . affording communication with other devices via a communication network typically an IP network.

When it is sought to make software modules communicate solutions dedicated to a given level of parallelism are found in the prior art. The main technologies are dedicated to communication between processes. Message queues UNIX sockets for communication between processes of the same device and INET sockets for communication between processes situated on remote devices connected to an IP Internet Protocol network can be cited. Software buses exist such as the D Bus which is a system for communication between processes. It is not suitable for software modules neither such as simple tasks nor for threads nor for communication between machines.

The invention aims to propose a communication system or software bus that affords communication between software modules. This communication occurs in a machine and between machines and indifferently functions for the software module whether it is a case of a process a thread or a simple task. The communication is based on mechanisms adapted to the multitask level at which the sender and receiver software modules operate. It is based on a hierarchical architecture phases of discovery and of recording of the various software modules having to communicate via the bus.

Advantageously the means for seeking the process on which said second task depends consist of bus management modules associated with each process each of said bus management modules comprising a routing table listing the tasks and the threads of said process on which they depend.

Advantageously the means for transmitting a message between said relay task and said distant relay task consists for each process of an inter process communication module hosted by a thread of said process.

Advantageously said information processing device comprises means for initialising one of said processes as the master process and the other processes as slave processes. The master process comprises an inter device communication module hosted by a thread of said process so as to be able to transmit a message between a relay task of said device and a distant relay task hosted on another information processing device.

The invention also concerns a method for exchanging messages between tasks running on one or two information processing devices as just described. The method is characterised in that in order to transmit a message from a first task to a second task it comprises 

According to another advantageous feature of the invention said method comprises the following steps of initialising said bus 

According to another advantageous feature of the invention said initialisation steps further comprise a step of creating in the master process as many relay tasks as there are client tasks of the bus in the slave process in the device.

According to another advantageous feature of the invention the client tasks of the bus are recorded with a public or private mode only the public tasks are exported to the master process.

According to another advantageous feature of the invention said method also comprises a step of discovery between machines participating in the bus. Said step of discovery between machines participating in the bus comprises for example 

In the process . a thread . is found intended for managing the bus for the process. The thread . is a client process of the bus. On the other hand the thread . is not a direct client of the bus. It hosts a bus management module . internal to the thread and one or more tasks . . and .. It is then these tasks that are the clients of the bus. These tasks are scheduled within the thread . by an ad hoc scheduler which may be merged with the bus management module . or not.

The software is then divided into processes . .. Each process contains a management module of the bus . .. It also hosts one or more client software modules of the bus . . . and .. These clients of the bus may be threads or tasks executed directly within the process. These clients may also comprise tasks . . and . executed within a thread. The thread then also hosts a management module of the bus ..

The phase of initialisation of the bus in a machine takes place in the following manner illustrated by . The client software modules that are to communicate with the bus are distributed within one of more processes. One of these processes is elected master process. The other processes if there are any are therefore slave processes.

During a step . the management modules of the bus of the slave processes establish a connection link with the management module of the bus of the master process. Typically this connection link is a UNIX socket.

During a step . each client software module of the bus is registered with the latter. This registration takes place with the management module of the bus of the process or of the thread on which the client software module depends. Advantageously this registration comprises the name of the software module reference to the management module of the bus on which said client software module depends as well as a visibility mode. The visibility mode comprises a private mode in which the client software module of the bus can send a message to other public clients and receive a response relating thereto on the bus but not receive direct messages from the other public clients. It also comprises a public mode in which the client software module of the bus makes public its name and its location and can therefore receive messages in addition to sending them.

During step . for each client software module of the bus that is registered the management module of the bus creates an FIFO First In First Out used in the case of an exchange on the same management module of the bus. These FIFOs may be simple FIFOs that is to say not protected by a mutual exclusion if the sequencing of the management module of the bus and of the clients of the bus under its responsibility is cooperative. In the contrary case FIFOs protected by a mutual exclusion mechanism are used. Each management module of the bus has an FIFO used in the case of exchanges with a different management module of the bus for managing the receptions of messages relating to this client module.

During a step . the management module of the bus of a slave process that receives registrations of client software modules of the bus exports these registrations to the management module of the bus of the master process. This management module of the bus maintains a table referred to as a user routing table of the client software modules of the bus present on the machine. The users here being the client modules of the bus. Advantageously only the modules that are declared public are present in this table.

During a step . the management module of the bus of the master process initiates in the master process as many software modules as there are client software modules of the bus in the slave process in the device. These software modules are managed by the management module of the bus of the master process and are called relay proxy software modules. This step is optional. The relay processes may alternatively be created as required during message exchanges as will be described below.

This phase of initiation of the bus in the device therefore constitutes an internal discovery phase where the various processes in the device establish a communication with the process elected as master and where each client software module of the bus in the device is discovered by the management module of the bus of the master process that maintains a table of all the clients of the bus in the device.

The initialisation of the bus advantageously also comprises a step of discovery between machines participating in the bus. This step is illustrated by the flow diagram in . It is implemented for each device by the management modules of the bus of the master processes.

During an announcement step . each device sends an announcement over the communication network connecting the devices. Advantageously this sending is made over the LAN links in broadcast mode on the sub network thereof and on the WAN links in multicast mode on a particular group. Advantageously this sending is repeated over time to enable new machines connecting to the bus to discover the existing machines. The announcement message advantageously contains the name of the machine as well as its IP address and a port for enabling an IP connection.

During a step . the device then checks whether the distant device from which it has received the announcement is known. Advantageously it maintains a table of known machines and it then suffices for it to check in this table whether an entry exists for this distant device.

If the device is already known there is nothing to do and looping is effected while awaiting the reception of another announcement message.

If the device is not known it is added to the table during a step .. An entry is created in the table of known machines which is shown with the name of the distant device its IP address and the port on which it can be joined.

During a step . a connection is established with this distant device. This connection may take the form of an INET socket dedicated to communication between machines. Advantageously two INET sockets are created one using the TCP Transmission Control Protocol dedicated to the exchanges of messages and another using the UDP User Datagram Protocol dedicated to signalling messages such as the announcement message.

At the end of this inter machine discovery phase the management modules of the bus of each master processor of each machine connected to the bus are all interconnected. At each machine all the distant machines are known and referenced. A communication link is established to each of these distant machines.

The exchange of messages between two client software modules of the bus uses the same programming interface API Application Programming Interface for access to the bus whatever the type of software module.

The exchange of messages between two client software modules of the bus that depend on the same management of the bus is illustrated by . In this case the two clients are typically tasks within the same thread.

During a step . the sender posts its message via the API of the bus specifying the name of the addressee.

During step . the management module of the bus perceives that the addressee forms part of its sphere for example by comparing the reference of the management module of the bus of the addressee with its own and posts the message in the simple FIFO thereof.

During step . the addressee recovers the message or messages that are intended for it by an operation of extracting the simple FIFO.

The exchange of messages between two client software modules of the bus that do not depend on the same management module of the bus but are stored within the same process is illustrated by .

During a step . the sender posts its message via the API of the bus specifying the name of the addressee.

During step . the management module of the bus perceives that the addressee does not form part of its sphere for example by comparing the reference of the management module of the bus of the addressee and its own and posts the message in the FIFO of the management module of the bus of the addressee.

During a step . the management module of the bus of the addressee extracts the message or messages present in its FIFO posting them in the FIFO of the addressee of said messages.

During a step . the addressee recovers the message or messages that are intended for it by means of an operation of extracting the FIFO.

Concerning the transmission of a message between a sender and a receiver formed by client software modules of the bus that are situated on different processes the transmission uses relay software modules. The bus then has means for initialising within each process a client software module of the bus managed by the bus and which serves as a relay of the distant software module. Thus a relay software module of the addressee is created within the process of the sender while a relay software module of the sender is created within the process of the addressee. These relay software modules are managed by the bus. Thus seen from the sender or the addressee the communication appears to be always internal to the process. The same primitives may be used by the client software modules of the bus. It is the bus that manages the interprocess communication via these relay software modules. These relay software modules also enable asynchronous functioning of the communications. This is because the sender posts its message with the relay software module of the addressee and can continue its processing. During this time the bus routes the message to the real addressee by means of an interprocess connection typically a UNIX socket.

Concerning this communication between processes it has been seen that on initialisation of the bus a communication link is established between the slave processes and the master process. On the other hand no link is created between the slave processes with each other. Consequently as required that is to say when the sender and the addressee are hosted by two slave processes a link is created typically a UNIX socket between the two slave processes.

The transmission process between a sender and an addressee hosted on different machines takes place exactly on the same scheme. It also involves a relay module of the sender within the process of the addressee and a relay module of the addressee within the process of the sender. A routing phase managed by the management modules of the bus of the master processes of the two machines enables a direct connection to be created between the two processes. The connection is here typically an INET socket.

During a first step . the client software module of the bus that wishes to send a message that is called the sender performs a routing step with the name of the addressee with the bus that is to say with the management module of the bus on which it depends.

During a step . when the bus perceives that the addressee is not hosted by the same process it creates the relay software module of this addressee within the process of the sender. In some embodiments this relay module may be pre existing for example within the master process if the relays were created during the initialisation phase see the optional step ..

During step . the message is then transmitted to this relay software module in accordance with the mechanism described for a transmission of messages within the process. If the communication is asynchronous the sender can then resume its processing.

During step . the bus will create as required the direct connection link with the process hosting the addressee. Several cases present themselves here. If the communication takes place within the same machine between a slave process and the master process the communication link already exists. A creation is unnecessary. If the communication takes place within the same machine between two slave processes the communication link must be created between the two slave processes typically in the form of a UNIX socket. If the communication takes place between two different machines the direct link must be created between the two processes typically in the form of an INET socket. This creation is negotiated by the master processes of the two machines which exchange the necessary addresses and ports.

During step . the bus creates a relay software module of the sender in the process hosting the addressee.

During step . the message is then transmitted between the two relays via the direct communication link established between the two processes.

A last step . then consists of transmitting the message via the interprocess mechanisms already described to the final addressee.

Advantageously the naming of the client software modules of the bus occurs in accordance with a scheme derived from the scheme used for URLs Uniform Resource Locators . According to the scheme the name of a module is broken down as follows ism name machine name module software where ISM is the name given to the protocol of the bus according to the invention. Within the same machine a relative naming reduced to name module software may be used.

Advantageously the various copies of the messages in the FIFOs within the same process are avoided. The message being copied once in a common memory space only one reference on this message is then exchanged. This limits actual copying.

As can be seen at the time in question this information processing device enables three processes . . and . to be executed in parallel. These three processes are scheduled by an operating system . of the information processing device .

The process . itself contains several threads . . and . which are executed in parallel while being scheduled by the operating system .. It also contains a management module of the bus of the same type as the process ..

The thread . contains system tasks namely a communication module of the interprocess type . enabling messages to be exchanged between processes as will be explained below as well as a communication module of the inter device type . for enabling messages to be exchanged between various information processing devices. The thread . contains two user tasks . and . as well as a bus management module of the thread . type including the proprietary scheduler not shown of all the tasks of the single thread . in this case the two tasks . and .. The thread . contains a user task . as well as a bus management module . of the thread type including the proprietary scheduler of the user task ..

The process . contains a thread . and a bus management module of the process . type. The thread . contains a user task . and a system task namely a communication module of the interprocess type . as well as a management module of the bus of the thread . type including the proprietary scheduler of all the tasks of the single thread . in this case the user task . and the communication module ..

The process . contains two threads . and . and a bus management module . of the process type. The thread . contains a user task . and a system task namely the communication module . of the interprocess type as well as a bus management module . of the thread type including the proprietary scheduler of all the tasks of the thread . namely the task . and the communication module .. As for the process . it comprises two user tasks . and . as well as a bus management module . of the thread type including the proprietary scheduler of all the tasks of the thread namely the tasks . and ..

It is noted that the scheduling architecture is hierarchical and thus comprises within the same process one or more threads itself including one or more tasks. Moreover the scheduling of the processes and threads will be considered to be pre emptive and performed by the operating system . of the information processing device. As for the scheduling of the tasks within a thread it will be considered to be pre emptive or not and performed by a proprietary scheduler that is to say dependent on said thread.

It will be noted that at another time this configuration may have changed because for example a task a thread or even a process has ended its execution or because a task has moved in a so called mobile mode from a thread to another thread of the same process or a different process.

Each management module of the bus of the thread type comprises a protected FIFO as well as FIFOs that are respectively dedicated to the user tasks of the corresponding thread. The function of these FIFOs is explained below. The FIFOs are not shown in in order not to burden this figure.

Each management module of the bus of the process type . . and . further contains a routing table . . . in which there are stored for each task its name and its reference to the FIFO in the management module of the bus of the corresponding thread type.

Each task has the possibility of sending and receiving command messages sending and receiving responses to command messages and sending and receiving notifications and sending and receiving responses on notification.

To send a command message a task calls a unique typical method for this type of message accepting as parameters the reference of the relevant task supplied during its registration within said relevant bus the names of the relevant bus and task optionally if the task requires a response a reference and a callback function prototyped by the bus for this type of response as well as the parameters necessary for executing the demand.

To receive a command message a task positions by means of a method disclosed by said bus for this type of command reception an event triggered function referred to as callback prototyped by said bus and a reference used for triggering this function.

To send a notification a task calls a unique typical method for the type of notification accepting as parameters the reference of the task concerned which is provided at the time of its registration in said bus optionally if the task requires a response a reference and callback function prototyped by the bus for this type of response as well as the parameters necessary for the notification.

Finally to receive a notification a task positions the name of the bus concerned and the name of the task concerned an event triggered function callback prototyped by said bus and a reference for triggering said function.

To send a message of response to a command message or to a notification a bus management module calls a unique typical method for this type of response accepting as parameters the reference of the message supplied by the call to the callback function pre assigned to the reception of said message and the parameters necessary for said function.

The various tasks the various threads and processes shown in belong to the same logic entity referred to as a software bus which is named by way of example bus

The invention uses a master slave hierarchical architecture only for the routing function. Thus within an information processing device a process is initialised in master mode and the other processes of the same device are initialised in slave mode. In the example of a configuration shown within the information processing device the process . is thus initialised in master mode and the processes . and . are initialised in slave mode.

It will be noted that several buses with different names including a master process and slave processes may coexist on the same information processing device.

The master process . has a communication module . of the interprocess type . of the master process . which is in a listening mode on a Unix socket called var run bus1 Master and the communication modules . and . of the interprocess type are in a connection mode to the Unix socket of the master process ..

It will be noted that in general the names of the buses of the master and slave processes are identical on the same information processing device but nothing prevents the contrary.

After connection between slave processes and master process and identification and authentication with access list the slave processes . and . have connections to the master process respectively on the ports .  and . . Each connection of the processes is recognised as a connection to the bus name in question in this case the bus bus1 .

For the process of routing the messages between tasks the invention uses a centralised hierarchical architecture whereas for exchanging messages between tasks it uses a distributed architecture. To illustrate these two features examples of implementation of message exchanges transmitted between tasks are given below.

It will thus be considered that within the information processing device and the same process whether it be master or slave a task wishes to send a message to another task forming part of the same thread. For example the task named . wishes to send a given message to the task named . forming part of the same thread .. The management module of the thread bus . takes charge of the message in question and asks the bus management module of the process type . for the route that the message should follow. Provided with its routing table . the bus management module of the process type . replies to it with the reference of the non protected FIFO dedicated to the task . hosted by the same management module of the thread bus .. Said management module of the thread bus . then posts said message in said FIFO and triggers a request for scheduling of this destination task .. Once this task has been scheduled the message is extracted from the FIFO and is taken into account by the task . by calling its event triggered function callback with the parameters contained in the message.

Let now consider a task which within the information processing device wishes to send a message to a task forming part of another thread but still of the same process. For example the task named . wishes to send a given message to the task named . forming part of another thread . but of the same process .. The management module of the thread bus . takes charge of the message in question and asks the bus management module of the process type . for the route to follow. The latter responds to it with the reference of the protected FIFO of the bus management module . of the thread type. Said bus management module . of the thread type then posts the message in said protection FIFO of the bus management module of the thread . and by a means made available by the operating system . makes a request for scheduling of the management module containing said FIFO namely the bus management module .. Once the bus management module . is scheduled the bus management module of the thread . extracts the message from the protected FIFO and then like the previous case makes a routing request to the bus management module . of the process and obtains from the latter a reference of a non protected FIFO for reception of the message by the destination task .. The bus management module . of the thread then posts the message in this FIFO and makes a request for scheduling of the destination task .. Once the task . is scheduled the message is extracted from the FIFO and is taken into account by the task . by calling its event triggered function callback with the parameters contained in the message.

It will be noted that if an FIFO is not empty at the time that a message is posted therein it is that the message or messages that it contains are not yet extracted. However this also means that the awakening of the corresponding thread has already been triggered. It will therefore be possible to awaken the thread in question only where the FIFO is empty.

It will also be noted that the routing process is routinely implemented in order to satisfy the mobile side of the user tasks. This is because even if the destination task has migrated before the extraction of the message from the protected FIFO the routing process enables the necessary rerouting.

Let now be consider that within the information processing device a task on a thread of a slave process wishes to send a message to another task hosted on a thread of the master process. For example the task . wishes to send a given message to the named task . hosted on the thread . of the process .. The bus management module of the thread type . takes charge of the message and asks the bus management module . of the process type for the route to follow for this message. The bus management module . now replies that the destination task . is unknown to it. It stores the message to be transmitted and sends a message of the distant task search message type as emanating from the local task . using the signalling connection . . The communication module . of the process . of the thread . receives on its connection .  the message of the distant task search type and informs the bus management module . of the process type which then looks in its routing table ..

In the routing table . of the bus management module . the destination task . is known to be resident on the thread .. According to the invention the bus management module of the process type . creates a distant relay task R. with the characteristics extracted from the search message on the same thread as the communication module that received this search message namely the thread . and sends to the management module . via the connection receiving the search message namely the connection .  in response to said search message a message of the add relay task type as emanating from the task . with the characteristics needed for creating a relay task. The communication module . of the process . of the thread . receives on its connection .  the message of the addition of remote task type and informs the bus management module of the process type .. The latter creates the relay task R. with the characteristics extracted from the message on the same thread as the communication module that received the message of the addition type in this case the thread . and enhances its routing table with this new task. There follows a search for the messages awaiting routing corresponding to this name. The corresponding messages are stored in the non protected FIFO dedicated to the destination task R..

The management module of the bus of the thread type . makes a demand for scheduling of this relay task R.. Once this task has been scheduled the bus management module . of the thread type serialises the message in the connection .  of the communication device .. The connection .  managed by the bus management module . of the thread type receives and deserialises the message. The management module . then performs all the operations already described for posting the message in the FIFO dedicated to the task . and if this FIFO is empty for making a scheduling demand. Once the task . has been scheduled the message is extracted from the FIFO and is taken into account by the task . by calling its event triggered function callback with the parameters contained in the message.

As will be understood the task . can communicate with the task . by means of the relay tasks R. of the thread . and R. of the thread ..

Let us consider again that in the information processing device a task of a slave process wishes to send a given message to another task that is now hosted on a thread of another slave process. For example the task . wishes to send a given message to the task named . hosted by the process . on the thread .. The bus management module . of the thread type . takes over the message and requests the bus management module . of the process type for the route to follow for the message. It replies to it that the destination task is unknown to it. It stores the message and sends a message of the remote task search type as emanating from the task . using the communication module of the interprocess type .. The communication module . of the master process . and of the thread . receives the message of the remote task search type on its signalling type connection .  and informs the management module of the bus of the process type . which looks in its routing table ..

In the latter the destination task . since it is not hosted by the master process . is not known. The bus management module . of the process type broadcasts this search message in all the connections that are established bearing the name of the relevant bus bus1 other than the one that saw said first search message passed that is to say in the connections bearing the name bus1 of the communication module . and . . Upon reception on its connection of this message of the remote task search type each communication module informs the bus management module of the process type on which it depends which looks in its routing table for the presence or not of the destination task sought.

Only the communication module . of the process . of the thread . has in its routing table . the relevant task . resident on the same process and on the same thread as it and advises the management module of the bus of the thread type . of this which creates on the same thread . as the communication module . that received the search message a relay task R. with the characteristics extracted from the search message enhances its routing table effects a search for a message awaiting routing as already explained above and transmits a message of the add remote relay task type as emanating from the task . with as its connection parameters the name of the Unix socket named var run bus1 Slave3.2 . The communication module . of the process . of the thread . receives the message of the add remote relay task type on its connection .  and propagates it to the connection .  from where the first search request came. The communication module . of the process . of the thread . receives in its turn the message of the add remote relay task type on its connection .  and informs the management module of the bus of the process type . of this.

The latter then creates on the same thread . that hosts the communication module . that received the message of the add remote relay task type . the relay task R. with the characteristics extracted from the search message and then enhances its routing table . with said relay task R.. Moreover it initialises a connection request with the information contained in said message of the add remote relay task type and then upon acceptance of the connection an identification and authentication phase with access list. There follows a search for messages awaiting routing corresponding to this name. The corresponding messages are stored in the non protected FIFO dedicated to the destination task R..

The bus management module of the thread type . makes a request for scheduling this relay task R.. Once the relay task R. is scheduled the bus management module . of the thread type serialises the message in the connection .  contained in the communication module .. The connection .  managed by the bus management module . receives and deserialises the message.

The management module . then performs all the operations already described for posting the message in the dedicated FIFO of the task . and if this FIFO is empty for making a scheduling request. Once the task . has been scheduled the message is extracted from the FIFO and taken into account by the task . by calling its event triggered function callback with the parameters contained in the message.

The latter operating mode can be extended to the exchange of messages between information processing devices the message of the add remote task type will then arrive through the inter device communication module . with the information of an INET socket of the ip port address type. In this case a serialisation deserialisation phase is necessary.

Let us consider that in the information processing device the task named . deregisters from the bus. The corresponding bus management module . of the thread type will release the FIFO resource the resource of the scheduler and the reference resource supplied at the time of registration. It also generates a remote task elimination message . to all the local tasks of all the threads of the process and to all the connections of the signalling type of the process by means of the communication module .. The connection .  of the communication device . receives this message and informs the bus management module . of the process type which checks whether it has corresponding remote relay tasks. If such is the case it will release them. If messages were awaiting acknowledgement these are reinserted in the FIFO awaiting a remote task search process a process that will therefore be initiated. The bus management module of the process type will also check whether connections of the data type are without a link to remote relay tasks. If such is the case it will release this connection and propagate the message over all these signalling connections other than the one from which the message came that is to say .  and .. The connection .  of the communication device . receives this message and informs the management module of the bus of the process type which checks whether it has corresponding remote relay tasks. If such is the case it will release them. If messages were awaiting acknowledgement these are reinserted in the FIFO awaiting a remote task search process a process that will therefore be initiated. The management module of the bus of the process type will also check whether connections of the data type are without any link to remote relay tasks. If such the case it will release this connection.

If in addition the task . is inserted in the thread . of the process . the routing table of the management module of the bus of the process type . is enhanced by this name. The result is a procedure for seeking waiting messages corresponding to this name. In addition the search messages corresponding to this name will be honoured.

In summary and in relation to in order to transmit a message from a first task . to a second task a message exchange method according to the invention comprises 

Thus as illustrated below the invention proposes a system for communicating between different tasks belonging to various threads themselves belonging to different processes said tasks being grouped together in the same entity or software bus or on the other hand belonging to different software buses.

In general this communication between tasks uses a client server mode of the command response type based on 1 to 1 or 1 to n messages and of the notification response type based on 1 to n messages. It uses a system of naming client tasks in accordance with a format. This communication can be done directly task to task or indirectly by interposed service such as a system of tasks producing command to service and then service to notification reader tasks. This communication takes place within the same processing device but may also occur between two information processing devices. In addition for this communication the task can be hosted and or move on a certain information processing device or a certain process or a certain thread.

The communication is based on the name of the bus and the name of the task on a hierarchical scheduling architecture on a centralised architecture for the routing function on a distributed architecture for the exchange of messages and on phases of discovery and registration deregistration of the various tasks on one or more bus names.

