---

title: Regenerating a user interface area
abstract: A user interface (UI) area having multiple data sources is regenerated based upon changes made to UI elements associated with the UI area. To efficiently regenerate the changed UI elements, a processor of the computer determines UI controls and data objects associated with the UI area to generate a conditional list. The conditional list includes corresponding events representing an association of the UI controls and the data objects. Based upon a modification to a data object, an optimized data binding structure is generated to determine a corresponding UI control that is affected by the modification. An updated UI controls list is computed to include the affected one or more UI controls based upon the optimized data binding structure. Based upon a trigger to render the UI area, the affected UIs are regenerated on the UI area by updating the affected UI controls based upon the modification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09015608&OS=09015608&RS=09015608
owner: SAP SE
number: 09015608
owner_city: Walldorf
owner_country: DE
publication_date: 20120716
---
The field generally relates to computer systems and software and more particularly to software methods and systems to regenerate user interface areas.

User interface UI technologies focus on interface technologies that support human computer interaction. UI technology research focuses on the enabling technologies that help computers hear see speak and to understand and combine these in multimodal ways. Rendering an entity on a UI includes generating a visual representation from a model by using computer programs. Updating the UI indicates that an already displayed visual representation is partially or completely refreshed.

Since the model associated with the UI includes enormous amount of information updating the UI partially or completely causes significant information exchange between a server hosting the model and the processor processing the update. Due to the amount of information exchange there may be an overhead caused on the processor including excessive or indirect computing time memory bandwidth and the like. Hence reducing the amount of data transfer and the overhead while maintaining accuracy in updating the UI is useful.

Various embodiments of systems and methods to regenerate a computer generated user interface UI area are disclosed. The UI area having multiple data sources is regenerated based upon changes made to UI elements associated with the UI area. UI elements associated with the UI area include UI controls and data objects. To efficiently regenerate the changed UI elements a processor of the computer determines UI controls and data objects associated with the UI area to generate a conditional list. Generating the conditional list includes determining events based upon a correlation between the data objects the UI controls and the UI area. The conditional list represents an association of the UI controls and the data objects by verifying whether the UI controls and the data objects reflect any modification performed on the data objects.

Based upon a modification to a data object an optimized data binding structure is generated to determine a corresponding UI control that is affected by the modification. The optimized data binding structure is generated by distinguishing between data bindings associated with data instances and data bindings associated with iterative data objects. An updated UI controls list is computed to include the affected one or more UI controls based upon the optimized data binding structure. If the modification is performed on a UI control the UI control is directly added to the UI controls list. Based upon a trigger to render the UI area the affected UIs are regenerated on the UI area by updating the affected UI controls based upon the modification.

These and other benefits and features of embodiments will be apparent upon consideration of the following detailed description of the embodiments thereof presented in connection with the following drawings.

Embodiments of techniques for systems and methods to regenerate a user interface area are disclosed herein. In the following description numerous specific details are set forth to provide a thorough understanding of the embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one of the one or more embodiments. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

Data objects are editable entities representing transitory compilations of attributes of a corresponding UI element. A path that is used to access this data object is called a binding. UI technologies use UI controls as an interface for application development and a renderer generates a corresponding markup fragment from the UI controls and its properties. Since the UI area has multiple data sources a mode of data access is specified for accessing the data rather than the actual value. While rendering the UI area the renderer decodes the specified access and determines the actual value. Thus the final UI is a result of the information from both the UI control and the corresponding bound data. When the bound data or the UI control is modified the UI area is correspondingly updated and regenerated.

To efficiently regenerate the modified UI elements thereby reducing the CPU usage and the amount of data exchanged an optimized regenerating process may be employed. Examples for optimizing the regeneration process include minimizing a quantity of regenerated UI elements by determining affected UI elements removing duplicates and existing elements maintaining threshold to determine a quantity of regeneration regenerating one or more parts of a UI element and the like. To regenerate the UI area with modified UI elements the UI controls and data objects associated with the UI area are determined to generate a conditional list. Generating the conditional list includes determining events based upon a correlation between the data objects the UI controls and the UI area. The conditional list represents an association of the UI controls and the data objects by verifying whether the UI controls and the data objects reflect any modification performed on the data objects. Based upon a modification to a data object an optimized data binding structure is generated to determine a corresponding UI control that is affected by the modification. An updated UI controls list is computed to include the affected one or more UI controls based upon the optimized data binding structure. Computing an updated UI controls list includes determining the affected one or more UI controls and compiling the UI controls to generate the list. If the modification is performed on a UI control the UI control is directly added to the UI controls list. Based upon a trigger to render the UI area the affected UI controls are regenerated on the UI area by updating the affected UI controls based upon the modification.

Computer system comprises a user interface UI area including UI elements and . The UI elements may have UI components depending upon the type of UI elements. For instance if UI element is a text box it includes field representing a name of the UI element and value representing the editable entity of the UI element. Similarly UI element includes value and UI element includes field and value . UI area is in communication with UI engine that represents a backend structure of UI area . UI engine includes UI control representing the UI controls associated with the UI elements e.g. and and data objects representing the data objects associated with editable entities e.g. and .

Database stores a relationship map of each of the UI elements corresponding fields and entities UI controls and data objects. The relationship map may be used to determine interdependencies between UI controls and data objects. Conditional list is generated by determining UI controls and data objects associated with a current instance of the UI area . Conditional list includes events which represent an association between the UI controls and the data objects. The association between each UI control and data object verifies whether the corresponding UI control or data object reflects any modifications performed on the data objects. For instance if the type of UI element is modified field and value may also be modified. However if the type of UI element is modified value may not be modified. The association verifies the status of the UI element by determining if the element reflects any modification performed on the data object. For example conditional list may include events that are triggered by each change in a UI element UI control and or data object . Conditional list is maintained in a manner to avoid duplication of event entries thereby not overloading the processor of the computer system. For instance if field is modified twice the latest modification is stored and is represented by a corresponding event.

The relationship between data objects and the UI area may include a complex mapping. In an embodiment the relationship between the UI elements and the data objects include a complex mapping. Complex mapping may also include immutable UI controls and restrict modification to an associated data. To accommodate complex mapping optimized data binding structure is generated based upon a modification to a data object. Optimized data binding structure is interpreted by detecting the affected UI controls from the modified data objects. The interpretation is accomplished by organizing the bindings between UI controls and data objects in a bi directional central data structure where the mapping can be realized via the data objects and via the UI controls.

The interpretation may also be accomplished by building a separate optimized data binding structure containing binding paths of the corresponding UI controls and data objects and the identification of UI controls that are affected due to the modification performed on one or more data objects. Thus optimized data binding structure includes a list of UI controls that are affected by the modification of one or more data objects. Optimized data binding structure is persisted until the bindings are changed and upon any changes to the bindings optimized data binding structure is updated. In an embodiment a relationship between the markup fragment of UI area and UI controls are also associated with optimized data binding structure .

In an embodiment the bindings may not specifically refer to a data object. For instance for a table with multiple rows each row may represent an instance of the data object and the corresponding binding path may represent the specific instance. For example the binding path may be represented as TABLE..FIELD and while rendering such a path the is replaced by an actual number of the row. For such cases optimized data binding structure includes a binding path of a corresponding instance of the UI control.

In another embodiment optimized data binding structure distinguishes between binding to a specific data instance of the data objects and binding to iterative data objects. For the specific data instance of the data object the data object can be used to trace the affected UI control. For iterative data objects the instances of the data object are traced to determine the affected UI control. This method of distinguishing between data bindings associated with data instance and data bindings associated with iterative data objects includes a lesser number of mappings when compared to the method of including a binding path for each instance.

An updated UI controls list is computed to include the affected UI controls based upon optimized data binding structure . Updated UI controls list includes a list of UI controls that are to be updated to regenerate on UI area . In an embodiment UI control specific business logic is included to notify one or more dependent UI controls based upon updating the affected UI controls. These dependencies may be represented as data bindings or evaluated by the business logic to determine the associated dependent UI controls and to compute updated UI controls list . Based upon a trigger to render the UI area the affected UI controls present in updated UI controls list are regenerated on UI area by updating contents of the affected UI controls based upon the modification.

In an embodiment a complexity of the affected UI controls is computed to determine a degree of regenerating of the UI controls on the UI area. The complexity of the affected UI controls includes an amount of modification a number of cross references or interdependencies of UI controls a number of UI controls affected or the like. A degree of regenerating represents a measure of data that needs to be regenerated on UI area . For instance in a UI segment containing twenty UI controls if seventeen UI controls are affected the whole UI segment may be regenerated instead of determining conditional list optimized data binding structure and updated UI controls list . In another embodiment a composite regenerating of the affected UI controls is executed based upon a degree of modification. For instance consider a UI segment made up of seven UI segment parts if one UI segment part is affected only the affected UI segment part may be regenerated instead of regenerating the entire UI segment.

In an embodiment computer system comprises a UI programming model including a user interface phase to receive the modification to data objects associated with UI area and to regenerate the affected UI controls based upon the modification an event handling phase to determine conditional list of corresponding events and based upon the modification to generate optimized data binding structure and a rendering phase to trigger a regenerating of the UI area by regenerating the affected UI controls based upon the modification. In an embodiment the regenerating of the affected updated UI controls from updated UI controls list is executed by consolidating the affected UI controls and regenerating them during the rendering phase instead of regenerating each affected UI control upon modification.

In an embodiment the UI programming model is configured to include a UI rendering framework to compute the updated UI controls list including the affected UI controls a server side framework to regenerate a markup page based upon the updated UI controls list and a client side framework to convert the markup page to an application protocol and transfer the application protocol to a corresponding client.

In an embodiment the UI controls include a feature of regenerating an attribute of the UI element instead of regenerating the entire UI element. Hence if the attribute of the UI element is affected the attribute is regenerated. For instance if a UI element has three attributes UI field name UI representation and UI value and if the attribute UI representation is affected then UI representation is regenerated.

In an embodiment a UI rendering framework is configured to compute the updated UI controls list which includes the UI controls that are affected by the modification. A server side framework regenerates a markup page based upon the updated UI controls list and a client side framework converts the markup page to an application protocol and transfers the application protocol to a corresponding client. In an embodiment a markup page is a collection of several markup fragments.

In an embodiment a threshold for the modification of the data objects is determined and based upon the threshold a degree of regeneration of the UI controls is determined and rendered on the computer generated UI area. Determining a threshold of the modification includes determining an amount of the modification of the data objects. Based upon the amount of the modification a degree of regeneration of the UI controls is determined. In an embodiment if the amount of modifications exceeds the threshold the entire UI may be regenerated instead of determining the modified UI controls. In an embodiment the UI area is rendered by delta rendering engine .

At process block a modification to one or more data objects is received. The modification may be received from the UI or an application associated with the UI. At process block based upon the modification an optimized data binding structure is generated to determine corresponding UI controls that are affected by the modification. The optimized data binding structure includes a list of UI controls that are affected by the modification to their corresponding data objects. At process block based upon the optimized data binding structure an updated UI controls list is computed that includes the affected UI controls. In an embodiment the modification may be received for a UI control. In such cases the modified UI control is directly included in the updated UI controls list. At process block the affected UI controls from the updated UI controls list are regenerated on the UI area by updating the affected UI controls based upon the modification.

A computer generated UI area interchangeably called a UI area throughout the specification in communication with UI engine displays one or more UI elements configured to be regenerated on the UI. In an embodiment to regenerate the UI area UI engine determines one or more UI controls and one or more data objects that are associated with the UI area. In an embodiment the data objects and the UI controls associated with the UI area are stored in database . Event handler generates a conditional list of one or more events representing an association of the corresponding UI controls and the data objects. These events represent an association of the corresponding UI controls and the data objects associated with the UI area. Processor recognizes one or more modification of one or more data objects. Based upon the modifications data binder generates an optimized data binding structure to determine corresponding one or more UI controls that are affected by the modification.

Delta rendering engine computes an updated UI controls list including the affected UI controls based upon the optimized data binding structure. Further delta rendering engine regenerates the affected UI controls on the UI area by updating the affected UI controls based upon the modification. Thus computer system is utilized to determine the UI controls that are affected by the modification and the UI area is updated to change the affected UI controls. In an embodiment the conditional list and the optimized data binding structure are stored in database . Based upon a modification associated with the data object the respective data is accessed from database to compute the updated UI controls list.

In an embodiment a server is associated with regenerating the UI area. The server hosts event handler and data binder . The server is configured to determine the UI controls and the data objects associated with the UI area. Based upon the determined UI controls and the data objects the server generates a conditional list of the corresponding events representing the UI controls that are correlated to the data objects. Upon receiving a modification in the data object the server generates the optimized data binding structure. From the structure the server determines the UI controls that are affected by the modification and assigns them to the updated UI controls list. Based upon a trigger received to render the UI area the server regenerates the affected UI controls on the UI area by updating the affected UI controls based upon the modification.

Some embodiments may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment may be implemented using Java C or other object oriented programming language and development tools. Another embodiment may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transaction hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transaction data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments. One skilled in the relevant art will recognize however that the embodiments can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in detail.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the one or more embodiments. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments including what is described in the Abstract is not intended to be exhaustive or to limit the one or more embodiments to the precise forms disclosed. While specific embodiments of and examples for the one or more embodiments are described herein for illustrative purposes various equivalent modifications are possible within the scope as those skilled in the relevant art will recognize. These modifications can be made in light of the above detailed description. Rather the scope is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

