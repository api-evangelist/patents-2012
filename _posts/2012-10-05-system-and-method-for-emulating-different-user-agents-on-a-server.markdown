---

title: System and method for emulating different user agents on a server
abstract: A system and method for emulating a multitude of different user agents on a server-side is disclosed herein. On a server-side, an acceptable user agent string for receiving full content from the web-site with a browser sniffing agent is identified. The acceptable user agent is emulated by transmitting a HTTP request with the acceptable user agent string, allowing for access to the full content of the web-page of the web-site.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09148467&OS=09148467&RS=09148467
owner: Appcelerator, Inc.
number: 09148467
owner_city: Mountain View
owner_country: US
publication_date: 20121005
---
This application is a continuation of U.S. application Ser. No. 12 327 802 filed Dec. 3 2008 now U.S. Pat. No. 8 285 813 which claims priority to U.S. Provisional Patent Application No. 60 992 703 filed on Dec. 5 2007 which is hereby incorporated by reference in its entirety.

Prior to Rich Internet Applications traditional Web applications involved a client server architecture with all of the processing on the server side and the client side used to display the HTML web pages served by the server. Each time a user desired to view a new Web page a HTTP request was sent to the server and the requested Web page was served to the Web browser on the client side. Such a traditional system is shown in with a Web server on a server side receiving requests over the Internet from a Web browser on a client side.

Rich Internet Applications such as Ajax greatly improved on the traditional client server architecture by allowing the client machine to dynamically render and partially refresh web pages based on an initial set of instructions from the server user input and small amounts of subsequent data dynamically requested from the server. As shown in the client machine processes Ajax instructions to render a Web page for the user.

Early Web applications allowed a user s browser to send a request to a server. The server processed the request and responded to the browser with a Web page. When the user wanted to view a new page another request was sent to the server and the server responded to the browser with a new Web page. Such a process resulted in a waste of bandwidth since much of the Web contents in the first Web page were also contained in the second web page. The need to resend the same information led to a much slower user interface of a Web application than that of a native application.

An emerging technology called Ajax Asynchronous and JavaScript XML was developed for refreshing part of a page instead of refreshing the whole page on every interaction between the user and application. In an Ajax application when a user submits a form in a page a script program usually a JavaScript program resident on the Web browser receives the user s request and sends a XML Extended Markup Language HTTP Hyper Text Transfer Protocol request to the Web server in background so as to retrieve only the needed Web contents instead of the whole page and perform corresponding processing to partly refresh the page when receiving a response from the Web server. In this way the application response time is shortened because the amount of data exchanged between the Web browser and the Web server is greatly reduced. And the processing time of the Web server is saved because much of the processing is performed at the client side.

Ajax is the use of dynamic HTML JavaScript and CSS to create dynamic and usually interactive Web sites and applications. A more detailed explanation of Ajax is set forth in Edmond Woychowsky Prentice Hall 2007 which is hereby incorporated by reference in its entirety.

Applets or Java Applets are mini executable programs named with the .class suffix and are placed on a Web page and provide interactive and multimedia uses.

Application Programming Interface API is a collection of computer software code usually a set of class definitions that can perform a set of related complex tasks but has a limited set of controls that may be manipulated by other software code entities. The set of controls is deliberately limited for the sake of clarity and ease of use so that programmers do not have to work with the detail contained within the given API itself.

An Attribute provides additional information about an element object or file. In a Document Object Model an attribute or attribute node is contained within an element node.

Behavioral layer is the top layer and is the scripting and programming that adds interactivity and dynamic effects to a site.

Binding in a general sense is the linking of a library to an application program usually to prevent repetition of frequently utilized code.

Compiler is a computer program that translates a series of instructions written in one computer language into a resulting output in a different computer language.

Document Object Model DOM Element is an object contained in a Document Object Model DOM . The term DOM is generally used to refer to the particular DOM held in the memory region being used by the Web browser. Such a DOM controls the Graphical Respondent Interface GRI or Graphical User Interface GUI . The DOM is generated according to the information that the Web browser reads from the HTML file and or from direct JavaScript software instructions. Generally there exists a unique DOM element for every unique HTML element. DOM elements are sometimes referred to as HTML DOM elements because the DOM element exists only because HTML code that was read by the Web browser listed some HTML element that had not previously existed and thereby caused the Web browser to create that DOM element. Often specific elements of the greater set of HTML DOM elements are identified by specifying an HTML DOM checkbox element or an HTML DOM text input element. A more detailed explanation of the document object model is set forth in Jeremy Keith friendsof 2005 which is hereby incorporated by reference in its entirety.

Function is a process encoded in software which performs some activity and returns a value as a result.

HyperText Markup Language HTML is a method of mixing text and other content with layout and appearance commands in a text file so that a browser can generate a displayed image from the file.

Hypertext Transfer Protocol HTTP is a set of conventions for controlling the transfer of information via the Internet from a Web server computer to a client computer and also from a client computer to a Web server.

Internet is the worldwide decentralized totality of server computers and data transmission paths which can supply information to a connected and browser equipped client computer and can receive and forward information entered from the client computer.

JavaScript is an object based programming language. JavaScript is an interpreted language not a compiled language. JavaScript is generally designed for writing software routines that operate within a client computer on the Internet. Generally the software routines are downloaded to the client computer at the beginning of the interactive session if they are not already cached on the client computer. JavaScript is discussed in greater detail below.

JSON is JavaScript Object Notation format which is a way of taking data and turning it into valid JavaScript syntax for reconstituting an object at the other end of the transmission protocol.

MySQL is a relational database management system which relies on SQL for processing data in a database.

Parser is a component of a compiler that analyzes a sequence of tokens to determine its grammatical structure with respect to a given formal grammar. Parsing transforms input text into a data structure usually a tree which is suitable for later processing and which captures the implied hierarchy of the input. XML Parsers ensure that an XML document follows the rules of XML markup syntax correctly.

PHP is a scripting language that allows developers create dynamically generated Web pages and is used for server side programming.

Platform is the combination of a computer s architecture operating system programming language PHP JAVA RUBY ON RAILS runtime libraries and GUIs.

Presentation layer follows the structural layer and provides instructions on how the document should look on the screen sound when read aloud or be formatted when it is printed.

Rendering engine is software used with a Web browser that takes Web content HTML XML image files and formatting information CSS XSL and displays the formatted content on a screen.

Serialization places an object in a binary form for transmission across a network such as the Internet and deserialization involves extracting a data structure from a series of bytes.

SQL Structured Query Language is a computer language designed for data retrieval and data management in a database.

Structural layer of a Web page is the marked up document and foundation on which other layers may be applied.

User is a client computer generally operated by a human being but in some system contexts running an automated process not under full time human control.

Web Browser is a complex software program resident in a client computer that is capable of loading and displaying text and images and exhibiting behaviors as encoded in HTML HyperText Markup Language from the Internet and also from the client computer s memory. Major browsers include MICROSOFT INTERNET EXPLORER NETSCAPE APPLE SAFARI MOZILLA FIREFOX and OPERA.

Web Scraping is generally defined as searching and extracting content from Web sites over HTTP to obtain results that are used for another purpose.

Web Server is a computer able to simultaneously manage many Internet information exchange processes at the same time. Normally server computers are more powerful than client computers and are administratively and or geographically centralized. An interactive form information collection process generally is controlled from a server computer to which the sponsor of the process has access. Servers usually contain one or more processors CPUs memories storage devices and network interface cards. Servers typically store the HTML documents and or execute code that generates Web pages that are sent to clients upon request. An interactive form information collection process generally is controlled from a server computer to which the sponsor of the process has access.

World Wide Web Consortium W3C is an unofficial standards body which creates and oversees the development of web technologies and the application of those technologies.

XHTML Extensible Hypertext Markup Language is a language for describing the content of hypertext documents intended to be viewed or read in a browser.

XML Extensible Markup Language is a W3C standard for text document markup and it is not a language but a set of rules for creating other markup languages.

There are three types of JavaScript 1 Client side JavaScript 2 Server side JavaScript and 3 Core JavaScript. Client side JavaScript is generally an extended version of JavaScript that enables the enhancement and manipulation of web pages and client browsers. Server side JavaScript is an extended version of JavaScript that enables back end access to databases file systems and servers. Core JavaScript is the base JavaScript.

Core JavaScript includes the following objects array date math number and string. Client side JavaScript and Server side JavaScript have additional objects and functions that are specific to client side or server side functionality. Generally any JavaScript libraries .js files created in core JavaScript can be used on both the client and the server without changes. Client side JavaScript is composed of a Core JavaScript and additional objects such as document form frame and window. The objects in Client side JavaScript enable manipulation of HTML documents checking form fields submitting forms creating dynamic pages and the browser directing the browser to load other HTML pages display messages . Server side JavaScript is composed of Core JavaScript and additional objects and functions for accessing databases and file systems and sending email. Server side JavaScript enables Web developers to efficiently create database driven web applications. Server side JavaScript is generally used to create and customize server based applications by scripting the interaction between objects. Client side JavaScript may be served by any server but only displayed by JavaScript enabled browsers. Server side JavaScript must be served by a JavaScript enabled server but can be displayed by any browser.

Dinovo United States Patent Publication Number 20020069255 for a Dynamic Content Delivery To Static Page In Non Application Capable Environment discloses a system for incorporating dynamic content into a static page from a non application capable server.

Mocket et al. United States Patent Publication Number 20010037359 for a System And Method For A Server side Browser Including Markup Language Graphical User Interface Dynamic Markup Language Rewriter Engine And Profile Engine describes a system and method for a server side browser including markup language graphical user interface dynamic markup language rewriter engine and profile engine. The system includes a user computer and a destination server computer separated by a server computer hosting a server side browser SSB . The SSB includes a markup language graphical user interface MLGUI a dynamic markup language rewriter engine DMLRE and a profiling engine PE . The SSB may be configured as an intermediary infrastructure residing on the Internet providing customized information gathering for a user. The components of the SSB allow for controlling brokering and distributing information more perfectly by controlling both browser functionality on the client side and server functionality on the destination site side within a single point and without the necessity of incremental consents or integration of either side.

Lafer et al. U.S. Pat. No. 6 192 382 for Method And System For Web Site Construction Using HTML Fragment Caching discloses storing HTML fragments in a tag cache.

Buchthal et al. U.S. Pat. No. 7 308 648 for a Method System And Computer Readable Medium For Filtering Harmful HTML In An Electronic Document discloses parsing an HTML document into HTML elements and attributes and comparing these to a content library using a filter of an API to remove unknown HTML fragments.

Daugherty et al. United States Patent Publication Number 20020016828 for a Web Page Rendering Architecture discloses a system and method for caching function calls.

Lipton et al. United States Patent Publication Number 20070143672 for Partial Rendering Of Web Pages discloses updating a Web page without having to download the entire Web page with some rendering instructions represented as HTML fragments.

Irassar et al. United States Patent Publication Number 20040250262 for Business To Business Event Communications discloses an event handling mechanism that allows communication of event information among providers and subscribers across a network using an event handling server.

Jennings et al. United States Patent Publication Number 20070073739 for a Data Driven And Plug In Defined Event Engine discloses an event engine that enables application developers to define finite state machines for implementation via a data driven approach using executable plug ins.

Lindhorst et al. U.S. Pat. No. 6 981 215 for a System For Converting Event Driven Code Into Serially Executed Code discloses an event driven server model that uses active server pages that appear to other files as objects with associated method and properties for developing Web pages.

Wilson United States Patent Publication Number 20070240032 for a Method And System For Vertical Acquisition Of Data From HTML Tables discloses passing a HTML document s content from a table to a DOM interpreter and parsing selected data to a formatted data structure on a browser.

Monsour et al. United States Patent Publication Number 20050278641 for a JavaScript Calendar Application Delivered To A Web Browser discloses a JavaScript application that generates HTML on the fly from within invisible frames and renders such HTML on a user s screen in visible frames.

Alderson United States Patent Publication Number 20040201618 for Streaming Of Real Time Data To A Browser discloses means for sending real time data to a browser in batches at a predetermined time by storing data in a queue either on the browser or server.

Dillon et al. U.S. Pat. No. 7 389 330 for a System And Method For Pre Fetching Content In A Proxy Architecture discloses a system that uses an upstream proxy server in communication over a WAN with a downstream proxy server that communicates with a browser which allows for pre fetching of objects by the upstream proxy server over the Internet from a Web server.

McCollum et al. U.S. Pat. No. 7 269 636 for a Method And Code Module For Adding Function To A Web Page discloses a means for adding function to a Web page on Web browser.

Collins et al. United States Patent Publication Number 20070027768 for a System And Method For Collection Of Advertising Usage Information discloses a HTML tag that is operative to request an instrumentation script from a script server with the instrumentation script being operative to collect visitor event information on a Web site.

Mechkov et al. United States Patent Publication Number 20070214239 for a Dynamically Updated Web Page discloses updating less than an entire Web page using an active server page authored using ASP.NET.

Abe et al. United States Patent Publication Number 20040268303 for a System Method And Computer Program Product For Generating A Web Application With Dynamic Content discloses a technique to use objects and Web contents dynamically generated on a server to generate a Web application model to support a change of a system.

Pereira et al. United States Patent Publication Number 20070288858 for an Engine For Rendering Widgets Using Platform Specific Attributes discloses rendering a widget application using system calls and callbacks.

Dong et al. United States Patent Publication Number 20070130293 for a Method And System For Providing Asynchronous Portal Pages discloses rewriting HTML and rewriting script in order to redirect HTTP requests to XMLHTTP requests for a portal system.

Salerno et al. United States Patent Publication Number 20040167876 for a Method And Apparatus For Improved Web Scraping discloses a method for Web scraping that parses the results to retrieve HTTP links.

However current technologies that operate Server side JavaScript fail to offer complete interactions which are the hallmark of rich web sites and applications. For example one problem is the ability to have browser type functionality on a server side.

The Present Invention overcomes the obstacles of the prior art. The present invention allows for the emulation of different user agents on a server for Web scraping automated testing content repurposing or anywhere it is useful to have browser type functionality in a server type environment with scalability and performance.

One aspect of the present invention is a method for emulating a multitude of different user agents on a server side. The method includes identifying a Web page on a Web site. The Web site has browser sniffing code. The method also includes determining an acceptable user agent string for receiving full content from the Web site. The method also includes emulating the acceptable user agent by transmitting a HTTP request with the acceptable user agent string. The method also includes accessing the full content of the Web page of the Web site.

Another aspect of the present invention is a system for emulating a multitude of different user agents on a server side. The system includes a Web page and a Web server. The Web page has browser sniffing code. The Web server includes means for modifying a user agent string of code transmitted to the web page to emulate a preferred type of Web browser and means for Web scraping.

The present invention parses and executes the Web page as a browser would parse the Web page. The present invention is configured to execute all or part of the code on that page load external resources or not and call various external systems in the course of processing the Web page. As a result the present invention can faithfully analyze the load producing traffic in real time e.g. monitoring how many links to certain resources are really being sent whether they are clustered in certain ways e.g. per page per application or site per user per session how much overlap they contain and where do they appear and how their content is being used. In addition to reporting all this data and presenting the data in various ways to the system operators the present invention effects certain optimizations. For example the present invention aggregates multiple JavaScript and CSS files into single files caches them and replaces the multiple links to the original files into single links to the new files thus reducing the number of network trips needed to complete the Web page. The present invention delivers only the pieces of code that are used often and proxies the rest of the code to deliver them on demand. The present invention reassembles JavaScript files for more optimal caching on the client and fewer network trips and present invention can do so for images too using a technique known as image sprites. Further the present invention does all of this without changing the original code and files used to generate the web pages. The on the fly runtime information and optimizations are then used as actionable feedback to change the original code and files or for building new code and files better.

To understand the differences between the server and browser sides it s important to keep in mind the page lifecycle. The page request from the browser is received by the Web server which fetches the appropriate HTML document either from the file system or perhaps from another handler such as PHP or Ruby or Java . The Web server Apache server then feeds the document to the script server of the present invention which begins to parse the HTML document and builds up the DOM tree. When the script server encounters tags the script server not only adds them to the DOM but may also execute them if they have a runat attribute that indicates they should run on the server. During the parsing and execution external content may also be fetched and loaded into the document via elements and Jaxer.load . . . for JavaScript code or via or for HTML content or via XMLHttpRequests for any content. After the DOM is fully loaded the onserverload event is fired. This is the server side equivalent of the onload event on the browser. The onserverload event is named differently so that a developer s code can react separately to onserverload and onload events. The script server post processes the DOM to carry out its built in logic and prepare the DOM for sending to the browser removing blocks meant only for the server replacing functions to be proxied with proxies saving as needed functions that should be available on callbacks . . . etc. Finally the DOM is serialized back to HTML and that HTML is streamed back via the Web server to the browser.

The resulting HTML page is sent back to the browser as the response to the browser s request. The browser begins to parse the HTML building up the DOM. When the browser encounters tags the browser not only adds them to the DOM but also executes them. External JavaScript code or any other content may also be loaded. The onload event fires. Of course the page is progressively rendered throughout much of this flow and also the user can interact with it.

Callbacks from the browser to server side functions are handled via XMLHttpRequests. When the script server receives such a request it creates a new empty document unless configured to use a different static document . The script server retrieves the saved functions that are needed to be made available during callbacks to this page. If a function called oncallback is found it is executed. This is usually used to create the environment needed during a callback if the saved functions are not enough. The callback function itself is executed. Finally the result of that execution is packaged and returned as the response to the XMLHttpRequest.

While a DOM is available during callback processing it is not serialized as HTML and returned as the response as it was during the regular non callback page processing flow. The DOM on script server and the DOM on the browser typically are not synchronized. Both are created from the same HTML source but they are often subject to processing by different JavaScript code and both come to life at different points in the page lifecycle the DOM on the script server exists temporarily when the page is processed by the script server and is eliminated after it s been serialized into the HTML sent to the browser the DOM in the browser is built on the browser from that HTML and is the DOM that s rendered to the user and with which the end user interacts.

While script server and the browser may well share some code e.g. when using runat both usually the JavaScript code designated to run on script server and interacting with the script server DOM is different than the code designated to run on the client. The latter exists e.g. as a tag in the script server DOM but is not executed in script server.

Remember that the only things sent to the browser at the end of page processing is what s actually in the DOM and what the script server of the present invention has added such as proxies clientData and injected scripts. For example if a developer added an expando property which is an in memory change to the DOM that will not get serialized it will not appear on the client side.

On the browser the div is present with an id of myDiv but without a userId property. For this same reason setting event handlers programatically rather than in the DOM will not translate to DOM changes and hence will not propagate to the browser. For example with a button 

A developer could add an onclick . . . attribute to the tag but this does not assist with adding the event handler programatically. The script server of the present invention provides Jaxer.setEvent domElement eventName handler function that does the right thing in the script server as well as on the browser.

The function used as the event handler should be made available to the browser. When setEvent is executed on the server as above it results in the following change to the myButton element This is sent to the browser since it is a DOM change. If the function passed into setEvent has no name its body source is used as the value of the attribute var btn document.getEleemntById myButton Jaxer.setEvent btn onclick function alert hi 

Which is useful for short functions but is easier to pass in the code to execute as a string var btn document.getEleemntById myButton Jaxer.setEvent btn onclick alert hi 

The environment of the present invention is preferably based upon the very same Mozilla engine which powers Firefox 3. This means that for the most part DOM interaction in the server using the present invention is the same as interacting with the DOM in a Web browser. It parses and executes pages progressively building up the DOM as it goes along and allowing JavaScript to interact with whatever DOM has already been built up at the time the JavaScript executes. Any document.write calls will write to the DOM immediately following the current location on the page. The JavaScript that is part of a page and loaded into the page executes within the context of the global window object. For each request at the server the present invention preferably provides a document object model. This DOM which we ll refer to as DOM can be used to insert data and otherwise transform the page before it is first returned to the browser. You interact with and manipulate the DOM much the same as you would in the browser. Some third party Javascript toolkits such as jQuery can also be used to modify this DOM. The document is accessible through the document object and the root element of the DOM is accessible through the document.documentElement object. To ensure that element properties are serialized properly when the DOM is returned to the browser use element.setAttribute attr value rather than element.foo value . Form element values set with formElement.value code font are an exception they ll still be serialized as expected. To attach an event handler to an element preferably use the special Jaxer method Jaxer.setEvent . Example Transforming the DOM.

The present invention allows Web developers to consume and transform content from HTML pages written in other languages like PHP PYTHON RUBY ON RAILS .NET or JAVA. The present invention includes a rich framework for many useful tasks on the server including accessing local or remote Web resources and services without cross domain security restrictions that a browser might impose or rewriting HTML pages generated by other platforms such as set forth below.

Having briefly described the present invention the above and further objects features and advantages thereof will be recognized by those skilled in the pertinent art from the following detailed description of the invention when taken in conjunction with the accompanying drawings.

As shown in a system of the invention generally includes a server side a client side and a network or preferably the Internet . The server side includes a web server a handler and a JavaScript server preferably having a server core and a server framework . The client side includes a Web browser has a client framework a client side JavaScript code and a rendering engine . The server framework accesses filesystems and databases as well as the Internet . A more detailed description of the abilities of the running JavaScript on the server side and client side is disclosed in Colton et al. U.S. patent application Ser. No. 12 270 817 filed Nov. 13 2008 for A Web Server Based On The Same Paradigms As Web Clients which is hereby incorporated by reference in its entirety. An additional detail of facilitated server side to client side communications is disclosed in Colton et al. U.S. patent application Ser. No. 12 276 327 filed Nov. 22 2008 for a System And Method For Facilitated Client Side To Server Side Communications which is hereby incorporated by reference in its entirety. Details of exposing the dynamic Web on the server side is disclosed in Colton et al. U.S. patent application Ser. No. 12 326 110 filed Dec. 2 2008 for a System And Method For Exposing The Dynamic Web Server Side which is hereby incorporated by reference in its entirety. Details of compressing JavaScript in an HTML document on the server side is disclosed in Colton et al. U.S. patent application Ser. No. 12 326 861 filed Dec. 2 2008 for a System And Method For JavaScript Compression which is hereby incorporated by reference in its entirety.

In the system is shown during a callback operation. The callback begins at the client side JavaScript code with a callback request sent to the client framework . A HTTP GET request is transmitted over the Internet to the server side and received at the Web server . The HTTP GET request is sent to the server core which sends the HTTP GET request as a callback to the server framework . The server framework receives the callback deserializes performs the get functions invokes serializes and sends the response to the callback to the server core . The server core sends the response to the Web server which sends the response over the Internet to client framework on the Web browser . Additional details concerning JavaScript callbacks is set forth in Colton et al. U.S. patent application Ser. No. 12 326 891 filed Dec. 3 2008 for a System And Method For Binding A Document Object Model Through JavaScript Callbacks which is hereby incorporated by reference in its entirety.

In the system is shown during a normal process. The process begins with a HTTP GET request for a Web page sent over the Internet from the Web browser on the client side to the server side . The HTTP Request is sent to the handler server . The HTML Web page is then sent to the script server architecture . The server core of the script server architecture parses the HTML Web page to create a HTML DOM of the HTML Web page. The server core also parses and interprets the JavaScript of the HTML Web page. The server framework accesses databases and filesystems to respond to the Requests for the HTML Web page. The server framework also injects proxies to modify the HTML Web page. The server core serializes the DOM back to the HTML Web page and the web server transmits the HTML Web page to the client side where the Web browser renders the HTML Web page for display for a user. As shown in a Web server e.g. apache server receives a request from the client side. The request is sent to the handler server PHP Ruby or Java language . The handler server feeds the HTML document to script server core which begins to parse the HTML document thereby building the DOM tree for the HTML document on the server side. Events and callbacks are sent to the script server framework . The script server adds tags to the DOM and executes them if the has a runat attribute that indicates the should be run on the server. During the parsing and execution external content from filesystems databases and the like are fetched and loaded into the HTML document. After the DOM is loaded the onserverload event is fired from the script server framework . The script server architecture post processes the DOM to perform its built in logic and prepare the DOM for transmission to the client side. This post process includes removing block meant only for the server replacing function to be proxied with proxies saving functions that should be available as callbacks and the like. The DOM is serialized back to HTML and the HTML is streamed back via the web server to the browser. A more detailed explanation of event driven JavaScript architecture is set forth in Colton et al. U.S. patent application Ser. No. 12 273 539 filed on Nov. 18 2008 for a Flexible Event Driven JavaScript Server Architecture which is hereby incorporated by reference in its entirety. A more detailed explanation of on the fly processing is set forth in Colton et al. U.S. patent application Ser. No. 12 276 337 filed on Nov. 22 2008 for a System And Method For On The Fly Post Processing Document Object Model Manipulation which is hereby incorporated by reference in its entirety.

As shown in the present invention allows the server to execute the JavaScript functions that are set to runat server or runat both . These functions might call databases file systems communicate across network sockets or get session data. And since the server side engine has a HTML DOM just like the browser the HTML page can be manipulated through standard DOM APIs and your favorite Ajax libraries. The present invention also has session objects that can be used to persist data for users during a session or transaction. Any functions set to runat server are stripped from what gets sent to the browser . Specifically at 1 the page executes on the server and a resulting HTML page is sent to the browser . A more detailed description of the runat function is set forth in Colton et al. U.S. patent application Ser. No. 12 270 868 filed on Nov. 14 2008 for a System And Method For Tagging Code To Determine Where The Code Runs which is hereby incorporated by reference in its entirety. A more detailed description of validating the code is set forth in Colton et al. U.S. patent application Ser. No. 12 325 239 filed on Nov. 30 2008 for a Client Side And Server Side Unified Validation which is hereby incorporated by reference in its entirety.

After server sends the resulting HTML page to the browser at 2 the browser interprets the HTML page and executes the JavaScript within the HTML page. If JavaScript functions tagged to runat server proxy are included then the present invention automatically strips out the bodies of those functions and replaces the bodies with a new functions by the same name that know how to invoke the original function on the server using Ajax calls and return the result either synchronously or asynchronously. Ajax communications do not need to be written using the present invention. Any functions not tagged with a runat attribute or set to runat client or runat both are processed by the browser .

Any functions set to runat server proxy can now be called from the browser . The function is called as if it were running on the browser and the present invention automatically via XHR communications with the server marshals the parameters to the server where the function executes calling databases getting info from the session data etc. . . . and returns the result to the browser . The server proxy functions can be invoked either synchronously or asynchronously. At 3 the browser calls the server asynchronously for new information.

The server computer program of the present invention is pre configured for preferable use as a plug in to the APACHE 2.x web server. To provide standards compliant JavaScript and DOM capabilities server side the server computer program is built on the MOZILLA engine which is the same engine used in the popular FIREFOX browser. The server computer program of the present invention is layered into APACHE as an input and output filter for use to modify dynamic pages created by other languages such as PHP or Ruby.

The server computer program of the present invention is preferably a combination of C C Core code and a server side JavaScript Framework. The server core provides the JavaScript parser and runtime HTML parser and DOM engine and an event architecture that calls the server framework as the document is being processed on the server side . The server framework provides the logic for example deciding which code to run on the server side and which on the client side creating proxies on the client side for callable server side functions serializing and deserializing data and other related activities. A more detailed description of generating proxies is set forth in Colton et al. U.S. patent application Ser. No. 12 275 182 filed on Nov. 20 2008 for a System And Method For Auto Generating JavaScript Proxies And Meta Proxies which is hereby incorporated by reference in its entirety. Further discussions on proxy generation are set forth in Colton et al. U.S. patent application Ser. No. 12 275 213 filed on Nov. 20 2008 for a Single Proxy Generation For Multiple Web Pages which is hereby incorporated by reference in its entirety. A more detailed description of accessing the DOM on the server side is set forth in Colton et al. U.S. patent application Ser. No. 12 277 336 filed on Nov. 22 2008 for a System And Method For Accessibility Of Document Object Model And JavaScript By Other Platforms which is hereby incorporated by reference in its entirety. A more detailed description of caching is set forth in Colton et al. U.S. patent application Ser. No. 12 325 268 filed on Dec. 1 2008 for a System And Method For Caching HTML Fragments which is hereby incorporated by reference in its entirety. A more detailed description of using aspect oriented programming with the present invention is set forth in Colton et al. U.S. patent application Ser. No. 12 326 103 filed on Dec. 2 2008 for Aspect Oriented Programming which is hereby incorporated by reference in its entirety.

On the server side a developer s JavaScript environment is enhanced by the server framework which provides access to the database e.g. MySQL file system network the HTTP Request and Response data and the external server side platforms such as Java PHP and Ruby. The script server architecture allows for processing of web applications on the fly. An additional explanation of on the fly post processing is disclosed in Colton et al. U.S. patent application Ser. No. 12 325 240 filed on Nov. 30 2008 for On The Fly Post Processing Of HTML Streams which is hereby incorporated by reference in its entirety. Further details are provided in Colton et al. U.S. patent application Ser. No. 12 325 249 filed on Nov. 30 2008 for On The Fly Rewriting Of Uniform Resource Locators In A Web Page which is hereby incorporated by reference in its entirety. Yet further details are provided in Colton et al. U.S. patent application Ser. No. 12 326 035 filed on Dec. 1 2008 for On The Fly Optimization Of Web Applications which is hereby incorporated by reference in its entirety. Yet further details are provided in Colton et al. U.S. patent application Ser. No. 12 326 087 filed on Dec. 1 2008 for On The Fly Instrumentation Of Web Applications Web Pages or Web Sites which is hereby incorporated by reference in its entirety. Yet further details are provided in Colton et al. U.S. patent application Ser. No. 12 326 910 filed on Dec. 3 2008 for a System And Method For On The Fly Rewriting Of JavaScript which is hereby incorporated by reference in its entirety. Yet further details are provided in Colton et al. U.S. patent application Ser. No. 12 327 330 filed on Dec. 3 2008 for a System And Method For On The Fly Post Processing Security Verifications which is hereby incorporated by reference in its entirety.

The client side preferably has a user interface. The user interface also referred to as UI is typically a computer which includes a processing means for interacting with various input and output devices I O devices and various networks. The I O Devices can be drives a keyboard a display a scanner a mouse and the like. The processing means typically includes a CPU such as an INTEL PENTIUM processor or the like. The processing means also preferably includes a memory random access memory and read only memory and interfaces for communicating with networks and the I O Devices. The computers on the server side are similar to the client side however more powerful.

An example of code written by a developer and prior to processing by the present invention is set forth below.

Processing of the code by the present invention results in the code being formatted as set forth below 

As shown in a server computer contains server architecture . The server architecture includes the server core and the server framework . The server core includes a JavaScript parser . The server computer is preferably a conventional server computer available from IBM HP APPLE DELL and SUN.

As shown in a user computer contains a Web browser . The Web browser preferably includes the client framework client side JavaScript code and the rendering engine . The user computer is preferably a conventional user computer such as a PC available from HP DELL and GATEWAY or a MAC available from APPLE. The Web browser is preferably MICROSOFT INTERNET EXPLORER NETSCAPE APPLE SAFARI MOZILLA FIREFOX or OPERA.

A general method of the present invention is shown in . At block a Web page having a browser sniffing code is identified. Such browser sniffing codes are commercially available as BROWSERHAWK or BROWSEROBJECT. The browser sniffing code analyzes HTTP requests from browsers sent to a Web server for a particular Web site. The browser sniffing code determines the identity of the Web browser in order to present content appropriate for that browser. The browser may be a MICROSOFT INTERNET EXPLORER browser a MOZILLA FIREFOX browser an OPERA browser an APPLE SAFARI browser or the like. A browser sniffing code is necessary due to incompatibilities between browsers in the interpretation of HTML CSS and the DOM. As a result different browsers will display the same page differently to different browsers and sometimes the full content of the Web page is not available if the user agent is unacceptable. At block an acceptable user agent string for receiving full content from the Web site is determined on a server side. The script server architecture of the present invention is able to determine on the server side what browser user agent provides full access to the content of the web page. At block an acceptable user agent is emulated by transmitting a HTTP request with the acceptable user agent string. For example if a user agent pertaining to a MOZILLA FIREFOX browser is an acceptable user agent to access the full content of the Web page then the script server architecture of the present invention emulates a user agent pertaining to a MOZILLA FIREFOX browser. If a user agent pertaining to an APPLE SAFARI browser is an acceptable user agent to access the full content of the Web page then the script server architecture of the present invention emulates a user agent pertaining to a APPLE SAFARI browser. At block the full content of the Web page of the Web site is accessed on the server side. This full content of the Web page may be manipulated if necessary serialized and sent to a client side.

A simple example illustrating how the present invention can fetch a Web page to be analyzed from a third party site parse and execute the DOM and JavaScript on that Web page using its DOM and JavaScript engines then convert the result into an accessible format in this case HTML and submitting it to another platform via a Web Services HTTP request receiving a response in return.

The HTML document to be fetched from the third party site e.g www.third party.com It should be noted that it does not explicitly contain the word phishing. 

The following is the code which the present invention uses to fetch the Web page execute the Web page and create the accessible format.

The accessible format which the present invention sends to the other platform note that it now contains the word phishing because the JavaScript was executed and this is what the user going to that site would have seen 

The verification service in this case an ASP.NET page as you can see from its url can look for suspicious words and return a go no go decision.

When the present invention first processes a page before sending it to the client it executes any JavaScript code designated to run at the server specifically any script blocks with a runat attribute of server both or one of their variants. Some of the functions defined during the processing can be designated to be available for callbacks. These functions are only available for callbacks from this page. A function is designated as callable from the browser it is in a script block with a runat server proxy attribute or if it has a proxy property with a value of true or if it s included in the Jaxer.proxies array in the page. If any of these holds the function is cached saved on the server at the end of page processing and in its place a proxy function with the same name is injected into the browser bound page. When the proxy function is called on the browser it makes an XMLHttpRequest back to the server and the server retrieves the original function and executes it then the result is returned to the browser where it s handled as if the proxy function returned it.

In the present invention preferably there are two proxy functions injected into the browser bound page for every callable server side function one with the same name as the server side function and one with Async appended to its name. The second one is used to make asynchronous calls ones that don t freeze the browser while the request is made to the server processed and returned. The Async version takes an additional first argument a function to be called when the response is received from the server. That function takes as its arguments the returned result of the server side function. An example is as follows 

Note that calling the getLastName function on the server is as easy as calling any function on the browser because there actually is a getLastName function on the browser and it s a proxy for the true getLastName function on the server. Using getLastNameAsync requires a bit more work restructuring code to allow for the asynchronous flow but it often means a better user experience.

In many cases other functions are needed on the server during a callback. For example getLastName requires certain access privileges. It needs to call a getCurrentUser function and then call isAuthorized on it. But getCurrentUser and isAuthorized should not be callable from the browser directly e.g. for security reasons. To achieve this the present invention automatically caches any other functions defined at the end of page processing unless they re explicitly designated with runat server nocache or runat both nocache and makes them available to other functions but not to the browser during a callback the asynchronous version is omitted simplicity as shown below.

All three server side functions getCurrentUser isAuthorized and getLastName are saved after the page is processed and are available during a callback but only one getLastName is allowed to be called directly from the browser and it can then call the others as needed. It s a good practice to limit the proxied functions to only the ones actually needed by the browser to support the user interaction flow.

To understand callbacks in even more detail consider the page lifecycle. The script server architecture of the present invention loads the page and processes it creating the DOM from the HTML and running the server side JavaScript which may create some functions and may manipulate the DOM. At the end of the page the HTML DOM is turned back into HTML and the HTML is sent to the browser. The present invention then caches whatever functions may be required during a callback destroys the server side global window JavaScript context and all the JavaScript functions and data in it as well as the DOM and prepares for its next request. The cached functions are saved to the database but for efficiency they re also cached as bytecode in memory. Then on every callback an empty window object with an empty DOM is made available and the cached functions for that page are recreated in that window using the bytecode in memory after fetching from the database if needed . Finally the specific function specified in the callback is executed.

As a result of this flow the environment available during a callback isn t the same as during the initial page. Basically just the cached functions are available. In most cases that works well and is highly efficient there s no need to recreate the entire original page to call a function no complications trying to somehow sync the DOM during the callback to the possibly changed DOM now on the browser and no danger that user specific data on that page may be available to other users etc. However if more control is needed e.g. to make a server side library available if that server side library consisted purely of functions it was probably automatically cached when loaded during the initial page processing so everything will operate. But if it requires some non function objects to be present the functions will need to be recreated during the callback. This can be done if the library contained an external JavaScript file to load it via . The autorun attribute tells the present invention to automatically run this library not only on every request for this page but also on every callback on this page for efficiency the library is actually compiled into bytecode and stored in memory. Alternatively a special function called oncallback can be defined in the Web page. This special function will be executed on every callback for this Web page before the function calling back is executed. The oncallback can for example check whether the environment is set up and if not it can establish the environment.

An example of on the fly post processing of document object model manipulation is shown below. The HTML document is as shown below.

The DOM tree and its elements for the HTML document with the omission of the whitespace nodes is shown below.

From the foregoing it is believed that those skilled in the pertinent art will recognize the meritorious advancement of this invention and will readily understand that while the present invention has been described in association with a preferred embodiment thereof and other embodiments illustrated in the accompanying drawings numerous changes modification and substitutions of equivalents may be made therein without departing from the spirit and scope of this invention which is intended to be unlimited by the foregoing except as may appear in the following appended claim. Therefore the embodiments of the invention in which an exclusive property or privilege is claimed are defined in the following appended claims.

