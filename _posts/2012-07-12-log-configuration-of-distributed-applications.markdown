---

title: Log configuration of distributed applications
abstract: A method of configuring a logging utility includes generating, by a computer system, at least one message based on a model of logs from at least two software components of a multi-component application and sending, by the computer system, the message to at least one of the two software components for configuring a logging utility of the corresponding software component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262248&OS=09262248&RS=09262248
owner: INTERNATIONAL BUSINESS MACHINES CORPORATION
number: 09262248
owner_city: Armonk
owner_country: US
publication_date: 20120712
---
This application is a continuation of U.S. Provisional application Ser. No. 13 542 863 filed on Jul. 6 2012 the disclosure of which is incorporated by reference herein.

The present disclosure relates generally to log files and more particularly to configuring log files of a distributed application.

Computer data logging is a process of recording events with an automated computer program in a certain scope to provide an audit trail that can be used to understand the activity of a system and to diagnose problems.

A distributed application is a software system with at least two distinct and interrelated software components that are capable of running on two or more computers and communicating across a computer network. These software components may also reside on a single computer and communicate with each other using internal communications mechanisms.

Each software component can provide its own tool for managing the creation of its log files. However since there may be a multitude of software components each with their own interface it can be difficult for a single user to manage all of them. Further the logs generated by these components may provide information that is redundant or less than useful. Thus the log files may use up valuable disk space which may affect the performance of the system.

According to an exemplary embodiment of the invention a method of configuring a logging utility includes generating by a computer system at least one message based on a model of logs from at least two software components of a multi component application and sending by the computer system one of the messages to at least one of the two software components for configuring a logging utility of the corresponding software component.

According to an exemplary embodiment of the invention a method of configuring generation a logging utility includes retrieving logs from at least two software components of a multi component application generating states to form a model of the retrieved logs where each state is representative of at least two related records of the logs editing the log model to perform at least one of i removing at least one of the states ii merging at least two of the states into a single state and iii sub dividing one of the states into at least two separate states and configuring a logging utility of at least one of the software components based on the edited model.

According to an exemplary embodiment of the invention a method of configuring a logging utility includes deriving a log model from logs of at least two software components of a multi component application editing the log model to perform at least one of i removing one state of the model ii merging two states of the model into a single state and iii sub dividing one state of the model into at least two separate states and configuring a logging utility of at least one of the software components based on the edited model.

According to an exemplary embodiment of the invention a computer system to configure log utilities includes a processor and a memory. The memory stores a log configuration program. The processor is configured to execute the program. The program is configured to generate at least one message based on a model of logs from at least two software components of a multi component application and send one of the messages to at least one of the two software components for configuring a logging utility of the corresponding software component.

According to an exemplary embodiment of the invention a computer system to configure logging utilities includes a processor and a memory. The memory stores a log configuration program. The processor is configured to execute the program. The program is configured to retrieve logs from at least two software components of a multi component application generate states from the retrieved logs to form a log model enable editing of the log model and configured to send at least one message to a logging utility of at least one of the software components based on the edited model to change how the corresponding logging utility performs logging.

According to an exemplary embodiment of the invention a computer system to configure logging utilities includes a processor and a memory. The memory stores a log configuration program. The processor is configured to execute the program. The program is configured to derive a log model from logs of at least two software components of a multi component application configured to enable the log model to be edited and configured to send at least one message to a logging utility of at least one of the software components based on the edited model to change how the corresponding logging utility performs logging.

The information provided in the record is merely an example as the invention is not limited to log files with records of any particular format or number of information fields. For example some log records may have less or more information. Examples of the logged action or result include an indication that a certain process thread or service has been started successfully could not be started or was stopped by the component. Further examples of the logged action or result include an indication that a particular file was read by a component or written to by a component. Additional examples of the logged action or result include an indication that a component is running out of memory has suffered a fatal exception has successfully connected or communicated to another component etc. These examples of logged actions are merely examples as the invention is not limited to any particular logged event.

In an exemplary embodiment the collection of the log files includes transferring the log files to a central location using a file transport protocol e.g. ftp etc. . Referring back to once the log files have been collected the method continues by generating state transition log models S . The generation of the log models may include generation of textual tokens from the logged records based on pre established tokenization and correlation rules. A log or log file can be modeled as an ordered sequence of transaction records R R R . . . RN etc. Each record may be represented by a tuple comprising a timestamp and a collection of tokens according to equation 1 below where PI 1 where tsrepresents the time at which a transaction generated the record Ri and Ci represents a collection of tokens Tp extracted from record Ri indexed according to a position index set PIi. A token may be defined recursively as either a sequence of characters called a word or a collection of indexed tokens.

In an exemplary embodiment white space is used as a delimiter to generate the tokens. For example text followed by white space text between white space and text after white space each becomes a token. However embodiments of the invention are not limited any particular delimiter. For example a delimiter can be any character number or string. In an embodiment a regular expression is used to identity the timestamp of a record.

The tokenization may store an index for each generated token within the tokenized record. The index includes the location or position of the token within the record. For example the logText token could have an index of 4 within the overall record while the index of its sub tokens could have indexes 1 2 and 3 within the logtext token .

In an exemplary embodiment the tokenization rules can be adjusted during a feedback stage and be iteratively improved if necessary. The tokenization rules can be generated without involving a domain expert. For example it can be assumed that upon previewing the records displayed in and average user would conclude that XML element Trace is merely a container for other useful information and does not need to be considered as a token on its user. The user may also conclude that the relationship between the IP address IPAddress and location ServerLoc of a server is known and therefore merits inclusion of only one of the elements for tokenization.

Candidate transaction states can be generated from the resulting tokens and their indexes within the logged transaction. In the absence of semantic knowledge of transaction records one can exploit the structural resemblance among transaction records to identify the candidate transaction states. The intuition here is that given an underlying transaction model a state in the model would generate transaction records that have the same overall structure even though the records may differ in content for different transaction instances.

Clusters of transaction records that share close structural resemblance with each other are identified and a candidate state is associated with each cluster. The structure of a transaction record R may be defined in terms of the position indices of terminal tokens. For example in a plain text tokenizer all resulting tokens could be considered terminal tokens. However for an XML tokenizer described above one could consider only the sub tokens of the token LogText as the terminal tokens. What constitutes a terminal token may be provided in a pre defined rule that governs tokenization. Initially the rules may be specified based on the type of the transaction records or log file e.g. plain text XML database tables etc. and by a preliminary examination of records by a non expert. Later the rules may be enhanced by a domain expert.

Given the terminal tokens the structure of a record can be defined as the set of indices of the terminal tokens as shown by equation 2 . struct PI and is a terminal token 2 

To facilitate the comparison between the structure of two records the data object representing a record R includes a compact representation of struct R . Using this information the entire sample space Q of transaction records may be in a given format partitioned by equation 3 as . 3 where . are disjoint sets and . denotes the structure of records comprising the set. Essentially records in each of these sets are structurally compatible with each other. The process of partitioning a group of records into smaller subspaces based on equation 3 is illustrated in the top half of where the partition indices have been renumbered to write U .

Following an initial partitioning of transaction records the contents of the tokens may be used to define a structural distance between records. For example records may be compared using a Hamming like distance metric which is defined as the number of terminal tokens that do not match between two records. For example in the first two records differ in two terminal token positions and hence the distance between them is 2. This distance can be used to define record clusters within each partition to comprise all the transaction records that have a distance less than a given threshold Tof each other. A candidate state Sis assigned to represent such a cluster and can be viewed as a pseudo transaction record in that is closest to all the records in this cluster. The threshold Tplays the role of a similarity knob that can be used to produce states that represent broad or refined collections of records. While a Hamming like distance can be used for measuring resemblance of records alternative distance metric can be used as well.

A state can be defined by equation 4 as follows ID where TP PI 4 where IDrepresents a unique state ID and C represents a collection of token patterns TPindexed according to a position index set PI. After candidate states are produced relationships among them are established through a correlation process to generate a set of candidate transaction model s . Upon producing a set of candidate they can be mapped to the original sequence of transaction records from which they are derived. This state sequence may be formed so that temporal based correlation rules can be used to form actual transaction models. For example transaction models may be derived using the order of occurrence of the records matching the model s states or even the time intervals between which adjacent records occur.

Referring back to a user e.g. a domain expert may edit the resulting models S . The editing may include deletion of states merging of states converting a state into at least two separate states re ordering of state transition sequences etc. For example a first state can cause or invoke a second state. Thus an edit that indicates the second state has invoked the first state is an example of re ordering a state transition sequence. Further the editing may include defining thresholds on valid transition times. For example if a state associated with one or more logged records transitions to another state but not within a valid transition time these states could be moved from the model. In this way the transaction model generation rules can be augmented with a human s domain expertise. Then the framework can rerun the model generation process to derive a set of refined models.

Referring back to the method includes sending the models to a logging utility interface which may be referred to as a universal log processing framework S . The models may have been edited by a domain expert as discussed above prior to being sent to the universal framework. The universal framework may receive these models from several disparate software components that are part of a multi component application. The universal framework may include a function that filters log records based on user feedback. The universal framework may be run on a same computer as a software component or on a remote computer.

The method includes configuring separate log utilities to generate or suppress log records according to the generated and or edited models S . For example assume a multi component application includes components such as a DB2 database and Cognos the universal framework would attempt to configure the logging utility of DB2 and Cognos based on the resulting models. For example assume that DB2 is currently generating a log record for each table that is backed up to a file. The model editing performed by a domain expert could have generated a state in a model that indicates the series of records corresponds to a database backup . For example individual states that indicate a backup of each table can be merged into a single state that indicates a backup of the database. The universal framework can then configure the log utilities of DB2 to log a single record indicating that the database has been backed up instead of logging one record for each backed up table. In a further example the editing by the domain expert has removed or deleted some of the states from an existing model. For example suppose the domain expert is only interested in the backup of table 1 and table 2 but not table 3. The universal framework can configure the logging utility of the DB2 database to stop logging the backup of table 3. In this way the universal framework has caused suppression of log records that it would normally generate.

In another example the DB2 database is currently providing the single log record indicating that the database has been backed up the editing by the domain expert has split the corresponding state into separate states that indicate the backup of each table and then the universal framework configures the logging utility of the DB2 database to again generate separate log records for each backed up table. In this way the universal framework has caused additional log records to be generated.

While embodiments of the universal framework have been described configuring a logging utility of a database for logging backup of tables embodiments of the invention are not limited thereto as these are merely examples.

The configuring by the universal framework may be performed based on pre defined rules or policies that describe how one or more original log records should be mapped to new expressions of the records.

In an embodiment the universal framework includes application specific log configuration adaptors that enable it to configure log utilities of various software components. The log configuration adaptors may be an application programming interface API that includes software functions that are called to send computer messages or commands to the log utilities so they may be configured.

In the method of the universal framework may determine whether configuration of a logging utility is possible S . For example if the logging utility that is to be configured had been upgraded with a version that is incompatible with the adaptors of the universal framework the universal framework could determine that it is unable to configure the logging utility. If configuration of the logging utility is not possible the universal framework can be configured to intercept the logs from the logging utility S and filter the record content based on the user generated models S . For example if the edited model indicates that records associated with the backup of table 3 should be discarded the universal framework can delete such records from the log file.

Whether or not the configuration was possible the method may include a step of the universal framework filtering the generated log records based on other criteria S . For example suppose first and second logged records are only important if they happen within a first pre defined time period. The universal framework can be configured to remove the first and second logged records from a log file if they have not occurred within the first pre defined time period.

Referring back to the universal framework may compress log records based on certain pre defined criteria or rules S . For example the universal framework could have rules that specify log records from different components are to be compressed in a different manner. For example the universal framework could be configured to compress the log files generated by each logging utility using a different or same compression algorithm. For example the log files or portions thereof that are not filtered out can be compressed. The compressed log files can be saved to a storage component in which the software component is located or to a separate storage component.

The universal framework or a universal log configuration component includes application specific log configuration adaptors a database of user generated log filtering policies and a log compression component . The log modeling utility includes a database of logged records and a database of record transformations . The adaptors are used to configure the log utilities of each application component of the multi component application. One of the adaptors may be provided to configure each logging utility or one of the adaptors may be provided to configure several of the log utilities. The database of filtering policies stores policies that indicate how certain log records are to be filtered out of existing log records. The log compression component is configured to use one or more compression algorithms to compress log files or log records.

The log modeling utility can perform the method of blocks S through S. For example the log modeling utility may be configured to collect the software records as performed in block S generate the state transition log models as performed in block S enable a user to perform model editing as performed in block S and send the models to the universal log configuration component as performed in block S. The collected software logs can be stored in a database of log records . The log modeling utility may store transformations used in the model editing in a database of transformations .

In the runtime phase i.e. during a system operational phase the universal log configuration component filters out some of the records it has retrieved from the components based on filtering policies and sends the filtered records to the components. The records that are not filtered out can be compressed by each of the components and then sent to a data storage device . The universal log configuration component may store the filtered out log records and or the remaining log records in a data storage device . An event monitor can monitor changes to the record by the component . illustrates a runtime phase of the system according to another exemplary embodiment of the invention. In this embodiment the universal log configuration component performs the compression of the log records and sends the compressed records to a data storage device that it maintains.

The computer system referred to generally as system may include for example a central processing unit CPU random access memory RAM a printer interface a display unit a local area network LAN data transmission controller a LAN interface a network controller an internal bus and one or more input devices for example a keyboard mouse etc. For example the display unit may be used to display a graphical user interface to perform the model editing. As shown the system may be connected to a data storage device for example a hard disk via a link . CPU may be the computer processor that performs the above described methods.

As will be appreciated by one skilled in the art aspects of the present disclosure may be embodied as a system method or computer program product. Accordingly aspects of the present disclosure may take the form of an entirely hardware embodiment an entirely software embodiment including firmware resident software micro code etc. or an embodiment combining software and hardware aspects that may all generally be referred to herein as a circuit module or system. Furthermore aspects of the present disclosure may take the form of a computer program product embodied in one or more computer readable medium s having computer readable program code embodied thereon.

Any combination of one or more computer readable medium s may be utilized. The computer readable medium may be a computer readable storage medium. A computer readable storage medium may be for example but not limited to an electronic magnetic optical electromagnetic infrared or semiconductor system apparatus or device or any suitable combination of the foregoing. More specific examples a non exhaustive list of the computer readable storage medium would include the following an electrical connection having one or more wires a portable computer diskette a hard disk a random access memory RAM a read only memory ROM an erasable programmable read only memory EPROM or Flash memory an optical fiber a portable compact disc read only memory CD ROM an optical storage device a magnetic storage device or any suitable combination of the foregoing. In the context of this document a computer readable storage medium may be any tangible medium that can contain or store a program for use by or in connection with an instruction execution system apparatus or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium including but not limited to wireless wireline optical fiber cable RF etc. or any suitable combination of the foregoing.

Computer program code for carrying out operations for aspects of the present disclosure may be written in any combination of one or more programming languages including an object oriented programming language such as Java Smalltalk C or the like and conventional procedural programming languages such as the C programming language or similar programming languages. The program code may execute entirely on the user s computer partly on the user s computer as a stand alone software package partly on the user s computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario the remote computer may be connected to the user s computer through any type of network including a local area network LAN or a wide area network WAN or the connection may be made to an external computer for example through the Internet using an Internet Service Provider .

Aspects of the present disclosure are described above with reference to flowchart illustrations and or block diagrams of methods apparatus systems and computer program products according to embodiments of the disclosure. It will be understood that each block of the flowchart illustrations and or block diagrams and combinations of blocks in the flowchart illustrations and or block diagrams can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer special purpose computer or other programmable data processing apparatus to produce a machine such that the instructions which execute via the processor of the computer or other programmable data processing apparatus create means for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

These computer program instructions may also be stored in a computer readable medium that can direct a computer other programmable data processing apparatus or other devices to function in a particular manner such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function act specified in the flowchart and or block diagram block or blocks.

The computer program instructions may also be loaded onto a computer other programmable data processing apparatus or other devices to cause a series of operational steps to be performed on the computer other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions acts specified in the flowchart and or block diagram block or blocks.

The flowchart and block diagrams in the figures illustrate the architecture functionality and operation of possible implementations of systems methods and computer program products according to various embodiments of the present disclosure. In this regard each block in the flowchart or block diagrams may represent a module segment or portion of code which comprises one or more executable instructions for implementing the specified logical function s . It should also be noted that in some alternative implementations the functions noted in the block may occur out of the order noted in the figures. For example two blocks shown in succession may in fact be executed substantially concurrently or the blocks may sometimes be executed in the reverse order depending upon the functionality involved. It will also be noted that each block of the block diagrams and or flowchart illustration and combinations of blocks in the block diagrams and or flowchart illustration can be implemented by special purpose hardware based systems that perform the specified functions or acts or combinations of special purpose hardware and computer instructions.

