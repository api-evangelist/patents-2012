---

title: Classpath optimization in a Java runtime environment
abstract: A computer implemented method, data processing system, and computer usable program are provided by the aspects of the present invention. Aspects of the present invention identify required classes of a software program in the import statements in the source code. Next, the aspects of the present invention identify an element in a classpath environment variable that contain only the required classes and generate a new classpath environment variable with the identified element. Aspects of the present invention then store the new classpath environment variable in a classpath file that is specific to the software program for subsequent invocation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09069582&OS=09069582&RS=09069582
owner: International Business Machines Corporation
number: 09069582
owner_city: Armonk
owner_country: US
publication_date: 20120914
---
This application is a continuation of and claims the benefit of priority to U.S. application Ser. No. 12 127 525 filed on May 27 2008 and entitled Method and Apparatus for Classpath Optimization in a Java Runtime Environment which is a continuation of U.S. application Ser. No. 11 225 572 filed on Sep. 13 2005 and entitled Method and Apparatus for Classpath Optimization in a Java Runtime Environment the contents of which are hereby incorporated by reference.

The present invention relates generally to a data processing system. In particular the present invention relates to a Java runtime environment in a data processing system. Still more particularly the present invention relates to optimizing a classpath environment variable in the Java runtime environment by generating a new classpath environment variable that only includes directories containing classes that are required by a current Java program.

In the Java runtime environment when a user invokes a Java program the Java class loader loads bootstrap classes extension classes and user classes. Java runtime environment JRE is a product available from Sun Microsystems Inc. Bootstrap classes are classes of the basic Java platform. Extension classes are Java archive JAR files that are required by the Java platform. User classes are classes that are defined by program developers. Currently the location of the user classes is identified by the classpath environment variable which lists directories and JAR files containing class files. The classpath environment variable is typically set on a user login to be used for all of the Java programs.

When Java programs are installed Java class loader loads packages containing classes that are required by the Java program by traversing the classpath environment variable as defined by the user. In this way the required classes may be identified by the Java class loader. However as the number of directories or JAR files defined in the classpath environment variable increases or as the number of Java programs increases searching through the classpath environment variable becomes very time consuming. The number of classes or JAR files in a directory also is a factor. Thus the number of classes directories and JAR files may increase as additional Java programs are installed.

Furthermore some Java programs may be executed repeatedly with different input data. These programs include programs that process a file of credit card transactions cumulative rainfall amounts seismic data images or other types of information. These repeatedly executed programs are either time sensitive or run on resources that are constrained by usage or time. If all directories and JAR files in the classpath environment variable are searched each time one of these programs is executed performance of the program may suffer.

Since the required classes must be loaded before the Java program can be executed it would be advantageous to have the classpath environment variable only contain relevant classes for the current Java program such that the time spent searching for the required classes in the classpath environment variable may be minimized.

A computer implemented method a data processing system and computer usable program code are provided for classpath optimization in a platform independent runtime environment. A required class is identified in an import statement in source code for a software program wherein the software program requires the required class. In a classpath environment variable an element containing the required class is identified to form an identified element. Using the identified element a new classpath environment variable is generated.

With reference now to the figures depicts a pictorial representation of a network of data processing systems in which aspects of the present invention may be implemented. Network data processing system is a network of computers in which embodiments of the present invention may be implemented. Network data processing system contains network which is the medium used to provide communication links between various devices and computers connected together within network data processing system . Network may include connections such as wire wireless communication links or fiber optic cables.

In the depicted example server and server connect to network along with storage . In addition clients and connect to network . These clients and may be for example personal computers or network computers. In the depicted example server provides data such as boot files operating system images and applications to clients and . Clients and are clients to server in this example. Network data processing system may include additional servers clients and other devices not shown.

In the depicted example network data processing system is the Internet with network representing a worldwide collection of networks and gateways that use the Transmission Control Protocol Internet Protocol TCP IP suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high speed data communication lines between major nodes or host computers consisting of thousands of commercial governmental educational and other computer systems that route data and messages. Of course network data processing system also may be implemented as a number of different types of networks such as for example an intranet a local area network LAN or a wide area network WAN . is intended as an example and not as an architectural limitation for different embodiments of the present invention.

With reference now to a block diagram of a data processing system is shown in which aspects of the present invention may be implemented. Data processing system is an example of a computer such as server or client in in which computer usable code or instructions implementing the processes for embodiments of the present invention may be located.

In the depicted example data processing system employs a hub architecture including north bridge and memory controller hub NB MCH and south bridge and input output I O controller hub SB ICH . Processing unit main memory and graphics processor are connected to NB MCH . Graphics processor may be connected to NB MCH through an accelerated graphics port AGP .

In the depicted example network adapter connects to SB ICH . Audio adapter keyboard and mouse adapter modem read only memory ROM universal serial bus USB ports and other ports and PCI PCIe devices connect to SB ICH through bus . PCI PCIe devices may include for example Ethernet adapters add in cards and PC cards for notebook computers. PCI uses a card bus controller while PCIe does not. ROM may be for example a flash binary input output system BIOS .

HDD and CD ROM drive connect to SB ICH through bus . HDD and CD ROM drive may use for example an integrated drive electronics IDE or serial advanced technology attachment SATA interface. Super I O SIO device may be connected to SB ICH .

An operating system runs on processing unit and coordinates and provides control of various components within data processing system in . As a client the operating system may be a commercially available operating system such as Microsoft Windows XP Microsoft and Windows are trademarks of Microsoft Corporation in the United States other countries or both . An object oriented programming system such as the Java programming system may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system Java is a trademark of Sun Microsystems Inc. in the United States other countries or both .

As a server data processing system may be for example an IBM eServer pSeries computer system running the Advanced Interactive Executive AIX operating system or the LINUX operating system eServer pSeries and AIX are trademarks of International Business Machines Corporation in the United States other countries or both while LINUX is a trademark of Linus Torvalds in the United States other countries or both . Data processing system may be a symmetric multiprocessor SMP system including a plurality of processors in processing unit . Alternatively a single processor system may be employed. Instructions for the operating system the object oriented programming system and applications or programs are located on storage devices such as HDD and may be loaded into main memory for execution by processing unit . The processes for embodiments of the present invention are performed by processing unit using computer usable program code which may be located in a memory such as for example main memory ROM or in one or more peripheral devices and .

Those of ordinary skill in the art will appreciate that the hardware in may vary depending on the implementation. Other internal hardware or peripheral devices such as flash memory equivalent non volatile memory or optical disk drives and the like may be used in addition to or in place of the hardware depicted in . Also the processes of the present invention may be applied to a multiprocessor data processing system.

In some illustrative examples data processing system may be a personal digital assistant PDA which is configured with flash memory to provide non volatile memory for storing operating system files and or user generated data.

A bus system may be comprised of one or more buses such as bus or bus as shown in . Of course the bus system may be implemented using any type of communication fabric or architecture that provides for a transfer of data between different components or devices attached to the fabric or architecture. A communication unit may include one or more devices used to transmit and receive data such as modem or network adapter as shown in . A memory may be for example main memory ROM or a cache such as found in NB MCH as shown in . The depicted examples in and above described examples are not meant to imply architectural limitations. For example data processing system also may be a tablet computer laptop computer or telephone device in addition to taking the form of a PDA.

With reference now to a block diagram illustrating the relationship of software components operating within a computer system that may implement the present invention. Java based system contains platform specific operating system that provides hardware and system support to software executing on a specific hardware platform. Java Virtual Machine JVM is one software application that may execute in conjunction with the operating system. JVM provides a Java run time environment with the ability to execute Java application or applet which is a program servlet or software component written in Java programming language. The computer system in which JVM operates may be similar to data processing system or network data processing system as described above. However JVM may be implemented in dedicated hardware on a so called Java chip Java on silicon or Java processor with an embedded pico Java core.

At the center of a Java run time environment is the JVM which supports all aspects of Java s environment including its architecture security features mobility across networks and platform independence. The JVM is a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only one platform for which the code was compiled. Java programs are compiled for the JVM . In this manner Java is able to support applications for many types of data processing systems which may contain a variety of central processing units and operating system architectures.

To enable a Java application to execute on different types of data processing systems a compiler typically generates an architecture neutral file format the compiled code is executable on many processors given the presence of the Java run time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture.

A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets the bytecode or bytecodes. The bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Bytecodes may be translated into native machine code by a just in time compiler or JIT.

The JVM loads the class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM . The class loader loads class files from an application and the class files from the Java application programming interfaces APIs which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.

One type of software based execution engine is the just in time compiler. With this type of execution the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVM s usually interpret bytecodes but JVM s may also use other techniques such as just in time compiling to execute bytecodes.

When an application is executed on the JVM that is implemented in software on a platform specific operating system a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language compiled to bytecodes and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.

With reference now to a block diagram of a JVM is depicted in accordance with an illustrative embodiment of the present invention. JVM includes class loader subsystem which is a mechanism for loading types such as classes and interfaces given fully qualified names. JVM also contains runtime data areas execution engine native method interface and memory management . Execution engine is a mechanism for executing instructions contained in methods of classes loaded by class loader subsystem . Execution engine may be for example Java interpreter or compiler . Native method interface allows access to resources in the underlying operating system. Native method interface may be for example the Java Native Interface JNI .

Runtime data areas contain native method stacks Java stacks PC registers method area and heap . These different data areas represent the organization of memory needed by JVM to execute a program.

Java stacks are used to store the state of Java method invocations. When a new thread is launched the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks it pushes and pops frames. The thread s Java stack stores the state of Java method invocations for the thread. The state of the Java method invocation includes its local variables the parameters with which it was invoked its return value if any and intermediate calculations. Java stacks are composed of stack frames. A stack frame contains a state of a single Java method invocation. When a thread invokes a method the JVM pushes a new frame onto the Java stack of the thread. When the method completes the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner the Java instruction set is well defined for a variety of platform architectures.

Program counter PC registers are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register and Java stack. If the thread is executing a JVM method the value of the PC register indicates the next instruction to execute. If the thread is executing a native method then the contents of the PC register are undefined. Native method stacks store the state of invocations of native methods. The state of native method invocations is stored in an implementation dependent way in native method stacks registers or other implementation dependent memory areas. In some JVM implementations native method stacks and Java stacks are combined.

Method area contains class data while heap contains all instantiated objects. The constant pool is located in method area in these examples. The JVM specification strictly defines data types and operations. Most JVM s choose to have one method area and one heap each of which are shared by all threads running inside the JVM such as JVM . When JVM loads a class file it parses information about a type from the binary data contained in the class file. JVM places this type of information into the method area. Each time a class instance or array is created the memory for the new object is allocated from heap . JVM includes an instruction that allocates memory space within the memory for heap but does not include instructions for freeing space within the memory. Memory management in the depicted example manages memory space within the memory allocated to heap . Memory management may include a garbage collector which automatically reclaims memory used by objects that are not referenced. Additionally a garbage collector also may move objects to reduce heap fragmentation.

Currently a Java class loader in class loader subsystem loads class files in order to execute a Java program. The Java class loader identifies class files that are required by the Java program by traversing classpath environment variable . Classpath environment variable tells the Java class loader in JVM where to find class files including user defined class files to load. The Java class loader traverses the classpath environment variable and examines all of the directories or JAR files in the classpath environment variable to determine if the required class files are present. However as the number of directories and JAR files to be examined increases in the classpath environment variable class loading efficiency suffers because there are more and more directories or JAR files to search through. In addition if the Java program is executed repeatedly the time spent on searching for the required classes may affect performance of the program.

Aspects of the present invention provide a computer implemented method data processing system and computer usable program code for classpath optimization by generating a new classpath environment variable that only includes elements containing classes that are required by a current Java program. These elements include directories and JAR files. In an illustrative embodiment aspects of the present invention may be implemented in a Java class loader within class loader subsystem of JVM in .

Turning now to a diagram illustrating a known script for setting the classpath environment variable is depicted. As shown in script sets the classpath environment variable to include every directory and JAR file that is in a user environment. This includes a library in home utexas staff mausolf mycondor directory each file in each jar file of the library and a rt.jar file in the usr java j2sdk1.4.105 jre lib directory . Thus everything in the user environment including all of the directories and JAR files are included in the classpath environment variable regardless of whether it is relevant to a current Java program.

Turning now to a diagram illustrating a known classpath environment variable generated using a known script is depicted. After script in is run classpath environment variable is generated. Classpath environment variable includes every directory and JAR file in the user environment including those that are not relevant to the current Java program.

To avoid examining all directories or JAR files identified in the classpath environment variable that are irrelevant to the program the aspects of the present invention generate a new classpath environment variable by including only those directories or JAR files that contain classes that are required by the current Java program. The aspects of the present invention generate the new classpath environment variable by examining the import statements in the source code for the current Java program and removing directories or JAR files that do not contain classes identified in the import statements. An import statement includes the source code of another file into the source code of the current file.

The import statements in the source code specify classes that are required for the Java program. For example import com.ibm.my project. statement indicates all class files within the directory com ibm my project are required for the Java program. If dependencies exist in the required class files of the import statements the aspects of the present invention examine the required class files themselves in a recursive manner until all required classes are identified. In order to identify directories or JAR files in the import statements to be removed aspects of the present invention examine each of the import statements to identify the required class files.

Next the aspects of the present invention search each directory identified in the classpath environment variable for the required class files. If none of the required class files are present in the directory the fully qualified name of the JAR file in the directory is removed from the classpath environment variable. If the classpath environment variable includes JAR files the aspects of the present invention search each JAR file identified in the classpath environment variable for the required class files by utilizing a jar tvf command. The jar tvf command lists the content of a JAR file. If none of the required class files is present in the JAR file the JAR file is removed from the classpath environment variable.

The aspects of the present invention continue to search for the required class files until the required class files are located. Once all of the required class files in the import statements are located a new classpath environment variable is generated with the remaining directories or JAR files in the classpath environment variable. In other words the new classpath environment variable only includes those directories or JAR files that contain the required classes. In this way the time spent searching for the required classes in the classpath environment variable may be minimized and the Java class loader may locate and load the required classes faster.

Turning now to a diagram illustrating a known classpath environment variable is depicted. As shown in classpath environment variable identifies two directories where the JVM may find the class files. In this example the two directories are user local classes and user local lib . Within each of the two directories there may be hundreds of class files and libraries. Thus searching through the two directories for class files at runtime may be time consuming.

Turning now to a diagram illustrating a known Java program source file is depicted. As shown in Java program source code includes two import statements which indicate the class files that are required by the current Java program. The two import statements are import statements and . Import statement indicates that class file com.ibm.my project.registration is required. Import statement indicates that class file com.ibm.my project.utilities is required.

Currently the Java class loader searches through hundreds of class files and libraries in directories and in to find the required class files as indicated in import statements and in . In order to avoid searching through all of the files and libraries aspects of the present invention generate a new classpath environment variable that includes only directories and JAR files that contain the required class files such that the search time may be reduced.

In order to generate the new classpath environment variable aspects of the present invention examine each of import statements and in to identify required class files com.ibm.my project.registration and com.ibm.my project.utilities. Next the aspects of the present invention search each directory identified in the classpath environment variable user local classes and user local lib for the required class files. If none of the required class files are present in the directory the fully qualified name of a JAR file in the directory is removed from the classpath environment variable. For example if no com.ibm directory exists in user local classes the fully qualified name of the JAR file in user local classes directory is removed from the classpath environment variable such that the directory would not be searched by the Java class loader.

On the other hand user local lib includes a plurality of JAR files including my project.jar. The aspects of the present invention search each JAR file identified in user local lib for the required class files by utilizing a jar tvf command. The jar tvf command lists the contents of a JAR file. For example a jar tvf grep com.ibm.my project command is used to list the contents of the my project.jar.

Based on the list of contents the aspects of the present invention determine if the required class files com.ibm.my project.registration and com.ibm.my project.utilities are present in my project.jar. If the required class files are absent the fully qualified path name of the jar file in the directory is removed from the classpath environment variable. However if the required class files are present a new classpath environment variable is generated with only the directories or JAR files that contain the required class files.

Turning now to a diagram illustrating an exemplary classpath environment variable is depicted in accordance with an illustrative embodiment of the present invention. As shown in new classpath environment variable is generated by the aspects of the present invention after traversing classpath environment variable and removing any directories or JAR files that do not contain the required class files for the current Java program as described above.

New classpath environment variable includes only two JAR files user local lib runtime.jar and user local lib my project.jar . In this example runtime.jar is needed by the Java runtime environment. My project.jar is a single JAR file that is required by program . Instead of searching through hundreds of class files and libraries in user local classes and each JAR file in user local lib as shown in the Java class loader may simply load runtime.jar and my project.jar to execute program . Once the new classpath environment variable is generated it may be stored in a classpath file with a name of the current Java program and a .classpath extension. For example test.classpath.

In one illustrative embodiment when the user invokes the program such as program the program is manually invoked by using a java c command with the parameter new classpath program name. For example java c test.classpath test . The java c command specifies the classpath to be used by the Java class loader. In an alternative embodiment when the user invokes the program the Java runtime environment looks for a classpath file with the program name test followed by the .classpath extension. If the classpath file is found the new classpath environment variable is set for the program and the program is invoked using the new classpath environment variable. However if the classpath file is not found the aspects of the present invention may generate a new classpath file automatically according to the steps as described above. The aspect of the present invention then uses the new classpath file to invoke the program and save the classpath file with a .classpath extension for subsequent use. However the automatic generation of the optimized classpath environment variable is optional. For programs that are run infrequently the user may not want the overhead of optimizing the classpath environment variable each time the program is run. On the other hand if the program is invoked frequently and is time sensitive the user may want to optimize the classpath environment variable such that each subsequent execution of the program will take less time and be more efficient. This efficiency is achieved because the optimized classpath environment variable is only generated once for the program but is subsequently used each time the program is run.

Turning now to a flowchart of an exemplary process for classpath environment variable optimization is depicted in accordance with an illustrative embodiment of the present invention. This process may be implemented within a Java class loader within a class loader subsystem such as class loader subsystem of JVM in .

As shown in from the perspective of the Java class loader the process begins when aspects of the present invention examine the import statements of the Java program to identify class files that are required by the program step . Next aspects of the present invention search the next directory that is identified in the classpath environment variable for the required class files step . A determination is made by aspects of the present invention as to whether the directory contains the required class files step . If the directory contains the required class files the directory is included in the new classpath environment variable step . If the directory does not contain the required class files the aspects of the present invention remove the fully qualified name of the JAR file in the directory from the classpath environment variable step .

A determination is then made as to whether additional directories are present in the classpath environment variable step . If additional directories are present the process returns to step to search the next directory for the required class files. However if additional directories are not present the aspects of the present invention search the next JAR file identified in the classpath environment variable for the required class files using the jar tvf command step . The jar tvf command lists the contents of the JAR file.

A determination is then made as to whether the contents of the JAR file contain the required class files step . If the JAR file contains the required class files the JAR file is included in the new classpath environment variable step . If the JAR file does not contain the required class files the aspects of the present invention remove the JAR file from the classpath environment variable step .

Next a determination is made as to whether additional JAR files are present in the classpath environment variable step . If additional directories are present the process returns to step to search the next JAR file for the required class files. However if additional JAR files are not present the aspects of the present invention generate the new classpath environment variable with the directories and JAR files that contain the required class files step . The new classpath environment variable is then stored in a classpath file with the program name and .classpath extension step .

Later when the user invokes the Java program step in one embodiment the Java runtime environment looks for a classpath file with a program name followed by a .classpath extension step . A determination is made by the Java runtime environment as to whether the classpath file exists step . If the classpath file exists the program is invoked by using a Java c new classpath program name command step . The new classpath is the name of the classpath file stored with the new classpath environment variable in step . Thus the process terminates thereafter. However if the classpath file does not exist the process may return to step and repeat the steps to automatically generate a new classpath environment variable. Instead of having to search through all of the directories and JAR files in the classpath environment variable each time a repeatedly executed program is executed the new classpath environment variable in the classpath file may be used repeatedly by the Java runtime environment.

It is noted that automatic generation of a new classpath environment variable is optional. For programs that are run infrequently the user may not want the overhead of optimizing the classpath environment variable. On the other hand if the program is invoked frequently and is time sensitive the user may want to optimize the classpath environment variable such that each subsequent execution of the program will be more efficient. This efficiency is achieved because the optimized classpath environment variable is only generated once for the program but is subsequently used each time the program is run. Thus the optimized classpath environment variable does not have to be generated for a program that is run infrequently or that is not time sensitive.

In addition to including only directories and JAR files that contain the required classes other types of classpath optimizations may be performed. For example the classpath environment variable may be reordered starting from directories or JAR files with the highest number of classes to directories or JAR files with the lowest number of classes. By reordering the classpath environment variable based on the number of classes the directories or JAR files contain the likelihood that the required class files are found early in the search process is increased because the probability that the required classes are found is higher in a bigger set of directories and JAR files than a smaller set of directories and JAR files. This optimization decreases the search time of the Java class loader and the execution time of the program hence improves the program performance.

Turning now to an exemplary implementation of classpath environment variable optimization is depicted in accordance with an illustrative embodiment of the present invention. This exemplary implementation utilizes the process as depicted in . As shown in the optimization process begins when a user invokes an optimization command javaOptCp to optimize the classpath environment variable for a Java program named my program.java step . Java source file includes two import statements which specify two required class files com.ibm.my project.registration and com.ibm.my project.utilities .

Upon receiving the javaOptCp command aspects of the present invention identify the required classes in the import section in source code of Java source file step . The aspects of the present invention then locate the required classes in the directories as specified by classpath environment variable step . Classpath environment variable includes directories and JAR files that are required by different Java programs. Once the required classes are located the aspects of the present invention remove the directories that do not contain required classes from the classpath environment variable step since these directories are not required for this particular program my program.java. New classpath environment variable is generated by aspects of the present invention as a result which includes only the home mausolf dev directory.

Aspects of the present invention then save the new classpath environment variable in an optimized classpath file with the same filename as the Java program but with a .classpath extension step . In this example implementation the optimized classpath file is My program.classpath . Once the new classpath environment variable is saved in the classpath file the classpath optimization process completes.

Later the user invokes the Java program by using a javaOpt command step . The javaOpt command looks for a classpath file with a .classpath extension of the program name. If the classpath file is found the command sets the program classpath to the new classpath environment variable in the classpath file by calling a java classpath command. By using the javaOpt command search time by the Java class loader may be minimized. The program then executes and the program invocation process terminates.

It is noted that classpath optimization steps and in are executed only once to optimize the classpath while program invocation step in may be executed multiple times for a program that is executed repeatedly. It is also noted that the classpath file is unique to a program. Thus each program is associated with a different classpath file.

In summary the aspects of the present invention optimize Java program performance in particular repeatedly executed Java program performances by dynamically filtering and reordering the classpath. The aspects of the present invention create an optimized classpath that is specific to a particular program in advance of program execution. Furthermore the aspects of the present invention may be integrated with enterprise development tools such as Eclipse to optimize the performance of programs during their development. In this manner the optimized classpath may be deployed all of the way from the development phase to production phase along with the application such that the optimization is separate from the time sensitive processing of the production resources.

The invention can take the form of an entirely hardware embodiment an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment the invention is implemented in software which includes but is not limited to firmware resident software microcode etc.

Furthermore the invention can take the form of a computer program product accessible from a computer usable or computer readable medium providing program code for use by or in connection with a computer or any instruction execution system. For the purposes of this description a computer usable or computer readable medium can be any apparatus that can contain store communicate propagate or transport the program for use by or in connection with the instruction execution system apparatus or device.

The medium can be an electronic magnetic optical electromagnetic infrared or semiconductor system or apparatus or device or a propagation medium. Examples of a computer readable medium include a semiconductor or solid state memory magnetic tape a removable computer diskette a random access memory RAM a read only memory ROM a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk read only memory CD ROM compact disk read write CD R W and digital video disc DVD .

A data processing system suitable for storing and or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code bulk storage and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution.

Input output or I O devices including but not limited to keyboards displays pointing devices etc. can be coupled to the system either directly or through intervening I O controllers.

Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems cable modems and Ethernet cards are just a few of the currently available types of network adapters.

The description of the present invention has been presented for purposes of illustration and description and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention the practical application and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.

