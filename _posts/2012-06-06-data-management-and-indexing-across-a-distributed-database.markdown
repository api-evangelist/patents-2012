---

title: Data management and indexing across a distributed database
abstract: In one embodiment, a distributed database system supporting flexible configuration of data clusters is disclosed. The system includes a cluster manager, an index, and a dataset distributed over one or more database clusters. Where the nodes of the clusters may report ownership of a particular range, the index contains an alternate range. The cluster manager receives requests to access a range of data within database and queries the index to determine the appropriate nodes and/or clusters with which to connect. The cluster manager then directs the requestor to connect to the specified nodes and/or clusters.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08965921&OS=08965921&RS=08965921
owner: Rackspace US, Inc.
number: 08965921
owner_city: San Antonio
owner_country: US
publication_date: 20120606
---
The present disclosure relates generally to cloud computing and more particularly to a scalable distributed data management system utilizing load balancing techniques including data distribution and distributed indexing to leverage a cloud computing system.

Cloud computing services can provide computational capacity data access networking routing and storage services via a large pool of shared resources operated by a cloud computing provider. Because the computing resources are delivered over a network cloud computing is location independent computing with all resources being provided to end users on demand with control of the physical resources separated from control of the computing resources.

Cloud computing is a model for enabling access to a shared collection of computing resources networks for transfer servers for storage and applications or services for completing work. More specifically the term cloud computing describes a consumption and delivery model for IT services based on the Internet and it typically involves over the Internet provisioning of dynamically scalable and often virtualized resources. This frequently takes the form of web based tools or applications that users can access and use through a web browser as if it was a program installed locally on their own computer. Details are abstracted from consumers who no longer have need for expertise in or control over the technology infrastructure in the cloud that supports them. Most cloud computing infrastructures consist of services delivered through common centers and built on servers. Clouds often appear as single points of access for consumers computing needs and do not require end user knowledge of the physical location and configuration of the system that delivers the services.

The utility model of cloud computing is useful because many of the computers in place in data centers today are underutilized in computing power and networking bandwidth. People may briefly need a large amount of computing capacity to complete a computation for example but may not need the computing power once the computation is done. The cloud computing utility model provides computing resources on an on demand basis with the flexibility to redistribute resources automatically or with little intervention.

The flexibility of the cloud lends itself to a number of solutions for storing retrieving and analyzing large datasets. Relational database management systems RDBMS are data management systems designed to handle large amounts of interrelated data. RDBMS organize related data into tables optimized for rapid access of data while maintaining core requirements of atomicity the requirement that a transaction be entirely successful and that changes made by a partially successful transaction be reverted consistency the requirement that transactions must not violate specified database consistency checks isolation the requirement that no transaction can interfere with another transaction and durability the requirement that committed transactions be written to a permanent location instead of for example a buffer . Many RDMBS protocols support splitting large amounts of data over multiple computing nodes. In a horizontally distributed environment transaction data may be stored among multiple nodes whereas in a vertically distributed environment the data may be replicated at multiple nodes. As can be seen the task of achieving reasonable query performance in a distributed network while maintaining atomicity consistency isolation and durability is non trivial. Challenges inherent in the task have necessitated tradeoffs that make distributed RDBMS suit some applications better than others.

Due in part to these tradeoffs a number of NoSQL type systems have emerged. These systems soften the requirements of a relational database in exchange for increased performance. Abandoning certain RDBMS tenets has the ability to pay dividends particularly in a distributed environment. For example a NoSQL system may employ an eventual consistency model to improve data transactions. Under an eventual consistency model transaction results will propagate to appropriate data locations eventually as opposed to arriving at a guaranteed time. Propagating results and synchronizing data requires considerable overhead and deprioritizing certain writes can relieve burden on the hardware including storage element and the supporting network. It can also improve query response time.

Based on the intended use and associated design considerations NoSQL systems utilize a variety of different mechanisms to distribute data over a set of compute nodes. These mechanisms lead to partitioning rules such as a minimum level of granularity when partitioning data between computing systems. On the other hand cloud computing is uniquely suited to rapid and dynamic creation reconfiguration and destruction of computing systems. Data management architectures with greater flexibility and capable of efficient balancing and scaling can better leverage the ephemeral resources available within the cloud. Accordingly it is desirable to provide a better functioning data management system capable of maximizing cloud computing resources while providing improved query efficiency and data capacity.

The following disclosure has reference to database structure and management in a distributed computing environment such as a cloud architecture.

The API may also perform one or more gatekeeping functions. Under its gatekeeping role the API may perform permission verification data encryption data compression and or apply other suitable transformation to communications based on a global policy a client or system identifier or another trigger. In some embodiments particularly well suited to a cloud environment the API may enforce a security policy. Cloud environments may restrict client commands based on a permission set associated with a client and described in the security policy. The API may verify that communications particularly commands but also data and other communications between the client and the system are permissible based on the security policy. In an embodiment the security policy directs the API to reject certain client communications. In an embodiment the security policy directs the API to apply one of a number of possible translations to a client command based on the client s permission set. In an embodiment the security policy directs the API to encrypt communications between the client and the system . In some embodiments the API contains and manages the security policy directly. Conversely the security policy may be maintained at least in part on a separate security policy master. In one embodiment the API the policy master and or the security policy is used to provide a US eAuthentication compatible federated authentication system to achieve access controls and limits based on traditional operational roles. In a further embodiment the implementation of an auditing API provides the necessary environment to receive a certification under FIPS 199 Moderate classification for a hybrid cloud environment.

Referring still to the API is in communication with the database cluster . The cluster is a set of one or more database nodes of which nodes and are examples . Each node represents a computing resource capable of storing and manipulating at least a part of the dataset. Nodes may represent computing hardware such as processors storage devices and or network interfaces and may also represent virtualized instances of computing hardware. In a cloud environment nodes having virtualized hardware are especially common. For instance a single enterprise class processor may be presented as a dozen or more virtual processors utilized in a multitude of nodes . Virtualization and other techniques can also combine hardware into a unified virtual construct. For example multiple storage devices may be presented as a single unified storage device. Particularly in but not limited to environments with rapid dynamic resource allocation a complex relationship between physical resources virtual resources and nodes emerges. In various embodiments nodes comprise any number and or any portion of any type of resource both real and virtual.

In the course of receiving a client command the API forwards the command and any associated data to one or more of the nodes . In an embodiment the API communicates with the node directly. A coordinating node for example node receives and processes the client command. If the target data is within the node s dataset the node may perform the transaction. Otherwise the command is propagated to the appropriate node . In some examples the coordinating node acts as a proxy for other nodes if the target data is not within the node s dataset. That is to say the coordinating node forwards the command to the target node for example node for processing. Any response is then transmitted from the target node back to the API through the coordinating node . In the alternative the coordinating node may hand off the command to the target node and task the target node with transmitting any reply to the API .

In some embodiments any node may receive commands from a requestor such as the API and thereby act as a coordinating node. This may be referred to as server symmetry or a cluster of peers. In other embodiments one or more nodes are hidden from direct access and cannot receive commands from for example a client . In embodiments with multiple potential coordinating nodes determining a coordinating node may turn on an attribute of the node an attribute of the data stored within the node an attribute of the network and or other suitable criteria. For example a coordinating node may be selected based in part on the node s processing power. In another example a coordinating node is selected based in part on the access frequency of data stored within the node. In some applications it may be advantageous to select a coordinating node that is infrequently accessed for load balancing purposes or it may be advantageous to select a coordinating node that is frequently accessed to increase the chance that the target data will be stored within the node. In another example a coordinating node is selected based in part on the network latency between the node and the requestor. In a further example the coordinating node is selected based in part on some other node metric such as the scheduled maintenance of another node .

In some embodiments the API does not communicated directly with the nodes . In one such embodiment a separate computing resource referred to as the load balancer receives the client command from the API determines a target node and or a coordinating node and acts as a proxy for communications with the cluster . As with the nodes the load balancer may contain any combination of virtual and physical computing resources including processing resources storage resources I O resources and network resources. The exact allocation of resources may vary dynamically according to workload performance network load and or other metrics. In many embodiments the load balancer relieves the nodes of compute burdens including data filtering target resolution and or acting as a proxy and thereby improves cluster response time.

Each database protocol may utilize slightly different terminology to express certain underlying concepts. Exemplary systems will be examined in detail to illustrate the concepts therein. From these examples equivalent concepts and terms can be recognized in other database architectures. Thus in the interest of conciseness embodiments will be described utilizing generic terms for concepts that may be applied to any relevant architecture.

Cassandra a trademark of Apache Software Foundation is one such distributed database system. Cassandra stores data in units called columns. Each column is a tuple a list of associated data elements. The basic column format can be represented as name value timestamp . For brevity the timestamp while an essential element of the column is often not written. Thus an example column may be written UserName User1 . An optional level of hierarchy called a super column may incorporate any number of columns. Moving up a level keys sometimes referred to as rows are tuples consisting of a name and one or more columns or super columns. An example key may be written Status Key UserName User1 Logged In Y . Any number of keys may be grouped into a column family. Analogously a group of column families is referred to as the keyspace the final level of hierarchy. A pseudocode representation of the relationship could be constructed as 

The particular allocation of keys may be determined by an allocation algorithm with two common algorithms being RandomPartitioner RP and OrderPreservingPartitioner OPP . RandomPartitioner does not allocate data by keys directly and instead utilizes an MD5 hash of the key to assign a hexadecimal number to each key. Each node on the ring has an associated numerical range based on a node token. For example if node is associated with a range of 100 200 then data stored under keys with an MD5 hash between these two values will be assigned to node . In contrast OrderPreservingPartitioner and other ordering partitioners utilize a sequential ordering of the key names such as alphanumeric under OPP. Under an OPP algorithm node may be associated with a range of b d . Data stored under a key with a name that falls within the range is assigned to the respective node . Because of the ring structure another node can be added under either algorithm with minimal adjustment to the ranges of the other nodes . One method for adding a node assigns half of the keys associated with the busiest existing node to the new node . This only requires modifying the range of one existing node i.e. the busiest node .

Another form of data distribution is replication. Replication creates nearly identical data sets on multiple nodes. Referring to node is a replica of node . Replication allows node to assume some of the load of node . Unlike some other architectures Cassandra does not utilize a primary or master replica. Each node remains a peer of all other nodes . For writes the write command is sent to all replicas in the illustrated cluster both nodes and . However not all nodes need to respond with an acknowledgement in order for the write to be successful. Based on the configuration of the cluster a success at as few as one of the replicated nodes will suffice. Nodes that were not successful are updated and made consistent later as resources allow. For reads the requestor may have the option to select the consistency level of the data within the read request command. In other words the requestor may elect to accept the data provided by first node to respond or may request that the coordinating node verify the data against other replicated nodes . If the data conflicts the latest data is provide to the requestor and nodes with older data are updated. This is referred to as a read repair process.

MongoDB a registered trademark of 10gen Inc. is also a distributed database system. The basic data element in MongoDB is a document. A document is an ordered list of one or more key value pairs. A simple document might be represented as UserName User1 Logged In Y . Unlike a column a document can contain any number of elements the elements being key value pairs. In contrast to the fixed four or five levels of hierarchy utilized by Cassandra MongoDB provides more flexible data structures. Levels of hierarchy are created by embedding a document within the value field of a key value pair of a parent document. Traversing the hierarchy upwards top level documents are incorporated into collections. Collections may be divided into sub collections of documents but this is not required. At the highest level of hierarchy the collections are grouped into a database which is roughly analogous to a keyspace in Cassandra . Thus a pseudocode representation of a MongoDB database may be as simple as 

Still referring to node is a replica of node . Under one common replication scheme master slave replication one of the nodes for example node is designated the master node. Only the master node can receive data writes directly. This ensures that the master node has a current and coherent data set. Slave nodes do not receive write requests directly from the clients and may be hidden meaning that they do not receive read commands. In other implementations clients will be able to read directly from slave nodes. A recent alternative to master slave replication is a replica set. This type of replication changes how a master node in this configuration referred to as a primary node and slave nodes here referred to as secondary nodes are determined yet with respect to most read and write handling replica set implementations closely resemble master slave systems.

From these examples several general concepts emerge which may be applied to other database protocols and implementations. is a schematic diagram illustrating a data warehouse database system according to aspects of the present disclosure. The system includes a dataset distributed over a number of nodes within a cluster . The nodes may be organized according to any suitable database protocol including Cassandra and MongoDB as well as HBase a trademark of Apache Software Foundation CouchDB a trademark of Apache Software Foundation Riak a trademark of Basho Technologies Inc. and other suitable protocols.

As one example of a typical process that may attempt to perform a database read the system includes a query parser . The query parser receives query commands and initiates data gathering tasks based on the commands. In this way the query parser provides another layer of abstraction insulating the requestor here the API from the particular implementation of the database cluster . The query commands received by the query parser may include client commands received by an API as well as query commands from other sources. In various embodiments the query parser creates one or more data gathering tasks by translating a query command into an instruction set consistent with the database architecture of the cluster . In some such embodiments translating a query command includes translating expressions including regular expression Boolean expressions natural language queries and other expression within the query command. In an embodiment the query parser uses default values for fields or parameters not specified by the query command. In a further embodiment the query parser performs a semantic validation of the query command as part of structuring the data gathering tasks. This may include database reference resolving determining whether requested data exists within the dataset . Validation may include verifying that data types match between the query command and the target data. Validation may also include determining whether the issuer of the query command has permission to access the target data. In an embodiment utilizing a security policy to determine the issuer s permissions the security policy is maintained at least in part on a separate security policy master. In an embodiment once the query command has been decomposed into data gathering tasks and validated if necessary the query parser executes the data gathering tasks.

These tasks commonly involve reading data from the database cluster . In order for the query parser to extract the data from the distributed nodes within the cluster the query parser requests a connection from the cluster manager . The cluster manager refers to the cluster index and determines the configuration of the nodes . The configuration is then analyzed based on one or more criteria to create a connection list. In some embodiments the connection request from the query parser provides the cluster manager with information about the underlying query task. In some such embodiments the cluster manager structures the connection list based at least in part on the nature of the query. For example in response to a query task that seeks to retrieve data stored under a specific key the cluster manager may compare the specified key with the key ranges of the nodes and list the node having the strongest association with the specified key. The strongest association may mean that the node contains the data or that the node is a designated proxy for the data holder. In an embodiment a connecting node is listed based at least in part on an attribute of the node such as performance available resources workload the node s visibility status and or other node attributes. In another embodiment the connecting node is provided based at least in part on an attribute of the data such as frequency of access coherency data integrity data age access permissions and or other data attributes. In yet another embodiment a connecting node is selected based on a combination of an attribute of the query an attribute of a node and or an attribute of a node s dataset.

The cluster manager may provide the assembled connection list to the query parser and allow the query parser to establish the connections directly. In other embodiments a designated proxy resource which may be the cluster manager establishes communications based on the connection list and relays commands between the query parser and the designated nodes . In some embodiments the connection list contains more than one node in which case the nodes are accessed sequentially in parallel in combination and or in the alternative. Based on the connection list the query parser is connected either directly or through an intermediary to the listed nodes . In some embodiments especially those utilizing a cluster of peer nodes one or more of the specified nodes may be a coordinating node that acts as a proxy for other nodes within the cluster. In such embodiments the coordinating node routes data between the target node and the query parser .

After the node or nodes have attempted to retrieve the requested data one or more responses are passed back to the query parser . A response may include the requested data and may also include status indicators and or ancillary data such as the time of the last update to the data. The parser receives the response and may perform additional translation modification and or verification steps before forwarding it to provider of the query instruction. In an embodiment such as one employing read repair processes the query parser instructs a node to update its dataset based on the data contained within a response. In various embodiments the parser aggregates data within a response set filters data within the response set verifies that the returned data s type and format match the query verifies that the returned data is within the client s permission level performs other suitable alteration and or performs some combination thereof. In an embodiment the parser translates the response into a response set recognized and supported by the API to be passed on to the client . In an embodiment the parser forwards the response set to another computing process or computing resource such as an Extract Transform and Load process.

By utilizing the cluster manager to determine the coordinating node or nodes the query parser achieves a certain degree of insulation from the particular node arrangement and architecture and from the distribution of data throughout the cluster . From the parser s perspective an access or connection point is provided via a known proxy a connection list or another mechanism and from this query responses can be expected without further consideration of the cluster topography. In some applications this allows the query parser to be migrated to remarkably different database environments without modification.

The system may also include an Extract Transform and Load ETL process . The ETL process exemplifies a set of processes that may attempt to write data to the cluster . The ETL process receives a variety of ETL commands for example client write commands from sources including the API . A typical flow for executing an ETL command by the ETL process involves building an index of data to be extracted extracting data validating the extracted data performing one or more transformations to the extracted data staging the transformed data for writing creating an audit log loading writing the staged data to the cluster and removing transient data structures. For the purposes of this disclosure method used by the ETL process to write data to the cluster will be explored in detail.

Prior to writing to the cluster the ETL process requests a connection from the cluster manager . As disclosed in the context of the query parser the cluster manager utilizes the cluster index to determine the configuration of the nodes . The cluster manager may compile a connection list based on the node configuration as well as on any combination of request attributes node attributes and data attributes. As with query reads the ETL process may supply the cluster manager with information about the data to be written. For example a key value for the data may be specified. In this example a connecting node may be included in the list based at least in part on the key being within a node s key range. In an embodiment the connecting node is listed based at least in part on an attribute of the node such as performance available resources workload the node s visibility status the node being a designated master or slave and or other node attributes. In another embodiment the connecting node is listed based at least in part on an attribute of the data such as frequency of access coherency data integrity data age access permissions and or other data attributes. In some embodiments the cluster manager provides the ETL process with a list containing more than one node in which case the nodes may be accessed in sequentially parallel in combination and or in the alternative.

Connections are established between the ETL process and one or more nodes based on the connection list created by the cluster manager . In the illustrated embodiment the ETL process connects to the nodes directly. However in alternate embodiments the cluster manager or another designated proxy may forward instructions to the nodes . Designated proxies may include peer nodes acting as coordinating nodes for a target node. In such embodiments the coordinating node routes data between the target node and the ETL process . Upon completion of the database write whether successful or unsuccessful a target node may send the ETL process a reply that may include a confirmation flag. In an embodiment the ETL process utilizes one or more replies to generate a status response. The status response is then sent to the ETL command initiator. As it does for read processes the cluster manager insulates the ETL process from the particular node arrangement and from the particular distribution of data throughout the cluster .

There are numerous advantages to the database system in addition to the aforementioned benefits of providing a simplified interface between read and write processes and the cluster . The cluster manager provides an additional level of abstraction between the cluster and data processes. This abstraction allows the cluster to be reconfigured without disrupting reads and writes. These changes to the cluster can include adding additional resources rebalancing existing resources and or accommodating failing resources. A secondary node may be promoted to a primary node or a hidden node may be made readable. In some embodiments the cluster manager supports more extensive changes to the cluster topography such as moving from a single node implementation to a distributed cluster without modifying read and write processes. Another significant advantage of this particular system is the ability to add additional clusters as the dataset evolves. The strength of cloud computing architectures lies in the rapid rebalancing of system resources. The value of a dynamically scalable database that accommodates changes to the cluster topography without requiring modifications to the processes accessing the cluster cannot be overstated.

The cluster manager also allows data to be distributed among the nodes in a manner different from the scheme supported by the database protocol. If a hypothetical Cassandra type database protocol distributes data according to key values the cluster manager can further split data at the column level. For example a first node may be assigned a subset of columns under a key and a second node may be assigned a second subset of columns under the same key. In this example the cluster manager determines from the underlying read or write request whether to add the first node the second node or both to the connection list based on the column range in the request. To the database software implemented on the node it may appear that the node stores a complete set of column data under the key. In this way the node can be said to be unaware that the key has been split. There are many potential benefits to providing this additional level of control for data distribution. In some embodiments the database protocol imposes a maximum data size or number of entries that may be stored on a node . Thus a more flexible distribution system allows for larger data sets. In some embodiments a number of smaller nodes are quicker to replicate and synchronize than an equivalent large node. In some embodiments a high traffic key has high traffic columns and low traffic columns. By isolating the high traffic columns the frequently accessed data can be replicated without replicating low traffic data. This avoids wasting resources by duplicating infrequently accessed data and instead directs resources where they may be most useful.

In block the particular configuration and topography of the nodes within the cluster are analyzed. In the example it is determined that Node6 is a proxy for Node5. In block a connection list is assembled based on such factors as the cluster topography the resources allocated to the nodes the configuration of the nodes the cluster workload the attributes of the underlying access command the nature of the data set and or other relevant criteria. In the example Node6 is added to the connection list as a proxy for Node5 which contains the target data. In block a connection is established between the requesting process and the designated node or nodes. In an embodiment the requesting process connects directly to one or more designated nodes. In a further embodiment an intermediary such as a proxy is utilized to relay commands between the nodes and the requesting process. In block the index is updated if necessary. In some embodiments the node or the requestor updates the index directly. In some embodiments the node or the requestor instructs the cluster manager to update the index.

Another example demonstrates how the method can be used to parse a read request that is not supported by the database protocol. In this example a read request attempts to query data using a lower level of hierarchy than the database protocol supports. A read request is received to read Col A Col G under Keyspace1 Column Family1 Key1 . In this example the database protocol does not allow queries on a subset of columns within a key. However the system and index can be structured to allow such queries. In response to the read request the index is queried using the key Keyspace1 Column Family1. This returns a list of columns of the form Name Value where Name is a key and column range and value is the node containing data stored under the key and column range. In the example the query of the index database returns Key1 Cols A thru D Node15 Key1 Cols E thru K Node20 Key1 Cols L thru Z Node25 . When the index results are analyzed it is determined that the requestor need only query nodes 15 and 20. These nodes are included in the connection lists. This eliminates an unnecessary query of node 25. Culling unnecessary queries improves request response time reduces load on the database cluster reduces network load and reduces load on the requestor. Limiting the query to relevant nodes may also reduce the amount of data that must be filtered or analyzed. This in turn may reduce the resources that need to be allocated to the requestor. For these and other reasons the method provides numerous advantages over traditional distributed database management methods.

The system includes a query parser as an example of a process that may initiate reads to the dataset. To perform a read the query parser requests a connection list from the cluster manager . The cluster manager refers to the cluster index and determines the configuration of the nodes . In the illustrated embodiment the index contains configuration data on both clusters and . Based in part on the index as well as other criteria such as attributes of the query task of the nodes of the dataset and or other suitable attributes or criteria the cluster manager returns a connection list to the query parser . In configurations having multiple clusters the connection list may specify one or more nodes and or may specify one or more clusters. In an embodiment the connection list includes nodes within both cluster and cluster . The query parser then utilizes the connection list provided by the cluster manager to establish the specified connections either directly or through a proxy. In an exemplary embodiment where the connection list includes a cluster but not a node the query parser selects and connects to a node within the cluster according to a procedure established in the database protocol. Once the connection is established the execution of the read request is performed substantially similar to that of system . In some embodiments the procedures for requesting a connection and executing a read request are the same for single cluster system and multiple cluster system . In one such example a single query parser is used in both a single cluster system and a multiple cluster system .

The system also includes an ETL process as an example of a process that may initiate writes to the dataset. Similar to the query parser the ETL process requests a connection list from the cluster manager in response to an ETL command. The cluster manager queries the index analyzes the topography of the associated data clusters and assembles a connection list containing a combination of nodes and clusters . The ETL process utilizes the connection list to form the specified connections. In an embodiment the execution of the ETL command is performed substantially similar to that described with referenced to single cluster system . In some embodiments the procedures for requesting a connection and executing an ETL command are the same for single cluster system and multiple cluster system . In one such example an ETL process is used in both a single cluster system and a multiple cluster system .

As can be seen in some embodiments both read and write processes may establish connections to database based on the identity of the node and regardless of the cluster . Moreover coordination is not required between the clusters. Because of this the operation of the query parser the ETL process and the nodes need not depend on any particular cluster structure nor do those elements even need to be aware of additional clusters. Instead in such embodiments the index performs the bulk of the cluster management. This can be seen in an example. In one example the clusters utilize a protocol similar to Cassandra . A query task attempts to perform a read of data stored under the key UserName. A first node belonging to cluster has a key range of T V and a second node belonging to cluster has an overlapping key range of R Z . However in the example data under UserName is only stored within the node of cluster . In the simplest implementation the cluster manager will provide a list with both the first and second nodes and the query parser will attempt to query both. The query to the node of cluster will return the data requested whereas the query to the node of cluster will fail or return nothing. However a more optimized implementation will utilize the index to store cluster identifiers for particular keys. For example the index may store a name value pair of UserName cluster . The cluster manager may then use this data to assemble a connection list including cluster

A system incorporating multiple database clusters offers several advantages. A protocol may have a maximum number of nodes in a cluster thus providing multiple clusters allows the system to incorporate additional nodes beyond the maximum. In some embodiments the computing resources may render it more efficient to group data into clusters . For example data that is frequently accessed together such as data stored under related keys may be grouped in the same cluster . Alternately in some environments it may be more efficiently to divide data that is frequently accessed together across clusters in order to parallelize transactions. Another advantage is additional distribution granularity. As stated previously each database protocol has a level of hierarchy used to divide data between nodes . For example in Cassandra data may be distributed based on key. One notable advantage of the system is that the index may be structured to distribute data based on an alternate hierarchy level such as a column or super column. Even in a cloud environment resources do not always scale effortlessly. Supporting a large node may require grouping resources that are not located in physical proximity that have a less than optimal interconnection that are of a different type or that have other unsatisfactory characteristics. A large node is slower to replicate which may lead to problems with auto scaling data synchronization data backup and fault recovery. For these and other reasons a data set that exceeds the optimal node size may be more efficient if divided between multiple nodes. Thus in an embodiment a key corresponding to a large number of columns and therefore a large amount of data is split between nodes based on a column identifier.

In block the configuration and topography of the clusters and nodes are analyzed. In block a connection list is assembled based on such factors as the cluster topography the resources allocated to the nodes the configuration of the nodes the cluster workload the attributes of the underlying access command the nature of the data set and or other relevant criteria. The connection list may specify any combination of nodes and or clusters. In block a connection is established between the process issuing the connection request and the designated nodes and or clusters . In an embodiment the requesting process connects directly to one or more designated nodes . In a further embodiment an intermediary such as a proxy is utilized to relay commands between the nodes and the requesting process. In block the index is updated if necessary. For example a write may add a new key to a dataset or may remove a key from the dataset. In some embodiments the node or the requestor updates the index directly. In some embodiments the node or the requestor instructs the cluster manager to update the index.

In an example utilizing a Cassandra type database protocol for both the data cluster and the index a read request is received to read data under Keyspace1 Column Family1 Key1 Cols A G . The exemplary index is organized by keyspace and column family. It is understood that the organization of the index cluster is arbitrary. Other examples organize the index by other identifiers. The index is queried with the string Keyspace1 Column Family1. The query returns Key1 Cols A thru D Cluster1 Key1 Cols E thru K Node30 Key1 Cols L thru Z Node35 . Based on the query results Cluster1 and Node30 which happens to be in a different cluster are added to the connection list. The requesting process establishes the specified connections and executes the data access command.

For clarity of presentation the system described with reference to includes two clusters. It should be noted that the system is in no way limited in the number of clusters. However large data sets such as those associated with large numbers of clusters may lead to a situation where the index is not comfortably implemented on a single device. is a schematic diagram illustrating a data warehouse database system incorporating a distributed index database cluster . The system is similar to the systems and of in certain respects. According similar features in are identified by the same reference numerals for clarity and simplicity. In this way has been simplified to better convey the inventive concepts of the present disclosure.

System includes an index database cluster . The index cluster is a set of one or more index database nodes . Each node represents a computing resource capable of storing and manipulating at least a part of the index. Nodes may represent computing hardware such as processors storage devices network interfaces and or other computing hardware and may also represent virtualized instances of computing hardware. In various embodiments nodes comprise any number and or any portion of any type of resource both real and virtual. In an embodiment the index cluster has a protocol and configuration similar to that of data clusters such as clusters and . In an alternate embodiment the index cluster utilizes a different database protocol from the data clusters . In various further embodiments the index cluster is architected in a manner designed to optimally provide cluster configuration data.

The system includes read and write processes such as a query parser and an ETL process that request a connection to the data clusters from the cluster manager . In response the cluster manager queries the index cluster to compile a connection list. To do so the cluster manager establishes communication with an index node . In an embodiment the manager communicates with the index node directly. In an alternate embodiment communications are relayed to the index node via a proxy. The particular index node may be a target node and or may be a coordinating node configured to forward the command to the target node. In an embodiment the coordinating node acts as a proxy for the target node. The connected index node provides the cluster manager with a response that may include one or more data nodes and or clusters. The response may also include status information and or ancillary data such as a timestamp. From this response the cluster manager prepares a connection list. The requestor may be provided with the connection list allowing the requestor to establish the connections directly. Alternately the requestor may utilize a proxy such as the cluster manager to connect to the data clusters and or nodes on the connection list. Once the connection or connections are established the execution of the data access command may proceed substantially similar to that previously described.

Utilizing an index cluster allows the system to leverage the benefits of a distributed database. In an embodiment the index cluster reduces seek time over an alternative implementation. Utilizing an index cluster may also reduce latency and improve network performance during index queries. In some embodiments the index cluster offers improved fault tolerance by such mechanisms as node replication. In an embodiment the rapid resource allocation of a cloud environment allows node resources to be diverted from underutilized index nodes to high traffic nodes .

In some embodiments the size and or number of entries in an index database justify incorporating a hierarchical index database configuration. The system includes a plurality of hierarchical index clusters of which clusters and are examples containing a plurality of index nodes . In the illustrated embodiment the system includes a first hierarchical level of index clusters cluster and a second hierarchical level of index clusters clusters and . Other embodiments incorporate additional hierarchical levels. In an embodiment the index clusters and have identical topographies. In some embodiments the index clusters differ in number of index nodes in distribution of index node resources and or in other characteristics. In an embodiment the index clusters and utilize the same database protocol as the data clusters and . In various embodiments the index clusters and data clusters have different database protocols node structures architectures configurations and or other attributes.

Index nodes of each hierarchical level may contain configuration information for a data node and or cluster and with the exception of the final hierarchical level may contain configuration information about a subsequent hierarchical level of the index. By definition the final hierarchical level of the index only contains configuration information for data nodes and or data clusters . The designation final denotes nothing more than that a query of a final hierarchical level returns only data nodes and or data clusters . In the illustrated embodiment the final hierarchical level of index clusters is the second hierarchical level containing clusters and . In other embodiments the system includes one or more intermediate hierarchical levels between the first and final hierarchical levels.

In an example of the method utilizing a Cassandra type database protocol for both the data clusters and the index clusters a read request is received to read data under Keyspace1 Column Family1 Key1 Cols A G . The first hierarchical index cluster is organized by keyspace therefore the index is queried with the string Keyspace1. It is understood that the organization of any hierarchical index cluster is arbitrary. Other examples organize a first hierarchical index cluster by other identifiers. The query returns Column Family1 Keys1 thru5 Index Cluster5 Column Family1 Keys6 thru99 Index Cluster10 Column Family2 Data Node40 . Based on the query results the pointer to Index Cluster 5 is relevant to the read request. Therefore Index Cluster 5 is queried. In the example the second hierarchical index level is organized by keyspace and column family. In accordance with this particular implementation the second hierarchical index level cluster Index Cluster5 is queried using the term Keyspace1 Column Family1. The query returns Key1 Cols A thru D Index Cluster7 Key1 Cols E thru K Node51 Key1 Cols L thru Z Node52 . Because the read request seeks columns A thru G the references to Index Cluster7 and Node51 are both relevant to the read request. Therefore Node51 is added to the connection list and Index Cluster7 is queried. In the present example Index Cluster7 is an nth level hierarchical index cluster and is organized by keyspace column family and key. The query Keyspace1 Column Family1 Key1 returns Col A Node54 Cols B thru D Node56 . Based on this result Node54 and Node56 are added to the Node56 list. As the query does not provide any other relevant index locations the connection list is provided to the requesting process or a proxy for establishing the specified connections. Once the connections to the data nodes is established the execution of the underlying data read command proceeds similar to that described previously.

One of skill in the art will recognize that the behavior of the query parser and ETL process of method and system is substantially similar to that of the query parser and ETL process described with respect to system of system of and system of . It follows that in an embodiment a particular query parser and ETL process pair is utilized in a single cluster system a multiple cluster system a system incorporating a single level hierarchical index cluster and system incorporating a multiple level hierarchical cluster.

The present disclosure describes multiple embodiments of a system and method for data management and indexing across a distributed database. In some exemplary embodiments a database system is disclosed comprising a cluster manager an index a first database cluster containing one or more database nodes including a first database node the first database cluster configured to operate according to a first database protocol and a data set distributed among the first database cluster wherein the first database node reports a first data range within the first database cluster wherein the index contains a second data range associated with the first database node the second data range different from the first wherein the cluster manager receives a request having a target data value from a requesting process performs a query of the index in response to the request and communicably directs the requesting process to access the first database cluster based on a determination that the target data value falls within the second data range. In some embodiments the system further comprises a second database cluster containing one or more database nodes and configured to operate according to a second database protocol wherein the data set is further distributed among the second database cluster. The first database cluster may be a complete and conforming independent cluster as specified by the first database protocol and the second database cluster may also be a complete and conforming independent cluster as specified by the second database protocol. In some embodiments the data set is structured to store data under a database hierarchy the first database protocol supports distributing data at a set of hierarchy levels within database hierarchy and the index is structured to distribute data at a level of the database hierarchy different from the hierarchy levels in the set supported by the first database protocol. In an exemplary embodiment the index includes a first entry and a second entry the first entry referencing the second entry and the cluster manager performs a second query of the index in response to the first entry referencing the second entry. In some exemplary embodiments the system further comprises an index cluster containing one or more index nodes and the index is distributed among the index nodes. In some such embodiments the index cluster is configured to operate according to an index database protocol different from the first database protocol. In some such embodiments the system further comprises a second index cluster containing one or more index nodes and the index is further distributed among the second index cluster. In one such embodiment the index includes a first entry distributed among the first index cluster and a second entry distributed among the second cluster where the first entry references the second. The cluster manager then performs a second query of the index in response to the first entry referencing the second entry. In an exemplary embodiment the first entry also references one or more of the first database cluster and the first database node.

In some exemplary embodiments a method of establishing a connection to a database node is disclosed the method comprising receiving a connection request at a cluster manager from a requesting process querying an index of a database system to receive a cluster and node configuration for the database system determining a cluster node topography for the database system based on the received cluster and node configuration assembling a connection list based on the cluster node topography of the database system and connecting the requesting process to one or more of a specified database node and a specified database cluster based on the connection list. In some embodiments querying of the index includes querying a first hierarchical level of the index for cluster and node configuration to receive a first index response determining whether the first index response includes a relevant pointer to a second hierarchical level of the index and querying the second hierarchical level when it is determined that the first index response includes the relevant pointer to the second hierarchical level. In one such exemplary embodiment querying of the first hierarchical index includes performing a query command on a first index node in a first index cluster and querying of the second hierarchical index includes performing a query command on a second index node in a second index cluster. The first index cluster may be different from the second index cluster. In an exemplary embodiment the connection request includes an attribute of an underlying data access command querying of the index includes issuing a query command based on the attribute and assembling of the connection list includes analyzing the cluster node topography based on the attribute. In some embodiments the assembling of the connection list includes analyzing the cluster node topography based on at least one of an attribute of an underlying data access command an attribute of a node and an attribute of a dataset of a node. In an exemplary embodiment the connection list includes a reference to the specified database cluster and the method further comprising connecting the requesting process to a database node within the specified database cluster according to a procedure established in a database protocol of the specified database cluster.

In some exemplary embodiments a method of adding a node to a distributed database system is disclosed the method comprising receiving a trigger to add a new node to a distributed database system determining whether the distributed database system benefits from creating a new cluster creating index entries for the new node and the new cluster when it is determined that the distributed database system benefits from the new cluster establishing the new node and the new cluster as part of the distributed database system the new node being established within the new cluster repartitioning keys within an index updating the index with the created index entries and the repartitioned keys. In some embodiments the method further comprises moving data from an existing node to the new node. In an exemplary embodiment the method further comprises determining whether an existing node benefits from being relocated from an existing cluster to the new cluster relocating the existing node to the new cluster when it is determined that the existing node benefits from being relocated repartitioning the key ranges of the existing cluster and the new cluster based on the relocating of the existing node to the new cluster and updating the index with the repartitioned key ranges of the existing cluster and the new cluster.

In the above embodiments the distributed database systems and methods offer fine grained control over data distribution the ability to handle large and complicated datasets and flexible allocation of computing resources without disrupting processes attempting to access the data. However no particular capability or advantage is associated with or required for any one particular embodiment. Although illustrative embodiments have been shown and described a wide range of modification change and substitution is contemplated in the foregoing disclosure and in some instances some features of the embodiments may be employed without a corresponding use of other features. Accordingly it is appropriate that the appended claims be construed broadly and in a manner consistent with the scope of the embodiments disclosed herein.

