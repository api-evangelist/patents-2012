---

title: System and method for cluster management
abstract: A system and method of managing a cluster of distributed machines is described. A cluster manager receives status updates regarding tasks running on each machine in the cluster from a task tracker running on the machine. The cluster manager receives resource requests from a job tracker created by a client wishing to run a job in the cluster. The cluster manager is responsible for implementing push-based fair scheduling of resources to the job trackers. The job tracker is responsible for running tasks for one job in the resource identified by the cluster manager. In one embodiment, the job tracker can run in the client for small jobs and in the cluster for larger jobs. The cluster manager can also be restarted, for example, for software updates without restraining the cluster.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104493&OS=09104493&RS=09104493
owner: FACEBOOK, INC.
number: 09104493
owner_city: Menlo Park
owner_country: US
publication_date: 20121106
---
Hadoop s MapReduce has a single node called JobTracker that is responsible for running all jobs. However both memory capacity and processing availability can become a problem for this node. The memory is filled up with the statistics for each of the tasks of the jobs while the processor is busy scheduling and updating the statistics of the currently running tasks. Further because of the single lock used in the design of the JobTracker its parallelism is limited.

Additionally if fair scheduling is implemented so that many clients can share a machine cluster and run their jobs in parallel on a small subset of the resources of the cluster thousands of jobs and millions of tasks are stored in memory thus effectively filling up the JobTracker heap. Moreover the fair scheduler has heavy scheduling cycles further compounding processing problems.

Because of the problems with the memory capacity and processor availability JobTracker has a limit to the number of tasks it can hold in memory. Beyond this limit the fair scheduling iterations become too expensive and tasks are finished slower than they enter into the system thus further slowing down the JobTracker.

A system and method of managing a cluster of distributed machines is described. A cluster manager receives status updates regarding tasks running on each machine in the cluster from a task tracker running on the machine. The cluster manager receives resource requests from a job tracker created by a client wishing to run a job in the cluster. The cluster manager implements push based fair scheduling of resources to the clients. In one embodiment the job tracker can be run in the client for small jobs or in the cluster for larger jobs. The cluster manager can also be restarted for example for software updates without restraining the cluster.

Various aspects and examples of the invention will now be described. The following description provides specific details for a thorough understanding and enabling description of these examples. One skilled in the art will understand however that the invention may be practiced without many of these details. Additionally some well known structures or functions may not be shown or described in detail so as to avoid unnecessarily obscuring the relevant description.

The terminology used in the description presented below is intended to be interpreted in its broadest reasonable manner even though it is being used in conjunction with a detailed description of certain specific examples of the technology. Certain terms may even be emphasized below however any terminology intended to be interpreted in any restricted manner will be overtly and specifically defined as such in this Detailed Description section.

User device can be any computing device capable of receiving user input as well as transmitting and or receiving data via the network . In one embodiment user device is a conventional computer system such as a desktop or laptop computer . In another embodiment user device may be mobile device having computer functionality such as a personal digital assistant PDA mobile telephone smart phone or similar device. User device is configured to communicate with access management system and or the financial account provider via the network . In one embodiment user device executes an application allowing a user of user device to interact with the access management system . For example user device can execute a browser application to enable interaction between the user device and access management system via the network . In another embodiment user device interacts with access management system through an application programming interface API that runs on the native operating system of the user device such as IOS or ANDROID .

User devices can be configured to communicate via the network which may comprise any combination of local area and or wide area networks using both wired and wireless communication systems. In one embodiment network uses standard communications technologies and or protocols. Thus network may include links using technologies such as Ethernet 802.11 worldwide interoperability for microwave access WiMAX 3G 4G CDMA digital subscriber line DSL etc. Similarly the networking protocols used on network may include multiprotocol label switching MPLS transmission control protocol Internet protocol TCP IP User Datagram Protocol UDP hypertext transport protocol HTTP simple mail transfer protocol SMTP and file transfer protocol FTP . Data exchanged over network may be represented using technologies and or formats including hypertext markup language HTML or extensible markup language XML . In addition all or some of links can be encrypted using conventional encryption technologies such as secure sockets layer SSL transport layer security TLS and Internet Protocol security IPsec .

A cluster can include up to thousands of machines available to store data and perform tasks such as analyzing and processing data in parallel. depicts an example layout of components for one embodiment of the cluster management techniques described herein. A client A N running on a user device that wants to run a job on a machine in cluster for analyzing and or processing data creates a job tracker A N A N that sends a resource request to a cluster manager . The cluster includes multiple machines A N and the cluster manager is responsible for scheduling machine resources for jobs that are run on the machines A N.

Each machine A N runs a task tracker A N that tracks the status of tasks such as map tasks and reduce tasks that are running on that particular machine. The task trackers A N communicate with the cluster manager about the status of tasks running on the respective machine. When the cluster manager is unavailable the proxy job tracker responds to communications sent to the cluster manager .

In one embodiment a job tracker A N can be created inside the respective client A N and the client A N submits the job to the job tracker A N. A separate job tracker is created by the client for each job to be run so that the job tracker only needs sufficient memory and processing power to run a single job. However many tasks may need to be performed in conjunction with the single job.

In another embodiment the client A N can create a job tracker A N inside the cluster . The client A N requests from the cluster manager a machine inside the cluster on which to run the job tracker A N. One of the criteria used to determine whether the job tracker is run inside the client or inside the cluster is the size of the job. Small jobs are run inside the client to minimize the latency of short jobs by reducing delays that occur in scheduling. Thus if a job includes fewer than a threshold number of tasks for example 1000 tasks the job is considered a small job and the job tracker is run inside the client. If a job includes greater than the threshold number of tasks the job tracker is run inside the cluster to reduce the number of communications sent between the client and the cluster. A person of skill in the art will appreciate that the threshold number of tasks can differ from 1000. In one embodiment the threshold number of tasks can be dynamically set. In one embodiment the threshold number of tasks can be manually set.

Another criterion that can be used to determine whether the job tracker is run inside the client or inside the cluster is the relative locations of the client and the cluster. If the client and the cluster are located at the same datacenter the threshold limit for the number of tasks that correspond to a small job can be set higher.

Then at block the job tracker A N A N submits a resource request for each task it has to run for the job to the cluster manager . The resource request includes information about how many map tasks or reduce tasks need to be performed.

Next at block the cluster manager matches available resources within the machines A N in the cluster to the resource request and sends a resource grant back to the job tracker if resources are available for performing the requested tasks. The resource grant includes information about which task tracker the task should be sent to for example an internet protocol IP port of the task tracker associated with the machine that has available resources to run the requested task.

If no resources are available when the resource request is sent the job tracker does not have to re submit the resource request. The cluster manager will monitor the availability of resources in the cluster and automatically send the resource request to the job tracker when the resource becomes available. This is known as push based scheduling.

At block the job tracker A N A N matches the resource grant to the task that generated the resource request and then pushes the task action to the task tracker A N identified in the resource grant.

Then at block the task tracker A N communicates the task progress and statistics related to the task such as total time the task has been running back to the job tracker running the job. In one embodiment the task trackers A N also send information about the running tasks on the machine to the cluster manager .

At decision block if the task has not finished block No the process returns to block where the task tracker A N sends an update on the task progress to the job tracker A N A N at regular intervals. If the task has finished block Yes at block the task tracker A N updates both the job tracker A N A N and the cluster manager that the task has finished running.

There can be up to thousands of machines A N running in the cluster . The cluster manager tracks the information provided by each task tracker A N running on the thousands of machines to determine the availability of resources in the cluster. The cluster manager can hold millions of objects in memory that correspond to the outstanding resource requests from the job trackers A N A N as well as session states that include a mapping of resource requests to granted resources.

The task tracker A N sends heartbeats to the cluster manager to inform the cluster manager that the machine is alive. The heartbeats can include a description of the machine s capabilities for example the number of central processing units CPUs and the number of terabytes of disk space that the machine has and the number and type of tasks that are currently running on the machine.

Based on the description of the machine the cluster manager can determine how many tasks of a certain type for example map tasks and reduce tasks can run on the machine. Thus resources are granted by the cluster manager based on the number and type of tasks reported by the task trackers A N to be running on the machines of the cluster rather than on the amount of physical resources available for example the number of CPUs available on each machine. By determining the number of tasks available to be run on a machine finer grained decisions regarding the availability of resources in the cluster can be made by the cluster manager .

If the cluster manager fails to receive an expected heartbeat from a task tracker A N the cluster manager assumes that the machine on which the task tracker was running has gone down and tasks that the machine was running have terminated.

The cluster management techniques discussed herein use push based scheduling that is as resources become available on the machines A N in the cluster resource grants are sent by the cluster manager in response to resource requests received from clients A N. Thus as resources become available in the cluster the cluster manager pushes the resources back to the job trackers A N A N through resource grants.

In contrast other traditional systems rely on pull based scheduling where a job tracker must keep requesting whether a resource is available until it receives the needed resources. Further in other traditional systems resource requests are made for a specified amount of physical resources such as CPUs rather than by the number and type of tasks such as map tasks and reduce tasks to be run.

In the case where the client creates a job tracker A N in the cluster the job tracker A N will transmit heartbeats to the client. If the client regularly receives heartbeats from the job tracker the client knows that the job tracker is running. However a machine A N in the cluster can stop running due to hardware or software problems and if a job tracker A N is running on that machine the job tracker A N will also stop. Thus it is important to let the client know that the job tracker A N has stopped running so that the client can restart the job tracker.

Then at decision block the client determines whether the job requested to be run by the job tracker has finished. If the job was reported by the job tracker to have finished block Yes the process ends at block .

If the job was not reported by the job tracker to have successfully completed block No at decision block the client determines whether the job tracker has stopped sending heartbeats. If the client receives heartbeats from the job tracker or alternatively if the client tries to communicate with the job tracker to ask for the current status of a job and receives a response block Yes the process returns to decision block to determine whether the job has finished.

If the client stops receiving heartbeats or does not receive a response when attempting to communicate with the job tracker block No at block the client sends a request to the cluster manager for a new machine on which to run the job tracker.

Upon receiving information regarding which machine the job tracker should be run on at block the client sends a command to the new machine to create a new job tracker.

Then at block the client receives regular heartbeats from the newly started job tracker. The process returns to decision block to determine whether the job has finished.

Note that the cluster manager does not need to track the job tracker A N or restart the job tracker A N if the machine goes down. In this cluster management scheme the client A N is responsible for tracking the job tracker A N because the job is only important to the client. If the client process is gone then no other entity in the system cares about what happens to the rest of the job and whether or not the job tracker A N is running.

In one embodiment the cluster management techniques discussed herein are designed to implement fair share scheduling where the cluster resources are equally distributed among requesting clients. Thus if a first client runs a job that occupies the entire cluster and a second client wants to run another job the first job will be preempted so that the available resources can be equally distributed between the two clients.

Next at block the cluster manager receives a second job request from a job tracker created by a second client for running in the cluster . To ensure fair share scheduling of resources between the two clients at block the cluster manager sends a command to the first job tracker running the first job request to pre empt the first job because the first job is unfairly using more than half of the resources of the cluster. Because the first job requires the resources of the entire cluster the first job will be temporarily interrupted. The cluster manager can send the preemption command to the first job tracker at any time i.e. the cluster manager does not wait for a heartbeat from the job tracker before sending the preemption command.

Then at block the cluster manager sends a resource grant for the second job request to the second client s job tracker. At block the second client s job tracker runs the second job on the cluster . When the task tracker tracking the second job reports to the cluster manager that the second job has finished at block the cluster manager sends a message to the first job tracker that it can again use the cluster s resources to continue running the first job.

With traditional cluster management techniques if a cluster manager needs to be restarted for example to update and release new cluster manager software the machines and sessions that communicate with the cluster manager also go down. CPU time previously invested in running jobs in the cluster is wasted and all of the running jobs must be restarted after the cluster manager is running again.

In contrast with the cluster management techniques disclosed herein the cluster manager can be restarted transparently so that machines and sessions connected to the cluster manager at the beginning of the restart of the cluster manager do not time out while the cluster manager is down. Further the cluster manager retains the state it had before the restart so that sessions that were active before the restart are not invalidated and the resource grants made before the restart are still respected. When the cluster manager is restarted the jobs running in the cluster can continue to run because the job trackers A N A N are external to the cluster manager . is a flow diagram illustrating an example process for restarting the cluster manager.

At block the cluster manager notifies the proxy job tracker that it is going to be restarted. In one embodiment the cluster manager sets a safe mode flag on the proxy job tracker and sets its own safe mode flag. Then any new requests sent to the cluster manager will know that the cluster manager is unavailable and that the requesters should periodically poll the proxy job tracker to find out whether the cluster manager is available again.

The cluster manager opens and maintains a new session for every job that is tracked by a job tracker A N A N and each session includes a mapping from the resource requests of the job tracker to resource grants. At block the cluster manager is paused and the cluster manager s session states are saved to a file on disk to persist its state.

Then at block the cluster manager is restarted. During the restart the cluster manager is unavailable to respond to requests. However the jobs that are running continue to run except when the task trackers need to communicate with the cluster manager . In that case the task trackers will pause and wait for the cluster manager to come back online while periodically polling the proxy job tracker to identify when the cluster manager is available again.

The proxy job tracker responds to communications sent to the cluster manager when the cluster manager is unavailable. At decision block if a resource request is sent by a job tracker A N A N to the unavailable cluster manager the proxy job tracker responds to the job tracker. The job tracker is told to wait until the cluster manager becomes available again. In one embodiment the proxy job tracker notifies the job tracker A N A N when the cluster manager is available again. In one embodiment the proxy job tracker responds to requests by informing the job trackers that the cluster manager is still unavailable.

At block after the cluster manager has been restarted the cluster manager s stored states are read from the file on disk and restored. Thus the cluster manager will have the same state as it had before it was restarted and the jobs resume with no loss of any computations performed before the restart of the cluster manager.

Then at block the cluster manager notifies the proxy job tracker that it has been restarted. In the embodiment discussed above where the cluster manager set its safe mode flag before being restarted the cluster manager unsets its safe mode flag and also unsets the proxy job tracker s safe mode flag. The process ends at block .

In the example of the cluster manager includes a communications module a resource monitoring module a scheduling module and a memory . Additional or fewer components or modules can be included in the cluster manager and each illustrated component.

As used herein a module includes a general purpose dedicated or shared processor and typically firmware or software modules that are executed by the processor. Depending upon implementation specific or other considerations the module can be centralized or its functionality distributed. The module can include general or special purpose hardware firmware or software embodied in a computer readable storage medium for execution by the processor. As used herein a computer readable medium or computer readable storage medium is intended to include all mediums that are statutory e.g. in the United States under 35 U.S.C. 101 and to specifically exclude all mediums that are non statutory in nature to the extent that the exclusion is necessary for a claim that includes the computer readable storage medium to be valid. Known statutory computer readable mediums include hardware e.g. registers random access memory RAM non volatile NV storage to name a few but may or may not be limited to hardware.

In one embodiment the cluster manager includes a communications module configured to receive resource requests from job trackers A N A N send resource grants to the job trackers based upon availability of resources and send preemption commands to the job trackers. The communications module is also configured to receive heartbeats from the task trackers A N running on the machines A N in the cluster . In one embodiment the communications module is also configured to receive task status updates from the task trackers A N running on the machines A N in the cluster .

In one embodiment the cluster manager includes a resource monitoring module configured to track the availability of resources in the machines A N based upon the communications received from the task trackers A N. The resource monitoring module can receive a request for resources to perform a specified number of tasks and based on the machine descriptions and currently running tasks on each machine reported by the task trackers the resource monitoring module can determine whether there are sufficient resources to accommodate the resource request. The scheduling module maps a resource request to an available resource and works in conjunction with the communications module to send a resource grant in response to a resource request.

In one embodiment the cluster manager includes a scheduling module configured to track the total amount of resources a client A N is using to ensure that fair scheduling of resources is implemented. When one or more clients are determined to be using more than their share of resources the scheduling module works in conjunction with the communications module to send a preemption command to the job trackers of those clients to interrupt jobs run by the respective clients. When resources are freed up the scheduling module sends a subsequent command to the job trackers that they may continue running the interrupted jobs.

In one embodiment the cluster manager includes a memory configured to store session states that contain a mapping of resource requests to granted resources outstanding requests from the job trackers task status updates from task trackers A N and preempted jobs and the associated job tracker. The information stored in the memory can be used by the other modules in the cluster manager .

In the example of the job tracker A N A N includes a communications module a task matching module and a memory . Job trackers A N created inside the cluster can also include a job tracker heartbeat module . Additional or fewer components or modules can be included in the job tracker A N A N and each illustrated component.

In one embodiment the job tracker A N A N includes a communications module configured to receive job requests submitted by a client. The communications module is also configured to send resource requests to and receive resource grants pushed from the cluster manager . In one embodiment the job tracker A N is created in the cluster and the communications module is configured to send heartbeats to the client to indicate that the job tracker is still running.

In one embodiment the job tracker A N A N includes a task matching module configured to map a resource grant received from the cluster manager that includes the specific task and the specific task tracker for the task to a resource request. Then the task matching module in conjunction with the communications module sends the task action to be performed to the task tracker identified in the resource grant.

In one embodiment a job tracker A N created inside the cluster includes a job tracker heartbeat module configured to generate heartbeats to send to the client that created the job tracker. The job tracker heartbeat module sends heartbeats in conjunction with the communications module to inform the client that the job tracker is still running. In one embodiment the heartbeats can also include status updates of tasks that are awaiting resources and tasks that are presently running on a machine in the cluster.

In one embodiment the job tracker A N includes a memory configured to store the job requests submitted by the client and the resource grants mapped to the appropriate job request. The information stored in the memory can be used by the other modules in the job tracker A N.

In the example of the task tracker A N includes a communications module a task monitoring module a task tracker heartbeat module and a memory . Additional or fewer components or modules can be included in the task tracker A N and each illustrated component.

In one embodiment the task tracker A N includes a communications module configured to receive task actions from job trackers A N A N send heartbeats to the cluster manager and send task progress information to the respective job tracker A N A N.

In one embodiment the task tracker A N includes a task monitoring module configured to monitor the status of tasks for which task actions have been received from job trackers A N A N. The status of the tasks is sent as part of the heartbeats to the cluster manager in conjunction with the task tracker heartbeat module and the communications module .

In one embodiment the task tracker A N includes a task tracker heartbeat module configured to generate heartbeats for sending to the cluster manager in conjunction with the task monitoring module and the communications module . The heartbeats inform the cluster manager that the task tracker and associated machine is alive and the status of tasks running on the machine. Further the heartbeat can include a quantitative description of the machine s capabilities as well as the number and type of tasks that are currently running on the machine.

In one embodiment the task tracker A N includes a memory configured to store the task actions sent by the job tracker A N A N and the status of running tasks. The information stored in the memory can be used by the other modules in the task tracker A N.

In the example of the proxy job tracker includes a communications module a cluster manager monitoring module and a memory . Additional or fewer components or modules can be included in the proxy job tracker and each illustrated component.

In one embodiment the proxy job tracker includes a communications module configured to receive resource requests from job trackers A N A N when the cluster manager is unavailable and to send a response to the requests that the cluster manager is currently unavailable.

In one embodiment the proxy job tracker includes a cluster manager monitoring module configured to monitor when the cluster manager has been restarted and is available again. The cluster manager monitoring module works in conjunction with the communications module to update the job trackers A N A N and any other entity that sent communications to the cluster manager that the cluster manager is available again.

In one embodiment the proxy job tracker includes a memory configured to store communications to the cluster manager . The information stored in the memory can be used by the other modules in the proxy job tracker .

In the example of the client A N includes a communications module a job determination module a job creator module and a memory . Additional or fewer components or modules can be included in the client A N and each illustrated component.

In one embodiment the client A N includes a communications module configured to receive commands from an external source to perform a certain function that involves running jobs on the cluster and to create a job tracker A N inside the client or to send a command to a machine to create a job tracker A N inside the cluster .

In one embodiment the client A N includes a job determination module configured to determine the jobs to be run that results in the desired function sent by the external source. For each job that needs to be run the job determination creates a job tracker A N either inside the client or in con junction with the communications module creates a job tracker A N inside the cluster .

The job determination module is also configured to determine the number of tasks needed to execute a job. The number of tasks is compared with a preset threshold value or a threshold value identified by the external source. If the number of tasks is no more than the threshold number the job determination module in conjunction with the job creator module create a job tracker A N inside the client otherwise the job determination module in conjunction with the job creator module and the communications module send a command to a machine in the cluster to create a job tracker A N inside the cluster . In some instances the job determination module may also take into account a relative location of the client and the cluster in determining the preset threshold number to be used for comparing tasks.

In one embodiment the client A N includes a memory configured to store threshold values commands from an external source and job trackers that are created both inside the client and inside the cluster. The information stored in the memory can be used by the other modules in the client A N.

While the above described cluster management techniques discussed the scheduling of map tasks and reduce tasks by the cluster manager the cluster manager can schedule other types of tasks. In fact any application that performs scheduling can benefit from these cluster management techniques for example pool based scheduling for different classes of jobs and different users can be implemented.

The cluster management techniques disclosed herein provide benefits including lower latencies for jobs higher cluster utilization better fairness in scheduling and the ability to integrate with other systems for scheduling.

As mentioned above embodiments of the present invention can be utilized within a social networking system. Typically a social networking system includes one or more computing devices storing user profiles associated with users and or other objects as well as connections between users and other users and or objects. In use users join the social networking system and then add connections to other users or objects of the social networking system to which they desire to be connected. The users may be individuals or entities such as businesses organizations universities manufacturers. The social networking system allows its users to interact with each other as well as with other objects maintained by the social networking system. In some embodiments the social networking system allows users to interact with third party websites and financial account providers.

Based on stored data about users objects and connections between users and or objects the social networking system can generate and maintain a social graph comprising a plurality of nodes interconnected by a plurality of edges. Each node in the social graph represents an object or user that can act on another node and or that can be acted on by another node. An edge between two nodes in the social graph represents a particular kind of connection between the two nodes which may result from an action that was performed by one of the nodes on the other node. For example when a user identifies an additional user as a friend an edge in the social graph is generated connecting a node representing the first user and an additional node representing the additional user. The generated edge has a connection type indicating that the users are friends. As various nodes interact with each other the social networking system can modify edges connecting the various nodes to reflect the interactions.

API request server allows other systems user devices or tools to access information from social networking system by calling APIs. The information provided by the social network may include user profile information or the connection information of users as determined by their individual privacy settings. For example a system user device or tools interested in accessing data connections within a social networking system may send an API request to social networking system via a network. The API request is received at social networking system by API request server . API request server processes the request by submitting the access request to access management system where access is determined and any data communicated back to the requesting system user device or tools via a network.

Web server links social networking system via a network to one or more client devices the web server serves web pages as well as other web related content such as Java Flash XML and so forth. The web server may communicate with the message server that provides the functionality of receiving and routing messages between social networking system and client devices. The messages processed by message server can be instant messages queued messages e.g. email text and SMS short message service messages or any other suitable messaging technique. In some embodiments a message sent by a user to another can be viewed by other users of social networking system for example by the connections of the user receiving the message. An example of a type of message that can be viewed by other users of the social networking system besides the recipient of the message is a wall post. In some embodiments a user can send a private message to another user that can only be retrieved by the other user.

Each user of the social networking system is associated with a user profile which is stored in user profile store . A user profile includes declarative information about the user that was explicitly shared by the user and may also include profile information inferred by social networking system . In one embodiment a user profile includes multiple data fields each data field describing one or more attributes of the corresponding user of social networking system . The user profile information stored in user profile store describes the users of social networking system including biographic demographic and other types of descriptive information such as work experience educational history gender hobbies or preferences location and the like. A user profile may also store other information provided by the user for example images or videos. In certain embodiments images of users may be tagged with identification information of users of social networking system displayed in an image. A user profile in user profile store may also maintain references to actions by the corresponding user performed on content items in content store and stored in the edge store .

A user profile may be associated with one or more financial accounts allowing the user profile to include data retrieved from or derived from a financial account. A user may specify one or more privacy settings which are stored in the user profile that limit information from a financial account that social networking system is permitted to access. For example a privacy setting limits social networking system to accessing the transaction history of the financial account and not the current account balance. As another example a privacy setting limits social networking system to a subset of the transaction history of the financial account allowing social networking system to access transactions within a specified time range transactions involving less than a threshold transaction amounts transactions associated with specified vendor identifiers transactions associated with vendor identifiers other than specified vendor identifiers or any suitable criteria limiting information from a financial account identified by a user that is accessible by social networking system . In one embodiment information from the financial account is stored in user profile store . In other embodiments it may be stored in financial account store .

Action logger receives communications about user actions on and or off social networking system populating action log with information about user actions. Such actions may include for example adding a connection to another user sending a message to another user uploading an image reading a message from another user viewing content associated with another user attending an event posted by another user among others. In some embodiments action logger receives subject to one or more privacy settings transaction information from a financial account associated with a user and identifies user actions from the transaction information. For example action logger retrieves vendor identifiers from the financial account s transaction history and identifies an object such as a page in social networking system associated with the vendor identifier. This allows action logger to identify a user s purchases of products or services that are associated with a page or another object in content store . In addition a number of actions described in connection with other objects are directed at particular users so these actions are associated with those users as well. These actions are stored in action log .

Action log may be used by social networking system to track user actions on social networking system as well as external website that communicate information to social networking system . Users may interact with various objects on social networking system including commenting on posts sharing links and checking in to physical locations via a mobile device accessing content items in a sequence or other interactions. Information describing these actions is stored in action log . Additional examples of interactions with objects on social networking system included in action log include commenting on a photo album communications between users becoming a fan of a musician adding an event to a calendar joining a groups becoming a fan of a brand page creating an event authorizing an application using an application and engaging in a transaction. Additionally action log records a user s interactions with advertisements on social networking system as well as other applications operating on social networking system . In some embodiments data from action log is used to infer interests or preferences of the user augmenting the interests included in the user profile and allowing a more complete understanding of user preferences.

Action log may also store user actions taken on external websites and or determined from a financial account associated with the user. For example an e commerce website that primarily sells sporting equipment at bargain prices may recognize a user of social networking system through social plug ins that enable the e commerce website to identify the user of social networking system . Because users of social networking system are uniquely identifiable e commerce websites such as this sporting equipment retailer may use the information about these users as they visit their websites. Action log records data about these users including webpage viewing histories advertisements that were engaged purchases made and other patterns from shopping and buying. Actions identified by action logger from the transaction history of a financial account associated with the user allow action log to record further information about additional types of user actions.

Content store stores content items associated with a user profile such as images videos or audio files. Content items from content store may be displayed when a user profile is viewed or when other content associated with the user profile is viewed. For example displayed content items may show images or video associated with a user profile or show text describing a user s status. Additionally other content items may facilitate user engagement by encouraging a user to expand his connections to other users to invite new users to the system or to increase interaction with the social network system by displaying content related to users objects activities or functionalities of social networking system . Examples of social networking content items include suggested connections or suggestions to perform other actions media provided to or maintained by social networking system e.g. pictures or videos status messages or links posted by users to the social networking system events groups pages e.g. representing an organization or commercial entity and any other content provided by or accessible via the social networking system.

Content store also includes one or more pages associated with entities having user profiles in user profile store . An entity is a non individual user of social networking system such as a business a vendor an organization or a university. A page includes content associated with an entity and instructions for presenting the content to a social networking system user. For example a page identifies content associated with the entity s user profile as well as information describing how to present the content to users viewing the brand page. Vendors may be associated with pages in content store allowing social networking system users to more easily interact with the vendor via social networking system . A vendor identifier is associated with a vendor s page allowing social networking system to identify the vendor and or to retrieve additional information about the vendor from user profile store action log or from any other suitable source using the vendor identifier. In some embodiments the content store may also store one or more targeting criteria associated with stored objects and identifying one or more characteristics of a user to which the object is eligible to be presented.

In one embodiment edge store stores the information describing connections between users and other objects on social networking system in edge objects. Some edges may be defined by users allowing users to specify their relationships with other users. For example users may generate edges with other users that parallel the users real life relationships such as friends co workers partners and so forth. Other edges are generated when users interact with objects in social networking system such as expressing interest in a page on the social networking system sharing a link with other users of the social networking system and commenting on posts made by other users of the social networking system. Edge store stores edge objects that include information about the edge such as affinity scores for objects interests and other users. Affinity scores may be computed by social networking system over time to approximate a user s affinity for an object interest and other users in social networking system based on the actions performed by the user. Multiple interactions between a user and a specific object may be stored in one edge object in edge store in one embodiment. In some embodiments connections between users may be stored in user profile store or user profile store may access edge store to determine connections between users.

The processor s can include central processing units CPUs that can execute software or firmware stored in memory . The processor s may be or may include one or more programmable general purpose or special purpose microprocessors digital signal processors DSPs programmable application specific integrated circuits ASICs programmable logic devices PLDs or the like or a combination of such devices.

The memory represents any form of memory such as random access memory RAM read only memory ROM flash memory or a combination of such devices. In use the memory can contain among other things a set of machine instructions which when executed by processor causes the processor to perform operations to implement embodiments of the present invention.

Also connected to the processor s through the interconnect is a network interface device . The network interface device provides the system with the ability to communicate with remote devices and may be for example an Ethernet adapter or Fiber Channel adapter.

The system can also include one or more optional input devices and or optional display devices . Input devices can include a keyboard a mouse or other pointing device. The display device can include a cathode ray tube CRT liquid crystal display LCD or some other applicable known or convenient display device.

Unless the context clearly requires otherwise throughout the description and the claims the words comprise comprising and the like are to be construed in an inclusive sense i.e. to say in the sense of including but not limited to as opposed to an exclusive or exhaustive sense. As used herein the terms connected coupled or any variant thereof means any connection or coupling either direct or indirect between two or more elements. Such a coupling or connection between the elements can be physical logical or a combination thereof. Additionally the words herein above below and words of similar import when used in this application refer to this application as a whole and not to any particular portions of this application. Where the context permits words in the above Detailed Description using the singular or plural number may also include the plural or singular number respectively. The word or in reference to a list of two or more items covers all of the following interpretations of the word any of the items in the list all of the items in the list and any combination of the items in the list.

The above Detailed Description of examples of the invention is not intended to be exhaustive or to limit the invention to the precise form disclosed above. While specific examples for the invention are described above for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. While processes or blocks are presented in a given order in this application alternative implementations may perform routines having steps performed in a different order or employ systems having blocks in a different order. Some processes or blocks may be deleted moved added subdivided combined and or modified to provide alternative or subcombinations. Also while processes or blocks are at times shown as being performed in series these processes or blocks may instead be performed or implemented in parallel or may be performed at different times. Further any specific numbers noted herein are only examples. It is understood that alternative implementations may employ differing values or ranges.

The various illustrations and teachings provided herein can also be applied to systems other than the system described above. The elements and acts of the various examples described above can be combined to provide further implementations of the invention.

Any patents and applications and other references noted above including any that may be listed in accompanying filing papers are incorporated herein by reference. Aspects of the invention can be modified if necessary to employ the systems functions and concepts included in such references to provide further implementations of the invention.

These and other changes can be made to the invention in light of the above Detailed Description. While the above description describes certain examples of the invention and describes the best mode contemplated no matter how detailed the above appears in text the invention can be practiced in many ways. Details of the system may vary considerably in its specific implementation while still being encompassed by the invention disclosed herein. As noted above particular terminology used when describing certain features or aspects of the invention should not be taken to imply that the terminology is being redefined herein to be restricted to any specific characteristics features or aspects of the invention with which that terminology is associated. In general the terms used in the following claims should not be construed to limit the invention to the specific examples disclosed in the specification unless the above Detailed Description section explicitly defines such terms. Accordingly the actual scope of the invention encompasses not only the disclosed examples but also all equivalent ways of practicing or implementing the invention under the claims.

While certain aspects of the invention are presented below in certain claim forms the applicant contemplates the various aspects of the invention in any number of claim forms. For example while only one aspect of the invention is recited as a means plus function claim under 35 U.S.C. 112 sixth paragraph other aspects may likewise be embodied as a means plus function claim or in other forms such as being embodied in a computer readable medium. Any claims intended to be treated under 35 U.S.C. 112 6 will begin with the words means for. Accordingly the applicant reserves the right to add additional claims after filing the application to pursue such additional claim forms for other aspects of the invention.

