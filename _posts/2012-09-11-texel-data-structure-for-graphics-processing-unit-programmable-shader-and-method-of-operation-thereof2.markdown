---

title: Texel data structure for graphics processing unit programmable shader and method of operation thereof
abstract: A graphics processing subsystem and a method of shading are provided. In one embodiment, the subsystem includes: (1) a memory configured to contain a texel data structure according to which multiple primitive texels corresponding to a particular composite texel are contained in a single page of the memory and (2) a graphics processing unit configured to communicate with the memory via a data bus and execute a shader to fetch the multiple primitive texels contained in the single page to create the particular composite texel.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09652815&OS=09652815&RS=09652815
owner: Nvidia Corporation
number: 09652815
owner_city: Santa Clara
owner_country: US
publication_date: 20120911
---
This application is directed in general to computer graphics and more specifically to data structures for graphics processing units GPUs .

Many computer graphic images are created by mathematically modeling the interaction of light with a three dimensional scene from a given viewpoint. This process called rendering generates a two dimensional image of the scene from the given viewpoint and is analogous to taking a photograph of a real world scene.

As the demand for computer graphics and in particular for real time computer graphics has increased computer systems with graphics processing subsystems adapted to accelerate the rendering process have become widespread. In these computer systems the rendering process is divided between a computer s general purpose central processing unit CPU and the graphics processing subsystem. Typically the CPU performs high level operations such as determining the position motion and collision of objects in a given scene. From these high level operations the CPU generates a set of rendering commands and data defining the desired rendered image or images. For example rendering commands and data can define scene geometry lighting shading texturing motion and or camera parameters for a scene. The graphics processing subsystem creates one or more rendered images from the set of rendering commands and data.

Scene geometry is typically represented by geometric primitives such as points lines polygons for example triangles and quadrilaterals and curved surfaces defined by one or more two or three dimensional vertices. Each vertex may have additional scalar or vector attributes used to determine qualities such as the color transparency lighting shading and animation of the vertex and its associated geometric primitives.

Many graphics processing subsystems are highly programmable through an application programming interface API enabling implementation of among other things complicated lighting and shading algorithms. To exploit this programmability applications can include one or more graphics processing subsystem programs which are executed by the graphics processing subsystem in parallel with a main program executed by the CPU. Although not confined merely to implementing shading and lighting algorithms these graphics processing subsystem programs are often referred to as shading programs programmable shaders or simply shaders. 

One aspect provides a graphics processing subsystem. In one embodiment the subsystem includes 1 a memory configured to contain a texel data structure according to which multiple primitive texels corresponding to a particular composite texel are contained in a single page of the memory and 2 a graphics processing unit configured to communicate with the memory via a data bus and execute a shader to fetch the multiple primitive texels contained in the single page to generate the particular composite texel.

In another embodiment the subsystem includes 1 a memory configured to contain a texel data structure according to which multiple primitive texels corresponding to a particular composite texel are contained in a single page of the memory and 2 a graphics processing unit configured to communicate with the memory via a data bus and including a plurality of streaming multiprocessors at least one of the streaming multiprocessors configured to execute a shader. In one embodiment the shader is configured to 2a initiate a fetch of the multiple primitive texels the initiating involving single address translation and 2b employ the multiple primitive texels to render the particular composite texel.

Another aspect provides a method of shading. In one embodiment the method includes 1 initializing a shader to perform a shading operation with respect to a particular composite texel 2 initiating a fetch of multiple primitive texels the initiating resulting in an address translation corresponding to a single page containing the multiple primitive texels 3 fetching the multiple primitive texels from the single page and 4 employing the multiple primitive texels to perform the shading operation.

It is realized herein that in carrying out their shading algorithms programmable shaders often read or fetch multiple primitive texel elements or texels from a virtual memory space to create one or more composite texels.

However because a virtual memory space is an abstraction of physical memory space a process of address translation is required to translate the address of each primitive texel in the virtual memory space to a physical address. The physical address is then employed to fetch the primitive texel from physical memory. Since modern computer systems employ cache memories to operate faster a page including the address containing the primitive texel is also loaded into cache memory or simply cached to accommodate the possibility that data at nearby addresses can be read from the cache memory.

Unfortunately address translation is relatively complex and consumptive of processing resources. For this reason it is advantageous to reduce the amount of address translation required to be undertaken. In this regard it has been found advantageous to use a translation lookaside buffer TLB to store recently translated addresses and thereby provide a mechanism by which address translations contained in the TLB can be re used. Unfortunately as the frequency of address translation increases the likelihood of a hit namely that the TLB contains an entry for the virtual address requiring translation diminishes decreasing the TLB s effectiveness.

Further loading cache memory with pages from main memory is consumptive of bus bandwidth. For this reason it is advantageous to reduce the amount of cacheing required to be undertaken.

It is realized herein that the conventional data structure for storing primitive texels in which primitive texels are grouped by object almost invariably causes the multiple primitive texels corresponding to a particular composite texel to span multiple pages of memory. Thus fetching the multiple primitive texels needed to create a particular composite texel often involves not only excessive address translation but also excessive page cacheing.

It is realized herein that were the primitive texel data structure reformed such that multiple primitive texels pertaining to a particular composite texel be contained in a single memory page address translations could be reduced perhaps dramatically. Accordingly introduced herein are various embodiments of a primitive texel data structure and a method of operating a primitive texel data structure in which multiple primitive texels corresponding to a particular composite texel are contained or interleaved in a single memory page. Accordingly a single address translation or TLB hit allows multiple primitive texels to be retrieved. In certain embodiments all of the primitive texels corresponding to a particular composite texel are interleaved in a single memory page allowing the retrieval of all primitive texels pertaining to the particular composite texel to be fetched with a single address translation or TLB hit .

It is also realized that when multiple primitive texels are interleaved the fraction of space a particular composite texel occupies in a given page increases as the size of the texel increases. Stated another way interleaving reduces the number of composite texels a given page can contain. Thus when a particular page is fetched it is likely to contain fewer unneeded primitive texels. This is advantageous because fetching unneeded primitive texels wastes bandwidth and temporary storage e.g. cache space. Interleaving is particularly advantageous when creating sparsely textured images or portions thereof i.e. those having simpler composite texels . In such cases the primitive texels can be made smaller their granularity decreased increasing the number of primitive texels that can be contained in a memory page and further decreasing waste. For example if a non interleaved primitive texel has a 256 256 tile size interleaving it with four other primitive texels allows the tile size to be reduced to 128 128. If a shader only requires one quadrant of the original 256 256 tile to create a particular composite texel the primitive texel can be represented in one quarter of the original space. Similarly it is easier to keep track of the primitive texels that have been fetched.

Some embodiments of the primitive texel data structure and method call for the primitive texels to be interleaved within the pages based on powers of two. For example if primitive texels are interleaved in 4 kB blocks and the distance or stride between the 4 kB primitive texel blocks is also a power of two multiple of 4 kB constructing an address for each of the primitive texel blocks in a given page involves inserting one or more most significant bits MSBs to the address of the lowest 4 kB primitive texel block. The address of the lowest 4 kB primitive texel block may be appropriately regarded as a base address and the inserted MSB s may be properly regarded as an offset. Thus for example inserting a single 0 MSB addresses even strides and inserting a single 1 MSB addresses odd strides.

Before describing various embodiments of the primitive texel data structure and method a computing system within which the primitive texel data structure may be embodied or carried out will be described.

As shown the system data bus connects the CPU the input devices the system memory and the graphics processing subsystem . In alternate embodiments the system memory may connect directly to the CPU . The CPU receives user input from the input devices executes programming instructions stored in the system memory operates on data stored in the system memory and configures the graphics processing subsystem to perform specific tasks in the graphics pipeline. The system memory typically includes dynamic random access memory DRAM used to store programming instructions and data for processing by the CPU and the graphics processing subsystem . The graphics processing subsystem receives instructions transmitted by the CPU and processes the instructions in order to render and display graphics images on the display devices .

As also shown the system memory includes an application program an application programming interface API and a graphics processing unit GPU driver . The application program generates calls to the API in order to produce a desired set of results typically in the form of a sequence of graphics images. The application program also transmits zero or more high level shading programs to the API for processing within the GPU driver . The high level shading programs are typically source code text of high level programming instructions that are designed to operate on one or more shading engines within the graphics processing subsystem . The API functionality is typically implemented within the GPU driver . The GPU driver is configured to translate the high level shading programs into machine code shading programs that are typically optimized for a specific type of shading engine e.g. vertex geometry or fragment .

The graphics processing subsystem includes a graphics processing unit GPU an on chip GPU memory an on chip GPU data bus a GPU local memory and a GPU data bus . The GPU is configured to communicate with the on chip GPU memory via the on chip GPU data bus and with the GPU local memory via the GPU data bus . The GPU may receive instructions transmitted by the CPU process the instructions in order to render graphics data and images and store these images in the GPU local memory . Subsequently the GPU may display certain graphics images stored in the GPU local memory on the display devices .

The GPU includes one or more streaming multiprocessors . Each of the streaming multiprocessors is capable of executing a relatively large number of threads concurrently. Advantageously each of the streaming multiprocessors can be programmed to execute processing tasks relating to a wide variety of applications including but not limited to linear and nonlinear data transforms filtering of video and or audio data modeling operations e.g. applying of physics to determine position velocity and other attributes of objects and so on. Furthermore each of the streaming multiprocessors may be configured as a shading engine that includes one or more programmable shaders each executing a machine code shading program i.e. a thread to perform image rendering operations. The GPU may be provided with any amount of on chip GPU memory and GPU local memory including none and may use on chip GPU memory GPU local memory and system memory in any combination for memory operations.

The on chip GPU memory is configured to include GPU programming code and on chip buffers . The GPU programming may be transmitted from the GPU driver to the on chip GPU memory via the system data bus . The GPU programming may include a machine code vertex shading program a machine code geometry shading program a machine code fragment shading program or any number of variations of each. The on chip buffers are typically used to store shading data that requires fast access in order to reduce the latency of the shading engines in the graphics pipeline. Since the on chip GPU memory takes up valuable die area it is relatively expensive.

The GPU local memory typically includes less expensive off chip dynamic random access memory DRAM and is also used to store data and programming used by the GPU . As shown the GPU local memory includes a frame buffer . The frame buffer stores data for at least one two dimensional surface that may be used to drive the display devices . Furthermore the frame buffer may include more than one two dimensional surface so that the GPU can render to one two dimensional surface while a second two dimensional surface is used to drive the display devices .

The display devices are one or more output devices capable of emitting a visual image corresponding to an input data signal. For example a display device may be built using a cathode ray tube CRT monitor a liquid crystal display or any other suitable display system. The input data signals to the display devices are typically generated by scanning out the contents of one or more frames of image data that is stored in the frame buffer .

The data assembler is a fixed function unit that collects vertex data for high order surfaces primitives and the like and outputs the vertex data to the vertex shading engine . The data assembler may gather data from buffers stored within system memory the GPU local memory and the on chip GPU memory as well as from API calls from the application program used to specify vertex attributes. The vertex shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code vertex shading program processing vertex data as specified by the vertex shading program. For example vertex shading engine may be programmed to transform the vertex data from an object based coordinate representation object space to an alternatively based coordinate system such as world space or normalized device coordinates NDC space. The vertex processing unit may read and write data that is stored in GPU local memory and the on chip GPU memory .

The primitive assembler is a fixed function unit that receives processed vertex data from vertex shading engine and constructs graphics primitives e.g. points lines triangles or the like for processing by the geometry shading engine . In alternative embodiments a second primitive assembler not shown may be included subsequent to the geometry shading engine in the data flow through the GPU . The geometry shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code geometry shading program processing graphics primitives received from the primitive assembler as specified by the geometry shading program. The geometry shading engine may be programmed to generate zero or more new graphics primitives and calculate parameters such as plane equation coefficients that are used to rasterize the new graphics primitives. For example for use in cube map rendering the geometry shading engine may be configured to process input primitives sextuple the input primitives and emit up to six sets of output primitives one for each face of a cube. The geometry shading engine may read and write data that is stored in the GPU local memory and the on chip GPU memory . The geometry shading engine outputs the parameters and new graphics primitives to the rasterizer . The rasterizer is a fixed function unit that scans the new graphics primitives and outputs fragments and coverage data to the fragment shading engine .

The fragment shading engine is a programmable execution unit such as the streaming multiprocessor that is configured to execute a machine code fragment shading program processing fragments received from rasterizer as specified by the machine code fragment shading program. For example the fragment shading engine may be programmed to perform operations such as perspective correction texel mapping shading blending and the like to produce shaded fragments that are output to the raster operations unit . The fragment shading engine may read and write data that is stored in the GPU local memory and the on chip GPU memory . The raster operations unit optionally performs fixed function computations such as near and far plane clipping and raster operations such as stencil z test and the like and outputs pixel data as processed graphics data for storage in a buffer in the GPU local memory such as the frame buffer .

Certain embodiments of the graphics pipeline include a tesselation engine not shown configured to convert low detail subdivision surfaces into higher detail primitives. In general tessellation tiles high order surfaces into structures that are more suitable for rendering.

Having described a computing system within which the primitive texel data structure may be embodied or carried out various embodiments of the primitive texel data structure and method will be described.

In the embodiment of the page contains multiple blocks of primitive texels corresponding to a particular composite texel i.e. blocks . Thus multiple two or more primitive texels corresponding to composite texel can be fetched with a single address translation or TLB hit. Also in the embodiment of the page contains all of the primitive texels corresponding to texel . Thus a single address translation is all that is required to cause the blocks corresponding to the composite texel to be fetched.

The page also contains multiple primitive texels corresponding to another particular composite texel composite texel i.e. blocks . Certain embodiments of the page contain multiple primitive texels not shown corresponding to other composite texels. While the blocks are fetched along with the primitive texels corresponding to texel it is typically expected that the extent to which the page is wasted is reduced with the benefit of the primitive texel data structure described herein. Further when it comes time to perform shading with respect to texel an entry corresponding to the page may still reside in the TLB. Thus the address translation that would otherwise be required to fetch the blocks can be avoided.

In the embodiment of the blocks and the blocks are each contained in uniform e.g. 4 kB blocks. They are interleaved with each other such that the block is stored between the block and the block etc. Further in the embodiment of the address of the is also the address of the page . Accordingly MSBs of adequate length are pre appended to a base address e.g. of 12 bits in the case of a 4 kB block size . For example if each composite texel has eight corresponding primitive texels three MSBs are adequate to address the blocks containing the eight corresponding primitive texels. Addressing the primitive texel blocks in this manner is not required but requires less address translation.

In the above described embodiments each of the primitive texels corresponds to a single composite texel. However this need not be the case. In an alternative embodiment a particular primitive texel corresponds to and is employed to create multiple composite texels. For example one or more of the primitive texels contained in the blocks correspond to for example four composite texels. This embodiment therefore employs fewer primitive texels to construct the same number of composite texels requiring less memory to store the primitive texels and decreasing the number of address translations or TLB lookups necessary to perform shading operations with respect to a given number of composite texels.

Also in the above described embodiments the primitive texels are assumed to be of the same size. However this need not be the case either. In an alternative embodiment the primitive texels are of different size. For example some primitive texels may cover a 4 8 tile while others may cover a 2 4 tile. Likewise the composite texels may be of different size. Further the sizes of the primitive texels need not equal the sizes of their corresponding composite texels.

Because primitive texels are referenced with a strong spatial locality those skilled in the pertinent art will understand that adjacent primitive texels are likely to be used concurrently across multiple threads in embodiments in which the GPU supports multi threaded execution. It is therefore advantageous that primitive texels be stored adjacently. However while a composite texel is created using multiple primitive texels within a given page the primitive texels are advantageously interleaved coarsely and not finely within the page. This may be referred to as an array of structures of arrays. The array of structures is the composite texel the structure is the memory page and structure of arrays are the individual primitive texels.

Those skilled in the art to which this application relates will appreciate that other and further additions deletions substitutions and modifications may be made to the described embodiments.

