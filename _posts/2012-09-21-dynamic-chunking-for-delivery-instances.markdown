---

title: Dynamic chunking for delivery instances
abstract: Systems and methods for dynamically chunking for delivery instances are provided that automatically implement chunking strategies based on one or more chunking considerations related to a request for a media file. These systems and methods may be part of a larger media servicing network that can be used to, among other things, process uploaded media content, provide it for streaming/downloading, and collect metric information regarding the streaming/downloading. The disclosed systems and methods provide for receiving a request having a Uniform Resource Locator (URL) and providing an index file to implement chunking strategies based on chunking considerations associated with the request.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08645504&OS=08645504&RS=08645504
owner: Unicorn Media, Inc.
number: 08645504
owner_city: Tempe
owner_country: US
publication_date: 20120921
---
This application is a continuation of and claims the benefit of co pending commonly assigned U.S. patent application Ser. No. 13 430 081 filed Mar. 26 2012 entitled Dynamic Chunking for Delivery Instances which is a continuation in part and claims the benefit of commonly assigned U.S. patent application Ser. No. 12 976 883 filed Dec. 22 2010 entitled Dynamic Chunking For Media Streaming which issued as U.S. Pat. No. 8 145 782 on Mar. 27 2012 which claims priority to Australian Patent Application Serial No. 2010202741 filed Jun. 30 2010 entitled Dynamic Chunking For Media Streaming. Both applications are incorporated by reference for all purposes.

Additionally application Ser. No. 13 339 668 filed Dec. 29 2011 entitled Dynamically Executed Syndication Services and application Ser. No. 13 339 680 filed Dec. 29 2011 entitled Multi Platform Media Syndication Customization are also incorporated by reference into this application for all purposes.

This disclosure relates in general to cloud based computer processing and but not by way of limitation to providing media for use in media streaming.

The delivery of media over networks such as the Internet can be accomplished in many ways including progressive downloading or streaming. Streaming a media file typically involves downloading chunks or small segments of the media file. Information including where chunks may be accessed can be stored in an index file also known as a manifest file . This index file can be delivered to a client such as a media player application for use in streaming. Additional information may also be provided which can alter the appearance of the client.

Systems and methods for dynamically executing syndication services are provided that automatically implement business rules for syndication based on contextual data associated with a media file a request for a media file or both. These systems and methods may be part of a larger media servicing network that can be used to among other things process uploaded media content provide it for streaming downloading and collect and distribute metric information regarding the streaming downloading. The disclosed systems and methods provide for receiving a request having a Uniform Resource Locator URL or other content indicator and providing an index file in accordance with business rules based on contextual data associated with the request the content or both. Embodiments further enable media content owners to distribute a single URL or other content indicator corresponding to a particular media file among many media providers enabling a single media delivery and analytics service to provide comprehensive metric information regarding content syndication and usage for all requests for the content across all media providers.

According to one embodiment a method for providing media with a data network is provided. The method includes receiving a first request having a universal source locator URL . The URL includes information indicative of a requested media file. The method further includes determining one or more factors related to the first request determining a first chunking strategy based on the one or more factors related to the first request and generating a first index file having information for streaming the requested media file via the data network. Generating the first index file is based at least in part on the first chunking strategy. The method also includes providing the first index file receiving a second request having the URL and determining one or more factors related to the second request. The one or more factors related to the second request is different than the one or more factors related to the first request. The method additionally includes determining a second chunking strategy based on the one or more factors related to the second request and generating a second index file having information for streaming the requested media file via the data network. Generating the second index file is based at least in part on the second chunking strategy and content of the second index file is different from content of the first index file. Finally the method includes providing the second index file.

According to another embodiment a server for providing a media file with a data network is provided. The server includes a network interface for communicating with the data network a memory and a processor communicatively coupled with the memory and the network interface. The processor is configured to cause the server to receive a first request having a universal source locator URL . The URL includes information indicative of a requested media file. The processor is also configured to cause the server to determine one or more factors related to the first request determine a first chunking strategy based on the one or more factors related to the first request and generate a first index file having information for streaming the requested media file via the data network. The generating the first index file is based at least in part on the first chunking strategy. The processor is further configured to cause the server to provide via the network interface the first index file receive a second request having the URL and determine one or more factors related to the second request. The one or more factors related to the second request is different than the one or more factors related to the first request. The processor is additionally configured to cause the server to determine a second chunking strategy based on the one or more factors related to the second request and generate a second index file having information for streaming the requested media file via the data network. Generating the second index file is based at least in part on the second chunking strategy and content of the second index file is different from content of the first index file. Finally processor is configured to cause the server to provide via the network interface the second index file.

According to yet another embodiment a non transitory computer readable medium having instructions imbedded thereon for providing media with a data network is provided. The instructions when executed by one or more computers cause the one or more computers to receive a first request having a universal source locator URL . The URL includes information indicative of a requested media file. The instructions further cause the one or more computers to determine one or more factors related to the first request determine a first chunking strategy based on the one or more factors related to the first request and generate a first index file having information for streaming the requested media file via the data network. The generating the first index file is based at least in part on the first chunking strategy. The instructions also cause the one or more computers to provide the first index file receive a second request having the URL and determine one or more factors related to the second request. The one or more factors related to the second request is different than the one or more factors related to the first request. The instructions additionally cause the one or more computers to determine a second chunking strategy based on the one or more factors related to the second request and generate a second index file having information for streaming the requested media file via the data network. Generating the second index file is based at least in part on the second chunking strategy and content of the second index file is different from content of the first index file. Finally the instructions further cause the one or more computers to provide the second index file.

In the appended figures similar components and or features may have the same reference label. Further various components of the same type may be distinguished by following the reference label by a dash and a second label that distinguishes among the similar components. If only the first reference label is used in the specification the description is applicable to any one of the similar components having the same first reference label irrespective of the second reference label.

The ensuing description provides preferred exemplary embodiment s only and is not intended to limit the scope applicability or configuration of the disclosure. Rather the ensuing description of the preferred exemplary embodiment s will provide those skilled in the art with an enabling description for implementing a preferred exemplary embodiment. It is understood that various changes may be made in the function and arrangement of elements without departing from the spirit and scope as set forth in the appended claims.

The increased availability of media content over data communications networks such as the Internet has mirrored the increased bandwidth for these networks. Because media has recently taken a more prominent role in data communications the distribution of media and the data associated with such distribution has become increasingly important particularly to media media providers. Media streaming has become a widely used method of media distribution but the preprocessing associated with streaming can be burdensome. Certain protocols including forms of Hypertext Transfer Protocol HTTP streaming require chunking and storing media assets and generating a corresponding index files. These requirements can deprive a media provider of the ability to dynamically insert additional media such as advertisements into a media stream and can consume a large amount of storage space to store chunks of media for a media asset including chunks for any alternative sub streams e.g. streams with alternative bitrates captions alternative languages etc. . Certain systems and methods can be utilized however to introduce the desired functionality back into the system.

A traditional approach to preprocessing media for streaming involves chunking and storing media assets then creating corresponding index files to indicate where chunks may be located to download for streaming. Streaming protocols often provide for frequently updating an index file for instances where the corresponding media is frequently updated such as during live streaming. Thus an index file does not need to contain all chunks for a requested media asset. In addition because media files are frequently stored in a format that requires little additional processing to chunk the chunks can be created in real time during the streaming of a media file. The systems and methods disclosed herein take advantage of these features to enable dynamic index file creation and dynamic media file chunking.

For instance rather than preprocess media assets for streaming by chunking and indexing all files with relevant sub streams prior to streaming the media a server can dynamically create and update an index file during streaming. The dynamically created index file can contain information regarding a next chunk of media in the various available sub streams. The next chunk of media may not be cached at a location specified in the index file in which case a chunk may be dynamically created by pulling all or part of the media file of interest from a media file origin chunking it and making it available for download. The chunk also may be cached thereby eliminating the need to create the chunk again if it is requested at some later time.

Because the chunks are created during streaming a media provider and or media distributer can have more information and control during the streaming process. Rather than generate single index file for a given media asset an instance of the index file generator may be created at the beginning of the media streaming to provide individualized media content to a particular end user and unique information regarding the streaming session to a media provider. The file index generator can vary the length of each chunk by for example indicating starting and ending points in the index file. Thus the file index generator may determine a uniform chunk length for a media asset varying the length of the chunks for different media assets or the file index generator may adjust the length of the chunks within a single media asset. The index file generator can further insert additional media such as an advertisement at any time during the streaming by specifying the location of the additional media in the index file. The determination to insert advertisements can be based on any information including data collected during the streaming session.

As the index file generator receives requests for and generates index files it can further gather data regarding the streaming session for reporting to a media provider. Media providers often rely on beaconing data collected from media player applications to determine when an end user stops plays pauses skips etc. the streaming media content. Such information can be vital in determining the value of the media.

Because not all media player applications provide this beaconing data the data gathered by the index file generator can serve as a substitute for or complement to the beaconing data. For example if a request is made for a chunk that does not immediately follow a previously requested chunk a skip was made. If the amount of time elapsed between a previous request and a subsequent request exceeds the time for playback of the previously requested chunk a pause was made. If a request is not received within a certain time since a prior request it can be determined that a stop was made.

As illustrated above the state of a client may be determined from a variety of factors. This can include when the request for the index file is received when the index file is provided a length of time to play back the segment of media for streaming and or the starting and or ending point of the segment of media for streaming. The determined state of a client may also be based on whether the request for the index file has been received within a certain amount of time since receipt of a previous request for an index file whether the segment of media for streaming includes media other than the media file and more. The state of a client and or the data from which it was determined may be used to create reporting data to serve as a substitute or complement to beaconing data from a client media player application. Because the index file generator can determine the length of the chunks it therefore can determine the frequency of subsequent index file requests and the resolution of the reporting data based on the requests. The index file generator may log the reporting data and or transmit the reporting data over a network during streaming.

The determined state of a client may be used by the index file generator and or other services for various purposes. For example it may be used in behavioral advertisement targeting and enforcement of session advertisement behavior adjusting advertisement content and playback based on the behavior of a user as determined by the stated of a client. The state of a client further may be used to support resume features on a per client basis allowing a user to continue playback of a media asset from a point at which the user had previously stopped playback. The state of a client also may be used to support individual encryption keys in an encryption scheme and allow the index file generator to return secure URLs e.g. time expiring or Internet Protocol IP allowed for chunks to support functions such as payment services.

Additionally or alternatively the tasks of generating the index file and providing a location a requested chunk can be split up thereby enabling the system to determine which chunks are actually requested. For example a system may be configured to dynamically create an index file having links to one or more redirectors on the system. These redirectors can be configured to issue the location of the chunk which can be created dynamically. The redirectors can further determine which chunk is actually requested thereby enabling among other things calculation of Quality of Service QOS metrics an increase the accuracy of reporting data a decrease the frequency of index file generation if efficient to do so and the ability to more easily handle keys of an encryption scheme.

While the above embodiments may be implemented in a variety of different systems some particular embodiments may be implemented as part of a media service system. is a block diagram illustrating a media servicing system according to some embodiments of the present invention. The system may deliver media content to the end user device through a network such as the Internet . The end user device can be one of any number of devices configured to receive media over the Internet such as a mobile phone tablet computer personal computer portable media device etc. A media asset provided by a media provider can be processed and indexed by cloud hosted integrated multi node pipelining system CHIMPS and further stored on media file delivery service provider MFDSP . Additionally or alternatively the CHIMPS may also be adapted to store the media asset.

The media servicing system further enables a media provider or other entity to gather information regarding user behavior during media playback. For example a media provider can be provided with data indicating that end users tend to stop watching a video at a certain point in playback or that users tended to follow links associated with certain advertisements displayed during playback. With this data a media provider can adjust factors such as media content advertisement placement and content etc. to increase revenue associated with the media content and provide the end user device with a more desirable playback experience.

End user device can request a media asset to stream with a client program executed by the end user device . The client program can be for example a media player browser or other application adapted to request and or play media assets. In response to a request for a media asset the CHIMPS can utilize any number of application centers and or kernel application center s to provide the client program with a data object concerning the requested media asset. The data object can include information about the media asset including where the media asset can be located such as within the MFDSP or within the CHIMPS itself. Location information may be provided by Universal Resource Indicator URI a Universal Resource Locator URL or other indicator. During playback of the media asset the CHIMPS can collect data regarding the playback through beaconing provided by a client program executed by the end user device and or indexing service from within the CHIMPS and or MFDSP. The CHIMPS can subsequently provide the data and or any analytics information derived from the data to the media provider .

Components within the kernel application center can communicate through network such as a local area network LAN and can include one or more origin servers and a storage array with which data objects and or media assets may be stored and distributed. The storage array may also be utilized by services running on processing server s and or transcoding server s that may require temporary or long term storage. Kernel server can utilize processing server s transcoding server s to provide various functional capabilities to the CHIMPS .

For example as described in more detail below the CHIMPS can provide transcoding service for media assets provided by a media provider for syndication. Such a service can allow a media provider to upload a media asset to an application center after which the application center would notify the kernel server that the media asset has been uploaded. The kernel server can then notify services running on the processing server s of the upload. These services can utilize transcoding server s to transcode the media asset which can then be moved to a MFDSP and or stored locally by storage array and origin server s . Services running on the processing server s can also update the associated data object stored by the storage array and origin server s .

Media can be ingested into the CHIMPS when a media provider uploads a media asset to ingestion server s in an application center by utilizing a client . The client can be a stand alone application or browser based for example and can communicate with ingest server s through an application programming interface API configured for the ingestion of media assets.

Ingest server s can communicate with devices in the kernel application center executing programs such as kernel server and file replication service . The kernel server can be configured organize the workflow among services such as transcoding file system manager and other services e.g. analytics dynamic API etc. Upon a particular event for example the kernel server can be configured to notify the relevant services of the event causing the services to process tasks associated with the event.

The file replication service under direction of the kernel server can coordinate the movement of the media assets between services. For example retrieving the uploaded media asset from the ingest server s and storing it on the file archive or retrieving transcoded media assets from transcoding server s and storing them in the media asset origin.

The data object updater keeps the data object origin up to date in response to any changes in the system. When for example a file is uploaded transcoded and stored in media asset origin the location and other metadata concerning the transcoded media assets need to be created or updated in the data object origin to ensure an end user device that accesses the object in the data object origin has the correct information regarding the related media asset. Because the data object updater receives updates from the kernel server which is notified when a transcoded media asset is stored in the media asset origin the system ensures the data objects in the data object origin are constantly up to date.

The upload of a media asset to the ingest server s as described above can provide an example of how the kernel server may coordinate workflow. For instance in response to the upload the ingest server s can notify the kernel server that a media asset has been uploaded. The kernel server informs the file replication service of the uploaded media asset and the file replication service moves the uploaded media asset into the file archive and notifies the kernel server of the move. In response the kernel server notifies the file replication service the file system manager and the transcoding master of the move. The file replication service then will know it can delete the uploaded media asset from the ingest server s the file system manager will update the file system accordingly and the transcoding master will notify transcoding service s of different transcoding tasks to be performed. The transcoding service s can then retrieve the uploaded media asset from the file archive to create transcoded media assets. The transcoding service s notify the kernel server once transcoding is complete and the kernel server relays this information to the file replication service . The file replication service then takes the transcoded media assets from the transcoding services and moves them to the media asset origin . Once the file replication service notifies the kernel server of the move the kernel server in turn notifies the file replication service and the data object updater . The data object updater which updates the data object origin accordingly and the file replication service deletes the transcoded media assets from the transcoding services .

The modular nature of the system enables all tasks associated with an event to be completed quickly. As illustrated in the example above workflow relating to a particular event such as a media asset upload can be spread among the various services simultaneously. Moreover because the system s modularity enables it to be scaled to accommodate differing hardware capacities and because the system can be configured to dynamically allocate hardware to different services according to the needs of the system the speed of completing tasks relating to a particular event can further be increased. For example a server of the CHIMPS can be configured to dynamically switch its purpose based on external conditions such as load and overall system performance providing functions such as transcode upload metrics collection application web service and more on an as needed basis.

Embodiments of such systems may include other systems that manage various requests from end users. For example a system for dynamic index file generation and media file chunking. Referring to shows an embodiment of such a system . Media may be streamed to end user device though a client . As mentioned above the client can be stand alone media player a plug in a browser or other application which can be executed on a personal computer or other electronic device.

An index file generator as discussed previously can be a program instantiated for media streaming to a particular client . The index file generator can be executed on a server or other computing device within an application center of the CHIMPS . Index files generated by the index file generator can include a wide variety of information such as starting ending and or run times for media chunks and locations for media chunks. This information can be embedded in a single string of data such as a URI or a URL. If media includes various sub streams e.g. streams with alternative bitrates captions alternative languages etc. the index file can include data for chunks corresponding to each of the alternative sub streams as well as information regarding the bitrate and or other unique information for each stream. Alternatively or in addition index files indicating alternative sub streams may be separate from index files indicating one or more media chunks for streaming.

It should be understood that the index file can further comprise a wide variety of formats which can depend on the particular protocol. HTTP streaming may for example require index files to comprise one or more of M3U M3U8 XML and XML based formats. Of course other formats can be used in accordance with relevant streaming protocols.

Table 1 illustrates a simplified example of a generated index file in M3U9 format indicating chunk of media for streaming. The index file in this example provides a URI for a chunk of media. The URI indicates the chunk is to be generated by dynamic segmentor the chunk being 10 seconds long starting at 9 seconds into the media file and ending 19 seconds into the media file.

Referring again to the index file generator can also include an indicator within an index file to indicate whether a chunk of media is to be dynamically created. If for example it is determined that a requested media asset has not been chunked and that the asset will be chunked dynamically the index file generator can include the indicator in data corresponding to a chunk of media to be created. The indicator which can be as simple as including the term seg in a URL will indicate that a requested chunk of media needs to be generated.

The chunks of media can be generated during media streaming by a dynamic segmentor which can be incorporated into an HTTP service . The HTTP service as well as the media asset origin can be located within a kernel application center of the CHIMPS on for example a media asset origin server. The system can be configured such that the kernel application center provides dynamically created chunks of media to a MFDSP for delivery to client . The MFDSP can store the chunks locally in for example a media asset cache thereby forgoing the need to dynamically create a chunk again if the same chunk is requested in the future.

In sum the system for dynamic index file generation and media asset chunking can after receiving a request for an index file from a client dynamically generate an index file with an index file generator . The index file can among other things indicate where a next chunk of media may be located. A client can then request the chunk from the location indicated by the index file which can comprise a media asset cache in a MFDSP . If the chunk is not found in the media asset cache the cache miss can redirect the request to a segmentor of an HTTP service which can dynamically generate the requested chunk of media by accessing the corresponding media asset in the media asset origin . The requested media chunk can then be provided to the MFDSP for storage in the media asset cache and delivery to the client . If the same chunk is requested at a later point in time the MFDSP can deliver the chunk from the media asset cache thereby forgoing the need to redirect the request to the segmentor to regenerate the chunk.

Embodiments utilizing one or more redirectors can have several advantages. For example and not by way of limitation if a certain client were implemented in such a way that it reads ahead to request chunks it could result in incorrect reporting data. Thus it would be advantageous to determine which chunk is actually requested by the client. Additionally or alternatively where chunks are available in various sub streams with different bitrates determining the actual requested chunk can be useful in calculating Quality of Service QOS metrics. Furthermore it there may be scenarios in which it is more efficient to create larger index files having many chunks comprising large segments of media reducing the number of index files required to stream a media asset and thereby reducing the processing requirements to create the index files. If encryption is used having for example a rotating key or a per client key encryption scheme in which a valid key might change during playback of a media asset it also may be advantageous to incorporate redirector s for handling legacy keys for some period of time.

At block the method additionally provides for receiving input from an advertising service. According to some embodiments this input could be the availability of an advertisement and can be provided by a service inside or outside the CHIMPS. In other embodiments the input could come from a service that factors in any of a variety of factors to indicate that a specific advertisement or type of advertisement should be shown. Or that any advertisement should be shown.

At block a determination is made whether to include an advertisement in the next chunk. According to some embodiments this determination can be made with or without input from an advertisement service. It should be known that this determination can include the factors used by an advertisement service to provide the input of block . Whether the determination includes input from an advertisement service of block or not the determination can still include factors such as information about an end user collected before or during streaming of the media. This can include behavior of the end user during streaming of the media as determined for example by machine based logic through beaconing data and or requested chunks of media provided by a client . Factors can also include information regarding the media asset used for streaming such as type of content or preferred points within the media for an advertisement preference s and or selection s of an end user when a previous advertisement was shown time of day and more. It can further include information regarding the source of a media asset such as who created and or provided the asset for viewing by an end user. It will be understood that other embodiments contemplate include secondary media other than advertisements into the media stream in this manner. Moreover the secondary media and or advertisement can be of any length and also may be chunked. Thus it may be determined that the next chunk includes all or a select portion of an advertisement of any specific length.

An index file is created based on the request as well as the determination of whether media such as an advertisement should be streamed indicated by block . As discussed above the index file can assume a variety of formats and include any amount of information regarding a next chunk of media for streaming. For example HTTP streaming can utilize index files having the URLs of available chunks of media. Information can be embedded in these URLs to indicate a location to download the corresponding chunk of media starting point and or ending point of a chunk of media an indicator to indicate whether the chunk is to be dynamically created by a segmentor a location of an advertisement to be streamed and more. This information is included in the index file and sent to the client at block .

At block reporting data can be created based on information included in the index file. As previously discussed information included in an index file and or index file request can indicate the behavior of an end user device during streaming such as a pause stop skip play etc. of the media. According to some embodiments this information can be extracted from requests for an index file and or providing the requested index file. The information can be gathered in addition to or as a substitute for beaconing data provided by a client . Moreover if beaconing data is provided the creation of reporting data may be omitted altogether.

Reporting data can include any amount of information regarding end user behavior as indicated through index file requests and or provided index files. This can include a particular action and when it was performed. Additionally or alternatively the data may be kept in a more rudimentary form depending on the application or embodiment indicating the data included in a index file request and or an index file. This reporting data may be stored in a log file for reporting after streaming and or transmitted during streaming to a relevant service that collects such metrics.

As indicated by block the reporting data may be sent to a metrics collector for analytics. A metrics collector according to certain embodiments may be an application executed by a server from within the application center in which the index file generator is executed or it may be executed elsewhere such as in a kernel application center or in a system outside the CHIMPS . Depending on the form of the reporting data the metrics collector can further process and store the information.

The method can begin at block when a request for a chunk of media is received from a MFDSP . As discussed above this request may be made in response to a cache miss at the MFDSP and or because an indicator was included in the request for the chunk of media that the chunk was to be created dynamically. As discussed herein if the MFDSP has the requested chunk cached from a prior request the MFDSP can provide the requested chunk and preclude the need to send the request to a dynamic segmentor to generate the chunk. It should be understood that the request may come from sources other than a MFDSP according to alternative embodiments. One such source includes the media caching server of embodiment as shown in .

The starting and ending points of a requested chunk of media are then determined at block . This information can be included directly in the request or derived from the request a previous request and or other sources. At block the information as well as information identifying the requested chunk of media can be used to retrieve all or part of the relevant media asset from a media asset origin . The retrieved portion will include at least the relevant media from the starting point to the ending point of the requested chunk of media.

At block the requested media chunk is generated by converting the relevant portion of the media asset into a deliverable chunk. The media asset as stored in the media asset origin may not be chunked it may be stored in its entirety as a media file or group of alternative files corresponding to alternative sub streams . Generating the chunk therefore can require determining the starting and ending points from the retrieved portion of the media asset and converting the resulting segment of media into a deliverable chunk.

Although the generation of the deliverable chunk may involve transcoding it may not. The media asset can be stored in a format where transcoding may not be needed thereby reducing the processing requirements for creating chunks of media during streaming. For example media assets may be stored such as H.264 or MPEG 4 video format and or AAC HE AAC or MP3 audio format. According to some streaming protocols such as some forms of HTTP streaming chunks of media in these formats would not need transcoding before being wrapped in an MPEG 2 transport stream container format. Instead such a conversion essentially would require the addition of metadata to create the streaming format from the format of the stored media asset. In other words generating a deliverable chunk of media may only require identifying the stored media asset extracting the relevant segment of the media from the media asset and adding certain metadata in accordance with a container format. This process requires little processing power and can be easily performed on the fly during streaming. Once the deliverable chunk of media is generated it is sent to the MFDSP or other requesting entity at block .

The index file generator generates an index file to indicate the next chunk of media . As described above this chunk may include an advertisement and the index file can include any amount of information about a chunk of media including information regarding alternative sub streams for streaming. The dynamic index file generator can include information regarding existing chunks of media and when used in conjunction with a dynamic segmentor may also include information regarding chunks of media that may need to be created. As detailed above if a chunk of media is to be generated dynamically the index file generator may indicate this by including an indicator in the generated index file such as in a URL for one or more chunks described within the index file. Once the index file is generated the index file generator sends the index file which is received by the client .

Alternative embodiments may provide for the generation of index files containing more than a next chunk of media. For example an index file generator may generate an index file containing information regarding several chunks of media in which case the chunks of media can be dynamically generated by a dynamic segmentor when requested by the client. The determination of whether to include information regarding more than a next chunk of media can include factors such as whether the index generator is generating reporting data the desired frequency of such reporting data and more.

Using information contained in the index file the client can then request the next chunk of media and this request can be received by a MFDSP . The MFDSP then checks to see if the chunk is already stored in the cache . If so the MFDSP can provide the requested chunk to the client blocks and . The requested chunk may be found in a MFDSP s cache if the chunk was created and stored in the MFDSP during preprocessing or if the chunk was dynamically created and stored in the MFDSP from an earlier request.

If the chunk is not found on the MFDSP the chunk can be requested of the dynamic segmentor which receives the request and retrieves the corresponding media asset from an asset origin server . As discussed above the entirety of the relevant media asset does not need to be retrieved as long as at least the portion containing the relevant segment for the requested chunk is retrieved. It will be understood that alternative embodiments can provide for the media asset being stored in a variety of locations accessible directly or indirectly to the dynamic segmentor.

The dynamic segmentor can then generate the requested chunk by converting the retrieved media into a deliverable chunk. That is the dynamic segmentor converts the retrieved media into an acceptable format for streaming which can vary depending on the streaming protocol utilized. The dynamic segmentor can then return the requested chunk to the MFDSP which can cache the chunk and return it to the client . Once the chunk is received by the client the client can play the chunk to an end user.

The techniques for creating index files and or creating corresponding chunks of media can be adapted for each request. This allows the CHIMPS or similarly enabled system to provide optimal chunking for each delivery instance which can differ even among similar devices depending on any of a variety of factors. For example a new version of a particular device type e.g. a particular smart phone set top box tablet etc. may have the same operating system and or browser as an older version of the device type but with a larger buffer than the older version. As such optimized chunking for delivery instances involving the old and new versions of the device type may differ in that delivery to the new version can include using chunk sizes that would cause a buffer overflow in the older version. By dynamically determining and implementing a chunking strategy for each delivery instance in this manner the CHIMPS or similarly enabled system can help provide the optimal user experience under any of a variety of circumstances.

Chunking considerations are factors that can impact any aspect of the chunking of a media file and or advertisements included in the delivery of the media file. Such considerations can include but are not limited to bandwidth codec processor type buffer size memory and or processor utilization battery network type geographic location whether a device is moving a location in the playback of the media file and the like.

The bandwidth of a device for example can impact the size of the chunks delivered to the device. For a relatively low bandwidth the chunk size may be reduced so that chunks are downloaded more quickly which may reduce the chance that a media player would need to interrupt playback to while waiting for the next chunk to be delivered. Conversely chunk size can be increased for higher bandwidths. Similarly the chunks may be adapted to accommodate a particular network type e.g. WiFi mobile wireless network land line wired etc. which can determine or be indicative of an available bandwidth.

Different aspects of the hardware of a device can also be considered when chunking a media file. In addition to the buffer size as indicated above a processor type can also impact how a file is chunked such as the size of the chunk and or the codec used. Additionally or alternatively QOS metrics can indicate memory and or processor utilization including during playback of the requested media file which can impact the chunking of the media file.

Chunking considerations further can include a variety of factors related to mobile devices. For example whether a device is situated in a particular geographic location at a particular event where large numbers of mobile devices may be located and or the device is moving can impact the available bandwidth to the device. The battery level of a mobile device may also impact the bandwidth in certain circumstances. The CHIMPS or other chunking system can anticipate changes in bandwidth by determining such chunking considerations and adjusting the chunking accordingly. Moreover QOS bandwidth and or other information from multiple devices can be aggregated to help the CHIMPS further adapt media chunking for related delivery instances. Thus the chunking considerations for streaming to one device may include information regarding one or more other devices. For example the CHIMPS may anticipate a sudden reduced bandwidth for a particular delivery instance related to a cell phone where it is determined that other cell phones nearby on the same carrier have had sudden drops in bandwidth.

Chunking considerations further can include a type of codec used and or a location in the playback of the media file. Certain codecs for example may require or prohibit the use of certain sized chunks. Also for example if the playback of the media file has just started smaller chunks may be used to help ensure that playback begins quickly without the need to wait for larger chunks to be delivered. Also chunk sizes can be altered to accommodate ad insertion or similar interleaving of media content at particular point s in the playback of the media file.

Chunking considerations may be determined from information included in the request a database and or other sources which may disclose data such as a URL client ID globally unique identifier GUID or other identifier a network type a device type and or capability an operating system executed by the end user device an application application identifier application state or other application information a location associated with the device information associated with a user of the end user device information regarding the requested media file e.g. genre length rating s ownership artist etc. . Additionally or alternatively the request may simply include information that enables one or more of these items to be determined. Additionally or alternatively a repository may be stored maintained or derived and queried for authorization authentication validation or selection for example a repository of application identifiers may be maintained and queried to determine whether an application is authorized to request the content and if so to select further aspects of or for processing the content request. Additionally or alternatively such stored or derived repository data may be used in conjunction with other data either internally or externally identified such as a secret key shared key public key stored certificate other stored data or other data for authorization authentication validation or selection including data stored on another digital service on another server on the client device in a device associated with the client device in the operating system in the application in another application in a network or in another location from which it may be retrieved.

As indicated previously the determination of chunking considerations can include utilizing information other than the information provided in the request. This may involve accessing information stored in one or more a databases or other data structures internal or external to the CHIMPS . It may also involve communicating with other entities and or systems such as a content owner or media provider . Additionally or alternatively chunking considerations can be gathered using data independent of information provided in the request such as the time at which the request was received.

At block a chunking strategy based on chunking considerations is determined. And at block the corresponding index file and chunks are provided accordingly. As indicated above the chunking strategy i.e. the way in which the chunks are created and delivered can be impacted by the chunking considerations including the size of the chunks the length of the playback of the chunks and the choice of codec used. Furthermore multiple considerations can be taken into account to determine the chunking strategy.

This chunking strategy can be implemented on the fly i.e. immediately before or during playback of the media file utilizing the dynamic indexing and chunking techniques discussed above. For example an index file generator can incorporate the chunking strategy into a dynamically generated index file and the dynamic segmentor can produce the requested chunks accordingly. Because the contextual data and chunking strategies can vary for each delivery instance the content of the index files corresponding to requests for the same media file can be different e.g. indicate different chunk sizes codecs to use etc. based on differing chunking strategies.

It should be noted that the methods systems and devices discussed above are intended merely to be examples. It must be stressed that various embodiments may omit substitute or add various procedures or components as appropriate. For instance it should be appreciated that in alternative embodiments the methods may be performed in an order different from that described and that various steps may be added omitted or combined. Also features described with respect to certain embodiments may be combined in various other embodiments. Different aspects and elements of the embodiments may be combined in a similar manner. Also it should be emphasized that technology evolves and thus many of the elements are examples and should not be interpreted to limit the scope of the invention.

Specific details are given in the description to provide a thorough understanding of the embodiments. However it will be understood by one of ordinary skill in the art that the embodiments may be practiced without these specific details. For example well known circuits processes algorithms structures and techniques have been shown without unnecessary detail in order to avoid obscuring the embodiments. This description provides example embodiments only and is not intended to limit the scope applicability or configuration of the invention. Rather the preceding description of the embodiments will provide those skilled in the art with an enabling description for implementing embodiments of the invention. Various changes may be made in the function and arrangement of elements without departing from the spirit and scope of the invention.

Also it is noted that the embodiments may be described as a process which is depicted as a flow diagram or block diagram. Although each may describe the operations as a sequential process many of the operations can be performed in parallel or concurrently. In addition the order of the operations may be rearranged. A process may have additional steps not included in the figure. Furthermore embodiments of the methods may be implemented by hardware software firmware middleware microcode hardware description languages or any combination thereof. When implemented in software firmware middleware or microcode the program code or code segments to perform the necessary tasks may be stored in a non volatile computer readable medium such as a storage medium. Processors may perform the necessary tasks.

Having described several embodiments it will be recognized by those of skill in the art that various modifications alternative constructions and equivalents may be used without departing from the spirit of the invention. For example the above elements may merely be a component of a larger system wherein other rules may take precedence over or otherwise modify the application of the invention. Also a number of steps may be undertaken before during or after the above elements are considered. Accordingly the above description should not be taken as limiting the scope of the invention.

