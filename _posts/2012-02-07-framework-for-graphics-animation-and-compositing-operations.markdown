---

title: Framework for graphics animation and compositing operations
abstract: A framework for performing graphics animation and compositing operations has a layer tree for interfacing with the application and a render tree for interfacing with a render engine. Layers in the layer tree can be content, windows, views, video, images, text, media, or any other type of object for a user interface of an application. The application commits change to the state of the layers of the layer tree. The application does not need to include explicit code for animating the changes to the layers. Instead, an animation is determined for animating the change in state. The determined animation is explicitly applied to the affected layers in the render tree. A render engine renders from the render tree into a frame buffer for display on the processing device. Those portions of the render tree that have changed relative to prior versions can be tracked to improve resource management.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08446415&OS=08446415&RS=08446415
owner: Apple Inc.
number: 08446415
owner_city: Cupertino
owner_country: US
publication_date: 20120207
---
This is a continuation of U.S. application Ser. No. 11 756 331 filed 31 May 2007 now U.S. Pat. No. 8 130 226 entitled Framework for Graphics Animation and Compositing Operations which in turn is a continuation in part of U.S. application Ser. No. 11 500 154 filed 4 Aug. 2006 and entitled Framework for Graphics Animation and Compositing Operations each of which is incorporated herein by reference in its entirety and to which priority is claimed. This application is also related to U.S. application Ser. No. 13 186 026 filed 19 Jul. 2011 now U.S. Pat. No. 8 130 231.

The subject matter of the present disclosure relates to a framework for handling graphics animation and compositing operations for graphical content of an application executing on a processing device such as a computer.

The following table shows 15 files that are provided as a computer program listing filed electronically herewith as text files which are hereby incorporated by reference in their entirety.

Mac OS X provides prior art graphics and imaging frameworks for developers to create views for graphical user interfaces GUIs of a computer application. MAC OS is a registered trademark of Apple Inc. of Cupertino Calif. . For example Cocoa is an object oriented application environment that developers can use to develop Mac OS X native applications. Apple s Cocoa Application Framework also referred to as Application Kit or AppKit is one of the core Cocoa frameworks. Application Kit provides functionality and associated Application Programming Interfaces APIs for applications including objects for graphical user interfaces event handling mechanisms application services and drawing and image composition facilities.

NSView is part of Cocoa s Objective C API and is an abstract class that defines basic drawing event handling and printing architecture of applications. With NSView each view of an application s GUI is dealt with using local coordinates and each view is positioned relative to its parent view in a hierarchical fashion. Using a view hierarchy is useful for building complex user interfaces out of modular parts. The Application Kit framework is used to develop NSView based applications. This framework contains objects needed to implement a graphical event driven user interface that includes windows dialogs buttons menus scrollers text fields etc. Application Kit framework handles the drawing of objects communicates with hardware devices and screen buffers clears areas of the screen before drawing and clips views.

GUIs for computer applications have increased in complexity and are usually designed to handle views animations videos windows frames events etc. Even with the increased complexity the goal of developers is to make the GUIs more tactile and natural in appearance. Accordingly developers must consider how to create and manage the GUIs for computer applications with this goal in mind.

Referring to a rendering process according to the prior art is schematically illustrated. In the rendering process an application which can be based on NSView as discussed above inputs GUI information into a backing store and issues rendering commands to the render engine . The render engine renders the GUI information from the backing store into a frame buffer . The render engine can use Apple s Core Image and Core Video. Core Image is an image processing framework and Core Video is a video processing framework. Scan out hardware then outputs the rendered information in the frame buffer to a display using a frame rate of the display .

This prior art rendering process has no built in framework for animating objects or views. Instead the NSView based application handles animation explicitly by moving views around resizing views etc. To provide animation most NSView based applications developed in the art resort to using snapshots of the views and compositing the snapshots using other facilities. In the application is show having a pseudo code loop for animating movement of an object or view for the application s GUI. In this simplified example the object or view is being moved from a start point A to an end point B e.g. the application may receive user input moving a view from a starting position on the display to an ending position . The typical developer of the application does not want the object to disappear from point A on the display and suddenly appear at point B on the display because users prefer a more gradual or natural movement.

To make the movement more gradual or natural the developer of the application typically animates the movement of the object from start point A to end point B using explicit code such as code segment or loop . In this simplified code the loop is used to animate the object by incrementally moving the object some distance X for each iteration of the loop . shows some resulting positions of an object or view as it would appear incrementally on displayed results as the application of performs the animation of the object with the iterative loop of . The number of steps or snapshots used to animate the movement of the object is decided by the developer. In addition to such an iterative loop for moving objects the developer must include explicit code in the application to implement any form of animation e.g. fade in fade out resize etc. for an object.

In addition to requiring explicit animation in the application the data structures and painting model for NSView present problems when the application has dynamic content. For example NSView makes no particular distinction between changes in content and layout and is not well tuned for continuous re layout. As an NSView object is moved for example it creates damage to content in its wake that requires other views to be redrawn. Redrawing a view typically invokes the model to view mapping code of NSView based application and requires expensive computations to be performed particularly if the model data needs to be retrieved over a network .

The timing of services for this form of application offers some additional difficulties for developers. Most animations are done using one or more timers e.g. the embedded loops or iterative steps in the main event loop of the application . Therefore the duty cycle of the timer for the animation is completely dependent on how fast the application services its main event loop. Although some events can be handled quickly other events may take much longer and may actually be subject to I O delays.

In addition the frame buffer and scan out hardware operate under a frame rate to output information to the display . The frame rate is typically about 60 Hz. To improve the handling of events developers attempt to operate the application in synchronization with the frame rate of the hardware. In this way the majority of events of the application can be timely handled within the main loop of the application and rendered to the display at the frame rate . However maintaining such a consistent frame rate of 60 Hz. in the main loop of the application can be difficult. Furthermore determining what actual frame rate to use and determining when to initiate the timer to keep it in sync with video blanking of the scan out hardware is not readily apparent in a given context because the application is not given intimate knowledge of the video display and its associated hardware .

In addition to presenting problems for developers with respect to animation and event handling the NSView based application may have problems related to layout of the GUI for the application . For example a number of constraints must typically be applied to views when they are resized for display. One of the views may have a fixed absolute size while other views may be designed to change size with the composition. Additionally many views e.g. text or web views must explicitly change how they are represented as a function of the actual size at which they are to be displayed. Consequently the text or web view may need to invoke its own layout techniques when it is resized. Developers of the NSView based application must explicitly handle these types of complex issues.

The subject matter of the present disclosure is directed to overcoming or at least reducing the effects of one or more of the problems set forth above.

A framework for performing graphics animation and compositing operations is disclosed. The framework is used as part of rendering process to render a user interface of an application for display on a computer system. The framework is divided into two processes. A layer tree process interfaces with the application and a render tree process interfaces with a render engine. The layer tree process has a first data structure or layer tree that contains object or layers associated with the user interface of the application. The layers can be content windows views video images text media or any other type of object for a user interface of an application. The render tree process is separate from the layer tree process and does not interface with the application. The render tree process has a second data structure or render tree that contains object or layers associated with the layer tree. The render engine renders from the render tree.

When the application changes or is manipulated to change a layer of the user interface e.g. a user moves a layer from a first position to a second position in a window of the user interface the layer tree process receives the changes from the application and implements the changes directly to the layer tree. The changes from the application change the state of one or more layers in the layer tree. For example if a layer has been moved in the application then attributes describing the position of the affected layer in the layer tree will change. From the change in state of the affected layer in the layer tree an animation and compositing process independent from the application determines what animation to use to animate the change of the affected layer. The animation and compositing process then implements the determined animation on the affected layer of the render tree. Then the render engine renders the layers in the render tree into a frame buffer of the computer system.

The foregoing summary is not intended to summarize each potential embodiment or every aspect of the present disclosure.

While the subject matter of the present disclosure is susceptible to various modifications and alternative forms specific embodiments thereof have been shown by way of example in the drawings and are herein described in detail. The figures and written description are not intended to limit the scope of the inventive concepts in any manner. Rather the figures and written description are provided to illustrate the inventive concepts to a person skilled in the art by reference to particular embodiments as required by 35 U.S.C. 112.

Referring to one embodiment of a rendering process according to certain teachings of the present disclosure is schematically illustrated. In the rendering process an application inputs graphical user interface GUI information into a backing store not shown and a Core Animation framework sometimes referred to herein simply as Core Animation is used to process the GUI information in the backing store. Once the framework has processed the GUI information a render engine renders the processed information into a frame buffer . Although not shown in the render engine typically renders processed information into an assembly buffer that is then composited into the appropriate location of the frame buffer . When compositing is completed scan out hardware outputs the rendered information in the frame buffer to a display using a frame rate of the display .

The processing performed by the Core Animation framework includes graphics animation and compositing operations for the application . To perform the operations the Core Animation framework divides the processing into a layer tree and a render tree . In this two tree approach the layer tree is exposed to the application and is used for implicit animation and implicit layout of graphics objects also referred to herein as layers . On the other hand the render tree is manipulated and is traversed by the render engine .

As will be discussed in more detail later the layer tree includes a data structure that interfaces with the application . The data structure of the layer tree is configured to hold a hierarchy of layers. The layers are objects having various properties and attributes and are used to build the GUI of the application . The terms property and attribute may be used interchangeably in the present disclosure . In general for example the layers can include content windows views video images text media etc. The data structure of the layer tree is preferably as small and compact as possible. Therefore many of the attributes of the layers preferably have default values kept in an extended property dictionary such as NSDictionary of Apple s Cocoa application environment.

During operation the application interacts with the layer tree of the framework to manipulate the hierarchy of layers in the layer tree . The application can be any computer application or client process that manipulates or changes the layers being displayed. When the application commits an event or change to the layer tree the framework determines what events or changes are made at each layer by the application . These events or changes in the layer tree are then committed to an animation and compositing process of the framework . This process determines one or more implicit animation functions of the framework to use on the layer tree based on the committed events or changes for each layer of the layer tree .

The animation and compositing process then performs explicit animation of the events or changes and configures the layout of the layers in the render tree . The animation and layout of the render tree are then rendered by the render engine and output to the frame buffer . Any manipulations of layers made by the application to the layer tree are not evaluated at the frame rate of the display . Instead changes in the render tree are traversed and updated at the frame rate .

As alluded to above the framework separates the animation and compositing of layers from the application . For example when the application makes changes the affected layers in the layer tree are instantly changed from one state to another. State changes reflected in the layers of the layer tree are then percolated to the physical display by animating the changes and compositing the layers of the render tree from the initial state of the layers to their final or end state. This form of animation and composition is referred to herein as implicit animation and is part of the animation and compositing process of .

By using implicit animation in the framework the application does not have to include code for animating changes e.g. movement resizing etc. of layers to be displayed. Accordingly any code required for animating layers can be minimized in the application . As shown in simplified form in for example the application may not require an embedded loop for animating changes to the layers. Instead the application includes code that indicates a change in the state of a layer e.g. indicates a change in position of a layer . The framework determines from the changes made to the layers in the layer tree what implicit animation to perform on the layers and then the framework explicitly performs that animation on the layers using the render tree . Accordingly animations can be abstracted in such a way that the code of the application does not need to run at the frame rate . This allows the animation for objects layers to be decoupled from the logic of the application and allows the application and the animations to run on separate threads in the rendering process .

The animation and compositing process can perform a number of different types of animation on layers or objects. For example if the application operates on the layer tree to change a layer from start point A to end point B in the GUI for the application the animation and compositing process automatically manipulates i.e. without application input the representation of that layer in the render tree to animate its movement from point A to point B on the display . In another example if the application operates on the layer tree to add a new layer to the layer tree the animation and compositing process may automatically manipulate the render tree to fade in the new layer. In yet another example if the application operates on the layer tree to replace an existing layer with a new layer the animation and compositing process automatically manipulates the render tree to animate a transition from the existing layer to the new layer.

To help illustrate the how the application changes the state of layers in the layer tree shows an example result of a layer of the layer tree of being changed from a start state to an end state by the application of . In this example the layer is schematically represented as an object in a layout boundary and is shown moved from a start state A to an end state B e.g. a user of the application s GUI has moved a window from one point A on the screen to another point B .

Returning to the state change of the layer made by the application are committed almost immediately to the layer tree . Once made the animation and compositing process obtains the change in state of the affected layer from the layer tree using a state based form of operation. The animation and compositing process then uses characteristics of the start state and end state of the layers to determine what animation to use to arrive at the end state of the layers for display. Finally the process explicitly applies the determined animation and associated layout of the layers to the data structure of the render tree in a procedural fashion.

To help illustrate the operation of the animation and compositing process shows example results of animation on an affected layer in a layout boundary . The layer is part of the render tree of and is associated with the changed layer of . In this example the layer is being moved in increments of a distance X over a period of time from point A on the display to another point B on the display as the animation and compositing process of applies the determined animation in a procedural fashion to the render tree of . It will be appreciated that several layers can be simultaneously changed and animated. By separating the animation and compositing from the application in the framework can better synchronize animation with the frame rate . In this way multiple and simultaneous changes made to the layers by the application can be committed in synchronization to the display .

Given the above overview of the rendering process and Core Animation framework of the present disclosure we now turn to a more detailed discussion of one embodiment of a Core Animation framework according to certain teachings of the present disclosure. In a rendering process is illustrated showing an embodiment of a Core Animation framework for graphics animation and compositing operations. The framework includes a layer tree process a queue an implicit animation process an explicit animation process and a render tree process . The framework is part of an object oriented application environment such as Cocoa designed for developing Mac OS X native applications. Files of an Objective C API for the Core Animation framework have been incorporated herein by reference in the computer program listing appendix. The framework can be used to build interactive user interfaces for applications. Preferably the framework is compatible with Apple s existing Application Kit framework by using an NSView subclass to host layers and other properties of the framework as discussed below.

The layer tree process has a data structure or layer tree that interfaces with an application . Like views of NSView a layer of the framework draws itself When it draws itself the layer is given a CoreGraphics context CGContext . Unlike NSView however rendering commands from the application are not issued immediately but are instead captured into the retained data structure of the layer tree and are then eventually passed over to the render tree process for processing. The render tree process can then redraw layers in the render tree that are associated with the layers of the layer tree with no intervention by the application . This is one purpose for separating the layer tree process from the render tree process . The render tree process can always synthesize an up to date representation of the layers without needing to call back to the application . Although only one layer tree and render tree are shown in it will be appreciated that there may be several trees with each visible layer tree backed by a corresponding render tree .

The isolation mentioned above also allows the render tree process to be implemented in a number of ways including allowing the render tree process to reside in another thread or in another process via Interprocess Communication IPC . For example the render tree process can be implemented on an NSTimer on a separate thread from the layer tree process . The isolation between the layer tree process and the render tree process also allows the layer tree process to be implemented in an object language like Objective C while the render tree process can be coded entirely in a procedural language such as C if necessary for performance.

As shown in the layer tree is diagrammatically illustrated as a number of first layers also referred to herein as model objects that are interconnected by dependencies with one another in a hierarchical fashion. It is understood that a computer system can store the layer tree in any format suitable for the computer. Several types of layers can be defined in the framework . Some possible types of layers include Image layers CoreGraphics layers Text layers Vector layers e.g. layers based on CGLayerRef Client drawable and display lists CoreVideoBuffer or Media layers e.g. autonomously animating content such as movie or Quark Composer and other more generic layers.

Before proceeding with the discussion of the rendering process of we first turn to a discussion of the layers in the layer tree of the framework . The layers are substantially similar to views of Apple s NSView. Like the views in NSView for example each layer is associated with a window in which it is displayed and the layers are related to one another in a hierarchical fashion of superlayers and sublayers because some layers are subregions of other layers in a window.

The framework can use the following classes NSArray NSDictionary NSEnumerator CAAnimation and CIFilter and the protocol CAAction. NSArray NSDictionary NSEnumerator and CIFilter are known and used in the art. CAAnimation and CAAction are defined for the disclosed framework of and are described in the incorporated files. The base layer class for layers in the framework is the NSObject class. However the base layer class has specific timing CATiming and object protocols e.g. key value coding for the framework of the present disclosure.

For the key value coding KVC protocol of the layers CA Layer implements the NSKeyValueCoding protocol for all Objective C properties defined by a class and its subclasses. CALayer dynamically implements missing accessor methods for properties declared by subclasses. When accessing properties via KVC whose values are not objects the standard KVC wrapping conventions are used with extensions to support the following types CGPoint NSValue CGSize NSValue CGRect NSValue and CGAffineTransform NSAffineTransform .

Many more details of the layers are discussed herein and are included in the incorporated file CALayer. Here we only briefly mention some of the geometrical and hierarchical properties for layers in the framework . Many of the properties are similar to those used in Core Graphics. Layers have bounds or a coordinate system that are defined by the property CGRect bounds. The position of a layer is defined by the property CGPoint position. The Z component of the position of a layer is defined by the property CGFloat zPosition.

The frame of a layer is defined by the property CGRect frame. Unlike NSView each layer in the layer hierarchy of the framework has an implicit frame rectangle that is defined as a function of the bounds transform and position properties. When setting the frame of the layer the position and bounds.size for the layer are changed to match the given frame. The frame and bounds model of the framework is similar to that used for Apple s Application Kit but only the bounds offset and matrix are stored. The frame can be computed using an instance of method CGRect frame. 

To help visualize the layers their hierarchy in the layer tree the frame and bounds of the layers and other details we turn briefly to . shows an example of a window of a graphical user interface. The window has three layers A B and C. Much like the view hierarchy used in Apple s NSView the layers A B and C in the window are linked together in a layer hierarchy which is also shown in . In general each layer can have another layer as its superlayer and can be the superlayer for any number of sublayers. As used herein a superlayer is the layer that is immediately above a given layer in the hierarchy and a sublayer is the layer that is contained either wholly or partially by the superlayer. In the example of the window s content layer is at the top of the hierarchy and layer A in the hierarchy is the superlayer for the sublayers B and C.

In for example the relationships for three example layers D E and F are shown where layer D is the superlayer of E and where layer E is the superlayer of F. Each layer D E and F is defined by a corresponding frame rectangle D E and F having its own coordinate system D E and F. The bounds attribute of the layers defines its coordinate system . In general the frame rectangle of each layer is positioned within the coordinate system of its superlayer. Thus the frame rectangle E for layer E is positioned within the coordinate system D of layer D and the frame rectangle F for layer F is positioned within the coordinate system E of layer E. When a given layer is moved or its coordinate system is transformed e.g. rotated flipped etc. all of its sublayers are moved or transformed along with it. Yet because each layer has its own coordinate system the drawing instructions for that layer can be consistent no matter where the layer is or where its superlayer moves to on a screen.

The frame rectangles essentially define the area of the layers i.e. the tablet on which the layers can draw. The frame rectangle of a given layer can lie within the frame rectangle of its superlayer. In addition the frame rectangle of a given layer can extend outside its superlayer s frame rectangle . For example the frame rectangle F lies entirely within the frame rectangle E of its superlayer D but the frame rectangle E for layer E extends outside the frame rectangle D of its superlayer D. In contrast to views in NSView the layers can place content outside the frame of their parent layers.

Given the above overview of layers we now return to a discussion in of how the layers are interrelated to one another to construct the layout of the layer tree of the disclosed framework . The layers in the layer tree are constrained by layer constraints not shown in . A constraint based layout manager adds a constraints layer property to the data structure for layers in the layer tree . The constraint based layout manager is defined in the incorporated file CAConstraintLayoutManager. The constraints layer property is an array of CAConstraint objects. Each CAConstraint object describes one geometrical relationship between two layers of the layer tree . Layout of the layers in the layer tree is performed by fetching the constraints of each sublayer and solving the resulting system of constraints for the frame of each sublayer starting from the bounds of the containing layer . The relationships between layers are linear equations of the form u m v c where u and v are scalar values representing geometrical attributes e.g. leftmost position of the two layers and where m and c are constants. Sibling layers are referenced by name using a name property of each layer . A special name superlayer is used to refer to the superlayer of a given layer .

Now that we have an understanding of the layer tree and its layers we turn to a discussion of details related to the render tree process and render tree . As discussed previously the render tree process has a data structure or render tree that does not interface with the application . Instead explicit animation is made to the render tree by the explicit animation process and the render engine renders from the render tree . The render tree is similar to the layer tree in that it contains a description of the layer hierarchical of the layers found in the layer tree . Accordingly the render tree also includes a plurality of second layers also referred to herein as renderable objects that are related in a hierarchical fashion and that are associated with the first layers of the layer tree .

In contrast to the layer tree the render tree further includes animation objects added to the data structure of the layers in the render tree . For illustrative purposes the animation object for one of the render tree layers is diagrammatically shown in as an appended element to a node D that has been changed in the layer tree by the application . During processing by the animation processes implicit and or explicit the animation object is added to a representation of the layer in the render tree associated with the changed layer in the layer tree . In typical operation of the framework adding the animation object is implicitly invoked through an action that is a CAAnimation object. Details related to CAAnimation object are discussed below and in the incorporated file CAAnimation. 

The animation object has a key a duration property and other properties and details discussed herein. The key is used to identify the animation and the key may be any string such that only one animation per unique key is added per layer in the render tree . The special key transition is automatically used for transition animations of the layers . The duration property of the animation object defines the duration of the animation. If the duration property of the animation object is zero or negative it is given a default duration which can be either a particular value of a transaction property for the render process or can be a default value of 0.25 seconds for example.

Given the details of the framework discussed above we now turn to a discussion of how the framework is used in the rendering process . In the rendering process of is shown in flow chart form as process . For the sake of understanding in the discussion that follows reference is concurrently made to reference numbers of components in the rendering process of and to blocks of the process of .

During operation the application obtains changes made to graphical content of the application s GUI system Block . The application interfaces with the layer tree process and commits the changes to the layer tree Block . As discussed previously the changes to the layer tree are not immediately rendered by the render engine for a display of a general purpose processing device such as a computer. Instead the layer tree process changes the state of one or more affected layers and sublayers in the hierarchy of the layer tree Block . The layers in the layer tree are model objects that encapsulate geometry timing and visual properties and provide the cached content that will eventually be rendered for display. In the example of a node D has had its state changed from X to Y e.g. the layer associated with node D has been moved from one position to another position has been resized from one size to another size etc. . The state change to the layer in the layer tree may not include any animation or compositing information and the state change may merely indicate to the layer tree process the start and end states of the affected layers and sublayers of the hierarchy in the layer tree .

The state change of the layers and sublayers is then queued in a queue of the framework Block . The queue is used to commit the state changes to the implicit animation process and periodically determines whether to commit the state changes Block . Preferably multiple state changes to layers in the layer tree are batched into atomic transactions that are committed together by the queue . If it is not time to commit then the process can return to obtaining additional state changes to the layer tree by the application at Blocks through .

If it is time to commit then the queue commits the state changes to the implicit animation process Block . The implicit animation process includes default animation operations but explicit overrides can be made. Explicit overrides can be implemented by an appropriately programmed application using the actions property of the layers. In addition explicit overrides can be implemented using a defaultActionForKey method for implementing a default action for a specified key on the layer and using a actionForKey method for implementing an action for a specified key on the layer

The implicit animation process determines what animation operations to perform based on the state changes of the affected layers in the layer tree Block . This determination depends on the context of the state change. The context is based on various variables such as the type of layer being changed the position of the changed layer in the hierarchy of the layer tree any sublayers of the changed layer the type of change etc. Details related to this determination are provided in more detail later.

Once the animations have been determined the explicit animation process then implements the determined animations on the associated layers in the render tree Block . In particular the explicit animation process implements the processes or steps of the animations on the associated layers in the hierarchy of the render tree in a transactional fashion. Eventually the explicit animations of the render tree are committed to the render engine for rendering and are eventually displayed Block .

Thus the render tree is used for the compositing operations that are independent of the activity of the application producing the layers in the layer tree . In this way rendering is performed in a separate process or thread from the application that has produced the information in layer tree and the rendering operation will have a reduced impact on the operation of the application s run loop.

As noted previously changes in the layers associated with the layer tree are percolated to the render tree . In other words the layer tree process and the render tree process interact in a transactional model. Changes to the data structure of the layer tree are explicitly flushed or committed to the render tree in order to have a visual effect. This is similar to window backing store flushing where a group of changes appears atomically. The difference in the framework is that some of the changes are not necessarily implemented immediately and might implicitly require animation.

If new changes are committed before the explicit animation and render tree processes and have completed animations of affected layers the processes and can still animate to the newly requested state smoothly from its current state again without the application being involved. If the root or a subtree of the hierarchy associated with the layer tree is changed to a completely new scene and committed to the render tree for example a default scene transition can be explicitly invoked e.g. 0.5 second dissolve or cube transition can be implicitly applied .

Transactions are the mechanism used by the framework for batching multiple operations to the layer tree into atomic updates to the render tree . Details related to the transactions are included in the incorporated file CATransaction. Every modification to the layer tree requires a transaction to be part of it. The framework supports two kinds of transactions explicit transactions and implicit transactions.

Explicit transactions occur when the application explicitly sends a begin message in the CATransaction class before modifying the layer tree and sends a commit message after modifying the layer tree . In this way the application can call explicit transactions before modifying the layer tree and can commit the explicit transactions after modifying the layer tree . Implicit transactions are created automatically by the framework when the layer tree is modified by the application s thread without an active transaction. The implicit transactions are committed automatically when the thread s run loop next iterates. In some circumstances i.e. where there is no run loop or the run loop is blocked it may be necessary to use explicit transactions to get timely updates to the render tree .

To handle transactions the framework defines a CATransaction which is an NSObject. Using the framework new transactions can be initiated all changes made during a current transaction can be committed to the render tree and any extant implicit transactions can be flushed. Preferably implicit transactions are not committed until any nested explicit transactions have been completed. Transaction properties can include animationDuration that defines a default duration in seconds for animations added to layers and can include disableActions that suppresses implicit actions for property changes.

Use of transactions and implicit animation in the framework offers a number of advantages in the rendering process of . In one advantage the separate layer and render trees and keep rendering and display operations clean. For example the application can provide an instruction for a layer at a start state X in the layer tree to be changed to an end state Y. The layer tree process implements that state change to the affected layer and the application can then immediately continue to operate as if the affected layer is at end state Y. Separately the explicit animation process and render tree process of the framework process the associated layer of the render tree to animate its change from start state X to end state Y. 

In the rendering process the application no longer performs the animation. Instead the framework performs the animation by first determining the animation to perform with the implicit animation process and then implementing the determined animation with the explicit animation process . Having the application assume the end state for the affected layer of the layer tree while having the framework animate the associated layer of the render tree to its end state allows multiple events and changes to be queued up with the layer tree process and queue without the application having to do graphical programming and animation.

As noted previously the framework determines what animations to use for layers changed by the application . The type of animation used can depend upon characteristics of a given context of the application s GUI currently being rendered for display. In the framework the animations between states are implicitly determined and it is assumed that animations will be gradual to some extent. If a new position for a layer tree layer is set for example the associated render tree layer is implicitly animated from its current position to its new position via a default animation or transition to gradually animate the change. Similarly when a new layer tree layer is added an associated render tree layer will have a default appearance animation or transition e.g. a 0.25 second materialize or dissolve .

Preferably animation behaviors are programmable in the framework by invoking a predefined name of the animation e.g. Push Left Swirl In etc. . The framework can define various forms of animation and can have a set of predetermined animations to be used. For example some animations in the framework can be defined in a manner similar to what is used in Synchronized Multimedia Integration Language. Synchronized Multimedia Integration Language is technology developed and distributed by the World Wide Web Consortium W3C . In addition animations in the framework can include animatable properties attributes and filters of layers and can include transitions between changes in the layers of the layer tree . Preferably the framework allows developers to make overrides of default values such as timing controls for animations.

For example the framework can define a transition animation subclass that contains various transition types such as fade moveIn push and reveal. Because some transitions of the animation model may be motion based the framework can further define a property subtype for these transitions. The property subtype can be used to specify the direction for the motion based transitions. For examples values for this property subtype can be fromLeft fromRight fromTop fromBottom and fromCorner. 

Because animations may occur over a period of time the framework can further define another property subtype for animations that specifies the amount of progress for the animation at which to begin and end execution. In one example a timing function can define the pacing of the animation. The timing function can define a general keyframe animation class to create an array of objects providing the value of the animation function for each keyframe. Typically a keyframe is a frame used to designate where changes occur in the animation. The framework can also define CATimingFunction objects. If N number of keyframes are set for the animation there would typically be N 1 objects in the timingFunctions array. Each function in the array describes the pacing of one keyframe to keyframe segment of the animation.

In addition a path object can define the behavior of an animation. Each point in the path object except for moveto points defines a single keyframe for determining the timing and the interpolation of the animation. For constant velocity animations along a path the animation can be set to a calculated mode of paced. Other calculated modes can include linear and discrete. 

For basic i.e. single keyframe animations the framework can define a subclass for interpolation objects that define the property values between which an animation is to be interpolated. Preferably the object type of the interpolation objects matches the type of the property being animated using the standard rules described in incorporated files. Some supported modes for interpolating animation include 1 interpolating between a fromValue and a toValue 2 interpolating between a fromValue and a fromValue plus a byValue interpolating between a toValue minus a byValue and a toValue 3 interpolating between a fromValue and the current presentation value of a property 4 interpolating between the layer s current value of a property in the render tree and a toValue for that property 5 interpolating between the layer s current value of a property in the render tree and that value plus a byValue and 6 interpolating between the previous value of a property in the render tree and the current presentation value of that property.

To handle animations of multiple layers the framework can also define an animation subclass for grouped animations to create an array of CAAnimation objects. Each member of the array can be run concurrently in the time space defined for a parent animation.

In addition to motion transitions and other animations disclosed herein the framework can allow layer properties to be animated as well. For this the framework can include a set of ValueAnimation classes. In one example a FloatAnimation value may be defined in one of the ValueAnimation classes so that the X position of a layer in the GUI could be set to the FloatAnimation value that has been specified to oscillate between two values.

Furthermore the animations defined in the framework can include animatable filters for the layers. For example the framework can define additional attributes for CIFilter objects that can be accessible both via the NSKeyValueCoding protocol and through declared properties. These additional attributes can be used to construct keypaths to existing filters so that the framework can set an attribute of a filter attached to a layer and so that animations of the layers may access filter attributes via the key paths. In this way the filters for layers can be animatable within the framework .

As used herein a key is a string that identifies a specific property of an object. Typically a key corresponds to the name of an accessor method or instance variable in the receiving object. As used herein a key path is a string of keys separated by dots. The key path is used to specify a sequence of object properties to traverse. The property of the first key in the sequence is relative to the receiver and each subsequent key is evaluated relative to the value of the previous property. For example the key path address.street would get the value of the address property from the receiving object and then determine the street property relative to the address object.

In one example of animatible filters a generalized filtering model may include maskop mask compositeop layerop layer backgroundop background background . Here layerop can be a unary image operator that processes the foreground image. For example layerop could be used to add a glow to a layer. Backgroundop can be a unary image operator that processes the background image. For example backgroundop could be used to ripple the background. In addition compositeop can be a binary image operator that combines the foreground and background and it can default to source over or to source over with shadow if present. Finally maskop can be a ternary operator that takes a mask and two images and blends them together.

Although the framework preferably provides a number of default animations overrides can be made available to specify particular animation behaviors. In this way the GUI of the application can be essentially programmed for goal states and the framework can handle the details of animating the layers of the application s GUI towards those goal states. The application therefore can be developed as if the application is animating the layers of the GUI. However the application never truly animates the layers of the GUI when the implicit animations of the framework are used.

The framework defines a timing protocol called CATiming that is implemented by layers and animations. Details related to this protocol are included in the incorporated file CATiming. The timing protocol of the framework models a hierarchical timing system with each object describing the mapping from time values in the object s parent to local time. Absolute time is defined as mach time i.e. machine time converted to seconds. A CACurrentTime function is provided as a convenience for querying the current absolute time. Conversions can also be made between different versions of time. The timing model of the framework can allow animations to repeat their basic duration multiple times and can optionally allow animations to play backwards before repeating.

Animations may use various timing functions defined in the framework . For example the timing functions in the framework can generally be represented by segments of functions describing timing curves. These functions can map input time normalized to a range such as between 0 1 to output time also in the range 0 1 . The timing functions for the framework can be used to define the pacing of an animation over its duration or over the duration of one keyframe . Common timing functions can also be created and used in the framework such as linear easeIn easeOut and easeInEaseOut. In addition timing functions can be created that are modeled on a cubic Bezier curve where the end points of the curve are at 0 0 and 1 1 and where the two points c1 and c2 defined by the class instance are the control points. Thus the points defining the Bezier curve can be 0 0 c1 c2 1 1 . 

Not all time varying images however can be modeled as state transitions of the layers from one state to another state. Some layers e.g. Video Flash or Quartz Composer are media layers in that these media layers have timing and other behaviors that are intrinsic to them. Because media layers may need to be representable as nodes in the layer tree the framework includes a MediaLayer abstraction for interacting with CoreVideo compliant media. The MediaLayer abstraction is used for the media layers of the layer tree that have intrinsic animation and that have their appearance change as a function of time. The media layers can reference a media file. The media can be abstract and needs to provide a compliant frame for time accessor for the render tree process to use and needs to provide a time mapping between the notion of time for the render tree process and the notion of time for the media in the media layer. All of the standard layer attributes Opacity transform shadow etc. can be applied in the render tree process for the media layer.

Other common objects for display in an application s GUI that have intrinsic timing include the pulsing button rotating gear progress bar animated GIF or other similar objects. These can be specified by a particular type of media layer that has its animation represented by a set of images. For this type of media layer the layer itself can provide a time varying method for drawing itself for each frame when rendered from the render tree . For example the framework samples this type of media layer at an appropriate number of times and provides the frames as an atomic set to the render tree process . The render tree process then plays out the animation either in a one shot fashion or more typically in a looped fashion so that the layer can be animated for display.

A layer can exhibit a number of behaviors when its frame rectangle is changed by the application . In a default mode the bounds i.e. the coordinate system are not changed and the layer s contents are merely scaled. Since a display list representing the content is resolution independent the display list just needs to be replayed through the new current transformation matrix CTM which is used to transform the bounds and frame of the layers. The other mode of resizing a layer is just to give the resized layer more or less real estate and not to change the size of any of its items. In this case any sublayers of the resized layer are resized according to their auto sizing information. This information relates how a sublayer s frame changes when its parent layer s bounds change. Because each layer retains its own drawing information resizing can occur without necessarily invoking drawing code of the application . The only case where intervention by the application may be necessary is when a layer s representation is a function of its bounds such as text layout . In this case the application may defer computing the new representation for the text layer and can work with the old representation for the text layer until the resize is complete.

Layer classes define the content attributes geometry transformation matrix coordinate system and relationships of layers all of which have been described elsewhere herein. The layer classes also define the timespaces duration speed and time offsets for the layers using a CATiming protocol. Like its coordinate system a layer s timespace is defined relative to the timespace of its parent layer so that doubling the speed of a given layer will result in also doubling the speed of animations that occur in its sublayers. Features of the layer classes are also used to manage the animations and actions associated with layers. For example layers receive action triggers in response to layers being inserted and removed from the layer tree modifications being made to layer properties or explicit requests. These action triggers typically cause an animation to begin.

The parent class for all layers of the framework is CALayer of the layer classes . Subclasses of CAlayer allow applications to display other types of content. CATextLayer class is used to create a layer s content from a string or attributed string. CAOpenGLLayer class provides an OpenGL rendering environment that is subclassed to provide static or updated content using OpenGL. OPENGL is a registered trademark of Silicon Graphics Inc. of Mountain View Calif. CAScrollLayer class simplifies displaying a portion of a layer. The extent of the scrollable area of a CAScrollLayer object is defined by the layout of its sublayers. In one embodiment CAScrollLayer may not provide for keyboard or mouse event handling or provide visible scrollers although in other embodiments it could provide any one of these. QCCompositionLayer provided by the QuartzComposer framework animates a QuartzComposer composition as its content.

Animation and timing classes are used to animate the entire contents of a layer or selected attributes using both basic animation and key frame animation. The animation and timing classes descend from a CAAnimation class that uses the key value coding protocol for supporting an extended key value coding mechanism. CAAnimation also uses a CATiming protocol that provides the duration speed and repeat count for an animation and uses a CAAction protocol for starting an animation in response to an action triggered by a layer.

The CAAnimation class allows an array of animation objects to be grouped together and run concurrently. The CAAnimation class also defines timing functions that describes the pacing of animation as a Bezier curve. For example a linear timing function specifies that the animation s pace is even across its duration while an ease in timing function causes an animation to slow down as it nears the end of its duration.

Some other animation and timing classes include CATransition that provides a transition effect that affects the entire layer s content. The transitions effects can be used to fade push or reveal layer content when animating. Default transition effects can also be extended by using Core Image filters to modify the effects. CAPropertyAnimation is used for animating a layer property specified by a key path and CABasicAnimation can be used for interpolating a layer property. In addition CAKeyFrameAnimation is used for key frame animation of a layer. For example the key path of the layer property to be animated is specified along with an array of values that represent the value at each stage of the animation and arrays of key frame times and timing functions. As the animation runs each value is set in turn using the specified interpolation.

Layout Manager classes are used for positioning layers relative to their superlayer and for defining constraint of a CAConstraint class that describe the relationship of one geometric attribute of a layer the left right top or bottom edge or the horizontal or vertical center in relation to a geometric attribute of one of its sibling layers or its superlayer. A transaction management class is used to manage transactions of the layers. Because every modification to the layer tree See is part of a transaction a CATransaction class is used for batching multiple layer tree operations into atomic updates to the render tree See . Transactions can also be nested and supported transaction types include implicit transactions and explicit transactions as already discussed.

Having detailed various classes of the disclosed framework above we now turn to a brief discussion of how the disclosed framework may operate in conjunction with other software components on a general purpose processing device such as a computer. illustrates one embodiment of a software stack showing an Operating System O S kernel O S services resources Core Animation framework application frameworks and services and applications which are diagrammatically stacked in software levels. In general elements shown in one software level use the resources from the levels positioned below and provide services to the software levels positioned above.

The resources are above the O S services and include graphics resources such as Open Graphics Library OpenGL etc. OpenGL developed by Silicon Graphics Inc. is a specification for various graphics functions. Core Animation is positioned between the resources and the application frameworks and services . The frameworks and services is an amalgamation of functions and can include Cocoa QuickTime etc. These frameworks and services provide high level and often functional support for applications residing in the highest level.

In practice an application may be developed for Cocoa or another application framework or service and may support features of Core Animation . For example the application may enable NSViews to be bound to the layer classes used in Core Animation . In turn Cocoa can bind its properties to the properties associated with Core Animation . Then when the application makes a change to a property the layer model object in the layer tree is changed and Core Animation ties an animation object to the layer tree object. Then according to the teachings disclosed herein the APIs of Core Animation can handle the animation using the layers in the render tree during independent operations that are separate from the operations of the application.

Various attributes or properties for layers can be defined in the framework and are discussed in incorporated application Ser. No. 11 500 154. Additional attributes or properties are also discussed in the incorporated files such as CALayer in the Computer Program Listing Appendix.

In addition to attributes the framework has methods or functions some of which have already been discussed and some of which are discussed in incorporated application Ser. No. 11 500 154. Additional methods or functions are also discussed in the incorporated files in the Computer Program Listing Appendix.

The GUI for the application will typically have layers that incorporate interactive behavior for producing events. For example a layer of the application can represent a button of the GUI. Because a button in the framework is made up of many sublayers e.g. title left cap center right cap shadow the hierarchy for interacting with the button is likely to be much coarser grained than the layer tree . Accordingly the framework can provide a protocol implemented by the layers that provide interactive behaviors e.g. a mouse suite of methods a keyboard suite etc . . . . Alternatively the layers for the button or other interactive event can be aggregated into an interactive object defined in the framework so that the individual layers can be handled together as a group.

For example the framework can define action objects that respond to events via the CAAction protocol. The CAAction protocol which is detailed in the incorporated files may be used to trigger an event named as a path on a receiver function. The layer on which the event happened is identified in the protocol and arguments of the protocol can carry various parameters associated with the event. When an action object is invoked it receives three parameters the name of the event the layer on which the event happened and a dictionary of named arguments specific to each event kind There are three types of events property changes externally defined events and layer defined events. Whenever a property of a layer is modified the event with the same name as the property is triggered. External events are determined by calling a key path and looking up the action associated with the event name.

As shown in and in summary of previous discussions the API s interface with the application that is executing on the processing device and that has graphical content e.g. a user interface . Layer tree information has a data structure of layers model objects that are maintained based on the graphical content of the application . In addition render tree information has a data structure of layers renderable objects that are maintained independently of the application and are based on the model objects in the layer tree information . To render content to the display of the processing device the layers in the render tree information are made available to a rendering process not shown .

At some point during processing a modification of at least a portion of the application s graphical content is identified. For example a layer is modified changed inserted removed etc. in the layer tree information by the application so that an animation object is added to one or more layers in the render tree information . Alternatively the application can make an explicit request for a modification.

In response to the modification one or more API s perform explicit and or implicit manipulations or animations on the layers properties etc. in the render tree information as they are rendered for display. Each of the manipulations or animations can be implicitly or explicitly controlled using directional information e.g. from left from right from top from bottom etc. timing information linear discrete paced ease in ease out ease in and out cubic Bezier curve etc. specific values for starting ending interpolating etc. and other controls disclosed herein.

In a first example the API s animate one or more properties of one or more layers in the render tree information in response to the modification. Various properties of a layer can be classified as being animatable and these layer properties have corresponding properties in the render tree information that contain the current presentation value to be displayed. Some animatable properties include but are not limited to the z component of a layer s position in its superlayer the anchor point of a layer whether a layer is hidden background color corner radius border width boarder color opacity one or more CoreImage filters shadow properties and any combination thereof. The example in shows the animation of the border width of a layer i.e. the border width has been increased which can be controlled using directional and timing information.

In a second example the API s animate a transition of one or more layers in response to a modification. The transition can include but may not be limited to fade in fade out move in move out push reveal and any combination thereof for one or more layers in the render tree information . These transitions can also be controlled using directional information and timing information. The example of shows a transition of a layer i.e. the circle moving in and being revealed from a bottom direction in a paced pattern as the layer is iteratively made available for display.

In third and fourth examples and the API s can use different animation schemes to animate layers. The third example of shows a basic animation scheme for animating layers between interpolated values in a single key frame for rendering. The fourth example of shows a key frame animation scheme for animating layers over a number of key frames. As discussed previously the animation schemes can be based on a number of timing functions and set to occur over one or more key frames.

In a fifth example the API s animate a transformation of one or more layers in response to a modification. The transformation can include but may not be limited to translating the layer from one position to another scaling the layer in one or more directions rotating the layer about a point or axis warping or stretching the layer in at least one direction folding at least a portion of the layer and any combination thereof The transformation can be three dimensional based on one or more axes and controlled using directional and timing information as well. For example to draw attention to layers when displayed the transformation matrices of the layers can be manipulated by the API s so that the layers are spun 360 around when rendered for display. Further details are provided in the files CALayer and CATransformation3D incorporated herein.

In a sixth example the API s scroll one layer scrollable layer within another layer framing layer . For example a visible region of the scrollable layer in the render tree information can be scrolled to a particular point or until a certain region is visible within the framing layer in which it is contained. The scrolling performed by the API s can be controlled by directional and timing information and by one or more axes i.e. vertical horizontal or both . Preferably content of the scrollable layer in the render tree information is tiled so the various tiles can be handled asynchronously during the rendering process. Further details are provided in the files CAScrollLayer and CATiledLayer incorporated herein.

As noted previously separating the layer tree process from the render tree process offers a number of benefits in the framework of the present disclosure. In addition to these benefits the framework of the present disclosure preferably improves resource management using a dirty regions technique and a buffer handling technique discussed in incorporated application Ser. No. 11 500 154.

Reference to Core Animation herein essentially corresponds to reference to Layer Kit as used in the incorporated application Ser. No. 11 500 154. Thus elements denoted by CA essentially correspond to similar elements in the parent application denoted by LK. In other words CAAnimation as used herein essentially corresponds to LKAnimation as used in the parent application.

It will be appreciated that the present disclosure amply illustrates to a computer programmer of skill how to make and use the disclosed framework for graphics animation and compositing operations. Therefore programming the features and functional aspects of the disclosed framework would be a routine matter to a computer programmer of skill with the benefit of the present disclosure and can be accomplished using many different programming languages and within the context of many different operating systems. Of course the disclosed framework would be ultimately coded into a computer code and stored on a programmable storage device such as a compact disk a tape stored in a volatile or non volatile memory etc.

The foregoing description of preferred and other embodiments is not intended to limit or restrict the scope or applicability of the inventive concepts conceived of by the Applicants. In exchange for disclosing the inventive concepts contained herein the Applicants desire all patent rights afforded by the appended claims. Therefore it is intended that the appended claims include all modifications and alterations to the full extent that they come within the scope of the following claims or the equivalents thereof

