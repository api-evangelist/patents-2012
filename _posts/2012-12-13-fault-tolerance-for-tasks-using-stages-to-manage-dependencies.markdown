---

title: Fault tolerance for tasks using stages to manage dependencies
abstract: A high availability system has an application server communicatively coupled to one or more client machines through a network utilizing stateless communication sessions. The application server manages concurrent execution of tasks on multiple client machines. A task may be dependent on the execution of another task and the dependencies are managed through stages. The application server utilizes a fault tolerance methodology to determine a failure to any one of the components within the system and to perform remedial measures to preserve the integrity of the system.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158610&OS=09158610&RS=09158610
owner: MICROSOFT TECHNOLOGY LICENSING, LLC.
number: 09158610
owner_city: Redmond
owner_country: US
publication_date: 20121213
---
This application is a continuation in part of U.S. patent application Ser. No. 13 197 797 filed on Aug. 4 2011.

A system administrator or developer in a data processing system may often be required to execute a large list of tasks or processes. The easiest way to schedule the list of tasks is to run them sequentially. However sequential execution of each task may not fully utilize the system s resources and may increase the completion time for all the tasks to execute. An alternative to sequential execution is to execute each task in parallel with the other tasks. Although running the tasks in parallel may be more efficient it may also be more complicated due to dependencies that exist between the various tasks in the list. For example some tasks may temporarily change the topology of the system in such a way that other tasks running in parallel may fail. Other tasks may depend upon the output or changes made to data generated by previously executed tasks in the list. However certain tasks may not complete or fail thereby preventing subsequent dependent tasks from being executed. Yet other tasks may have dependencies on instructions from other tasks being executed in a particular order.

This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter nor is it intended to be used to limit the scope of the claimed subject matter.

A high availability data processing system has an application server and multiple client machines that communicate through a network. The system employs an infrastructure that can recover from failures seamlessly with no downtime and no required action from a developer. The system automatically detects failures from any component within the system and takes an automatic action after a detected failure to ensure the correct behavior of the system.

The application server manages the execution of tasks on the client machines so that multiple tasks execute concurrently. The dependencies between the tasks are controlled through the use of stages. Each task is associated with a stage that uniquely identifies a task and a maximum stage that identifies the stages that can execute concurrently with the task. The application server controls and tracks execution of the tasks on the multiple client machines in the order specified by the stages.

The application server interacts with one or more client machines through a sequence of stateless communication sessions. The application server utilizes a server fault tolerance module to determine when a client machine or the network has encountered a failure and initiates an appropriate measure to ensure that each task executes properly. The client machine utilizes a client fault tolerance module to determine when the application server or the network has failed and the appropriate measures to employ.

These and other features and advantages will be apparent from a reading of the following detailed description and a review of the associated drawings. It is to be understood that both the foregoing general description and the following detailed description are explanatory only and are not restrictive of aspects as claimed.

Various embodiments pertain to a technology for utilizing a fault tolerance methodology in a high availability data processing system that executes tasks concurrently using stages. The high availability data processing system utilizes an application server to manage the concurrent execution of tasks on multiple client machines. The application server and the client machines communicate through stateless communication sessions over a network. The fault tolerance methodology evaluates the various components of the system that are subject to failure such as the application server the client machines and the network and automatically takes actions to reduce downtime of the system identify inevitable faults and recover the infrastructure to a stable operational state.

The fault tolerance methodology utilizes redundancy identifies failures in the system and initiates actions to be taken when a failure is detected. Redundancy may be achieved based on cost considerations. In one or more embodiments the system may utilize redundant machines for the application server and for each of the client machines in order to improve availability and to reduce the chance of failures. The redundant machines across multiple datacenters would also ensure resilience against network failures.

In one or more embodiments redundancy may be implemented on the application server only. The infrastructure may utilize a backup server to support the application server in the event there is a failure to the application server. However the infrastructure may utilize more cost effective means to implement redundancy for the application server such as without limitation a file system share and the like. For example if the application server was implemented as an SQL server a file system share may be utilized as a backup source. The file system would not be affected by the same failure factors that may affect the SQL server such as incorrect SQL server updates malicious attacks to an SQL server erroneous configuration of a network that affects an SQL server port and the like.

The fault tolerance methodology automatically detects failures in any component of the infrastructure such as the application server a client machine and the network. In order for the system to facilitate greater scalability the client machines are transparent to the application server and communications between the application server and the client machines are done using a stateless communication protocol. As such each client machine contacts the application server to request execution of a task and the application server approves or denies execution of the task based on the stages associated with the task and other pending tasks. The client machine updates the application server when a task is completed or when the client machine requests additional time to complete a task.

Failures to a client machine or network may be detected when the application server does not receive requests from one or more of the client machines. In addition a client machine or network failure may be detected when the application server does not receive a completion message or an additional time request from one or more of the client machines. A client machine may detect a failure to the application server when the client machine does not receive a response from a request after several attempts in sending the request. In this situation the client machine contacts the redundant backup and continues its communications with the redundant backup.

The fault tolerance methodology may employ one of several actions when a failure is detected. Based on the type of failure and the nature of the tasks executing the system may elect a best effort approach that attempts to execute as many tasks as possible. In some scenarios this approach is advantageous. For instance when one or more tasks are scheduled to be executed automatically during the night. In this case ceasing execution of a task after a failure does not save resources. The system may elect to continue execution of as many tasks as possible during the night and mange the effects of the failure at a later time. The system logs data pertaining to the failure in order to analyze the failure at a later time.

In this case if the application server detects that a client machine does not return a completion message or an additional time request to the application server within an estimated time interval the application server marks that task as completed and allows other dependent tasks to execute. If a client machine does not receive a response from the application server the client machine assumes there may be a failure with the application server and proceeds to execute its tasks. In addition the client machine may contact the backup server to continue communications with the backup server. If the failure is due to a network failure the task eventually timeouts in the application server and the other dependent tasks execute.

Alternatively for other tasks a more conservative approach may be employed. After a detected failure no other tasks are executed and the state of the system is preserved for analysis. In some situations running tasks after a failure may be disastrous. For instance if the tasks at hand pertain to a service update scenario the system should stop execution of the tasks after a failure has been detected.

If the application server detects a client machine that is not responsive in a timely manner the application server assumes that the client machine has experienced a failure and blocks all other tasks from running and preserves the state of the system. If a client machine detects a failure when communicating with the application server the client machine does not proceed executing the task and attempts to communicate with the backup server.

Attention now turns to a more detailed description of the embodiments. First a detailed description is provided that describes using stages for managing dependencies between tasks executed in parallel. Thereafter the detailed description describes embodiments pertaining to fault tolerance detection and processing in a system that utilizes stages for managing dependencies between tasks executed concurrently.

The application server executes a task dependencies management module . According to one embodiment the task dependencies management module is responsible for managing the dependencies in the parallel execution of a number of tasks A N referred to herein generally as tasks on a number of execution resources A N referred to herein generally as execution resources in the operating environment . The task dependencies management module may be implemented as hardware software or a combination of the two. The task dependencies management module may be an add in or component of a batch processing system a software testing suite or the like and may include a number of application program modules and other components executing on the application server and or other computers or computing devices.

The tasks may include any computer executable instructions presented in any form such as software programs application modules database scripts stored procedures system scripts testing profiles and the like. The execution resources may include computing resources for executing the tasks such as CPUs virtual machines execution threads runtime engines batch processors database engines testing engines and the like. The execution resources may be provided by the application server and or one or more other computers or computing devices in the operating environment .

According to embodiments the tasks for parallel execution are defined in a task definition list . The task definition list includes a definition of each task to be executed. In one embodiment the definition of each task in the task definition list comprises a tuple including a task ID identifying the task to be executed a numeric stage of execution for the task and a maximum stage indicating a maximum stage of execution that can be executed in parallel with the task. The stage and maximum stage of each task are used by the task dependencies management module to determine which tasks defined in the task definition list may be executed in parallel. The stages and maximum stages defined in the task definition list may be based on the dependencies between the tasks. According to embodiments each task is assigned to only one stage and each stage may contain multiple tasks. Tasks assigned to the same stage may run in parallel. In addition all the tasks assigned to stages that are less than a current maximum stage can also be executed in parallel.

Therefore the task dependencies management module may determine if a particular task may be executed based on the stage and or maximum stage of all other pending or running tasks. Particularly a task A with stage SA and maximum stage MA will be allowed to execute unless another task B is pending or currently running with stage SB less than SA and maximum stage MB less than SA. For example the task definition list may include four tuples defining four tasks A B C and D as shown below in Table 1.

According to the task definitions shown in Table 1 task A will be allowed to execute at any time since no other defined task has a maximum stage less than the stage SA of task A i.e. MB SA MC SA and MD SA. Task B may also execute at any time for the same reasons MA SB MC SB and MD SB . However task C may only execute after task B is complete because while the maximum stage MA of task A and the maximum stage MD of task D are both greater than or equal to the stage SC i.e. MA SC and MD SC the maximum stage MB of task B is less than the stage SC. Similarly task D may only be executed alone once tasks A B and C are complete MA

In one embodiment the task definition list may comprise an extensible markup language XML file with a node defining each task . shows a sample portion of XML from a task definition list according to the embodiment. The XML may include a Task node for each task . The task node may include a Name attribute identifying a script profile or definition of the associated task . The task node also includes a Stage attribute specifying the numeric stage of the task and a MaximumStage attribute specifying the maximum stage. For example as shown in a task identified as BVT Client BecWebService.xml may have a stage of 001 and a maximum stage of 019. In another embodiment the Task nodes may be grouped under a parent node such as a Batch Group or Cycle node with its own name or identifier and multiple batches or groups may be defined in the task definition list .

According to the task definition list defined by the XML all tasks in the listing except BVT SubscriptionExtendedTests.xml and UnlistedBVTProfiles would be allowed to run in parallel with the task BVT Client BecWebService.xml. Similarly the task BVT AuthZExtendedTests.xml is set to execute in stage 001 but only other tasks assigned to stage 001 may run in parallel with the task. Therefore the task BVT Aws.xml which is set to execute in stage 002 will not be allowed to execute until the BVT AuthZExtendedTests.xml has completed.

In other embodiments the task definition list may be stored in a delimited flat file a database table or any other mechanism known in the art for storing structured data. As further shown in each task has only one associated entry in the task definition list making the listing easy to maintain and ensuring that the solution scales well. The concept of stages may also allow for increased maintainability as it groups parallel tasks in the same stage. Once the tasks are mapped to stages in the task definition list the task dependencies management module need only read the stage configuration and base the decision whether to run a task on the stage and maximum stage data. There is no extra design effort required from system administrators or developers.

According to one embodiment the task dependencies management module reads and parses the task definition list in order to provide an indication of whether a particular task is allowed to execute or not upon request for permission to execute the task from an execution resource . The task dependencies management module may implement an application programming interface API that is used by the execution resources to determine whether tasks may be executed based on the defined dependencies. When an execution resource becomes available the execution resource may utilize the API to request permission to execute a particular task from the task dependencies management module by specifying the task ID such as the task Name attribute for example. The task dependencies management module may utilize the stage and maximum stage defined for the identified task in the task definition list along with knowledge of the completed and currently executing tasks to determine if the requested task can currently be executed using a procedure similar to that described below in regard to . The task dependencies management module may then return an indication of whether the specified task may currently be executed to the requesting execution resource .

The execution resources may also utilize the API to update the task dependencies management module on the completion of a particular task as well as whether the task completed successfully or not. The task dependencies management module may track the completed tasks and or the currently executing tasks in an executed task list . The executed task list may be utilized to determine whether a particular task may be executed as described above. The executed task list may be stored in a memory of the application server or may be stored in a database or other storage mechanism accessible by the server.

According to another embodiment the task dependencies management module reads the task definitions from the task definition list and initiates execution of the defined tasks in stage order on the available execution resources in the environment . The task dependencies management module may further monitor execution of the tasks on the execution resources to determine when a task completes and an execution resource becomes available. Upon completion of a task and or an execution resource becoming available the task dependencies management module utilizes the stage and maximum stage defined for each task to determine which task s may be executed next.

In a further embodiment the task definition list is parsed and the task definitions contained therein are stored in a table of a database on the application server . The executed task list may also be stored in the database and the functionality required by the task dependencies management module to determine whether a particular task may execute as will be described below in regard to may be implemented in stored procedures. The database may expose the API and the stored procedures executed to handle each request made by an execution resource as described above.

Referring now to additional details will be provided regarding the embodiments presented herein. It should be appreciated that the logical operations described with respect to are implemented 1 as a sequence of computer implemented acts or program modules running on a computing system and or 2 as interconnected machine logic circuits or circuit modules within the computing system. The implementation is a matter of choice dependent on the performance and other requirements of the computing system. Accordingly the logical operations described herein are referred to variously as operations structural devices acts or modules. These operations structural devices acts and modules may be implemented in software in firmware in special purpose digital logic and any combination thereof. It should also be appreciated that more or fewer operations may be performed than shown in the figures and described herein. The operations may also be performed in a different order than described.

The routine begins at operation where the task dependencies management module loads a list of tasks from the task definition list . As described above in regard to the task definition list may comprise one or more tuples defining a task ID stage and maximum stage for each task. According to embodiments the list of tasks parsed from the task definition list may be stored in memory of the application server or in a database table or other storage mechanism accessible by the server. It will be appreciated that the operation to load the list of tasks from the task definition list may only be executed once by the task dependencies management module at the beginning of the execution of a group or batch of tasks defined in the task definition list instead of upon every request.

From operation the routine proceeds to operation where the task dependencies management module receives the task ID of the task to be executed. For example an execution resource may utilize the API of the task dependencies management module to request permission to execute a particular task . The request may specify a task ID of the task such as the task Name attribute described above in regard to .

The routine then proceeds from operation to operation where the task dependencies management module determines whether the specified task may be executed based on the stage and maximum stage of all other pending or running tasks . Particularly the task dependencies management module determines if any pending or currently running task has a stage or maximum stage that is less than the stage defined for the specified task. If another task B is pending or currently running with a stage SB less than the stage SA of the retrieved task and a maximum stage MB less than SA the specified task is not allowed to run in parallel with or prior to the other task and the routine proceeds to operation where the task dependencies management module prevents the specified task from being executed. For example the task dependencies management module may respond to the requesting execution resource with an indicator indicating that the specified task may not be executed at this time.

However if no other pending or currently running task has a stage or maximum stage that is less than the stage defined for the specified task then the routine proceeds from operation to operation where the specified task is allowed to execute. For example the task dependencies management module may respond to the requesting execution resource with an indicator indicating that the task may be executed. From operations or the routine ends.

In a further embodiment a client module may execute on a remote computer and manage the execution of the tasks defined in a local list or group of tasks on a subset of the execution resources . Upon detecting that an execution resource is available the client module may determine the next task in the local list of tasks to be executed and utilize the API of the task dependencies management module to request permission to execute the task by providing a task ID for example. The task execution module will utilize the routine described above to determine if the task is allowed to execute based on the stage and maximum stage of the other pending and currently running tasks as determined from the list of tasks and the executed task list .

The task execution module may then respond to the client module with an indicator indicating whether the task may be executed or not. If the task may be executed then the client module will initiate the task on the available execution resource . If the task may not be executed then the client module will select the next task in the local task list for execution and request permission for execution of that task from the task dependencies management module . In another embodiment the client module may execute on the same application server as the task dependencies management module or may be a component of the task dependencies management module and the local task list may be the task definition list .

Attention now turns to a description of embodiments employing fault tolerance. illustrates an exemplary high availability data processing system that executes tasks using stages to manage dependencies among the tasks. The system may include an application server and one or more client machines A C referred to herein generally as tasks that are communicatively coupled to the application server through a communications framework . In addition the system includes a backup server communicatively coupled to the application server . The application server and the backup server interact with a redundancy module .

The system also includes a task definition list and an executed task list that may be accessed by the application server and the backup server . Although the system as shown in has a limited number of elements in a certain topology it may be appreciated that the system may include more or less elements in alternate topologies as desired for a given implementation.

An application server may include a task dependencies management module . The task dependencies management module is responsible for managing the dependencies in the parallel execution of a number of tasks A N referred to herein generally as tasks on a number of client machines A C referred to herein generally as client machines . The task dependencies management module on the application server may include a server fault tolerance module . The server fault tolerance module detects network and client machine failures and processes these failures accordingly.

The backup server is a computing device that takes over the processing activities of the application server in the event of a failure to the application server . The backup server may be implemented as any type of computing device capable of performing the same operations and functions as the application server. The backup server may be implemented as a file system share a server a network access storage device and so forth.

The backup server may include a task dependencies management module and a redundancy module . The task dependencies management module may include a server fault tolerance module . The task dependencies management module is similar to the task dependencies management module of the application server so that the backup server is able to continue processing in the same manner as the application server in the event of a failure to the application server .

The redundancy module communicates with the backup server and the application server to track the state of the application server in order to continue operations in the event of a failure to the application server . The redundancy module may use any of the well known techniques for implementing redundancy such as checkpoints restarts redundant multi threading backing up and restoring data and so forth.

In some embodiments the redundancy module may be duplicated in both the application server and the backup server . The redundancy modules communicate with each other synchronize the state of the application server and identify the time when the backup server takes over.

In one or more embodiments the redundancy module may be partitioned into two segments. One segment may be embodied in the application server e.g. server front end and another segment may be embodied in the backup server . In other embodiments the redundancy module may be implemented in a separate computing device.

The tasks for execution are defined in a task definition list . The task definition list includes a definition of each task to be executed as described above. An executed task list may be utilized to determine whether a particular task may be executed as described above. The task definition list and the executed task list may be stored in a central repository accessible by both the application server and the backup server . By storing the lists in this manner a current version of these lists may be available to the backup server when the backup server takes over for the failed application server .

A client machine may include one or more tasks a client task module and a client fault tolerance module . The client task module manages execution of a task on a client machine and interacts with the application server with respect to the scheduling of a task . The client fault tolerance module detects failures to the application server and or network.

In one or more embodiments the application server the backup server and the client machines may each be implemented as a computing device that may be any type of electronic device capable of executing programmable instructions. The computing device may be implemented as a mobile device a personal digital assistant a mobile computing device a smart phone a tablet a cellular telephone a handheld computer a server a server array or server farm a web server a network server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof.

In other embodiments a client machine and the backup server may be implemented as a sequence of computer program instructions that when executed by a processor causes the processor to perform methods and or operations in accordance with a prescribed task. These modules may be implemented as program code programs procedures module code segments program stacks middleware firmware methods routines and so on. The executable computer program instructions may be implemented according to a predefined computer language manner or syntax for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high level low level object oriented visual compiled and or interpreted programming language.

The client fault tolerance module the client task module the server fault tolerance module and the redundancy module may be implemented as a sequence of computer program instructions that when executed by a processor causes the processor to perform methods and or operations in accordance with a prescribed task. These modules may be implemented as program code programs procedures module code segments program stacks middleware firmware methods routines and so on. The executable computer program instructions may be implemented according to a predefined computer language manner or syntax for instructing a computer to perform a certain function. The instructions may be implemented using any suitable high level low level object oriented visual compiled and or interpreted programming language.

The communications framework facilitates communications between the application server and the client machines . The communications framework can embody any type of communications medium such as wired or wireless networks utilizing any communication protocol. The communications framework may be implemented as one or more computer networks that operate in accordance with one or more communication protocols i.e. Ethernet Internet protocol suite TCP IP 802.11 etc. . The embodiments are not limited in this manner.

Although the system shown in has a limited number of elements in a certain configuration it should be appreciated that the system can include more or less elements in alternate configurations. For example the application server may be arranged as a plurality of server machines. By way of another example the client machines may be implemented as processes that run within the application server . The application server and the client machines may be located within a same physical location and communicatively coupled through a local area network. Alternatively the application server may reside at one physical location and each client machine may reside in a separate physical location and communicate through the Internet.

Yet in other embodiments the application server and the client machines may be controlled by the same or different system administrators. For example the application server may be utilized as part of a service and the client machines may be operated by entities that differ from the entity operating the application server . Various configurations are possible and the embodiments are not limited in this manner.

Attention now turns to various exemplary methods. It may be appreciated that the representative methods do not necessarily have to be executed in the order presented or in any particular order unless otherwise indicated. Moreover various activities described with respect to the methods can be executed in serial or parallel fashion or any combination of serial and parallel operations. The methods can be implemented using one or more hardware elements and or software elements of the described embodiments or alternative embodiments as desired for a given set of design and performance constraints. For example the methods may be implemented as logic e.g. computer program instructions for execution by a logic device e.g. a general purpose or specific purpose computer .

In one or more embodiments a client machine and the application server communicate by exchanging messages within a session through a stateless communication protocol. A session is a sequence of messages that are exchanged between two devices in accordance with a protocol. In a stateless protocol a client machine and the application server communicate without saving any state information. State information may consist of protocol parameters user or client machine identifiers session identifiers authentication status and the like. For example the hypertext transfer protocol HTTP is a stateless protocol. Each request and response is treated as an independent communication that does not rely on information from a previous communication.

In one or more embodiments the application server operates as a stateless server. The application server does not save any state information from previous requests. The application server responds to each request without tracking state information of the client machine making the request. In this manner the application server is not constrained to communicating with a predetermined number of client machines since the application server does not have to maintain the resources needed to save each client machine s state information.

Otherwise block no the application server waits for requests from client machines block . If the application server does not receive task requests within a time interval block no then the application server detects a network failure and the application server enters into server failure mode block . A network failure is presumed to be the cause of the failure since no tasks have been received from any client machine.

Otherwise if a request to execute a task was received block yes then the application server checks if a previous failure was detected block . If a previous failure was detected block yes then the application server enters into server failure mode block . Otherwise if there were no previous failures block no then the application server determines if the task can execute based on the dependency of the stages as noted above with respect to block . If the task cannot execute then the application server responds to the client machine informing the client machine that the task is not ready to execute block . This may be due to a dependent stage that has not completed execution.

If the requested task can execute block yes then the application server waits for completion of the task block . At the estimated completion time the application server checks if a increase time message and completion message was received from the task. If a message have been received by the client machine previously indicating that the task will complete later block yes then the timeout interval is increased block and the process proceed to wait for completion of the task block .

If an increased time message has not been received block no then the application server checks if a task completion message has been received block . If a task completion message has not been received block no and a timeout interval has been reached block yes then the application server enters into server failure mode block . If a task completion message has been received block yes then the application server tracks completion of the task and updates the executed task list accordingly block . If a task completion message has not been received block no and the timeout interval has not been reached block no then the process proceeds to wait for completion of the task block .

If all tasks have been executed block yes then the application server returns to other processing. If there are remaining tasks to execute block no then the application server waits for a client request block . When a client request is received block the application server processes the request in accordance with an appropriate failure mode block . For the best effort mode block yes the request is logged and the application server gives the client machine permission to execute the task block . For the conservative mode block no the application server logs the request and then denies the client machine permission to execute the task block .

If the client machine does not receive a response from the application server block no then the client machine re transmits the request to the application server block no . If the number of retries has been reached block yes and the application server is acting as the primary server block yes then the client machine detects a server failure and commences communications with the backup server to request execution of the task block . Otherwise if the backup server is acting on behalf of the application server block no then the client machine goes into client failure mode block .

If the task has been granted permission to execute block yes then the client machine executes the task block . When the task completes block yes a completion message is sent to the application server block . If the task has not finished block no and the estimated completion time expires before the task completes block yes then the client machine sends the application server an additional time message indicating an updated estimated completion time block . It the task has not finished block no and the estimated completion time did not expire block no then the process waits until the task completes block .

When the task completes processing on the client machine block yes then a completion message is sent to the application server block . If the client machine has more tasks to execute block yes then the next task is selected from the task list block and the process continues bock . Otherwise if the client machine does not have more tasks to execute block no processing terminates.

Attention now turns to a discussion of an exemplary operating environment. Referring now to there is shown a schematic block diagram of an exemplary operating environment . It should be noted that the operating environment is exemplary and is not intended to suggest any limitation as to the functionality of the embodiments.

The embodiments may be applied to an operating environment having one or clients communicatively coupled through a communications framework with one or more servers . Each client may be communicatively coupled to one or more client data stores . Each server may be communicatively coupled to one or more server data stores .

A client may be embodied as a hardware device a software module or a combination thereof. The client may be any type of electronic device such as without limitation a mobile device a personal digital assistant a mobile computing device a smart phone a cellular telephone tablet a handheld computer a server a server array or server farm a web server a network server a blade server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof. The client may also be embodied as a software module having instructions that execute in a single execution path multiple concurrent execution paths e.g. thread process etc. or in any other manner.

Each server may be communicatively coupled to other servers through any type of communication interconnect such as a LAN WAN and so forth. A server may be embodied as a hardware device a software module or as a combination thereof. The server may be any type of electronic device capable of executing programmable instructions such as without limitation a mobile device a personal digital assistant a mobile computing device tablet a smart phone a cellular telephone a handheld computer a server a server array or server farm a blade server a web server a network server an Internet server a work station a mini computer a mainframe computer a supercomputer a network appliance a web appliance a distributed computing system multiprocessor systems or combination thereof. The server may also be embodied as a software module having instructions that execute in a single execution path multiple concurrent execution paths e.g. thread process etc. or in any other manner.

The communications framework facilitates communications between the clients and the servers . The communications framework may embody any well known communication techniques such as techniques suitable for use with packet switched networks e.g. public networks such as the Internet private networks such as enterprise intranet and so forth circuit switched networks e.g. the public switched telephone network or a combination of packet switched networks and circuit switched networks with suitable gateways and translators .

Attention now turns to a discussion of an exemplary application server and client machine . illustrates a block diagram of an exemplary application server . The application server may have one or more processors a display a memory and a network interface . A processor may be any commercially available processor and may include dual microprocessors and multi processor architectures. The display may be any visual display unit and may include a display having a touch screen embedded within the display. The network interface facilitates wired or wireless communications between the applications server and a communications framework.

The memory may be any computer readable storage media that may store executable procedures applications and data. The computer readable media does not pertain to propagated signals such as modulated data signals transmitted through a carrier wave. It may be any type of memory device e.g. random access memory read only memory etc. magnetic storage volatile storage non volatile storage flash memory drive optical storage DVD CD floppy disk drive and the like. The memory may also include one or more external storage devices or remotely located storage devices. The memory may contain instructions and data as follows 

The memory may be any computer readable storage media that may store executable procedures applications and data. The computer readable media does not pertain to propagated signals such as modulated data signals transmitted through a carrier wave. It may be any type of memory device e.g. random access memory read only memory etc. magnetic storage volatile storage non volatile storage flash memory drive optical storage DVD CD floppy disk drive and the like. The memory may also include one or more external storage devices or remotely located storage devices. The memory may contain instructions and data as follows 

Although the subject matter has been described in language specific to structural features and or methodological acts it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather the specific features and acts described above are disclosed as example forms of implementing the claims.

