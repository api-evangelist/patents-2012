---

title: Systems and methods for load balancing drives and servers by pushing a copy of a frequently accessed file to another disk drive
abstract: A file system that balances the loading of filers and the capacity of drives that are associated with the filers is described. The file system includes a first disk drive that includes a first unused capacity and a second disk drive that includes a second unused capacity, wherein the second unused capacity is smaller than the first unused capacity. The file system further includes a first filer that is configured to fill requests from clients through access to at least the first disk drive. The file system further includes a second filer that is configured to fill requests from clients through access to at least the second disk drive. The second filer is configured to select an infrequently accessed file from the second disk drive and to push the infrequently accessed files to the first disk drive, thereby improving a balance of unused capacity between the first and second disk drives without substantially affecting a loading for each of the first and second filers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08943513&OS=08943513&RS=08943513
owner: Overland Storage, Inc.
number: 08943513
owner_city: San Diego
owner_country: US
publication_date: 20120913
---
This application is a divisional application of and claims priority benefit under 35 U.S.C. 120 from U.S. application Ser. No. 11 238 405 filed on Sep. 29 2005 which application is a divisional application of and claims priority benefit under 35 U.S.C. 120 from U.S. application Ser. No. 10 060 918 filed Jan. 29 2002 both applications of which are hereby incorporated herein by reference in their entireties the second application of which claims priority benefit under 35 U.S.C. 119 e from each of the following U.S. Provisional Applications each of which is also incorporated herein by reference in its entirety 

This invention relates to the field of data storage and management. More particularly this invention relates to high performance mass storage systems and methods for data storage backup and recovery.

In modern computer systems collections of data are usually organized and stored as files. A file system allows users to organize access and manipulate these files and also performs administrative tasks such as communicating with physical storage components and recovering from failure. The demand for file systems that provide high speed reliable concurrent access to vast amounts of data for large numbers of users has been steadily increasing in recent years. Often such systems use a Redundant Array of Independent Disks RAID technology which distributes the data across multiple disk drives but provides an interface that appears to users as one unified disk drive system identified by a single drive letter. In a RAID system that includes more than one array of disks each array is often identified by a unique drive letter and in order to access a given file a user must correctly identify the drive letter for the disk array on which the file resides. Any transfer of files from one disk array to another and any addition of new disk arrays to the system must be made known to users so that they can continue to correctly access the files.

RAID systems effectively speed up access to data over single disk systems and they allow for the regeneration of data lost due to a disk failure. However they do so by rigidly prescribing the configuration of system hardware and the block size and location of data stored on the disks. Demands for increases in storage capacity that are transparent to the users or for hardware upgrades that lack conformity with existing system hardware cannot be accommodated especially while the system is in use. In addition such systems commonly suffer from the problem of data fragmentation and they lack the flexibility necessary to intelligently optimize use of their storage resources.

RAID systems are designed to provide high capacity data storage with built in reliability mechanisms able to automatically reconstruct and restore saved data in the event of a hardware failure or data corruption. In conventional RAID technology techniques including spanning mirroring and duplexing are used to create a data storage device from a plurality of smaller single disk drives with improved reliability and storage capacity over conventional disk systems. RAID systems generally incorporate a degree of redundancy into the storage mechanism to permit saved data to be reconstructed in the event of single or sometimes double disk failure within the disk array. Saved data is further stored in a predefined manner that is dependent on a fixed algorithm to distribute the information across the drives of the array. The manner of data distribution and data redundancy within the disk array impacts the performance and usability of the storage system and may result in substantial tradeoffs between performance reliability and flexibility.

A number of RAID configurations have been proposed to map data across the disks of the disk array. Some of the more commonly recognized configurations include RAID 1 RAID 2 RAID 3 RAID 4 and RAID 5.

In most RAID systems data is sequentially stored in data stripes and a parity block is created for each data stripe. The parity block contains information derived from the sequence and composition of the data stored in the associated data stripe. RAID arrays can reconstruct information stored in a particular data stripe using the parity information however this configuration imposes the requirement that records span across all drives in the array resulting in a small stripe size relative to the stored record size.

Information or files are stored on the disk array . Typically the writing of data to the disks occurs in a parallel manner to improve performance. A parity block is constructed by performing a logical operation exclusive OR on the corresponding blocks of the data stripe to create a new block of data representative of the result of the logical operation. The result is termed a parity block and is written to a separate area within the disk array. In the event of data corruption within a particular disk of the array the parity information is used to reconstruct the data using the information stored in the parity block in conjunction with the remaining non corrupted data blocks.

In the RAID architecture multiple disks a typically mapped to a single virtual disk . Consecutive blocks of the virtual disk are mapped by a strictly defined algorithm to a set of physical disks with no file level awareness. When the RAID system is used to host a conventional file system it is the file system that maps files to the virtual disk blocks where they may be mapped in a sequential or non sequential order in a RAID stripe. The RAID stripe may contain data from a single file or data from multiple files if the files are small or the file system is highly fragmented.

The aforementioned RAID architecture suffers from a number of drawbacks that limit its flexibility and scalability for use in reliable storage systems. One problem with existing RAID systems is that the data striping is designed to be used in conjunction with disks of the same size. Each stripe occupies a fixed amount of disk space and the total number of stripes allowed in the RAID system is limited by the capacity of the smallest disk in the array. Any additional space that may be present on drives having a capacity larger than the smallest drive goes unused as the RAID system lacks the ability to use the additional space. This further presents a problem in upgrading the storage capacity of the RAID system as all of the drives in the array must be replaced with larger capacity drives if additional storage space is desired. Therefore existing RAID systems are inflexible in terms of their drive composition increasing the cost and inconvenience to maintain and upgrade the storage system.

A further problem with conventional RAID arrays resides in the rigid organization of data on the disks of the RAID array. As previously described this organization typically does not use available disk space in an efficient manner. These systems further utilize a single fixed block size to store data which is implemented with the restriction of sequential file storage along each disk stripe. Data storage in this manner is typically inefficient as regions or gaps of disk space may go unused due to the file organization restrictions. Furthermore the fixed block size of the RAID array is not able to distinguish between large files which benefit from larger block size and smaller files which benefit from smaller block size for more efficient storage and reduced wasted space.

Although conventional RAID configurations are characterized as being fault tolerant this capability is typically limited to single disk failures. Should more than one or two disk fail or become inoperable within the RAID array before it can be replaced or repaired there is the potential for data loss. This problem again arises from the rigid structure of data storage within the array that utilizes sequential data striping. This problem is further exacerbated by the lack of ability of the RAID system to flexibly redistribute data to other disk areas to compensate for drive faults. Thus when one drive becomes inoperable within the array the likelihood of data loss increases significantly until the drive is replaced resulting in increased maintenance and monitoring requirements when using conventional RAID systems.

With respect to conventional data storage systems or other computer networks conventional load balancing includes a variety of drawbacks. For example decisions relating to load balancing are typically centralized in one governing process one or more system administrators or combinations thereof. Accordingly such systems have a single point of failure such as the governing process or the system administrator. Moreover load balancing occurs only when the centralized process or system administrator can organize performance data make a decision and then transmit that decision throughout the data storage system or computer network. This often means that the such load balancing can be slow to react difficult to optimize for a particular server and difficult to scale as the available resources expand or contract. In addition conventional load balancing typically is limited to balancing processing and communications activity between servers only.

The present invention solves these and other problems by providing a dynamically distributed file system that accommodates current demands for high capacity throughput and reliability while presenting to the users a single file system interface that appears to include every file in the system on a single server or drive. In this way the file system is free to flexibly transparently and on the fly distribute and augment physical storage of the files in any manner that suits its needs across disk drives and across servers and users can freely access any file without having specific knowledge of the files current physical location.

One embodiment includes a storage device and architecture which possesses features such as transparent scalability where disks of non identical capacity can be fully utilized without the dead space restrictions associated with conventional disk arrays. In one embodiment a flexible storage space allocation system handles storing large and small file types to improve disk space utilization. In another embodiment an improved method for maintaining data integrity overcomes the single drive or double fault limitation of conventional systems in order to increase storage reliability while at the same time reducing maintenance and monitoring requirements.

In one embodiment distributed parity groups DPG are integrated into the distributed file storage system technology. This architecture provides capabilities for optimizing the use of disk resources by moving frequently and infrequently accessed data blocks between drives so as to maximize the throughput and capacity utilization of each drive.

In one embodiment the architecture supports incorporation of new disk drives without significant reconfiguration or modification of the exiting distributed file storage system to provide improved reliability flexibility and scalability. Additionally the architecture permits the removal of arbitrary disk drives from the distributed file storage system and automatically redistributes the contents of these drives to other available drives as necessary.

The distributed file storage system can proactively position objects for initial load balancing such as for example to determine where to place a particular new object. Additionally the distributed file storage system can continue to proactively position objects thereby accomplishing active load balancing for the existing objects throughout the system. According to one embodiment one or more filters may be applied during initial and or active load balancing to ensure one or a small set of objects are not frequently transferred or churned throughout the resources of the system.

As used herein load balancing can include among other things capacity balancing throughput balancing or both. Capacity balancing seeks balance in storage such as the number of objects the number of Megabytes or the like stored on particular resources within the distributed file storage system. Throughput balancing seeks balance in the number of transactions processed such as the number of transactions per second the number of Megabytes per second or the like handled by particular resources within the distributed file storage system. According to one embodiment the distributed file storage system can position objects to balance capacity throughput or both between objects on a resource between resources between the servers of a cluster of resources between the servers of other clusters of resources or the like.

The distributed file storage system can comprise resources such as servers or clusters which can seek to balance the loading across the system by reviewing a collection of load balancing data from itself one or more of the other servers in the system or the like. The load balancing data can include object file statistics server profiles predicted file accesses or the like. A proactive object positioner associated with a particular server can use the load balancing data to generate an object positioning plan designed to move objects replicate objects or both across other resources in the system. Then using the object positioning plan the resource or other resources within the distributed file storage system can execute the plan in an efficient manner.

According to one embodiment each server pushes objects defined by that server s respective portion of the object positioning plan to the other servers in the distributed file storage system. By employing the servers to individually push objects based on the results of their object positioning plan the distributed file storage system provides a server process and administrator independent approach to object positioning and thus load balancing within the distributed file storage system.

In one embodiment the network file storage system includes a first file server operably connected to a network fabric a second file server operably connected to the network fabric first file system information loaded on the first file server and second file system information loaded on the second file server the first file system information and the second file system information configured to allow a client computer operably connected to the network fabric to locate files stored by the first file server and files stored by the second file server without prior knowledge as to which file server stores the files. In one embodiment the first file system information includes directory information that describes a directory structure of a portion of the network file system whose directories are stored on the first file server the directory information includes location information for a first file the location information includes a server id that identifies at least the first file server or the second file server.

In one embodiment the network file storage system loads first file system metadata on a first file server operably connected to a network fabric loads second file system metadata on a second file server connected to the network fabric the first file system metadata and the second file system metadata include information to allow a client computer operably connected to the network fabric to locate a file stored by the first file server or stored by the second file server without prior knowledge as to which file server stores the file.

In one embodiment the network file storage system performs a file handle lookup on a computer network file system by sending a root directory lookup request to a first file server operably connected to a network fabric receiving a first lookup response from the first file server the first lookup response includes a server id of a second file server connected to the network fabric sending a directory lookup request to the second file server and receiving a file handle from the second file server.

In one embodiment the network file storage system allocates space by receiving a file allocation request in a first file server the first file server owning a parent directory that is to contain a new file the file allocation request includes a file handle of the parent directory determining a selected file server from a plurality of file servers sending a file allocation request from the first server to the selected server creating metadata entries for the new file in file system data managed by the selected file server generating a file handle for the new file sending the file handle to the first file server and creating a directory entry for the new file in the parent directory.

In one embodiment the network file storage system includes a first file server operably connected to a network fabric a second file server operably connected to the network fabric first file system information loaded on the first file server and second file system information loaded on the second file server the first file system information and the second file system information configured to allow a client computer operably connected to the network fabric to locate files owned by the first file server and files owned by the second file server without prior knowledge as to which file server owns the files the first file server configured to mirror at least a portion of the files owned by the second file server the first file server configured to store information sufficient to regenerate the second file system information and the second file server configured to store information sufficient to regenerate the first file system information.

In one embodiment the network file storage system loads first file system metadata on a first file server operably connected to a network fabric loads second file system metadata on a second file server connected to the network fabric the first file system metadata and the second file system metadata include information to allow a client computer operably connected to the network fabric to locate a file stored by the first file server or stored by the second file server without prior knowledge as to which file server stores the file maintains information on the second file server to enable the second file server to reconstruct an information content of the first file system metadata and maintains information on the first file server to enable the first file server to reconstruct an information content of the second file system metadata.

In one embodiment the computer network file storage system is fault tolerant and includes a first file server operably connected to a network fabric a second file server operably connected to the network fabric a first disk array operably coupled to the first file server and to the second file server a second disk array operably coupled to the first file server and to the second file server first file system information loaded on the first file server the first file system information including a first intent log of proposed changes to the first metadata second file system information loaded on the second file server the second file system information including a second intent log of proposed changes to the second metadata the first file server having a copy of the second intent log the second file server maintaining a copy of the first intent log thereby allowing the first file server to access files on the second disk array in the event of a failure of the second file server.

In one embodiment a distributed file storage system provides hot swapping of file servers by loading first file system metadata on a first file server operably connected to a network fabric the first file system operably connected to a first disk drive and a second disk drive loading second file system metadata on a second file server connected to the network fabric the second file system operably connected to the first disk drive and to the second disk drive copying a first intent log from the first file server to a backup intent log on the second file server the first intent log providing information regarding future changes to information stored on the first disk drive and using the backup intent log to allow the second file server to make changes to the information stored on the first disk drive.

In one embodiment a distributed file storage system includes a first file server operably connected to a network fabric a file system includes first file system information loaded on the first file server the file system configured to create second file system information on a second file server that comes online sometime after the first file server has begun servicing file requests the file system configured to allow a requester to locate files stored by the first file server and files stored by the second file server without prior knowledge as to which file server stores the files.

In one embodiment a distributed file storage system adds servers during ongoing file system operations by loading first file system metadata on a first file server operably connected to a network fabric creating at least one new file on a second file server that comes online while the first file server is servicing file requests the at least one new file created in response to a request issued to the first file server the distributed file system configured to allow a requester to locate files stored by the first file server and files stored by the second file server without prior knowledge as to which file server stores the files.

In one embodiment a distributed file storage system includes first metadata managed primarily by a first file server operably connected to a network fabric the first metadata includes first file location information the first file location information includes at least one server id and second metadata managed primarily by a second file server operably connected to the network fabric the second metadata includes second file location information the second file location information includes at least one server identifier the first metadata and the second metadata configured to allow a requestor to locate files stored by the first file server and files stored by the second file server in a directory structure that spans the first file server and the second file server.

In one embodiment a distributed file storage system stores data by creating first file system metadata on a first file server operably connected to a network fabric the first file system metadata describing at least files and directories stored by the first file server creating second file system metadata on a second file server connected to the network fabric the second file system metadata describing at least files and directories stored by the second file server the first file system metadata and the second file system metadata includes directory information that spans the first file server and the second file server the directory information configured to allow a requestor to find a location of a first file catalogued in the directory information without prior knowledge as to a server location of the first file.

In one embodiment a distributed file storage system balances the loading of servers and the capacity of drives associated with the servers the file system includes a first disk drive including a first unused capacity a second disk drive including a second unused capacity wherein the second unused capacity is smaller than the first unused capacity a first server configured to fill requests from clients through access to at least the first disk drive and a second server configured to fill requests from clients through access to at least the second disk drive and configured to select an infrequently accessed file from the second disk drive and push the infrequently accessed files to the first disk drive thereby improving a balance of unused capacity between the first and second disk drives without substantially affecting a loading for each of the first and second servers.

In one embodiment a distributed file storage system includes a first file server operably connected to a network fabric a second file server operably connected to the network fabric first file system information loaded on the first file server and second file system information loaded on the second file server the first file system information and the second file system information configured to allow a client computer operably connected to the network fabric to locate files stored by the first file server and files stored by the second file server without prior knowledge as to which file server stores the files.

In one embodiment a data engine offloads data transfer operations from a server CPU. In one embodiment the server CPU queues data operations to the data engine.

In one embodiment a distributed file storage system includes a plurality of disk drives for storing parity groups each parity group includes storage blocks the storage blocks includes one or more data blocks and a parity block associated with the one or more data blocks each of the storage blocks stored on a separate disk drive such that no two storage blocks from a given parity set reside on the same disk drive wherein file system metadata includes information to describe the number of data blocks in one or more parity groups.

In one embodiment a distributed file storage system stores data by determining a size of a parity group in response to a write request the size describing a number of data blocks in the parity group arranging at least a portion of data from the write request according to the data blocks computing a parity block for the parity group storing each of the data blocks on a separate disk drive such that no two data blocks from the parity group reside on the same disk drive and storing each the parity block on a separate disk drive that does not contain any of the data blocks.

In one embodiment a distributed file storage system includes a plurality of disk drives for storing parity groups each parity group includes storage blocks the storage blocks includes one or more data blocks and a parity block associated with the one or more data blocks each of the storage blocks stored on a separate disk drive such that no two storage blocks from a given parity set reside on the same disk drive a redistribution module to dynamically redistribute parity groups by combining some parity groups to improve storage efficiency.

In one embodiment a distributed file storage system stores data by determining a size of a parity group in response to a write request the size describing a number of data blocks in the parity group arranging at least a portion of data from the write request according to the data blocks computing a parity block for the parity group storing each of the data blocks on a separate disk drive such that no two data blocks from the parity group reside on the same disk drive storing the parity block on a separate disk drive that does not contain any of the data blocks and redistributing the parity groups to improve storage efficiency.

In one embodiment a distributed file storage system includes a plurality of disk drives for storing parity groups each parity group includes storage blocks the storage blocks includes one or more data blocks and a parity block associated with the one or more data blocks each of the storage blocks stored on a separate disk drive such that no two storage blocks from a given parity set reside on the same disk drive and a recovery module to dynamically recover data lost when at least a portion of one disk drive in the plurality of disk drives becomes unavailable the recovery module configured to produce a reconstructed block by using information in the remaining storage blocks of a parity set corresponding to an unavailable storage block the recovery module further configured to split the parity group corresponding to an unavailable storage block into two parity groups if the parity group corresponding to an unavailable storage block spanned all of the drives in the plurality of disk drives.

In one embodiment a distributed file storage system stores data by determining a size of a parity group in response to a write request the size describing a number of data blocks in the parity group arranging at least a portion of data from the write request according to the data blocks computing a parity block for the parity group storing each of the data blocks on a separate disk drive such that no two data blocks from the parity group reside on the same disk drive storing the parity block on a separate disk drive that does not contain any of the data blocks reconstructing lost data by using information in the remaining storage blocks of a parity set corresponding to an unavailable storage block to produce a reconstructed parity group splitting the reconstructed parity group corresponding to an unavailable storage block into two parity groups if the reconstructed parity group is too large to be stored on the plurality of disk drives.

In one embodiment a distributed file storage system integrates parity group information into file system metadata.

As data storage requirements increase it is desirable to be able to easily increase the data storage capacity and or performance of a data storage system. That is it is desirable to be able to increase the available capacity and performance of a storage system without modifying the configuration of the clients accessing the system. For example in a typical Personal Computer PC network environment if a database accesses a network drive M it is desirable to be able to add storage to this drive all the while still calling the drive M as opposed to adding say drives N O and P as storage requirements increase. In some cases having to switch from a single drive M to four drives M N O P is a mere nuisance. However in some cases such a change requires significant reconfiguration of client configurations. In other cases such a change requires modification of existing application software and in some instances such a change simply will not work with the application being used.

The objective for more capacity can be met in some storage systems by adding additional disk drives to the system. However this may not result in increasing performance. In fact adding additional drives may cause a significant decrease in performance. This is because 1 if more ports are not added to the system when new drives are added the performance decreases because now more data is available and presumably being accessed through the same performance ports and 2 the controller managing the file system metadata has more operations to perform and can become a bottleneck. Adding drives to existing systems may also limited by physical form factors. That is to say that some systems have physical limits to how many drives can be added.

In one embodiment the system described herein provides a Distributed File Storage System DFSS that can scale disk capacity scale data throughput e.g. megabytes per second of data delivery and scale transaction processing throughput e.g. processing of file system metadata . In one embodiment the system also provides load balancing such that the scaled components handle the workload with improved efficiency.

In one embodiment the DFSS is dynamically distributed. In one embodiment the DFSS allows the integration of multiple servers so that the aggregation of servers appears to a client as a single storage device. With the DFSS multiple servers can access and control the same disk array separate disk arrays or both simultaneously. The DFSS is designed so that each server can continue to read and write data to the drives it controls even when other controllers in the DFSS fail. The DFSS also provides a mechanism for balancing the load on the controllers and the drives.

In one embodiment the DFSS is designed such that when multiple controllers are controlling a single array of disk drives also called a drive array some or all of the servers connected to the drive array have valid copies of the file system metadata describing the data on that drive array. This means that each server has direct access to all of the file system metadata for one or more of the drive arrays it can access. Thus 1 a server can continue to operate normally if the other servers in the system fail and 2 there is little or no performance degradation due to one server polling another server regarding location of data on drive arrays. The DFSS provides inter server communication to maintains synchronization of the file system metadata. The DFSS is designed such that a server can read from more than one drive array and can read from drive arrays maintained by another server. In one embodiment only one controller attached to a particular drive array has write privileges for that particular drive array at a given time.

The DFSS maintains a description of which servers have read and write privileges to a file represented by a file handle passed to the client. When the client looks up a file handle the client is informed of its options regarding which servers it may read the data from which is typically several and which one server it needs to use to write data. In addition since the servers typically have multiple network interface cards ports to the client network the file handle also includes data which suggests to the client which port is likely to be the least utilized.

The DFSS is also designed such that when there are multiple servers which are not sharing the same drive arrays the drive arrays are seamlessly integrated. For example suppose a system has 4 servers numbered S S S and S and two drive arrays numbered A and A . Further suppose that S and S control A and that S and S control A. The DFSS allows for a directory on A to have children on A. In fact the file system keeps track of usage statistics and if A is less utilized than A the file system will automatically create the next files on A instead of A. The DFSS provides coordination between the servers to allow this level of integration.

Because each server has a complete set of metadata for each drive array it can access a particular server can continue to operate even if other servers fail. The DFSS includes a mechanism for determining if a controller has failed and a mechanism for transferring write privileges in such cases. Clearly if all controllers attached to a given drive array fail the data on that drive array will become inaccessible. However the capability to support multiple controllers for each drive array greatly reduces the likelihood of such an event. If all such controllers for a drive array fail read and write operations on the remaining controller drive arrays continue unhindered.

The DFSS can perform load balancing at three levels. First when a directory lookup is performed the file system encodes within the file handle the lesser used network interface to provide balancing of network interface resources. Second when a new file is created it is created on lesser used drives and owned by a lesser used server. Third dynamic analysis of loading conditions is performed to identify under utilized and over utilized drives. In response the file system in some cases redistributes the parity groups across the drives in the existing drive array for more optimum usage of parity checking and in other cases the file system moves files to lesser used drive arrays.

Many data storage systems are designed with the twin goals of providing fast access to data and providing protection against loss of data due to the failure of physical storage media. Prior art solutions typically relied on Redundant Arrays of Independent Disks RAID . By having the data striped across multiple drives the data can be accessed faster because the slow process of retrieving data from disk is done in parallel with multiple drives accessing their data at the same time. By allocating an additional disk for storing parity information if any one disk fails the data in the stripe can be regenerated from the remaining drives in the stripe.

While this approach has proven effective in many applications it does have a few fundamental limitations one of this is that there is a rigid algorithm for mapping addresses from the file system to addresses on the drives in the array. Hence stripes are created and maintained in a rigid manner according to a predetermined equation. An unfortunate side effect results from this limitation. There is no mechanism from keeping data from a particular file from becoming highly fragmented meaning that although the data could actually fit in a single stripe the data could actually be located in many of stripes this situation can be particularly acute when multiple clients are writing to a file system .

In one embodiment the DFSS abandons the notion of having a rigid algorithm to map from addresses in the file system to drive addresses. Instead DFSS uses Distributed Parity Groups DPGs to perform the mapping. Data blocks in the DPGs are mapped via a mapping table or a list of tables rather than a fixed algorithm and the blocks are linked together via a table of linked lists. As discussed below the DPG mapping can be maintained separately or can be integrated into the file system metadata.

Initially the mapping is somewhat arbitrary and is based on the expectation that the drives will be accessed evenly. However the system keeps track of drive usage frequency. As patterns of usage are established blocks are copied from frequently accessed drives to infrequently accessed drives. Once the copy is complete the blocks are remapped to point to the new copies.

The disk drives are viewed as consisting of a collection of blocks. The block size is typically an integer multiple of the drive sector size. The drive sector size is a characteristic of the drives and is the minimum size of data that can be written to the drives. For most Fibre Channel drives the sector size is 512 bytes.

In one embodiment the blocks are grouped via a G Table. The G table is a collection of Gees which represent the individual blocks and their linkage. Each Gee contains a code that identifies what that the Gee s purpose is e.g. linkage or representing data . Gees for a DPG strung together into a G group. The entire G table is cached either in whole or in part in Random Access Memory RAM . Individual Gees are modified in cache to indicate when a specific block of data is in cache. This provides a straightforward way to be assured that if any client has caused disk data to be cached any other client seeking that same data will be directed to the already cached data.

RAID systems are implemented independently from the file system. That is from the file system s point of view the array looks like one big disk. Hence stripes are created and maintained without any knowledge of the data they contain. Two unfortunate side effects result from this limitation. First there is no mechanism from keeping data from a particular file from becoming highly fragmented meaning that although the data could actually fit in a single stripe the data could actually be located many stripes this situation can be particularly acute when multiple clients are writing to files . The can result in each drive doing hundreds of seeks while a smarter system could do just one. This is significant because the seek is the slowest operation related to accessing data on disks.

Second when a drive fails the data on that drive must be regenerated on a replacement drive exactly as it was on the failed drive. This means that if for example a server that has only 10 of its disk space currently used can only regenerate the data onto a replacement drive or a hot spare even though there is more than enough disk space to regenerate the data onto the other disks. For remote installations if a hot spare is used once one failure occurs the hot spare is used and the system can no longer tolerate another failure until the bad drive is replaced. Of curse this could be lessened by the usage of multiple hot spares but that significantly increases the amount of disk storage that is not being used and merely waiting in the wings .

In one embodiment the DFSS management of the DPGs is integrated into the file system thus making the file system aware of the DPGs and how data blocks from a file are collected into parity groups. Making the file system aware of the DPGs allows the file servers in the DFSS to more intelligently use the disk arrays than a RAID system would. With the DPG system the file system has knowledge of the drive arrays and therefore reduces the kind of fragmenting that is typical of RAID systems.

Furthermore in the event of a failure of one drive in the DFSS the data from the failed drive can be redistributed across the remaining drives in a disk array. For example suppose a file contained a DPG having a length also known as a span of 9 data spread across 9 drives where 8 drives contain the data blocks and the ninth drive contains the parity block . When one drive fails the data can be regenerated and redistributed using a DPG of span 8. Note that without knowledge of which blocks are associated with which files this redistribution is not possible because the file must still have the same number of total blocks but when the span is reduced from 9 to 8 there is an orphan block of 1 which must be still associated with the file. This orphan is associated with another DPG in the same file. This association is not possible without knowledge of the file. Alternatively if there are at least ten disks in the disk array the data can be regenerated and redistributed using a DPG span of 9 omitting the failed drive. Thus the integration of DPG management into the file system provides flexibility not available in a conventional RAID system.

Sine the DFSS has full knowledge of the file system the DFSS has knowledge of which blocks on the disks are not used. This allows the DFSS to identify heavily used disks and redistribute data from heavily used disks to unused blocks on lesser used blocks.

Storage system capability is typically measured in capacity bandwidth and the number of operations per second that can be processed. It is desirable to be able to easily scale a storage system that is to be able to easily increase the storage capacity the bandwidth or the operations per second capacity of the storage system. Storage system capacity is scaled by adding disk drives or to replace disk drive with drives having greater capacity. To increase storage system bandwidth or transactions per second capacity it is typically necessary to add servers. It is desirable to be able to add and utilize these resources with little or no user intervention or configuration.

In one embodiment the DFSS can automatically identify and utilize available resources including disk drives and servers. Two features are used realize this 1 detecting the addition of disk drives and or servers and 2 a automatically initializing and incorporating newly added disk drives and or servers. The same mechanisms that are used to detect newly added resources can also be used to support the deletion of resources.

With regard to detection of new resources modem high performance networking technologies such as Fibre Channel and Gigabit Ethernet supply methods for determining what devices are connected to the network. By storing the device map and periodically querying the network for an updated device map the presence of new devices can be determined. New devices are added to the appropriate server resource map.

In one embodiment a resource manager in the DFSS provides the capability to incorporate the new resources automatically. The resource manager keeps track of available disk resources as measured in available disk devices and the available free blocks on each disk. The resource manager keeps track of the available servers and the unutilized capacity in terms of bandwidth and transactions per second of each server. When new resources are added to the DFSS the resource manager incorporates the additions into a resource database.

The resource manager works in conjunction with aspects of the DFSS to dynamically allocate storage and controller resources to files. When the DFSS needs to create a new file or extend an already created file it coordinates with the resource manager to create a DPG of the appropriate size. A similar approach is followed by the DFSS in the selection of which server to use in the creation of a new file.

The resource manager approach also supports a load balancing capability. Load balancing is useful in a distributed file system to spread the workload relatively uniformly across all of the available resources e.g. across disks network interfaces and servers . The ability to proactively relocate file data is a tool that can be used to support load balancing by moving file data from over utilized resources to under utilized resources. In one embodiment the resource manager supports load balancing by incorporating resource usage predictions.

In the DFSS the server workload includes communication with client machines reading and writing files from disks managing file metadata and managing server resources such as storage capacity. The workload is divided up among the server hardware resources. If the workload is evenly divided the resulting performance will be improved. Thus one key to performance is intelligent resource management. In one embodiment resource management involves adaptive load balancing of server workloads. Prior art distributed file system technologies do not offer an effective method of performing load balancing in the face of a dynamic load environment and thus cannot provide optimum performance.

In one embodiment adaptive load balancing is based on the implementation of two mechanisms. First a mechanism is provided to predict the future server workload. Second a mechanism is provided to reallocate distributed server resources in response to the predicted workload.

Prediction of the future workload has several aspects. The first of these aspects is the past history of server workload in terms if file access statistics server utilization statistics and network utilization statistics. The loading prediction mechanism uses these statistics with an appropriate filter applied to generate predictions for future loading. As a very simple example a file that has experienced heavy sequential read activity in the past few minutes will likely continue to experience heavy sequential read access for the next few minutes.

The predictions for future workload can be used to proactively manage resources to improve performance and capacity usage. One mechanism used to reallocate server workload is the movement and replication of content files such that server and storage utilization is balanced and the direction of client accesses to available servers is balanced. Some degree of cooperation from client machines can be used to provide more effective load balancing but client cooperation is not strictly required.

A file server contains a number of hardware resources including controllers storage elements disks and network elements. In the configuration used by the DFSS multiple client machines are connected through a possibly redundant client network to one or more server clusters. Each server cluster has one or more servers and a disk storage pool.

Software resident on each server collects statistics regarding file accesses and server resource utilization. This includes information regarding the access frequency access bandwidth and access locality for the individual files the loading of each disk controller and disk storage element in terms of CPU utilization data transfer bandwidth transactions per second and the loading of each network element in terms of network latency and data transfer bandwidth.

The collected statistics are subjected to various filter operations which results in a prediction of future file and resource utilization i.e. workload . This prediction can also be modified by server configuration data which has been provided in advance by a system administrator and explicit hints regarding future file and or resource usage which can be provided directly from a client machine.

The predicted workload is then used to develop a plan that where to move content files between storage elements and where to direct client accesses to controllers in such a manner that the overall workload is distributed as evenly as possible resulting in best overall load balance and distributed server performance.

Disks and servers in the DFSS can be hot swapped and hot added meaning they can be replaced or added while the DFSS is online and servicing file requests. Disks in a disk array need not match in capacity or throughput. Extra capacity is automatically detected configured and used. Data is redistributed in the background both across servers and across DPGs to improve system performance. Hot adding of servers allows for increased file operations per second and file system capacity. Hot added servers are automatically configured and used.

In one embodiment servers are arranged in clusters that operate as redundant groups typically as redundant pairs . In normal operation the servers in a cluster operate in parallel. Each acts as a primary server for a portion of the file system. Each server in a cluster maintains a secondary copy of the metadata and intent log of the other s primary file system metadata and intent log. The intent log tracks differences between metadata stored in memory e.g. metadata in a metadata cache and metadata stored on disk. Upon failure of a server in the cluster the server remaining server or servers will pick up the workload of the failed server with no loss of metadata or transactions.

Each server in a high performance data storage system includes storage controller hardware and storage controller software to manage an array of disk drives. Typically a large number of disk drives are used in a high performance storage system and the storage system in turn is accessed by a large number of client machines. This places a large workload on the server hardware and server software. It is therefore important that the servers operate in an efficient manner so that they do not become a bottleneck in the storage system. In one embodiment a high performance data path is provided in the server so that data can efficiently be moved between the client machines and disks with a minimum amount of software intervention.

Prior art approaches for server and storage controllers tend to be software intensive. Specifically a programmable CPU in the server becomes involved in the movement of data between the client and the disks in the disk array. This limits the performance of the storage system because the server CPU becomes a bottleneck. While current approaches may have a certain degree of hardware acceleration such as XOR parity operations associated with RAID these minimal acceleration techniques do not adequately offload the server CPU.

In one embodiment the DFSS uses a server architecture that largely separates the data path from the control message path. Control messages e.g. file read write commands from clients are routed to a host CPU in the server. The host CPU processes the commands and sets up the network and storage interfaces as required to complete the data transfer operations associated with the commands. The data transfer operations once scheduled with the network and storage interfaces can be completed without further CPU involvement thus significantly offloading the host CPU. In one embodiment a data flow architecture packages instructions with data as it flows between the network interfaces and data cache memories.

The server hardware and software perform the functions of interfacing with client via the network interfaces servicing client file operation requests setting up disk read and write operations needed to service these requests and updating the file metadata as necessary to manage the files stored on disk.

The controller hardware provides a control flow path from the network and storage interfaces to the host CPU. The host CPU is responsible for controlling these interfaces and dealing with the high level protocols necessary for client communications. The host CPU also has a non volatile metadata cache for storing file system metadata.

A separate path for data flow is provided that connects the network and storage interfaces with a non volatile data cache. In one embodiment the separate path for data flow is provided by a data engine. The data path is used for bulk data transfer between the network and storage interfaces. As an example of the data path operation consider a client file read operation. A client read request is received on one of the network interfaces and is routed to the host CPU. The host CPU validates the request and determines from the request which data is desired. The request will typically specify a file to be read and the particular section of data within the file. The host CPU will use file metadata to determine if the data is already present in the data cache memory or if it must be retrieved from the disks. If the data is in the data cache the CPU will queue a transfer with the network interface to transfer the data directly from the data cache to the requesting client with no further CPU intervention required. If the data is not in the data cache the CPU will queue one or more transfers with the storage interfaces to move the data from disk to the data cache again without any further CPU intervention. When the data is in the data cache the CPU will queue a transfer on the network interface to move the data to the requesting client again with no further CPU intervention.

One aspect of this autonomous operation is that the CPU schedules data movement operations by merely writing an entry onto a network or storage interface queue. The data engine and the network and storage interfaces are connected by busses that include address and data buses. In one embodiment the network or storage interface does the actual data movement or sequence of data movements independently of the CPU by encoding an instruction code in the address bus that connects the data engine to the interface. The instruction code is set up by the host CPU when the transfer is queued and can specify that data is to be written or read to one or both of the cache memories. In addition it can specify that an operation such as a parity XOR operation or a data conversion operation be performed on the data while it is in transit. Because instructions are queued with the data transfers the host CPU can queue hundreds or thousands of instructions in advance with each interface and all of these can be can be completed asynchronously and autonomously. The data flow architecture described above can also be used as a bridge between different networking protocols.

As described above the data engine offloads the host CPU direct involvement in the movement of data from the client to the disks and vice versa. The data engine can be a general purpose processor digital signal processor programmable FPGA other forms of soft or hard programmable logic or a fully custom ASIC.

The data engine provides the capability for autonomous movement of data between client network interfaces and data cache memory and between disk network interfaces and cache memory. The server CPU involvement is merely in initializing the desired transfer operations. The data engine supports this autonomy by combining an asynchronous data flow architecture a high performance data path than can operate independently of the server CPU data paths and a data cache memory subsystem. The data engine also implements the parity generation functions required to support a RAID style data protection scheme.

The data engine is data flow driven. That is the instructions for the parallel processing elements are embedded in data packets that are fed to the data engine and to the various functional blocks within the data engine.

In one embodiment the data engine has four principal interfaces two data cache RAM interfaces and two external bus interfaces. Other versions of the data engine can have a different number of interfaces depending on performance goals.

A data path exits between each network interface and each cache interface. In each of these data path is a processing engine that controls data movement between the interfaces as well as operations that can be performed on the data as it moves between the interfaces. These processing engines are data flow driven as described above.

The processing engine components that are used to perform these functions include an external bus write buffer a feedback buffer a cache read buffer a cache write buffer a parity engine and the associated controller logic that controls these elements. The buffer elements are memories of appropriate sizes that smooth the data flow between the external interfaces the parity engines and the caches.

The data engine is used to provide a data path between client network interface and storage network interface controllers. The network interface controllers may support Fibre Channel Ethernet Infiniband or other high performance networking protocols. One or more host CPUs schedule network transfers by queuing the data transfer operations on the network interfaces controllers. The network interface controllers then communicate directly with the data engine to perform the data transfer operations completely autonomously from any additional CPU involvement. The data transfer operations may require only the movement of data or they may combine the movement of data with other operations that must be performed on the data in transit.

The processing engines in the data engine can perform five principal operations as well as a variety of support operations. The principal operations are read from cache write to cache XOR write to cache write to one cache with XOR write to other cache write to both caches.

The data flow control structure of the data engine reduces the loading placed on the server CPU. Once data operations are queued the server CPU does not need to be directly involved in the movement of data in the operations that are performed on data or the management of a data transfer.

The number of servers included in the DFSS is variable. However for the purposes of this description their structure configuration and functions are similar enough that the description of one server is to be understood to apply to all . In the descriptions of other elements of the figure that are similarly duplicated in the DFSS a description of one instance of an element is similarly to be understood to apply to all instances.

The server is connected to a disk array that stores a portion of the files of the distributed file storage system. Together the server disk array pair can be considered to be one server node . The disks in the disk array can be Integrated Drive Electronics IDE disks Fibre Channel disks Small Computer Systems Interface SCSI disks InfiniBand disks etc. The present disclosure refers to disks in the disk array by way of example and not by way of limitation. Thus for example the disks can be many types of information storage devices including for example disk drives tape drives backup devices memories other computers computer networks etc.

In one embodiment one or more server nodes are grouped into a cluster of server nodes. In one embodiment each server in the cluster is connected not only to its own disk array but also to the disk array s of the other server s of the cluster . Among other advantages conferred by this redundant connection is the provision of alternate server paths for reading a popular file or a file on a busy server node. Additionally allowing servers to access all disk arrays of a cluster provides the assurance that if one server of a cluster should fail access to the files on its associated disk array is not lost but can be provided seamlessly by the other servers of the cluster .

In one embodiment files that are stored on the disk array of one server node are mirrored on the disk array s of each server node in the cluster . In such an embodiment if the disk array should become unusable the associated server will still be able to access copies of its files on the other disk array s of the cluster .

As shown in the server is associated with the disk array that can include multiple disk drives of various sizes and capacities. Thus the DFSS allows for much more flexibility than many conventional multi disk file storage systems that require strict conformity amongst the disk arrays of the system. Among other advantages conferred by this flexibility is the ability to upgrade portions of the system hardware without having to upgrade all portions uniformly and simultaneously.

In many conventional networked storage systems a user on a client needs to know and to specify the server that holds a desired file. In the DFSS described in although the files of the file system can be distributed across a plurality of server nodes this distribution does not require a user on a client system to know a priori which server has a given file. That is to a user it appears as if all files of the system exist on a single server. One advantage of this type of system is that new clusters and or server nodes can be added to the DFSS while still maintaining the appearance of a single file system.

The server includes a server software module . The server software module includes server interface SI software for handling communications to and from clients file system FS software for managing access storage and manipulation of the files and a JBOD Just a Bunch of Disks interface JI for handling communications with the disk array and with other disk arrays of the cluster . Communications between the server interface and the file system take place using a Client Server Object . Communications between the file system and the JBOD interface take place using a Disk Service Object . In one embodiment as depicted in the software of the file system resides principally on the servers while the file data is stored on standard persistent storage on the disk arrays of the DFSS .

The server software module also includes a polling module for polling clients of the DFSS and a polling module for polling disk arrays of the DFSS .

In the embodiment shown in the server includes a Fibre Channel Application Programming Interface FC API with two Fibre Channel ports for communicating via the fabric with the client and with other server s of the cluster . The FC API also communicates with the server interface and with the client polling module in the server software module .

The server includes an FC API with two Fibre Channel ports for communicating with the disk array and with other disk arrays of its cluster . The FC API may communicate with the disk array via a communication fabric as shown in . The FC API may also communicate with the disk array directly. The FC API also communicates with the JBOD interface and with the disk polling module in the server software module .

The server includes an Ethernet interface with two Ethernet ports configured to handle Gigabit Ethernet or 10 100T Ethernet. The Ethernet interface communicates with the server interface in the server software module . In the Gigabit Ethernet port communicates with one or more Ethernet clients of the DFSS . The Ethernet clients include an installable client interface software component that communicates with the client s operating system and with the Ethernet interface of the server node . In the Ethernet port communicates with an administrative interface system .

To improve performance for certain implementations a small file system software layer may also exist on clients as shown in the embodiment shown in where the client system includes an installable software component called the Client Interface CI that communicates with both the client s operating system and via the communication fabric with a server node of the DFSS .

The functions of the FC API modules and the Ethernet interface may alternatively be handled by other communication protocols.

In order to perform normal file system operations such as for example creating and deleting files allowing clients to read and write files caching file data and keeping track of file permissions while also providing the flexibility mentioned above a cluster maintains metadata about the files stored on its disk arrays . The metadata comprises information about file attributes file directory structures physical storage locations of the file data administrative information regarding the files as well as other types of information. In various embodiments the file metadata can be stored in a variety of data structures that are configured in a variety of interconnected configurations without departing from the spirit of the distributed file system. is a block diagram that shows one embodiment of a configuration comprising five metadata structures and connections between them. Each of these structures the data they hold and how the structures are used are described in greater detail below.

Referring to a Filename Table includes a collection of filenames for both files stored on the server node as well as files that are children of directories stored on the server node .

A G node Table includes a collection of G nodes where each G node contains data related to attributes of a file. A one to one correspondence exists between the G nodes and files stored on the server node .

A Gee Table holds data about the physical locations of the file blocks on the disk array . The Gee Table additionally includes pointers to each associated G node in the G node Table and each G node in the G node Table includes a pointer to an associated portion of the Gee Table .

A Gnid Table on the server node includes Gnid strings that hold data describing the directory structure of that portion of the file system whose directories are stored on the server node . A one to one correspondence exists between the Gnid strings and directory files stored on the server node . Gnid strings are collections of Gnids which hold information about individual files that exist within a given directory. The file system allows files within a directory to be stored on a cluster that is different from the cluster on which the parent directory is stored. Therefore Gnids within a Gnid string on the server node can represent files that are stored on clusters other than the current cluster .

Each Gnid includes several pointers. A Gnid in the Gnid Table includes a pointer to an associated filename for the file represented by the Gnid. Because the Filename Table includes filenames for both files stored on the server node as well as files that are children of directories stored on the server node all Gnids on the server node point to the Filename Table on the server node .

A Gnid in the Gnid Table includes a pointer to its parent directory s G node in the G node Table and a parent directory s G node includes a pointer to the beginning of its associated Gnid string in the Gnid Table .

Each Gnid also includes a pointer to its own G node. Since a Gnid can represent a file that is stored on another cluster of the file system a pointer to the Gnid s own G node can point to the G node Table on another server node of the file system .

A Cache Node Table includes the Cache Nodes that hold information about the physical locations of file blocks that have been cached including a pointer to a cache location as well as a pointer to a non volatile location of the data on the disk array . A pointer to a Cache Node exists in the Gee Table for every associated data block that has been cached. Similarly a pointer exists in the Cache Node to a location in the Gee Table associated with a disk storage location for an associated data block.

To review the description from in one embodiment the servers of a cluster are able to access files stored on all the disk array s of the cluster . In one embodiment all server nodes of a cluster have copies of the same Filename Table Gee Table G node Table and Gnid Table .

In embodiments where files as well as metadata are mirrored across the server nodes of a cluster a different Gee Table exists for each disk array within a cluster since the Gee Table holds information about the physical storage locations of the files on a given disk array and since the disk arrays within a given cluster are not constrained to being identical in capacity or configuration. In such an embodiment the servers within the cluster have copies of both the Gee Table for a first disk array and the Gee Table for each additional disk array of the cluster.

In one embodiment in order to enhance both the security of the metadata and efficient access to the metadata each server node stores a copy of the Filename Table the G node Table the Gnid Table and the Gee Table in both non volatile memory for security and in volatile memory for fast access . Changes made to the volatile versions of the metadata structures are periodically sent to the non volatile versions for update.

In one embodiment the server nodes in the cluster do not have access to one another s cache memory. Therefore unlike the four metadata structures and already described the Cache Node Table is not replicated across the server nodes of the cluster . Instead the Cache Node Table stored in volatile memory on a first server refers to the file blocks cached on the first the server and the Cache Node Table stored in volatile memory on a second server refers to file blocks cached on the second server .

In one embodiment the metadata structures described in are duplicated across the server nodes of the cluster allowing access to a set of shared files and associated metadata to all servers in the cluster . All of the server nodes in the cluster can access the files stored within the cluster and all are considered to be owners of the files. Various schemes can be employed in order to prevent two or more servers from altering the same file simultaneously. For example in embodiments where the cluster includes two server nodes and one such scheme is to conceptually divide each of the duplicated metadata structures in half and to assign write privileges or primary ownership for one half of each structure to each server node of the cluster . Only the server node that that is primary owner of the metadata for a particular file has write privileges for the file. The other server node s of the cluster are known as secondary owners of the file and they are allowed to access the file for read operations.

In a failure situation when the server determines that its counterpart is not functional the server can assume primary ownership of all portions of the metadata structures and all associated files owned by the server thus allowing operation of the file system to continue without interruption. In one embodiment if a server in cluster having more than two servers experiences a failure then primary ownership of the failed server s files and metadata can be divided amongst the remaining servers of the cluster.

A Start of String SOS marker marks the beginning of the Filename Entry with a checksum a filename length count of 6 and a character string holding the filename Thomas. 

A Deleted String DS marker marks the beginning of the Filename Entry with a checksum a filename length count of 4 and a character string holding the filename Frog. 

A Start of String SOS marker marks the beginning of the Filename Entry with a checksum a filename length count of 2 and a character string holding the filename It. 

Comparing the checksums and the filename length counts of each Filename Entry to those calculated for a desired filename provides a quick way to eliminate most Filename Entries in the Filename Table before having to make a character by character comparison of the character strings .

Another advantage of including the filename length counts applies when deleting a Filename Entry from the Filename Table . Replacing the Start of String SOS marker with a Deleted String DS marker as in the Filename Entry signals that the corresponding file is no longer stored on the disk array even if the remainder of the Filename Entry remains unchanged. The filename length accurately represents the length of the deleted string and when a new filename of the same length or shorter is to be added to the table the new name and checksum and filename length count if necessary can be added into the slot left by the previous filename.

The file system divides files into one or more file logical blocks for storage. Each file logical block is stored in a cluster of one or more disk logical blocks on the disk array . Although the file system retains many of the advantages of a conventional file system implemented on RAID Redundant Array of Independent Disks including the distribution of files across multiple disk drives and the use of parity blocks to enhance error checking and error correcting unlike many RAID systems the file system does not restrict file logical blocks to one uniform size. File logical blocks of data and parity logical blocks can be the size of any integer multiple of a disk logical block. This variability of file logical block size allows for flexibility in allocating disk space and thus for optimized use of system resources.

In the file system the size of a file logical block is described by its integer multiple called its extent in disk logical blocks. For example a file logical block with an extent of 3 is stored in a cluster of 3 disk logical blocks on the disk array .

The Gee Table stores metadata describing the disk logical block locations on the disk array for each file logical block of the files.

In one embodiment the Gees include a G code field and a Data field . The G code field in the Gees indicates the type of data that is included in the Data field . In four types of G codes are depicted G NODE DATA PARITY and LINK. 

In one embodiment the G code of G NODE indicates that the Gee is a first Gee of a Gee group. For example the first Gee of the Gee group is a G NODE Gee . Similarly the first Gee of the Gee groups and are also G NODE Gees .

The Data field of a G NODE Gee can include a pointer to the file s G node in the G node Table and information about whether this is the first or Root G NODE Gee of the file s Gee string . The Data field of a G NODE Gee can also include information about the extent or size of the logical disk block clusters for the file logical blocks of the Gee group as will be described in greater detail below.

In the Data fields of the G NODE Gees and contain a reference to G node index 67 indicating that they all relate to the file associated with the G node at index 67 of the G node Table . That is they all relate to portions of the same file. The Data field of the Gee refers to the G node index 43 indicating that it relates to a different file.

Of the G NODE Gees only the first Gee contains an indication that it is a Root Gee meaning that it is the first Gee of the Gee string . The Gee is a G NODE Gee indicating that it is a first Gee of a Gee group the remainder of which is not shown and the Data field of the Gee also indicates that the Gee is not a Root Gee for its Gee string.

Following the G NODE Gee in a Gee group are Gees representing one or more Distributed Parity Groups DPGs . A DPG is set of one or more contiguous DATA Gees followed by an associated PARITY Gee. A DATA Gee is a Gee with a G code of DATA that lists disk logical block s where a file logical block is stored. For example in the Gees and are all DATA Gees and each is associated with one file logical block .

A PARITY Gee is a Gee with a G code of PARITY. Each PARITY Gee lists disk logical block location s for a special type of file logical block that contains redundant parity data used for error checking and error correcting one or more associated file logical blocks. A PARITY Gee is associated with the contiguous DATA Gees that immediately precede the PARITY Gee. A set of contiguous DATA Gees and the PARITY Gee that follows them are known collectively as a Distributed Parity Group .

For example in the PARITY Gee is associated with the DATA Gees and together they form the Distributed Parity Group . Similarly the PARITY Gee is associated with the DATA Gees and together they form the Distributed Parity Group . The PARITY Gee is associated with the DATA Gees which together form the Distributed Parity Group and the PARITY Gee is associated with the DATA Gees which together form the Distributed Parity Group .

The size of a disk logical block cluster described by a DATA Gee or a PARITY Gee as measured in number of disk logical blocks matches the extent listed in the previous G NODE Gee. In the example of the G NODE Gee defines an extent size of 2 and each DATA and PARITY Gee of the two Distributed Parity Groups of the Gee group lists two disk logical block locations. Similarly G NODE Gee of the second Gee group defines an extent size of 3 and each DATA and PARITY Gee of the Gee group lists three disk logical block locations. G NODE Gee of the third Gee group defines an extent size of 3 and each DATA and PARITY Gee of the Gee group lists three disk logical block locations.

If a Gee group is not the last Gee group in its Gee string then a mechanism exists to logically link the last Gee in the Gee group to the next Gee group of the Gee string. LINK Gees have the G code of LINK and a listing in their respective Data fields that provides the index of the next Gee group of the Gee string . For example the Gee is the last Gee of Gee group and its Data field includes the starting index 76 of the next Gee group of the Gee string . The Gee is the last Gee of Gee group and its Data field includes the starting index 88 of the next Gee group of the Gee string . Since the Gee group does not include a LINK Gee it is understood that Gee group is the last Gee group of the Gee string .

A G code of FREE not shown in indicates that the Gee has never yet been allocated and has not been associated with any disk logical location s for storing a file logical block. A G code of AVAIL not shown in indicates that the Gee has been previously allocated to a cluster of disk logical block s for storing a file logical block but that the Gee is now free to accept a new assignment. Two situations in which a Gee is assigned the G code of AVAIL are after the deletion of the associated file logical block and after transfer of the file to another server in order to optimize load balance for the file system .

A G code of CACHE DATA indicates that the disk logical block cluster associated with the Gee which was previously a DATA Gee has been cached. A G code of CACHE PARITY indicates that the disk logical block cluster associated with this Gee which was previously a PARITY Gee has been cached. The CACHE DATA and CACHE PARITY G codes will be described in greater detail when Cache Nodes and the Cache Node Table are described in connection with below.

The G node Table is a collection of G nodes where each G node includes attribute information relating to one file. Attribute information can include but is not restricted to information about physical properties of the file such as for example its size and physical location on disk information about the file s relationships to other files and systems such as for example permissions associated with the file and server identification numbers for the primary and secondary owners of the file and information about access patterns associated with the file such as for example time of the last file access and time of the last file modification .

In addition to file attribute information a G node provides links to the root Gee and a midpoint Gee of the file s Gee string in the Gee Table . If the file is a directory file its G node also contains a pointer to the beginning of the Gnid string that describes the files contained in the directory as will be explained with reference to below.

A File Attribute links field designates the number of directory entries for a file in the file system . This number can be greater than one if the file is the child of more than one directory or if the file is known by different names within the same directory.

A File Attribute ctime field designates the time of the last modification to a G node excluding updates to the atime field and to the mtime field .

If a file is a directory file rather than a data file then its Child Gnid Index field is an index for the oldest child in an associated Gnid string to be described in greater detail with reference to below otherwise this field is not used.

A Gee Index Last Used field and a Gee Offset Last Used field together designate a location of a most recently accessed Gee for a given file. These attributes can be used to expedite sequential reading of blocks of a file.

A Gee Index Midpoint field and a Gee Offset Midpoint field together point to a middle Gee of the Gee string . Searching for a Gee for a given file block can be expedited using these two fields in the following way if a desired block number is greater than the block number of the midpoint Gee then sequential searching can begin at the midpoint of the Gee string rather than at its beginning.

A Gee Index Tail field and a Gee Offset Tail field together point to the last Gee of the Gee string . New data can easily be appended to the end of a file using the pointers and .

A Quick Shot Status field and a Quick Shot Link field are used when a snapshot of the file system is taken to allow for online updates and or verification of the system that does not interrupt client access to the files. During a snapshot copies of some portions of the system are made in order to keep a record of the system s state at one point in time without interfering with the operation of the system. In some embodiments more than one Quickshot can be maintained at a given time. The Quick Shot Status field indicates whether the G node was in use at the time of the snapshot and therefore if it has been included in the snapshot. If the G node has been included in the snapshot the Quick Shot Link field provides a link to the newly allocated copy of the G node.

In one embodiment a bit mask is associated with each element with the file system identifying any of a number of Quickshot instances to which the element belongs. When a Quickshot is requested a task can set the bit for every element holding the file system at bay for a minimum amount of time. Thus capturing the state of a file system comprises identifying elements in the file system as being protected rather than actually copying any elements at the time of the Quickshot.

In one embodiment the file system uses a copy on write mechanism so that data is not overwritten new blocks are used for new data and the metadata is updated to point to the new data. Thus a minimum of overhead is required to maintain a Quickshot. If a block is being written and the file system element being modified has a bit set indicating that it is protected by a Quickshot the metadata is copied to provide a Quickshot version of the metadata which is distinct from the main operating system. Then the write operation continues normally.

Files in the file system are distributed across a plurality of server nodes while still appearing to clients as a single file system. According to different embodiments files can be distributed in a variety of ways. Files can be distributed randomly or according to a fixed distribution algorithm or in a manner that enhances load balancing across the system or in other ways.

In one embodiment the files of a given directory need not be stored physically within the same cluster as the cluster that stores the directory file itself. Nor does one large table or other data structure exist which contains all directory structure information for the entire file system . Instead directory structure information is distributed throughout the file system and each server node is responsible for storing information about the directories that it stores and about the child files of those directories.

In one embodiment server nodes of the DFSS hold directory structure information for only the directory files that are stored on the server node and for the child files of those directories that is the files one level down from the parent directory. In another embodiment server nodes of the DFSS hold directory structure information for each directory file stored on the server node and for files from a specified number of additional levels below the parent directory in the file system s directory structure.

In one embodiment an exception to the division of responsibility described above is made for the directory structure information for a root directory of the file system . The root directory is a directory that contains every directory as a sub directory and thus every file in the file system . In this case every server in the file system can have a copy of the directory structure information for the root directory as well as for its own directories so that a search for any file of unknown location can be initiated at the root directory level by any server of the file system . In another embodiment the directory structure information for the root directory is stored only in the cluster that stores the root directory and other clusters include only a pointer to the root directory.

The Gnid Table on the server node defines a structure for directory files that reside on the server node . The Gnid Table comprises Gnid strings which in one embodiment are linked lists implemented within a flat array. In one embodiment a Gnid string exists for each directory file on the server node . Individual elements of a Gnid string are called Gnids and a Gnid represents a child file of a given parent directory.

Since Gnids share a common structure a description of one Gnid is to be understood to describe the structure of all other Gnids as well.

The Gnid includes but is not restricted to seven fields and . A Status field indicates whether the Gnid is a first Gnid GNID OLDEST in the Gnid string a last Gnid GNID YOUNGEST in the Gnid string a Gnid that is neither first nor last GNID SIBLING in the Gnid string or a Gnid that is not currently in use GNID FREE .

A Parent G node Ptr field is a pointer to the G node for the file s parent directory in the G node Table .

A Sibling Gnid Ptr field is a pointer to the next Gnid on the Gnid string . In the embodiment described above the Sibling Gnid Ptr field points to the Gnid within the Gnid string that has the next largest checksum value. A NULL value for the Sibling Gnid Ptr field indicates that the Gnid is the last Gnid of the Gnid string .

A G node Ptr field is a pointer to the file s G node indicating both the server node that is primary owner of the file and the file s index into the G node Table on that server node.

A ForBiGnid Ptr field is a pointer used for skipping ahead in the Gnid string and a BckBiGnid Ptr field is a pointer for skipping backward in the Gnid string . In one embodiment the fields and can be used to link the Gnids into a binary tree structure or one of its variants also based on checksum size thus allowing for fast searching of the Gnid string .

The Cache Node Table stores metadata regarding which data blocks are currently cached as well as which data blocks have been most recently accessed. The Cache Node Table is integrated with the file system by way of a special type of Gee in the Gee Table . When a data block is cached a copy of its associated DATA Gee which describes the location of the data on the disk array is sent to the Cache Node Table where it is held until the associated data is released from the cache. Meanwhile the DATA Gee in the Gee Table is modified to become a CACHE DATA Gee its G Code is changed from DATA to CACHE DATA and instead of listing a data block s location on disk the Data field of the Gee now indicates a location in the Cache Node Table where a copy of the original DATA Gee was sent and where information about the data block s current location in cache can be found.

In one embodiment the Cache Node Table is implemented as a list of fixed length Cache Nodes where a Cache Node is associated with each Gee whose data has been cached. The structure of one embodiment of a Cache Node is described in .

Referring to the Cache Node is shown to include nine fields. A Data Gee field is a copy of the DATA Gee from the Gee Table that allows disk location information to be copied back into the Gee Table when the associated data block is released from cache. A PrevPtr field holds a pointer to the previous Cache Node in the Cache Node Table . A NextPtr field holds a pointer to the next Cache Node in the Cache Node Table . In one embodiment the Cache Node Table is implemented as a flat array in which case the PrevPtr and NextPtr fields can hold indices of a previous and a next item in the table. A CacheBlockAddr field holds a pointer to a location in cache where the associated data has been cached. A ReadCt field is a counter of the number of clients currently reading the associated data block. A CacheTime field holds a time that the associated cache contents were last updated. A Regenerated field holds a flag indicating that the associated cache contents have been regenerated. A CacheBlockHiAddr field and a CacheBlockLoAddr field hold a high water mark and low water mark of the data in a cache block. These water marks can be used to demarcate a range of bytes within a cache block so that if a write operation has been performed on a subset of a cache block s bytes then when the new data is being written to disk it is possible to copy only relevant or necessary bytes to the disk.

In one embodiment the Cache Node Table is conceptually divided into three lists as depicted in . A Normal List includes all the Cache Nodes in the Cache Node Table which are associated with cached data that is not currently in use. A Write List holds the Cache Nodes of data blocks that have been modified and that are waiting to be written to disk. A Read List holds the Cache Nodes of data blocks that are currently being read by one or more clients.

When existing cached data is needed for a write or a read operation the associated Cache Node can be removed from the Normal List and linked to the Write List or the Read List as appropriate. The Cache Nodes in each of the lists can be linked by using the PrevPtr and NextPtr fields. The Cache Nodes of data blocks that are being written to can be moved from the Normal List to the Write List until an associated data block stored on the disk array is updated. The Cache Nodes of data blocks that are being read can be similarly moved to the Read list by resetting the links of the PrevPtr and NextPtr fields.

The Cache Nodes of data blocks that are being read can additionally have their ReadCt field incremented so that a count may be kept of the number of clients currently reading a given data block. If additional clients simultaneously read the same file the server increments the Cache Node s ReadCt field and the Cache Node can stay in the Read List . As each client finishes reading the ReadCt is appropriately decremented. When all clients have finished reading the file block and the ReadCt field has been decremented back to a starting value such as 0 then the Cache Node is returned to the Normal List .

In one embodiment the server that wishes to access an existing Cache Node for a read or a write operation can take the desired Cache Node from any position in the Normal List as needed. The Cache Nodes from the Write List whose associated data have already been written to disk are returned to a top position of the Normal List . Similarly when no clients are currently reading the cached data associated with a given the Cache Node on the Read List the Cache Node is returned to the top position of the Normal List . In this way a most recently accessed Cache Node amongst the Cache Nodes on the Normal List will be at the top position and a least recently accessed the Cache Node will be at a bottom position .

In one embodiment if space in the cache is needed for a new data block when all of the Cache Nodes have been assigned then the Cache Node in the bottom position is selected to be replaced. To do so the cached data associated with the bottom Cache Node can be written to a disk location specified in the DataGee field of the bottom Cache Node and the DataGee from the bottom Cache Node is returned to its location in the Gee Table . The bottom Cache Node can then be overwritten by data for a new data block.

In one embodiment the server nodes in the cluster do not have access to one another s cache memory. Therefore unlike the metadata structures described in the Cache Node Table is not replicated across the servers of the cluster .

In addition to the metadata structures described above in connection with other metadata structures can be used to enhance the security and the efficiency of the file system . Two metadata structures a Lock Node Table and a Refresh Node Table assist with the management of shares and locks placed on the files of the server node . A share or a lock represents a client s request to limit access by other clients to a given file or a portion of a file. Depending on its settings as will be described in greater detail below a share or a lock prevents other client processes from obtaining or changing the file or some portion of the file while the share or lock is in force. When a client requests a share or a lock it can either be granted or if it conflicts with a previously granted share or lock it can be given a pending status until the original share or lock is completed.

Information about current shares and locks placed on a server node s files is stored in a Lock Node Table. A Lock Node Table includes Lock Strings where each Lock String describes the current and pending shares and locks for a given file.

The Share Nodes have eight fields and the Lock Nodes have ten fields and . In the first four fields of both the Share Nodes and the Lock Nodes are the same and as such a description of one shall be understood to apply to both Share Nodes and Lock Nodes.

A lockStatus field indicates whether the node is of type SHARE or LOCK or if it is currently an unused FREE node. A SHARE node represents a current or pending share request. A share applies to an entire file and if granted it specifies the read and write permissions for both a requesting client and for all other clients in the system. A LOCK node represents a current or pending lock request. A lock applies to a specified byte range within a file and if granted it guarantees that no other client process will be able to access the same range to write read or read write depending on the values in the other fields while the lock is in effect.

A timeoutCt field helps to ensure that locks and shares are not inadvertently left in effect past their intended time due to error failure of a requesting client process or other reason. Locks automatically time out after a given length of time unless they are refreshed periodically.

A next field points to the next node in the Lock String . A pending field indicates whether the lock or share represented by the node is active or pending.

The fields of contain additional information useful to the Share Nodes . An access field indicates the kind of access to the file that the client desires. In one embodiment the access field may take on one of four possible values 0 indicates that no access to the file is required 1 indicates that read only access is required 2 indicates that only write access is required and 3 indicates that read and write access to the file are both required.

A mode field indicates the level of access to the file that another client process will be permitted while the share is in effect. In one embodiment the mode field can take on one of four possible values 0 indicates that all access by other client processes is permitted 1 indicates that access to read the file is denied to other client processes 2 indicates that access to write to the file is denied to other client processes and 3 indicates that both read and write access are denied to other client processes.

A clientID field identifies the client that requested the share. A uid field identifies the user on the client that has requested the share or lock.

Fields of contain additional information useful to Lock Nodes . An offset field indicates the starting point of the byte range within the file where the lock is in effect. A length field indicates the length of the segment beginning at the offset point that is affected by the lock. In one embodiment Lock Nodes are kept ordered within the Lock String according to their offset field .

An exclusive field indicates whether the lock is exclusive or non exclusive. An exclusive lock sometimes called a write lock is used to guarantee that the requesting process is the only process with access to that part of the file for either reading or writing. A non exclusive lock often called a read lock is used to guarantee that no one else may write to the byte range while the requesting the process is using it although reading the file is permitted to other clients.

A clientID field identifies the client that requested the lock. A uid field identifies the user on the client that is requesting the lock. A svid field identifies the process that is requesting the lock.

In one embodiment a Refresh Node Table is used to detect clients who hold locks or shares on files and who are no longer in communication with the DFSS . A Refresh Node is created for each client that registers a lock or share. depict examples of how Refresh Nodes can be configured as a binary tree and as a doubly linked list respectively. Based on the task at hand and on the links used for traversal both structures can exist simultaneously for the same set of Refresh Nodes as will be explained in greater detail below.

Referring to six Refresh Nodes and are shown configured as a binary tree. The structure of each Refresh Node is the same and it is to be understood that a detailed description of one Refresh Node applies also to the other Refresh Nodes of . In one embodiment the Refresh Node includes six fields. A clientID field identifies a client who has registered at least one current lock or share. A counter field maintains a counter that in one embodiment is originally set to a given start value and is periodically decremented until a refresh command comes from the client to request that the counter be returned to its full original value. If the counter field is allowed to decrement to a specified minimum value before a refresh command is received from the identified client then all locks and shares associated with the client are considered to have timed out and they are removed from their respective Lock Strings .

In one embodiment Refresh Nodes are allocated from a flat array of Refresh Nodes. The Refresh Nodes can be linked and accessed in a variety of ways depending on the task at hand with the help of pointer fields located in each node. For example when a refresh command arrives from the client it is advantageous to be able to quickly locate the Refresh Node with the associated clientID field in order to reset its counter field . A binary tree structure as shown in the example of can allow for efficient location of the Refresh Node with the given clientID field value if the nodes of the tree are organized based on the clientID field values. In such a case a left link field ltLink and a right link field rtLink pointing to the Refresh Node s left and right child respectively provide links for traversal of the tree using conventional algorithms for traversing a binary tree.

In one embodiment unused Refresh Nodes in the flat array are kept in a doubly linked Free List such as the one depicted in for ease of allocation and de allocation. In one embodiment used Refresh Nodes are kept in a doubly linked list called a Used List. With this structure decrementing the counter field of each Refresh Node that is currently in use can be carried out efficiently. In a stackNext field and a stackPrev field of the Refresh Node together allow for doubly linked traversal of the Refresh Nodes of the Free List and the Used List. When a new Refresh Node is needed it can be removed from the Free List and linked to both the Used List and the binary tree by the appropriate setting of the link fields and .

In one embodiment the Filename Table the G node Table the Gee Table and the Gnid Table are cached as well as being stored on the disk array . In one embodiment when the server changes a portion of the metadata in cache an entry is made into an Intent Log in non volatile memory such as flash memory or battery backed RAM. The Intent Log Entry documents the intention to update both the version of the metadata stored on the disk array and any mirrored version s of the metadata on other server nodes of the cluster . The Intent Log provides protection against inconsistencies resulting from a power loss before or during an update.

A file handle is provided to clients by the DFSS for use when requesting access to a file. Each file handle uniquely identifies one file. The DFSS treats both normal data files and directories as files and provides file handles for both. In the description that follows the term file may apply to either a data file or a directory file unless specifically limited in the text.

A ServerID field identifies by means of a server identification number ServerID the primary owner of the associated file. The inclusion of the file owner s ServerID in the file handle enables a user on the client to access a file in the distributed file system without needing to knowing explicitly which server node is holding the desired file. Using the file handle to request a file from the file system software allows the file system software to direct the request to the appropriate server. By contrast conventional UNIX file handles do not include information regarding the server storing a file and they are therefore not able to accommodate the level of transparent file access provided in the file system software .

In one embodiment clusters include only two server nodes and the ServerID of the file s secondary owner can be obtained by flipping the least significant bit of the field . This ability is useful when the primary owner is very busy and must issue a retry later response to a client s request to read a file. In return the client can temporarily change the ServerID in the file s file handle and re send the read request to the file s secondary owner . Similar accommodations can be made for clusters of more than two server nodes.

A G node Index field provides an index into the file s G node in the G node Table on the server identified in the ServerID field .

In one embodiment the file handle for a given file does not change unless the file is moved to another server node or unless its G node location is changed. Thus the file handle is relatively persistent over time and clients can advantageously store the file handles of previously accessed files for use in subsequent accesses.

In order to access a desired file the client sends the file s file handle and a request for file access to the file system . As was illustrated in the embodiment shown in the file handle of a given file comprises information to identify the server that stores the file and the location of the file s G node in the G node Table . With the information found in the G node as described in the example of the desired file can be located and accessed.

The file handle for a given file remains relatively static over time and typically the client stores the file handles of files that it has already accessed for use in subsequent access requests. If the client does not have a desired file s file handle the client can request a file handle look up from the file system to determine the needed file handle .

In one embodiment of a file handle look up process the DFSS accepts the file handle of a parent directory along with the filename of a desired child file and the DFSS returns the file handle for the desired child file. If the client does not know the file handle for the desired file s parent directory then the client can use the file handle for any directory along the pathname of the desired file and can request a file handle look up for the next component on the desired pathname. The client can then iteratively request a file handle look up for each next component of the pathname until the desired file s file handle is returned.

For example if the client desires the file handle for a file whose pathname is root WorkFiles PatentApps DesiredFile and if the client has the file handle for the parent Patent Apps directory then the client can send the look up request with the PatentApps file handle to get the DesiredFile file handle . If the client initially has no file handle for the parent PatentApps directory but does have the file handle for the WorkFiles directory then the client can send a first look up request with the known WorkFiles file handle together with the filename for the PatentApps directory. The DFSS returns the file handle for the PatentApps directory. Since the client still does not have the needed DesiredFile file handle the client can send a second file handle look up request this time using the newly received PatentApps file handle and the DesiredFile filename. In response the file system returns the DesiredFile file handle . In this way beginning with the file handle for any file along the pathname of a desired file the file handle for the desired file can eventually be ascertained.

In one embodiment when the client first accesses the file system the client is provided with one file handle namely the file handle for a root directory. The root directory is the directory that contains all other directories and is therefore the first component on the pathname of every file in the system. Thus if need be the client can begin the look up process for any file s file handle with a look up request that comprises the root file handle and the filename of the next component of the desired file s pathname. The final file handle returned will provide the client with the information needed to accurately locate the desired file.

In this example the filename of the desired file is AAAAA. The ServerID field indicates that the parent directory is stored on the server with ServerID 123 and the G node index field shows that a G node for the parent directory can be found at index location 1 in the G node Table .

When the server receives the look up request the server uses information in the G node index field of the file handle to access a G node at index location 1. 

As described above the G node acts as a repository of general information regarding a file. In the example illustrated in the File Attribute type field of the G node namely NFDIR indicates that the file associated with the G node is a directory not a regular data file.

As described earlier the Gnid sting holds information about the children files of a given directory. The Child Gnid Index in G node points to a first Gnid in the directory s Gnid string . The server searches for the desired data file amongst the children files of the parent directory by searching the corresponding Gnids on the directory s Gnid string. The server uses the Filename Ptr fields of each Gnid to access the associated file s filename entry for comparison with the filename of the desired file.

In the Child Gnid Index field of G node indicates a value of 3 and the server accesses the Gnid at index location 3 in the Gnid Table . To determine a filename associated with the Gnid the server uses the Filename Ptr field to access the Filename Entry associated with the Gnid at index 3. To ascertain if the filename stored at the Filename Entry matches the filename in the look up request the server first compares the checksum and filename length count of the filename in the look up request with the checksum and the filename length count stored in the Filename Entry in the Filename Table . Note These checksums and filename lengths are not shown explicitly in . If the aforementioned checksums and filename length counts match the server proceeds with a character by character comparison of the character string in the look up request and the filename in the Filename Entry .

If a mismatch is encountered during the comparisons as is the case in where the Filename Entry holds a filename of ABCD and length 4 while the desired filename of AAAAA has a length of 5 then the current Gnid is eliminated from consideration. After encountering a mismatch for the Gnid at index 3 the server continues to traverse the Gnid string by using the Sibling Gnid Ptr field in the current Gnid as an index pointer.

The Sibling Gnid Ptr field of the Gnid holds a value of 4 indicating that a next Gnid can be found at index location 4 of the Gnid Table . When the checksum and name length for the desired filename do not match those from a Filename Entry DE found at index location 0 of the Filename Table the server again eliminates the current Gnid from consideration.

The server again uses the Sibling Gnid Ptr field as a pointer this time from the Gnid at index location 4 to a Gnid at index location 6 in the Gnid Table . Following the Filename Ptr of the Gnid to Filename Entry and performing the aforementioned checksum filename length and filename comparisons reveals that the desired filename and Filename Entry filename do match. The server therefore determines that this Gnid is associated with the desired file.

In order to send the desired file handle which comprises the ServerID and G node Table index for the desired file to the requesting client the server accesses the G node Ptr field of the current Gnid . The G node of a file is stored on the server node where the file is stored which is not necessarily the same server node that holds its parent directory. The G node Ptr field provides both the ServerID of the server that is the file s primary owner and an index that identifies the file s G node in the primary owner s G node Table .

In the example of the contents of the G node Ptr field show that the desired G node exists at location 9 in the G node table on the same server namely the server with ServerID 123. However it would also be possible for the G node Ptr field to contain an index to a G node Table on another server in which case the file handle would include the ServerID of the server holding the file and its G node . This possibility is indicated by the dotted arrow pointing from the G node Ptr field to another server of the DFSS . Thus the information in the G node Ptr field allows the server to provide the client with both a ServerID and with the G node Index needed to create the file handle for the desired file. The file handle for the desired file can be sent back to the client for use in future access of the desired file and the process of file handle look up is complete.

The server indicated in a ServerID field accesses the G node at index 9 as indicated in a G node index field of the file handle .

As disclosed above the Gee Table holds information about the physical storage locations of a file s data and parity blocks on the disk array . The Gee Table also holds information that helps locate blocks of data that have been copied to cache. A Gee holds storage location information about one block of data. Gees for a given file are linked together to form the gee string . A first Gee of the gee string is called the root of the gee string .

The Gee Index Root field of the G node provides an index to a root Gee in the Gee Table . Reading the data field of the Gee confirms that this Gee is a root Gee and that it is associated with the G node at index location 9. The server continues reading the gee string at the next contiguous Gee in the Gee Table . Reading the G code of the Gee with its value of CACHE DATA reveals that this Gee represents data that has been cached.

As disclosed above the Cache Node Table holds information that allows the server to access a file block s location in cache . Reading the Data Field of a next Gee provides a pointer to an appropriate cache node of the Cache Node Table . The cache node holds the CacheBlockAddr field which points to a location in cache of the data associated with the Gee . The cache node also holds a copy of the associated Gee from the Gee Table in the Data Gee field until the associated data block is no longer stored in cache. The Data Gee field also provides a pointer to the location of the associated file data stored on the server node s disk array . By following the pointers from the file handle to the G node at index location 9 on to the Gees and at index locations 2 and 3 on to the Cache Node at index location 7 and finally on to cache location w the data originally requested by the client can be accessed for reading writing or other operations and the process of file access is complete.

Referring to a process of accessing a file is described beginning with the request for a file handle look up through the use of the file system s metadata structures to final access of the file data in cache.

Beginning at a start state the process moves to a state where the client determines whether it has the file handle for a file that it wishes to access.

If the client does not have the desired file handle the process moves to a state where the client and one or more servers of the DFSS perform a file handle look up as will be described in greater detail with reference to .

Returning to the state if the client determines that it does have the desired file handle then the process moves on to a state where the client sends the file access request to the server indicated in the file handle .

From state the process moves to a state where the server accesses a G node indicated in the file handle .

Moving on to a state the server uses a pointer in the G node to access an appropriate Gee in the Gee Table . Several possibilities exist for appropriate gees depending on the current access needs of the server . For example in the embodiment of the G node described in seven fields relate to pointers to the Gee Table . The Gee Index Root field is an index to the root Gee which can be used for example when reading from the beginning of a file is desired. Fields and together point to the last Gee of a file which can be used for example when appending new data to the end of a file. Fields and together point to a most recently used Gee for the file which can be used for example for sequential access to the gees of a file. Fields and together point to a middle Gee for the gee string which can be used for example when access to the middle or second half of the file is desired.

After accessing an appropriate Gee in the state the process moves on to a state where the server reads the G code field in order to determine if the data represented by the Gee has already been cached. If the G code holds a value other than CACHE DATA or CACHE PARITY the server assumes that the desired data has not yet been cached and the process moves to a state where the desired data is sent to cache. The state is described in greater detail in connection with below.

Returning to the state if the server determines that the G code holds a value of CACHE DATA or CACHE PARITY the server assumes that the desired data has already been cached. The process then moves on to a state where the server accesses the cache node indicated in the gee s data field .

From the state the process moves on to a state where the server manipulates the accessed cache node as needed according to the description of . For example if the cache node is currently on the Normal List and the client has requested to read the data block the server can increment the cache node s ReadCt field and move it to the Read List .

Once the Cache Node is properly updated the process moves from the state to a state where the server accesses the file block data in the cache location indicated in the Cache Node . From here the process moves on to a state where the server performs a desired operation on the cached data block. From the state the process moves on to a state where accessing the file is complete.

In the process reaches the state only if the client does not have a file handle for the desired file. Referring to the embodiment of the file handle illustrated in the file handle for a given file comprises among other possible fields a ServerID field identifying the server that stores the data and metadata for a file as well as a G node Index field that indicates the G node of the given file on that identified server .

The root directory is the first component of the pathname for every file in the file system and if necessary the client can begin the process of file handle look up with the file handle of the root directory. In one embodiment every client has at least the file handle for a root directory for the file system . For example the root directory can be known to reside on the server with ServerID number 0 and its G node can be known to reside at index 0 of the G node Table on Server 0. However it may also be that at the beginning of the look up process the client has the file handle for the desired file s parent directory or for another directory on the pathname of the file and that by beginning with one of these directories closer to the file itself the look up process may be shortened.

Beginning at a start state the process moves to a state where the client sends the look up request comprising the file handle for a directory and the filename of a desired next component. The look up request is sent to a server indicated in the file handle field of the look up request . The process next moves to a state where the server accesses a G node indicated in the file handle of the look up request .

Moving on to a state the server uses the ChildGnidIndex field in the G node to access a first Gnid in the directory s Gnid string . As described in connection with the embodiment shown in the Gnid string is a linked list of Gnids with one Gnid for each child file in a parent directory.

Moving on to a state the server calculates a checksum and filename length for the filename of the next desired pathname component that was sent by the client in the look up request . Having a checksum and filename length for a desired file allows the server to expedite searching for a matching Filename Entry because comparison of checksums and comparison of filename lengths can be accomplished much more quickly than a character by character comparison of the filenames themselves. Performing the first two types of comparisons before embarking on the character by character comparison allows the server to eliminate any Filename Entries whose checksum and filename length do not match before performing the more costly character by character filename comparison.

Moving on to a state the server uses the FilenamePtr field of the currently accessed Gnid to locate the associated Filename Entry in the Filename Table . Moving on to a state the server determines if the checksum stored in the currently accessed Filename Entry is greater than the checksum calculated in the state .

As described in connection with in one embodiment Gnids are stored in the Gnid string in order of checksum values calculated for their associated character strings with the Gnid having the smallest checksum value coming first. This ordering of Gnids by checksum value allows the server to determine whether a desired filename may still exist on the given Gnid string . In this embodiment if in the state the server determines that the checksum found in the currently accessed Filename Entry is greater than the checksum calculated in the state then a Gnid for the desired file with the lower checksum cannot exist on the currently accessed Gnid string . In this case the process moves on to a state where it reports a File Not Found Error to the client .

Returning to the state if the server determines that a checksum found in a currently accessed Filename Entry is greater than the checksum calculated in state then the process moves on to a state .

In the state the server determines if the checksums and the filename lengths from the two sources match. If either the checksums or the filename lengths or both do not match then this Filename Entry can be ascertained not to be associated with the client s desired file and the process moves on to a state . In the state the server uses the SiblingGnidPtr in the current Gnid to access the next Gnid in the current Gnid string.

Returning to the state if the server determines that the checksums and filename lengths do match then this Filename Entry cannot yet be eliminated and the process moves on to a state where the server performs a character by character comparison of the two filenames.

If in the state the server determines that the two filenames do not match then as was the case in state this Filename Entry can be ascertained not to be associated with the client s desired file. In this case the process moves on to a state where the server uses a SiblingGnidPtr in the current Gnid to access a next Gnid in the current Gnid string .

From the state the process returns to the state and the server uses the Filename Ptr field of the newly accessed Gnid to access an associated Filename Entry in the File Table . This loop through the states and possibly continues until a Filename Entry and associated Gnid for the desired file is found or until an error is encountered.

If in the state the server determines that the filenames do match then the process has identified a Filename Entry and an associated Gnid that corresponds to the desired file. In this case the process moves on to a state where the server sends the desired file handle information back to the client . Moving on to a state the file handle look up process is complete. The process from then proceeds from the state back to the state and continues as described in the explanation of .

Moving on to a state the server writes the associated file data from its volatile location in cache to its non volatile location on disk array which is indicated in the DataGee field of the cache node .

Moving on to a state the server copies the DataGee field from the cache node back to its original position in the Gee Table changing the G code back from CACHE DATA to DATA or from CACHE PARITY to PARITY indicating that the associated data is no longer cached.

Moving on to a state the server overwrites the DataGee field in the cache node with a Gee from the Gee Table that is associated with a new file block to be cached.

Moving on to a state the server caches the new file block from disk to a cache location associated with the cache node.

Moving on to a state the process of caching file data is complete and the process in can proceed from the state on to the state to continue the task of accessing a file.

Referring to a process of file allocation is shown in flowchart form. The process begins in a start state and moves to a state where the client send a file allocation request that includes a filename for a new file and a file handle for the new file s parent directory.

The process moves to the state and the server node indicated in the parent directory s file handle receives the file allocation request. For the purposes of the description of this figure this server node will be known as the parent server.

The process moves to the state and the parent server uses workload statistics received from the other server nodes of the DFSS to decide if the file will be owned by the parent server node or by another server node.

If the parent server node decides that it will be the owner of the new file then the process moves to a state where the parent server creates a new file makes an appropriate new Filename Entry in the Filename Table and allocates a new G node for the new file. At this point the parent server node has enough information to create the file handle for the new file.

Returning to the state if the parent server node decides that another server node should own the new file the process moves to a state where the parent server sends a file allocation request to another server of the DFSS . For the purposes of describing this figure the other server will be known as the second server.

From the state the process moves to a state where the second server creates a new file makes the appropriate new Filename Entry in the Filename Table and allocates the new G node for the new file. At this point the second server has enough information to create the file handle for the new file.

From the state the process moves on to a state where the second server sends the file handle for the new file to the parent server node .

At this point when the parent server node has the file handle for the new file the process moves on to a state .

The state can also be reached from state in the case where the parent server decided to be the owner of the file. As disclosed above in state the parent server also had the information to create a file handle for the new file and the process also moves on to a state . 

For either case in state the parent server node as owner of the new file s parent directory allocates a Gnid for the new file adds it to the appropriate Gnid string and if one does not already exist the parent server node makes an appropriate new Filename Entry in the Filename Table .

From state the process moves on to a state where the parent server node sends the file handle for the new file to the requesting client .

The process moves on to a state where the process of file allocation is now complete. The requesting client can access the new file using the newly received file handle and since the file handle contains identification for the server that owns the new file any access request can be automatically routed to the appropriate server node.

In various embodiments the DFSS can be configured to store and manage a very large number of files of widely varying sizes. In some embodiments it can be advantageous to store all of the file metadata on disk while copies of the metadata for only some of the most recently used files are additionally cached in volatile memory. In some embodiments memory for metadata structures can be dynamically allocated as new metadata structures are brought from disk to volatile memory.

In one embodiment the file system can be advantageously configured to store file metadata in a data structure called a Super G node SG that comprises the file s G node other file information and information that allows the file system to locate the physical storage locations of the file s data blocks as will be described in greater detail below.

In the embodiment shown in the Super G node comprises 16 Kbytes of memory. The Status Linking Information and G node fields together comprise 128 Bytes of the Super G node and the remainder of the Super G node can be used to store the File Location Data .

A Super G node of type Super G node Data SGD can be used for a file that is small enough that its data can fit entirely within the File Location Data field of the SGD . For the embodiment described with reference to a small file refers to a file that is 16 256 Bytes or smaller. When a file s Super G node is of type SGD locating the file s data simply means reading it from the File Location Data field of the SGD .

In the embodiment shown in a Super G node of type Super G node Gee SGG can be used for medium files that is files of sizes up to approximately 700 MegaBytes of data that are too large to fit into an SGD . In an SGG the File Location Data field is used to hold a Gee String Packet GSP that comprises information very similar to that of the Gee String described with reference to . As with the Gee String the Gee String Packet comprises Gees that point to the physical locations of the file s data .

A Super G node of type Super G node List SGL can be used for large files whose Gee String is too large to be described by a Gee String Packet that fits within the SGL s File Location Data field. Instead the SGL s File Location Data field is used to hold a Gee String Packet Block GSPB which is a list of pointers to a plurality of Gee String Packets that together describe the Gees that point to the locations of the file s data . In one embodiment an SGL can reference files of sizes up to approximately 490 GigaBytes.

A Super G node of type Super G node List of Lists SGLL can be used for very large files. Here the File Location Data field of the SGLL comprises a Gee String Packet List Block that comprises pointers to a plurality of Gee String Packet Blocks that point to a plurality of Gee String Packets that points to a plurality of Gees that point to a plurality of storage locations that hold the desired data .

In one embodiment Gee String Packet List Blocks Gee String Packet Blocks and Gee String Packets are implemented in structures that are equivalent in size and organization to the Super G node described with reference to except that the G node field is not used.

The foregoing description of a distributed file storage system addresses the need for a fault tolerant storage system with improved reliability and scalability characteristics. This system features a flexible disk array architecture that accommodates the integration of variably sized disk drives into the disk array and provides mechanisms to permit each drive s capacity to be more fully utilized than prior art systems. In one embodiment variably sized data and parity blocks are distributed across the available space of the disk array. Furthermore the system provides methods of redistributing data across the disk array to improve data storage and retrieval as well as provide for improved fault tolerance. Another benefit of the data redistribution characteristics of the system is that it continues to provide fault tolerant data access in situations where many drives of the disk array have failed. This feature is a notable improvement over conventional RAID systems that typically only provide fault tolerance for single or at most two drive failures.

The communications medium can be any of a number of different networking architectures including for example Local Area Networks LAN Wide Area Networks WAN and wireless networks which may operate using Ethernet Fibre Channel Asynchronous Transfer Mode ATM and Token Ring etc. Furthermore any of a number of different protocols can be used within the communications medium to provide networking connectivity and information exchange capabilities between the clients and the server node including for example TCP IP protocols Bluetooth protocols wireless local area networking protocols WLAN or other suitable communications protocols.

The server node includes the server that serves as a front end to the disk array . The server receives information and requests from the clients and processes these requests to store and retrieve information from the disk array . In one aspect the server maintains at least a portion of an instruction set or file system that determines how data and information are stored and retrieved from the disk array .

Although the server node is illustrated as a single entity in it will be appreciated that many server nodes can be connected to the communications medium . Thus a plurality of server nodes can be connected to the communications medium and accessible to the clients for the purposes of information storage and retrieval. Furthermore the server nodes can operate independently of one another or be configured to transparently present a single disk image to each client thus creating a unified storage area that facilitates end user interaction with the server nodes . In one aspect the server nodes incorporate functionality for maintaining the single disk image through the use of the file system present in each of the servers which provides communication and organization to create the single disk image.

One advantage achieved by the aforementioned distributed configurations is that they may provide increased data protection and or fault tolerance. For example if the replicated server node fails or becomes unavailable the second replicated server node can handle client requests without service interruption. Another advantage achieved by using this interconnected arrangement is that alternative server node access paths can be created where identical data can be read simultaneously from the two or more interconnected server nodes . Thus if one server node in the cluster is busy and unavailable another redundant server node can service client requests to increase data throughput and accessibility. As with the single server node configuration a plurality of clusters may be present and accessible to the clients . Similarly the clusters can be configured to present a single disk image to the clients to facilitate interaction by the end users of the distributed file storage system .

As shown in each disk array in the server nodes can include a variable number of disks where each server node has a different disk array configuration. Each disk within the disk array can have a different storage capacity. These features of the distributed file storage system contribute to improved flexibility and scalability in configuring the server nodes .

The variable disk configuration of the distributed file storage system overcomes a limitation present in many conventional storage systems which require that upgrades to the storage system be performed in a coordinated manner where all disks in each disk array are replaced in unison. Additionally many conventional storage systems including RAID architectures require strict conformity amongst the disk arrays within the system as well as conformity in disk capacity within individual disk arrays. The distributed file storage system of the present invention is not limited by the restriction of uniform disk upgrades or conformity in disk capacity and can accommodate replacement or upgrades of one or more drives within each server node with drives of differing capacity. To maintain data integrity and knowledge of available storage space within the distributed file storage system one of the functions of the aforementioned file system present in the servers is to accommodate differences in disk array capacity and disk number between the server nodes.

A first file having data to be stored on the disk array is subdivided into one or more data blocks. The determination of the data block size number and distribution is calculated by the file system as data storage requests are received from the clients . Each data block is mapped or assigned to a location within the disk array that corresponds to the particular disk and logical block within the disk . Unlike conventional disk arrays the block size used for data storage is variable from one block to the next within the file.

The server organizes and distributes information to the disk array by dividing a file into one or more data blocks that are distributed between one or more parity groups . Each parity group includes a discrete number of data blocks and further includes a parity block containing parity information calculated for the data blocks contained within the particular parity group . Unlike conventional systems the size of the data blocks and parity blocks is not singularly fixed throughout the disk array . The collection of data blocks and parity blocks can include a number of different sizes and configurations resulting in more flexible storage of data within the disk array .

Using File in as an example the information contained in the file is distributed in 7 data blocks corresponding to DATA DATA. Each data block DATA DATA is distributed between 3 parity groups wherein the first parity group contains DATA DATA the second parity group contains DATA DATA and the third parity group contains DATA DATA. Furthermore 3 parity blocks PARITY PARITY and PARITY are formed one for each parity group.

The parity groups are determined by the server which assesses the incoming data to be stored in the disk array and determines how the data is distributed into discrete data blocks and furthermore how the data blocks are distributed into parity groups . After determining the data block and parity group distribution the server calculates the parity information for the data blocks in each parity group and associates the parity block containing this information with the appropriate parity group .

The server then determines how the information for each parity group is stored within the disk array . Each data block and parity block is distributed within the disk array in an arrangement where no blocks originating from the same parity group are stored on the same disk of the disk array . The non overlapping storage of data blocks and parity blocks derived from the same parity group creates the fault tolerant data storage arrangement where any block within a parity group can be reconstructed using the information contained in the other remaining blocks of the parity group . This arrangement where blocks associated with the same parity group are not be stored on the same disk is important in case of a disk failure within the array to insure that that lost data can be reconstructed. Otherwise if two or more blocks associated with the same parity group are stored on the same drive then in the event of a disk failure data recovery can not be assured.

An example distribution of data blocks and parity blocks within the disk array is shown in . The 7 data blocks and 3 parity blocks corresponding to the File are distributed along disk numbers and respectively. In a similar manner a second file is divided into 4 data blocks and 2 parity groups that are distributed along disk numbers and respectively. The size order and placement of the data blocks is pre determined by the server which assigns regions of each disk corresponding to particular logical blocks to store data blocks of designated sizes. The parity blocks of the parity groups associated with the first file are further stored on disks with the parity blocks of the second file stored on disks .

The data blocks and the parity blocks need not be sequentially stored but rather can be distributed throughout the disk array . Using this arrangement the distributed file storage system permits the non sequential assignment and storage of parity group information in a flexible manner that is not limited by a rigid order or placement schema. Flexible block placement in the aforementioned manner improves disk utilization within the disk array and provides for accommodating variable disk capacities as will be shown in greater detail in subsequent figures.

Upon receiving the data the server analyzes the characteristics of the data to determine how the data will be distributed into one or more data blocks . In one aspect the data analysis includes identifying the content or type of data that has been sent such as for example multimedia data textual data or other data types. Using one or more of the plurality of available disk blocks sizes the server identifies desirable block sizes and distribution mappings that are used to group the data and organize it into the data blocks .

The data is then parsed into blocks according to the data analysis and the resulting blocks are further arranged into one or more parity groups . The parity group arrangement determination distributes the data blocks between the parity groups and dictates the size of the parity blocks that will be associated with each parity group . For example a parity group composed of 3 data blocks having sizes of 128K 64K and 256K respectively will have a different associated parity block size than and parity group composed of 2 data blocks having sizes of 128K and 256K. The server can therefore vary the block size as well as the parity group size in a number of different ways to achieve improved storage and distribution characteristics within the disk array .

In one aspect the distributed file storage system is an improvement over conventional systems by allowing both data and parity blocks to be assigned to physical disk blocks. Furthermore the mapping of the data and parity blocks to the physical disk s may be performed either before or after the parity calculations thus improving storage flexibility.

Upon determining the parity group arrangement the server calculates the parity blocks for each parity group . As previously described the parity block calculation creates a fault tolerant information block which is associated with each group of data blocks within the parity group . The parity block is calculated by selecting all data blocks in a parity group and performing a logical operation on the data contained therein to compute error correction information. In one embodiment the error correction information is determined using the logical operation exclusive OR to generate the parity information. Using this error correcting information the parity block can be used to restore the information contained in a particular data block or parity group that may become corrupted. Furthermore the parity information can be used to restore the contents of entire disks within the disk array using the error correction information in conjunction with other non corrupted data.

When the parity groups have been formed the server then determines how the data blocks and parity block for each parity group will be distributed in the disk array. Although the data can be striped sequentially across the disks of the disk array it is typically more efficient to map and distribute the blocks throughout the disk array in a non sequential manner See . Mapping the data blocks in this manner requires knowledge of how the data blocks are positioned and ordered within the disk array . Detailed knowledge of the mapping for each data block is maintained by the server using a file storage mapping structure. This structure will be discussed below in connection with . Using the mapping schema determined by the server the blocks of each parity group are stored in the disk array .

As previously indicated the distributed file storage system employs a variable parity approach where the size of the parity block is not necessarily constant. The server creates parity blocks by selecting one of more data blocks for which error correction information will be computed. The size of the parity block is dependent upon the number of data blocks whose error correction information is computed and is determined by the server . In one aspect the server selects a parity block size that is convenient and efficient to store within the existing space of the disk array . The server also provides for distributed placement of the parity blocks in a manner similar to that of the data blocks . Thus both data blocks and parity blocks are desirably mapped throughout the disk array with the server maintaining a record of the mapping.

The server insures that both data blocks and parity blocks are appropriately positioned within the disk array to insure some level of fault tolerance. Therefore the server desirably distributes selected data blocks and parity blocks containing error correction information for the selected data blocks on non overlapping disks e.g. all blocks of a parity group are on separate disks . This insures that if a disk failure does occur that the corrupted information can be recovered using the remaining data parity information for each parity group. Upon calculating the appropriate parity information and distribution mapping the parity blocks are stored in the disk array in a manner designated by the server .

In either method of data and parity information storage the transfer of information from the client may comprise both a parametric component and a data component. The parametric component defines a number of parameters used in the storage of information to the disk array and may include for example operation definitions file handles offsets and data lengths. When using the aforementioned storage methods the parameters and data need not necessarily be transferred at the same time. For example the parameters may be transferred during the client storage request and the data may be transferred anytime thereafter in a subsequent stage of the method . In one aspect transfer of information using the parametric and data components desirably allows the distributed file storage system to make decisions about how to process the incoming data prior to the actual data transfer to thereby improve the flexibility and functionality of the system.

In addition to improved space utilization a number of other important features arise from the aforementioned flexible distribution of the blocks . In one aspect using variable capacity disks within the array contributes to improved scalability and upgradeability of the distributed file storage system . For example if the unused storage space within the array fails below a desired level one or more of the disks within the array can be readily replaced by higher capacity disks. The distributed file storage system implements an on the fly or hot swap capability in which existing disks within the array can be easily removed and replaced by other disks. Since each server in a cluster maintains a copy of the metadata for other servers in the cluster servers can also be hot swapped. Using this feature a new higher capacity disk can be inserted into the array in place of a lower capacity disk. The server is designed to automatically incorporate the disk space of the newly inserted drive and can further restore data to the new drive that resided on the former smaller capacity drive. This feature of the distributed file storage system provides for seamless integration of new disks into the array and facilitates disk maintenance and upgrade requirements.

In addition to exchanging or swapping existing disks within the array the server can accommodate the addition of new disks directly into the array . For example the disk array containing the fixed number of disks can be upgraded to include one or more additional disks such that the total number of disk in the array is increased. The server recognizes the additional disks and incorporates these disks into the addressable space of the distributed file storage system to provide another way for upgrading each disk array .

In the examples shown above both the swapping of disks to increase storage space and the incorporation of additional disks into the array is facilitated by the flexible block placement and addressing of disk space within the array . Unlike conventional systems that have a rigid architecture where the number of disks within each array is fixed and the addressable disk space is dictated by the smallest disk within the array the distributed file storage system accommodates many different disk array configurations. This flexibility is due in part to the manner in which the disk space is formatted as well as how the data is arranged and processed by the server .

In one aspect the flexibility of the distributed file storage system is improved through the use of parity groups . In order to accommodate files with different characteristics as well as improve how information is distributed throughout the disk array parity groups are formed with variable block numbers. The block number of the parity group is defined by the number of blocks within the group. For example a parity group containing 4 data blocks is characterized as having a block number of 4. In a similar manner a parity group containing a single data block is characterized as having a block number of 1. The block number of the parity group is one factor that determines the size of the parity group and additionally determines the information that will be used to form the parity block.

Data organization and management by the server is maintained using one or more data structures that contain information which identifies the size and ordering of the data blocks within each parity group . In one embodiment the ordering or sequence of the blocks is maintained through a linked list organizational schema. The linked list contains one or more pointers that act as links between each block within the parity group . The links therefore allow the server to maintain knowledge of the order of the blocks as they are distributed throughout the disk array . As blocks are written to or read from the disk array the server uses the links to identify the order of the blocks used for each parity group .

As shown in the distributed file storage system can also allocate parity groups on the basis of block size. In the illustrated embodiment exemplary parity groups are shown having the same block number of 4 with differing block sizes of 256K and 128K respectively. The feature of variable block size allocation within each parity group provides yet another way by which the server can distribute data and information within the disk array in a highly flexible and adaptable manner.

The implementation of parity groups having a plurality of different block numbers as well as allowing for the use of different block sizes within each block improves the ability of the server to utilize available disk space within the array . Furthermore using combinations of different data block and parity group characteristics allows the server to select combinations that are best suited for particular data types.

For example large data files such as multimedia video or sound are well suited for storage using large parity groups that contain large block sizes. On the other hand smaller files such as short text files do not have the same space requirements as the larger file types and thus do not significantly benefit from storage in a similar block size. In fact when small files are stored in large blocks there is the potential for wasted space as the smaller file does not use all of the space allocated to the block. Therefore the distributed file storage system benefits from the ability to create data blocks and parity groups of variable sizes to accommodate different data types and permit their storage in a space efficient manner.

As discussed in connection with the distributed file storage system further improves the utilization of space within the disk array by implementing a mechanism for reorganizing the allocation of data blocks as needed to accommodate data stored to the disk array . Furthermore a redistribution function shown in can alter the composition or distribution of blocks or parity groups within the array to make better use of available space and improve performance by reorganizing information previously written to the array .

In order to maintain coherence in the data stored to the disk array knowledge of the size and ordering of each block within the parity group is maintained by the server . Prior to writing of data to the disk array the server creates a disk map that allocates all of the available space in the disk array for storing particular blocks sizes and or parity group arrangements. Space allocation information is maintained by the server in a metadata structure known as a Gee Table. The Gee Table contains information used to identify the mapping and distribution of blocks within the disk array and is updated as data is stored to the disks .

The Gee Table stores informational groups which interrelate and reference disk blocks or other discrete space allocation components of the disk array . These informational groups referred to as Gee strings contain disk space allocation information and uniquely define the location of files in the disk array . Each Gee string is subdivided into one or more Gee groups which is further divided into one or more Gees containing the physical disk space allocation information. The Gee strings and components thereof are interpreted by the server to define the mapping of parity groups in the disk array which store information and files as will be discussed in greater detail hereinbelow.

Based on the available space within the disk array the server determines the type and number of parity groups that will be allocated in the array . The initial parity group allocation prior to data storage forms the Gee Table and directs the storage of data based on available parity groups. The Gee Table therefore serves as a map of the disk space and is updated as data is stored within the blocks of the array to provide a way for determining the file allocation characteristics of the array . The server retrieves stored files from the disk array using the Gee Table as an index that directs the server to the blocks where the data is stored so that they may be retrieved in a rapid and efficient manner.

In one embodiment space allocation in the disk array is achieved using a Gee Table containing an index field a G code field and a data field . The index field is a value that is associated with a row of information or Gee within the Gee Table and is used as an index or a pointer into the array or list comprising the Gee Table . Additionally the index field uniquely identifies each Gee within the Gee Table so that it can be referenced and accessed as needed.

The G Code field indicates the type of data that is stored in the disk space associated with each Gee and is further used to identify space allocation characteristics of the Gees . During initialization of the disk array the server assigns all of the disk space within the array to various parity groups . These parity groups are defined by the block size for data and parity blocks and the number of data blocks within the group . Identifiers in the G Code field correspond to flags including FREE AVAIL SPARE G NODE DATA PARITY LINK CACHE DATA or CACHE PARITY .

The data field stores data and information interpreted by the server in a specific manner depending upon the G code field identifier . For example this field can contain numerical values representing one or more physical disk addresses defining the location of particular blocks of the parity groups . Additionally the data field may contain other information that defines the structure characteristics or order of the parity blocks . As will be described in greater detail hereinbelow the information contained in the G table is accessed by the server and used to store and retrieve information from the disk array .

In one embodiment the fields of the G table map out how space will be utilized throughout the entire disk array by associating each physical block address with the designated Gee . Parity groups are defined by sets of contiguous Gees that are headed by the first Gee containing information that defines the characteristics of the parity group . The G Code field identifier G NODE instructs the server to interpret information in the data field of a particular Gee having the G NODE identifier as defining the characteristics of a parity block that is defined by a G group .

A characteristic defined in the data field of the Gee having a G NODE identifier includes an extent value . The extent value represents the extent or size of the blocks associated with each Gee in a particular G group . The extent value further indicates the number of logical disk blocks associated with each file logical block . For example the Gee with an index of 45 contains the G Code identifier G NODE and has a value of 2 associated with the extent value. This extent value indicates to the server that all subsequent data blocks and parity blocks defined in the parity group and represented by the G group will have a size of 2 logical disk blocks. Thus as indicated in the Gees having indexes 46 49 are each associated with two logical addresses for drive blocks within the array . In a similar manner the Gee with an index of 76 contains the G Code identifier G NODE and has an extent value of 3 . This value indicates to the server that the subsequent Gees 77 79 of the parity group are each associated with 3 physical drive block addresses.

In the preceding discussion of information is organized into a single G table however it will be appreciated that there are a number of different ways for storing the information to improve system flexibility including the use of multiple tables or data structures. The exact manner in which this information is stored is desirably designed to insure that it may be efficiently accessed. For example in one embodiment nodes of the Gee Table can be utilized as a common storage vehicle for multiple types of metadata including file names identifiers GNIDS Gees etc.

As discussed in connection with other G code identifiers are used during the storage and retrieval of information from the disk array . For example another G code identifier DATA signifies that the data field of a particular Gee is associated with the physical address for one or more drive blocks that will store data. Likewise the G code identifier PARITY signifies that the data field of a particular Gee is associated with the physical address for one or more drive blocks that store parity information. The parity information stored in the data blocks referenced by the PARITY Gee is calculated based upon the preceding DATA Gees as defined by the G NODE Gee. Thus as shown in the the Gee having an index of 79 will store the physical address of disk blocks that contain parity information for data blocks specified by Gees having indexes 77 78 .

Upon acquiring the necessary information describing the array composition the server determines a parity group allotment to be used in conjunction with the available disk space. The parity group allotment describes a pool of available parity groups that are available for data storage within the array . The parity group allotment further describes a plurality of different block and or parity group configurations each of which is suited for storing particular data and file types i.e. large files small files multimedia text etc . During data storage the server selects from the available pool of parity groups to store data in a space efficient manner that reduces wasted space and improves data access efficiency.

In one embodiment the parity group allotment is determined automatically by the server based on pre programmed parity group distribution percentages in conjunction with available disk space within the array . Alternatively the server can be configured to use a specified parity group allotment that is provided to the server directly. In another aspect the parity groups can be allocated dynamically by the server based on file characteristics such as file size access size file type etc.

Based on the allotment information and the disk space available in the array the server performs a mapping operation to determine how the parity groups of the allotment will be mapped to physical block addresses of drives within the array . The mapping operation comprises determining a desirable distribution of parity groups on the basis of their size and the available space and characteristics of the disk array . As the distribution of parity groups is determined by the server the G table is created and populated with Gees which associate each available parity group with the physical block addresses defining their location on one or more disks in the disk array . Initially the G table describes parity groups that contain free or available space however as data is stored to the disk the G table is updated to reflect the contents of the physical disk blocks that are pointed to by the Gees .

During operation of the distributed file storage system the G table is accessed by the server to determine the logical addresses of files and information stored within the disk array . Furthermore server continually updates the G table as information is saved to the disk array to maintain knowledge of the physical location of the information as defined by the logical block addresses. The dynamically updated characteristics of the G Table data structure therefore define and maintain the mapping of data and information in the disk array .

In addition to the aforementioned a priori method of parity group allocation other methods of disk preparation may also be utilized. For example another method of disk preparation can use a set of free disk block maps to allow dynamic allocation of the parity groups. This method additionally provides mechanisms for dynamic extension of existing parity groups and includes logic to ensure that the disk does not become highly fragmented. In some instances fragmentation of the disk is undesirable because it reduces the ability to use long parity groups when mapping and storing information to the disk.

Referring to the file is divided into a plurality of file logical blocks each of which contains a portion of the information represented in the file . The number size and distribution of the file logical blocks is determined by the server by selecting available disk logical blocks designated in the G table . The information contained in each file logical block is stored within the disk logical blocks and mapped using the G table . In the distributed file storage system the size of each file logical block is described by the extent value which is an integer multiple in disk logical blocks . For example the logical block designated LB 1 comprises two disk logical blocks and has an extent value of 2. In a similar manner the logical block designated LB 7 comprises three disk logical blocks and has an extent value of 3.

The server forms parity groups using one or more file logical blocks and the associated parity block . For each file one or more parity groups are associated with one another and ordered through logical linkages typically defined by pointers used to determine the proper ordering of the parity groups to store and retrieve the information contained in the file . As shown in the illustrated embodiment the file is defined by a parity string containing four parity groups . The four parity groups are further linked by three logical linkages to designate the ordering of the logical blocks LB 1 through LB 10 which make up the file .

The G table stores the information defining the G string using a plurality of indexed rows defining Gees . The Gees define the characteristics of the G strings and further describe the logical location of the associated file in the disk array . In the G table the G string is made up of the one or more Gee groups. Each G group is a set of contiguous Gees that all relate to a single file. For example in the illustrated embodiment the Gee string includes three Gee groups and .

The first Gee in each G group is identified by the G Code field identifier G NODE and the data field of this Gee contains information that defines the characteristics of a subsequent Gee within the Gee group . The data field of the first Gee in each G group further contains information that determines the ordering of the Gee groups with respect to one another. Some of the information typically found in the data field of the first Gee in each G group includes A G NODE reference that relates the current G group with a file associated with a G node at a particular index 67 in the illustration in the G table the extent value that defines the size of each file logical block in terms of disk logical blocks and a root identifier that indicates if the G group is the first G group in the G string. Of a plurality of G NODE Gees only the first Gee contains an indication that it is a Root Gee meaning that it is the first Gee of the Gee string .

Following the G NODE Gee in a Gee group are Gees representing one or more distributed parity groups . A distributed parity group is set of one or more contiguous DATA Gees followed by an associated PARITY Gee. A DATA Gee is a Gee with the G code of DATA that lists disk logical block s where a file logical block is stored. For example in the Gees with indexes of 46 47 50 52 77 79 and 89 90 are all DATA Gees and each is associated with one file logical block .

A PARITY Gee is a Gee with the G code of PARITY. Each PARITY Gee lists disk logical block location s for a special type of file logical block that contains redundant parity data used for error checking and error correcting one or more associated file logical blocks . A PARITY Gee is associated with the contiguous DATA Gees that immediately precede the PARITY Gee. The sets of contiguous DATA Gees and the PARITY Gees that follow them are known collectively as distributed parity groups .

For example in the PARITY Gee at index 49 is associated with the DATA Gees at indexes 46 48 and together they form the distributed parity group . Similarly the PARITY Gee at index 53 is associated with the DATA Gees at indexes 50 52 and together they form the distributed parity group . The PARITY Gee at index 79 is associated with the DATA Gees at indexes 77 78 which together form the distributed parity group and the PARITY Gee at index 91 is associated with the DATA Gees at indexes 89 90 which together form the distributed parity group .

The size of a disk logical block cluster described by a DATA Gee or a PARITY Gee matches the extent listed in the previous G NODE Gee. In the example of the G NODE Gee of the first Gee group defines an extent size of 2 and each DATA and PARITY Gee of the two distributed parity groups of the Gee group lists two disk logical block locations. Similarly G NODE Gee of the second Gee group defines an extent size of 3 and each DATA and PARITY Gee of the Gee group lists three disk logical block locations. G NODE Gee of the third Gee group defines an extent size of 3 and each DATA and PARITY Gee of the Gee group lists three disk logical block locations.

If a Gee group is not the last Gee group in its Gee string then a mechanism exists to link the last Gee in the Gee group to the next Gee group of the Gee string using the logical linkages . LINK Gees both have the G code of LINK and a listing in their respective Data fields that provides the index of the next Gee group of the Gee string . For example the Gee with an index of 54 is the last Gee of Gee group and its Data field includes the starting index 76 of the next Gee group of the Gee string . The Gee with an index of 80 is the last Gee of Gee group and its Data field includes the starting index 88 of the next Gee group of the Gee string . Since the Gee group does not include a LINK Gee it is understood that Gee group is the last Gee group of the Gee string .

As previously indicated the G code of FREE not shown in indicates that the Gee has never yet been allocated and has not been associated with any disk logical location s for storing a file logical block. The G code of AVAIL not shown in indicates that the Gee has been previously allocated to a cluster of disk logical block s for storing a file logical block but that the Gee is now free to accept a new assignment. Two situations in which a Gee is assigned the G code of AVAIL are after the deletion of the associated file logical block and after transfer of the file to another server in order to optimize load balance for the distributed file storage system .

In the illustrated embodiment the parity group includes two data blocks DATA and DATA and an associated parity block PARITY and are shown stored on DISK DISK and DISK respectively. Knowledge of the logical disk addresses for each of these blocks is maintained by the server using the aforementioned G table . As previously discussed the G table maintains mapping and structural information for each parity group defined by the plurality of Gees . The Gees further contain information including the file descriptor associated with the blocks of the parity group the size and extent of the blocks of the parity group and the mapping to the logical disk space for each block of the parity group . During routine operation the server accesses data in the disks of the array using the G table to determine the appropriate logical disk blocks to access.

As shown in a complete disk failure is exemplified where a loss of data integrity results in the logical blocks on DISK becoming inaccessible or corrupted. During the fault tolerant restoration process the server determines that the data block DATA is among the one or more blocks that must be recovered . Using conventional data parity block recovery methods the server recovers the compromised data block DATA using the remaining blocks DATA and PARITY of the associated parity group . The recovered data block DATA REC is then stored to the disk array and contains the identical information that was originally contained in DATA . Using the existing G table mapping as a reference the server identifies a new region of disk space that is available for storing the recovered data block and writes the information contained in DATA REC to this region. In one embodiment space for a new parity group is allocated and the reconstructed parity group is stored in the new space. In another embodiment the old parity group having 1 parity block and N data blocks where one data block is bas is entered onto the free list as a parity group having N 1 data blocks. The server further updates the G table to reflect the change in logical disk mapping if any of the recovered data block DATA REC to preserve file and data integrity in the disk array .

One desirable feature of the distributed file storage system is that the recovered data block need not be restored to the same logical disk address on the same disk where the data failure occurred. For example the recovered data block DATA REC can be stored to DISK and the G table updated to reflect this change in block position. An important benefit resulting from this flexibility in data recovery is that the disk array can recover and redistribute data from a failed drive across other available space within the disk array . Therefore a portion of a disk or even an entire disk can be lost in the distributed file storage system and the data contained therein can be recovered and moved to other locations in the disk array . Upon restoring the data to other available disk space the server restores the integrity of the parity group resulting in the preservation of fault tolerance through multiple losses in data integrity even within the same parity group without the need for immediate repair or replacement of the faulted drive to restore fault tolerance.

As an example of the preservation of fault tolerance through more than one data fault a second drive failure is shown to occur on DISK and affects the same parity group . This disk failure occurs subsequent to the previous disk failure in which DISK is illustrated as non operational. The second disk failure further results in the loss of data integrity for the block DATA . Using the method of data recovery similar to that described above the information contained in the data block DATA can be recovered and redistributed to another logical address within the disk array . The recovered data block DATA REC is illustrated as being saved to available disk space located on DISK and is stored in a disk region free of corruption of data fault. Thus fault tolerance is preserved by continuous data restoration and storage in available non corrupted disk space.

The fault tolerant data recovery process demonstrates an example of how the distributed file storage system handles data errors or corruption in the disk array . An important distinction between this system and conventional storage systems is that the aforementioned data recovery process can automatically redistribute data or parity blocks in a dynamic and adaptable manner. Using block redistribution processes described above results in the distributed file storage system having a greater degree of fault tolerance compared to conventional storage systems. In one aspect the increase in fault tolerance results from the system s ability to continue normal operation even when one or more drives experience a data loss or become inoperable.

In conventional storage systems when a single disk failure occurs the storage system s fault tolerant characteristics are compromised until the drive can be repaired or replaced. The lack of ability of conventional systems to redistribute data stored on the faulted drive to other regions of the array is one reason for their limited fault tolerance. In these conventional systems the occurrence of a second drive failure similar to that shown in will likely result in the loss or corruption of data that was striped across both of the failed drives. The distributed file storage system overcomes this limitation by redistributing the data that was previously stored on the faulted drive to a new disk area and updating the G table which stores the mapping information associated with the data to reflect its new position. As a result the distributed file storage system is rendered less susceptible to sequential drive faults even if it occurs within the same parity group. Thus the process of recovery and redistribution restores the fault tolerant characteristics of the distributed file storage system and beneficially accommodates further drive failures within the array .

Another feature of the distributed file storage system relates to the flexible placement of recovered data. In one aspect a recovered data block may be stored anywhere in the DFSS through a modification of the parity group associated with the data. It will be appreciated that placement of recovered data in this manner is relatively simple and efficient promoting improved performance over conventional systems.

In one embodiment this feature of tolerance to multiple disk failures results in an improved hands off or maintenance free data storage system where multiple drive failures are tolerated. Furthermore the distributed file storage system can be configured with the anticipation that if data corruption or a drive failure does occur the system will have enough available space within the array to restore and redistribute the information as necessary. This improved fault tolerance feature of the distributed file storage system reduces maintenance requirements associated with replacing or repairing drives within the array. Additionally the mean time between failure MTBF characteristics of the system are improved as the system has reduced susceptibility to sequential drive failure or data corruption.

In one embodiment the distributed file storage system is desirably configured to operate in a hands off environment where the disk array incorporates additional space to be tolerant of periodic data corruption or drive failures without the need for maintenance for such occurrences. Configuration of the system in this manner can be more convenient and economical for a number of reasons such as reduced future maintenance costs reduced concern for replacement drive availability and reduced downtime required for maintenance.

In one aspect the fact that parity groups may be integrated with the file metadata provides a way for prioritizing recovery of the data. For example when some file or set of files is designated as highly important or is frequently accessed a background recovery process can be performed on those designated files first. In the case where the file is frequently accessed this feature may improve system performance by avoiding the need for time consuming on demand regeneration when a client attempts to access the file. In the case where the file is highly important this feature reduces the amount of time where a second drive failure might cause unrecoverable data loss.

Data corruption may further be detected by the server when one or more disks within the array become inaccessible. Inaccessibility of the disks can arise for a number of reasons such as component failure within the drive or wiring malfunction between the drive and the server. In these instances where one or more disks within the array are no longer accessible the server identifies the data associated with the inaccessible drive s as being corrupted or lost and requiring restoration.

During the identification of the data fault the number and location of the affected logical blocks within the disk array is determined. For each logical block identified as corrupted or lost the server determines the parity group associated with the corrupted data . Identification of the associated parity group allows the server to implement restoration procedures to reconstruct the corrupted data using the non corrupted data and parity blocks within the same parity group . Furthermore the logical storage block or disk space associated with the corrupted data is identified in the G table to prevent further attempts to use the corrupted disk space.

In one embodiment the server identifies the bad or corrupted logical blocks mapped within the G table and removes the associated Gees from their respective parity groups thereby making the parity group shorter. Additionally the server can identify corrupted logical blocks mapped within the G table and remap the associated parity groups to exclude the corrupted logical blocks.

Prior to restoring the information contained in the affected logical blocks the server determines the number and type of parity groups that are required to contain the data that will subsequently be restored. This determination is made by accessing the G table and identifying a suitable available region within the disk array based on parity group allocation that can be used to store the reconstructed data. When an available parity group is found the server updates the G table to reflect the location where the reconstructed data will be stored. Additionally the mapping structure of the array is preserved by updating the links or references contained in Gees of the G table to reflect the position and where the reconstructed data will be stored in relation to other parity groups of the parity string. Data is then restored to the logical disk address pointed to by the updated Gee using the remaining non corrupted blocks of the parity group to provide the information needed for data restoration.

As previously discussed one feature of the distributed file storage system is the use of variable length and or variable extent parity groups. Unlike conventional storage systems that use only a fixed block size and configuration when storing and striping data to a disk array the system of the present invention can store data in numerous different configurations defined by the parity group characteristics. In one embodiment by using a plurality of different parity group configurations the distributed file storage system can improve the efficiency of data storage and reduce the inefficient use of disk space.

The first parity string comprises a single 4 block parity group having 1024 byte data and parity blocks. The total size of the first parity string including all data and parity blocks is 5120 bytes and has an extent value of 2. The second parity string comprises two 3 block parity groups having 1024 byte data and parity blocks. The total size of the second parity string including the data and parity blocks is 8192 bytes and has an extent value of 2. The third parity string comprises four 2 block parity groups having 512 byte data and parity blocks. The total size of the third parity string including the data and parity blocks is 6144 bytes and has and extent value of 1. The fourth parity string comprises nine 1 block parity groups having 512 byte data and parity blocks. The total size of the fourth parity string including the data and parity blocks is 8192 bytes and has an extent of 1.

Each of the parity strings represent the minimum number of parity groups of a particular type or composition that can be used to fully store the information contained in File . One reason for the difference in parity group composition results from the different numbers of total bytes required to store the data contained in File . The differences in total byte numbers further result from the number and size of the parity blocks associated with each parity group .

A utilization value is shown for each parity string used to store File . The utilization value is one metric that can be used to measure the relative efficiency of storage of the data of File . The utilization value is determined by the total number of bytes in the parity string that are used to store the data of File compared to the number of bytes that are not needed to store the data. For example in the second parity string one parity group is completely occupied with data associated with File while another parity group is only partially utilized. In one aspect the remainder of space left in this parity group is unavailable for further data storage due to the composition of the parity group . The utilization value is calculated by dividing the file occupying or used byte number by the total byte number to determine a percentage representative of how efficiently the data is stored in the parity string . Thus the utilization values for the first second third and fourth parity strings are 100 66 100 and 100 respectively.

In one embodiment the server determines how to store data based on the composition of the file and the availability of the different types of parity groups. As shown in of the different choices for storing File the first parity string is most efficient as it has the lowest total bytes required for storage 5120 bytes total as well as a high utilization value 100 . Each of the other parity strings are less desirable for storing the data in File due to greater space requirements larger number of total bytes and in some cases reduced storage efficiency lower utilization value .

When storing the byte pattern contained in File different storage characteristics are obtained for each parity string . For example the first parity string is only partially occupied by the data of File resulting in the utilization value of 25 . Similarly the second parity string is also partially occupied resulting in the utilization value of 33 . Conversely the third and fourth parity strings demonstrate complete utilization of the available space in the parity group 100 percent utilization . Based on the exemplary parity group characteristics given above the most efficient storage of File is achieved using the third parity string where a total of 1536 bytes are allocated to the parity string with complete 100 utilization.

The aforementioned examples demonstrate how files with differing sizes can be stored in one or more parity group configurations. In each of the above examples the unused blocks or partially filled blocks remaining in the parity group are zero filled or one filled to complete the formation of the parity group and encode the desired information from the file. Furthermore by providing a plurality of parity group configurations improved storage efficiency can be achieved for different file sizes where less space is left unutilized within the disk array . It will be appreciated by one of skill in the art that many possible parity group configurations can be formed in a manner similar to those described in B. Examples of characteristics which may influence the parity group configuration include logical block size extent parity group size parity group number among other characteristics of the distributed file storage system . Therefore each of the possible variations in parity group characteristics and distribution should be considered but other embodiments of the present invention.

Typically one or more selected parity groups of the available configurations of parity groups provide improved storage efficiency for particular file types. Therefore in order to maintain storage efficiency across each different file configuration a plurality of parity group configuration are desirably maintained by the server. One feature of the distributed file storage system is to identify desirable parity group configurations based on individual file characteristics that lead to improved efficiency in data storage.

Typically a plurality of parity group configurations are available and contain the requisite amount of space for storing the file. Using an analysis methodology similar to that described in B the server assesses the utilization characteristics for each parity group configuration that can be used to store the file. Based on the available configurations and their relative storage efficiency the server selects a desirable parity group configuration to be used for file storage. In one embodiment a desirable parity group configuration is identified on the basis of the high utilization value that is indicative of little or no wasted space non file encoding space within the parity groups. Furthermore a desirable parity group configuration stores the file in the parity string comprising the least number of total bytes in the parity string. Using these two parameters as a metric the server selects the desirable parity group configuration and stores the data contained in the file . During file storage the G table is updated to indicate how the file is mapped to the disk array and characteristics of the G string used to store the file are encoded in the appropriate Gees of the G table . Furthermore the one or more Gees corresponding to the logical disk blocks where the data from the file is stored are updated to reflect their now occupied status i.e. removed from pool of available or free disk space .

In another embodiment the distributed file storage system provides a flexible method for redistributing the parity groups of the disk array . As discussed previously prior to storage of information in the disk array the distributed file storage system creates the G table containing a complete map of the logical blocks of each disk of the disk array . Each logical block is allocated to a particular parity group type and may be subsequently accessed during data storage processes when the group type is requested for data storage. During initialization of the disk array the server allocates all available disk space to parity groups of various lengths or sizes which are subsequently used to store data and information. As files are stored to the disk array the parity groups are accessed as determined by the server and the availability of each parity group type changes.

Using the plurality of different sizes and configurations of parity groups allows the server to select particular parity group configurations whose characteristics permit the storage of a wide variety of file types with increased efficiency. In instances where a file is larger than the largest available parity group the server can break down the file and distribute its contents across multiple parity groups. The G table maps the breakdown of file information across the parity groups over which it is distributed and is used by the server to determine the order of the parity groups should be accessed to reconstruct the file. Using this method the server can accommodate virtually any file size and efficiently store its information within the disk array .

When a large quantity of structurally similar data is stored to the disk array a preferential parity group length can be associated with the data due to its size or other characteristics. The resulting storage in the preferential parity group length reduces the availability of this particular parity group and may exhaust the supply allocated by the server . Additionally other parity group lengths can become underutilized as the data stored to the disk array does not utilize these other parity group types in a balanced manner. In one embodiment the distributed file storage system monitors the parity set distribution and occupation characteristics within the disk array and can alter the initial parity set distribution to meet the needs of client data storage requests on an ongoing basis and to maintain a balanced distribution of available parity group types. The parity group monitoring process can further be performed as a background process or thread to maintain data throughput and reduce administrative overhead in the system .

As disk usage occurs parity groups become occupied with data and of the total initial allocation of parity groups a lesser amount remain as free or available parity groups . illustrates parity group data occupation statistics where of the original initially allocated parity groups for each parity type a fraction remain as free or available for data storage. More specifically The occupation statistics for the 4 block parity group comprise 2500 free vs. 7500 occupied parity groups the occupation characteristics for the 3 block parity group comprise 7500 free vs. 2500 occupied parity groups the occupation characteristics for the 2 block parity group comprise 3500 free vs. 6500 occupied parity groups and the occupation characteristics for the 1 block parity group comprise 500 free vs. 9500 occupied parity groups.

During operation of the distributed file storage system free parity groups can become unevenly distributed such that there are a greater proportion of free parity groups in one parity group length and a lesser proportion of free parity groups in another parity group length. While this disparity in distribution does not necessarily impact the performance or effectiveness of storing data to the disk array the server monitors the availability of each parity group to insure that no single parity group type becomes completely depleted. Depletion of a parity group is undesirable as it reduces the choices available to the server for storing data and can potentially affect the efficiency of data storage. As shown in the 3 block parity group possess a greater number of free parity groups compared to any of the other parity groups while the 1 block parity group possess the smaller number of free parity groups and may be subject to complete depletion should data storage continue with a similar parity group distribution characteristics.

To prevent parity group depletion the server can redistribute or convert at least a portion of one parity group into other parity group lengths. As shown in the server converts a portion of the 3 block parity group into the 1 block parity group . The resulting conversion redistributes the number of parity groups within the disk array by reducing the number of parity groups of a first parity group type 3 block parity and generates an additional quantity of parity groups of the second parity group type 1 block parity . Redistribution in this manner beneficially prevents the complete depletion of any parity group and thus preserves the efficiency of data storage by insuring that each parity group is available for data storage.

In one embodiment parity group redistribution is performed by updating one or more Gees of the G table to reflect new parity group associations. As previously discussed each parity group is assigned using a data structure linking associated Gees. The redistribution process updates these data structures to redefine the parity group associations for the logical blocks of the disk array . Thus the server can rapidly perform parity group distribution without affecting existing occupied parity groups or significantly degrading the performance of the distributed file storage system .

A second redistribution process known as parity group consolidation shown in converts two or more smaller parity groups into one or more larger parity groups. For example two 2 block parity groups can be combined to form the single 5 block parity group . Alternatively the two 2 block parity groups can be combined to form a 3 block parity group and a 1 block parity group .

It will be appreciated that numerous combinations of parity group dissolution and consolidation exist. These redistribution processes are advantageously used to modify the existing parity group configurations to accommodate the demands of the system as it is populated with information. Using these processes improves the performance and efficiency of storing data in the system . Consistency and knowledge of the parity group distribution is maintained using the G table which is updated as the modifications to the parity groups are made. These processes can further be performed using both occupied and unoccupied parity groups or a combination thereof to further improve the flexibility of the distributed storage system .

As a particular type of parity group is depleted indicated by a reduction in the number of free parity groups for the particular group type the server proceeds to assess the parity group statistics for each parity group defined within the G table . The assessment of parity group statistics comprises determining both the free and available parity group statistics using the G table as a reference. In determining how to increase the quantity of free parity groups for a depleted parity group type the server assesses which other parity groups contain available or free parity groups that have not be used to store data. This assessment is made based upon the parity group usage statistics which for example indicate free parity groups occupied parity group disk space occupation frequency of access or utilization among other statistics that can be collected while the distributed file storage system is in operation.

In one embodiment the server continually collects and stores usage statistics so as to provide up to date and readily available statistical information that can be used to determine how redistribution of available parity groups should proceed. Additionally these statistics can be acquired from the G table where the server calculates the usage statistics based upon the current contents of the G table .

Upon acquiring the parity group statistics the server calculates a suitable re distribution of the parity groups. The re distribution desirably takes into account factors such as for example the number and type of parity groups within the disk array the availability of unoccupied parity groups within each parity group type the frequency of usage or access of each parity group type among other considerations that can be determined using the parity group statistics. During parity group redistribution one or more different parity groups can be used as a source for supplementing the depleted parity group set. The overall effect of redistribution is to balance the free or available parity groups of each type so that no one single parity group is depleted.

Parity group redistribution in the aforementioned manner is facilitated by the use of the G table mapping structure. Using the G table parity groups can be readily assigned and re assigned without significant overhead by modifying the contents of appropriate Gees. This method of disk space allocation represents a significant improvement over conventional disk storage methods such as those used in RAID architectures. In conventional RAID architectures the rigid nature of disk space allocation prevents optimizing data storage in the manner described herein. Furthermore the parity group redistribution feature of the distributed file storage system provides an effective method to monitor and maintain optimized disk storage characteristics within the array to insure efficient use of available disk space.

In addition to redistributing free or available space within the disk array the distributed file storage system also features a method by which occupied parity groups can be modified and re configured into other parity group types. One benefit realized by re configuring occupied parity groups is that unnecessary space allocated to a particular parity group in which data is stored may be reclaimed for use and converted to available or free storage space. Furthermore re configuration of occupied parity groups can be used to de fragment or consolidate the information stored in the disk array enabling the information contained therein to be accessed more efficiently.

When the server performs an optimization routine one or more of the parity groups can be re configured into another type of parity group. For example as shown in the illustration a portion of the 1 block parity groups corresponding to 3200 groups can be consolidated into 2000 groups of 4 block parity. In the consolidated parity groups the original information contained in the 1 block parity group is retained in a more compact form in the 4 block parity groups. The resulting 4 block parity groups require less parity information to maintain data integrity compared to an equivalent quantity of information stored in a 1 block parity configuration. In the illustrated embodiment the residual space left over from the optimization routine corresponds to approximately 1200 groups of 1 block parity and can be readily converted into any desirable type of parity group using G table updating methods.

The aforementioned optimization routine can therefore beneficially re allocate occupied logical disk blocks into different parity group configurations to reclaim disk space that might otherwise be lost or rendered inaccessible due to the manner in which the data is stored in the parity groups. As with other parity group manipulation methods provided by the distributed file storage system the process of optimizing parity groups is readily accomplished by rearrangement of the mapping assignments maintained by the G table and provides a substantial improvement in performance compared to conventional storage systems. In conventional systems data restriping is a time consuming and computationally expensive process that reduces data throughput and can render the storage device unavailable while the restriping takes place.

Like conventional storage systems the distributed file storage system provides complete functionality for performing routine data and disk optimization routines such as de fragmentation of logical block assignments and optimization of data placement to improve access times to frequently accessed data. These processes are efficiently handled by the system which can use redundant data access to insure availability of data disk optimization routines take place.

The distributed file storage system further provides adaptive load balancing characteristics that improve the use of resources including servers and disk arrays . By balancing the load between available resources improved data throughput can be achieved where client requests are routed to less busy servers and associated disk arrays . Load dependent routing in this manner reduces congestion due to frequent accessing of a single server or group of servers. Additional details of these features can be found in those discussions relating to adaptive load balancing and proactive control of the DFSS .

In one embodiment frequently accessed data or files are automatically replicated such that simultaneous requests for the same information can be serviced more efficiently. Frequently accessed data is identified by the servers of the distributed file storage system which maintain statistics on resource usage throughout the network. Furthermore the servers can use the resource usage statistics in conjunction with predictive algorithms to learn content access patterns. Based on these access patterns frequently accessed content can be automatically moved to server nodes that have high bandwidth capacities capable of serving high numbers of client requests. Additionally less frequently accessed material can be moved to server nodes that have higher storage capacities or greater available storage space where the data or files can be conveniently stored in areas without significant bandwidth limitations.

Using either the resource utilization statistics the file access statistics or a combination thereof the one or more servers of the distributed file storage system predict future file and resource utilization characteristics . In one embodiment the future file and resource utilization characteristics describe a predicted workload for each of the disk arrays within the distributed file storage system . The predicted workload serves as a basis for determining how to best distribute the workload among available servers and disk arrays to improve access times and reduce bandwidth limitations. Furthermore the predicted workload can be used to distribute files or content across the available disk arrays to balance future workloads.

An additional feature of the distributed file storage system is the ability to perform hot upgrades to the disk array . This process can involve hot swapping operations where an existing disk within the array is replaced typically to replace a faulted or non operational drive . Additionally the hot upgrade process can be performed to add a new disk to the existing array of disks without concomitant disk replacement. The addition of the new disk in this manner increases the storage capacity of the disk array automatically and eliminates the need to restrict access to the disk array during the upgrade process in order to reconfigure the system . In one embodiment the server incorporates the additional space provided by the newly incorporated disk s by mapping the disk space into existing unused available parity groups. For example when a new drive is added to the disk array the server can extend the length or extent of each available parity group by one. Subsequently parity group redistribution processes can be invoked to optimize and distribute the newly acquired space in a more efficient manner as determined by the server . In one embodiment when there are more newly added logical disk blocks than can be accommodated by addition to the unused parity groups at least some of the unused parity groups are split apart by the dissolution process to create enough unused parity groups to incorporate the newly added logical disk blocks.

One approach to adaptive or active load balancing includes two mechanisms. A first mechanism predicts the future server workload and a second mechanism reallocates resources in response to the predicted workload. Workload prediction can have several aspects. For example one aspect includes past server workload such as for example file access statistics and controller and network utilization statistics. The loading prediction mechanism can use these statistics with an appropriate filter applied to generate predictions for future loading. For example a straightforward prediction can include recognizing that a file that has experienced heavy sequential read activity in the past few minutes will likely continue to experience heavy sequential read access for the next few minutes.

Predictions for future workload can be used to proactively manage resources to optimize loading. Mechanisms that can be used to reallocate server workload include the movement and replication of content files or objects between the available storage elements such that controller and storage utilization is balanced and include the direction of client accesses to available controllers such that controller and network utilization is balanced. In one embodiment some degree of cooperation from client machines can provide effective load balancing but client cooperation is not strictly needed.

Embodiments of the invention include a distributed file server or servers comprising a number of hardware resources including controllers storage elements such as disks network elements and the like. Multiple client machines can be connected through a client network or communication fabric to one or more server clusters each of which includes of one or more controllers and a disk storage pool.

File system software resident on each controller can collect statistics regarding file accesses and server resource utilization. This includes information of the access frequency access bandwidth and access locality for the individual objects stored in the distributed file the loading of each controller and disk storage element in terms of CPU utilization data transfer bandwidth and transactions per second and the loading of each network element in terms of network latency and data transfer bandwidth.

The collected statistics can be subjected to various filter operations which can result in a prediction of future file and resource utilization i.e. workload . The prediction can also be modified by server configuration data which has been provided in advance for example by a system administrator and explicit indications regarding future file and or resource usage which may be provided directly from a client machine.

The predicted workload can then be used to move content files objects or the like between storage elements and to direct client accesses to controllers in such a manner that the overall workload is distributed as evenly as possible resulting in best overall load balance across the distributed file storage system and the best system performance.

The predicted workload can be employed to perform client network load balancing intra cluster storage load balancing inter node storage load balancing intra node storage capacity balancing inter node storage capacity balancing file replication load balancing or the like.

Client network load balancing includes managing client requests to the extent possible such that the client load presented to the several controllers comprising a server cluster and the load presented to the several client network ports within each is evenly balanced. Intra cluster storage load balancing includes the movement of data between the disks connected to a controller cluster such that the disk bandwidth loading among each of the drives in an array and the network bandwidth among network connecting disk arrays to controllers is balanced. For example intra cluster storage load balancing can be accomplished by moving relatively infrequently accessed files or objects. Intra cluster storage load balancing advantageously achieves uniform bandwidth load for each storage sub network while also achieving uniform bandwidth loading for each individual disk drive.

Inter node storage load balancing comprises the movement of data between drives connected to different controller clusters to equalize disk access load between controllers. This can often cost more than intra node drive load balancing as file data is actually copied between controllers over the client network. Intra node storage capacity balancing comprises movement of data between the disks connected to a controller or controller pair to balance disk storage utilization among each of the drives.

Inter node storage capacity balancing comprises movement of data between drives connected to different controllers to equalize overall disk storage utilization among the different controllers. This can often cost more than intra node drive capacity balancing as file data is actually be copied between controllers over the network. File replication load balancing comprises load balancing through file replication as an extension of inter node drive load balancing. For example high usage files are replicated so that multiple controller clusters include one or more that one local read only copy. This allows the workload associated with these heavily accessed files to be distributed across a larger set of disks and controllers.

Based on the foregoing embodiments of the present invention include a distributed file storage system that proactively positions objects to balance resource loading across the same. As used herein load balancing can include among other things capacity balancing throughput balancing or both. Capacity balancing seeks balance in storage such as the number of objects the number of Megabytes or the like stored on particular resources within the distributed file storage system. Throughput balancing seeks balance in the number of transactions processed such as the number of transactions per second the number of Megabytes per second or the like handled by particular resources within the distributed file storage system. According to one embodiment the distributed file storage system can position objects to balance capacity throughput or both between objects on a resource between resources between the servers of a cluster of resources between the servers of other clusters of resources or the like.

The distributed file storage system can proactively position objects for initial load balancing for example to determine where to place a particular new object. While existing server loading is a factor used in the determination other data can be used to help predict the access frequency of the new object such as for example file extensions DV access attributes or the like. For example a file extension indicating a streaming media file can be used to predict a likely sequential access to the same.

The distributed file storage system actively continues load balancing for the existing objects throughout the system using load balancing data. For capacity load balancing large objects predicted to be infrequently accessed can be moved to servers which for example have the lower total percent capacity utilizations. Movement of such files advantageously avoids disrupting throughput balancing by moving predominantly infrequently accessed files. For throughput balancing objects predicted to be frequently accessed can be moved to servers which for example have the lower total percent transaction utilizations. In one embodiment smaller objects predicted to be frequently accessed can be moved in favor of larger objects predicted to be frequently accessed thereby advantageously avoiding the disruption of capacity balancing.

According to one embodiment one or more filters may be applied during initial and or active load balancing to ensure one or a small set of objects are not frequently transferred or churned throughout the resources of the system.

The distributed file storage system can comprise resources such as a server or server which can seek to balance the loading across the system by reviewing a collection of load balancing data from itself one or more of the other servers in the system or the like. The load balancing data can include object file statistics server profiles predicted file accesses historical statistics object patterns or the like. A proactive object positioner associated with a particular server can use the load balancing data to generate an object positioning plan designed to move objects replicate objects or both across other resources in the system. Then using the object positioning plan the resource or other resources within the distributed file storage system can execute the plan in an efficient manner.

According to one embodiment the generation of the positioning plan can be very straightforward such as for example based on object sizes and historical file access frequencies. Alternatively the generation of the plan can be quite complex based on a large variety of load balancing information applied to predictive filtering algorithms the output of which is a generally more accurate estimate of future file accesses and resource usage which results in more effective object positioning. Another embodiment can include adaptive algorithms which track the accuracy of their predictions using the feedback to tune the algorithms to more accurately predict future object access frequencies thereby generating effective object positioning plans.

According to one embodiment each server pushes objects defined by that server s respective portion of the object positioning plan to the other servers in the distributed file storage system. By employing the servers to individually push objects based on the results of their object positioning plan the distributed file storage system provides a server process and administrator independent automated approach to object positioning and thus load balancing within the distributed file storage system.

To facilitate a complete understanding of exemplary load balancing aspects of the invention this part of the detailed description describes the invention with reference to wherein like elements are referenced with like numerals throughout.

According to one embodiment each of the servers F F F F and F comprises software hardware and communications similar to the servers disclosed with reference to . For example server F communicates with each drive of the disk array . Additionally server F forms part of cluster . According to one embodiment at least some of the objects stored on a disk array within a cluster are stored and are thereby accessible on other disk arrays within the cluster. For example server F can be configured to communicate with each drive of the disk array . Server F also communicates with one or more of the other servers of the DFSS . Moreover the servers F F F F and F include software and hardware systems which employ some or all of the features of the distributed file storage system such as for example the disclosed use of metadata structures for object organization metadata and data caching and the like.

According to one embodiment the DFSS includes proactive object positioning. For example each server F F of the DFSS proactively positions objects such as files directories or the like based on a desire to balance or optimize throughput capacity or both. According to one embodiment the foregoing balancing and optimization can advantageously occur at multiple levels within the DFSS . For example the DFSS can advantageously seek to optimize the placement and structure of objects within and between disks of the disk arrays between the servers of a cluster and between servers of other clusters.

Similar to the embodiments disclosed with reference to the DFSS provides the server F with the ability to adjust the file logical block size and the distribution of files across multiple drives using for example the Gee Table . Thus the server F can adjust or choose the layout of particular files within a disk using for example larger file logical block sizes for larger files or the like thereby creating efficient storage of the same. Moreover the server F can adjust or choose the layout of particular files across varying numbers of disks thereby matching for example performance of drives within the disk array with attributes of particular files.

For example shows the placement of two files within the DFSS e.g. streamed file SF and large file LF. According to the exemplary embodiment file SF comprises a file which is to be streamed across computer networks such as for example the Internet. As shown in file SF is stored in the disk array using a distributed parity group of three blocks e.g. two data blocks SF and SF and one parity block SF. Similar to the foregoing description of distributed file storage system the DFSS advantageously allows files to modify the number of drives in the distributed parity group for a variety of reasons including to take advantage of attributes of a disk array. Thus when it is determined that it is desirable to store file SF on only fast disk drives the distributed parity group can be chosen such that file SF is stored on the fastest drives of disk array in equally shared portions. A skilled artisan will recognize from the disclosure herein that the servers advantageously balance the desire to employ the faster drives of a particular disk array against the desire to reduce the overhead associated with using smaller parity groups. For example according to some embodiments use of only two disks of five disks means that half of the data stored is overhead parity data.

Thus the server F advantageously and proactively can adjust the placement and structure of objects such as files within and between drives of the disk array . A skilled artisan will recognize that such proactive placement is outside the ability of conventional data storage systems. For example as disclosed with reference to the DFSS advantageously includes a directory and file handle lookup process which allows the clients to find files without first knowing which server is currently storing the file. Thus when one of the servers of the DFSS repositions an object to balance load capacity or the like the clients can use the lookup process to find the repositioned object in its new location.

As disclosed in the foregoing one embodiment of the DFSS seeks to balance the loading and capacity between servers of a cluster. As disclosed with reference to the embodiments of FIGS. and the clients request data from a file through the use of the file handle which according to one embodiment includes the server identification . Thus the DFSS can advantageously alter the server identification of the file handle for a particular file thereby changing the read or write request from being processed by for example server F to for example server F. A skilled artisan will recognize a wide number of reasons for making the foregoing alteration of the file handle including the availability of F the load of F versus F or the like. In addition the DFSS can alter the file handle based on comparisons of server load balancing data to set up read only copies of heavily accessed files or the like as discussed below.

Load balancing between servers differs from load balancing between drives in among other things load balancing between servers involves balancing through the movement or creation of additional copies of objects while load balancing between drives involves the movement of data blocks.

One embodiment of the DFSS comprises servers F F each having access to load balancing data from itself and each of the other servers. According to one embodiment each server uses the load balancing data to generate an object positioning plan and then pushes objects defined by their respective portion of the plan to other servers in the DFSS . The foregoing implementation provides a distributed and server independent approach to object positioning within the DFSS . It will be understood by a skilled artisan from the disclosure herein that resources or groups of resources can gather load balancing data such as for example each some or all clusters each some or all servers or the like.

According to one embodiment the load balancing data of a particular server can include a wide variety of statistical and attribute data relating to the architecture and performance of the respective server and disk array. Additional statistical information can be maintained relating to the historical object access frequencies and patterns. This statistical information can be applied to a filtering function to predict future object frequencies and patterns.

The load balancing data can include relatively static information such as for example the number of servers for a given cluster and the number of drives connected to each server. Moreover for each server the load balancing data can include an indication of the number and type of interfaces available to the server performance statistics of the server amount of available memory an indication of the health of the server or the like. For each drive the load balancing data can include an indication of the layout of the drive such as track information cylinder information or the like capacity and performance information performance statistics an indication of the health of the drive or the like. Additionally the load balancing data can include an indication of the performance and the health of storage network configurations client network configurations or the like. The relatively static load balancing data can be considered the profile of the resources associated therewith.

Other relatively static information can include an indication of the quality of service being demanded by the clients from a particular server such as for example server F and its associated disk array can be configured to provide data availability with little or no downtime thereby allowing the server to support Internet hosting applications or the like. Additionally the foregoing relatively static statistical or attribute information can change occasionally such as for example when a drive is replaced or added a server is reconfigured the quality of service is changed or the like.

According to yet another embodiment the load balancing data can also include relatively dynamic information such as for example throughput information like the number of read or write input output operations per second IOPS . For example the dynamic information can include server throughput for each server such as for example client transactions per second client megabytes per second disk transaction per second disk megabytes per second or the like. The foregoing server throughput information can include read write or both operations for each client interface of the particular server. The server throughput data also includes dynamic information such as the cache hit ration errors or the like of each particular server. The dynamic information can also include disk throughput for each disk such as for example an indication of the amount of metadata capacity that is being utilized the amount of data capacity utilized read write or both transactions per second read write or both megabytes per second errors or the like.

In addition to the foregoing data the load balancing data includes object statistic information such as for example the last access time and the access frequency for each object. According to one embodiment the measurement of access frequency can be filtered using one or more filtering weights designed to emphasize for example more recent data over more historical data.

According to one embodiment each server may include file statistical information in the load balancing data comprising additional information for the more heavily accessed and potentially smaller objects. For example the file statistical information can include an indication of access frequency for for example the last ten 10 minutes one 1 hour twenty four 24 hours or the like. Moreover the file statistical information can include average read block size average write block size access locality such as a indication of randomness or sequentialness for a given file histogram data of accesses versus day and time or the like. According to one embodiment the indication of randomness can include randomness rating such as for example a range from 0 and 1 where 0 corresponds to primarily randomly accessed file and one corresponds to a primarily sequentially accessed file or vice versa.

Based on the above the load balancing data for a given server can include virtually any information performance or attribute statistic or the like that provides insight into how objects such as files and directories should be created reconfigure moved or the like within the DFSS . For example a skilled artisan can include additional information useful in the prediction of file access frequencies such as for example the time of day the file size the file extension or the like. Moreover the additional information can include hints corresponding to dynamic volume access attributes such as for example block size read write information the foregoing quality of service guarantees or the randomness sequentialness of file access.

According to one embodiment the load balancing data can include a Least Recently Used LRU stack and or a Most Recently Used MRU stack advantageously providing insight into which objects can be used for balancing capacity throughput or both within the DFSS . For example according to one embodiment the LRU stack tracks the objects that are rarely or infrequently accessed thereby providing information to the servers about which objects can be mostly ignored for purposes of throughput balancing and are likely candidates for capacity balancing. The MRU stack tracks the objects that are more frequently accessed thereby providing information to the servers about which objects are highly relevant for throughput balancing. According to one embodiment the servers F F can employ the MRU stack to determine the objects on which the servers should be tracking additional performance statistics used in more sophisticated load balancing or sharing solutions as discussed in the foregoing.

A skilled artisan will recognize from the disclosure herein that the MRU and LRU stacks can be combined into a single stack or other structure tracking the frequency of access for some or all of the objects of the servers F F. A skilled artisan will also recognize from the disclosure herein that the time frame chosen for determining frequency of use for a given object affects the throughput and capacity balancing operations. For example if the time frame is every twelve hours the number of objects considered to be frequently accessed may be increased as compared to a time frame of every half second. According to one embodiment the DFSS uses an adaptive time frame of ten 10 minutes to twenty four 24 hours.

Although the load balancing data is disclosed with reference to its preferred embodiment the invention is not intended to be limited thereby. Rather a skilled artisan will recognize from the disclosure herein a wide number of alternatives for the same. For example the load balancing data can include detailed performance statistics similar to those disclosed above. On the other hand the load balancing data can include only a few data points providing only a rough sketch of the throughput and capacity on a particular server. Moreover the server may track access frequency using information contained in the G Node of an object such as for example the last access time or atime field.

As disclosed in the foregoing the servers F F F F and F each share their respective load balancing data with one another. Thus the load balancing data comprises load balancing data from the particular server in this example server F and the load balancing data from each of the other servers F F and F F. According to one embodiment a server transmits its load balancing data at predetermined time intervals. According to another embodiment each server determines when a significant change or a time limit has expired since the last broadcast of its load balancing data and then broadcasts the same.

As shown in each server includes the proactive object positioner which accepts as an input the load balancing data of the some or all of the servers and generates as an output the object positioning plan . According to one embodiment the proactive object positioner for a given server generates a plan for that server. The server then attempts to push objects found in the plan to the other servers in the DFSS to balance throughput capacity or both. According to another embodiment the proactive object positioner for a given server generates the plan which is relevant to all servers. In such a case the server attempts to push only its objects from the plan to other servers. Thus each server in the DFSS acts independently to accomplish the plan of the entire DFSS thereby advantageously providing a distributed and balanced approach that has no single point of failure and needing if any only minimal supervision.

As discussed in the foregoing the object positioner corresponding to each server in the DFSS can generate the positioning plan to position objects to balance capacity throughput or both.

According to one embodiment the proactive object positioner for each server can instruct its server to balance the number of objects stored on some or each disk array of the DFSS . For example as disclosed with reference to each server has a predefined amount of memory for caching the G nodes of the objects stored on the disk array associated with that server. By balancing the number of objects related to a particular server the DFSS advantageously avoids having more G node data for a server than can be stored in that server s G node memory cache.

According to one embodiment the proactive object positioner for each server can instruct its server to balance the size of objects stored on some or each disk array of the DFSS . For example if a particular server is associated with a disk array having a large number of small objects stored therein the server can exceed that server s G node memory cache. Therefore each proactive object positioner can instruct its server to push objects such that the size of objects accessible by each server is balanced. For example the servers can evenly distribute the number of small objects the number of medium sized objects and the number of large objects between servers. By balancing the size of objects related to a particular server the DFSS reduces the chances of having more G node data for a server than can be stored in that server s G node memory cache.

According to yet another embodiment the proactive object positioner for each server can instruct its server to optimize the number of free and used data blocks when the servers in the DFSS have a large average object size. In such case the number of G nodes and the G node memory cache will not likely be a performance issue although number of used versus free data blocks will likely be an issue. While used versus free data blocks need not be entirely uniform across servers maintaining a certain level of unused block capacity for each server provides flexibility in throughput balancing and new object creation thereby enhancing the performance of the overall DFSS .

According to one embodiment the proactive object positioner generates the positioning plan to position objects based on for example predicted access frequencies of the same. As discussed above prediction may comprise historical data and may comprise a number of other data and factors as well. The positioner can advantageously use objects predicted to be infrequently accessed for capacity balancing to avoid upsetting any throughput balancing already in place. For example when the positioner determines to balance the capacity among resources of the DFSS such as for example a drive disk array or server the positioner can move objects that are of little significance to the throughput of the resource such as for example those objects predicted to be least accessed. Thus as the positioner balances the capacity through objects predicted to be or found to be least recently accessed the respective throughput of the resources will not be substantially affected. According to one embodiment each server tracks the objects predicted to be infrequently used by maintaining in their load balancing data an LRU stack of for example pointers to the G Nodes of the objects predicted to be infrequently accessed.

Additionally the positioner can generate the positioning plan to move objects predicted to be infrequently accessed from faster drives to slower drives. For example if the large file LF from were predicted to be infrequently accessed storage of file LF on the fastest drives of the DFSS for example the drives of the disk array would be inefficient. Thus the proactive object positioner determines that the large file LF predicted to be infrequently accessed can be advantageously stored on the slow large drives of the disk array of server F. A skilled artisan will recognize that movement of the file LF to servers F is not expected to substantially affect the throughput of servers F and F outside of the processes for moving the file LF.

Additionally the proactive object positioner can use the MRU stack in a server s load balancing data to instruct an overburdened server to take actions to offload some of the access from itself to those servers with less throughput. For example the positioner can generate instructions to move the objects predicted to be heavily accessed to other servers thereby moving the entire throughput load associated therewith to the other servers. Also positioner can generate instructions to create copies of objects predicted to be heavily accessed on other servers thereby sharing the throughput load with the other servers

For example according to one embodiment the server F includes the streamed file SF predicted to be heavily accessed which in this example may include extremely popular multimedia data such as for example a new video or music release a major news story or the like where many clients are requesting access of the same. Moreover according to this embodiment the server F is being over utilized while the server F is being under utilized. Thus the object positioner recognizes that the movement of the file SF to the server F may simply overload the server F. According to one embodiment the proactive object positioner can instruct the server F to push for example read only copies of the file SF to the server F. Moreover a skilled artisan will recognize from the disclosure herein that the server F can then return to a requesting client a file handle for the file SF designating server F and the client will then generate requests to server F instead of server F. Accordingly the over utilization of server F is advantageously decreased while the under utilization of server F is advantageously increased thereby balancing the throughput across the DFSS .

According to yet another embodiment the proactive object positioner can generate instructions to move objects to match the attributes of resources available to a particular server thereby potentially decreasing the response time of the DFSS . For example as illustrated in the foregoing embodiment the object positioner can instruct the server F to push the file SF predicted to be heavily accessed to the server F having very fast disk drives even when the server F is not being over utilized. Moreover as discussed above the positioner can instruct the server F to store the file in distributed parity groups matching the number of very fast drives.

According to one embodiment one or more of the servers can include specific software and hardware solutions such as dedicated digital signal processors which can add additional horse power to the generation of the object positioning plan . For example load balancing can be performed by an external client connected to the DFSS .

As shown in the plan calls for server F to push the large file LF to server F for storage thereon thereby freeing the fastest drives in the DFSS to store more objects predicted to be more heavily accessed. Moreover the plan includes an indication that server F will return an indication of staleness for any clients still caching the file handle of file LF designating server F. The plan also indicates that if server F requests server F will accept and store a copy of the streamed file SF and return an indication of file creation to server F such as for example the file handle of server F s copy of file SF. Thus the DFSS uses a pushing approach to ensure server independence in proactively placing objects.

Based on the foregoing disclosure related to a skilled artisan will recognize the vast scalability of the DFSS . For example adding or removing hardware components such as drives resources or even servers simply causes updated or sometimes additional load balancing information to be broadcast to the other servers. Each server then can immediately generate new positioning plans to take full advantage of the new components or configuration of the DFSS . Each server then pushes their respective objects throughout the DFSS thereby efficiently balancing the throughput capacity or both of the same.

Although the foregoing invention has been described in terms of certain preferred embodiments other embodiments will be apparent to those of ordinary skill in the art from the disclosure herein. For example the DFSS may advantageously push new file handles to clients such as for example file handles including information on the location of an object. According to another embodiment the DFSS can advantageously allow servers who have pushed objects to other servers to automatically suggest new file handles to requesting clients. However this approach can have the drawback that the file handle stored by the old server can itself be outdated for example when the new server subsequently pushed the same object to yet another server. Thus according to one embodiment servers return indications of staleness for objects they not longer have stored on their respective disk arrays.

In addition a skilled artisan will recognize from the disclosure herein that many of the balancing ideas can be implemented in conventional non distributed file storage systems. For example the method of moving infrequently accessed files to balance capacity so as not to upset balanced load can be incorporated into conventional data storage systems.

Each server in the DFSS includes storage controller hardware and storage controller software to manage an array of disk drives. For example the servers each manage data on the disk arrays and . A large number of disk drives can be used and the DFSS can be accessed by a large number of client machines . This potentially places a large workload on the servers . It is therefore desirable that the servers operate in an efficient manner to reduce the occurrence of bottlenecks in the storage system.

Prior art approaches for storage servers tend to be software intensive. Specifically a programmable CPU in the server becomes involved in the movement of data between the client and the disks in the disk array. This limits the performance of the storage system because the server CPU becomes a bottleneck. While prior approaches may have a certain degree of hardware acceleration such as XOR parity operations associated with RAID these minimal acceleration techniques do not adequately offload the server CPU.

The storage interfaces communicate with the disks . In one embodiment the first I O bus is a PCI bus. In one embodiment the second I O bus is a PCI bus. In one embodiment the caches and are non volatile. In one embodiment the network interfaces are Fibre Channel interfaces. In one embodiment the storage interfaces are Fibre Channel interfaces. The data engine can be a general purpose processor a digital signal processor a Field Programmable Gate Array FPGA other forms of soft or hard programmable logic a custom ASIC etc. The network interface controllers can support Fibre Channel Ethernet Infiniband or other high performance networking protocols.

The architecture shown in allows data to be efficiently moved between the client machines and disks with little or no software intervention by the CPU . The architecture shown in separates the data path from the control message path. The CPU handles control file system metadata and housekeeping functions conceptually the CPU can be considered as a control engine . Actual file data passes through the data engine .

Control messages e.g. file read write commands from clients are routed to the CPU . The CPU processes the commands and queues data transfer operations to the data engine . The data transfer operations once scheduled with the data engine can be completed without further involvement of the CPU . Data passing between the disks and the clients either as read or write operations is buffered through the data cache and or the data cache . In one embodiment the data engine operates using a data flow architecture that packages instructions with data as the data flows through the data engine and its associated data caches.

The data engine provides a separate path for data flow by connecting the network interfaces and the storage interfaces with the data caches . The data engine provides file data transfers between the network interface and the caches and between the storage interface and the caches . As an example of the data path operation consider a client file read operation. A client read request is received on one of the network interfaces and is routed to the CPU . The CPU validates the request and determines from the request which data is desired. The request will typically specify a file to be read and the particular section of data within the file. The CPU will use file metadata in the cache to determine if the data is already present in one of the data caches or if the data must be retrieved from the disks . If the data is in the data cache the CPU will queue a transfer with the network interfaces to transfer the data directly from the appropriate data cache to the requesting client with no further intervention by the CPU . If the data is not in the data caches then the CPU will queue one or more transfers with the storage interfaces to move the data from the disks to the data caches again without further intervention by the CPU . When the data is in the data caches the CPU will queue a transfer on the network interfaces to move the data to the requesting client again without further intervention by the CPU .

One aspect of the operation of the data engine is that the CPU schedules data movement operations by writing an entry onto a queue in the network interfaces or into a queue in the storage interfaces . The data engine and the network and storage interfaces are connected by busses . The busses each include an address bus and a data bus. In one embodiment the network or storage interfaces perform the actual data movement or sequence of data movements independently of the CPU by encoding an instruction code in the address bus that connects the data engine to the interface. The instruction code is set up by the host CPU when the transfer is queued and can specify that data is to be written or read to one or both of the cache memories . In addition the instruction code can specify that an operation such as a parity XOR operation or a data conversion operation be performed on the data while it is in transit through the data engine . Because instructions are queued with the data transfers the host CPU can queue hundreds or thousands of instructions in advance with each interface and all of these instructions can be can be completed asynchronously and autonomously.

As described above once a data movement operation has been queued the data engine offloads the CPU from direct involvement in the actual movement of data from the clients to the disks and vice versa. The CPU schedules network transfers by queuing data transfer operations on the network interfaces and the storage interfaces . The interfaces and then communicate directly with the data engine to perform the data transfer operations. Some data transfer operations involve the movement of data. Other data transfer operations combine the movement of data with other operations that are to be performed on the data in transit e.g. parity generation data recovery data conversion etc. .

The processing modules in the data engine can perform five principal operations as well as a variety of support operations. The principal operations are 

The data ASIC is a special purpose parallel processing system that is data flow driven. That is the instructions for the parallel processing elements are embedded in data packets that are fed to the ASIC and to the various functional blocks within the ASIC .

In one embodiment the ASIC has four principal interfaces a first data cache interface a second data cache interface a first bus interface and a second bus interface . Other versions of the ASIC can have a different number of interfaces depending on performance goals.

Data from the first data cache interface is provided to a cache read buffer to a feedback buffer to a feedback buffer and to a cache read buffer . Data from the second data cache interface is provided to a cache read buffer to a feedback buffer to a feedback buffer and to a cache read buffer .

Data is provided from the bus interface through a write buffer to a parity engine . Data is provided from the parity engine through a cache write buffer to the cache interface . Data is provided from the feedback buffer to the parity engine .

Data is provided from the parity engine through a cache write buffer to the cache interface . Data is provided from the feedback buffer to the parity engine .

Data is provided from the bus interface through a write buffer to a parity engine . Data is provided from the parity engine through a cache write buffer to the cache interface . Data is provided from the feedback buffer to the parity engine .

Data is provided from the bus interface through a write buffer to a parity engine . Data is provided from the parity engine through a cache write buffer to the cache interface . Data is provided from the feedback buffer to the parity engine .

Data is provided from the cache read buffers to the bus interface . Data is provided from the cache read buffers to the bus interface .

Data transfer paths are provided between the cache interface and the bus interface and . Similarly data transfer paths are provided between the cache interface and the bus interfaces and . A control logic includes in each of these data path a processing engine that controls data movement between the respective interfaces as well as operations that can be performed on the data as it moves between the interfaces. The control logic is data flow driven as described above 

In one embodiment the bus is a PCI bus the bus is a PCI bus and data transfer commands for the data engine are contained in PCI addresses on the respective buses. is a map of data fields in a 64 bit data transfer instruction to the data engine for use with a 64 bit PCI bus. A cache address is coded in bits . A parity index is coded in bits . An opcode is coded in bits . A block size is coded in bits . A PCI device address is coded in bits . Bits and are unused.

The block size is used to select the extent of a block addressed by the parity index. This is the number of consecutive 16 kilobyte blocks that make up the parity block addressed by the parity index. In one embodiment the block size is three bits interpreted as follows 

In one embodiment the bus interface is a PCI interface and the bus interface is a PCI interface. Each of these PCI interfaces includes a read control to control reads from the caches and . The read control reads data from the respective output buffers and as needed. On completion of a PCI transaction the output buffer is cleared. Each PCI interface also includes a write control to control writes to the input buffers. The write control adds an address word to the start of a data stream and control bits to each word written to the input buffer. In the case where parity is generated and data is saved the write control determines which cache gets the data assigns parity to the other cache that is the cache that does not receive the data and adds control bits to the data stream. Address words are typically identical for the various input buffers but added control bits will be different for each input buffer. For parity generation or regeneration of lost data the data in transit is stored in one of the feedback buffers or . The feedback buffer is cleared on completion of a data stream operation.

As described above each data block written to an input buffer has address and control bits inserted into the data stream. The control bits are as follows 

For operations that include an XOR operation the XOR destination is a parity block in cache e.g. in the cache or the cache . When a parity block is addressed the address is calculated from a combination of the parity index field from the PCI address word the lower bits of the PCI address bus the number depending on the block size and the block size field from the PCI address word. Once the ASIC calculates the parity block address for the first. PCI data word this address is incremented for each subsequent data word.

The parity block address can be generated from the PCI address word using one of two methods. The first method is to concatenate the parity index with the lower bits of the PCI address word. The second method is to sum the parity index with the lower bits of the PCI address word. In either method data is typically aligned to a natural boundary e.g. 16 k blocks to a 16 k boundary 32 k blocks to a 32 k boundary etc. .

The CPU queues network transaction requests to the network interfaces and storage transaction requests to the storage interfaces . In one embodiment the network bus is a memory mapped bus having an address word and one or more data words such as for example a PCI bus and queuing a storage transaction request involves sending an address word and one or more data words to a selected network interface . In one embodiment the address word includes opcode bits and address bits as shown in . The data words provide information to the selected network interface regarding what to do with the data at the specified address e.g. where to send the data and to notify the CPU when the data has been sent . In one embodiment the selected network interface views the data engine e.g. the ASIC as simply a memory to use for retrieving and storing data using addresses in the address word included in the network transaction request. In such an embodiment the network interface does not know that the data engine is interpreting various bits of the address word as opcode bits and that the data engine. is performing operations e.g. parity operations on the data.

The storage interfaces operate with the data engine e.g. the ASIC in a similar manner. The storage interfaces view the data engine as a memory e.g. a simple cache . The storage interfaces communicate with the disks to retrieve data from the disks and write data to the disks. The data engine takes care of assembling parity groups computing parity recovering lost data etc.

 Hiding the parity calculations in the data engine offloads the parity workload from the CPU thereby giving the CPU more time for metadata operations. Moreover using a portion of the memory mapped bus address word allows the CPU to send commands to the data engine again offloading data operations from the CPU . The commands are associated with the data by virtue of being associated with the address of the data . The network interfaces and the storage interfaces which themselves are typically network type interfaces such as Fibre Channel interfaces SCSI interfaces InfiniBand interfaces etc. are unaware of the opcode information buried in the address words. This allows standard off the shelf interfaces to be used.

In one embodiment the CPU keeps track of the data stored in the data caches and thus allowing the server to service many client requests for file data directly from the caches and to the network interfaces without the overhead of disk operations.

Although the foregoing description of the invention has shown described and pointed out novel features of the invention it will be understood that various omissions substitutions and changes in the form of the detail of the apparatus as illustrated as well as the uses thereof may be made by those skilled in the art without departing from the spirit of the present invention. Consequently the scope of the invention should not be limited to the foregoing discussion but should be defined by the appended claims.

