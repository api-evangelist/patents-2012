---

title: Context-aware question answering system
abstract: A question is received to be answered by a question answering (QA) system. The question may be a business intelligence question that is expressed in a natural language. The question is parsed. The parsed question is matched to a pattern from a number of patterns. A technical query associated with the matched pattern is processed to retrieve data relevant to the question from a number of data sources. The QA system generates an answer to the question based on retrieved data. In one aspect, the QA system generates answers based contextual information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08935277&OS=08935277&RS=08935277
owner: SAP SE
number: 08935277
owner_city: Walldorf
owner_country: DE
publication_date: 20120330
---
Information overload is an obstacle in information retrieval systems. Users are faced with the problem of choosing between many possible resources those likely to satisfy their needs. Typical question answering QA systems take as input a question posed in natural language and respond with an automatically generated answer. As opposed to search engines that return a list of documents web pages links images etc. among which the answer is yet to be found QA systems determine a direct answer to the posed question. Conventional open domain QA systems derive the answer from unstructured data e.g. documents text corpus file collections etc.

Business Intelligence BI generally refers to a category of software systems and applications used to improve business enterprise decision making and governance. These software tools provide techniques for analyzing and leveraging enterprise applications and data. Such advanced tools require some technical knowledge on how to formulate queries in order to retrieve relevant data. Typically BI systems are based on structured data such as business domain models. Querying data warehouses requires training technical knowledge and cannot readily be done. To access data managed by BI systems users typically enter technical queries expressed in a specific language e.g. Structured Query Language SQL SPARQL Protocol and RDF Query Language SPARQL Multidimensional eXpressions MDX language and the like. Such technical queries are not natural to non expert users and have to be manually built by the users. Translating an arbitrary BI question expressed in natural language into relevant formal representation that leads to correct answer is not a trivial task.

Embodiments of techniques for context aware QA system are described herein. In the following description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components materials etc. In other instances well known structures materials or operations are not shown or described in detail to avoid obscuring aspects of the invention.

Reference throughout this specification to one embodiment this embodiment and similar phrases means that a particular feature structure or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore the particular features structures or characteristics may be combined in any suitable manner in one or more embodiments.

In one embodiment a QA system based on structured data is implemented. The QA system receives as input a question expressed in natural language and outputs a direct answer to the question. In one embodiment questions may be users queries expressed in natural language e.g. What is the capital of France . A question may be any type of request for information. In one embodiment a question may be a business intelligence BI query. Exemplary simple BI questions are What are the sales in France in 2010 or Which store is best performing . In one embodiment the QA system generates answers to BI queries where the answers to the BI queries are determined based on BI data.

Typically BI tools exploit business data models to enable access to underlying data sources. These models enable users to access data stored in relational databases or Online Analytical Processing OLAP cubes. In one embodiment the QA system is based on a semantic abstraction defined by business domain models. Semantic abstraction is the term for a semantic layer that describes an underlying base data source. A semantic abstraction can be a level of abstraction based on a relational OLAP or other data source or a combination of more than one existing semantic layers.

A universe is a specific form of semantic abstraction. A semantic abstraction includes data model objects and data foundation metadata that describes a connection to structure for and aspects of the underlying data source. A data model object is an object defined within a semantic domain. Data model objects describe the underlying data source and define dimensions attributes and measures that can be applied to the underlying data source. A data model object represents a dimension of the underlying data source represents relationships between dimension members and attributes or provides calculations from based on or designed to be applied to an underlying data source.

Typically in a universe a data model object is assigned a common business term such that the user does not need to understand the specific logic of the underlying data source but can work with familiar terminology when constructing queries or otherwise accessing the data. End users can manipulate objects of these models e.g. measures and dimensions using common business terms such as customer or revenue rather than SQL or MDX queries. Technical queries as SQL or MDX may be automatically generated in response to the manipulation of business terms. Examples of common business terms include customer employee product line revenue profit attrition fiscal year quarter and the like. In one embodiment the QA system is based on BI semantic universe as knowledge representation of data sources based on which the QA system determines answers to posed questions.

A question may be one or more words that form a search term or request for data information or knowledge that represent the answer or based on which the answer is constructed. A question may be expressed in the form of one or more keywords e.g. Sales revenue France . Questions may include various selection criteria and search terms. A Question may be composed of complex linguistic features not only keywords e.g. What is the sales revenue in France in 2008 However keyword based search for answer is also possible. In one embodiment using unrestricted syntax for questions posed by users is enabled. The use of restricted syntax results in variety of expression alternatives for users to better state their needs. Questions that are BI queries may include business entities as search terms. BI entities may refer to any object defined in business data models for example measures and dimensions.

QA system retrieves information from one or more data sources to answer questions posed by users . In one embodiment data sources may include data warehouse data models and document repositories . Data warehouse enables data storage and retrieval. In one embodiment data warehouse may be a storage mechanism that houses a standardized consistent clean and integrated form of data. The data may be sourced from various operational systems. Examples of operational systems from which data may be sourced include but are not limited to customer relationship management CRM enterprise resource planning ERP supply chain management systems SCM and the like. Data stored in in data warehouse may be structured in a way to specifically address reporting and analytic requirements. In one embodiment data warehouse may be a relational database. In one embodiment data sources may include one or more databases such as data warehouse .

In one embodiment data models enable access to data stored in data warehouse . Data models may describe various business entities stored in data warehouse and attributes roles and relationships of the entities. In one embodiment data models may define a semantic abstraction of the underlying data kept in data warehouse . Examples of objects of data models include but are not limited to measures dimensions members of dimensions where a member represents a value of a dimension hierarchies functional dependencies and the like. A dimension object may model a set of business entities of a common nature. A dimension may be a collection of related data members which represents one aspect of a business for example products or sales . Examples of typical dimensions include but are not limited to time product and geography. Dimensions may be organized into a basic parent child hierarchy or a hierarchy of levels e.g. OLAP hierarchies . For example a geography dimension might include levels for continent country state and city. In one aspect a dimension may be an analysis function that provides means of slicing and dicing data in a data warehouse. A function of dimensions is to enable filtering and grouping. Another function is to provide structured labeling of otherwise unsorted numeric measures. In a universe a measure may be a value commonly numerical that is derived from one or more dimensions. A measure may be a business entity that represents a set of values that have the same dimensionality and a common business meaning. Measures are numerical facts that can be aggregated against various dimensions. For instance the measure Revenue may be aggregated on the dimension Country to retrieve the revenue in different countries.

Data warehouse may be queried and explored by business entities defined in data models . In one embodiment data models may define multi dimensional models that describe hierarchies of dimensions and functional dependencies between measures and dimensions. Multi dimensional models may be OLAP cubes. A dimension in an OLAP cube is represented as an axis and measures are calculated within cells of the OLAP cube. An example of technical queries that may be executed over OLAP cubes is MDX. Business entities defined in a multi dimensional model are in functional dependency if one determines the other. For example the dimension City determines the related dimension State . In one embodiment QA system is based on a universe defined by data models . Examples of such universes are SAP BusinessObjects universes.

In some example embodiments data sources may include one or more document repositories . Examples of documents that document repositories may store include but are not limited to reports such as Crystal Reports or OLAP Intelligence Reports Desktop Intelligence Documents and Web Intelligence documents. Other exemplary documents that may be kept in document repositories include but are not limited to analytics dashboards workspaces maps scorecards etc. In a further aspect other documents include but are not limited to Excel Spreadsheets Power Point presentations Rich Text Format Documents Text Files documents in Adobe Portable Document Format etc. In some example embodiments documents kept in document repositories reference business entities such as universes information spaces measures dimensions members of dimensions etc. For example BI reports may be composed of sections that include charts tables text etc. Measures and dimensions may be associated in the same tables or charts. Such relationship between measures and dimensions or other business entities imply a contextual and semantic relationship that may be of analytic interest to users . Another example is dashboards composed of various views or pages where measures and dimensions may be associated in the same view or page.

In some example embodiments client applications include one or more components such as search application and mobile client . Client applications can operate on a variety of devices. Such devices include but are not limited to mobile and handheld devices for example laptops mobile phones personal or enterprise digital assistants and the like personal computers servers or other computer systems that access the services and functionality provided by QA system . For example mobile client may be an application installed on a mobile or other handheld device. Mobile client dispatches query requests to QA system .

Search application dispatches requests for information to QA system . Search application is a client application to QA system . Search application sends requests for answers to QA system . Search application may be installed on a personal computer a server or other computer system. In one embodiment search application includes graphical user interface GUI and session manager . Users may enter questions in GUI . GUI may be a search box or other GUI component the content of which represents a question to be submitted to QA system . Users may authenticate to QA system via session manager . Session manager keeps track of users activity across sessions of interaction with the QA system . Session manager may keep track of what questions are submitted within the lifecycle of a session of one of users . For example session manager may retain a succession of questions posed by a user of users during a session. In one embodiment answers produced by QA system in response to questions of a user of user posed throughout the course of the user s session may also be retained. Information for sessions managed by session manager may be shared between computer systems and devices.

In one embodiment client applications and QA system are communicatively coupled through network e.g. the Internet intranet or other public or private computer network. QA system and client applications may communicate by using Hypertext Transfer Protocol HTTP protocol via Representational State Transfer REST calls. In one embodiment QA system may reside on a server node. Client applications may establish server client communication with QA system or vice versa.

QA system responds to the requests for information sent by client applications e.g. posed questions by users . QA system generates answers to the received questions. In some example embodiments QA system may include question analyzer pattern matcher and answer generator . Question analyzer is a computer module that analyzes the received questions. Question analyzer performs various methods and techniques for analyzing the questions syntactically and semantically. Question analyzer parses received questions. Question analyzer may include various modules to perform analyses of received questions. Examples of computer modules that question analyzer may encompass include but are not limited to tokenizer part of speech POS tagger stemmer focus identification entity recognition semantic relationship identification and syntactic relationship identification .

Tokenizer is a computer module that performs lexical analysis. Tokenizer converts a sequence of characters into a sequence of tokens. Tokens may be string of characters typed by a user and categorized according to rules as a meaningful symbol. Tokenizer identifies words boundaries in an input question and breaks the question or any text into its component parts such as words multiword tokens numbers and punctuation marks. Tokenizer reads in a string of characters identifies the lexemes in the string and categorizes them into tokens.

POS tagger is a computer module that marks up a word in a text to correspond to a particular part of speech. POS tagger reads a question or other text in natural language and assigns a part of speech to each word or other token. POS tagger determines to which part of speech a word corresponds based on the definition of the word and the context of the word. Context of the word may be based on its relationship with adjacent and related words in a phrase sentence question or paragraph. In one embodiment context of a word may be dependent on previously posed one or more questions. Examples of parts of speech that may be assigned to words include but are not limited to nouns verbs adjectives adverbs etc. Examples of other part of speech categories that POS tagger may assign include but are not limited to comparative or superlative adverbs wh adverbs conjunctions determiners negative particles possessive markers prepositions wh pronouns and the like. POS tagger tags or otherwise annotates tokens of a question with part of speech categories. In one embodiment POS tagger tags tokens or words of a question to be parsed by QA system .

Stemmer is a computer module that identifies root stem or base forms of words in a text. In one embodiment stemmer determines stem forms for tokens or words in a question received at QA system . Typically questions posed by users to be parsed by QA system may include morphological variants of words that are derived from the same stem and share an abstract meaning. In one embodiment stemmer annotates words or tokens of received questions with corresponding stem or base form. Users may express their information needs using different variants without being induced to include an exhaustive list of variants of words in order to retrieve accurate answers.

Focus identification is a computer module that detects a category or a type of a question. Based on this determination the question may be assigned an expected answer type EAT of the searched answer. In one embodiment focus identification determines the focus of a question to be parsed by QA system . The focus is a word or sequence of words that define the question and delineate it by indicating what answer the question is looking for. In one embodiment the EAT of the question is the class of the expected answer. For example in question Which store has not sold which product category the focus of the question is the dimension store . In some example embodiments focus identification may determine question type based on parts of the question such as what who how where which and the like. For example questions starting with the wh question word who may have as expected answer type a person. In one embodiment focus identification annotates questions received at QA system with corresponding question focus.

Entity recognition is a computer module that identifies or extracts entities in input text and classifies them according to type. In one embodiment entity recognition detects entities in a query or a question received at QA system and classifies the entities into predefined types or classes. For example Canada may be classified as an entity of type COUNTRY John Paul as an entity of type PERSON and General Motors Corporation as an entity of type ORGANIZATION . Entity recognition may identify entities using predefined set of entities types. In one embodiment entity recognition may also discover new or unseen entities. Examples of entities that entity recognition may identify include but are not limited to names of people companies places cities countries months years currency dates and the like. Entity recognition classifies extracted entities by type and annotates words or tokens of questions received at QA system with corresponding entity type. In one embodiment entity recognition annotates entities position into a question.

In a further aspect entity recognition identifies terms in questions posed by users that are defined in data models . In one embodiment entity recognition identifies business entities in the question corresponding to entities defined in a semantic layer. For example in the following BI question Which store has not sold which product category entity recognition may identify and annotate the business entity store as dimension STORE the entity sold as measure SALES and the entity product category as dimension CATEGORY where the business entities may be defined in one or more universes in data models .

An entity can be referred to in more than one way. For example the United States of America United States America and USA are various ways to refer to the same country. In one embodiment entity recognition detects variations of the same entity. In one embodiment entity recognition may identify entities that are defined in external sources such as WordNet . For example entity recognition may determine that two entities are synonyms hyponyms or the like. Such external sources may group English words into sets of cognitive synonyms each expressing distinct concept.

Semantic relationship identification is a computer module that identifies semantic relationships of recognized entities in questions posed by users to other entities defined in business data models e.g. data models such as a universe. In one embodiment semantic relationship identification may determine functional dependencies between entities the dimension associated to a member and other semantic relationships defined in data models or external sources.

Syntactic relationship identification is a computer module that identifies syntactic relationships in a question composed of tokens posed by users to QA system . Syntactic relationship identification determines the grammatical structure of sentences for example which groups of words are associated as phrases and which word is the subject or object of a verb. In one embodiment syntactic relationship identification conforms to a formal grammar.

Question analyzer is a computer module that parses a received query and generates a corresponding data structure of the query. For example in response to received question at QA system question analyzer outputs the question parsed as a data structure. The parsed question may be represented in the form of a parse tree or other graph structure. In one embodiment the produced parse tree corresponding to the question may be implemented in Resource Description Framework RDF . To generate the parsed question question analyzer may trigger computer modules . Question analyzer can use functionality provided by computer modules individually or in combination. Additionally question analyzer may use external computer systems for dedicated tasks that are part of the question parsing process. Examples of such external systems are WordNet Stanford Parser and SAP BusinessObjects ThingFinder .

In one embodiment question analyzer outputs parsed question and pattern matcher receives the parsed question as input. Pattern matcher may include pattern database and pattern learner . Pattern database includes a set of predefined linguistic patterns. A pattern is a set of rules for recognizing character strings that share common features. Patterns are flexible means for specifying matching and recognizing strings of text. Regular expressions are an example of patterns. Patterns may also include sub patterns. In one embodiment patterns may be developed on demand and pattern database may be expanded. Patterns defined in pattern database may be associated with corresponding technical queries. In one embodiment pattern database may include pairs of patterns and corresponding associated technical queries. In one embodiment a pattern of a question may be associated with predefined templates of technical queries. Once a question to be answered is parsed by question analyzer the parsed question is matched by pattern matcher to a corresponding pattern included in pattern database .

If a question matches a pattern then a technical query associated with the pattern is triggered to query data sources to retrieve the answer. The triggered technical query takes as input tokens or other objects from the posed question. In one embodiment technical queries are instantiated in response to matching a pattern to the user s question and placeholders in the pattern are replaced with corresponding tokens or other objects from the posed question. Patterns associate questions expressed in natural language to structured technical queries. Through patterns users questions are translated in any target technical language e.g. SQL MDX and the like . In one embodiment patterns may be implemented in SPARQL. Information to be matched in pattern may be represented in RDF for example the parsed question may be represented in RDF.

Answer generator is a computer module that generates answers to posed questions. Examples of answers generated by answer generator may include but are not limited to answers in the form of natural language sentences reports charts or other analytic representation raw data web pages and the like.

In some example embodiments answer generator may include query processor visualization processor and feedback handler . When a pattern and a parsed question are matched a technical query associated with the pattern is executed by query processor . Based on retrieved data by a technical query executed by query processor visualization processor renders visualization of the retrieved data where the visualization represents the answer. Visualization processor may render various analytics to represent the answer including but not limited to charts tables dashboards maps and the like. In one embodiment visualization processor may be SAP BusinessObjects Common Visual Object Modeler CVOM . Another example is SAP BusinessObjects Exploration Views providing dashboard and exploration capabilities of BI data. Visualization processor presents the answer to the user in understandable form.

Feedback handler is a computer module that processes feedback from users on answers generated by answer generator . In one embodiment users may be engaged in dialog with the QA system to evaluate the relevance of received answers. Answer generator may produce a list of answers corresponding to a question submitted by a user of users . The user may rank each answer according to its relevance to the question. In one embodiment the feedback of users on generated answers may be used for pattern learning.

In one embodiment pattern matcher may also include pattern learner . Pattern learner is a computer module that learns to match random input questions to corresponding one or more patterns or sub patterns. Pattern learner may utilize explicit feedback as well as implicit feedback from users to improve pattern matching.

In one embodiment QA system may use external computer systems for dedicated tasks that are part of the question answering processes. Also QA system may retrieve data from external data sources. Examples of external source systems include but are not limited to Lightweight Directory Access Protocol LDAP directories operational systems BI systems social networks etc.

At the query is parsed. In one embodiment methods and techniques for analyzing queries semantically and syntactically may be implemented. For example various modules such as tokenizer POS tagger stemmer focus identification entity recognition semantic relationship identifier and syntactic relationship identifier may perform analyses of received queries. In one embodiment business entities are identified in the query where the business entities correspond to entities defined in a semantic layer or other ontologies representing data sources e.g. data models in .

At as a result of parsing the query a corresponding data structure that corresponds to the parsed query is generated. The parsed query may be represented as a tree structure such as a parse tree. In one embodiment the parse tree is a labeled tree graph. The parsed question may represent syntactic and semantic analysis of the received question. For example nodes of the tree may represent various tokens or business entities for example measures dimensions attributes members of measures and the like. Edges of the tree represent relations between the entities. In one embodiment the generated tree structure may be implemented in RDF. The RDF tree may represent entities identified in the received question and relations between these entities in the form RDF triples. Examples of relations between entities include but are not limited to a member of relationship representing that one node is a member of another node that is a dimension belongs to representing that one node is an attribute that belongs to another node that is a dimension has annotation representing that one node is annotated syntactically or semantically and the like. In one aspect nodes of the tree may also correspond to patterns for capturing linguistic features. Examples of linguistic features that may be captured by such patterns include but are not limited to the negation not a range indicated by the word between a selection criteria all or my and the like.

At the parsed query is matched to a pattern from a number of patterns. To translate the received BI query to a machine readable query e.g. a technical query the parsed query is matched to patterns such as patterns kept in pattern database in . Through patterns arbitrary BI questions expressed in natural language are translated into relevant formal representation that leads to correct answer. Questions in general and in particular BI queries may exhibit and involve various features. A pattern specifies features of the questions. Examples of features represented in patterns may include but are not limited to tokens wh question words parts of speech lemmas business entities or objects and semantic relationships. From another perspective a feature may also be the succession of tokens within the question. In one embodiment a lemma feature may represent the verb to be e.g. LEMMA be . To illustrate the exemplary question Which store has not sold which product category include as features the subject that is the EAT expression which store where the EAT is the dimension store then a negation not follows the measure sales identified from the token sold represents the predicate in the question and the dimension category represents the object in the question. The exemplary question may be matched to a pattern with the following exemplary structure 

In the above exemplary pattern structure MEA stands for a measure and DIM stands for a dimension. Patterns may specify various constraints to be matched by concrete questions. Another exemplary BI question is What is the revenue in Germany The exemplary question may be matched by the following pattern 

Syntax of Pattern 1 is adopted for illustrative purposes. Technically patterns may be implemented in various programming languages and scripts including SPARQL. In Pattern 1 WHQ represents a wh question word such as what LEMMA be represents the verb to be such as is REL WHQ LEMMA be represents relationship between two tokens for example that the wh word and the verb to be are in succession SL MEA represents an entity defined in the semantic layer SL where the entity is a measure such as revenue TOKEN in represent a token that is the preposition in SL MEM represents an entity defined in the semantic layer SL where the entity is a member such as Germany .

In one aspect a pattern may be divided logically into three abstract levels the token layer representing identified tokens and parts of speech the syntactic layer representing structure of the sentence including corresponding succession or order of tokens and the semantic layer representing entities and relationships between entities defined in the corresponding ontology. Table 2 below illustrates the logical structure of an exemplary pattern.

In one embodiment a pattern may include one or more sub patterns. For example when exact matching of the input question to a pattern is not possible partial matching of patterns is invoked. Partial matching of patterns involve matching sub patterns that are part of defined patterns and producing technical queries that correspond to the longest matched sub pattern. Sub patterns are patterns within patterns. Thus a pattern can refer to already defined patterns. For example in Pattern 1 it may be desirable that REL WHQ LEMMA be is represented as distinct sub pattern since numerous questions may contain that structure for example the sub pattern may be defined as PATTERN wh be . Another sub pattern of Pattern 1 that may be defined is PATTERN in filter that represents a filter expression such as in Germany . In one embodiment a pattern may involve nested sub patterns. Sub patterns allow for partial matching of questions. Pattern 2 below represents Pattern 1 with defined sub patterns 

An entity can be referred to in more than one way. For example the United States of America United States America US and USA are various ways to refer to the same country. In one embodiment patterns may represent different feature types for the same one or more tokens in questions. For example an ontology representing geographic data may include the following triples 

A pattern may describe on one hand that US is a token in an input question such as What is the revenue in US and on the other hand that it is hyponym of both Country and Place as defined in the ontology. In one embodiment in a pattern a reference can be made to the same token and different features may be assigned to the token. In Table 2 a reference is represented by the symbol followed by the number of reference e.g. 1 .

At a technical query is triggered where the technical query is associated with the pattern that matches the received query. For example the received query may be the exemplary question What is the global revenue in Tokyo . This exemplary question may be matched by Pattern 1 . Template 1 below represents an exemplary template of technical query that may be associated with Pattern 1 

In Template 1 MEA 1 indicates the first reference to a measure in the associated Pattern 1 . Further MEA 1 captures all measures identified in Pattern 1 . The dim of function returns the dimension that is associated to a member as defined in data models e.g. data models in . At the technical query is processed to retrieve data relevant to the query. The triggered technical query is processed by replacing placeholders with corresponding tokens or other objects from the received query. Technical templates and respectively technical queries are defined to as a combination of one or more constraints such as projections filters sorting criteria clauses truncation clauses and the like. In one embodiment Template 1 may be translated in the following technical Query 1 where the technical Query 1 represents the received query 

In technical Query 1 entities Revenue and Tokyo from the input question are replaced in Template 1 to retrieve relevant to the query data. At based on the retrieved data an answer to the received query is generated. For example Table 3 below represents an exemplary dataset generated in response to executing the technical Query 1 .

Usually the context of a user changes during user s interactions with systems and applications. Context may refer to any information that may be used to characterize the situation of an entity e.g. location identity activity time information etc. An entity may be anything considered relevant to the interaction between a user and an application including but not limited to time place person the user and the application themselves etc. A situation may be a collection of states of entities relevant to an interaction between the user and the computer system environment.

Typically changes of a user s context results in changes in the user s needs for information and vice versa the user s needs may also affect the user s context. The precision and relevancy of an answer to a user s query may also depend on the current user s context or situation. In one embodiment the QA system enables direct and accurate answers by utilizing contextual information into the answering process. In one embodiment the QA system may dynamically adapt to current user s actions and enable context aware answers. The QA system generates answers to BI queries that are adapted to the user s context or situation. In one embodiment a QA system may be integrated to a situational recommender system to enable context aware recommendation of answers to users questions.

A situational system may be defined as a system that based on a user s situation provides relevant resources to the user. In one embodiment a situation may be implemented as a collection of situation statements. A situation statement describes a relation between at least two resources. Situation statements may be expressed as one or more tuples representing assertions. Each assertion may be formed by a subject S a predicate P and an object O S P O . For example in the statement Maggie reading document 1 Maggie is the subject S document 1 is the object O and reading is the predicate P . The predicate P qualifies the relation between S and O and defines its semantics. In one embodiment situation tuples S P O may be extended to include additional metadata M e.g. specifying temporal restrictions privacy settings level of confidence accuracy etc. In such a case a situation statement may be expressed by one or more tuples S P O M where

In this equation t is a timestamp indicating when the situation statement was generated l is expected lifetime or validity period of the situation statement s is an ownership and privacy setting indicating who owns the situation statement and whether it is public private or has custom access authorizations origin indicates which system or user has created the situation statement and c shows the level of confidence or other type of ranking indicating the level of accuracy quality completeness or reliability of the situation. In one embodiment other types of metadata may be integrated to situation tuples including another related tuple.

Recommender system is connected to client s via network and includes situation management platform graph management platform and model factory . Model factory includes data sources for the recommender system . Model factory may encompass data sources including but not limited to XML files RDF files Ontology Web language OWL files SQL database or memory . Data sources of model factory such as XML RDF OWL SQL and memory store raw data of available resources. The model factory enables storage and retrieval of a number of available heterogeneous resources. In one embodiment data sources of model factory may be distributed across one or more source systems that are either internal or external to recommender system or both. These systems may communicate over public or corporate networks e.g. network . Examples of source systems include but are not limited to a Lightweight Directory Access Protocol LDAP a CRM system BI platform social network etc.

In one embodiment the data sources included in model factory are communicatively coupled to graph management platform . The graph management platform describes the heterogeneous resources available at data sources available in model factory . Further the graph management platform describes existing relations between the resources e.g. in a graph based data model to enable uniform data representation.

Graph management platform includes providers and graph repository . Providers are added to graph management platform to connect to one or more corresponding data sources available in model factory . In one embodiment each provider is customized to communicate with respective data source included in model factory . For example a BI provider may be customized to communicate with a BI platform or a social provider to connect to LDAP.

Providers may specify how to access and retrieve data from the corresponding data sources accessible through model factory . For example a data source may be a BI data warehouse such as SQL database and a provider from providers may specify logic to query or modify data in the BI data warehouse using SQL requests. Similarly a provider from providers may be modeled to query RDF files using SPARQL language. SPARQL is used to extract information from RDF files RDF Site Summary RSS and the like.

In one embodiment providers connect graph repository to data sources such as data sources . As illustrated exemplary graph repository may include graph model and graphs . In one embodiment graph model is a general model of resources available through model factory . The graph model may include nodes corresponding to or describing resources and edges to represent relationships between the resources. In one embodiment graph model may be implemented as a base schema using Resource Description Framework Schema RDFS language. Building and maintaining a complete graph of available resources may be inefficient or infeasible e.g. due to performance reasons computational costs technical limitations and the like. Additional graphs such as graphs may be added to graph repository on a per need basis by extending graph model .

In one embodiment graph model serves as a base model that may be further extended by providers . Each provider may register at graph repository to retrieve and extend graph model with specific nodes and relations defining corresponding graphs . Each provider may connect to a corresponding data source from model factory to retrieve available resources provided by the respective data sources . Providers may populate the retrieved resources to their corresponding graphs . For example a BI provider may populate and extend graph model to describe measures and dimensions of a business domain and their mutual dependencies.

In one embodiment each graph is built based on graph model by at least one corresponding provider from providers . Graphs may be implemented as extended schemas of the schema of graph model . Graphs may further include specific nodes and edges defined in accordance with respective data sources . In one embodiment each graph is specific to a particular data source available in model factory and is built upon graph model to model and represent resources provided by the corresponding data source.

The nodes and edges of graphs may represent resources and relations between these resources accordingly. In one embodiment one or more nodes and edges of graphs correspond to resources provided in model factory that are identified by URIs. The complete graph of graph repository is defined by merging the schema of graph model with extended schemas of graphs that are built by their respective providers . Therefore graph repository may be described as an aggregation of several partial graphs .

In one embodiment graph management platform maintains graph models to enable uniform representation of heterogeneous data resources and relations between the data resources available in model factory . Furthermore model factory may be extended by adding new data sources. Based on these new data sources new providers may be built and added to graph management platform to retrieve data resources available through the new data sources.

Situation management platform manages users situations occurring during the interactions between client s and recommender system . Client s may be one or more entities including users and client applications operable to generate events dispatched to recommender system via network . An event may refer to an interaction between at least two data resources and may be described as a specific type of situation statement where the interaction is represented by the relation between the resources. For example interactions between users and other available resources such as Maggie reading document1 John has meeting with Maggie etc. define corresponding events. In one embodiment events may be time dependent situation statements that are valid for a given period of time as opposite to other situation statements that describe static relations between resources. An event may be either external to recommender system e.g. dispatched to recommender system by client s or internally raised within recommender system .

Situation management platform includes event handler operators manager and situations manager . Situation management platform receives events to be processed. In one embodiment the processing of an event may result in long running operations. Therefore event handler adds the received events to queue to be prioritized and processed asynchronously.

Situations manager monitors situations of entities that are relevant to events received or generated at recommender system . In one embodiment a situation is collection of related situation statements or tuples. Situation graphs represent monitored situations in the form of a graph. A situation graph can be defined as a collection of valid situation statements that are represented in the form of a graph. In one embodiment a situation graph represents a user s situation at a certain point in time. In one embodiment the collection of situation statements or tuples that constitute a situation are arranged in situation graphs. For example the subject S and the object O of a tuple may be represented as nodes and the predicate P may be represented as an edge between the nodes of P and O .

In one embodiment as an event is dispatched to or otherwise detected by recommender system situation manager starts to monitor situations impacted by the event. Initially impacted situations may be situations of the subject S and or the object O . For example in one embodiment once a user authenticates to recommender system situations manager retrieves a list of relevant to the user situation statements where these situation statements constitute the user s current situation graph. Thus the user s situation is loaded to situations manager . When recommender system starts to monitor the situation of a user or an agent e.g. when an event concerning this user or agent occurs the agent s situation graph is initialized based on previously stored situations that are still valid. An agent is a resource present in the recommender system that may generate a situation statement. In one embodiment the origin attribute of a situation statement indicates the agent that has created the statement. Examples of agents include but are not limited to providers users client applications operators designed to perform various operations on situations e.g. updating situations in response to events etc. In one embodiment situation manager keeps graphs of monitored situations such as situation graphs in a cache. In yet another embodiment situation manager initialize situation graphs on a per need basis from situation statements retained in graph repository . Situation graphs may be retrieved at situation manager by querying graph repository .

Activation rules are designed to react to specific events and if certain conditions are met to trigger additional processing in response to the events. One or more particular rules from activation rules may be tailored to react to one or more specific events or event types. For example one rule may be specified to react to events of type a user is interacting with unstructured document . In one embodiment a rule may be defined that reacts to receiving of questions posed to the QA system.

Operators available in operators manager are used to manipulate situations by adding deleting or updating situation statements or tuples. Operators from operators manager may define any operation that may be applied on graphs from graph repository or situations graphs monitored in situation manager . An operator is a module that takes as input an event and a situation and returns the situation updated to reflect the event and or information that is generated as a result of the operator s processing. Operators may be used to maintain and perform operations on situation graphs. For example operators may add delete or update nodes and or edges of situations graphs. In one embodiment operators may assign values to blank nodes of graph models available in graph repository based on received events.

Recommendation operator is a specific kind of operator. A recommendation operator may add a recommendation situation statement to a situation graph managed by situations manager . For example a recommendation statement may be Recommender 1 recommend productX . In one embodiment based on added recommendation statements by recommendation operators relevant resources are suggested to users. Recommendations may be represented via a recommend predicate. In one embodiment to integrate a QA system to the recommender system a QA operator may be developed. Answers to questions may be represented as recommendations generated by the QA operator. For example the QA operator may add statements such as QA recommend answer1 . In one embodiment the QA system may be represented as a combination of one or more operators. For example one operator may be a question analyzer e.g. question analyzer in that parses questions expressed in a natural language. Another operator may be a pattern matcher e.g. pattern matcher in that matches the parsed question to corresponding pattern to translate a natural language question to technical query. Additional operator may also be an answer generator e.g. answer generator in that processes the technical query and generates an answer to the question. From another perspective other types of operators include but are not limited to stemming operator that may reduce words of unstructured documents to their roots so that different grammatical forms of the same words are identified expiry checker to determine outdated situation statements and to remove them from situation graphs consistency checker to resolve conflicting situation statements to ensure coherent context NER operator and the like.

Once an event from queue conforms to conditions of at least one activation rule from activation rules it is further determined what operator available in operators manager applies in response to the interpretation of the event. More than one activation rules from activation rules may be used to trigger the same operator under different conditions. Thus reusability of operators already developed is possible.

Recommender system exposes methods to client s to enable interaction of client s with the recommender system . Examples of such methods include but are not limited to authentication situation retrieval and event posting. In some example embodiments such methods may be implemented as REST services. For example a user may authenticate to recommender system via a GET method such as a method auth . This method may take as input users login and password information and return as output a token that corresponds to users sessions. This token may be required by further requests for interaction with the recommender system . Thus recommender system conforms to data security and role based access to heterogeneous resources provided by various source systems that impose respective security controls.

Once a user is authenticated client s may retrieve the user s situation via a GET method such as a method situation . This method may take the token as parameter and return a list of statements that constitute the user s situation. In one embodiment additional parameters may be used to filter retrieved statements to avoid unnecessary information retrieval. Another method exposed by recommender system may be posting of events. For example client s send events to recommender system via POST method such as a method event . The POST method may represent the event in RDF where the representation may conform to graph model .

Various predicates may be defined to represent semantics of data sources as well as users situations and context information. In one embodiment predicates that represent users preferences may be defined. Predicates that may represent users preference include but are not limited to prefers likes doesNotLike and the like. Users preferences are represented as preference situation statements via preference predicates. In one embodiment preferences may be explicitly generated by a user for example the user may rank recommendations or other resources. A user may also rank generated answers to questions. In one embodiment ranked statements of recommended answers are added to the situation management platform as situation statements with corresponding level of confidence attributed to the statements. In another embodiment preferences may be derived by analyzing users activities and history data. Derived preferences may have lower level of confidence than explicit preferences.

In one embodiment predicates that represent geographic and time contextual information are defined. Predicates that represent geographic and time information include but are not limited to hasLocation is Near predicated that represents relative information and the like. For example the hasLocation predicate can be used to describe the user s location in statements like Maggie hasLocation 46.217 6.561 or Maggie hasLocation India . The object O of such statements if a node of type Geography . Geographical nodes of different types may be used to describe geography information at different granularity levels e.g. country region city etc. . Geographic and time contextual information is represented as statements with such predicates.

Time information is represented as metadata associated with each situation statement. Generated statements are kept in graph repository and may represent context history information. Their associated time related attributes enable reconstruction of user s situation graph. Context history information may be retrieved from graph repository by querying it. A user s situation graph may be reconstructed for a specific period of time. Recommender system maintains a current situation graph of users situation to represent currently relevant contextual data. In one embodiment a QA system e.g. QA system in may analyze a question and generate an answer to the question based on contextual information such as previous questions.

One or more recommendations may be provided to an agent in response to an event where the recommendations are based on the agent s situation. Thus recommendations are adapted to users needs based on their context and situation. illustrates process for recommending a resource to an agent in response to an event according to one embodiment. The process starts at with receiving an event. The event represents an interaction between an agent and a resource. In one embodiment an event may be externally triggered e.g. sent to recommender system by client s in . An example of externally triggered event is Maggie reading document1 . In this example Maggie is an agent that is an external user and document1 is a resource. Another example of externally triggered event may be entered question by a user. In yet another embodiment an event may be internally triggered e.g. by internal agents of recommender system . An example of internally triggered event is OperatorX has processed document1 . Accordingly OperatorX is an internal agent program and document 1 is a resource. In one embodiment events may be described in RDF format.

At at least one impacted situation is determined based on the event. Generally situations of the subject S and the object O of the event situation statement are impacted if they are agents e.g. the user agent Maggie in the above described example. At at least one applicable activation rule is determined based on the event. In one embodiment one or more of available activation rules such as activation rules in are evaluated to determine their applicability to the event. An activation rule acts in response to specific events and triggers additional processing if a set of conditions specified by the rule are met. In one embodiment the structure of an activation rule may consist of an event a condition and an action part. The event part of activation rules is used to filter events to which the activation rule reacts and thus trigger additional processing. Thus event parts of available activation rules are evaluated to determine those rules responding to the received event. In one embodiment activation rules may be implemented in RDF.

At conditions specified by the at least one applicable activation rule are evaluated. Thus the condition part of the event is evaluated. For example such condition is operatorB can be applied if operatorA has processed document1 . Other exemplar conditions are used as execution guards to prevent multiple executions of the same operator in the same situation. Examples of execution guards include but are not limited to NOT operatorA hasProcessed document1 EXISTS opA hasProcessed document1 and the like. In one embodiment conditions may be evaluated by querying graph repository in . For example one or more of providers may translate the condition part of an activation rule from RDF format to a SPARQL query to be executed over respective graphs in graph repository or over respective situation graph .

At one or more applicable operators relevant to the event are determined based on the evaluation of the at least one activation rule. At an operator from the determined one or more operators is applied on the current situation graph of the at least one impacted situation if the conditions specified by the applicable rule are met. At the current situation graph of the at least one impacted situation is updated. In one embodiment as a result of processed operators the updated situation graph may connect to situation graphs of other impacted agents. For example a first user may comment on a document initially created by a second user. Thus situation graphs of the first and the second user may connect in response to the event and the subsequently processed operators.

At based on the updated situation graph of the at least one impacted situation another resource is recommended to the agent. For example the situation graph of the agent may be augmented with the situation statement document2 is recommended to Maggie . In one embodiment a link to the recommended document2 may pop up. Thus based on the situation of a user or other agent personalized recommendation are enabled and adapted to dynamic behavior of the respective user or other agent. If there are more than one impacted situations the steps of process are performed for each impacted situation.

In one embodiment the at least one operator is a module that takes the event and the at least one impacted situation as input and in response to the event outputs an updated impacted situation. A situation may be updated by adding updating or deleting situation statements. In one embodiment the situation graph may be augmented or updated by adding situation statements representing an event such as Maggie reading document1 . In one embodiment additional situation statements may be added to the situation graph in response to the processing of operations defined by the at least one operator e.g. statements generated in response to the execution of a NER operator applied on an unstructured document. In one embodiment operators may perform specific tasks or operations independently or operators may be mutually dependent e.g. an operator may be activated only if another operator has been already processed.

In one embodiment a QA operator may be triggered in response to receiving a question posed by a user. The QA operator may invoke a QA system such as QA system in to generate an answer to the question. Answers to questions may be generated as recommendations. Furthermore based on a situational recommender system such as recommender system in answers to questions may be recommended relevant to the users situations and context.

Services and functionality provided by a QA system may be invoked by various clients that may be laptops mobile devices personal computers servers or other computer systems. Based on the situational management platform users situations may be shared between more than one computer systems and devices. Therefore a user may switch between different devices without losing context history. For example a user may enter follow up questions from more than one device and it may refer to previously asked questions.

In one embodiment answers to users questions may be based on contextual information and users situations. Examples of such contextual information include but are not limited to a user s social network role in an organization current location previous questions and the like. Context information helps resolving ambiguities in posed questions. In one embodiment time and geography contextual information may be used to resolve ambiguities. For example if the question posed is What are the global sales revenue this year the QA system resolves the ambiguity to which year the user refers to based on time contextual information. The explicit marker this may signal that context resolution of the question is required. Another kind of questions that may exhibit ambiguities may lack explicit marker such as What about my sales revenue . The QA system may determine based on contextual information that the intent of the user is to pose the question What about my sales revenue in 2010 in Paris France Another example of ambiguous questions may be questions comprising ambiguous markers e.g. in the question What about my recent sales revenue the marker recent is ambiguous. The QA system may determine how to interpret the recent sales based on context data.

In one embodiment context information may include previously posed questions. A user may add a follow up question to previously posed questions. The follow up question makes reference to the previously posed questions. To illustrate a user may pose the question What is the revenue in France and then the user may enter a follow up question such as And in US to add additional filter to the previously posed question. As part of user s situation posed questions may be retained. A QA system may analyze a question and generate an answer to the question based on previously posed questions.

In one embodiment co references may occur in a question. A co reference occurs when multiple expressions in a question refer to the same entity or object. An expression is co reference to another expression if they share the same referent. Ambiguities involving co references could be resolved based on user s situation and contextual information.

In one embodiment query tree may be generated by one or more of computer modules in . Query tree may be implemented in Resource Description Framework RDF . Pattern represents an exemplary pattern that may be associated to query tree . Pattern may include a combination of one or more constraints such as projections filters sorting criteria clauses truncation clauses and the like. In one embodiment pattern may be implemented in SPARQL.

Some embodiments of the invention may include the above described methods being written as one or more software components. These components and the functionality associated with each may be used by client server distributed or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as functional declarative procedural object oriented lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively the components maybe implemented in server and client applications. Further these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level e.g. a graphical user interface . These first and second computer systems can be configured in a server client peer to peer or some other configuration. The clients can vary in complexity from mobile and handheld devices to thin clients and on to thick clients or even other servers.

The above illustrated software components are tangibly stored on a computer readable storage medium as instructions. The term computer readable storage medium should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term computer readable storage medium should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store encode or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described represented or illustrated herein. Examples of computer readable storage media include but are not limited to magnetic media such as hard disks floppy disks and magnetic tape optical media such as CD ROMs DVDs and holographic devices magneto optical media and hardware devices that are specially configured to store and execute such as application specific integrated circuits ASICs programmable logic devices PLDs and ROM and RAM devices. Examples of computer readable instructions include machine code such as produced by a compiler and files containing higher level code that are executed by a computer using an interpreter. For example an embodiment of the invention may be implemented using Java C or other object oriented programming language and development tools. Another embodiment of the invention may be implemented in hard wired circuitry in place of or in combination with machine readable software instructions.

A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases such as relational transactional hierarchical multi dimensional e.g. OLAP object oriented databases and the like. Further data sources include tabular data e.g. spreadsheets delimited text files data tagged with a markup language e.g. XML data transactional data unstructured data e.g. text files screen scrapings hierarchical data e.g. data in a file system XML data files a plurality of reports and any other data source accessible through an established protocol such as Open DataBase Connectivity ODBC produced by an underlying software system e.g. ERP system and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams broadcast data and the like. These data sources can include associated data foundations semantic layers management systems security systems and so on.

In the above description numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize however that the invention can be practiced without one or more of the specific details or with other methods components techniques etc. In other instances well known operations or structures are not shown or described in details to avoid obscuring aspects of the invention.

Although the processes illustrated and described herein include series of steps it will be appreciated that the different embodiments of the present invention are not limited by the illustrated ordering of steps as some steps may occur in different orders some concurrently with other steps apart from that shown and described herein. In addition not all illustrated steps may be required to implement a methodology in accordance with the present invention. Moreover it will be appreciated that the processes may be implemented in association with the apparatus and systems illustrated and described herein as well as in association with other systems not illustrated.

The above descriptions and illustrations of embodiments of the invention including what is described in the Abstract is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of and examples for the invention are described herein for illustrative purposes various equivalent modifications are possible within the scope of the invention as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather the scope of the invention is to be determined by the following claims which are to be interpreted in accordance with established doctrines of claim construction.

