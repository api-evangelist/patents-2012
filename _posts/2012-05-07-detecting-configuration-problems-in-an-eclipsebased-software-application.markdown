---

title: Detecting configuration problems in an eclipse-based software application
abstract: Detecting configuration problems in an ECLIPSE-based software application can be detected. Such a method can begin with the receipt of a user-command to test a configuration of an ECLIPSE-based software application or with a detection of a feature addition/update when an auto-testing feature is enabled. Information about the available sites for the ECLIPSE-based application can then be obtained. Then, a list of software elements required to operate the ECLIPSE-based software application can be compiled. At least one data attribute can be extracted from the meta data of each software element in the compiled list. The extracted data attributes can then be analyzed. When the analysis identifies a configuration problem, the existence of the configuration problem can be validated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08627289&OS=08627289&RS=08627289
owner: International Business Machines Corporation
number: 08627289
owner_city: Armonk
owner_country: US
publication_date: 20120507
---
This application is a continuation of U.S. patent application Ser. No. 12 018 684 filed Jan. 23 2008 pending which is incorporated herein in its entirety.

ECLIPSE is an open source software framework based on the Rich Client Platform RCP that utilizes discrete elements called plug ins to extend its capabilities. ECLIPSE is often used as a software integrated development environment IDE used in the development of ECLIPSE based applications. An ECLIPSE based application therefore consists of a myriad of plug ins that provides the application s functionality. Plug ins are grouped with elements that handle input output language translation called fragments to comprise a feature . Every feature contained in the ECLIPSE based application must be available and properly versioned in order for the application to function properly. Missing corrupted or improperly versioned features perpetrate a multitude of configuration errors within the application.

Further elements called feature patches are used to update the existing features of an application similar to the patching process of non ECLIPSE based software applications. Feature patches must also adhere to the same rules of versioning availability and dependencies in order to properly update their corresponding feature. The failure of a feature patch to properly install typically goes unnoticed by a user and simply causes additional application errors due to the improper configuration.

While there are a variety of tools available that test the software code of plug ins for functionality there is currently a lack of an automated tool that detects configuration problems between the various features and feature patches that comprise an ECLIPSE based application. The ECLIPSE framework does not contain an inherent utility feature that addresses this issue. Therefore the only option available at present is to manually verify every feature and feature patch of an ECLIPSE based application. For a small application this is an adequate solution. However most ECLIPSE based applications consist of hundreds or thousands of features and feature patches which render a manual process inefficient time consuming and excessively costly. This large quantity of features and feature patches also makes it impossible to address this issue within the formal testing cycle of the software application.

What is needed is an automated solution that detects configuration problems in an ECLIPSE based software application. That is the solution would automatically analyze all the features and feature patches of an ECLIPSE based application to determine the existence of configuration errors and or concerns. Ideally such a solution would provide a report of any identified configuration problems with recommended resolutions.

The present invention can be implemented in accordance with numerous aspects consistent with material presented herein. For example one aspect of the present invention can include software conforming to an ECLIPSE framework for configuration testing of features and feature updates. The software can be configured to analyze a set of features and feature patches of an ECLIPSE based application to determine an existence of configuration problems if any and to report determined configuration problems. The software can be implemented as a set of programmatic instructions digitally encoded in a machine readable media and executable by at least one computing device.

Another aspect of the present invention can include an automated method for detecting configuration problems in an ECLIPSE based software application. Such a method can begin with the receipt of a user command to test a configuration of an ECLIPSE based software application or with a detection of a feature addition update when an auto testing feature is enabled. Information about the available sites for the ECLIPSE based application can then be obtained. Then a list of software elements required to operate the ECLIPSE based software application can be compiled. At least one data attribute can be extracted from the meta data of each software element in the compiled list. The extracted data attributes can then be analyzed. When the analysis identifies a configuration problem the existence of the configuration problem can be validated.

Still another aspect of the present invention can include an automated system that detects configuration problems of an ECLIPSE based software application. Such a system can include an ECLIPSE based software application and a configuration test utility. The ECLIPSE based software application can be configured to operate in an ECLIPSE framework and consist of multiple software elements. Each software element can include metadata defining operational data. The configuration test utility can be configured to determine the existence of configuration problems between the software elements of the ECLIPSE based software application. The configuration test utility can produce a test report containing determined configuration problems.

Embodiments of the present invention disclose an automated solution that detects configuration problems in an ECLIPSE based software application. The automated solution can include a configuration test utility to detect configuration problems between the various software elements of the ECLIPSE based software application. The configuration test utility can interface directly with the software elements of the ECLIPSE based software application using an Application Programming Interface API . A test report can be generated that details detected configuration problems and recommend solutions for the problems.

Each plug in fragment feature and patch in the ECLIPSE framework can be associated with a manifest . An associated plug in fragment feature and patch must have a valid manifest in order for it to be integrated with the ECLIPSE based application of framework . A feature or patch with an invalid corrupted or that lacks a manifest will neither install nor resolve. When a plug in or fragment is not properly installed it will provide no functionality to the application even if the particular bundle was physically present in the build. Although it can be extremely important to identify such features and patches during software deployment and quality assurance phases of a software cycle conventional systems provide little assistance in this regard.

Hence an introduction of the configuration test utility into framework . The utility can detect any number of possible configuration errors occurring when attempting to install update a feature or feature patch . These errors can include but are not limited to manifest errors versioning errors incompatible platform filters unavailable required dependencies unavailable optional dependencies absence of parent features non standard application of feature patches unavailable branding plug ins and the like. Each of these errors can be categorized and presented in a configuration test report . Manifest errors refer to a lack of a required manifest and or or an error that causes one of the manifest and or to be unable to be read by the framework . The other errors shall be elaborated upon in turn.

In one embodiment the configuration test utility can be part of the framework externally implemented from the application which is able to interact through an ECLIPSE API . For example the utility can be part of a software development application. Developers can be provided with a user interface through which they can configure the utility execute functions of the utility and view print generated reports . Configuration options for the utility are many which can include testing for only a subset of possible configuration errors adding new developer defined configuration error tests to be executed by the utility adding customized reports utilizing SQL queries to view manipulate configuration data produced by the utility and the like.

The invention is not limited to being implemented as an external developer utility. In one contemplated embodiment for example the utility can be a component of the application itself which automatically tests for configuration issues when a feature or feature patch is applied to the application . The test utility can for example execute in a hidden fashion when new features or patches are applied unless configuration errors are detected in which case the application of the features patches can be aborted and a report and or notification of the errors can be presented.

Additionally the utility can be implemented as a feature where various testing rules used to generate the reports are able to be added and modified as individual plug ins of the feature . This permits functionality of the configuration test utility to evolve and to be adapted to handle new configuration issues and to be adjusted for new ECLIPSE framework standards as they emerge.

Regardless implementation specifics the utility can detect a variety of different configuration problems which are detailed in generated reports . An overview of various ones of these reportable errors is now provided which emphases a magnitude of issues relating to ECLIPSE framework configuration and which emphasis a need for and a value inherent in the configuration test utility . In detailing the various errors error causes are identified. Each of these causes is detectable by the utility using a set of programmatically implemented error detection rules.

Versioning errors occur when a feature or patch fails to comply with ECLIPSE Versioning Conventions. These conventions mandate that the version of a feature or patch be placed in the form major.minor.service.qualifier. The major the minor and the service identifiers must be numerals. The qualifier on the other hand may contain numerals or strings at the developer s convenience. In addition the version must not contain extra identifiers than the allowed options. The version of a feature or patch will be reset to as 0.0.0 by the ECLIPSE framework at the time the bundle is being resolved if the version violates these standards. A set of versioning rules can be included in the test utility which check to ensure that the ECLIPSE Versioning Conventions are followed. When violations to these conventions occur explicit violation messages and suggestions to resolve these versioning problems can be included in the test report . The rules utilized by the utility can be updated changed as corresponding ECLIPSE Versioning Conventions are altered.

Experience has shown that the software developers especially ones new to ECLIPSE sometimes fail to follow the versioning conventions. As a result the features and patches delivered by such individuals occasionally fail to install or even resolve in the application even though such bundles are physically present in the build.

The following example illustrates how important is it identify when features and patches violate the ECLIPSE Versioning Convection. These violations can have many side effects when installation attempts are made which cause an application to behave in an unpredictable fashion. The utility can prevent problems related to the following example in an efficient and straight forward fashion. In contrast a traditional approach has been to manually detect such issues which can be nearly impossible when an application is composed of a large number of features and patches .

To illustrate assume that a Feature F1 Version 1.0.0 is developed for application . This particular feature packages the Plug in P1 Version 1.0.0. The Version 1.0.0 of the Feature F1 does comply with the ECLIPSE Versioning Convention. Therefore the particular feature will properly install and resolve in the application . The version of this feature will be registered as 1.0.0 in the ECLIPSE Runtime as exactly marked in its feature manifest i.e. feature.xml file .

Imagine that a newer Version 2.0.0b of the same Feature F1 is introduced to the application at a later time. This particular version of the feature packages a brand new Plug in P2 Version 1.0.0 and a newer Version 2.0.0 of the existing Plug in P1. As you may see the service identifier 0b of the Version 2.0.0b of the Feature F1 isn t numeric contains the character b . Therefore the Version 2.0.0b is considered invalid according to the ECLIPSE Versioning Convention. Attempts to install this particular feature would not be permitted by the ECLIPSE Update Manager. If the Feature F1 Version 2.0.0b did not properly install for any reason the bundles that it packages such as the brand new Plug in P2 and the newer Version 2.0.0 of the existing Plug in P1 would not install in the application . If the Plug in P1 version 2.0.0 and the Plug in P2 version 1.0.0 did not install in the application they would provide no functionality to the application even though their versioning does perfectly comply with the ECLIPSE Versioning Convention.

Appreciably a feature can be installed in ECLIPSE without relying on the functionality provided by the ECLIPSE Update Manager which includes an internal versioning check that prevents installations having versioning errors. For instance certain ECLIPSE configurations allow its users to install a feature in the application by manually copying the particular feature and its contents to the build. If it was the method of installation used in the previous example the Feature F1 Version 2.0.0b would have installed in the application . However its version would still violate the ECLIPSE Versioning Convention therefore it will be reset to 0.0.0 by the ECLIPSE Runtime. Now there are two versions 1.0.0 and 0.0.0 originally 2.0.0b of the Feature F1 available in the application . The Version 1.0.0 is greater than 0.0.0 therefore the former Version 1.0.0 of the Feature F1 would resolve in the application . The Version 0.0.0 of the Feature F1 would be disabled even though it was the newer version.

If the Feature F1 Version 0.0.0 originally 2.0.0b did not resolve as mentioned the bundles that it packages might not resolve or install in the application . This means that the plug ins P1 Version 2.0.0 and P2 Version 1.0.0 would not resolve and therefore provide no functionality to the application even though not only these bundles are physically available to the application but also their versioning perfectly comply with the ECLIPSE Versioning Convention.

Experience demonstrates that there is a probability for at least one of the two plug ins P1 Version 2.0.0 and P2 Version 1.0.0 packaged by the Feature F1 Version 2.0.0b to resolve under these conditions even with the absence of their parent. If the latter was the outcome the resolved Version 1.0.0 of the Feature F1 would suffer from configuration related errors due to the resolution of the Plug in P1 Version 2.0.0. It has been witnessed that a feature or patch with configuration related errors could prevent the user from upgrading not only the given feature but also the remaining features in the application as well. In addition such a feature may restrict the user from installing new features in the application since adding new functionality to an application with configuration errors could make the application even more unstable.

The platform filter of a feature or patch specifies the platform that the particular bundle is allowed to resolve. For instance the following platform filter specifies that the corresponding bundle must only resolve on a platform running on an x86 architecture and using a Linux operating system built on the Motif windowing system.

If a feature with the above platform filter was included into an application developed for the WINDOWS platform for instance the targeted feature would not resolve. Consequently the plug ins and fragments packaged by the particular feature would not resolve either. It would therefore contribute no functionality to the application even though the bundles are available to the application .

Hence attempting to include a feature designed for one platform into an application developed for another platform not only fails to work but also increases a size of the application unnecessarily. Experience demonstrates that features and patches designed for one platform are sometimes mistakenly included into applications developed for another platform due to various reasons. It is usually a responsibility of a release engineer to identify such bundles and remove them from the application as quickly as possible.

It has also been witnessed that developers especially those new to the ECLIPSE framework sometimes assign incorrect platform filters to features which renders that features ineffective on the targeted platform. The release engineer must identify such bundles and correct their platform filters as quickly as possible which can be a process facilitated by utility which is able to detect and report incompatible platform filters .

A feature or patch packages plug ins and fragments by grouping them together in order for them to be installed uninstalled enabled and disabled as groups instead of individuals. The bundles packaged by a feature or patch are often referred to as the included dependencies of the particular feature or patch for simplicity. In addition a feature or patch may require the existence of other plug ins or fragments in order for its included dependencies to resolve and function in the application . The plug ins and fragments required by a feature or patch are often referred to as required dependencies of the particular feature or patch . Both the included and required dependencies of a feature or patch form strong hierarchical associations between features patches plug ins and fragments . It is mandatory that all of the included and required dependencies of a feature or patch to resolve and be configured properly in the application . A feature or patch failing to satisfy the above requirement would suffer from configuration related errors which might ultimately prevent the user from updating the application .

To illustrate by example a feature identified as F1 can package a second Feature F2 i.e. included dependency . The Feature F2 can depend upon the functionality included by a feature identified as F3 i.e. required dependency and the Feature F3 can package a feature identified as F4 i.e. included dependency again . In this particular example the Feature F1 requires the second Feature F2 to exist and resolve in the application in order for it to be properly configured. In addition the Feature F2 must be properly configured meaning all of its included and required dependencies must also exist and resolve in the application . If and only if both of these criterions were met the Feature F1 would function properly in the application . Additionally the Feature F2 can require the existence of its required dependency F3 and the dependencies of the feature F3 in the application . Finally the Feature F3 can require the existence of the Feature F4 and the dependencies of the Feature F4 in the application .

This complex hierarchical dependency structure mandates the existence and the resolution of all of its participants and their included and required dependencies in order for the Features F1 F2 F3 and F4 to function properly in the application . In this example the Feature F4 can be mistakenly excluded from the application . In such a situation the complete hierarchical dependency structure would collapse by causing configuration related errors in the remaining Features F1 F2 and F3.

It has been witnessed that a feature or patch with configuration related errors could prevent the user from upgrading not only the given feature but also the remaining features in the application . In addition such a feature may restrict the user from installing new features in the application since adding new functionality to the application with configuration errors could make the application even more unstable.

In this particular example if a release engineer had somehow known that the Feature F4 was missing from the application and that was what was causing configuration related errors in the remaining Features F1 F2 and F3 then this particular issue could have been resolved by simply introducing the missing Feature F4 and its contents to the application . Configuration test utility can assist in identifying that the unavailability of the Feature F4 was the root cause of the problem so that suitable problem resolution actions can be taken.

If a dependency of a feature or patch is made optional the associated feature or patch does not suffer from configuration related errors through the particular dependency was not available in the application . This behavior of the ECLIPSE framework makes the feature development more flexible but introduces a new breed of issues and challenges in the fields of Software Quality Engineering and Release Engineering which can be detected and reported by utility .

To illustrate a feature identified as F1 has an optional dependency F2. Under these circumstances the Feature F1 would not suffer from configuration related errors even though the Feature F2 was mistakenly excluded from the application . In addition the ECLIPSE framework can conclude that the Feature F1 must be properly configured and therefore raise no concerns about the unavailability of its dependency on the Feature F2 even though the particular feature F2 was excluded from the application by accident. The utility can report in the optional dependencies section of report that Feature F2 is an optional dependency of Feature F1 which is lacking in the application .

A feature patch provides updates to the bundles packaged by the feature that it was implemented for. Therefore a patch should be resolved if and only if the feature that it was implemented for was available and resolved in the application .

Patches do resolve in the ECLIPSE framework under certain circumstances even in the absence of the parent features. In addition the ECLIPSE framework can conclude that the feature patch must be properly configured and therefore raise no concerns about the unavailability of its parent feature what so ever. When a parent feature is absent the test utility can specify so in an absence of parent features section of report .

The topic of feature patches and their associated functionality often isn t well defined or documented. As a result the feature patches are often misused in ECLIPSE based applications which can result in fatal configuration related errors in the corresponding features and patches .

To illustrate implementing a feature patch to introduce an earlier release version of a set of plug ins and fragments when a newer release of the corresponding plug ins and fragments have been introduced by the parent feature of the particular patch is considered a non standard application. Similarly implementing a feature patch to reintroduce a set of plug ins and fragments when the same release of the corresponding plug ins and fragments have been introduced by the parent feature also falls into this category. Furthermore implementing a feature patch with a platform filter that is incompatible with the platform filter of the parent feature is too considered a non standard application

A feature or patch with configuration related errors often prevents a user from upgrading not only the given feature but also the remaining features in the application . Further such a feature may restrict the user from installing new features in the application since adding new functionality to an application with configuration errors could make the application even more unstable. The utility can detect and define a set of non standard application of feature patches within a section of the report .

A branding plug in brands a given feature by providing the feature with customized messages logos icons license agreements contact information help documents etc. that are exploited in the ECLIPSE About Dialog and its associated functionality. The ECLIPSE framework has one feature branding plug in combination to brand itself. An Eclipse Based Application may introduce a feature branding plug in combination for each component included in the particular application.

It is not required for each feature in an ECLIPSE based application to have a branding plug in. However it is recommended for an application to consist of a feature branding plug in combination to brand itself. If the application encapsulates other external applications and or modules then each one of the external components in the application may also carry a unique feature branding plug in combination in order to provide the application with their branding information. An average Eclipse Based Application may consist of a large number of features . Quite a few of these features may be designed to deliver their own branding plug ins to the application in order to brand the components that they belong to. Mistakenly excluding any of the branding plug ins from the particular Eclipse Based Application or such a plug in failing to resolve would result in the absence of the associated branding information in the application. The unavailable branding plug in section of report can identity potential branding problems and inconsistencies.

Interface can permit a user to customize reports and to specify details of the test information to be used by a configuration test utility. A selection button can trigger a testing operation which results in a configuration test report. Various options can be selected from interface such as an option to ignore warnings that are found with regard to features patches plug ins and fragments of a product.

Method can begin in step where an event that triggers a configuration test of an ECLIPSE based application can be detected. In one embodiment the triggering event can be a user selection of a test command within a configuration test interface. In another embodiment the configuration test event can be automatically triggered when a feature or feature patch is applied to an application. In order to find potential configuration issues a configuration utility can initially seek information about the sites available in a given application as shown by step . Sites are defined as locations containing features and patches that compose an application. Once the sites have been located a list of features plug ins fragments and feature patches required for the application can be compiled.

In step key operational data can be extracted from the manifest of each element in the compiled list. Extracted data can include but is not limited to feature identification version platform filters e.g. platform architecture language and other constraints a set of included plug ins fragments features and patches a set of required plug ins fragments features and patches an identification of a branding plug in if available and other information. In step the extracted data can be analyzed for potential configuration problems. A set of configuration problem specific rules e.g. rules for versioning for platform filters for dependencies for handling parent features for determining non standard feature patch issues for branding issues etc. can be used during step . In one embodiment these rules can be updateable to ensure concurrency with current ECLIPSE standards and or to permit developers to establish and test project specific constraints. In step any detected configuration problems can be validated. In step validation configuration problems can be collated into a test report which can be presented to a user in step or stored at a designated memory space for later examination.

The present invention may be realized in hardware software or a combination of hardware and software. The present invention may be realized in a centralized fashion in one computer system or in a distributed fashion where different elements are spread across several interconnected computer systems. Any kind of computer system or other apparatus adapted for carrying out the methods described herein is suited. A typical combination of hardware and software may be a general purpose computer system with a computer program that when being loaded and executed controls the computer system such that it carries out the methods described herein.

The present invention also may be embedded in a computer program product which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computer system is able to carry out these methods. Computer program in the present context means any expression in any language code or notation of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either or both of the following a conversion to another language code or notation b reproduction in a different material form.

This invention may be embodied in other forms without departing from the spirit or essential attributes thereof. Accordingly reference should be made to the following claims rather than to the foregoing specification as indicating the scope of the invention.

