---

title: Processor-in-the-loop co-simulation of a model
abstract: A model may be constructed and simulated using processor-in-the-loop co-simulation at a target device. In one implementation, a host environment may provide a graphical environment that facilitates construction of the model defined as a plurality of functional blocks. The host environment may receive, via graphical selection menus associated with the blocks of the model, an indication of which blocks of the model are to simulated at an external target device and which blocks of the model are to be simulated at the host environment. Further, the host environment may receive a command, that may be entered interactively by a user, to start simulation of the model and execute, in response to the command, co-simulation of the model at the host environment and the external target device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08457945&OS=08457945&RS=08457945
owner: The Mathworks, Inc.
number: 08457945
owner_city: Natick
owner_country: US
publication_date: 20120523
---
This application is a continuation of U.S. patent application Ser. No. 12 167 643 filed Jul. 3 2008 the disclosure of which is incorporated by reference herein in its entirety.

Technical computing environments are known that present a user such as a scientist or engineer with an environment that enables efficient analysis and generation of technical applications. In the MATLAB technical computing environment for example users may perform advanced analyses visualize data and develop algorithms. Ideally a technical computing environment will enable a technical researcher or designer to efficiently and quickly perform tasks such as research and product development.

Existing technical computing environments may be implemented as or run in conjunction with a graphically based environment. For example in one existing graphically based technical computing environment models may be built by connecting graphical blocks where each block may represent an object associated with functionality and or data. Blocks may be hierarchical in the sense that each block itself may be implemented as one or more blocks. A user may for instance view the model at a high level then select blocks to drill down into the model to see increasing levels of model detail.

Frequently the model is designed and tested through the technical computing environment executing on a general purpose computer. The target system for the model however may be another device such as a specialized processor running in an embedded system. For example a user may design a model to control a station in an assembly line where the station referred to as the target device for the model may include a number of external sensors and a microprocessor.

The following detailed description refers to the accompanying drawings. The same reference numbers in different drawings may identify the same or similar elements. Also the following detailed description does not limit the invention.

Users may simulate execution of a model by running the model in a technical computing environment executing on a general purpose computer. Sometimes however the user may desire that parts of the model be directly executed on a target device. This may be desirable for example to acquire on target performance data for performance reasons or to verify that the model works correctly on the target device. In this situation the technical computing environment may enable co simulation of the model where co simulation refers to the fact that the model is being simulated tested on both the target device and the remainder of the model on the host device i.e. the general purpose computer at which the technical computing environment is executed .

Implementations described herein relate to a technical computing environment in which users may construct and test graphical models. The models may be defined by a plurality of blocks potentially at different hierarchical levels in the model that each define functionality of the model. Users may individually select through a simple graphical menu whether each block should be simulated in a host environment or at a target device via processor in the loop PIL co simulation. Additionally in some implementations a modular application programming interface API may be provided to allow configuration of co simulation with the target device. The different modular API components may be independently combinable to create a complete interface with the target device.

A technical computing environment as the term is used herein is to be broadly interpreted to include any hardware and or software based logic that provides a computing environment that allows users to efficiently perform tasks related to disciplines such as but not limited to mathematics science engineering medicine business etc. In one implementation a technical computing environment may include a dynamically typed programming language e.g. the M language that can be used to express problems and or solutions in mathematical notations. For example a technical computing environment may use an array as a basic element where the array may not require dimensioning. In addition a technical computing environment may be adapted to perform matrix and or vector formulations that can be used for data analysis data visualization application development simulation modeling algorithm development etc. These matrix and or vector formulations may be used in many areas such as statistics image processing signal processing control design life sciences modeling discrete event analysis and or design state based analysis and or design etc.

A technical computing environment may further provide mathematical functions and or graphical tools or blocks e.g. for creating plots surfaces images volumetric representations etc. . In one implementation a technical computing environment may provide these functions and or tools using toolboxes e.g. toolboxes for signal processing image processing data plotting parallel processing etc. . In another implementation a technical computing environment may provide these functions as block sets. In still another implementation a technical computing environment may provide these functions in another way such as via a library etc.

A technical computing environment may be implemented as a text based environment e.g. MATLAB software Octave Python Comsol Script MATRIXx from National Instruments Mathematica from Wolfram Research Inc. Mathcad from Mathsoft Engineering Education Inc. Maple from Maplesoft Extend from Imagine That Inc. Scilab from The French Institution for Research in Computer Science and Control INRIA Virtuoso from Cadence Modelica or Dymola from Dynasim etc. a graphically based environment e.g. Simulink software Stateflow software SimEvents software etc. by The MathWorks Inc. VisSim by Visual Solutions LabViewt by National Instruments Dymola by Dynasim SoftWIRE by Measurement Computing WiT by DALSA Coreco VEE Pro or SystemVue by Agilent Vision Program Manager from PPT Vision Khoros from Khoral Research Gedae by Gedae Inc. Scicos from INRIA Virtuoso from Cadence Rational Rose from IBM Rhapsody or Tau from Telelogic Ptolemy from the University of California at Berkeley aspects of a Unified Modeling Language UML or SysML environment etc. or another type of environment such as a hybrid environment that includes one or more of the above referenced text based environments and one or more of the above referenced graphically based environments.

Workstation may operate as a single detached computing device. Alternatively workstation may be connected to a network such as a local area network LAN or wide area network WAN such as the Internet. When workstation is connected to a network TCE may be run by multiple networked computing devices or by one or more remote computing devices. In such an implementation TCE may be executed in a distributed manner such as by executing on multiple computing devices simultaneously. Additionally in some implementations TCE may be executed over a network in a client server relationship. For example workstation may act as a client that communicates with using a web browser a server that stores and potentially executes TCE .

For example as shown in system may include a remote TCE e.g. a remotely located computing device running a TCE and or a TCE service . TCE service may include a server computing device that provides a TCE as a remote service. For instance a TCE may be provided as a web service. The web service may provide access to one or more programs e.g. TCE provided by TCE service . A web service as the term is used herein is to be broadly interpreted to include any software application that allows machine to machine communications over a network e.g. a local area network LAN a metropolitan area network MAN a wide area network WAN such as the Internet etc. . For example a web service may communicate with a client e.g. workstation using an application program interface API that the client may access over the network. The web service may exchange Hypertext Markup Language HTML Extensible Markup Language XML or other types of messages with the client using industry compatible standards e.g. simple object access protocol SOAP and or proprietary standards. A web service may further include network services that can be described using industry standard specifications such as web service definition language WSDL and or proprietary specifications.

As used herein TCE and the computing hardware on which it operates such as workstation the computing hardware associated with remote TCE or the computing hardware associated with TCE service may be referred to as the host environment. 

System may additionally include target device . Target device may include for example a target computing device such as a specialized processor running in an embedded system. In other implementations target device may be a virtual target device such as an instruction set simulator that implements the interface of the target device. Models constructed with TCE may be designed to run at least partially at target device . In particular when simulating or testing the model via the host environment the user may desire to have target device execute one or more portions referred to as blocks herein of the model. As described in more detail below TCE may provide for processor in the loop PIL co simulation in which selected blocks of a model may be easily and automatically executed at target device while other portions of the model are executed by TCE . Results of the model blocks executing at target device may be received by TCE and presented to the user.

Target device and the host environment may be connected to one another in a number of different ways. For example target device may be connected to the host environment via a wired connection such as over a network or via a direct connection. Alternatively target device may be connected to the host environment via a wireless link or network connection. Additionally in some implementations target device and the host environment may be contained within a single physical housing or enclosure such as if target device was a processor embedded in a circuit board or card that is designed to be inserted into a personal computer.

Processing device may include a processor microprocessor or other types of processing logic that may interpret and execute instructions. Processing device may include a single core or multi core processing device. With a multi core processing device in one possible implementation TCE may execute on one core of the multi core processing device and target device may be implemented by or simulated by another core of the multi core processing device. Main memory may include a random access memory RAM or another type of dynamic storage device that may store information and instructions for execution by processing device . ROM may include a ROM device or another type of static storage device that may store static information and or instructions for use by processing device . Storage device may include a magnetic and or optical recording medium and its corresponding drive.

Input device may include a mechanism that permits an operator to input information such as a keyboard a mouse a pen a microphone voice recognition and or biometric mechanisms etc. Output device may include a mechanism that outputs information to the operator including a display a printer a speaker etc. Communication interface may include any transceiver like mechanism that enables computing device to communicate with other devices and or systems. For example communication interface may include mechanisms for communicating with another device or system via a network.

As will be described in detail below computing device may perform certain operations in response to processing unit executing software instructions contained in a computer readable medium such as main memory . A computer readable medium may be defined as a physical or logical memory device. The software instructions may be read into main memory from another computer readable medium such as storage device or from another device via communication interface . The software instructions contained in main memory may cause processing unit to perform processes that will be described later. Alternatively hardwired circuitry may be used in place of or in combination with software instructions to implement processes described herein. Thus implementations described herein are not limited to any specific combination of hardware circuitry and software.

The computer readable medium of workstation may particularly include TCE . TCE may include any of the features defined above with respect to the term technical computing environment. For example in one implementation the technical computing environment may include MATLAB software that provides a variety of mathematical functions and or graphical tools.

Although shows exemplary components of computing device in other implementations computing device may contain fewer different or additional components than depicted in . In still other implementations one or more components of computing device may perform one or more tasks performed by one or more other components of computing device .

TCE may include a TCE language component and a graphical model creation component . TCE language component may generally function to implement a technical computing language. TCE language component may for example provide an interface that integrates computation visualization and programming in a relatively easy to use environment where problems and solutions can be expressed in mathematical notation familiar to technical users.

Graphical model creation component may include software for modeling simulating and or analyzing dynamic systems. Graphical model creation component may for instance support linear and nonlinear systems models in continuous time sampled time or a hybrid of the two. Systems modeled with graphical model creation component may be constructed using a graphical interface that allows the user to arrange blocks that represent functionality and or data. Graphical model creation component may additionally allow users to execute or run the created model and to view and analyze results of the model.

In general graphical model creation component can be used to graphically generate models that represent a behavior of a design or system. The models may be used to facilitate communication peer review and iterative refinement with visual representations that simplify understanding. The graphical models may eventually be compiled and deployed in an external target system such as target device .

As described herein TCE may be implemented by logic that provides for the simulation of a created model in which one or more portions of the model may be run at target device using a processor in the loop PIL co simulation mode. This can be useful in a number of situations such as when a user would like to verify that a model that is designed to run on a target device will run on the target device without errors.

Before describing model co simulation in additional detail it will be helpful to describe an exemplary model generated with graphical model creation component .

A block as this term is used herein generally refers to a portion of functionality that may be used in a model. Although blocks will be generally described herein as functionality for a model that is graphically represented it can be appreciated that a block does not necessarily need to be represented graphically. Also the particular visual depiction used to represent a block is generally an arbitrary design choice.

Model is shown as a model representing a control system for an aircraft. Blocks nominal speed and high speed represent constants that define the engine speed of the aircraft. Switch may be settable by the user and may allow the tested engine speed to be set based on block or block .

Model additionally includes a number of signal input blocks labeled as blocks and . Block is labeled as a throttle command block and may be configured to generate a command simulating a throttle signal. In a production deployed version of model block may represent an actual throttle signal from the aircraft. Blocks similarly represent additional signals that may be generated by various sensors in the aircraft. More particularly these blocks include MAP sensor block EGO sensor block speed sensor block and throttle sensor block .

Blocks and are labeled as fuelsys algorithm and engine gas dynamics respectively and may represent model functionality related to determining fuel rate and other engine parameters. Block for instance may receive an input signal from throttle command block MAP sensor block EGO sensor block speed sensor block throttle sensor block and a signal from nominal speed block or high speed block . In response block may calculate a signal representing the engine s fuel rate.

Block air fuel mixture ratio and block metered fuel may represent probe blocks. These blocks may for instance allow a user e.g. the designer of model to view various signals in the model as the model is simulating. In model block may allow the user to view the fuel rate signal output from block and block may allow the designer to view the air flow ratio signal output from block .

The user may interact with model through one or more graphical windows . Graphical window may provide an interface through which commands relating to model can be entered. For example graphical window may display a toolbar that includes a run button and a stop pause button . Run button may cause TCE to begin simulating the model. That is TCE may execute the functionality associated with each block in the model in an order using input signals dictated by the connectivity of the blocks. Stop pause button may stop an ongoing simulation.

At some point a user that is designing a model may wish to simulate or run the model in order to test the model. When simulating the model via TCE the user may view the state of various signals in the model such as via blocks and in model . Additionally the user may define simulated test signals in place of signals that eventually will emanate from a physical sensor such as the signals for blocks in model . Additionally portions of the model may be executed at a device or process external to the host environment such as target device . When executing portions of the model at target device the target device may transmit information describing the results of the simulation back to TCE which may for instance then propagate the signals to other blocks in the model. In this manner the simulation of the model can be performed at both TCE and target device . This type of simulation called processor in the loop PIL co simulation herein can be advantageous when testing various portions of a model on a target device to for example ensure that the model functions properly on the target device.

The user may initially configure TCE for the target device block . This may be a one time operation in which TCE once configured for target device may not need to be re configured. The configuration may be performed using for example a connectivity application programming interface API used to facilitate connectivity between TCE and target device . The connectivity API may include a number of modular components that are each independently programmable. For example the API may include a builder component used to configure how TCE and target device handle building of a model a launcher component used to configure how TCE launches a model on target device and a communicator component used to configure how TCE and target device communicate. The connectivity API will be described in more detail below.

The user may design a model and provide the model to or load a previously designed model into TCE block . The model such as model may be designed using graphical model creation component and may be based on one or more graphical blocks that each define functionality of the model. It can be appreciated that the concepts described herein are not limited to any particular model design environment.

At some point the user may designate certain blocks in the model as blocks that during simulation are to be simulated in co simulation mode block . In one implementation an arbitrary set of blocks may be selected by the user for co simulation using a simple graphical interface. For example a user may select a block in some manner such as by selecting and right clicking on a block to bring up a context menu that allows the user to select how the block is to be simulated.

In alternate implementations option for selecting the simulation mode for the block instead of being shown directly in the graphical window in which the block is shown may be displayed in a graphical view separate from the view in which the block is displayed.

Referring back to at some point the user may desire to start the simulation of the model block . The user may for example press run button to initiate execution of the model. At this point TCE may begin to simulate the model as further described below with respect to blocks and . TCE may begin simulating the model using co simulation for the selected blocks if any without any further configuration or interaction by the user. From the user s perspective performing a PIL co simulation may involve selection of the blocks to co simulate and starting the simulation.

TCE may generate and compile build code for the model block . The code may be for example computer code in a language such as C C or another language that is then compiled. In some implementations portions of a model that were previously compiled and that have not changed since the previous compile may not need to be recompiled. In some implementations code generated or compiled for portions of the model that is to be simulated on target device may be generated differently based on features and capabilities of target device . Configuration information for generating and or building code specific to the target device may be configured via a build component of the connectivity API. For example an external compiler to use for the target device or other features of the code generation and build process may be configured via the connectivity API.

Model block code may include code that implements the functionality of the various blocks designated by the user as blocks that are to execute at target device . Model wrapper may provide an interface for the functions in model block code . In other words model wrapper may invoke the various functions in model block code pass data to these functions and receive results back from the functions. Model control component may via model wrapper code control the execution of the basic model functions provided by model block code . Model control component may additionally handle communications with TCE . Thus model control component may receive timing and model information from TCE and provide the results of model block code to TCE . Model control component may include device drivers such as Transmission Control Protocol Internet Protocol TCP IP or serial communication drivers for communicating with TCE .

Referring back to TCE may download the generated and compiled code to target device block . In other words TCE may download model target code to TCE . TCE may then commence PIL co simulation with target device block . During co simulation results of the model simulation at both TCE and target device may be received stored and or displayed by TCE .

Models designed with TCE may be represented in a hierarchical manner. For instance a block may be defined based on multiple other blocks. This allows a designer to design a complex model based on a number of less complex modular components. PIL co simulation may be performed at an arbitrary level of the model hierarchy.

Blocks and may represent elements from which model is built. Model may have been generated by a user placing each of blocks and in a graphical interface connecting inputs and outputs of the blocks to create logical connections between the blocks and configuring parameters relating to the blocks. Subsystem A in particular may have been generated by the user grouping through graphical model creation component blocks into sets of blocks as a subsystem.

In assume a user has selected subsystem C as a block that is to be simulated at target device . Subsystem C may be shown in a visually distinctive manner such as by cross hatch shading to indicate that that this block has been selected for PIL co simulation. TCE when generating model block code for this model may generate model block code to embody the functionality of subsystem C including the functionality defined by all blocks below subsystem C in the model hierarchy. At some point the user may select another or an additional block to include in the PIL co simulation. For instance the user may select subsystem B to include in the PIL co simulation. In this situation model block code may be generated to include the functionality embodied by both subsystem B and subsystem C as well as the functionality of all blocks below these blocks in the model hierarchy.

In some implementations blocks in addition to blocks that were explicitly selected by the user for co simulation at target device may be automatically selected by TCE for co simulation at target device . For instance the user s selection of certain blocks in the model for co simulation at target device may dictate that other blocks such as certain blocks below the selected blocks in the model hierarchy need to also be simulated at target device .

In some implementations target device may support as well as multiple blocks execution of multiple instances of a block. Control of the different instances of a block and of the different blocks may be provided by model control component .

In some implementations multiple separate instances of the simulation environment may be supported at a single target device . With such an architecture multiple models may be simultaneously simulated on a target device.

As previously mentioned information pertaining to model simulation on target device may be received by TCE . This information may be presented to the user in some manner. In one implementation information relating to status of the co simulation or to results of the simulation may be presented to the user as information annotating model .

From the point of view of the target devices PIL co simulation is essentially identical to the implementation shown in . That is each target device implements one or more blocks of the model. Using multiple target devices in this manner may be useful for example to increase model simulation speed or in situations in which the deployed version of the model is to be distributed over multiple target devices.

Graphical box may display a number of different types of information to the user. For example graphical box may display metrics relating to the status of an ongoing or completed co simulation such as code coverage metrics execution profile information or stack profile information. Additionally or alternatively graphical box may display information relating to co simulation configuration information such as a device type or status e.g. running halted etc. of target device or the state of the communication link to target device .

In the example shown in graphical box is particularly shown as displaying information relating to the status of the target device okay and code coverage information for block .

In some implementations TCE may present information relating to the state of various blocks that are being simulated via PIL co simulation at target device . As previously mentioned model control component of target device may communicate with TCE . TCE may receive and store information relating to the state of blocks being simulated at target device . State information relating to blocks being simulated at target device may be displayed to the user in a number of ways. For instance a user may add one or more blocks to a model that are designed to display variables or signals in the model. Alternatively graphical boxes such as graphical box that display state information relating to a block may present block state information to the user.

In some implementations TCE may allow the state of blocks that are to be simulated at target device to be set to a desired state. For instance the model when compiled and downloaded to the target device block may be compiled and downloaded with variables or other properties of the model blocks set to an initial predetermined state. In this manner a model may be immediately set to a desired state. Alternatively the user may desire that a model execute in non PIL co simulation mode until a certain state or time is reached and then at that point the model may switch to PIL co simulation mode. Accordingly TCE may provide an option through which the user may specify a condition at which PIL co simulation mode is to start. For example the user may specify that when certain model variables have certain values or after a certain model time has elapsed TCE should begin PIL co simulation. Prior to this point the model may be simulated entirely at TCE . After this point TCE may simulate the model in PIL co simulation mode with target device .

In some implementations TCE may allow the user to modify or tune parameters relating to the operation of blocks that are being simulated at target device . The user may for example select a block to modify parameters relating to the block. TCE may transmit the updated values for the parameters to model control component in target device . Model control component may then update model block code to reflect the changed parameter values.

As previously discussed a connectivity API may be used to initially facilitate connectivity between TCE and target device . The connectivity API may include a number of modular components that are each independently programmable. The modular nature of the connectivity API can facilitate component reuse and lead to reduced development effort.

Each API and may be used to generate a target connectivity component. A collection of target connectivity components may be registered with TCE as a target connectivity configuration. Each target connectivity component may be independently programmable and can be arbitrarily combined with other target connectivity components to create target connectivity configuration thus leading to modular connectivity development and code reuse. Advantageously reduced end user time may be needed to provide target connectivity for a new target device.

Techniques were described herein for performing PIL co simulation of a model. The PIL co simulation may be initiated via a one click simulation process. Initial configuration of the host environment for a target device may be performed via a number of modular API connectivity components.

The foregoing description of implementations provides illustration and description but is not intended to be exhaustive or to limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention.

For example while a series of blocks have been described with regard to the order of the blocks may be modified in other implementations. Further non dependent acts may be performed in parallel.

It will be apparent that embodiments as described herein may be implemented in many different forms of software firmware and or hardware in the implementations illustrated in the figures. The actual software code and or hardware used to implement embodiments described herein is not limiting of the invention. Thus the operation and behavior of the embodiments were described without reference to the specific software code and or hardware it being understood that one would be able to design software and or hardware to implement the embodiments based on the description herein.

Even though particular combinations of features are recited in the claims and or disclosed in the specification these combinations are not intended to limit the invention. In fact many of these features may be combined in ways not specifically recited in the claims and or disclosed in the specification.

No element act or instruction used in the present application should be construed as critical or essential to the invention unless explicitly described as such. Also as used herein the article a is intended to include one or more items. Where only one item is intended the term one or similar language is used. Further the phrase based on is intended to mean based at least in part on unless explicitly stated otherwise.

