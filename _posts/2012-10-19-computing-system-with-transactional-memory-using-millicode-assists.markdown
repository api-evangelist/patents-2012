---

title: Computing system with transactional memory using millicode assists
abstract: A computing system processes memory transactions for parallel processing of multiple threads of execution with millicode assists. The computing system transactional memory support provides a Transaction Table in memory and a method of fast detection of potential conflicts between multiple transactions. Special instructions may mark the boundaries of a transaction and identify memory locations applicable to a transaction. A ‘private to transaction’ (PTRAN) tag, directly addressable as part of the main data storage memory location, enables a quick detection of potential conflicts with other transactions that are concurrently executing on another thread of said computing system. The tag indicates whether (or not) a data entry in memory is part of a speculative memory state of an uncommitted transaction that is currently active in the system. Program millicode provides transactional memory functions including creating and updating transaction tables, committing transactions and controlling the rollback of transactions which fail.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09104427&OS=09104427&RS=09104427
owner: International Business Machines Corporation
number: 09104427
owner_city: Armonk
owner_country: US
publication_date: 20121019
---
This application is a divisional of U.S. patent application Ser. No. 11 928 533 filed Oct. 30 2007 which is a continuation in part of U.S. Ser. No. 11 748 044 filed May 14 2007 the contents of both are incorporated by reference herein in their entirety.

This invention relates to computer systems and particularly to a computing system with transactional memory using millicode assists.

Current multiprocessor and multithreaded computing systems allow the performance of a single software application to be scaled to many times the possible performance of a single threaded application. Current software and hardware systems provide for the parallel processing of multiple threads of execution. Software applications can use existing thread libraries such as the POSIX pthread library to control the creation of multiple threads of parallel execution. The use of multiple threads works well for applications that operate on easily partitioned tasks and data. Course grain locks can be used to control access to the few shared data structures to prevent rare conflicts between the data updates of multiple threads.

Many software applications contain data structures that must be shared among multiple threads and have frequent concurrent inspections and updates of the shared data structures. These applications require additional modifications in order to obtain good scaling when using large numbers of threads. Applications which use multiple threads of execution that access shared data structures currently require the use of specialized data locking routines in order to produce a reliable outcome that is free from deadlocks and corrupted data. The majority of existing multithreaded applications in this category use fine grained software locks to achieve good performance and correct operation. Writing high performance multithreaded programs which use fine grained software locks is extremely difficult and requires expert programming skills. The lack of these skills in the software industry severely limits the production of multithreaded applications which require the use of shared data structures and therefore the usefulness of multithreaded and multiprocessor computing systems for certain application classes including many forms of transaction processing.

Various Transactional Memory systems have been proposed and built to provide a simpler programming model for constructing multithreaded applications that need to control access to shared data structures. These systems allow software running on one thread of execution to optimistically assume that shared data structures can be updated without conflict with the accesses and updates of other threads of execution. The speculative updates to memory are kept pending until the transactional memory system confirms that no conflicts with storage accesses of other threads have occurred. The transactional memory system must be able to discard the pending speculative updates when conflicts between the storage accesses of multiple threads are detected. The existing transactional memory systems range from those that rely completely on new software constructs to those that rely on a mixture of hardware and software to obtain reasonable performance. Some existing systems have very high overhead in terms of the number of instructions executed in support of the required transactional memory behavior. Other existing systems have limitations associated with complex data cache structures that hold the pending updates to memory in caches. The cache based systems use many additional cache coherency states which causes a large increase in the design and simulation efforts for those systems.

Recently transactional memory systems have been proposed as illustrated by Microsoft s U.S. Patent Application Publication No. U.S.2007 0028056 which use software enlistment records associated with memory locations that have been accessed by transactions. The Microsoft system also uses a version value in the enlistment record . of Pub. No. 2007 0028056 includes an operation Locate enlistment record of memory location . The text describing gives the example of the enlistment record being part of a software object at the referenced memory address. From Pub. No. 2007 0028056 in paragraph 24 it will be seen that Timothy L. Harris the Microsoft inventor indicates that an enlistment record is created with the use of a software transactional memory interface . The Microsoft Pub. No. 2007 0028056 uses version numbers associated with each enlistment record and needs to deal with cases where the version number exceeds the maximum number supported by the enlistment record. In hindsight after learning of the details of our invention it will be recognized that these features of the recent developments in transaction memory systems are not needed and can be improved upon.

Earlier and now long ago as pointed out in the development of fast paced computing systems developments summarized by David A. Wood University of Wisconsin Transactional Memory Workshop April 8 2005 it was Chang and Mergen of IBM described in 801 Storage Architecture and Programming who proposed using a lock bit associated with each segment of virtual memory. Their system provided an ability to detect concurrent accesses of storage locations by multiple threads but restricted the total number of concurrent threads that could operate on any single virtual memory segment when the transaction locking mechanism becomes active. Large virtual memory page tables which are required by Chang and Mergen to execute concurrent threads imposes a performance penalty on all threads of execution that use virtual memory not just those that execute transactions so the Chang and Mergen suggestions became an anecdote in the prior art as Woods said No one seems to be looking at what they learned . The current invention uses a Transaction Table that is distinct from the virtual memory page tables of the system.

Unknown to Woods in the Chang and Mergen IBM Yorktown facility there have been ongoing laboratory developments relating to transactional memory systems culminating with the most recent transactional memory system described by Xiaowei Shen U.S. patent application Ser. No. 11 156913 filed Jun. 20 2005 and entitled Architecture Support of Best Effort Atomic Transactions for Multiprocessor Systems .

Shen describes a transactional memory system which focuses on using caches as buffers for data accessed by atomic transactions . Xiaowei Shen forces the failure of a transaction when the system detects a buffer overflow and does not propose dealing with the case of speculative data being evicted from the cache. A buffer overflow will result if too many transactional loads or stores target the same cache congruence class. The percentage of transactions which overflow the cache and fail will be proportional to the number of loads and stores contained in a transaction. Long transactions will fail more often.

Other systems have been proposed which use a cache to implement a conflict detection scheme and to capture speculative data which overflows the cache. We have found it desirable not to rely primarily on data cache states for conflict detection. The required specialized cache states cause an undesired increase in complexity and also makes it difficult to add the required detection and isolation mechanisms to existing multiprocessor cache coherency designs. Nevertheless there are numerous attempts to exploit the cache which have been tried besides the Xaiowei Shen development including Moore et al who describe the use of a before image log in their paper LogTM Log based Transactional Memory . Moore uses cache coherency states to implement a conflict detection scheme. Another such system Ananian et al describe a transactional memory system which uses a single unsorted linear array data structure to capture speculative data which overflows data caches. They use an extra bit per cache set the O bit to indicate if that set has overflowed and another bit per cache entry the T bit to indicate that the entry holds speculative data. The linear array data structure does provide the ability to support longer transactions but it does not provide the fast detection capability of the current invention. The linear array in Ananian needs to be searched for any cache access that targets the set that overflowed . This can be a long process for transactions which cause many overflows. Rajwar Herlihy and Lai take a similar approach as Ananian in their paper Virtualizing Transactional Memory . Rajwar also uses a data cache as the primary mechanism to track the speculative state associated with transactions. Speculative data which is forced out of the caches is moved to the XADT overflow area in virtual memory. The detection of a possible conflict with an address that is part of the XADT requires a slow linear search of the XADT. Rajwar describes the use of filters to eliminate some of these searches but there are many cases where the searches will still need to be done.

In addition to the above summarized developments in the field many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The paper Architectural Semantics for Practical Transactional Memory McDonald et al Computer Systems Laboratory Stanford University 2006 this paper listed in our IDS is submitted herewith and is incorporated herein by reference compares some of the proposals and provides references for many others and is incorporated herein by reference.

The shortcomings of the prior art are overcome and additional advantages are provided through the provision of a computing system with transactional memory using millicode assists. The millicoded microprocessors have millicode that is invoked for certain cases. Memory accesses generated by instructions within an Atomic Instruction Group AIG transaction are held pending. A new instruction e.g. tend or a buffer full indication causes the millicode to invoked to perform load and store processing. The millicode providing transactional memory functions including creating and updating transaction tables committing transactions and controlling the rollback of transactions which fail. Millicode Assist Setup Logic provides the ability to move the contents of the Address History Table to positions in millicode registers that are well suited to fast execution using the native hardware instructions of the microprocessor.

The program millicode provides assisting thread functions including AIG mode loads causing one additional load and two stores in which one store will miss the L1 cache and AIG mode stores which causes two additional loads and three stores in which one store will miss the L1 cache.

The use of hardware assists utilizing Millicode Assist Setup Logic for simple functions and millicode for more complex functions allows the invention to provide a balance of speed and flexibility when implementing the complex operations required for the support of a transactional memory programming environment in many types of microprocessors.

Transactional memory uses a combination of a private to transaction PTRAN tag attached to each increment of real system memory and a log of speculative loads and stores to provide an improved implementation of a transactional memory system. The current invention uses a log with the added mark bit employed as a private to transaction PTRAN tag and associated with every increment of real system memory. Hardware is provided to quickly detect conflicts between the storage accesses of transactions running on multiple threads of execution. The use of the tag in memory and associated conflict detection hardware included in this invention provides a much faster transactional memory system with much less overhead when compared to existing systems. The complexity of the current invention is lower than prior attempts at using additional cache coherency states for conflict detection especially for systems with large numbers of processors and associated interconnections.

The current invention uses the main memory array of the computing system to hold the speculative data and can support very long transactions. The current invention can benefit from the use of data caches but it does not require their use. The current invention provides the ability to check the address of a new memory access without a long search process for common cases. Likewise it is an improvement over software only transactional memory systems since the conflict detection and use of the tag in memory eliminates some of the software overhead associated with tracking the speculative state of transactions. It also provides the ability to detect storage conflicts at a very fine level own to a single byte as opposed to prior art software systems that track updates to entire software objects which may be hundreds or thousands of bytes. Existing software systems will either give frequent over indication of potential data conflicts or incur very large software path length penalties when attempting to track the updates to individual components of software objects.

Many software interfaces and instruction set modifications have been proposed for the support of transactional memory. The current invention can be used in combination with any of them in order to provide high performance transactional memory operations without incurring a large increase in hardware or software complexity. The preferred embodiment is described for the PowerPC architecture but anyone skilled in the art could apply the same approach to any other architecture such as IBM s zSeries IBM s pSeries with the P3 P4 P5 processors and even IBM s System 38 and its AS 400 which have a memory work of 65 bits could utilize the support of this invention as well as other computer systems such as Sun Microsystems SPARC Intel s IA32 etc. Anyone skilled in the art could extend the current invention for use with other Application Programming Interfaces APIs that may be created for other specialized versions of transactional memory implementations.

The current invention uses a hardware bit or bits associated with all memory locations not just those that are currently part of an active transaction. The current invention uses the added hardware bit or bits to provide much faster execution of transactions than that which can be obtained using Microsoft s Pub. No. 2007 0028056. The current invention uses an improved transaction table as a log to optimize the memory usage and provides a system which uses less memory than would be used by other systems like the Microsoft proposal yet the invention can execute applications developed for the Microsoft proposal. The current invention provides one or more PTRAN hits for every storage increment. There is no need in the current invention for an indirect method of locating the PTRAN bit. The current invention will provide a much faster indication of potential conflict since the PTRAN bit is a directly addressable part of the memory location to be marked. The current invention does not need a Microsoft style interface and achieves its benefit using hardware and firmware to update and reset the PTRAN bit. The current invention does not require application software to be aware of the state of the PTRAN bit or bits although one may provide a direct interface if desired. The current invention is also optimized for a short commit processing time. The current invention does not require the use of a version number for each storage location.

The current invention uses a hardware bit or bits associated with all memory locations not just those that are currently part of an active transaction. The current invention uses the added hardware bit or bits to provide much faster execution of transactions than that which can be obtained using Microsoft s Pub. No. 2007 0028056. The current invention uses an improved transaction log method to optimize the memory usage and provides a system which uses less memory than would be used by other systems like the Microsoft proposal. The current invention provides one or more PTRAN bits for every storage increment. There is no need in the current invention for an indirect method of locating the PTRAN bit. The current invention will provide a much faster indication of potential conflict since the PTRAN bit is a directly addressable part of the memory location to be marked. The current invention does not need a Microsoft style interface and achieves its benefit using hardware and firmware to update and reset the PTRAN bit. The current invention does not require software to be aware of the state of the PTRAN bit or bits although one may provide a direct interface if desired. The current invention is also optimized for a short commit processing time. The current invention does not require the use of a version number for each storage location.

We noted above the Chang and Mergen suggestions which became an anecdote in the prior art as Woods said No one seems to be looking at what they learned . An advantage of the current invention is that it uses a Transaction Table that is distinct from the virtual memory page tables of the system. This enables the current invention to process very large transactions and to provide conflict detection down to a single byte. The current invention has no limit on the number of concurrent threads that can simultaneously access memory locations in the same virtual memory segment. The current invention performs conflict detection on physical memory addresses or real addresses and only restricts simultaneous access at the granularity of this conflict detection. This granularity can differ for various implementations of the current invention but will usually be on the order of bytes. If the Chang and Mergen system tries to use large numbers of concurrent threads that system could not provide similar benefits without using extremely large virtual page table formats and consequently incurring a performance penalty. The current invention does not impose this performance penalty.

System and computer program products for implementing transactions using the above summarized methods are also described and claimed herein. Generally computer program products are delivered as computer program media which are tangible embodiments of the program delivering the instructions via a CD Rom a computer disc drive a connection to another system or other tangible embodiment of a signal for delivering a program signal to the computing system which supplies the support of this system all collectively known as computer program media. The computer program media may be provided as an independent software medium installed in the computing system memory or installed as firmware embodied in the computing system memory itself during operation.

Additional features and advantages are realized through the techniques of the present invention. Other embodiments and aspects of the invention are described in detail herein and are considered a part of the claimed invention. For a better understanding of the invention with advantages and features refer to the description and to the drawings.

As a result of the summarized invention technically we have achieved a solution which enables any millicoded processor to be used for transactional memory systems and provides a much faster transactional memory system with much less overhead when compared to existing systems. The current invention is also an improvement over existing hardware based transactional memory systems that rely on changes to cache coherence protocols. It allows the hardware system to deal with transactions which are long enough to overflow average size caches and doesn t involve the virtual memory management overhead of prior art schemes. The current invention has a much lower level of hardware complexity and is easier to implement and verify via simulation. It also allows for the ability to detect conflicts at a finer granularity than the cache line granularity of prior art systems that are tightly coupled with data caches. The current invention also allows for the fast execution of nested transactions.

The detailed description explains the preferred embodiments of the invention together with advantages and features by way of example with reference to the drawings.

Turning now to the drawings in greater detail it will be seen that in there is a computing system illustrating an embodiment of our invention which has one or more microprocessors coupled to a physical memory array via an interconnection element . The physical memory array stores transaction data and private to transaction PTRAN tags which are associated with every increment of real system memory. The interconnection element can be implemented as a shared bus or crossbar switch. The invention applies to systems which use any other scheme of interconnecting physical memory to a multiprocessor system which may be implemented in one or more chips. The memory could be broken down into smaller portions and distributed across private connections to each of the CPU chips as done for the IBM Systems using the Power4 microprocessor or for the AMD Opteron based servers. The microprocessors and memory controllers may be located together on a single silicon chip or they may be spread across multiple chips.

The physical memory of the computing system is divided into n increments. One or more private to transaction bits PTRAN associated with every increment of real system memory are provided for each of the n increments. The invention allows for the choice of any memory increment size and the best choice will depend on workload characteristics hardware costs and data caching structure used in the target system. An increment of 16 bytes is used in the illustrated embodiment. The PTRAN bit s are used to indicate whether or not a data entry in memory is part of the speculative memory state of an uncommitted transaction that is currently active in the system.

Special new instructions BEGIN AIG END AIG as illustrated by the Nested AIG code sequence of are used to mark the beginning and end of a group of instructions. The instructions which execute between the special new instructions are referred to as an Atomic Instruction Group AIG illustrated by AIG instructions shown in Instruction A Instruction A Instruction A . Additional storage access rules are used when a processor is executing instructions which are part of Atomic Instruction Group. All of the storage locations modified by the AIG group of instructions are updated in memory in an atomic fashion. The updates to the storage locations are kept pending until the processor and or software application indicates that they should be committed . All of the updates are either committed to normal memory at once or they are discarded. The results are discarded when hardware and or software detects a conflict between the storage accesses of multiple AIGs that are executing concurrently in the multiprocessor system. The invention provides a way for hardware to quickly detect potential conflicts between the storage accesses of multiple AIGs. Although the invention uses special new instructions to mark the boundaries of a transaction any other method could be used to identify a group of memory locations that are to be updated in an atomic fashion. The invention is compatible with any number of software interfaces that may be used to implement a transactional memory system. The invention can provide the same fast conflict detection for any system which is attempting to provide an atomic update of multiple storage locations. The invention also applies to systems which mark the boundaries of an instruction group in any other ways including compiler generated hints attached to other instructions internal microprocessor commands generated by internal microcode or millicode.

The PTRAN tag is one or more bits associated with an increment in memory which is set for all memory accesses generated by instructions that are part of an Atomic Instruction Group. A processor inspects the bit before attempting to set it this enables the quick detection of potential conflicts with other AIGs that are concurrently executing on other threads. The setting of the bit may be accomplished by a TS test and set operation of the IBM z Architecture as described by the IBM z Architecture Principles of Operation or any other equivalent operation that enables an atomic update in a multithreaded or multiprocessor system.

Turning now to it will be seen that Transaction Tables are created as part of the real system memory which is illustrated here as physical memory. The Transaction Tables could also be created in logical or virtual memory. Any system to map the logical system memory to the physical system memory can be used and there are numerous examples known in the art which can be used such as those in the IBM zSeries IBM s pSeries Sun Microsystems SPARC Intel s IA32 etc. A Transaction Table entry is made when instructions that are part of an Atomic Instruction Group cause a memory location to be inspected or updated. A Thread ID is associated with each Transaction Table. A Next Entry register is used as an index into the Transaction Table and indicates which entry should be written next. A Table Origin indicates the address of the first entry of the Transaction Table for its thread . The Transaction Table is used to hold additional information beyond the simple information that is associated with the PTRAN tag bit or bits that are associated with the memory location that has been inspected or updated. This additional information is related to the speculative state associated with an Atomic Instruction Group. In an illustrated IBM zSeries or pSeries CPU embodiment which we describe here we prefer to use a single PTRAN bit. In this case the Transaction Table will contain all additional information about the speculative state therefore the PTRAN bit will only indicate that a physical address is involved in an AIG. This is illustrated for Transaction Table A as the address the transaction info identifier and old or new data . Other embodiments of the current invention may use additional PTRAN bits which can be used by hardware or software to speed the processing of certain events involved in the processing of Atomic Instruction Groups or the speculative states of any other transactional memory system. The combination of using just a single bit in memory and associating that bit with a more complete description of the transactional state in the Transaction Tables provides a transactional memory system which requires very little hardware overhead without incurring the performance penalty seen in prior art software transactional memory systems.

Turning again to it will be seen as we said that an entry in the Transaction Table A for example comprises the address that has been inspected or updated inside of an AIG a Tran Info field and a Data Field . A store instruction that is part of an AIG will cause the system to copy the old data value from the original storage location to the Transaction Table entry for that address and the new speculative data is placed in the main storage location.

The invention can be made to work with the new values held in the Transaction Table if desired. The preferred embodiment places the old data value in the transaction table. This allows the system to be optimized for the case where most transactions are successful. The old data can be discarded quickly when it is no longer needed when a transaction is committed permanently to memory by changing the pointer to the transaction table or by clearing the contents of the transaction table. The Tran Info field of a Transaction Table entry includes any transaction information that is needed to make detailed decisions about the need to cause a transaction failure. It also has provisions for additional information to allow efficient support of nested transactions virtualized transactions or other extensions of the transactional memory architecture. In the preferred embodiment the Tran Info field includes an indication of whether the storage access of the associated address was a load type access or a store type access. The Tran Info field can also indicate whether the address is shared among multiple AIGs in the system.

An override of this AIG active mode may be provided. The override could be associated with the logical memory segment or logical memory page which contains the target address. An override forces the system to treat the storage request as normal in spite of the fact that the request is part of an AIG. If the override is active then the result of the decision will cause normal processing to take place. Assuming that an AIG is active and the override is not then the associated PTRAN bit is inspected at an inspection step . A load instruction inside of an AIG detects upon inspection the state of the PTRAN bit. When the PTRAN bit is already set it is due possibly to the actions of another thread executing on the same processor or on another processor. If at the inspection step it is found that the PTRAN bit is not set then the processor sets the PTRAN bit and make a record of the access in the Transaction Table for the active AIG by adding to the Transaction Table at the Set PTRAN step and then the complete load can continue . If the PTRAN bit is already set the address which caused this potential conflict is compared with the addresses already entered in the processor s Transaction Table. If the PTRAN bit was set when tested at the inspection step by another load earlier in the same AIG it is already part of the AIG as tested and determined and then the complete load may continue . Each Transaction Table contains the addresses for a particular AIG. Accordingly if the address was not already part of the AIG as tested and determined then the address for the load is not found in the processor s Transaction Table and then the processor checks whether the address is enabled for sharing among AIGs in a determination step for AIG sharing . If the address is not currently enabled for sharing among multiple AIGs the processor may signal other processors in the system to request a shared AIG access for this address during the determination step whether sharing is allowed among AIGs . A shared access can be granted if no other AIG in the system has speculatively written the storage location. If the shared access is not granted then the AIG fails otherwise the load address is added to the Transaction Table and the Tran Info field is updated to indicate that the address is a load access that is shared among multiple AIGs in the system.

The Store Processing Flowchart shows the actions for processing a store that is part of an AIG. When a processor attempts a store type access initially a store decision is made to determine whether the access is part of an AIG and whether the special storage access rules for AIG accesses apply. The mode of the processor is checked in a similar method as previously described for load accesses. If the special mode of operation under which the special access rules for AIG accesses apply is not active then the store is treated as a normal store . Assuming that an AIG is active the associated PTRAN bit is inspected at the store process inspection step . If the PTRAN bit is not already set then the PTRAN bit is set at the store transaction step and a new entry is added to the Transaction Table . The old data is moved to the Transaction Table entry the address is written to the new entry and the Tran Info field is updated. The Tran Info field is marked to indicate that the access associated with this entry was a store type access. The new store data is written to memory after the setting of the PTRAN bit is completed. If the inspection of the PTRAN bit indicates that the bit was already set then a decision is made based on whether the current store address is already part of an AIG which is active on the processor. The Transaction Table for the processor is examined if it is determined that the address is present in the Transaction Table then the Tran Info for the entry is checked and a decision as to shared access entry is made. If the Tran Info indicates that the entry is a load type access entry that is shared among multiple AIGs the transaction fails otherwise the Tran Info field for the associated entry is updated to indicate a store type access and the store is processed .

Turning now to the Commit Processing Flowchart of it will be seen that the invention includes a set of actions completed when the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory as determined initially at a test step . If not the processing continued in AIG mode . An AIG is committed to memory when the processing of the loads and stores of the AIG according to flowcharts from and does not result in a Transaction Failure. In the case of AIG success then testing determines the last instruction in an AIG has been processed and the entire group is ready to be committed permanently to memory. Then the Transaction Table is examined and each entry for the AIG to be committed is read and its associated PTRAN bit is reset in memory at the Transaction Table commit step determination.

A specialized hardware engine may be used to complete the performance of this commit operation. A combination of processor caches multiprocessor coherency actions and the current invention can be used to provide software with the illusion that all of the memory updates for a single AIG occur simultaneously even though the main memory storage arrays are not updated simultaneously. During the commit processing the resetting of the PTRAN bits continues until the last valid entry in the Transaction Table has been determined to be reached . At this point the AIG is considered to be committed and the performance by the engine therefore completes .

Some conditions prevent the completion of an AIG. These conditions may be detected during load processing while executing an AIG or during store processing while executing an AIG . There are many other possible processor conditions that may cause the need to abort the processing of an AIG. These include error conditions detected in the system as well as other conditions that would require significant additional hardware support to enable the processor to handle them correctly. Many prior art transactional memory architectures include provisions for the abort of transactions and for a subsequent retry. Prior art software constructs can be used together with the current invention to eliminate the need to provide hardware to deal with all possible special cases. A simple example is the case of a timer interrupt in the middle of processing an AIG. The interrupt may cause the processor to spend a large amount of time running code that is not part of the partially completed AIG. It may not be desirable for the processor to keep the AIG active during this time. The system can force a transaction failure for any AIG that is currently executing when a timer interrupt occurs. A similar approach can be used for any other special case events occurring in the processor.

Transaction failures or forced retries are handled according to the process of the Rollback Processing Flowchart for rollback processing shown in . Turning now to it will be seen that the lack of a transaction failure condition allows the processor to continue in the AIG active mode . The preferred embodiment of the current invention uses an eager policy with respect to detecting transaction failures and causing transaction rollback. Also the invention may be used in systems that wait until the end of a transaction to take the actions required for a rollback. The memory updates executed as part of an Atomic Instruction Groups are either committed to normal main storage at the same time or they are discarded with a rollback operation .

Upon finding a transaction failure condition failure several additional steps are required . Rollback Transaction Table processing entry steps provide that the Transaction Table for the AIG is inspected and any old data is written back to the main memory address indicated in the entry. The PTRAN bit for the associated address is reset. The rollback processing continues until the last valid entry in the table has been processed . After the last valid entry has been processed the rollback is complete . The actions taken by the processor at this point will differ based upon various software architectures for transactional memory. Any of transactional memory architectures described in the background may be used. In some cases the AIG will be retried from the beginning. In other cases special software handlers will be invoked to deal with the transaction failure. The current invention may be used with any of these different architectures.

The current invention supports the execution of nested transactions. A second AIG may be included within the scope of the first AIG as shown in . Each BEGIN AIG special instruction statement causes the system to create a Transaction Table and to associate the table with the AIG. Decisions about whether or not a storage address belongs to an AIG may include the inner AIG A or the combination of the inner and outer AIGs A B . The END AIG special instruction statement ends the transaction sequence but as shown a sequence for a specific transaction Transaction B may be nested within another sequence Transaction A The use of multiple Transaction Tables may be used to support many nesting architectures for transactional memory. Multiple versions of the old data may be stored in any number of Transaction Tables at any nesting depth. Prior art transactional memory systems that rely on data caches to hold speculative state are unable to provide similar support for nested transactions without adding additional state information to cache directories and adding additional complexity to the cache coherency protocol. Nesting support on prior art systems would impose a large hardware complexity penalty on those designs. The current invention can also be extended to include a combined Transaction Table that includes entries from both the inner AIG Instruction B Instruction B and the outer AIG Instruction A Instruction A Instruction A . This Combined Transaction Table may be used in place of the individual Transaction Tables or in addition to the individual Transaction Tables.

There are many additional hardware features that can be added to the invention to speed the processing of the Transaction Table manipulations and the setting and resetting of the PTRAN bit s . Since the PTRAN bit is part of the main storage data it can be cached in the normal data caches of the system. The Transaction Tables are also part of main storage and can also be cached. Additional control information can be added to the data caches to indicate whether a specific address has been enabled for shared AIG access and therefore eliminate the need to search the Transaction Table for some cases.

The preferred embodiment identifies the beginning of an AIG after decoding of an instruction . If it is determined that a BEGIN AIG instruction has been decoded the processor enters a new MILLICODE MODE and begins execution of millicode routines which have been written to support transactional memory execution. While the processor is in the MILLICODE MODE it has access to additional hardware state registers. One such state register indicates a new mode of execution AIG MODE which is used by the processor to control whether millicode is used to assist with the execution of other instructions associated with the support of transactional memory. In the current invention MILLICODE MODE is used to execute complex instructions that would be difficult to execute in a single pass of the instruction pipeline of a typical Reduced Instruction Set Computing RISC system. The processor enters AIG MODE and then millicode is used to create the transaction tables that are required for the support of transactional memory. If the instruction to be decoded is not the beginning of an AIG then the instruction is executed as usual and processing continues with the next instruction .

Prior to entering MILLICODE MODE the architected state of the processor is saved in the same manner that a traditional Program Call is handled in the IBM Z Series architecture. Any similar state saving mechanism may be used on any other processor architecture. The processor may return directly to this saved state if the AIG fails or may return to this state after a series of other error handling routines have been invoked. After the millicode associated with beginning a new AIG has been executed the processor exits MILLICODE MODE . The processor continues to be in AIG MODE at this point. While in AIG MODE decoding of instructions continues . If a load or store is decoded then special handling of these loads and stores is required . The processor enters MILLICODE SUBSET MODE to prepare for the execution of the processing steps required to track the transactional memory state. Entering the MILLICODE SUBSET MODE does not require as many processor cycles as MILLICODE MODE. The current invention uses a faster millicode setup path in the MILLICODE SUBSET MODE in order to minimize the time required to execute loads and stores that are part of an AIG. Additional processor state registers are added to enable the fast calculation of the table addresses required to track the state of the AIG. The steps required for the processing of a load inside of an AIG are described in those for a store inside of an AIG are described in . Since the execution of loads and stores inside of an AIG is a very common occurrence the MILLICODE SUBSET MODE is designed to provide very fast execution for their execution. After loads and stores in an AIG are processed the processor exits MILLICODE SUBSET MODE and it is determined whether there has been an AIG failure as described in the descriptions of and . If there is a failure then special handlers are invoked . The actions of the special handlers for transaction failure may vary depending on the architecture of the system using the invention. Many methods of dealing with transaction failures have been described in the prior art any of them could be used for this purpose. The possible methods include retrying the transaction from the beginning for a set number of attempts waiting for the condition that caused the failure to change calling specialized software routines to resolve conflicts among threads etc. These possible failure handlers may require the rollback of the AIG which caused the failure . If no failure was detected then it is determined whether the load or store was the last instruction of the AIG . If the instruction is the last instruction in the AIG then the AIG is committed by entering MILLICODE MODE and using the process described in . The processor then exits the AIG Mode and MILLICODE MODE and continues with the next sequential instruction after the AIG .

The decoding of instruction other than loads and stores inside of an AIG does not necessarily require special processing . If the instruction is not a load or store type instruction then it is determined whether the instruction is another BEGIN AIG . Nested AIG instructions require special handling . The prior art contains many different ways of handling nested transactions. The current invention can be used to support any of them. The nested AIG handler for the preferred embodiment adds the instructions of the inner AIG to the outer AIG creating a single larger AIG. Other embodiments of the invention may provide different rules of processing for loads and stores that are part an inner nested transaction as well as special rules for the commitment and failure handling of inner nested transactions. If it is determined that the instruction is not a BEGIN AIG then the instruction is executed and it is next determined whether the instruction is the last instruction of the AIG. The preferred embodiment uses the decoding of an END AIG instruction to indicate that the last instruction of an AIG has been reached. If the last instruction of the AIG has been reached then the processor enters MILLICODE MODE the AIG is committed to memory and the processor exits the AIG MODE of operation and then exits the MILLICODE MODE . If there is a failure then special handlers are invoked . The actions of the special handlers for transaction failure may vary depending on the architecture of the system using the invention. Many methods of dealing with transaction failures have been described in the prior art any of them could be used for this purpose. The possible methods include retrying the transaction from the beginning for a set number of attempts waiting for the condition that caused the failure to change calling specialized software routines to resolve conflicts among threads etc. These possible failure handlers may require the rollback of the AIG which caused the failure . If no failure was detected then it is determined whether the load or store was the last instruction of the AIG . If the instruction is the last instruction in the AIG then the AIG is committed using the process described in . The processor then exits the AIG Mode and continues with the next sequential instruction after the AIG .

The decoding of instruction other than loads and stores inside of an AIG does not necessarily require special processing . If the instruction is not a load or store type instruction then it is determined whether the instruction is another BEGIN AIG . Nested AIG instructions require special handling . The prior art contains many different ways of handling nested transactions. The current invention can be used to support any of them. The nested AIG handler for the preferred embodiment adds the instructions of the inner AIG to the outer AIG creating a single larger AIG. Other embodiments of the invention may provide different rules of processing for loads and stores that are part an inner nested transaction as well as special rules for the commitment and failure handling of inner nested transactions. If it is determined that the instruction is not a BEGIN AIG then the instruction is executed and it is next determined whether the instruction is the last instruction of the AIG. The preferred embodiment uses the decoding of an END AIG instruction to indicate that the last instruction of an AIG has been reached. If the last instruction of the AIG has been reached then the AIG is committed to memory and the processor exits the AIG MODE of operation .

The invention provides assist hardware that enables millicode to be invoked for quickly for certain cases as illustrated by .

Turning to it will be seen that the current invention uses an Address History Table that is part of a multithreaded microprocessor that has been designed for support of transactional memory and which uses millicode for the execution of complex instructions. The preferred embodiment uses a microprocessor that supports simultaneous multithreading SMT but other forms of multithreading such as hardware multithreading HMT may be used. The microprocessor in the preferred embodiment supports 4 simultaneous threads. Entries in the AHT are written by the load store units over new interfaces that carry command control address and data information. Command and control information may also be written into the AHT from the Instruction Execution Pipelines . The contents of the AHT may be copied or moved to the General Purpose Registers of the microprocessor over the new interface provided for that purpose. The contents may also be copied or moved to the Millicode Registers via the Millicode Assist Setup Logic over the interfaces provided . The Millicode Registers are used by millicode instructions during the execution of millicode. The Millicode Assist Setup Logic provides the ability to move the contents of the AHT to positions in the millicode registers that are well suited to fast execution using the native hardware instructions of the microprocessor. The Millicode Assist Setup Logic may also shift and or increment the contents of the AHT to provide additional speed of execution when running the millicode routines required to support transactional memory. The microprocessor also contains new state registers for indication of when the microprocessor enters MILLICODE MODE and AIG MODE . These states may be set or reset using the interfaces provided . The traditional use of the millicode mode state register as part of the control logic of a millicoded microprocessor is well known. The millicode assist setup logic of the current invention uses control information from the Instruction Execution Pipelines and AHT via the interfaces provided to anticipate when the microprocessor will enter millimode for the execution of millicode instructions that are used to support transactional memory operations. This early indication allows for the early setup of the millicode registers and quick execution of the required code.

The current invention uses the new AIG MODE state to limit the millicode hardware setup for loads and stores to just the minimal requirements for the executions of loads and stores while AIG MODE is active. Traditional millicoded microprocessors perform a wide variety of hardware setup steps when moving from normal execution mode to MILLICODE MODE. These setup steps may require dozens of microprocessor clock cycles in some cases. One object of the current invention is focused on reducing this overhead for the common case of setup for the execution of loads and stores while the AIG MODE is active.

The PowerPC architecture uses Special Purpose Registers SPRs for many purposes related to storing machine state in a microprocessor. The Address History Table of the current invention stores state information related to currently active AIGs. The pseudo code in uses the SPR naming convention when referencing the AHT. The pseudo code uses the PowerPC style of referencing General Purpose Registers i.e. R4. The current invention uses millicode that implements the same function using millicode registers. The setting of the PTRAN bit or bits associated with each load and store inside of an AIG is shown in the pseudo code example with the terms write the correct bit .

The loading of registers and shifting of contents are examples of functions that the current invention performs using the millicode assist setup logic . The invention allows these operations to be done in by specialized hardware in parallel with the traditional millicode setup operations that are used to move the microprocessor from the normal state to the millicode active state. The use of hardware assists for simple functions and millicode for more complex functions allows the invention to provide a balance of speed and flexibility when implementing the complex operations required for the support of a transactional memory programming environment.

The flow diagrams and code depicted herein are just examples. There may be many variations to these diagrams or the steps or operations described therein without departing from the spirit of the invention. For instance the steps may be performed in a differing order or steps may be added deleted or modified. All of these variations are considered a part of the claimed invention.

While the preferred embodiment to the invention has been described it will be understood that those skilled in the art both now and in the future may make various improvements and enhancements which fall within the scope of the claims which follow. These claims should be construed to maintain the proper protection for the invention first described.

