---

title: Conversion of contiguous interleaved image data for CPU readback
abstract: A method, system, and computer-readable storage medium are disclosed for conversion of contiguous interleaved image data. Image data in a contiguous interleaved format is received at a graphics processing unit (GPU). The GPU generates converted image data in a tiled format based on the image data in the contiguous interleaved format. The GPU sends the converted image data in the tiled format to a central processing unit (CPU).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08810587&OS=08810587&RS=08810587
owner: Adobe Systems Incorporated
number: 08810587
owner_city: San Jose
owner_country: US
publication_date: 20120731
---
This application claims benefit of priority of U.S. Provisional Application Ser. No. 61 606 216 entitled Conversion of Contiguous Interleaved Image Data for CPU Readback filed Mar. 2 2012 the content of which is incorporated by reference herein in its entirety.

A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by any one of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records but otherwise reserves all copyright rights whatsoever.

The present invention is directed to computer systems and more particularly it is directed to digital image processing.

As the complexity of digital imaging increases graphics operations are increasingly being performed using dedicated graphics rendering devices referred to as graphics processing units GPUs . As used herein the terms graphics processing unit and graphics processor are used interchangeably. GPUs are often used in removable graphics cards that are coupled to a motherboard via a standardized bus e.g. AGP or PCI Express . GPUs may also be used in game consoles and in integrated graphics solutions e.g. for use in some portable computers and lower cost desktop computers . Although GPUs vary in their capabilities they may typically be used to perform such tasks as rendering of two dimensional 2D graphical data rendering of three dimensional 3D graphical data accelerated rendering of graphical user interface GUI display elements and digital video playback. A GPU may implement one or more application programming interfaces APIs that permit programmers to invoke the functionality of the GPU.

A GPU may include various built in and configurable structures for rendering digital images to an imaging device. Digital images may include raster graphics vector graphics or a combination thereof. Raster graphics data also referred to herein as bitmaps may be stored and manipulated as a grid of individual picture elements called pixels. A bitmap may be characterized by its width and height in pixels and also by the number of bits per pixel. Commonly a color bitmap defined in the RGB red green blue color space may comprise between one and eight bits per pixel for each of the red green and blue channels. An alpha channel may be used to store additional data such as per pixel transparency values. Vector graphics data may be stored and manipulated as one or more geometric objects built with geometric primitives. The geometric primitives e.g. points lines polygons B zier curves and text characters may be based upon mathematical equations to represent parts of digital images.

Digital image processing is the process of analyzing and or modifying digital images using a computing device e.g. a computer system. Using specialized software programs digital images may be manipulated and transformed in a variety of ways. Programs used for manipulating and transforming digital images may be referred to as image processing programs or image editing programs. It is desirable for image editing programs to access and store digital image data in an efficient manner.

Various embodiments of systems methods and computer readable storage media for conversion of contiguous interleaved image data are disclosed. Image data in a contiguous interleaved format may be received at a graphics processing unit GPU . The GPU may generate converted image data in a tiled format based on the image data in the contiguous interleaved format. The tiled format may be readable by an image editing program running on a central processing unit CPU .

To convert the image data the GPU may execute a shader program such as a pixel shader. The output of the shader may comprise a plurality of tiles representing a rearrangement of the RGBA image data from the original image data in the contiguous interleaved format. In one embodiment the tiled format comprises a tiled planar format. In one embodiment the tiled format comprises a tiled interleaved format.

The converted image data in the tiled format may be sent from the GPU to the CPU. In one embodiment a readback operation may be used to transfer the converted image data from the GPU to the CPU. The converted image data may be stored in a memory managed by the CPU. An image editing program on the CPU may read the converted image data in the tiled format.

While the invention is described herein by way of example for several embodiments and illustrative drawings those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed but on the contrary the intention is to cover all modifications equivalents and alternatives falling within the spirit and scope of the present invention. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description. As used throughout this application the word may is used in a permissive sense i.e. meaning having the potential to rather than the mandatory sense i.e. meaning must . Similarly the words include including and includes mean including but not limited to. 

In the following detailed description numerous specific details are set forth to provide a thorough understanding of claimed subject matter. However it will be understood by those skilled in the art that claimed subject matter may be practiced without these specific details. In other instances methods apparatuses or systems that would be known by one of ordinary skill have not been described in detail so as not to obscure claimed subject matter.

Some portions of the detailed description which follow are presented in terms of algorithms or symbolic representations of operations on binary digital signals stored within a memory of a specific apparatus or special purpose computing device or platform. In the context of this particular specification the term specific apparatus or the like includes a general purpose computer once it is programmed to perform particular functions pursuant to instructions from program software. Algorithmic descriptions or symbolic representations are examples of techniques used by those of ordinary skill in the signal processing or related arts to convey the substance of their work to others skilled in the art. An algorithm is here and is generally considered to be a self consistent sequence of operations or similar signal processing leading to a desired result. In this context operations or processing involve physical manipulation of physical quantities. Typically although not necessarily such quantities may take the form of electrical or magnetic signals capable of being stored transferred combined compared or otherwise manipulated. It has proven convenient at times principally for reasons of common usage to refer to such signals as bits data values elements symbols characters terms numbers numerals or the like. It should be understood however that all of these or similar terms are to be associated with appropriate physical quantities and are merely convenient labels. Unless specifically stated otherwise as apparent from the following discussion it is appreciated that throughout this specification discussions utilizing terms such as processing computing calculating determining or the like refer to actions or processes of a specific apparatus such as a special purpose computer or a similar special purpose electronic computing device. In the context of this specification therefore a special purpose computer or a similar special purpose electronic computing device is capable of manipulating or transforming signals typically represented as physical electronic or magnetic quantities within memories registers or other information storage devices transmission devices or display devices of the special purpose computer or similar special purpose electronic computing device.

Embodiments of the systems and methods described herein may be used to perform a conversion of image data from a contiguous interleaved format using a GPU. is a block diagram illustrating constituent elements of a computer system that is configured to implement embodiments of the systems and methods described herein. The computer system may include one or more processors implemented using any desired architecture or chip set such as the SPARC architecture an x86 compatible architecture from Intel Corporation or Advanced Micro Devices or an other architecture or chipset capable of processing data. Any desired operating system s may be run on the computer system such as various versions of Unix Linux Windows from Microsoft Corporation MacOS from Apple Inc. or any other operating system that enables the operation of software on a hardware platform. The processor s may be coupled to one or more of the other illustrated components such as a memory by at least one communications bus.

In one embodiment a specialized graphics card or other graphics component may be coupled to the processor s . The graphics component may include a graphics processing unit GPU which in some embodiments may be used to perform at least a portion of the techniques described below. Additionally the computer system may include one or more imaging devices . The one or more imaging devices may include various types of raster based imaging devices such as monitors and printers. In one embodiment one or more display devices may be coupled to the graphics component for display of data provided by the graphics component .

In one embodiment program instructions that may be executable by the processor s to implement aspects of the techniques described herein may be partly or fully resident within the memory at the computer system at any point in time. The memory may be implemented using any appropriate medium such as any of various types of ROM or RAM e.g. DRAM SDRAM RDRAM SRAM etc. or combinations thereof. The program instructions may also be stored on a storage device accessible from the processor s . Any of a variety of storage devices may be used to store the program instructions in different embodiments including any desired type of persistent and or volatile storage devices such as individual disks disk arrays optical devices e.g. CD ROMs CD RW drives DVD ROMs DVD RW drives flash memory devices various types of RAM holographic storage etc. The storage may be coupled to the processor s through one or more storage or I O interfaces. In some embodiments the program instructions may be provided to the computer system via any suitable computer readable storage medium including the memory and storage devices described above.

The computer system may also include one or more additional I O interfaces such as interfaces for one or more user input devices . In addition the computer system may include one or more network interfaces providing access to a network. It should be noted that one or more components of the computer system may be located remotely and accessed via the network. The program instructions may be implemented in various embodiments using any desired programming language scripting language or combination of programming languages and or scripting languages e.g. C C C Java Perl etc. The computer system may also include numerous elements not shown in as illustrated by the ellipsis.

The GPU may include a host interface configured to communicate with a data source e.g. a communications bus and or processor s of a host computer system or the host system itself . For example the data source may provide input data e.g. artwork comprising one or more geometric objects and or executable program code to the GPU . In some embodiments the host interface may permit the movement of data in both directions between the GPU and the data source . The GPU may also include a display interface for providing output data to a data target . For example the data target may comprise a display device and the GPU along with other graphics components and or interfaces may drive the display by providing graphics data at a particular rate from a screen buffer e.g. the image buffer .

In one embodiment the GPU may include internal memory . The GPU memory also referred to herein as video memory or VRAM may comprise random access memory RAM which is accessible to other GPU components. As will be described in greater detail below the GPU memory may be used in some embodiments to store various types of data and instructions such as input data output data intermediate data program instructions for performing various tasks etc. In one embodiment the GPU may also be configured to access memory of a host computer system via the host interface . In one embodiment program instructions may be stored in the memory of the host computer system and executed by the host computer system to generate rendered output based on artwork input .

In one embodiment the GPU may include GPU program code that is executable by the GPU to perform aspects of the techniques discussed herein. Elements of the GPU program code may be provided to the GPU by a host computer system e.g. the data source and or native to the GPU . In one embodiment the GPU program code may comprise a vertex shader . A vertex shader comprises program instructions that are executable by the GPU to determine properties e.g. position of a particular vertex. A vertex shader may expect input such as uniform variables e.g. constant values for each invocation of the vertex shader and vertex attributes e.g. per vertex data . In one embodiment the GPU program code may comprise a pixel shader . A pixel shader comprises program instructions that are executable by the GPU to determine properties e.g. color of a particular pixel. A pixel shader may also be referred to as a fragment shader. A pixel shader may expect input such as uniform variables e.g. constant values for each invocation of the pixel shader and pixel attributes e.g. per pixel data . In generating the rendered output both the vertex shader and the pixel shader may be executed at various points in the graphics pipeline.

The GPU memory may comprise one or more buffers and each buffer may comprise a two dimensional array of pixel data e.g. color values and or pixel metadata e.g. depth values stencil values etc. . As illustrated in for example the GPU memory may comprise an image buffer . The image buffer may store intermediate or final pixel values generated in the rendering process. In one embodiment the image buffer may comprise a single sampling buffer wherein each pixel in the buffer is represented by a single set of color and alpha values e.g. one color value for a red channel one color value for a green channel one color value for a blue channel and appropriate values for a one or more alpha channels . In one embodiment the image buffer may comprise a multi sampling buffer usable for anti aliasing.

In one embodiment module may also obtain user input . For example the user input may include one or more instructions to perform an image editing operation which requires write access to a tiled planar array. As another example the user input may include one or more instructions to perform an image editing operation which requires read or write access to image data in a tiled format. In various embodiments such image editing operations may be initiated by user input by automatic operation of the image processing module itself i.e. the operation may be initiated in response to the execution of program instructions and without direct user input or by one or more instructions received by the image processing module from another module. The user input may be obtained using any suitable user input hardware .

An image reading module may be used to read the image input from storage e.g. from secondary storage such as storage . An image editing module may be used to perform the one or more image editing operations on the image input . An image writing module may be used to write the edited image e.g. to secondary storage such as storage . In one embodiment the process performed by the image reading module may be performed automatically and or programmatically. In one embodiment the process performed by the image editing module may be performed automatically and or programmatically. In one embodiment the process performed by the image writing module may be performed automatically and or programmatically. The module may produce an edited image as output.

Image processing module may be implemented as or in a stand alone application or as a module of or plug in for an image processing image editing and or image presentation application. Examples of types of applications in which embodiments of module may be implemented may include but are not limited to image editing processing and or presentation applications as well as applications in security or defense educational scientific medical publishing digital photography digital films games animation marketing and or other applications in which digital video image editing or presentation may be performed e.g. where operations are to be directed to different layers of images. Specific examples of applications in which embodiments may be implemented include but are not limited to Adobe Photoshop and Adobe Illustrator . In addition to generating output image module may be used to display manipulate modify and or store the output images for example to a memory medium such as a storage device or storage medium.

In one embodiment the image writing module may write pixels to tiled planar arrays. As used herein the term tiled means that the image is stored as a plurality of separate fixed size sub rectangles of pixels rather than a single large rectangle of pixels. For example an image of 300 by 400 pixels might be stored in twelve tiles of 100 by 100 pixels each. Typically an individual tile represents a piece of a larger image upon which an image editing program operates e.g. displays and or edits at a point in time. In one embodiment the image editing program may not subdivide the tiles. In one embodiment only the tiles representing the portion of the image currently being processed need be present in main memory and other tiles may be stored on secondary e.g. disk storage. Tiles for which all pixels have the same value may be stored in a compact special representation which includes one instance of the single shared value. Multiple images which contain identical pixel values in a particular area may share tiles. In one embodiment if one of the images which share tiles is to be modified a separate copy may first be made of each tile in the area to be modified so that the other images are not also modified.

Because of the above characteristics the image editing program may perform an operation referred to as lock for write before accessing the pixels of an image e.g. using the image reading module . In conjunction with the writing of data to a portion of memory by one entity a lock for write operation may disallow access to the portion of memory by other entities. Accordingly the use of a lock for write operation may prevent problems potentially resulting from concurrent access of multiple entities to the portion of memory. However the lock for write operation is potentially expensive and may involve multiple steps. For example for each area of pixels to be accessed the program must ensure that the tiles containing those pixels are copied from secondary storage to main memory if necessary that the tiles stay in main memory for the duration of the operation that single value tiles are changed from their compact representation to the normal representation and that a copy is made if the tile is shared and it is to be modified. The result of the lock for write operation on a tile is the location within main memory where data can be written into that tile. When the process of writing data to the pixels of a tile is complete the tile may be unlocked. The unlocking operation may be relatively inexpensive compared to the lock for write operation.

In a planar representation e.g. as shown in at least four separate tiles should be locked for write for each area within the image to be modified because the RGBA data is distributed among the separate tiles. In a non planar representation e.g. as shown in only one tile should be locked for write for each pixel to be modified. Therefore the use of the planar approach may present additional computational expense when an image editing program accesses the pixels of an image. Accordingly systems and methods are described as follows for efficient writing of pixels to tiled planar pixel arrays.

In a typical approach for processing a buffer of pixels and copying the result into a set of planar tiles an image editing program may perform the following operations in sequence. For each area corresponding to a tile within the image containing pixels to be modified the program may lock for write the red tile lock for write the green tile lock for write the blue tile and lock for write the alpha tile. The program may then perform the desired image processing operation. The program may copy the results of the image processing operation into one or more of the locked tiles. Finally the program may unlock the red green blue and alpha tiles. In the typical approach all of these operations may be performed in sequence.

As described herein systems and methods for writing pixels to tiled planar arrays may provide one or more performance enhancing modifications to the typical approach described above. The various performance enhancing modifications may be used separately or together. In one embodiment lock for write operations are performed in parallel with the image processing operation. In one embodiment the results of an image processing operation are copied to multiple tiles in parallel. In one embodiment if all of the pixels within a tile are to be modified the conversion from the compact special representation may be avoided and tiles may shared with other images may not be copied first.

Most modern computer processors have multiple processor cores each of which can perform an independent sequence of operations. In order to utilize most of the processing capacity of multiple processors and or multiple cores multiple sequences of operations may be performed in parallel. In some configurations parallelism may be applied to the copying of data as well as to computation. Accordingly the systems and methods described herein may use multiple separate threads of execution i.e. sequences of operations that may be performed concurrently by separate processors or processor cores. The multiple threads may use any suitable method for sending and receiving values between them. In one embodiment the threads may be designated as a first thread a second thread and one or more other threads. The number of other threads may be determined using any suitable basis such as by measuring performance or by using a library that chooses the number of threads. All of the threads may operate simultaneously and a thread may wait only when it cannot take further action without receiving information from another thread.

As shown in a first thread may be used to perform an image editing operation on an area of an image wherein the image comprises a plurality of tiles within the area. The first thread may coordinate or supervise the image editing operation including any necessary lock for write operations. In one embodiment the first thread may perform the following operations. The first thread may send to the second thread a description of the image pixels to be modified. The first thread may perform the image processing operation possibly by coordinating the actions of unrelated threads. For example the unrelated threads may apply various graphics processing or editing operations to image data. For each tile within the image containing pixels to be modified the first thread may receive from the second thread the result of a lock for write operation. For each tile within the image containing pixels to be modified the first thread may also send to one of the other threads the result of the lock for write operation and a pointer to the image processing results that should be copied to that tile.

As shown in a second thread may be used to perform a lock for write operation on one or more of the plurality of tiles. As shown in the second thread may be used to send results of the lock for write operations to the first thread . In one embodiment the second thread may perform the following operations. The second thread may receive from the first thread a description of the image pixels to be modified. In one embodiment based on this description the second thread may determine which tiles are to be locked for write. For each area corresponding to a tile within an RGBA image containing pixels to be modified the second thread may perform a lock for write operation on the red tile green tile blue tile and alpha tile. The second thread may send to the first thread the results of the lock for write operations. The result of each lock for write operation may include a memory location at which data can be written. In a further embodiment a plurality of second threads may perform these operations rather than one second thread.

As shown in the first thread may be used to send the output of the image editing operation to one or more third threads . The one or more third threads may receive the output of the image editing operation sent from the first thread . As shown in the one or more third threads may be used to store the output of the image editing operation in the plurality of tiles . Any suitable number of other threads may be used. In one embodiment for example each tile to be modified may be associated with a corresponding one of the other threads . In one embodiment each of the other threads may perform the following operations. The other thread may receive from the first thread the result of a lock for write operation and a pointer to the image processing results that should be copied to that tile. The other thread may copy the data from the image processing result to the tile. The other thread may then unlock the tile. The unlocking operation may result in reclaiming the memory used by the tile and copying the tile back to secondary storage e.g. disk . The unlocking operation may also make the unlocked tile available for writing by another image editing operation. In one embodiment a virtual memory system may track whether the tiles are in primary storage or secondary storage.

In one embodiment if all of the pixels within a tile are to be modified additional performance enhancements may be achieved. For example if the entirety of a tile is to be overwritten completely then the original contents of the tile may be ignored. In this manner the conversion from the compact special representation may be avoided to enhance performance. Similarly the process of making a copy of a shared tile may be avoided since the original contents of the shared tile are irrelevant to the outcome of the image editing operation. A new tile may be generated in memory instead. After the image editing operation is performed on the newly generated tile the tile may no longer be shared as it was before the operation.

When image editing operations are sought to be performed in real time e.g. such that the displayed image can be updated quickly efficient use of computing resources and memory bandwidth is key. CPUs e.g. processor s may be used to coordinate the use of computing and input output I O resources including GPU resources. To maintain maximum memory bandwidth on modern CPUs memory may be threaded across multiple cores of the CPU s . In one embodiment efficient use of the GPU may include providing the GPU with image data in an RGBA interleaved format in sufficiently large tiles e.g. 2 k by 2 k pixels . However an image editing program may require image data to be stored in a tiled planar format. Accordingly the RGBA interleaved data used by a GPU may be converted e.g. for use by an image editing program using the systems and methods described herein.

Discrete GPUs typically offer a much larger memory bandwidth than that of modern CPUs and fusion processors integrating both CPU and GPU functionality also tend to dedicate more memory bandwidth to the GPU than to the CPU. Accordingly the GPU may be leveraged to format the data on the GPU in a format that is efficient for the CPU. The considerations for the format may include cache coherency ease of treading and avoidance of gathered reads and scattered writes. Image editing programs may benefit in terms of storage costs and computing costs from storing pixel data in a tiled planar format. Tiles may represent the smallest amount of pixel data that can be atomically accessed from storage by an image editing program. When the image is stored in RGBA channels one or more of the channels in a tile may be constant e.g. the alpha channel or user mask . In such an instance the image editing program may avoid writing the entire tile to disk by noting that the tile representing the constant channel can be represented by a single constant value. Typically the tile size may represent the smallest level of interruption to service a user s request i.e. moving a slider . Therefore a deep document with many layers potentially has to composite a large amount of data to offer up a single update for the area represented by a tile. This often forces small tile sizes in practice which both underutilize the CPU and GPU. Meeting the maximum bandwidth potential during memory moves with CPUs may demand the source and destination to be cache line friendly and thus the format returned by the GPU may place the data for one tile in a contiguous stream possibly aligned to a cache line. Even when reading back single channel data from the GPU to the CPU it may be efficient to format the data into an RGBA texture because device drivers are typically optimized for RGBA textures. The reformatting into RGBA data may also allow for the maximal amount of data to be contained in one texture given that all textures may be constrained to the same size e.g. grayscale data may be limited to the same maximum size constraints of RGBA and thus the RGBA texture can contain more information .

As shown in image data in a contiguous interleaved format may be received at a graphics processing unit GPU . The image data in the contiguous interleaved format may be stored as a texture in a memory managed by the GPU. As shown in the image data may be converted to a tiled format from the contiguous interleaved format. In one embodiment the tiled format comprises a tiled planar format. In one embodiment the tiled format comprises a tiled interleaved format. The tiled format may be readable by an image editing program running on a central processing unit CPU . To convert the image data the GPU may execute a shader program such as a pixel shader. The output of the shader may comprise a plurality of tiles representing a rearrangement of the RGBA image data from the original image data in the contiguous interleaved format. RGBA data may be mapped from particular locations in the original image data in the contiguous interleaved format to particular locations in the converted image data in the tiled format.

As shown in the converted image data in the tiled format may be sent from the GPU to the CPU. Any suitable techniques may be used for sending the image data in the tiled format from the GPU to the CPU. In one embodiment a readback operation may be used to transfer the converted image data from the GPU to the CPU. The converted image data may be stored in a memory managed by the CPU. An image editing program on the CPU may read the converted image data in the tiled format.

For a tiled planar image format the image data may be de interleaved upon readback from the GPU to an interleaved contiguous buffer in memory managed by the CPU. The de interleaving process may include for each destination tile geometry intersected with a given rectangle performing a lock for write operation on each of the red green blue and alpha tiles. The de interleaving process may then de interleave the image data from the returned buffer into the planar tiles. Non cache coherent memory fetches and scattered writes may take place at this stage. illustrates an example of program code for de interleaving image data from the returned buffer into the planar tiles according to one embodiment.

For a tiled interleaved image format memory move operations may be performed upon readback from the GPU to an interleaved contiguous buffer in memory managed by the CPU. For each destination tile geometry intersected with a given rectangle a lock for write operation may be performed on the destination tile and a memory move operation may be performed from the returned buffer into the tile. Non cache coherent memory fetches may take place at this stage.

In one embodiment a pixel shader on the GPU may be used to convert pixel data from an RGBA interleaved contiguous texture to a format appropriate for a CPU based tiling system. The pixel shader may be given descriptions of the destination tiled image in order to reorder the data into an efficient format for use on the CPU. The description data may include the starting origin in the destination tile the destination tile size and the width and height of the source image. In one embodiment one pixel shader program may be used to handle conversion to a planar tiled format and another pixel shader program may be used to handle conversion to an interleaved tile format. The planar conversion process may write into an RGBA texture in order to maximize the volume of data that can be processed in parallel.

In one embodiment the GPU may be used to convert pixel data from an RGBA interleaved contiguous texture to a tiled planar format. The conversion may be performed before readback from the GPU to an interleaved contiguous buffer e.g. in a buffer managed by the CPU . A contiguous interleaved to planar tiled pixel shader may be engaged to perform the conversion. The pixel shader may be implemented using any suitable techniques or languages. In one embodiment for example the pixel shader may be implemented using OpenGL Shading Language GLSL . The pixel shader may render a quad which converts the data in interleaved RGBA format to a planar tiled set of streams encoded in an RGBA texture. A readback operation may then be performed on the texture to transfer the image data from the GPU to memory managed by the CPU. For each destination tile geometry intersected with a given rectangle a lock for write operation may then be performed on each of the red green blue and alpha tiles. A memmove or blockmove operation may be performed to transfer the image data from the returned buffer into the planar tiles typically using one thread per tile.

In one embodiment the GPU may be used to convert pixel data from an RGBA interleaved contiguous texture to a tiled interleaved format. The conversion may be performed before readback from the GPU to an interleaved contiguous buffer e.g. in memory managed by the CPU . A contiguous interleaved to tiled stream interleaved pixel shader may be engaged to perform the conversion. The pixel shader may be implemented using any suitable techniques or languages. In one embodiment for example the pixel shader may be implemented using OpenGL Shading Language GLSL . The pixel shader may render a quad which prompts the GPU to converts the data in interleaved RGBA format to an interleaved tiled set of streams encoded in an RGBA texture. A readback operation may then be performed on the texture to transfer the image data from the GPU to a buffer managed by the CPU. For each destination tile geometry intersected with a given rectangle a lock for write operation may then be performed on the destination tile. A memmove or blockmove operation may be performed to transfer the image data from the returned buffer into the tiles typically using one thread per tile.

Although the embodiments above have been described in detail numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications.

