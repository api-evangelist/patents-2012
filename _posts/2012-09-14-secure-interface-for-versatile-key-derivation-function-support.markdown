---

title: Secure interface for versatile key derivation function support
abstract: Improper re-use of a static Diffie-Hellman (DH) private key may leak information about the key. The leakage is prevented by a key derivation function (KDF), but standards do not agree on key derivation functions. The module for performing a DH private key operation must somehow support multiple different KDF standards. The present invention provides an intermediate approach that neither attempts to implement all possible KDF operations, nor provide unprotected access to the raw DH private key operation. Instead, the module performs parts of the KDF operation, as indicated by the application using the module. This saves the module from implementing the entire KDF for each KDF needed. Instead, the module implements only re-usable parts that are common to most KDFs. Furthermore, when new KDFs are required, the module may be able to support them if they built on the parts that the module has implemented.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08634562&OS=08634562&RS=08634562
owner: Certicom Corp.
number: 08634562
owner_city: Mississauga, Ontario
owner_country: CA
publication_date: 20120914
---
This application claims priority from PCT Application No. PCT IB2004 003705 filed Nov. 11 2004 and U.S. Provisional Patent Application No. 60 626 921 filed Nov. 12 2004.

The invention relates generally to the field of cryptography. In particular the invention relates to providing versatile key derivation function support.

Diffie Hellman DH key agreement is a fundamental development in cryptography. It is the first workable method of public key cryptography that made key distribution feasible without setting up pre arranged secrets.

In the simplest form of the DH key agreement each party has a respective private key x y from which a public key respectively can be derived. By exchanging public keys each party can compute a shared secret key by combining the private and public keys. The function used to derive a public key from a private key is a one way function that makes computation of the public key relatively simple but renders it infeasible to extract the private key from the public key. Such a function is based on the difficulty of factoring large numbers which are the product of two large primes or the discrete log problem over finite fields.

Diffie Hellman DH key agreement is in wide use today. The IPSec protocol uses DH key agreement and IPSec is used in most Virtual Private Networks VPNs that most corporations use for allowing employees to connect remotely to the corporate network as well as for connecting separate offices over the open Internet.

Diffie Hellman key agreement is also a NIST recommended option in the Transport Layer Security TLS protocol. The TLS protocol is the successor to the SSL protocol. These protocols are used widely today for securing sensitive web traffic such as online banking.

Static DH key agreement is a variant of DH key agreement in which one of the private keys is static which means that it is a long term key to be used multiple times.

Because of the sensitivity of the private key particularly where it is used multiple times it is usually located in a private key module which is an implementation that includes the private key operation. Generally such modules include measures to prevent extraction of the private key and to a much more limited extent abuse of the private key operation. For example these modules can be implemented in specialized hardware that does not admit the loading of malicious software such as viruses worms and Trojan horses. Generally such anti tampering measures are expensive to implement. Therefore to reduce costs modules are generally designed with a minimum functionality. That way the least amount of functionality needs anti tampering protection.

By way of a simple example a module may be a smart card. The smart card is owned by a user. Suppose that the user wishes to make a secure connection to a destination such as a home computer from some remote computer. The user enters the smart card into a smart card reader attached to the remote computer. Then a connection is made to the home computer. The home computer authenticates the user by sending a challenge. The remote computer forwards the challenge to the smart card. The smart card signs the challenge which is then forwarded back to the home computer. The home computer verifies the challenge and then provides the necessary access to the user via the remote computer. This allows the user to move around to different remote computers. The remote computers however should not be able to extract the user s private key from the smart card. That is they should only be able to connect to the home computer while the user leaves the smart card in the reader. For this to be achieved a more sophisticated method than simple challenge and response is needed. Instead the smart card may need to perform regular authentication of traffic or even encryption and decryption of all of the traffic. 

To enhance security further a key derivation function KDF which is a one way function applied to the raw DH shared secret is often specified. Some standards specify that a KDF is to be used with DH key agreement. Different standards recommend different KDFs however. For example ANSI specifies several different KDFs as does IEEE as do SSL and TLS and different yet again is IPSec.

The following provides a simplified description of the details behind two standardized key derivation functions. These are the ANSI X9.63 key derivation and the TLS key derivation functions.

The ANSI X9.63 key derivation is computed as follows. The input has three components. The first input component is Z which is a secret value shared between the private key module and the destination for example the home computer in the simple example above. This shared secret value Z is not to be revealed to any gateway such as the remote computer in the example above. The second input component is an integer key datalen which is the length in octets of the keying data to be generated. The optional third input component is an octet string SharedInfo which consists of some data shared by the entities who share the shared secret value Z. Furthermore SharedInfo can also optionally be given an encoding of the Abstract Syntax Notation One ASN.1 which includes 5 fields an algorithm identifier optional identifiers for each of the two entities optional public shared information and optional private shared information. Evaluation of the KDF on this input then proceeds as follows.

The first steps of the ANSI X9.63 key derivation function are certain consistency checks made on the lengths of the inputs and the desired output length keydatalen. Then a 4 octet integer counter j is initialised with value 1. A series of hash values Kj are computed as follows Kj SHA 1 Z j SharedInfo where indicates concatenation and indicates that the bracketed input is optional. The number t of these outputs depends on keydatalen. The hash values are concatenated to form a octet string K K K . . . Kt. The octet string is truncated to a shorted octet string K by taking the leftmost keydatalen octets. The output of the ANSI X9.63 KDF is K.

In the TLS standard key derivation functions are called pseudorandom functions PRF . The construction of the TLS PRF is quite different from the ANSI X9.63 KDF and is given as follows. The construction makes use of an auxiliary construction HMAC which is described first.

The HMAC construction can be built on any hash function. When the HMAC construction is used with a hash function such as MD5 and SHA 1 then the resulting function is labelled HMAC Hash where Hash is the name of the hash function. The TLS PRF uses HMAC SHA 1 and HMAC MD5. The generic form of HMAC namely HMAC Hash operates as follows.

The inputs to HMAC are a secret key K and a message M. The output is a tag T. The HMAC tag is computed as T Hash C K Hash D K M where indicates concatenation indicates the well known bit wise exclusive or XOR operation and C and D are constant bit strings as determined by the HMAC algorithm. More precisely the key K is padded with zero bits until its length matches that of C and D except if K is longer than C and D in which case K is replaced with the hash of the key. This is written as HMAC Hash .

The function HMAC Hash is used in another auxiliary hash generic construction in TLS PRF called P Hash. The construction for P Hash is as follows  Hash seed HMAC Hash 1 seed HMAC Hash 2 seed HMAC Hash 3 seed . . . where indicates concatentation and A is defined as follows 0 seed HMAC Hash 1 .

P Hash can be iterated as many times as necessary to produce the necessary amount of data As with the ANSI X9.63 the truncation of the final rightmost bytes is used when the resulting concatenation of HMAC tags is longer than the amount of data needed.

The TLS PRF is defined as follows PRF label seed  MD5 1 label seed  SHA 1 2 label seed where as usual indicates exclusive or and indicates concatenation. The values S and S are obtained by partitioning the octet string secret Z into two halves the left half being S and right half S with the left half being large secret has an odd number of octets.

Because the MD5 outputs as specified by the algorithm are 16 octets while the SHA 1 outputs are 20 octets the function P MD5 will generally use more iterations than P SHA 1.

The TLS PRF is used extensively in the TLS protocol. For example it is used to derive a master secret from a pre master secret and it is also used to derive an encryption key from the master key and so on.

The disharmony between standards on KDF creates a large incentive to module implementers either to support DH key agreement without the KDF or to support just a limited number of KDFs.

The standard Public Key Cryptography Standard PKCS 11 Cryptographic Token Interface cryptoki addresses an interface for tokens such as smart cards which are a class of private key modules. In this standard a few KDFs are supported but the interface provided are generally not KDF flexible. The standard FIPS 140 2 also specifies requirement for private key modules. It explicitly requires that the cryptographic values such as raw DH shared secret values do not depart the security boundary of the private key module but it does not provide a precise mechanism for key derivation.

The inventors have discovered that improper re use of a static DH private key can ultimately result in recovery of the private key by an adversary. More precisely when a shared secret established via static DH key agreement is used without application of a key derivation function KDF an adversary can launch an attack where multiple different shared keys are established and used thereby recovering the static DH private key.

The inventors recent discovery means that the option of implementing DH without KDF can be a security risk. Supporting a reduced number of KDF s may be too limiting for example it may require hardware upgrade just to use a new application standard.

As standards do not agree on key derivation functions the module for performing a DH private key operation must somehow support multiple different KDF standards. One approach is for the module to implement all the KDF algorithms which can be expensive because the module must support multiple different KDFs and limiting because the module cannot support new KDFs when these arise. The opposite approach is for the module to provide unprotected access to the raw DH private key operation and let the application using the module apply the KDF. However this renders the private key vulnerable to the recently discovered attacks.

In general terms the present invention permits the module to perform parts of the KDF algorithms as indicated by the application using the module. This saves the module from implementing the entire KDF for each KDF needed. Instead only re usable parts are implemented that are common to most KDFs. Furthermore when new KDFs are required the module may be able to support them if they are built on the KDF parts that the module has implemented.

In this manner raw access to the static DH private key operation is not permitted on the module because this generally tends to be too much of a security risk. Instead the module provides an interface flexible enough to support all existing KDFs of interest as well as all foreseeable KDFs. This is done by implementing the common parts of the existing and foreseeable KDFs on a secure private key module Most KDFs today are built on hash functions. Conveniently most private key modules need to implement at least a hash function. This is also important for anti tampering considerations because a hash function is crucial to the security of many algorithms such as digital signatures.

As an alternate to this the module can also simply provide access to the compression function of SHA 1. The application can use this compression function to compute SHA 1 just by adding some necessary padding and doing some appropriate chaining. This further simplifies the implementation module and also makes it more flexible. For example some additional flexibility is that certain ANSI deterministic random number generators use the SHA 1 compression function instead of the whole of the function SHA 1. More generally random number generation like key derivation generally involves a combination of hash function evaluations upon a mixture of secret and non secret inputs. Therefore the present invention is not just limited to supporting multiple KDFs it can also support multiple deterministic random number generators.

For even greater flexibility the module could support more atomic operations such as some of the sub operations of the SHA 1 compression function. However it does not seem likely that these sub operations will be re used for some purpose other than the SHA 1 compression function. Also these individual sub operations do not provide the full security of SHA 1 and may therefore expose secrets on the module to the application which is to be avoided. An exception to this principle however are the two pairs of new hash functions the pair SHA 384 and SHA 512 and the pair SHA 224 and SHA 256. Each of these pairs has much in common and could essentially be implemented with a single common function. The application would process the inputs and outputs only to the common function to obtain the desired hash function.

In the case of the TLS key derivation known as pseudo random function PRF in TLS terminology two hash functions are used. One is SHA 1 and the other is MD5. To apply the PRF TLS to a secret Z the secret is split into two halves S and S. Then a PRF based on MD5 is applied to S and a function based on SHA1 is applied to S. To save the module from implementing both MD5 and SHA1 which is potentially costly the module could instead provide a mechanism to reveal S to the application and keep S within the module. The module could perform the SHA1 calculation on S and the application could perform the MD5 calculation on S.

Although it is not anticipated that any other KDF than the one in TLS will divide up secrets in such a manner it tends to be difficult to predict which way standards will go. Therefore it may be useful for a module to support a generic method of dividing up a secret. The interface for the module therefore includes a mechanism whereby the application can request that part of a secret is made public. The module is implemented in a way such that enough of the secret remains secret and that the application cannot make multiple request for different parts of the secret.

Because new standards keep arising and because standards keep re designing KDFs and random number generators a flexible and secure interface to a hardware module provides considerable value for extending the usability of the module. Otherwise the module risks becoming obsolete too quickly.

In one aspect a method of computing a cryptographic function involving a shared secret is provided the shared secret being accessible to a first module. The method comprises the steps of performing on the first module at least one operation of the cryptographic function utilizing the shared secret and providing a result of the at least one operation to an application running on a second module to complete computation of the cryptographic function.

In another aspect a cryptographic apparatus is provided comprising a first module having a shared secret and a processor to perform at least one cryptographic operation using the shared secret and produce a result therefrom a second module running an application to compute a cryptographic function and a data connection between the first and second modules to transfer the result from the first module to the second module to enable the second module to complete computation of the cryptographic function using the result.

The description which follows and the embodiments described therein are provided by way of illustration of an example or examples of particular embodiments of the principles of the present invention. These examples are provided for the purposes of explanation and not limitation of those principles and of the invention. In the description which follows like parts are marked throughout the specification and the drawings with the same respective reference numerals.

Referring to there is shown a connection between a user device and a destination secured with a private key module device . The connection between user device and destination is generally not secure and is open. For example the connection may consist of a link to a public network such as Internet and a link from the public network to destination . Either link may be a wired link wireless link or a combination of both. In general private key module device is a self contained device such as a smart card or token which may be inserted into some local device or user device on which the application runs. The module device cooperates with the user device when invoked by an application to secure a communication over the link .

In this mode of operation the private key module device provides a private key functionality to secure the connection between user device and the destination device . However since private key module device is a custom private key module it would need some additional protection beyond that of a typical user computer like user device such as anti tampering protection. Implementing a key derivation function KDF partly in an application running on user device and partly in a module executing on private key module device enhances the security. It will be appreciated that although user device and private key module device are described as distinct devices here they may be integrated into a single physical device. For example private key module device may reside on user device as a special embedded chipset.

The user device typically will run multiple applications and perform different functions utilizing a CPU and memory device . The user device includes a communication module to manage the link under direction of a communication application running on the CPU . To establish a secure communication the communication application implements an established secure protocol such as one of those discussed above that requires a private key functionality such as a KDF. To facilitate computation of a selected KDF whilst maintaining flexibility the KDF derivation is separated into discreet subroutines and those that require operation on a private key are performed by the private key module . The balance are performed by the user device so that the raw private key data is not accessible through the user device .

Referring to there is shown an exemplary implementation of a security system that has a key derivation function KDF implemented partly in an application running on the user device and partly in an application running on a private key module . The KDF is divided into two parts. Private key module generates components of the KDF and application uses those components to compute the balance of the KDF. Private key module has a module interface for exchanging data and communicating with application . Module interface further has two interface functions a first interface function and a second interface function .

Advantageously some secret value such as a Diffie Hellman shared secret value Z are determined in private key module . The length of Z is made known to application but the value of Z is not. Application has a handle whereby it can reference the secret Z and thus ask private key module to derive values from Z.

The first interface function has input consisting of an integer and the handle of secret Z. This integer defines the number of octets of Z that shall be revealed to application . This is the S value in the TLS PRF. When executing this function private key module can enforce a minimum number of octets of the secret to be retained as S so that application does not learn the entire secret. The minimum number is chosen to be appropriate for the intended security level of the application. It may be 10 octets for a security level of 80 bits. Once first interface function is called the secret may be permanently truncated to S and private key module will not allow further truncation of S. A handle or pointer for referencing S is provided to application . Preferably the handle or pointer referencing Z may be re used as Z is not used in further computation. Henceforth private key module sets the secret Z S after first interface function is called. Optionally private key module can create a new handle that points to just S and output this new handle to application enabling application to refer to S later on. The value S is always part of the output of first interface function so that application i.e. first part of the KDF contained in application can perform any calculations it needs to on S such as the MD5 calculations used in the TLS PRF.

The second interface function has input consisting of two values X and Y and the handle of the secret Z. The first value is an octet string of length identical to the secret Z. The output of second interface function is SHA 1 .

Second interface function is the fundamental cryptographic operation from which both the ANSI X9.63 KDF and the TLS PRF can be built. From the output S of first interface function and the output of second interface function namely the hash value of SHA 1 application can complete the KDF computation and derive a key.

User device generally has a CPU memory device accessible to CPU storage media also accessible to CPU and some input and output devices not shown . As will be appreciated user device may also be some other programmable computation device. Application executes on CPU . Application may be stored on storage media which may be permanently installed in user device removable from user device or remotely accessible to user device . Application may also be directly loaded to CPU . Output of the KDF is required for securing the connection from user device to destination .

Private key module device generally has a CPU or a microprocessor memory device accessible to CPU and storage media also accessible to CPU . Private key module executes on CPU . Private key module may be stored on storage media or directly loaded to memory device . Private key module may store the secret private key in its memory device or its storage media . As will be appreciated private key module may also have input means such as a keyboard where private key module device is a smart card with keyboard for users to enter a secret private key.

While the distinction is made here that there are memory device which tends to be used for storing more volatile data and storage media which tends to be used to store more persistent data private key module device may have only a single data storage device for storing both volatile and persistent data. Similarly user device may have only a single data storage device for storing both volatile and persistent data.

Data link provides a communication channel between application and private key module when needed. Data link may be wired or wireless. It may be a direct connection between user device and private key module device . The data link may be permanent or more preferably a connection that is established on demand. In general data link is not an open link but instead is a protected link.

As noted above private key module does not implement an entire KDF. Components of the KDF generated in private key module implements only those re usable portions and only the part that performs the cryptographic operations that are fundamental to security. This promotes flexibility without compromising security. When implementing a DH protocol for example raw access to the static DH private key operation is not permitted on the module. Instead the module provides an interface flexible enough to support all existing KDFs of interest as well as all foreseeable KDFs. One way to do this most efficiently is to implement the common parts of the existing and foreseeable KDFs. Most KDFs today are built on hash functions although it is also foreseeable that some in the future will be built from block ciphers. Most private key modules ought to support at least a hash function because a hash function is crucial to the security of many algorithms such as digital signatures. Fortunately fewer hash functions are standardized than KDFs. For example the hash function SHA 1 can be re used to support several different KDFs such as the distinct ANSI IPSec and TLS key derivation functions. The TLS key derivation also uses another hash function MD5 but this can be handled outside of the module as explained further below.

Referring to for KDFs that are generated using SHA 1 operations the application instructs the private key module what input to supply as the input to the hash function. Some of the input is a secret and unknown to the application. To specify this the application refers to such secret input via a handle or pointer . Public input may be provided directly by the application . Formatting of the input which is custom to each KDF is specified by generic formatting interface provided by the module. The hash outputs that private key module provides to the application may be re used by the application as further inputs to more hash function calls. This is because many KDFs are based on a chaining mechanism where the output of one hash call is fed into the input of another hash call.

The operation in support of the ANSI X9.63 KDF and TLS PRF ANSI X9.63 KDF derives a key from a shared secret value by computing a series of hash values computed from hash function SHA 1 based on the shared secret value and then truncating an octet string formed from the concatenation of the hash values while TLS PRF has a much more complicated construction involving the computation of both hash function MD5 and hash function SHA 1.

A goal of the module interface is to not implement the hash function MD5. Only the hash function SHA 1 is implemented on private key module namely on the second part of the KDF. The application using private key module is therefore responsible for implementing MD5 in its first part of the KDF. From a security perspective this may not present a significant drawback. This is because the MD5 hash function is not universally considered to provide adequate security whereas the SHA 1 hash function tends to be universally accepted to provide adequate security for the purposes of key derivation for all but the highest security levels these higher levels require the use of SHA 256 or another successor to SHA 1 .

The operation in support of ANSI X9.63 KDF is generally shown in . In such operation application chooses X 0 and Y j SharedInfo where j is the 4 octet counter that the application maintains. Application may then call function with X Y and the handle for Z. The application of the private key module may then use the values for X and Y and the handle for Z supplied by application to compute the SHA 1 according to the expression described above and shown in . The application may then obtain the computed SHA 1 value and use this for building the ANSI X9.63 KDF and deriving a key.

The operation of applications and in support of the TLS PRF is shown in . The application calls the first interface function in order to divide the shared secret Z into two halves S and S part of and described above regarding function . The application then calls the second interface function to compute a hash value based on S part of and then uses the construction above to compute P SHA 1 from the outputs of the first and second interface functions part of . Parts and are explained below.

To build the function HMAC SHA 1 used in part of the TLS PRF operation shown in application first calls second interface function with X D and Y M and the handle for key K which gives T SHA 1 D K M . The value of D is a publicly known constant so is available to application . Then application sets X C and Y T with the same handle for K to get T SHA 1 C K T HMAC SHA K M . The value of C is public like D. 

If the key K needs to be padded with zero bits then application will account for this by prepending the second input Y with the necessary zero bits as XORed with the appropriate octets of the constant C and D. If the key K is long enough to require compression first then application can do this by setting X 0 and Y 0 to get the hashed key. In this case application may be optionally able to perform the rest of the computation on its own because it has all the information necessary or it may be use yet a third interface feature to designate the above hash output as another secret with a new handle.

To build the function P SHA 1 in part of the operation supporting TLS PRF shown in the application now uses S provided as an output in part and the construction above for computing HMAC SHA 1 where the secret key is confined to private key module . This involves computing A A A using iterated applications of HMAC SHA 1 which are then used in turn to form the output of P SHA 1 by further application of HMAC SHA 1.

The example above assumes that the keys derived in private key module are delivered as output to application . An alternative to this is the keys derived remain within private key module and the outputs are just handles or pointers to the said keys. An advantage of this is that all keys can be retained on private key module which gives the module holder greater assurance that application cannot abuse even the derived session keys let alone the long term private keys.

In an alternative embodiment private key module has an even greater degree of flexibility. Private key module supports some simple execution language such as javascript or java which enables a vast generality of operations to be performed on the card. In other words application supplies a program to private key module which private key module then executes. The program while in the module can access secrets freely. For security private key module ensures all outputs from the module go though approved secure algorithms such as a hash algorithm like SHA 1 or as part of symmetric encryption operation like ABS. This prevents most abuses that a malicious program could attempt.

To further enhance security private key module may require that the program be digitally signed by a signer whose public verification key has already been securely loaded onto private key module . This is one way to authenticate the program loaded into private key module . Program authentication ensures that the program is not a malicious executable with the objective of compromising the module s secrets. With program authentication it is not as necessary to restrict the module output to certain hashes or other algorithms because program itself is trustworthy enough to perform any algorithm.

The advantages of this alternative embodiment over the first embodiment are that it offers greater flexibility such as allowing a variety of hashes both existing and new to be executed on the module. The disadvantage is that the module needs to support a general execution language and possibly a portion of a public key infrastructure.

It will be appreciated that although the above examples are provided in the context of key derivation functions the principles outlined herein are applicable to other cryptographic functions such as random number generators.

Various embodiments of the invention have now been described in detail. Those skilled in the art will appreciate that numerous modifications adaptations and variations may be made to the embodiments without departing from the scope of the invention. Since changes in and or additions to the above described best mode may be made without departing from the nature spirit or scope of the invention the invention is not to be limited to those details but only by the appended claims.

